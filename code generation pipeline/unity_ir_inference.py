#!/usr/bin/env python3
"""
Unity IR Inference with Code Leak Steering

Generates natural language Unity behavior JSON from descriptions.
Uses the attractor steering system to detect and correct code leaks.

Usage:
    # Single generation
    python unity_ir_inference.py "rotating coin that gives points when collected"
    
    # Interactive mode
    python unity_ir_inference.py --interactive
    
    # With custom steering intensity
    python unity_ir_inference.py "enemy AI" --intensity 0.7
    
    # Batch processing
    python unity_ir_inference.py --batch prompts.txt --output results/
    
    # Skip steering (raw generation)
    python unity_ir_inference.py "player jump" --no-steering

As module:
    from unity_ir_inference import UnityIRGenerator
    
    generator = UnityIRGenerator()
    result = generator.generate("player that jumps with space")
    print(result.json_output)
"""

import json
import requests
import sys
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
import argparse

# Try to import json_repair for robust JSON fixing (pip install json-repair)
try:
    from json_repair import repair_json
    HAS_JSON_REPAIR = True
except ImportError:
    HAS_JSON_REPAIR = False
    
# Try json5 as fallback - more lenient parser (pip install json5)
try:
    import json5
    HAS_JSON5 = True
except ImportError:
    HAS_JSON5 = False

# ============================================================================
# IMPORTS FROM MODIFIED PIPELINE
# ============================================================================

from attractor_steering import (
    load_steering,
    AttractorSteering,
    DetectionResult,
    build_natural_language_prompt,
)
from attractor_mapper import (
    detect_code_markers,
    CODE_LEAK_PATTERNS,
)

# ============================================================================
# CONFIGURATION
# ============================================================================

# LLM endpoint (OpenAI-compatible API)
LLM_URL = "http://localhost:1234/v1/chat/completions"
LLM_MODEL = "local-model"

# Steering config (generated by pipeline)
import os
FILTER_CONFIG_DIR = os.path.join(os.path.dirname(__file__), "unity_ir_filter_configs")
MODEL_NAME = "local-model-unity-ir"

# Defaults
DEFAULT_INTENSITY = 0.5
MAX_REGENERATION_ATTEMPTS = 3
DEFAULT_TEMPERATURE = 0.7
DEFAULT_MAX_TOKENS = 4096  # Increased to allow for longer responses

# ============================================================================
# SYSTEM PROMPT
# ============================================================================

UNITY_IR_SYSTEM_PROMPT = """You are a Unity behavior specification generator. Output structured JSON describing game object behaviors.

STRUCTURE:
{
  "class_name": "BehaviorName",
  "components": ["Component1", "Component2"],
  "fields": [{"name": "fieldName", "type": "fieldType", "default": value}],
  "behaviors": [{
    "name": "behavior_name",
    "trigger": "what activates this behavior",
    "actions": [
      {"action": "action description", "temporal": "event" | "continuous" | "conditional", ...}
    ]
  }],
  "state_machine": {
    "has_state_machine": true/false,
    "initial_state": "state_name",
    "states": [...]
  }
}

TEMPORAL ACTION CLASSIFICATION (CRITICAL):
Every action has inherent temporal semantics. Classify actions by execution frequency:

EVENT ACTIONS (execute once when triggered):
- Audio: "play audio clip", "play sound effect"
- Instantiation: "spawn prefab", "create object", "destroy object"
- State changes: "set color", "set material", "enable component", "disable component"
- Particle effects: "play particle effect", "stop particle effect"
- Animation triggers: "play animation", "set animation trigger"
- Physics impulses: "apply impulse", "add explosion force"
- UI updates: "show UI", "hide UI", "set text"
- Game events: "trigger event", "send message"
- One-time calculations: "calculate path", "find nearest"

CONTINUOUS ACTIONS (execute every frame while trigger is active):
- Movement: "move toward", "move away from", "orbit around", "follow path"
- Rotation: "rotate toward", "look at", "rotate continuously"
- Physics forces: "apply force", "apply torque" (continuous force modes)
- Tracking: "track target", "aim at"
- Distance checks: "check distance to", "maintain distance from"
- Lerping: "lerp to position", "smooth rotation"
- Procedural animation: "bob up and down", "sway"

CONDITIONAL ACTIONS (check once per frame, then branch):
- Queries: "if X exists", "if distance >", "if health <"
- These trigger EVENT or CONTINUOUS actions based on conditions

BEHAVIOR STRUCTURE:
Each action MUST have a "temporal" field indicating execution frequency:
- "event": Execute once when behavior triggers
- "continuous": Execute every frame while behavior is active
- "conditional": Check condition, then trigger event/continuous based on result

DEFAULTS (if temporal not specified, infer from action type):
- Audio/visual/spawning/destruction → "event"
- Movement/rotation/tracking → "continuous"
- If action has a trigger condition → "conditional"

RULES:
1. Use proper Unity types for fields: AudioClip, GameObject, Material, Sprite, Transform, float, int, bool, string
2. Component names are exact Unity class names: Rigidbody, AudioSource, Collider, etc.
3. Actions use simple verb phrases: "play audio", "apply force", "set position", "spawn prefab"
4. NO code syntax: no operators (+,-,*), no API calls (Vector3.up), no functions (distance())
5. ALWAYS include "temporal" field for each action: "event", "continuous", or "conditional"
6. For state machines, actions within states also need temporal classification
7. Transitions define state changes with clear conditions

Example - Simple Pickup (trigger-based):
{
  "class_name": "HealthPickup",
  "components": ["Collider", "AudioSource"],
  "fields": [
    {"name": "healAmount", "type": "int", "default": 25},
    {"name": "pickupSound", "type": "AudioClip", "default": null}
  ],
  "behaviors": [{
    "name": "on_pickup",
    "trigger": "collision with player",
    "actions": [
      {"action": "play audio clip", "target": "pickupSound", "temporal": "event"},
      {"action": "heal player", "value": "healAmount", "temporal": "event"},
      {"action": "destroy this object", "temporal": "event"}
    ]
  }],
  "state_machine": {"has_state_machine": false}
}

Example - Projectile (mixed temporal):
{
  "class_name": "Projectile",
  "components": ["Rigidbody"],
  "fields": [
    {"name": "speed", "type": "float", "default": 20.0},
    {"name": "shotSound", "type": "AudioClip", "default": null}
  ],
  "behaviors": [{
    "name": "on_fire",
    "trigger": "when fired",
    "actions": [
      {"action": "play audio clip", "target": "shotSound", "temporal": "event"},
      {"action": "spawn particle trail", "temporal": "event"},
      {"action": "move forward", "speed": 20, "temporal": "continuous"}
    ]
  }],
  "state_machine": {"has_state_machine": false}
}

Example - Enemy Chaser (continuous behavior):
{
  "class_name": "EnemyChaser",
  "components": ["Rigidbody"],
  "fields": [
    {"name": "chaseTarget", "type": "GameObject", "default": null},
    {"name": "moveSpeed", "type": "float", "default": 5.0}
  ],
  "behaviors": [{
    "name": "chase_player",
    "trigger": "when chaseTarget exists",
    "actions": [
      {"action": "move toward chaseTarget", "speed": "moveSpeed", "temporal": "continuous"},
      {"action": "rotate to face chaseTarget", "temporal": "continuous"}
    ]
  }],
  "state_machine": {"has_state_machine": false}
}

Example - State Machine:
{
  "class_name": "EnemyAI",
  "components": ["Rigidbody", "Animator", "AudioSource"],
  "fields": [
    {"name": "player", "type": "GameObject", "default": null},
    {"name": "detectionRange", "type": "float", "default": 10.0},
    {"name": "attackRange", "type": "float", "default": 2.0},
    {"name": "moveSpeed", "type": "float", "default": 5.0}
  ],
  "behaviors": [],
  "state_machine": {
    "has_state_machine": true,
    "initial_state": "patrol",
    "states": [
      {
        "name": "patrol",
        "actions": [
          {"action": "set animation trigger", "trigger": "Patrol", "temporal": "event"},
          {"action": "move along patrol path", "temporal": "continuous"},
          {"action": "check distance to player", "temporal": "conditional"}
        ],
        "transitions": [
          {"to": "chase", "condition": "player distance < detectionRange"}
        ]
      },
      {
        "name": "chase",
        "actions": [
          {"action": "play audio clip", "target": "chaseSound", "temporal": "event"},
          {"action": "set animation trigger", "trigger": "Chase", "temporal": "event"},
          {"action": "move toward player", "speed": "moveSpeed", "temporal": "continuous"},
          {"action": "face player direction", "temporal": "continuous"}
        ],
        "transitions": [
          {"to": "attack", "condition": "player distance < attackRange"},
          {"to": "patrol", "condition": "player distance > detectionRange"}
        ]
      },
      {
        "name": "attack",
        "actions": [
          {"action": "play audio clip", "target": "attackSound", "temporal": "event"},
          {"action": "set animation trigger", "trigger": "Attack", "temporal": "event"},
          {"action": "deal damage to player", "temporal": "event"}
        ],
        "transitions": [
          {"to": "chase", "condition": "player distance > attackRange"},
          {"to": "patrol", "condition": "player distance > detectionRange"}
        ]
      }
    ]
  }
}

Output ONLY valid JSON. No markdown, no code, no explanations."""

# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class GenerationResult:
    """Result of Unity IR generation"""
    success: bool
    json_output: Optional[str] = None
    parsed: Optional[Dict] = None
    prompt: str = ""
    
    # Steering metadata
    was_steered: bool = False
    attempts: int = 1
    original_output: Optional[str] = None
    
    # Detection results (initial and final)
    initial_detection: Optional[DetectionResult] = None
    final_detection: Optional[DetectionResult] = None
    
    # Errors
    error: Optional[str] = None
    
    @property
    def detection_result(self) -> Optional[DetectionResult]:
        """Backward compatibility: returns final detection"""
        return self.final_detection
    
    def __str__(self) -> str:
        if not self.success:
            return f"GenerationResult(success=False, error={self.error})"
        
        status = "steered" if self.was_steered else "clean"
        # Show what was initially triggered
        initial_triggered = self.initial_detection.triggered_attractors if self.initial_detection else []
        
        return f"GenerationResult(success=True, status={status}, attempts={self.attempts}, triggered={initial_triggered})"

# ============================================================================
# LLM INTERFACE
# ============================================================================

def call_llm(
    system_prompt: str,
    user_prompt: str,
    temperature: float = DEFAULT_TEMPERATURE,
    max_tokens: int = DEFAULT_MAX_TOKENS,
) -> Optional[str]:
    """Call local LLM and return response text"""
    try:
        response = requests.post(
            LLM_URL,
            json={
                "model": LLM_MODEL,
                "messages": [
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                "temperature": temperature,
                "max_tokens": max_tokens
            },
            timeout=240
        )
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"].strip()
    except Exception as e:
        print(f"LLM call failed: {e}")
        return None


def extract_json_from_response(response: str) -> Tuple[Optional[str], Optional[Dict]]:
    """
    Extract and parse JSON from LLM response.
    
    Uses json-repair library if available, falls back to json5, then regex fixes.
    """
    # Find JSON content (in markdown block or raw)
    json_str = response
    
    # Extract from markdown if present
    match = re.search(r'```(?:json)?\s*([\s\S]*?)\s*```', response)
    if match:
        json_str = match.group(1)
    else:
        # Find raw JSON object
        match = re.search(r'\{[\s\S]*\}', response)
        if match:
            json_str = match.group(0)
        else:
            # Try incomplete JSON
            match = re.search(r'\{[\s\S]*', response)
            if match:
                json_str = match.group(0)
    
    # Method 1: Direct parse (fastest)
    try:
        return json_str, json.loads(json_str)
    except json.JSONDecodeError:
        pass
    
    # Method 2: json-repair library (best quality)
    if HAS_JSON_REPAIR:
        try:
            repaired = repair_json(json_str, return_objects=False)
            parsed = json.loads(repaired)
            # Re-serialize with pretty formatting
            return json.dumps(parsed, indent=2), parsed
        except Exception:
            pass
    
    # Method 3: json5 (handles comments, trailing commas, unquoted keys)
    if HAS_JSON5:
        try:
            parsed = json5.loads(json_str)
            # Re-serialize to clean JSON
            clean_json = json.dumps(parsed, indent=2)
            return clean_json, parsed
        except Exception:
            pass
    
    # Method 4: Manual regex fixes (fallback)
    fixed = try_fix_json(json_str)
    if fixed:
        try:
            return fixed, json.loads(fixed)
        except json.JSONDecodeError:
            pass
    
    return None, None


def try_fix_json(json_str: str) -> Optional[str]:
    """
    Manual JSON repair using regex.
    
    This is the fallback when json-repair and json5 are not available.
    It handles common LLM JSON errors but is not comprehensive.
    """
    # Remove comments
    json_str = re.sub(r'//[^\n]*', '', json_str)
    json_str = re.sub(r'/\*[\s\S]*?\*/', '', json_str)
    
    # Fix structural issues
    json_str = re.sub(r',\s*([\]}])', r'\1', json_str)  # trailing commas
    json_str = re.sub(r'}\s*\n\s*{', '},\n{', json_str)  # missing commas between objects
    json_str = re.sub(r'}\s*{', '}, {', json_str)
    
    # Quote unquoted values (common LLM error: putting code expressions as bare values)
    # This is a best-effort fix - json-repair does this much better
    json_str = re.sub(r':\s*(\([^)]+\))', r': "\1"', json_str)
    json_str = re.sub(r':\s*([a-zA-Z_][a-zA-Z0-9_.]*\.[a-zA-Z0-9_.]+)(\s*[,}\]])', r': "\1"\2', json_str)
    json_str = re.sub(r':\s*([a-zA-Z_][a-zA-Z0-9_.]*\s*[\+\-\*\/]\s*[^,}\]]+?)(\s*[,}\]])', r': "\1"\2', json_str)
    
    # Balance braces for truncated JSON
    open_braces = json_str.count('{') - json_str.count('}')
    open_brackets = json_str.count('[') - json_str.count(']')
    
    if open_braces > 0 or open_brackets > 0:
        # Trim trailing incomplete parts
        json_str = re.sub(r',\s*"[^"]*"\s*:\s*$', '', json_str)
        json_str = re.sub(r',\s*"[^"]*$', '', json_str)
        json_str = re.sub(r':\s*"[^"]*$', ': null', json_str)
        json_str = re.sub(r':\s*$', ': null', json_str)
        
        # Recount and close
        open_braces = json_str.count('{') - json_str.count('}')
        open_brackets = json_str.count('[') - json_str.count(']')
        json_str += ']' * max(0, open_brackets)
        json_str += '}' * max(0, open_braces)
    
    return json_str

# ============================================================================
# GENERATOR CLASS
# ============================================================================

class UnityIRGenerator:
    """
    Generates Unity IR JSON with code leak steering.
    
    Uses the attractor steering system to detect and correct
    programming syntax that leaks into natural language fields.
    """
    
    def __init__(
        self,
        model_name: str = MODEL_NAME,
        config_dir: str = FILTER_CONFIG_DIR,
        intensity: float = DEFAULT_INTENSITY,
        use_steering: bool = True,
        verbose: bool = False
    ):
        self.model_name = model_name
        self.intensity = intensity
        self.use_steering = use_steering
        self.verbose = verbose
        self.steering: Optional[AttractorSteering] = None
        
        if use_steering:
            try:
                self.steering = load_steering(model_name, config_dir)
                if verbose:
                    n_attractors = len(self.steering.config.attractors)
                    baselines = "enabled" if self.steering.config.baselines_enabled else "disabled"
                    print(f"Loaded steering: {n_attractors} attractors, baselines {baselines}")
            except FileNotFoundError:
                print(f"Warning: No steering config at {config_dir}/{model_name}/")
                print("Run pipeline first to generate configs, or use --no-steering")
    
    def generate(
        self,
        behavior_description: str,
        temperature: float = DEFAULT_TEMPERATURE,
        max_attempts: int = MAX_REGENERATION_ATTEMPTS
    ) -> GenerationResult:
        """Generate Unity IR JSON from behavior description"""
        
        result = GenerationResult(success=False, prompt=behavior_description)
        
        if self.verbose:
            print(f"Generating: {behavior_description}")
        
        # Initial generation
        response = call_llm(UNITY_IR_SYSTEM_PROMPT, behavior_description, temperature)
        
        if response is None:
            result.error = "LLM call failed"
            return result
        
        json_str, parsed = extract_json_from_response(response)
        
        if json_str is None:
            result.error = "Failed to extract valid JSON"
            result.original_output = response
            if self.verbose:
                print(f"  Raw response ({len(response)} chars): {response[:200]}...")
            return result
        
        # Validate that parsed result is a dict, not a list
        if parsed is not None and not isinstance(parsed, dict):
            result.error = f"IR generation returned invalid structure: expected dict, got {type(parsed).__name__}"
            result.original_output = json_str
            if self.verbose:
                print(f"  Error: {result.error}")
                if isinstance(parsed, list) and len(parsed) > 0:
                    print(f"  Got list with {len(parsed)} items, first item: {parsed[0]}")
            return result
        
        result.original_output = json_str
        
        # Unified attractor detection
        if self.steering:
            detection = self.steering.detect_unified(
                text=json_str,
                parsed_json=parsed,
                prompt=behavior_description,
                intensity=self.intensity,
                use_embeddings=True
            )
            result.initial_detection = detection
            result.final_detection = detection  # Will be updated if steering occurs
            
            if self.verbose:
                print(f"  Detection: {detection.summary()}")
            
            # Correction loop if attracted
            if detection.is_attracted:
                result.was_steered = True
                corrected_json, corrected_parsed, attempts, final_detection = self._correction_loop(
                    json_str, parsed, behavior_description, detection, max_attempts, temperature
                )
                json_str = corrected_json
                parsed = corrected_parsed
                result.attempts = attempts
                result.final_detection = final_detection
        
        result.success = True
        result.json_output = json_str
        result.parsed = parsed
        
        return result
    
    def _correction_loop(
        self,
        json_str: str,
        parsed: Dict,
        prompt: str,
        initial_detection: DetectionResult,
        max_attempts: int,
        temperature: float
    ) -> Tuple[str, Dict, int, DetectionResult]:
        """Run correction loop until output is clean or max attempts reached
        
        Returns:
            Tuple of (json_str, parsed_dict, attempts, final_detection)
        """
        
        current_json = json_str
        current_parsed = parsed
        current_detection = initial_detection
        
        for attempt in range(max_attempts):
            # Generate correction with progressively lower temperature
            # Start at 0.2, decrease each attempt to make LLM more conservative
            correction_temp = max(0.05, 0.2 - (attempt * 0.05))
            
            if self.verbose:
                print(f"  Correction attempt {attempt + 1} (temp={correction_temp:.2f})...")
            
            # Build correction prompt based on what was triggered
            system_prompt, user_prompt = self._build_correction_prompt(
                current_json, current_detection
            )
            
            corrected_response = call_llm(
                system_prompt,
                user_prompt,
                temperature=correction_temp
            )
            
            if corrected_response is None:
                continue
            
            new_json, new_parsed = extract_json_from_response(corrected_response)
            
            if new_json is None:
                continue
            
            # Validate structure: must be a dict, not a list
            if not isinstance(new_parsed, dict):
                if self.verbose:
                    print(f"    Result: Invalid structure (got {type(new_parsed).__name__}, expected dict)")
                continue
            
            # Re-detect
            new_detection = self.steering.detect_unified(
                text=new_json,
                parsed_json=new_parsed,
                prompt=prompt,
                intensity=self.intensity,
                use_embeddings=True
            )
            
            if self.verbose:
                print(f"    Result: {new_detection.summary()}")
            
            # Keep if improved
            if not new_detection.is_attracted:
                return new_json, new_parsed, attempt + 2, new_detection
            
            # Update for next iteration if better
            if len(new_detection.triggered_attractors) < len(current_detection.triggered_attractors):
                current_json = new_json
                current_parsed = new_parsed
                current_detection = new_detection
        
        return current_json, current_parsed, max_attempts + 1, current_detection
    
    def _build_correction_prompt(
        self,
        json_str: str,
        detection: DetectionResult
    ) -> Tuple[str, str]:
        """Build correction prompt based on detection results"""
        
        issues = []
        
        # Always report flagged patterns, even if below threshold
        if detection.flagged_keywords:
            issues.append(f"Code syntax detected: {', '.join(detection.flagged_keywords)}")
        
        if detection.structural_cliches_matched:
            issues.append(f"Structural clichés: {', '.join(detection.structural_cliches_matched)}")
        
        if detection.over_engineering_score > 0.3:
            issues.append("Output is over-engineered - simplify structure")
        
        if detection.under_engineering_score > 0.3:
            issues.append("Output is under-engineered - add missing detail")
        
        if detection.baseline_violations:
            issues.append(f"Baseline deviations: {', '.join(detection.baseline_violations[:3])}")
        
        system_prompt = """You fix Unity IR JSON by converting code syntax to natural language.

KEEP THESE KEYS: class_name, components, fields, behaviors
EACH FIELD HAS: name, type, default
EACH BEHAVIOR HAS: name, trigger, condition, actions

RULES:
- Keep the same JSON structure and keys
- Replace code/operators with natural language descriptions
- NO API names, NO operators, NO function calls

Output ONLY the corrected JSON."""
        
        user_prompt = f"""Fix this JSON - convert code to natural language, keep same keys:

{json_str}

FIX: {', '.join(issues) if issues else 'code-like patterns detected'}"""
        
        return system_prompt, user_prompt
    
    def generate_batch(self, descriptions: List[str], temperature: float = DEFAULT_TEMPERATURE) -> List[GenerationResult]:
        """Generate Unity IR for multiple descriptions"""
        results = []
        for i, desc in enumerate(descriptions):
            if self.verbose:
                print(f"\n[{i+1}/{len(descriptions)}] {desc[:50]}...")
            results.append(self.generate(desc, temperature))
        return results

# ============================================================================
# CLI MODES
# ============================================================================

def interactive_mode(generator: UnityIRGenerator):
    """Interactive generation session"""
    print("=" * 60)
    print("UNITY IR GENERATOR - Interactive Mode")
    print("=" * 60)
    
    # Show JSON repair library status
    if HAS_JSON_REPAIR:
        print("✓ json-repair available (robust JSON fixing)")
    elif HAS_JSON5:
        print("✓ json5 available (lenient parsing)")
    else:
        print("⚠ Install json-repair for better JSON handling: pip install json-repair")
    
    print("Enter behavior descriptions. Commands: quit, intensity <0-1>, verbose, quiet")
    print("=" * 60)
    
    while True:
        try:
            prompt = input("\n> ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\nExiting.")
            break
        
        if not prompt:
            continue
        if prompt.lower() == "quit":
            break
        if prompt.lower().startswith("intensity "):
            try:
                generator.intensity = float(prompt.split()[1])
                print(f"Intensity: {generator.intensity}")
            except (ValueError, IndexError):
                print("Usage: intensity <0-1>")
            continue
        if prompt.lower() == "verbose":
            generator.verbose = True
            print("Verbose on")
            continue
        if prompt.lower() == "quiet":
            generator.verbose = False
            print("Verbose off")
            continue
        
        result = generator.generate(prompt)
        
        if result.success:
            print(f"\n{result}")
            print("-" * 40)
            print(result.json_output)
            if result.was_steered:
                print("-" * 40)
                # Show initial vs final comparison
                if result.initial_detection:
                    print(f"Initial: {result.initial_detection.summary()}")
                if result.final_detection:
                    print(f"Final:   {result.final_detection.summary()}")
                # Show what was fixed
                if result.initial_detection and result.final_detection:
                    initial_triggers = set(result.initial_detection.triggered_attractors)
                    final_triggers = set(result.final_detection.triggered_attractors)
                    fixed = initial_triggers - final_triggers
                    if fixed:
                        print(f"Fixed:   {', '.join(fixed)}")
                    remaining = final_triggers
                    if remaining:
                        print(f"Remaining: {', '.join(remaining)}")
        else:
            print(f"\nFailed: {result.error}")
            if result.original_output:
                print("-" * 40)
                print(f"Raw LLM response ({len(result.original_output)} chars):")
                # Show full response for debugging
                print(result.original_output)


def batch_mode(generator: UnityIRGenerator, input_file: str, output_dir: str):
    """Process prompts from file"""
    input_path = Path(input_file)
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    with open(input_path) as f:
        prompts = [l.strip() for l in f if l.strip() and not l.startswith("#")]
    
    print(f"Processing {len(prompts)} prompts...")
    results = generator.generate_batch(prompts)
    
    # Save individual JSONs
    for i, (prompt, result) in enumerate(zip(prompts, results)):
        if result.success and result.parsed:
            safe_name = "".join(c if c.isalnum() else "_" for c in prompt[:40])
            with open(output_path / f"{i:03d}_{safe_name}.json", "w") as f:
                json.dump(result.parsed, f, indent=2)
    
    # Save summary
    summary = {
        "total": len(results),
        "successful": sum(1 for r in results if r.success),
        "steered": sum(1 for r in results if r.was_steered),
        "failed": sum(1 for r in results if not r.success),
        "results": [
            {
                "prompt": r.prompt,
                "success": r.success,
                "steered": r.was_steered,
                "attempts": r.attempts,
                "triggered_attractors": r.detection_result.triggered_attractors if r.detection_result else [],
                "error": r.error
            }
            for r in results
        ]
    }
    
    with open(output_path / "summary.json", "w") as f:
        json.dump(summary, f, indent=2)
    
    print(f"\nSaved to {output_path}/")
    print(f"  Success: {summary['successful']}/{summary['total']}")
    print(f"  Steered: {summary['steered']}")
    print(f"  Failed: {summary['failed']}")

# ============================================================================
# MAIN
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Generate Unity IR JSON from behavior descriptions"
    )
    parser.add_argument("prompt", nargs="?", help="Behavior description")
    parser.add_argument("--interactive", "-i", action="store_true")
    parser.add_argument("--batch", "-b", metavar="FILE")
    parser.add_argument("--output", "-o", default="unity_ir_output")
    parser.add_argument("--intensity", type=float, default=DEFAULT_INTENSITY)
    parser.add_argument("--no-steering", action="store_true")
    parser.add_argument("--verbose", "-v", action="store_true")
    parser.add_argument("--model", default=MODEL_NAME)
    parser.add_argument("--config-dir", default=FILTER_CONFIG_DIR)
    
    args = parser.parse_args()
    
    generator = UnityIRGenerator(
        model_name=args.model,
        config_dir=args.config_dir,
        intensity=args.intensity,
        use_steering=not args.no_steering,
        verbose=args.verbose
    )
    
    if args.interactive:
        interactive_mode(generator)
    elif args.batch:
        batch_mode(generator, args.batch, args.output)
    elif args.prompt:
        result = generator.generate(args.prompt)
        if result.success:
            print(result.json_output)
            if args.verbose:
                print(f"\n---\n{result}", file=sys.stderr)
        else:
            print(f"Error: {result.error}", file=sys.stderr)
            sys.exit(1)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()

