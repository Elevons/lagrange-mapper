[
  {
    "prompt_num": 1,
    "prompt": "Create a script that makes an object spin faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase.",
    "timestamp": "2026-01-07T14:34:43.288070",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpinningExplosion : MonoBehaviour\n{\n    [Header(\"Spin Settings\")]\n    public float startSpd = 10f;         // Initial angular speed (radians per second)\n    public float maxSpd = 100f;          // Maximum spin speed\n    public float spinUpTime = 1.5f;      // Time to reach max speed from start\n\n    [Header(\"Explosion Settings\")]\n    public int explosionCount = 10;\n    public GameObject[] explosionPrefabs;   // Assign in inspector, each has a Rigidbody2D and sound\n    public AudioSource mainAudio;           // For the spinning/louder sound\n    public AudioSource explosionSFX;       // Each explosion prefab has its own\n\n    [Header(\"Visual Settings\")]\n    public Color startMaterialColor = new Color(0.1f, 0.3f, 1f, 1f); // Blue-ish\n    public Color endMaterialColor = new Color(1f, 0f, 0f, 1f);     // Red\n\n    private float currentSpd = startSpd;\n    private float spinTime = 0f;\n    private bool spinning = true;\n\n    private Rigidbody2D rb;       // For explosion objects\n    private int currentExplosion = -1;\n    List<GameObject> explosions = new List<GameObject>();\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        mainAudio.Play();              // Start the spinning/louder sound\n\n        // Set up material color change (use a script for smooth transition if needed)\n        StartCoroutine(MaterialColorTransition());\n\n        // Optionally, play first explosion sound at start\n        // explosionSFX.Play();\n    }\n\n    void Update()\n    {\n        if (!spinning) return;\n\n        spinTime += Time.deltaTime;\n        currentSpd = Mathf.Lerp(startSpd, maxSpd, (spinTime / spinUpTime));\n        \n        if (currentSpd >= maxSpd && spinTime < spinUpTime)\n            currentSpd = maxSpd; // Hold at maximum\n\n        rb.angularVelocity = currentSpd * Vector2.right; // Spin rightward\n\n        // Increase main audio volume over time\n        float t = spinTime / spinUpTime;\n        mainAudio.volume = Mathf.Lerp(0.1f, 1f, t);\n\n        if (spinTime >= spinUpTime)\n        {\n            // Transition to explosion phase\n            StopAllCoroutines();\n            SpinAndExplodeToParts();\n        }\n    }\n\n    void SpinAndExplosionToParts()\n    {\n        spinning = false;\n\n        // Change material color smoothly from blue to red over 0.5 seconds (can use Material instead for real-time)\n        StartCoroutine(MaterialColorEnd());\n\n        // Trigger explosions\n        int i = 0;\n        foreach (var prefab in explosionPrefabs)\n        {\n            GameObject go = Instantiate(prefab, transform.position, Quaternion.identity);\n            go.GetComponent<Collider2D>().isTrigger = true; // For physics bounce\n            go.GetComponent<Rigidbody2D>().useGravity = false;\n\n            go.name = $\"Explosion_{i}\";\n            explosions.Add(go);\n\n            explosionSFX.Play(go); // Assuming each prefab has a local sound or use a public method to assign\n\n            i++;\n        }\n\n        // Optional: Destroy the original after all explosions (or keep for visual effect)\n        // Destroy(gameObject);\n    }\n\n    IEnumerator MaterialColorTransition()\n    {\n        float timer = 0f;\n        while (timer < 0.5f)\n        {\n            if (timer <= 0.25f) // Spin-up phase color change\n                material.color = Vector3.Lerp(startMaterialColor, new Color(0.2f, 0.4f, 0.8f, 1f), timer * 2);\n            else // End phase (approaching red)\n                material.color = Vector3.Lerp(new Color(0.2f, 0.4f, 0.8f, 1f), endMaterialColor, (timer - 0.25f) * 2);\n\n            yield return null;\n            timer += Time.deltaTime / 5; // Smoother transition\n        }\n        material.color = endMaterialColor;\n    }\n\n    void OnTriggerEnter2D(Collider2D other)\n    {\n        // Optional: Detect collision to stop spinning early, but not required per prompt.\n    }\n\n    // Clean up explosion sounds if needed\n    void OnDisable()\n    {\n        foreach (var go in explosions)\n            go.SetActive(false);\n    }\n}",
    "ir_json": {
      "class_name": "AcceleratingSpawner",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "spinSpeed",
          "type": "float",
          "default": 0
        },
        {
          "name": "maxSpinSpeed",
          "type": "float",
          "default": 100
        },
        {
          "name": "material",
          "type": "Transform",
          "default": null
        },
        {
          "name": "colorStart",
          "type": "Vector3",
          "default": [
            0,
            1,
            1
          ]
        },
        {
          "name": "colorEnd",
          "type": "Vector3",
          "default": [
            1,
            0,
            0
          ]
        }
      ],
      "behaviors": [
        {
          "name": "spinAndAccelerate",
          "trigger": "Time increases and spinSpeed < maxSpinSpeed",
          "actions": [
            {
              "name": "apply force",
              "parameters": {
                "direction": "transform.right * spinSpeed"
              }
            },
            {
              "name": "increase spinSpeed",
              "expression": "spinSpeed += 0.1"
            },
            {
              "name": "lerp material color",
              "parameters": {
                "from": "colorStart",
                "to": "colorEnd",
                "amount": "spinSpeed/maxSpinSpeed"
              }
            },
            {
              "name": "play sound",
              "parameters": {
                "volume": "0.05 * (spinSpeed/maxSpinSpeed)"
              }
            }
          ]
        },
        {
          "name": "explodeAtMaxSpeed",
          "trigger": "spinSpeed >= maxSpinSpeed and AudioSource.played == false",
          "actions": [
            {
              "name": "destroy object",
              "target": "self"
            },
            {
              "name": "create children",
              "count": 10
            },
            {
              "name": "for i=0 to 9",
              "actions": [
                {
                  "name": "instantiate object",
                  "parent": "父对象 (self)"
                },
                {
                  "name": "apply random initial velocity",
                  "expression": "(Random.insideUnitSphere * 20).normalized"
                },
                {
                  "name": "set rigidbody mass to 0.3 and add random center of mass offset"
                },
                {
                  "name": "assign a new material with random color in [0,1,0] to [1,0,1]"
                },
                {
                  "name": "attach an AudioSource to each child",
                  "expression": "play unique sound effect (randomly selected from predefined list)"
                }
              ]
            },
            {
              "name": "set parent to null"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class AcceleratingSpawner : MonoBehaviour\n{\n    // IR-specified fields (auto-injected)\n    public Transform material;\n    public Vector3 colorStart = [0, 1, 1];\n    public Vector3 colorEnd = [1, 0, 0];\n\n    [Header(\"Spin Settings\")]\n    public float spinSpeed = 0f;\n    public float maxSpinSpeed = 100f;\n    public Transform materialPoint = null; // Assignable in inspector for visual effect\n\n    [Header(\"Color Animation\")]\n    public Color colorStart = new Color(0f, 1f, 1f);\n    public Color colorEnd = new Color(1f, 0f, 0f);\n\n    [Header(\"AudioSource & Sound Settings\")]\n    public AudioSource audioSource;\n\n    private float lastTime = 0f;\n    private float currentTime = 0f;\n\n    void Start()\n    {\n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null)\n            audioSource = GetComponentInChildren<AudioSource>();\n        if (materialPoint == null)\n            materialPoint = transform; // fallback, can set in inspector\n    }\n\n    void Update()\n    {\n        currentTime += Time.deltaTime;\n        float elapsed = currentTime - lastTime;\n\n        if (spinSpeed < maxSpinSpeed && elapsed > 0.1f) // 0.1 seconds step for smooth acceleration\n        {\n            // Apply rightward force to spin the object\n            Vector3 force = transform.right * spinSpeedf;\n            rigidbody?.AddForce(force, ForceMode.Force);\n\n            // Increment spin speed gradually (accelerate)\n            spinSpeed += 0.1f;\n            SpinAndAccelerate();\n        }\n        lastTime = currentTime;\n\n        // Lerp material color based on normalized spin speed\n        if (materialPoint != null)\n        {\n            float t = Mathf.Clamp01(spinSpeed / maxSpinSpeed);\n            materialPoint.material.color = Color.Lerp(colorStart, colorEnd, t);\n        }\n\n        // Play sound if not already played and within spin range\n        if (!audioSource.isPlaying && spinSpeed > 0f)\n        {\n            float volume = 0.05f * (spinSpeed / maxSpinSpeed);\n            audioSource.PlayOneShot(new AudioClip(\"C:/Path/To/Sound/sfx-spin.wav\") { gain = volume });\n        }\n\n        // Optional: Destroy if over max speed and no more plays\n        // if (spinSpeed >= maxSpinSpeed && !audioSource.isPlaying) ExplodeAndDestroy();\n    }\n\n    void SpinAndAccelerate()\n    {\n        audioSource.PlayOneShot(new AudioClip(\"C:/Path/To/Sound/spin_sound.wav\") { volume = 0.05f * (spinSpeed / maxSpinSpeed) });\n    }\n\n    // Trigger explosion at max spin speed\n    void ExplodeAtMaxSpeed()\n    {\n        if (rigidbody != null)\n            rigidbody.SetIsKinematic(false); // Ensure physics still works during explosion\n\n        Destroy(gameObject);\n\n        int numChildren = 10;\n        for (int i = 0; i < numChildren; i++)\n        {\n            GameObject obj = Instantiate(this.gameObject, transform.position, Quaternion.identity);\n            obj.name = $\"Child_{i}\";\n            if (obj != null)\n            {\n                // Assign random material color between [0,1,0] and [1,0,1]\n                Material mat = new Material(obj.GetComponent<Renderer>().materialMaterial);\n                Vector3 startC = new Vector3(0f, 1f, 0f);\n                Vector3 endC = new Vector3(1f, 0f, 1f);\n                float t = (float)Random.Range(0f, 1f); // Or use spinSpeed/maxSpinSpeed for more control\n                mat.color = Color.Lerp(startC, endC, t);\n\n                // Random initial velocity (within sphere of radius 20)\n                Vector3 randDir = Random.insideUnitSphere * 20f;\n                randDir.Normalize();\n                obj.rigidbody?.AddVelocity(randDir);\n\n                // Add some center of mass offset\n                obj.rigidbody.centerOfMass = new Vector3(Random.Range(-0.2f, 0.2f), 0f, Random.Range(-0.2f, 0.2f));\n\n                // Assign material (if not set)\n                if (mat != null && !mat.isUsed) mat.apply();\n                else\n                {\n                    Renderer rend = obj.GetComponent<Renderer>();\n                    if (rend != null)\n                        rend.material = new Material(rend.materialMaterial);\n                    // Set color as above here if needed\n                }\n\n                // Attach random sound to each child\n                string[] sounds = { \"explosion1\", \"explosion2\" }; // Add more for variety\n                int idx = Random.Range(0, sounds.Length);\n                audioSource = obj.AddComponent<AudioSource>();\n                audioSource.clip = Resources.Load<AudioClip>(\"C:/Path/To/Sounds/\" + sounds[idx]) as AudioClip;\n                audioSource.volume = 0.5f; // Or randomize\n                audioSource.play();\n            }\n        }\n\n        // Optionally set parent to null for children\n        foreach (var child in GetComponentsInChildren<GameObject>())\n        {\n            if (child != this)\n                child.transform.parent = null;\n        }\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 8,
        "api_usage": 9,
        "code_quality": 7,
        "completeness": 8,
        "best_practices": 7,
        "total": 39,
        "justification": "Direct implementation with clear logic, handles spin-up, color transition, and explosion mechanics. Strong use of Unity's coroutine system and lerping. Some minor incomplete edge cases (like partial cleanup)."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 5,
        "code_quality": 5,
        "completeness": 6,
        "best_practices": 4,
        "total": 26,
        "justification": "Generated code shows some structural issues, hard-coded paths, less idiomatic Unity code. More abstract representation but loses specific implementation nuances."
      },
      "winner": "oneshot",
      "key_differences": [
        "Direct implementation vs generated abstraction",
        "More precise Unity API usage in oneshot approach",
        "Better understanding of specific component interactions"
      ],
      "advantages": [
        "More precise control over behavior",
        "Better readability and maintainability",
        "Direct mapping between intent and implementation",
        "Fewer abstraction-related potential runtime issues"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 2,
    "prompt": "Make a gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center, all while rotating the entire gravity well slowly.",
    "timestamp": "2026-01-07T14:36:03.429039",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GravityWell : MonoBehaviour\n{\n    [SerializeField] private float rotationSpeed = 0.02f;\n    [SerializeField] private Color activeLightColor = new Color(0.2f, 0.4f, 0.7f, 0.9f);\n    [SerializeField] private int maxLightIntensity = 100;\n    [SerializeField] private float minRumbleVolume = 0.01f;\n    [SerializeField] private float maxRumbleVolume = 1f;\n    [SerializeField] private float rumbleFrequency = 20f; // Low frequency\n    [SerializeField] private LayerMask gravityLayerMask;\n\n    private Rigidbody2D[] allRigidbodies;\n    private int activeObjectsCount;\n    private Vector3 centerPosition;\n    private Quaternion startRotation;\n    private bool isPlayingRumble = false;\n\n    void Start()\n    {\n        allRigidbodies = Physics.OverlapLayer(gravityLayerMask, typeof(Rigidbody2D));\n        if (allRigidbodies == null || allRigidbodies.Length == 0)\n            allRigidbodies = GetComponentsInChildren<<Rigidbody2D>();\n        centerPosition = transform.position;\n        startRotation = transform.rotation;\n    }\n\n    void Update()\n    {\n        Rotate();\n    }\n\n    void Rotate()\n    {\n        transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);\n    }\n\n    void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\") || !other.CompareTag(\"IgnoreGravity\"))\n        {\n            // Add to tracked objects for light and rumble\n            activeObjectsCount++;\n            ApplyGravity(other.gameObject.rigidbody2D ?? new Rigidbody2D(other.GetComponent<Collider2D>()?.gameObject));\n            PlayRumble(activeObjectsCount);\n            CreateParticleAtCollision(other.transform.position);\n        }\n    }\n\n    void OnTriggerExit2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\") || !other.CompareTag(\"IgnoreGravity\"))\n        {\n            activeObjectsCount--;\n            StopRumble();\n            // Optionally remove from gravity tracking here, or let physics handle\n        }\n    }\n\n    private void ApplyGravity(Rigidbody2D rigidBody)\n    {\n        Vector3 direction = (rigidBody.position - centerPosition).normalized;\n        float distance = Vector3.Distance(rigidBody.position, centerPosition);\n        float force = Mathf.Max(minRumbleVolume * (1f + 0.5f * (distance / (maxDistanceForForce + 1f))), minRumbleVolume); // Example: force increases with 1/distance\n        // For demonstration, apply a radial force pulling towards the center\n        Vector3 pull = -direction * force * Time.fixedDeltaTime;\n        rigidBody.AddForce(pull, ForceMode.Fixed);\n\n        // Optionally, you could set gravity on the Rigidbody here if desired\n    }\n\n    private void CreateParticleAtCollision(Vector3 collisionPoint)\n    {\n        ParticleSystem particle = Instantiate(ParticleSystem prefab, collisionPoint, Quaternion.identity); // Assign your prefab in inspector\n        // Set direction towards center or outward for effect\n        Vector3 fromToCenter = centerPosition - collisionPoint;\n        Vector3 direction = fromToCenter.normalized;\n        // Example: spawn particles along the radial line from center to point\n        for (int i = 0; i < 5; i++)\n        { // 5 particles per collision\n            ParticleSystemPart part = particle.AddParticleSystemParticle();\n            part.position = collisionPoint + direction * (1f + Random.Range(-0.3f, 0.3f));\n            part.color = new Color(Random.Range(0.7f, 1f), Random.Range(0.2f, 0.6f), 1f, 0.8f);\n            part.size = 0.05f + Random.Range(-0.01f, 0.03f);\n        }\n        // Adjust velocity for explosion effect\n        particle.GetComponent<ParticleSystem>().particleInfo.allSetVelocities *= 2f;\n    }\n\n    private void PlayRumble(int count)\n    {\n        if (!isPlayingRumble)\n        {\n            isPlayingRumble = true;\n            AudioSource rumbleSource = GetComponent<AudioSource>();\n            rumbleSource.PlayOneShot(new SoundClip(\"LowFrequencyRumble\"));\n            rumbleSource.volume = minRumbleVolume + (maxRumbleVolume - minRumbleVolume) * Mathf.Lerp(0f, 1f, count / (float)maxLightIntensity);\n            // Alternatively use a custom LFO for volume\n        }\n    }\n\n    private void StopRumble()\n    {\n        if (isPlayingRumble)\n        {\n            isPlayingRumble = false;\n            AudioSource rumbleSource = GetComponent<AudioSource>();\n            rumbleSource.Stop();\n            rumbleSource.SetVolume(0f);\n        }\n    }\n\n    // Assign your own ParticleSystem prefab in inspector\n    [SerializeField] private ParticleSystem particlePrefab;\n\n    void OnDrawGizmos()\n    {\n        if (particlePrefab != null)\n            Gizmos.DrawWireSphere(centerPosition, 0.25f);\n    }\n\n    float maxDistanceForForce = 30f; // Adjust as needed for rumble force scaling\n}",
    "ir_json": {
      "class_name": "GravityWell",
      "components": [
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "centerPosition",
          "type": "Vector3",
          "default": [
            0,
            0,
            0
          ]
        },
        {
          "name": "rotationSpeed",
          "type": "float",
          "default": 0.01
        },
        {
          "name": "rumbleVolume",
          "type": "float",
          "default": 0.05
        },
        {
          "name": "lightIntensityMultiplier",
          "type": "float",
          "default": 1.2
        }
      ],
      "behaviors": [
        {
          "name": "ApplyGravitationalForce",
          "trigger": "When Rigidbody is within maxDistance of centerPosition",
          "actions": [
            "Calculate distance between Rigidbody and centerPosition",
            "Compute force = (G * massOfRigidbody * gravityStrength) / (distance^2) * -directionToCenter",
            "Apply Force to Rigidbody"
          ]
        },
        {
          "name": "AdjustRumbleVolume",
          "trigger": "When any Rigidbody is within rumbleZoneDistance of centerPosition",
          "actions": [
            "Calculate average distance of nearby Rigidbodies to centerPosition",
            "Set rumbleVolume = baseRumbleVolume * (1 / (averageDistance + 0.01))"
          ]
        },
        {
          "name": "IncreaseLightIntensityWithObjects",
          "trigger": "When number of active Rigidbody near gravity well > zero",
          "actions": [
            "Count objects within influence radius of centerPosition",
            "Set light intensity multiplier = baseMultiplier * (objectCount / maxObjectCount)"
          ]
        },
        {
          "name": "CreateParticleOnCollision",
          "trigger": "When Rigidbody collides with gravity well center (within collisionRadius)",
          "actions": [
            "Calculate impact point at centerPosition",
            "Spawn particle system at impact point"
          ]
        },
        {
          "name": "RotateWell",
          "trigger": "Always",
          "actions": [
            "Increase rotation of RectTransform of this GameObject by rotationSpeed * deltaTime"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class GravityWell : MonoBehaviour\n{\n    // IR-specified fields (auto-injected)\n    public float rumbleVolume = 0.05f;\n    public float lightIntensityMultiplier = 1.2f;\n\n    [SerializeField] private Vector3 centerPosition = new Vector3(0, 0, 0);\n    [SerializeField] private float rotationSpeed = 0.01f;\n    [SerializeField] private float rumbleVolumeBase = 0.05f;\n    [SerializeField] private float lightIntensityMultiplierBase = 1.2f;\n    [SerializeField] private float influenceRadius = 10f; // For gravity detection\n    [SerializeField] private float collisionRadius = 0.5f; // For particle trigger\n    [SerializeField] private float G = 6.674f;\n    [SerializeField] private float gravityStrength = 1f;\n    [SerializeField] private int maxObjectCount = 20;\n\n    private Rigidbody rb;\n    private Transform localCenter;\n    private float lastTime = 0f;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        localCenter = transform;\n    }\n\n    void Update()\n    {\n        RotateWell();\n    }\n\n    void ApplyGravitationalForce(Rigidbody target)\n    {\n        Vector3 relativePos = (target.transform.position - localCenter.position).normalized;\n        float distance = Vector3.Distance(target.transform.position, localCenter.position);\n\n        if (distance < influenceRadius)\n        {\n            // Force magnitude inversely proportional to square of distance\n            float forceMag = (G * target.mass * gravityStrength) / (distance * distance);\n            Vector3 forceDir = -relativePos; // Pull towards center\n            target.AddForce(forceDir * forceMag, ForceMode.Force);\n        }\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (Vector3.Distance(other.transform.position, localCenter.position) < collisionRadius)\n        {\n            // Particle effect at the center on collision\n            Vector3 impact = localCenter.position;\n            GameObject particle = Instantiate(Resources.Load<GameObject>(\"ParticleEffect\"), impact, Quaternion.identity);\n            // Optionally set local center as parent for visual effect\n            if (particle != null && particle.transform)\n                particle.transform.SetParent(localCenter, false);\n        }\n    }\n\n    void OnDrawGizmos()\n    {\n        // Optional: Draw influence and collision radii for debugging\n        if (localCenter == null) return;\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(localCenter.position, influenceRadius);\n        Gizmos.DrawWireSphere(localCenter.position, collisionRadius);\n    }\n\n    void RotateWell()\n    {\n        float deltaTime = Time.deltaTime;\n        transform.Rotate(Vector3.up * rotationSpeed * deltaTime);\n    }\n\n    void UpdateRumbleVolume()\n    {\n        float avgDistance = 0f;\n        int nearbyCount = 0;\n        float rumbleZoneDistance = 5f; // Adjust as needed\n\n        Collider[] colliders = Physics.OverlapSphere(localCenter.position, rumbleZoneDistance, 0);\n        foreach (Collider c in colliders)\n        {\n            if (c.gameObject.activeSelf && c.GetComponent<Rigidbody>() != null)\n            {\n                nearbyCount++;\n                Vector3 pos = c.transform.position - localCenter.position;\n                avgDistance += pos.magnitude;\n            }\n        }\n        avgDistance /= nearbyCount;\n\n        if (nearbyCount > 0)\n        {\n            float adjustedRumble = rumbleVolumeBase / (avgDistance + 0.01f + 1e-6f);\n            // Optionally limit to [0,1]\n            rumbleVolumeBase = Mathf.Clamp(adjustedRumble, 0, 1) * rumbleVolumeBase;\n        }\n        // Could apply rumble effect here if desired\n    }\n\n    void UpdateLightIntensity()\n    {\n        int objectCount = 0;\n        Collider[] allColliders = Physics.OverlapSphere(localCenter.position, influenceRadius, 0);\n        foreach (Collider c in allColliders)\n        {\n            if (c.gameObject.activeSelf && c.GetComponent<Rigidbody>() != null)\n                objectCount++;\n        }\n        if (objectCount > 0)\n        {\n            float intensity = lightIntensityMultiplierBase * (objectCount / (float)maxObjectCount);\n            // Assign to a light component or adjust local lighting here\n        }\n    }\n\n    // Optional: Call this every frame for rumble and light updates\n    void LateUpdate()\n    {\n        UpdateRumbleVolume();\n        UpdateLightIntensity();\n    }\n\n    // For automatic gravity application on all nearby Rigidbodies (if you want to loop through)\n    // You could add a method like:\n    // void ApplyGravityToAllNearby() { foreach (var obj in GetNearbyRigids()) ApplyGravitationalForce(obj); }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 6,
        "code_quality": 5,
        "completeness": 8,
        "best_practices": 6,
        "total": 32,
        "justification": "Directly implements most requested features with good attempt at gravity and particle effects. However, has some inconsistent and incomplete implementations (e.g., partial rumble logic, incomplete particle spawning)."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 9,
        "completeness": 9,
        "best_practices": 8,
        "total": 43,
        "justification": "More structured approach with clear separation of concerns, better physics modeling, more complete implementation of gravitational mechanics, and more robust handling of edge cases."
      },
      "winner": "ir",
      "key_differences": [
        "IR approach uses more systematic design with explicit behavior definitions",
        "IR generates more modular and extensible code",
        "IR approach has better physics simulation principles",
        "Oneshot approach is more ad-hoc and less carefully architected"
      ],
      "advantages": [
        "More explicit behavior specification",
        "Better separation of concerns",
        "More predictable physics calculations",
        "Easier to modify and extend",
        "Clearer intent through intermediate representation"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 3,
    "prompt": "Build a script that turns any object into a musical instrument - when you collide with it, it plays a note based on where you hit it (top plays high notes, bottom plays low notes), the object's color shifts to match the note's frequency, it vibrates with the sound, and leaves a trail of particles that fade out over 2 seconds.",
    "timestamp": "2026-01-07T14:37:21.474345",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class MusicalInstrument : MonoBehaviour\n{\n    [Header(\"Musical Parameters\")]\n    public float noteRangeMin = 100; // Hz (low)\n    public float noteRangeMax = 2000; // Hz (high)\n    public int noteSteps = 32;\n    public float noteResolution = (noteRangeMax - noteRangeMin) / noteSteps;\n\n    [Header(\"Visual Settings\")]\n    public Color baseColor = new Color(1, 0.5f, 0, 1); // Default color\n    public float colorChangeSpeed = 10f; // How fast color shifts per frame\n\n    [Header(\"Vibration & Effects\")]\n    public Rigidbody rb;\n    public ParticleSystem particleTrail;\n\n    private NoteManager noteManager;\n    private Vector3 collisionPoint;\n    private float hitFrequency;\n    private Color targetColor;\n    private bool isPlaying = false;\n\n    void Start()\n    {\n        // Assign Rigidbody if not set\n        if (rb == null) rb = GetComponent<Rigidbody>();\n        // Initialize NoteManager (assuming it's a standard C# audio manager)\n        noteManager = FindObjectOfType<NoteManager>();\n        if (noteManager == null)\n        {\n            Debug.LogError(\"No NoteManager found in scene!\");\n            return;\n        }\n        // Optionally, create or assign a ParticleSystem for the trail\n        if (particleTrail == null)\n        {\n            particleTrail = Instantiate(new ParticleSystem());\n            particleTrail.name = \"InstrumentTrail\";\n            particleTrail.particlePrefab = new ParticlePrefab(); // Define or set in editor\n            particleTrail.startParticleDelay = 0.1f;\n            particleTrail liftime = 2f; // Set lifetime to 2 seconds\n        }\n    }\n\n    void Update()\n    {\n        if (!isPlaying) return;\n\n        // Animate color shift based on hit frequency (map Hz to RGB)\n        float h = (hitFrequency - noteRangeMin) / noteResolution;\n        int c = Mathf.RoundToInt(h * 7f); // Map to 0-224 for vibrant colors\n        targetColor = Color.HSLToRGB(c / 32f, 1f, 0.5f + (h % 2f)); // Slight brightness change with pitch\n\n        if (!colorIsClose(targetColor))\n        {\n            SetColorOverTime(baseColor, targetColor, colorChangeSpeed);\n        }\n\n        // Vibrate with sound (use rb.velocity scaled to amplitude)\n        float vibrAmpl = Mathf.Lerp(0.1f, 0.5f, Time.deltaTime * 10); // Amplitude over time\n        Vector3 vib = collisionPoint.normalized * vibrAmpl;\n        rb.velocity = new Vector3(vib.x, 0, vib.z) * 0.8f; // Only vertical component for vibration\n\n        // Trail particles fade out\n        if (particleTrail != null)\n        {\n            particleTrail.SetLifetime(liftime);\n            foreach (Particle particle in particleTrail Particles)\n            {\n                if (particle != null && particleSystem != null)\n                    particle.lifeTime = liftime;\n            }\n        }\n\n        // (Optional) Play note via NoteManager\n        noteManager.PlayNote(hitFrequency);\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (!isPlaying)\n        {\n            isPlaying = true;\n\n            // Detect where the collision happened (relative position to center)\n            Vector3 impact = (other.transform.position - transform.position).normalized;\n            float pitch = Mathf.Lerp(noteRangeMin, noteRangeMax, Impact.x < 0 ? 0 : 1f); // Simple top/bottom logic\n            if (impact.z > 0.5f) // Hit from above (high note)\n                pitch = noteRangeMax - (impact.z * (noteRangeMax - noteRangeMin));\n            else // Hit from below or side (low note)\n                pitch = noteRangeMin + (impact.z * (noteRangeMax - noteRangeMin));\n\n            hitFrequency = Mathf.Clamp(pitch, noteRangeMin, noteRangeMax);\n\n            // Calculate target color based on frequency\n            targetColor = Color.HSLToRGB(\n                (pitch - noteRangeMin) / noteResolution * 8f,\n                0.7f, // Saturation\n                0.6f + (pitch / (noteRangeMax + 1)) // Slight brightness rise with pitch\n            );\n\n            collisionPoint = other.transform.position; // Where the hit occurred\n\n            // Start particle trail at this point\n            Vector3 start = transform.position + impact * 0.2f;\n            if (particleTrail == null)\n                particleTrail = Instantiate(new ParticleSystem());\n            particleTrail.startPosition = start;\n            particleTrail.direction = -impact; // Trail fades away from instrument\n        }\n    }\n\n    void OnTriggerExit(Collider other)\n    {\n        isPlaying = false;\n        if (particleTrail != null && particleTrail.isInstantiated)\n            Destroy(particleTrail);\n    }\n\n    private bool colorIsClose(Color a, Color b = default) => \n        (Mathf.Abs(a.r - b.r) < 0.02f &&\n         Mathf.Abs(a.g - b.g) < 0.02f &&\n         Mathf.Abs(a.b - b.b) < 0.02f &&\n         Mathf.Abs(a.a - b.a) < 0.05f);\n\n    private void SetColorOverTime(Color from, Color to, float speed)\n    {\n        float t = 0;\n        while (!colorIsClose(from, to) && t <= 1f)\n        {\n            from.r = Mathf.Lerp(from.r, to.r, t * speed);\n            from.g = Mathf.Lerp(from.g, to.g, t * speed);\n            from.b = Mathf.Lerp(from.b, to.b, t * speed);\n            from.a = Mathf.Lerp(from.a, to.a, t * speed);\n            t += Time.deltaTime / (speed + 0.01f); // Avoid division by zero\n        }\n    }\n\n    // NoteManager should have a method PlayNote(float frequency)\n}",
    "ir_json": {
      "class_name": "MusicalInstrumentBehavior",
      "components": [
        "Rigidbody",
        "Collider"
      ],
      "fields": [
        {
          "name": "baseNoteFrequency",
          "type": "float",
          "default": 440.0
        },
        {
          "name": "noteRangeMin",
          "type": "float",
          "default": 130.81
        },
        {
          "name": "noteRangeMax",
          "type": "float",
          "default": 1760.0
        },
        {
          "name": "colorShiftSpeed",
          "type": "float",
          "default": 5.0
        },
        {
          "name": "particleLifetime",
          "type": "float",
          "default": 2.0
        }
      ],
      "behaviors": [
        {
          "name": "OnColliderEnter",
          "trigger": "Physics.Raycast hit point position relative to center + (transform.forward * collision normal)",
          "actions": [
            "play audio with frequency calculated from hit position (map vertical: top=high, bottom=low within noteRange)",
            "apply force to object in direction of normal scaled by 0.1 for vibration",
            "set object color using HSV where H is log2(noteFrequency/130.81) mapped to [0,360]",
            "create particle system with trail following collider's path and lifetime = particleLifetime"
          ]
        },
        {
          "name": "ColorUpdate",
          "trigger": "Always (on object)",
          "actions": [
            "lerp object color toward HSV((log2((baseNoteFrequency + hitYOffset) / noteRangeMin)) * 360/(noteRangeMax-noteRangeMin)), over colorShiftSpeed seconds"
          ]
        },
        {
          "name": "Vibrate",
          "trigger": "Always (on object after play audio)",
          "actions": [
            "apply force to Rigidbody components: transform.forward * 0.05"
          ]
        },
        {
          "name": "ParticleTrail",
          "trigger": "OnColliderEnter",
          "actions": [
            "create particle system at collider's center, using object's material for color",
            "set particle lifetime to particleLifetime",
            "align trail renderer along collider's forward direction"
          ]
        }
      ]
    },
    "ir_code": "using System.Collections;\nusing UnityEngine;\n\npublic class MusicalInstrumentBehavior : MonoBehaviour\n{\n    [Header(\"Main Settings\")]\n    public float baseNoteFrequency = 440.0f;\n    public float noteRangeMin = 130.81f;\n    public float noteRangeMax = 1760.0f;\n    public float colorShiftSpeed = 5.0f;\n    public float particleLifetime = 2.0f;\n\n    [SerializeField] private Rigidbody rigidbody;\n    [SerializeField] private Collider collider;\n\n    [SerializeField] private AudioSource audioSource;\n\n    void Start()\n    {\n        // Ensure audio source is assigned if present\n        if (rigidbody != null && audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n    }\n\n    void OnCollisionEnter(Collision collision)\n    {\n        Vector3 hitPosition = collision.contacts[0].point - transform.position;\n\n        // Map vertical offset to frequency within note range\n        float yOffset = hitPosition.y;\n        // Normalize the Y position relative to object center for mapping (e.g., -1 to 1 for note range)\n        float relY = (yOffset - transform.position.y) / (2 * rigidbody.maxVelocity * Time.deltaTime); \n        // Or use a fixed height if you know instrument size\n        float freq = baseNoteFrequency + (relY * (noteRangeMax - noteRangeMin)) + noteRangeMin;\n\n        // Clamp frequency within valid range\n        if (freq < noteRangeMin) freq = noteRangeMin;\n        if (freq > noteRangeMax) freq = noteRangeMax;\n\n        // Play audio using AudioSource (assuming you have a SoundClip or can use a simple tone)\n        if (audioSource != null)\n            audioSource.PlayOneShot(new UnityAudioTone(freq));\n\n        // Vibration\n        if (rigidbody != null)\n            rigidbody.AddForce(collider.normal * 0.1f, ForceMode.Force);\n\n        // Color shift based on vertical hit position (Y axis)\n        float targetHsvH = Mathf.Log2((freq / noteRangeMin) + 1f); // Add 1 to avoid log of values <=1\n        targetHsvH = targetHsvH * 360f / (noteRangeMax - noteRangeMin);\n\n        UpdateObjectColor(targetHsvH);\n\n        // Particle trail\n        CreateParticleTrail(collision);\n    }\n\n    void UpdateObjectColor(float h)\n    {\n        if (transform.color.h != 0)\n            transform.color = Color.HSLToRGB(h % 360f, transform.color.s, transform.color.v);\n        else\n            transform.color = Color.white; // fallback or set to solid color\n    }\n\n    void CreateParticleTrail(Collision collision)\n    {\n        Material mat = GetComponent<Renderer>().material;\n        if (mat == null) return;\n\n        Vector3 center = (collision.gameObject.transform.position + collision.transform.up * 0.5f) + collider.center;\n        Quaternion rotation = transform.rotation; // Use forward as trail direction\n        ParticleSystem ps = Instantiate(new ParticleSystem(mat), center, rotation);\n\n        if (ps != null)\n        {\n            ps.lifetime = new ParticleSystem.Lifespan(particleLifetime * Time.deltaTime);\n            ps.trailRenderer.transform.rotation = rotation;\n        }\n    }\n\n    void Vibrate()\n    {\n        if (rigidbody != null)\n            rigidbody.AddForce(transform.forward * 0.05f, ForceMode.Force);\n    }\n\n    // Optional: Trigger vibration after a short delay\n    void PlayAndVibrate(float seconds = 0.3f)\n    {\n        if (audioSource != null)\n            audioSource.PlayOneShot(new UnityAudioTone(baseNoteFrequency)); // Or use computed freq from earlier\n        StartCoroutine(VibrateAfterDelay(seconds));\n    }\n\n    IEnumerator VibrateAfterDelay(float delayTime)\n    {\n        yield return new WaitForSeconds(delayTime);\n        Vibrate();\n    }\n\n    // Dummy tone generator for demonstration (replace with actual synthesis or asset)\n    class UnityAudioTone\n    {\n        public float frequency;\n        // This would normally use a SoundWave or similar, but here we just pass the freq to an AudioSource if needed.\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 6,
        "code_quality": 5,
        "completeness": 8,
        "best_practices": 6,
        "total": 32,
        "justification": "Direct approach captures most requirements but has some implementation inconsistencies. Complex logic for frequency and color mapping, but slightly overcomplicated. Includes most desired behaviors with some potential edge cases."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 9,
        "completeness": 9,
        "best_practices": 8,
        "total": 43,
        "justification": "Generated code is more structured, modular, and follows Unity best practices. Cleaner separation of concerns, better method decomposition, and more robust error handling. Demonstrates a more systematic approach to implementing the musical instrument behavior."
      },
      "winner": "ir",
      "key_differences": [
        "IR approach provides a more abstracted, declarative specification of behavior",
        "Generated IR code is more modular and follows cleaner design principles",
        "Oneshot approach relies more on direct, potentially brittle implementation",
        "IR method allows for easier modification and extension of behavior"
      ],
      "advantages": [
        "More maintainable code structure",
        "Better separation of concerns",
        "More flexible approach to behavior definition",
        "Clearer mapping between specification and implementation",
        "Easier to modify and extend functionality"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 4,
    "prompt": "Create a creature that has 5 states: idle (sits still, plays ambient breathing), curious (slowly approaches player if within 10 units, plays questioning sound), scared (runs away from player, plays panic sound, color turns red), aggressive (chases player, plays roar, color turns dark, applies force toward player), and exhausted (stops moving, plays tired sound, color fades to gray). It transitions between states based on player distance and how long it's been in current state.",
    "timestamp": "2026-01-07T14:39:17.787405",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class CreatureStateManager : MonoBehaviour\n{\n    [Header(\"State Variables\")]\n    public enum State { Idle, Curious, Scared, Aggressive, Exhausted }\n\n    public enum ColorPhase { IdleGray, CuriousBlue, ScaredRed, AggressiveDark, ExhaustedGray }\n    public Color color = Color.gray;\n\n    // States and timers\n    private State currentState = State.Idle;\n    private int stateTimer = 0;\n    private float maxStateTime = 2.5f; // seconds per state before switching (tune as needed)\n    private float lastSwitchTime = 0f;\n\n    [Header(\"Behavior Parameters\")]\n    public float approachSpeedCurious = 3f;\n    public float runSpeedScared = 8f;\n    public Vector3 chaseDirection = Vector3.forward; // or use transform.forward\n\n    [SerializeField] private GameObject breathingEffect; // for idle breathing\n    [SerializeField] private AudioSource questionSound;\n    [SerializeField] private AudioSource panicSound;\n    [SerializeField] private AudioSource roarSound;\n    [SerializeField] private AudioSource tiredSound;\n\n    [SerializeField] private Transform playerTransform; // assign in inspector or find at runtime\n\n    private float currentDistanceToPlayer;\n    private bool isChasing = false;\n\n    void Start()\n    {\n        UpdatePositionAndColor();\n        if (playerTransform == null)\n            playerTransform = FindObjectOfType<Transform>().self;\n        InvokeRepeating(\"UpdateState\", 0.05f, 0.1f);\n    }\n\n    void Update()\n    {\n        currentDistanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n\n        // Handle state transitions\n        if (Time.time >= lastSwitchTime + maxStateTime)\n        {\n            SwitchToNextState();\n            lastSwitchTime = Time.time;\n        }\n\n        switch (currentState)\n        {\n            case State.Idle:\n                IdleBehavior();\n                break;\n\n            case State.Curious:\n                CuriousBehavior();\n                break;\n\n            case State.Scared:\n                ScaredBehavior();\n                break;\n\n            case State.Aggressive:\n                AggressiveBehavior();\n                break;\n\n            case State.Exhausted:\n                ExhaustedBehavior();\n                break;\n        }\n\n        // Reset chasing flag if not in aggressive\n        isChasing = false;\n        if (currentState == State.Aggressive)\n        {\n            // Follow player direction for chase\n            Vector3 targetDirection = (playerTransform.position - transform.position).normalized;\n            transform.Translate(chaseDirection.normalized * runSpeedScared * Time.deltaTime, Space.World);\n        }\n    }\n\n    void SwitchToNextState()\n    {\n        int currentIndex = Enum.GetValues(typeof(State)).GetHashCode((State)currentState) - 1000; // arbitrary offset for ordering\n        List<State> order = new List<State> { State.Idle, State.Curious, State.Scared, State.Aggressive, State.Exhausted };\n        foreach (var s in order)\n            if (s != currentState)\n                return currentState = s;\n    }\n\n    void IdleBehavior()\n    {\n        // Sit still\n        transform.position = new Vector3(transform.position.x, 0.5f + transform.position.y, transform.position.z);\n        // Optional: adjust rotation to face player for idle look\n\n        // Breathing effect (if assigned)\n        if (breathingEffect != null) breathingEffect.Play();\n        // Ambient sound\n        questionSound.Play() ?? null; // Only play occasionally or on input\n        color = ColorPhase.IdleGray;\n    }\n\n    void CuriousBehavior()\n    {\n        if (currentDistanceToPlayer < 10f)\n        {\n            transform.Translate(chaseDirection.normalized * approachSpeedCurious * Time.deltaTime, Space.World);\n            questionSound.Play();\n        }\n        else\n        {\n            // Stay still but maybe look around\n            transform.position = new Vector3(transform.position.x, 0.5f + transform.position.y, transform.position.z);\n        }\n\n        color = ColorPhase.CuriousBlue;\n    }\n\n    void ScaredBehavior()\n    {\n        if (currentDistanceToPlayer < 10f)\n        {\n            // Run away\n            Vector3 dirAway = -(playerTransform.position - transform.position).normalized;\n            transform.Translate(dirAway * runSpeedScared * Time.deltaTime, Space.World);\n            panicSound.Play();\n            color = Color.red;\n        }\n        else\n        {\n            // Still but scared, maybe jitter or back off slightly\n            transform.position += new Vector3(Random.Range(-0.5f, 0.5f), 0, Random.Range(-0.5f, 0.5f));\n        }\n\n        color = ColorPhase.ScaredRed;\n    }\n\n    void AggressiveBehavior()\n    {\n        // Chase player directly\n        isChasing = true;\n        transform.Translate(chaseDirection.normalized * runSpeedScared * Time.deltaTime, Space.World);\n        roarSound.Play();\n        color = ColorPhase.AggressiveDark;\n    }\n\n    void ExhaustedBehavior()\n    {\n        transform.position = new Vector3(transform.position.x, 0f, transform.position.z); // stand still\n        tiredSound.Play();\n        color = ColorPhase.ExhaustedGray;\n    }\n\n    void UpdatePositionAndColor()\n    {\n        color = ColorPhase.IdleGray;\n    }\n\n    // Optionally: For trigger-based state (if using colliders), add OnTriggerEnter/Exit methods here if needed.\n}",
    "ir_json": {
      "class_name": "MonsterAI",
      "components": [
        "Rigidbody",
        "Animator"
      ],
      "fields": [
        {
          "name": "curState",
          "type": "string",
          "default": "idle"
        },
        {
          "name": "lastTransitionTime",
          "type": "float",
          "default": 0.0
        },
        {
          "name": "position",
          "type": "Vector3",
          "default": null
        },
        {
          "name": "color",
          "type": "Color",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "StateMachine",
          "trigger": "TimeSinceLastTransition > 2.0 && (PlayerDistance < 10 || IsTargetChased)",
          "": "stay if not triggered",
          "actions": [
            {
              "when": "curState == 'idle'",
              "action": "set color to gray; play ambientBreathingAudio"
            },
            {
              "when": "PlayerDistance <= 10 && IsTargetCuriousTriggered",
              "action": "transitionToCurious"
            },
            {
              "when": "PlayerDistance < 5 && curState == 'curious'",
              "action": "transitionToScared"
            },
            {
              "when": "PlayerDistance > 12 && curState == 'scared'",
              "action": "transitionToIdle"
            },
            {
              "when": "IsTargetChased",
              "action": "transitionToAggressive"
            },
            {
              "when": "TimeSinceLastTransition >= 3.0 && curState == 'aggressive' && PlayerDistance > 20",
              "action": "transitionToExhausted"
            },
            {
              "when": "curState == 'exhausted' && TimeSinceLastTransition >= 4.0",
              "action": "destroy self"
            }
          ]
        },
        {
          "name": "CuriousApproach",
          "trigger": "PlayerDistance < 10 && curState == 'curious'",
          "actions": [
            {
              "when": true,
              "action": "move towards player at speed 2.0"
            },
            {
              "when": true,
              "action": "play questioningSound"
            }
          ]
        },
        {
          "name": "ScaredFlee",
          "trigger": "PlayerDistance < 5 && curState == 'scared'",
          "actions": [
            {
              "when": true,
              "action": "move away from player at speed 7.0"
            },
            {
              "when": true,
              "action": "play panicAudio"
            },
            {
              "when": true,
              "action": "set color to red"
            }
          ]
        },
        {
          "name": "ChasePlayer",
          "trigger": "IsTargetChased && curState == 'aggressive'",
          "actions": [
            {
              "when": true,
              "action": "move towards player at speed 6.0"
            },
            {
              "when": true,
              "action": "play roarAudio"
            },
            {
              "when": true,
              "action": "apply force to self in direction of player (magnitude 20)"
            },
            {
              "when": true,
              "action": "set color to dark"
            }
          ]
        },
        {
          "name": "ExhaustedStop",
          "trigger": "curState == 'exhausted'",
          "actions": [
            {
              "when": true,
              "action": "stop moving"
            },
            {
              "when": true,
              "action": "play tiredAudio"
            },
            {
              "when": true,
              "action": "set color to gray"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class MonsterAI : MonoBehaviour\n{\n    [SerializeField] private Rigidbody rb;\n    [SerializeField] private Animator animator;\n    public string curState = \"idle\";\n    public float lastTransitionTime = 0.0f;\n    public Vector3 position = transform.position;\n    [SerializeField] private Color color;\n    public Color targetColor;\n\n    private float playerDistance;\n    private bool isTargetChased = false;\n    private float timeSinceLastTransition = 0.0f;\n\n    private const float IDLE_COLOR_GRAY = new Color(0.4f, 0.4f, 0.4f, 0.6f);\n    private const float CURIOUS_COLOR = new Color(0.3f, 0.7f, 0.5f, 1.0f);\n    private const float SCARED_COLOR = new Color(1.0f, 0.2f, 0.2f, 0.8f);\n    private const float AGGRESSIVE_COLOR = new Color(0.15f, 0.35f, 0.1f, 0.4f);\n    private const float EXHAUSTED_COLOR = new Color(0.5f, 0.6f, 0.7f, 0.9f);\n\n    // Helper to get distance to player\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        animator = GetComponent<Animator>();\n        UpdatePlayerDistance();\n    }\n    void UpdatePlayerDistance()\n    {\n        playerDistance = Vector3.Distance(transform.position, GameObject.FindGameObjectWithTag(\"Player\").transform.position);\n        if (animator) animator.SetInteger(\"isChased\", isTargetChased ? 1 : 0);\n    }\n\n    private void Update()\n    {\n        UpdateState();\n        // Curious approach sound\n        if (curState == \"curious\" && !isTargetChased)\n            animator.Play(\"CuriousApproach\"); // Assume state names exist in Animator\n        // Flee or chase visuals\n        switch (curState)\n        {\n            case \"scared\":\n                color = SCARED_COLOR;\n                break;\n            case \"aggressive\":\n                color = AGGRESSIVE_COLOR;\n                break;\n            case \"exhausted\":\n                color = EXHAUSTED_COLOR;\n                break;\n            default:\n                color = IDLE_COLOR_GRAY;\n        }\n    }\n\n    // State machine transitions\n    void UpdateState()\n    {\n        timeSinceLastTransition += Time.deltaTime;\n\n        if (!isTargetChased && curState == \"idle\")\n        {\n            if (playerDistance < 10f)\n            {\n                curState = \"curious\";\n                lastTransitionTime = 0.0f;\n                isTargetChased = false; // Not currently being chased\n                UpdatePlayerDistance();\n            }\n            else\n            {\n                color = new Color(0.4f, 0.4f, 0.4f, 0.6f); // Gray (idle)\n            }\n        }\n\n        if (isTargetChased && curState == \"aggressive\")\n        {\n            ChasePlayer();\n        }\n        else if (curState == \"scared\")\n        {\n            if (playerDistance < 5f)\n            {\n                ScaredFlee();\n            }\n            else\n            {\n                // Transition back to idle after enough time out of scared\n                if (timeSinceLastTransition >= 2.0f)\n                {\n                    curState = \"idle\";\n                    lastTransitionTime = 0.0f;\n                }\n            }\n        }\n        else if (curState == \"aggressive\")\n        {\n            // Exhausted if not chasing for long enough\n            if (playerDistance > 20f && timeSinceLastTransition >= 3.0f)\n            {\n                curState = \"exhausted\";\n                lastTransitionTime = 0.0f;\n            }\n        }\n        else if (curState == \"exhausted\")\n        {\n            if (timeSinceLastTransition >= 4.0f)\n            {\n                Destroy(gameObject);\n            }\n        }\n\n        animator.SetInteger(\"curState\", curState); // Optional: update state in Animator\n    }\n\n    // Actions for transitions\n    void CuriousApproachAction()\n    {\n        animator.Play(\"CuriousApproach\"); // Assumes state exists\n        if (playerDistance < 10f)\n            animator.SetFloat(\"speed\", 2.0f);\n        else\n            animator.SetFloat(\"speed\", 0.0f); // Stop moving when not close enough\n        if (!isTargetChased)\n            animator.Play(\"questioningSound\"); // Assumes sound state or parameter exists\n    }\n\n    void ScaredFleeAction()\n    {\n        animator.Play(\"ScaredFlee\"); // Assumes state exists\n        rb.velocity = Vector3.zero;\n        rb.isKinematic = true; // Optionally make invulnerable during panic\n        if (playerDistance < 5f)\n            animator.SetFloat(\"speed\", 7.0f);\n        else\n            animator.SetFloat(\"speed\", 0.0f);\n        animator.Play(\"panicAudio\"); // Or set a parameter for sound effect\n        color = new Color(1.0f, 0.2f, 0.2f, 0.8f); // Red\n    }\n\n    void ChasePlayer()\n    {\n        isTargetChased = true;\n        rb.velocity = (Vector3)(GameObject.FindGameObjectWithTag(\"Player\").transform.position - transform.position).normalized * 6.0f;\n        rb.AddForce(transform.up * 20.0f, ForceMode.Force); // Push away\n        animator.Play(\"ChasePlayer\");\n        color = new Color(0.15f, 0.35f, 0.1f, 0.4f); // Dark\n    }\n\n    void ExhaustedStopAction()\n    {\n        rb.velocity = Vector3.zero;\n        rb.isKinematic = true; // Stop moving\n        animator.Play(\"ExhaustedStop\");\n        if (animator)\n            animator.SetFloat(\"speed\", 0.0f);\n        color = new Color(0.5f, 0.6f, 0.7f, 0.9f); // Tired gray\n    }\n\n    // Triggers for transitions\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n            isTargetChased = true;\n        else if (/* other collision logic for environment */)\n            // Handle entering scared/exhausted states here as needed\n            passThroughOrTransition(other);\n    }\n\n    private bool passThroughOrTransition(Collider other)\n    {\n        // Example: If entering a \"frightening\" area, transition to scared\n        return false; // Implement actual logic based on environment setup\n    }\n\n    public void SetTargetChased(bool chased)\n    {\n        isTargetChased = chased;\n        UpdatePlayerDistance();\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 6,
        "code_quality": 5,
        "completeness": 6,
        "best_practices": 5,
        "total": 29,
        "justification": "Direct translation has some implementation issues. State switching is rigid, code is somewhat complex, and some methods are incomplete. Uses standard Unity patterns but lacks robust state management."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 8,
        "completeness": 9,
        "best_practices": 8,
        "total": 42,
        "justification": "Intermediate representation allows for more flexible and declarative state management. Clearer separation of concerns, more comprehensive state transitions, and better encapsulation of behaviors."
      },
      "winner": "ir",
      "key_differences": [
        "IR approach uses a more declarative state machine with clear transition rules",
        "IR generates more modular and configurable code",
        "IR separates behavioral logic more cleanly",
        "OneShot approach is more procedural and harder to modify"
      ],
      "advantages": [
        "More flexible state transition logic",
        "Easier to extend and modify creature behavior",
        "Better separation of concerns",
        "More maintainable code structure",
        "Allows for easier configuration of state behaviors"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 5,
    "prompt": "Make a door that has locked, unlocking, open, and closing states. When locked, it plays a rattle sound and shakes slightly. When unlocking, it plays a key-turning sound for 3 seconds while rotating slowly, then transitions to open. When open, it plays a creak and stays open for 10 seconds, then automatically starts closing. During closing, it rotates back while playing a slam sound, then locks again. The door's material emission color changes with each state.",
    "timestamp": "2026-01-07T14:40:55.290934",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class LockedDoor : MonoBehaviour\n{\n    [Header(\"State Variables\")]\n    public enum DoorState { Locked, Unlocking, Open, Closing }\n    private DoorState currentState = DoorState.Locked;\n\n    // Reference to UI or visual components\n    [SerializeField] Transform doorTransform;\n    [SerializeField] GameObject doorMesh; // Assign the mesh or sprite renderer for color change\n    [SerializeField] AudioSource rattleSource;\n    [SerializeField] AudioSource unlockingSource;\n    [SerializeField] AudioSource creakSource;\n    [SerializeField] AudioSource slamSource;\n\n    // Sound and animation references\n    [SerializeField] AudioClip[] rattleClips = new AudioClip[1];\n    [SerializeField] AudioClip[] unlockClips = new AudioClip[3];\n    [SerializeField] float unlockDuration = 3f;\n    [SerializeField] Animator doorAnimator; // Set in inspector if using an animator\n\n    private bool isCreakingOpen = false;\n\n    void Start()\n    {\n        doorTransform = transform;\n        doorMesh.transform.SetParent(transform);\n        if (doorAnimator != null)\n            doorAnimator.SetTrigger(\"Start\");\n    }\n\n    void Update()\n    {\n        HandleState();\n        PlaySounds();\n        UpdateEmissionColor();\n    }\n\n    // Door interaction: assume trigger on a collidable object\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Key\") && currentState == DoorState.Locked)\n        {\n            UnlockDoor();\n        }\n        else if (currentState != DoorState.Closing && isCreakingOpen)\n        {\n            // User left while open, close automatically after timeout\n            StartCoroutine(CloseAndLock());\n        }\n    }\n\n    void HandleState()\n    {\n        switch (currentState)\n        {\n            case DoorState.Locked:\n                LockDoor();\n                break;\n            case DoorState.Unlocking:\n                UnlockDoor();\n                break;\n            case DoorState.Open:\n                if (!isCreakingOpen) CreakOpen();\n                break;\n            case DoorState.Closing:\n                CloseDoor();\n                break;\n        }\n\n        // Add rotation and animation logic here as needed\n        if (doorAnimator != null)\n        {\n            switch (currentState)\n            {\n                case DoorState.Locked:\n                    doorAnimator.SetTrigger(\"Locked\");\n                    break;\n                case DoorState.Unlocking:\n                    doorAnimator.SetTrigger(\"Unlocking\");\n                    break;\n                case DoorState.Open:\n                    doorAnimator.SetTrigger(\"Open\");\n                    isCreakingOpen = true;\n                    break;\n                case DoorState.Closing:\n                    doorAnimator.SetTrigger(\"Closing\");\n                    break;\n            }\n        }\n\n        // Movement or rotation could be added here if required\n    }\n\n    void LockDoor()\n    {\n        currentState = DoorState.Locked;\n        doorTransform.rotation = Quaternion.identity;\n        if (rattleSource != null)\n            rattleSource.PlayOneShot(rattleClips[0]);\n        // Optionally, set mesh color to locked hue\n        SetEmissionColor(lockedColor: new Color(0.2f, 0.1f, 0.05f, 1f));\n    }\n\n    void UnlockDoor()\n    {\n        if (unlockingSource == null)\n            unlockingSource = GetComponent<AudioSource>();\n        unlockingSource.PlayOneShot(unlockClips[0]);\n        // Slow rotation for 3 seconds\n        float startAngle = doorTransform.rotation.eulerAngles.y;\n        float targetAngle = (startAngle + 90f) % 360f; // Rotate to right by 90 degrees\n        Vector3 initialRotation = doorTransform.rotation.eulerAngles;\n        float rotateSpeed = 30f / unlockDuration; // Degrees per second\n\n        float elapsed = 0f;\n        while (elapsed < unlockDuration)\n        {\n            float currentAngle = Mathf.DeltaAngle(initialRotation.y, targetAngle) > 180 ? \n                (360 - Mathf.Abs(currentAngle - targetAngle)) : \n                Mathf.Abs(currentAngle - targetAngle);\n            float newAngle = (initialAngle.y + (currentAngle * (elapsed / unlockDuration))) + (targetAngle - initialAngle.y) * (elapsed / unlockDuration);\n            doorTransform.rotation = Quaternion.Euler(newAngle, initialRotation.x, initialRotation.z);\n            elapsed += Time.deltaTime;\n        }\n        // Transition to Open state\n        currentState = DoorState.Open;\n    }\n\n    void CreakOpen()\n    {\n        if (creakSource != null)\n            creakSource.PlayOneShot(creakClips[0]);\n        isCreakingOpen = true;\n    }\n\n    IEnumerator CloseAndLock()\n    {\n        isCreakingOpen = false;\n        currentState = DoorState.Closing;\n\n        // Play slam sound\n        if (slamSource != null)\n            slamSource.PlayOneShot(slamClips[0]);\n\n        float closeTime = 2f; // seconds to rotate back\n        float startAngle = doorTransform.rotation.eulerAngles.y;\n        Vector3 initialRotation = doorTransform.rotation.eulerAngles;\n\n        float elapsed = 0f;\n        while (elapsed < closeTime)\n        {\n            float currentAngle = Mathf.DeltaAngle(initialRotation.y, startAngle) > 180 ? \n                (360 - Mathf.Abs(currentAngle - startAngle)) : \n                Mathf.Abs(currentAngle - startAngle);\n            float newAngle = (initialAngle.y + (currentAngle * (elapsed / closeTime))) + (startAngle - initialAngle.y) * (elapsed / closeTime);\n            doorTransform.rotation = Quaternion.Euler(newAngle, initialRotation.x, initialRotation.z);\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        // Lock after closing\n        LockDoor();\n    }\n\n    void Unlocking()\n    {\n        SetEmissionColor(uncolored: new Color(0.4f, 0.6f, 1f, 0.7f)); // Example color transition\n    }\n\n    void OpenState()\n    {\n        if (creakSource != null)\n            creakSource.PlayOneShot(creakClips[0]);\n        isCreakingOpen = true;\n    }\n\n    void CloseDoor()\n    {\n        SetEmissionColor(lockedColor: new Color(0.1f, 0.2f, 0.3f, 0.8f)); // Darker for closing\n        // Optional: animate rotation back to closed\n        float closeTime = 2f;\n        Vector3 startAngle = doorTransform.rotation.eulerAngles;\n        float targetAngle = 0f; // Closed position\n\n        float elapsed = 0f;\n        while (elapsed < closeTime)\n        {\n            float currentAngle = Mathf.DeltaAngle(startAngle.y, targetAngle) > 180 ? \n                (360 - Mathf.Abs(currentAngle - targetAngle)) : \n                Mathf.Abs(currentAngle - targetAngle);\n            float newAngle = (startAngle.y + (currentAngle * (elapsed / closeTime))) + (targetAngle - startAngle.y) * (elapsed / closeTime);\n            doorTransform.rotation = Quaternion.Euler(newAngle, startAngle.x, startAngle.z);\n            elapsed += Time.deltaTime;\n        }\n    }\n\n    void UpdateEmissionColor()\n    {\n        switch (currentState)\n        {\n            case DoorState.Locked:\n                doorMesh.GetComponent<SpriteRenderer>().color = new Color(0.2f, 0.1f, 0.05f, 1f);\n                break;\n            case DoorState.Unlocking:\n                doorMesh.GetComponent<SpriteRenderer>().color = new Color(0.4f, 0.6f, 1f, 0.7f); // Light blue\n                break;\n            case DoorState.Open:\n                if (isCreakingOpen)\n                    doorMesh.GetComponent<SpriteRenderer>().color = new Color(0.3f, 0.5f, 0.8f, 0.9f); // Light gray open\n                else\n                    doorMesh.GetComponent<SpriteRenderer>().color = new Color(0.7f, 0.7f, 0.6f, 0.85f); // Slightly dimmed open\n                break;\n            case DoorState.Closing:\n                doorMesh.GetComponent<SpriteRenderer>().color = new Color(0.1f, 0.2f, 0.3f, 0.8f);\n                break;\n        }\n    }\n\n    // Helper to play sounds with fade or one shot as needed\n    void PlaySounds()\n    {\n        if (rattleSource != null && currentState == DoorState.Locked)\n            rattleSource.PlayOneShot(rattleClips[0]);\n        else if (unlockingSource != null && currentState == DoorState.Unlocking)\n            unlockingSource.PlayOneShot(unlockClips[0]);\n\n        if (isCreakingOpen && currentState == DoorState.Open)\n            creakSource.PlayOneShot(creakClips[0]);\n\n        // Automatically trigger slam on close\n        if (currentState == DoorState.Closing)\n            slamSource.PlayOneShot(slamClips[0]);\n    }\n}",
    "ir_json": {
      "class_name": "DoorBehavior",
      "components": [
        "Rigidbody",
        "Animator"
      ],
      "fields": [
        {
          "name": "isLocked",
          "type": "bool",
          "default": true
        },
        {
          "name": "rotationAngle",
          "type": "float",
          "default": 0.0
        },
        {
          "name": "openTimeSeconds",
          "type": "int",
          "default": 10
        },
        {
          "name": "rattleAudio",
          "type": "string",
          "default": ""
        },
        {
          "name": "keyTurnAudio",
          "type": "string",
          "default": ""
        },
        {
          "name": "slamAudio",
          "type": "string",
          "default": ""
        },
        {
          "name": "emissionColorLocked",
          "type": "string",
          "default": "#C0A080"
        },
        {
          "name": "emissionColorOpen",
          "type": "string",
          "default": "#FFCC00"
        },
        {
          "name": "emissionColorClosing",
          "type": "string",
          "default": "#888800"
        }
      ],
      "behaviors": [
        {
          "name": "Locked",
          "trigger": "isLocked == true && !opened",
          "actions": [
            "play audio rattle",
            "apply force Vector3(0, -1, 0) * 0.5f for 0.2s"
          ],
          "stateChangeCondition": "isLocked becomes false and rotationAngle != 90"
        },
        {
          "name": "Unlocking",
          "trigger": "!opened && isLocked == true",
          "actions": [
            "play audio keyTurn",
            "set animation 'rotate door' with speed 5 deg/s for 540 deg (3s)",
            "wait until rotationAngle >= 90"
          ],
          "stateChangeCondition": "rotationAngle >= 90 and !isLocked"
        },
        {
          "name": "Opening",
          "trigger": "!opened && isLocked == false",
          "actions": [
            "play audio creak",
            "set animation 'open door' to finished state",
            "wait for openTimeSeconds seconds"
          ],
          "stateChangeCondition": "isLocked becomes true or !opened and time elapsed >= openTimeSeconds"
        },
        {
          "name": "Open (Hold)",
          "trigger": "!opened && isLocked == false",
          "actions": [
            "set emission color to emissionColorOpen"
          ]
        },
        {
          "name": "Closing",
          "trigger": "isLocked == false && !closed",
          "actions": [
            "play audio slam",
            "set animation 'close door' with speed -6 deg/s for 540 deg (10s)",
            "wait until rotationAngle <= 0"
          ],
          "stateChangeCondition": "rotationAngle <= 0 or isLocked becomes true and !opened"
        },
        {
          "name": "Locked Again",
          "trigger": "!opened && isLocked == true",
          "actions": [
            "set emission color to emissionColorLocked"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\n[RequireComponent(typeof(Animator))]\npublic class DoorBehavior : MonoBehaviour\n{\n    public bool isLocked = true;\n    [Range(0f, 360f)]\n    public float rotationAngle = 0.0f;\n    public int openTimeSeconds = 10;\n    [SerializeField] private string rattleAudio = \"\";\n    [SerializeField] private string keyTurnAudio = \"\";\n    [SerializeField] private string slamAudio = \"\";\n    public string emissionColorLocked = \"#C0A080\";\n    public string emissionColorOpen = \"#FFCC00\";\n    public string emissionColorClosing = \"#888800\";\n\n    [Header(\"Rigidbody\")]\n    Rigidbody rigidbody;\n\n    [Header(\"Animator\")]\n    Animator animator;\n\n    void Start()\n    {\n        rigidbody = GetComponent<Rigidbody>();\n        animator = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        HandleLockedState();\n        HandleUnlockingState();\n        HandleOpeningState();\n        HandleClosingState();\n        // Additional logic as needed\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        // Example: Check for player or key interaction here if required\n    }\n\n    void OnTriggerExit(Collider other)\n    {\n        // Reset state if door is opened and player leaves\n        rotationAngle = 0.0f;\n        isLocked = true;\n    }\n\n    void OnAnimatorStateEnter(AnimatorStateInfo stateInfo, Animator anim)\n    {\n        // Optional: Add logic to track animation state transitions for behavior management\n    }\n\n    void HandleLockedState()\n    {\n        if (isLocked && !animator.isPlaying(\"Opened\") && rotationAngle != 90f)\n        {\n            // Play rattle sound\n            if (!string.IsNullOrEmpty(rattleAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().PlayClip(rattleAudio);\n\n            // Apply gentle upward force to simulate creaking\n            Vector3 force = new Vector3(0, -0.5f, 0) * Time.deltaTime;\n            rigidbody.AddForce(force, ForceMode.Force);\n            // Short duration effect (0.2 seconds)\n            if (Time.deltaTime < 0.2f)\n                return;\n\n            // Transition to Unlocking when rotated enough\n            if (rotationAngle >= 90f - 0.1f)\n            {\n                StartCoroutine(TransitionToUnlocking());\n                return;\n            }\n        }\n    }\n\n    IEnumerator TransitionToUnlocking()\n    {\n        while (rotationAngle < 90f - 0.1f)\n        {\n            // Animate door rotation\n            float targetDegrees = (90f + 3f * Time.deltaTime); // 5 deg/s\n            animator.SetInteger(\"Rotation\", targetDegrees);\n            yield return null;\n        }\n\n        // After rotated, check if lock is still active and trigger unlock sequence\n        if (isLocked)\n        {\n            StartCoroutine(UnlockSequence());\n        }\n    }\n\n    IEnumerator UnlockSequence()\n    {\n        float timer = 0f;\n        while (timer < 3f && !animator.IsPlaying(\"Closed\"))\n        {\n            // Play key turn audio\n            if (!string.IsNullOrEmpty(keyTurnAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().PlayClip(keyTurnAudio);\n\n            // Rotate door to 90 degrees (already done, but keep for clarity)\n            animator.SetInteger(\"Rotation\", 90f);\n            yield return null;\n            timer += Time.deltaTime;\n        }\n\n        isLocked = false;\n\n        // Wait until rotation is fully at 90\n        while (rotationAngle < 90.1f || rotationAngle > 89.9f)\n        {\n            yield return null;\n        }\n\n        // Now transition to Opening if not already open\n        StartCoroutine(OpenSequence());\n    }\n\n    IEnumerator OpenSequence()\n    {\n        float elapsed = 0f;\n        bool openReached = false;\n\n        while (elapsed < openTimeSeconds && !animator.IsPlaying(\"Closed\"))\n        {\n            // Play audio\n            if (!string.IsNullOrEmpty(rattleAudio) || !string.IsNullOrEmpty(keyTurnAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().PlayClip((rattleAudio + keyTurnAudio).Replace(\"\", \"\"));\n\n            // Set open animation and wait\n            animator.SetInteger(\"OpenFlag\", 1f); // Custom state for opening\n            yield return null;\n            elapsed += Time.deltaTime;\n\n            if (elapsed >= openTimeSeconds)\n            {\n                openReached = true;\n                break; // Or handle closing if desired\n            }\n        }\n\n        isLocked = false; // Only set when actually opening\n\n        // Optionally: Set emission color to Open state here\n        if (!animator.IsPlaying(\"Closed\"))\n        {\n            animator.SetInteger(\"EmissionColor\", 0); // Custom state index for color change\n            yield return null;\n            if (openReached)\n                SetEmissionColor(emissionColorOpen);\n        }\n    }\n\n    void HandleOpeningState()\n    {\n        if (!animator.IsPlaying(\"Closed\") && !isLocked)\n        {\n            // Play opening creak sound if needed\n            if (!string.IsNullOrEmpty(rattleAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().PlayClip(rattleAudio);\n\n            animator.SetTrigger(\"Open\"); // Assuming \"Open\" is a trigger in Animator\n            // Wait for openTimeSeconds then transition to Closed or Lock Again as needed\n            yield return new WaitForSeconds(openTimeSeconds);\n            // Here, you can add state change logic (e.g. back to Locked)\n        }\n    }\n\n    void HandleClosingState()\n    {\n        if (!animator.IsPlaying(\"Opened\") && !isLocked && rotationAngle < 360f)\n        {\n            // Play slam audio\n            if (!string.IsNullOrEmpty(slamAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().PlayClip(slamAudio);\n\n            animator.SetInteger(\"Rotation\", -6f * Time.deltaTime); // Close at -6 deg/s for 540 deg (10s)\n            yield return null;\n            float closeTime = 10f;\n            while (rotationAngle < -0.1f || rotationAngle > 359.9f && closeTime > 0)\n            {\n                rotationAngle += (-6f) * Time.deltaTime; // Negative for closing direction\n                closeTime -= Time.deltaTime;\n                yield return null;\n            }\n\n            if (!string.IsNullOrEmpty(slamAudio))\n                GameObject.FindGameObjectWithTag(\"Audio\").GetComponent<AudioSource>().StopClip();\n\n            isLocked = true; // After closing, lock again unless player has key\n\n            // Optionally set emission color to Closing state\n            SetEmissionColor(emissionColorClosing);\n        }\n    }\n\n    void Handle LockedAgain()\n    {\n        if (isLocked && rotationAngle != 90f)\n            animator.SetInteger(\"EmissionColor\", 1); // Custom index for locked color\n            SetEmissionColor(emissionColorLocked);\n    }\n\n    void SetEmissionColor(string color)\n    {\n        // You must define custom integer states in your Animator if using SetInteger for colors\n        // Alternatively, use a state machine with emission color transitions manually\n        // For demonstration: Just log the color change\n        Debug.Log(\"Emission Color Set to \" + color);\n        // Or implement proper color blending if using shaders/materials\n    }\n\n    // Additional methods can be added here for more advanced behavior (e.g., player interaction checks)\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 6,
        "code_quality": 5,
        "completeness": 6,
        "best_practices": 6,
        "total": 30,
        "justification": "Direct approach with good state management, but incomplete implementation. Handles most requirements but lacks full rotation and state transition logic. Code becomes complex and hard to follow with multiple nested methods and state tracking."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 8,
        "completeness": 9,
        "best_practices": 9,
        "total": 43,
        "justification": "Robust implementation with clear separation of concerns, comprehensive state management, and more declarative behavior definition. Uses coroutines effectively, has better error handling, and provides more flexible state transitions."
      },
      "winner": "ir",
      "key_differences": [
        "IR approach uses a more declarative, data-driven state machine model",
        "IR generates more modular and maintainable code",
        "Oneshot approach relies more on direct imperative programming",
        "IR provides better abstraction and separation of behavioral logic"
      ],
      "advantages": [
        "More scalable code generation",
        "Clearer state transition logic",
        "Better separation of configuration and behavior",
        "More consistent error handling",
        "More flexible for future modifications"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 6,
    "prompt": "Create a bouncy ball that, every time it hits a surface, bounces higher than the previous bounce, plays a pitch that increases with each bounce, changes color based on bounce count, and leaves a temporary trail. After 10 bounces, it explodes into confetti particles while playing a celebration sound.",
    "timestamp": "2026-01-07T14:42:49.481805",
    "oneshot_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class BouncyBall : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    public float initialBounceHeight = 1f;\n    public float maxBounceMultiplier = 2f; // How much higher each bounce grows (capped)\n    private float currentBounceMultiplier = 1f;\n\n    [Header(\"Audio\")]\n    public AudioSource pitchSource;\n    public AudioClip celebrationSound;\n\n    [Header(\"Visuals\")]\n    public Color startColor;\n    public Color endColor;\n    public int colorSteps = 5;\n    public Text colorText;\n    public TrailRenderer trailRenderer;\n\n    [Header(\"Collision & Triggers\")]\n    public LayerMask groundLayerMask; // Set in editor to the layer your ground uses\n    public GameObject bounceEffectPrefab; // For temporary trail effect (optional)\n\n    private int bounceCount = 0;\n    private Vector3 lastImpactPosition;\n    private bool exploded = false;\n\n    void Start()\n    {\n        currentBounceMultiplier = initialBounceHeight;\n        ChangeColor(startColor);\n    }\n\n    void Update()\n    {\n        if (exploded) return;\n\n        // Optional: Animate color change over time or bounce count\n        // float t = Time.time * colorSteps;\n        // float progress = Mathf.Clamp01(t / (colorSteps * 2f));\n        // float r = Mathf.Lerp(startColor.r, endColor.r, progress);\n        // ... apply similarly for g and b\n\n        // Play pitch sound per bounce (can be in OnTriggerEnter or Update)\n        if (bounceCount % 5 == 0 && !exploded)\n            PitchPlay();\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (!exploded)\n        {\n            lastImpactPosition = transform.position;\n            var layerHit = other.gameObject.layer;\n\n            // Detect ground collision\n            if ((groundLayerMask & (1 << layerHit)) != 0) // Assume ground is on a specific layer\n            {\n                Bounce();\n                bounceCount++;\n                ChangeColor(bounceCount);\n                if (bounceCount >= 10)\n                {\n                    ExplodeAndStop();\n                }\n            }\n            else if (other.CompareTag(\"Player\") || other.CompareTag(\"Wall\")) // Optional: handle walls or player hits\n            {\n                Bounce();\n                bounceCount++;\n                ChangeColor(bounceCount);\n                if (bounceCount >= 10)\n                {\n                    ExplodeAndStop();\n                }\n            }\n\n            // Trail effect on impact\n            if (trailRenderer != null && !exploded)\n            {\n                GameObject trail = Instantiate(bounceEffectPrefab, lastImpactPosition, Quaternion.identity);\n                trail.transform.parent = transform;\n                trail.SetActive(true);\n                Destroy(trail, 2f); // Temporary trail\n            }\n\n            // Pitch sound on bounce (triggered by surface hit)\n            if (!pitchSource.isPlaying && !exploded)\n            {\n                pitchSource.PlayOneShot(new AudioSourceClipData(celebrationSound) { volume = 0.7f });\n            }\n        }\n    }\n\n    void Bounce()\n    {\n        currentBounceMultiplier *= Mathf.Min(maxBounceMultiplier, (1 + (bounceCount - 1) / (float)(colorSteps - 1)));\n        // Cap to avoid infinite growth\n        currentBounceMultiplier = Mathf.Clamp(currentBounceMultiplier, initialBounceHeight, maxBounceMultiplier * initialBounceHeight);\n\n        Vector3 jumpDirection = -(transform.forward * (transform.up * 0.8f + transform.right * 0.6f)); // Simple upward bounce direction\n        // Normalize and scale by current height for vertical velocity\n        float bounceVelocity = Mathf.Sqrt(currentBounceMultiplier * 9.8f * Time.deltaTime); // Simplified physics, adjust as needed\n        jumpDirection.y = -1; // Flip to upwards\n        jumpDirection.Normalize();\n        jumpDirection *= bounceVelocity;\n\n        transform.position += jumpDirection;\n        // Optionally: rotate the ball on bounce (e.g., Quaternion.Euler(0, 360*(bounceCount+1), 0))\n    }\n\n    void PitchPlay()\n    {\n        if (celebrationSound != null)\n        {\n            var newClip = celebrationSound.Clone();\n            newClip.pitch = 1.05f + (0.01f * (bounceCount / 5)); // Gradually increase pitch\n            newClip.PlayOneShot(newAudioSource: pitchSource);\n        }\n    }\n\n    void ChangeColor(int count)\n    {\n        if (colorText != null)\n        {\n            colorText.text = $\"Bounce: {count}\";\n        }\n\n        float t = Mathf.Clamp01((float)bounceCount / colorSteps); // 0 to 1 over steps\n        t = Mathf.Clamp(t, 0f, 1f);\n\n        float r = Mathf.Lerp(startColor.r, endColor.r, t);\n        float g = Mathf.Lerp(startColor.g, endColor.g, t);\n        float b = Mathf.Lerp(startColor.b, endColor.b, t);\n        Color newColor = new Color(r, g, b, startColor.a);\n\n        if (colorText != null) colorText.color = newColor;\n        if (trailRenderer != null) trailRenderer.color = newColor;\n        this.color = newColor;\n    }\n\n    void ExplodeAndStop()\n    {\n        exploded = true;\n\n        // Create confetti particles\n        ParticleSystem confetti = Instantiate GameObject.InstantiatePrefab(\"ConfettiPrefab\", transform);\n        confetti.transform.parent = transform;\n        confetti.Play();\n\n        // Play celebration sound if not already playing\n        if (!pitchSource.isPlaying)\n            pitchSource.PlayOneShot(new AudioSourceClipData(celebrationSound) { volume = 0.7f });\n\n        StopAll();\n    }\n\n    void StopAll()\n    {\n        if (pitchSource != null && pitchSource.isPlaying) pitchSource.Stop();\n        Destroy(gameObject);\n    }\n}",
    "ir_json": {
      "class_name": "BouncyBall",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "bounceMultiplier",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "pitchIndex",
          "type": "int",
          "default": 0
        },
        {
          "name": "bounces",
          "type": "int",
          "default": 0
        },
        {
          "name": "color",
          "type": "string",
          "default": "#FF0000"
        },
        {
          "name": "trailObject",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "BounceOnCollision",
          "trigger": "Collider hits ground and is tagged 'Surface'",
          "actions": [
            "increase bounceMultiplier by multiplying with 1.05",
            "apply force to Rigidbody in upward direction scaled by (bounceMultiplier * gravity)",
            "increment bounces by 1",
            "change color to #FF7F00 if bounces == 1, #FFFF00 if 2, #00FF00 if 3, else keep previous color",
            "create temporary trail GameObject as child of this with size scaled by bounceMultiplier and lifetime based on bounceMultiplier"
          ]
        },
        {
          "name": "PitchIncreaseOnBounce",
          "trigger": "After BounceOnCollision behavior completes and bounces > 0",
          "actions": [
            "play next audio clip from pitchIndex using AudioSource",
            "increase pitchIndex by 1 (mod number of available pitches)"
          ]
        },
        {
          "name": "ColorCycleEnd",
          "trigger": "bounces >= 10",
          "actions": [
            "destroy trailObject",
            "destroy this"
          ]
        },
        {
          "name": "ExplodeOnFinalBounce",
          "trigger": "At end of ColorCycleEnd or just before destruction if bounces < 10 but close to 10",
          "actions": [
            "Create multiple confetti particle systems as children of this object",
            "Play celebration sound using AudioSource"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\n[RequireComponent(typeof(AudioSource))]\n\npublic class BouncyBall : MonoBehaviour\n{\n    public string color = \"#FF0000\";\n    public float bounceMultiplier = 1.0f;\n    [SerializeField] private int pitchIndex = 0;\n    public int bounces = 0;\n    [SerializeField] private Color ballColor;\n    public string colorPropertyName = \"color\";\n    [Tooltip(\"Optional: Trail GameObject to be used for bouncing effect\")]\n    public GameObject trailObject;\n\n    private Rigidbody rb;\n    private AudioSource audioSource;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        audioSource = GetComponent<AudioSource>();\n        if (ballColor == null) ballColor = new Color(new Color(\"#FF0000\").rgb);\n        SetBallColor();\n    }\n\n    void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Surface\"))\n        {\n            BounceOnCollision();\n        }\n    }\n\n    void BounceOnCollision()\n    {\n        bounces++;\n        float impactSpeed = rb.velocity.magnitude;\n        // Use Physics.gravity for Z axis, but no .magnitude on velocity since Vector3 has magnitude\n        Vector3 impulseForce = new Vector3(0f, -impactSpeed * bounceMultiplier * Physics.gravity.z, 0f);\n        rb.AddImpulse(impulseForce);\n\n        if (bounceMultiplier < 100f)\n            bounceMultiplier *= 1.05f;\n\n        SetBallColor();\n\n        if (!trailObject || trailObject == null)\n        {\n            TrailObject trail = new GameObject(\"BounceTrail\");\n            trail.transform.SetParent(transform);\n            trail.transform.localPosition = Vector3.zero;\n            MeshFilter meshFilter = trail.GetComponent<MeshFilter>();\n            if (meshFilter != null)\n                meshFilter.sharedMesh.scale = new Vector3(bounceMultiplier * 0.5f, bounceMultiplier * 0.5f, bounceMultiplier * 0.2f);\n            trailObject = trail;\n        }\n\n        PlayPitchAudio();\n    }\n\n    void PlayPitchAudio()\n    {\n        if (audioSource != null && pitchIndex < 4)\n        {\n            // Use AudioClipAsset or LoadAudio to play WAV files properly\n            var clip = AssetDatabase.LoadAudioFileAtPath(\"Sounds/Pitch\" + pitchIndex + \".wav\"); // Adjust path as needed\n            if (clip != null)\n                audioSource.PlayOneShot(clip);\n            else\n                Debug.LogWarning($\"No pitch sound found for index {pitchIndex}\");\n            pitchIndex = (pitchIndex + 1) % 4;\n        }\n    }\n\n    void SetBallColor()\n    {\n        switch (bounces)\n        {\n            case 1:\n                ballColor = Color.red;\n                break;\n            case 2:\n                ballColor = Color.orange;\n                break;\n            case 3:\n                ballColor = Color.yellow;\n                break;\n        }\n        if (ballColor != null)\n            GetComponent<Renderer>().material.color = ballColor;\n    }\n\n    void OnDrawGizmos()\n    {\n        if (trailObject != null)\n        {\n            Gizmos.color = Color.green;\n            // Use Vector3.zero and proper scaling\n            Gizmos.DrawLine(transform.position, transform.position + new Vector3(0f, bounceMultiplier * 1f, 0f));\n        }\n    }\n\n    void ColorCycleEnd()\n    {\n        if (bounces >= 10)\n        {\n            Destroy(trailObject);\n            Destroy(gameObject);\n        }\n    }\n\n    void ExplodeOnFinalOrNearFinalBounce()\n    {\n        if ((bounces >= 9 && bounces < 10) || (bounces >= 10))\n        {\n            CreateConfetti();\n            PlayCelebrationSound();\n        }\n    }\n\n    void CreateConfetti()\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            GameObject confetti = new GameObject(\"Confetti\" + i);\n            confetti.transform.SetParent(transform);\n            ParticleSystem ps = Instantiate(new ParticleSystem(\"ConfettiPS\"), transform.position, Quaternion.identity) as ParticleSystem;\n            if (ps != null)\n            {\n                ps.startNew()\n                    .duration(0.3f)\n                    .particleCount(50 + (int)(i * 20))\n                    .emissionRate(100f)\n                    .gravity(new Vector3(0f, 1f, 0f))\n                    .collideWithWorld(true);\n                ps.gameObject.transform.localScale = new Vector3(Random.Range(0.05f, 0.15f), Random.Range(0.05f, 0.15f), 0.5f);\n                ps.gameObject.transform.rotation = Quaternion.Euler(0f, (float)Random.NextDouble() * 180 - 90f, 0f);\n            }\n        }\n    }\n\n    void PlayCelebrationSound()\n    {\n        if (audioSource != null)\n        {\n            var wavClip = AssetDatabase.LoadAudioFileAtPath(\"Sounds/Celebration.wav\");\n            if (wavClip != null)\n                audioSource.PlayOneShot(wavClip);\n        }\n    }\n\n    class SoundClip\n    {\n        public static readonly string Path = \"Sounds/Celebration.wav\"; // Use .wav extension and proper path\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 8,
        "api_usage": 9,
        "code_quality": 7,
        "completeness": 8,
        "best_practices": 7,
        "total": 39,
        "justification": "Comprehensive implementation with detailed bounce mechanics, color changes, and sound progression. Strong use of Unity collision detection and physics. Some minor over-complexity in implementation."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 7,
        "code_quality": 8,
        "completeness": 7,
        "best_practices": 6,
        "total": 34,
        "justification": "More abstract approach with clear behavior definition, but less precise implementation. Some generated code looks incomplete or potentially problematic. Good structural intent but weaker execution."
      },
      "winner": "oneshot",
      "key_differences": [
        "OneShot approach provides more direct, explicit implementation",
        "IR approach offers more abstract, behavior-driven specification",
        "OneShot code is more immediately executable with fewer assumptions"
      ],
      "advantages": [
        "Direct translation of requirements into working code",
        "More precise physics and collision handling",
        "Better error handling and Unity API integration",
        "More granular control over bounce and visual mechanics"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 7,
    "prompt": "Make an object that floats upward when you're near it (within 5 units), but falls faster when you're far away. It plays a humming sound that gets higher pitched as it rises, and lower pitched as it falls. The object also rotates opposite to its vertical movement direction, and its scale pulses in sync with the audio frequency.",
    "error": "'bool' object has no attribute 'lower'",
    "timestamp": "2026-01-07T14:45:14.832079"
  },
  {
    "prompt_num": 8,
    "prompt": "Build a physics-based pendulum that swings naturally, but when it reaches the bottom of its swing, it applies an explosive force to any rigidbody it touches, plays a bell sound, and creates a shockwave particle effect. The pendulum's rope length can be adjusted, and the swing speed affects the volume of the bell sound.",
    "timestamp": "2026-01-07T14:45:15.180922",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Pendulum : MonoBehaviour\n{\n    [Header(\"Pendulum Settings\")]\n    public Transform pivot; // Assign in inspector or leave default to transform.position\n    [SerializeField] private float ropeLength = 2f;\n    public float swingSpeed = 5f; // Higher speed = louder bell\n\n    [Header(\"Collision & Effects\")]\n    public GameObject bellPrefab; // Bell object with a volume property\n    public ParticleSystem shockwavePrefab;\n    public LayerMask collisionLayer;\n\n    [Header(\"References\")]\n    public Rigidbody pendulumRigidbody; // Assign in inspector for physics simulation\n    public AudioSource bellSource;\n\n    private Transform bobTransform;\n    private Vector3 initialPosition;\n    private float angle = 0f; // In radians, 0 is hanging down\n\n    private bool isSwinging = false;\n\n    void Start()\n    {\n        // Setup pendulum\n        bobTransform = new Transform();\n        initialPosition = pivot.position + (Vector3 Down * ropeLength) + (new Vector3(0, Mathf.Sin(angle), 0) * ropeLength);\n        bobTransform.parent = transform;\n        bobTransform.localPosition = new Vector3(0f, Mathf.Sin(angle), 0f);\n        bobTransform.localRotation = Quaternion.identity;\n\n        // Optional: assign rigidbody if you want physics for the bob\n        if (pendulumRigidbody != null)\n            pendulumRigidbody = GetComponent<Rigidbody>() ?? pivot.GetComponent<Rigidbody>();\n    }\n\n    void Update()\n    {\n        float time = Time.deltaTime;\n        float rotationChange = swingSpeed * time; // Angular velocity over delta\n\n        if (!isSwinging) return;\n\n        angle += rotationChange;\n        angle = Mathf.Clamp(angle, -Mathf.Deg2Rad, Mathf.Deg2Rad); // Restrict to 0-π range\n        UpdatePendulumPosition();\n    }\n\n    void FixedUpdate()\n    {\n        if (isSwinging)\n        {\n            // Apply gravity manually for more control (optional but realistic)\n            if (pendulumRigidbody != null)\n                pendulumRigidbody.gravityScale = 1f; // Default, Unity handles it\n            // Use physics forces if you want damping or drag\n        }\n\n        // Optional: check for collision every few frames to trigger effects at bottom\n        if (IsAtBottom())\n        {\n            CheckForCollisionsAndTriggerEffects();\n        }\n    }\n\n    void OnDrawGizmos()\n    {\n        // Draw rope visual in editor (optional)\n        if (pivot != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(pivot.position, initialPosition);\n        }\n    }\n\n    void UpdatePendulumPosition()\n    {\n        bobTransform.localPosition = new Vector3(\n            Mathf.Cos(angle) * ropeLength,\n            -Mathf.Sin(angle) * ropeLength + pivot.position.y, // Center at pivot's y\n            0f\n        );\n        bobTransform.localRotation = Quaternion.Euler(0f, (float)(angle * 180f / Math.PI), 0f);\n    }\n\n    bool IsAtBottom()\n    {\n        return Mathf.Abs(angle) < Mathf.Deg2Rad && // Within small tolerance of straight down\n               (bobTransform.localPosition.y - pivot.position.y) < 0.01f; // Allowing for rope length\n    }\n\n    void CheckForCollisionsAndTriggerEffects()\n    {\n        if (bellPrefab != null)\n        {\n            // Detect lowest point by checking vertical velocity or position\n            float bobY = bobTransform.localPosition.y;\n            if (bobY <= pivot.position.y - 0.05f && !isSwinging) // Rough check, improve with velocity if needed\n            {\n                // Play bell sound with volume based on swing speed\n                if (bellSource != null)\n                {\n                    float bellVolume = Mathf.Pow(swingSpeed, 1.5f); // Higher speed = louder\n                    bellVolume = Mathf.Clamp01(bellVolume);\n                    bellSource.volume = new Volume { volume = bellVolume };\n                    bellSource.Play();\n                }\n            }\n        }\n\n        if (shockwavePrefab != null)\n        {\n            // Find colliding objects at the bottom using a broad phase check\n            Collider[] hits = Physics.OverlapSphere(new Vector3(bobTransform.position), 0.1f, collisionLayer);\n            foreach (var hit in hits)\n            {\n                if (hit.CompareTag(\"Rigidbody\") || hit.CompareTag(\"Player\") || hit.CompareTag(\"Enemy\")) // Adjust tag logic as needed\n                {\n                    CreateShockwave(hit.transform);\n                }\n            }\n        }\n    }\n\n    void CreateShockwave(Transform target)\n    {\n        if (shockwavePrefab != null)\n        {\n            GameObject shock = Instantiate(shockwavePrefab, target.position, Quaternion.identity, transform hierarchy);\n            // Optionally set direction or force for the shockwave\n        }\n    }\n\n    // Optional: Add a method to manually reset swing for testing\n    public void ResetSwing()\n    {\n        angle = 0f;\n        UpdatePendulumPosition();\n        isSwinging = false;\n    }\n}",
    "ir_json": {
      "class_name": "PendulumSwingWithExplosion",
      "components": [
        "Rigidbody",
        "Transform"
      ],
      "fields": [
        {
          "name": "rope_length",
          "type": "float",
          "default": 2.5
        },
        {
          "name": "swing_speed",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "is_active",
          "type": "bool",
          "default": true
        }
      ],
      "behaviors": [
        {
          "name": "Swing",
          "trigger": "VerticalVelocity Magnitude Exceeds Threshold AND HorizontalVelocity Nonzero",
          "actions": [
            "Apply Force (direction = -Cross(HorizontalVelocity, Gravity), magnitude = swing_speed * mass)",
            "Update Position using Rigidbody position + velocity * Time.deltaTime"
          ]
        },
        {
          "name": "Detect Bottom",
          "trigger": "VerticalPosition <= RopeLength AND VerticalVelocity < 0.1",
          "actions": [
            "Find Nearest Rigidbody Within (rope_length * 2) units",
            "If found, for each Rigidbody: Apply Force (direction = Up, magnitude = 50 + swing_speed)",
            "Play Sound (name: \"PendulumBell\", volume = swing_speed/100.0)",
            "Spawn Particle System (name: \"Shockwave\", start immediately)"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class PendulumSwingWithExplosion : MonoBehaviour\n{\n    public float rope_length = 2.5f;\n    public float swing_speed = 10.0f;\n    [SerializeField] private bool is_active = true;\n\n    private Rigidbody rb;\n    private Transform pivot;\n    private Vector3 gravity = new Vector3(0, -1, 0);\n    private Vector3 position;\n    private Vector3 velocity;\n    private float lastSwingTime = 0.0f;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        pivot = transform;\n        position = pivot.position;\n    }\n\n    void Update()\n    {\n        if (!is_active) return;\n\n        // Calculate current velocity (from Rigidbody)\n        velocity = rb.velocity;\n        position += velocity * Time.deltaTime;\n\n        float vertMag = velocity.magnitude * Mathf.Sin(flatAngleToDegree(angleToFlat(velocity)));\n        float horzMag = velocity.magnitude * Mathf.Cos(flatAngleToDegree(angleToFlat(velocity)));\n\n        // Swing logic: swing if moving (horizontally) and has vertical velocity component\n        if (horzMag > 1e-6f && vertMag >= 0.05f)\n        {\n            float angleRad = flatAngleToDegree(angleToFlat(velocity)).ToRadians();\n            Vector3 localVel = new Vector3(\n                Mathf.Sin(angleRad) * vertMag,\n                Mathf.Cos(angleRad) * horzMag, // Note: this mixes axes but mimics \"swinging\"\n                0\n            );\n            // Force direction: -cross(HorizDir, gravity), proportional to mass (use rb.mass)\n            Vector3 forceDirection = -Vector3.Cross(localVel.normalized cross new Vector3(0,1,0).normalized, gravity.normalized);\n            float forceMag = swing_speed * rb.mass;\n            rb.AddForce(forceDirection * forceMag);\n        }\n\n        // Detect bottom\n        if (position.y <= rope_length + 1e-6f && velocity.y < -0.01f)\n        {\n            FindNearestRigidbodyBelow();\n        }\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        [Debug.DrawRay](Debug.DrawRay.html)(pivot.position, Vector3.up * (rope_length + 1), Color.red);\n    }\n\n    void FindNearestRigidbodyBelow()\n    {\n        float searchRadius = rope_length * 2f;\n        Collider[] hits = Physics.OverlapSphere(pivot.position, searchRadius, LayerMask.GetMask(\"Dynamic\"));\n        foreach (Collider col in hits)\n        {\n            if (col.CompareTag(\"PendulumPart\") || col.CompareTag(\"RopeEnd\")) // adjust tag as needed\n            {\n                Rigidbody rb2 = col.GetComponent<Rigidbody>();\n                if (rb2 != null && !rb2.isKinematic)\n                {\n                    Vector3 toSurface = pivot.position - rb2.centerOfMass;\n                    float dist = toSurface.magnitude;\n                    // If surface is close enough, apply upward force\n                    if (dist < 0.1f)\n                    {\n                        rb2.AddForce(Vector3.up * (50f + swing_speed), ForceMode.Impulse);\n                        Debug.Log(\"Bottom detected! Applying big upward push.\");\n                    }\n                }\n            }\n        }\n\n        // Explosion at pivot when bottom hit\n        if (rb != null && !is_active)\n        {\n            Vector3 explosionPos = pivot.position;\n            float radius = 1.2f;\n            rb.AddExplosionForce(30f, explosionPos, radius, 0.8f, ForceMode.Impulse);\n        }\n\n        // Sound and Particle (simulate for demo)\n        PlayPendulumBell();\n        SpawnShockwave();\n    }\n\n    void PlayPendulumBell()\n    {\n        if (AudioSource.PlayOneShot(new AudioSource(this) { volume = swing_speed / 100.0f, loop = false }, \"PendulumBell\")) != null;\n        // Optionally: Debug.Log(\"Bell played\");\n    }\n\n    void SpawnShockwave()\n    {\n        ParticleSystem shockwave = (ParticleSystem)Instantiate(Resources.Load<ParticleSystem>(\"Shockwave\"), pivot.position, Quaternion.identity);\n        if (shockwave)\n            shockwave.Play();\n    }\n\n    // Helper to get angle from velocity in degrees\n    float flatAngleToDegree(float f) { return Mathf.Atan2(f) * 180f / Mathf.PI; }\n    float degreeToFlat(float d) { return Mathf.Deg2Rad(d); }\n\n    // Get angle of vector in radians (flat, ignoring Z)\n    float angleToFlat(Vector3 v) { return Mathf.Atan2(v.x, v.y); }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 8,
        "code_quality": 6,
        "completeness": 5,
        "best_practices": 7,
        "total": 33,
        "justification": "The oneshot approach provides a detailed implementation with physics simulation and effect triggers. However, the code is incomplete (collision detection and some methods are cut off) and slightly over-complicated. Good use of Unity-specific attributes and physics concepts, but lacks some polish."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 9,
        "code_quality": 8,
        "completeness": 9,
        "best_practices": 8,
        "total": 43,
        "justification": "The IR-generated approach shows a more systematic and complete implementation. It provides a clean, concise solution with clear separation of concerns, comprehensive physics simulation, and all requested features fully implemented."
      },
      "winner": "ir",
      "key_differences": [
        "The IR approach uses a more abstract, declarative specification of behavior",
        "IR-generated code is more concise and follows a clear architectural pattern",
        "IR approach demonstrates better separation of physics simulation and effect triggering"
      ],
      "advantages": [
        "More modular and extensible code structure",
        "Clearer definition of component behaviors",
        "Better abstraction of physics and interaction logic",
        "More consistent implementation of requested features"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 9,
    "prompt": "Create a time bomb that beeps every second, with the beep frequency increasing as time runs down. The object's color pulses red in sync with beeps, and it shakes more violently as time decreases. After 10 seconds, it explodes with a massive force affecting all rigidbodies in a 20-unit radius, plays an explosion sound, and spawns fire particles that last 5 seconds.",
    "timestamp": "2026-01-07T14:46:33.864258",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class TimeBomb : MonoBehaviour\n{\n    [Header(\"Time Bomb Settings\")]\n    public float totalDuration = 10f; // Total time before explosion in seconds\n    public float beepIntervalBase = 1f; // Base interval between beeps (seconds)\n    public int maxBeepCount = 20;      // Cap for safety\n\n    [Header(\"Visual Effects\")]\n    public Color defaultColor;\n    public GameObject redPulseColor;   // Assign a material or colorable object in inspector\n\n    [Header(\"Shake Settings\")]\n    public float initialShakeIntensity = 0.05f;\n    public float maxShakeIntensity = 1f;\n    private float currentShakeStrength = initialShakeIntensity;\n\n    [Header(\"Explosion Effects\")]\n    public AudioSource explosionSound;\n    public GameObject fireParticlePrefab; // Assign in inspector\n    public float fireParticleLifetime = 5f;\n\n    private float timer = totalDuration;\n    private int beepCount = 0;\n    private bool isBeeping = true;\n    private float lastBeepTime = 0f;\n\n    void Start()\n    {\n        // Initialize color\n        if (redPulseColor != null && redPulseColor.GetComponent<Material>())\n            AssignRedPulseColor();\n        else\n            defaultColor = Color.red;\n\n        // Fire up the timer\n        StartCoroutine(StartTimer());\n    }\n\n    IEnumerator StartTimer()\n    {\n        while (timer > 0f)\n        {\n            yield return new WaitForSeconds(beepIntervalBase);\n\n            if (isBeeping && beepCount < maxBeepCount)\n            {\n                Beep();\n                UpdateShakeAndColor();\n                beepCount++;\n            }\n            else\n            {\n                // If beeps capped, just keep ticking for color/shake\n                UpdateShakeAndColor();\n            }\n\n            timer -= beepIntervalBase;\n        }\n\n        // Final shake and color pulse before explosion\n        UpdateShakeAndColor();\n\n        if (explosionSound != null)\n            explosionSound.Play();\n\n        // Trigger explosion effect\n        StartCoroutine(ExplosionRoutine());\n    }\n\n    void Beep()\n    {\n        if (lastBeepTime <= 0f)\n        {\n            Invoke(\"PlayBeepSound\", Mathf.Ceil/beepIntervalBase);\n            lastBeepTime = Time.time + beepIntervalBase;\n        }\n    }\n\n    void PlayBeepSound()\n    {\n        // Optional: play a local sound or use the AudioSource\n        if (explosionSound != null)\n            explosionSound.Play();\n        else\n            Debug.LogWarning(\"No audio source assigned for beep!\");\n    }\n\n    void UpdateShakeAndColor()\n    {\n        // Pulse color every second (synced with beeps, but can be adjusted)\n        float elapsed = Time.time - startTime;\n        if ((elapsed / 1f) % 2 == 0f && timer > 0f)\n            SetPulseColor();\n\n        currentShakeStrength = Mathf.Lerp(initialShakeIntensity, maxShakeIntensity,\n            (timer / totalDuration) * 2f); // From gentle to violent shake\n\n        transform.localEulerAngles = new Vector3(30f, 0f, 0f); // Example: shaking on Z axis\n        // Animate shake by setting velocity or using a script for acceleration\n        // For simplicity, we'll just set local rotation; more advanced would use Rb or physics\n    }\n\n    void SetPulseColor()\n    {\n        if (redPulseColor != null)\n            redPulseColor.GetComponent<Renderer>().material.color = Color.red;\n        else\n            GetComponent<Renderer>().material.color = Color.red;\n    }\n\n    IEnumerator ExplosionRoutine()\n    {\n        yield return new WaitForSeconds(0f); // Start explosion immediately after timer ends\n\n        float explosionRadius = 10f; // Half is 5, so full diameter 20 units as requested\n\n        // Affect all rigidbodies in radius\n        Collider[] colliders = Physics.OverlapSphere(transform.position, explosionRadius, LayerMask.GetMask(\"Rigidbody\"));\n        foreach (var col in colliders)\n            if (col.CompareTag(\"Rigidbody\"))\n                col.rigidbody.AddForce(Vector3.zero * -100f + Random.insideUnitSphere * 50f, ForceMode.Impulse);\n\n        // Spawn fire particles\n        for (int i = 0; i < 30 && Time.time < (fireParticleLifetime + 5f); i++)\n        {\n            Vector3 randomPos = transform.position + Random.insideUnitSphere * 2f;\n            Instantiate(fireParticlePrefab, randomPos, Quaternion.identity);\n        }\n\n        // Optionally destroy self\n        Destroy(gameObject);\n    }\n\n    [System.Serializable]\n    public class Settings\n    {\n        public float beepIntervalBase = 1f;\n        public int maxBeepCount = 20;\n        public float initialShakeIntensity = 0.05f;\n        public float maxShakeIntensity = 1f;\n        public GameObject redPulseColor = null;\n    }\n\n    private float startTime = Time.time;\n\n    void Update()\n    {\n        // Pulse color every second (optional, fallback if coroutine not running)\n        if (timer <= 0f && !isBeeping)\n            SetPulseColor();\n    }\n}",
    "ir_json": {
      "class_name": "TimeBomb",
      "components": [
        "Rigidbody",
        "AudioSource",
        "Renderer",
        "Animator"
      ],
      "fields": [
        {
          "name": "timer",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "beepFrequency",
          "type": "float",
          "default": 440.0
        },
        {
          "name": "color",
          "type": "Vector4",
          "default": [
            1,
            0,
            0,
            1
          ]
        },
        {
          "name": "shakeStrength",
          "type": "float",
          "default": 0.5
        }
      ],
      "behaviors": [
        {
          "name": "TimerDecay",
          "trigger": "EverySecond",
          "actions": [
            {
              "updateBeepFrequency": "increase beepFrequency by -10"
            },
            {
              "pulseColor": "set color to [1,0,0,1] if not already"
            },
            {
              "increaseShake": "multiply shakeStrength by 1.2"
            }
          ]
        },
        {
          "name": "BeepSound",
          "trigger": "OnTimerTick",
          "actions": [
            {
              "play audio": "play beep sound (default: 440Hz) on AudioSource"
            }
          ]
        },
        {
          "name": "ColorPulseSynchronize",
          "trigger": "EverySecond",
          "actions": [
            {
              "syncShake": "align shakeStrength with timer countdown rate"
            },
            {
              "syncColor": "set color alpha to sin(timer/2 * π) + 0.5"
            }
          ]
        },
        {
          "name": "ExplosionAtFinish",
          "trigger": "When timer <= 0.01 (for smooth explosion)",
          "actions": [
            {
              "apply force": "apply -10000 * (transform.position normalized) to all rigidbodies within 20 units"
            },
            {
              "play sound": "play explosion sound on AudioSource"
            },
            {
              "spawn particles": "spawn fire particles at position, with duration 5 seconds and velocity upward"
            },
            {
              "destroy object": "destroy this GameObject"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeBomb : MonoBehaviour\n{\n    // IR-specified fields (auto-injected)\n    public Vector4 color = [1, 0, 0, 1];\n\n    [Header(\"Time Bomb Settings\")]\n    public float timer = 10.0f;\n    public float beepFrequency = 440.0f;\n    [SerializeField] private Vector4 pulseColor = new Vector4(1, 0, 0, 1);\n    [SerializeField] private float shakeStrength = 0.5f;\n\n    [Header(\"Audio & Visual Components\")]\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private Renderer renderer;\n\n    Animator animator;\n\n    void Start()\n    {\n        // Assign components if present\n        audioSource = GetComponent<AudioSource>();\n        renderer = GetComponent<Renderer>();\n\n        // Initialize Animator (if needed)\n        animator = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        // Timer decay logic every second\n        float t = Time.time;\n        timer -= Time.deltaTime * 0.5f; // Decays slowly over time\n\n        // Apply color pulse based on sin wave\n        pulseColor.a = Mathf.Sin(t / 2f * Mathf.Deg2Rad) + 0.5f;\n\n        // Synchronize shake strength with timer rate (optional, can be removed if unused)\n        if (timer > 0)\n            shakeStrength *= Mathf.Pow(1.2f, (1 - timer / 10f)); // Exponentially increase\n\n        // Timer tick: play beep sound\n        if (timer >= 0.01f) // Let's allow some visual/explosion time before explosion\n        {\n            if (audioSource != null)\n                audioSource.PlayOneShot(new AudioClip(\"UASynth\", new int[] {beepFrequency}, 44100, 1));\n            // Optionally animate or modulate beepFrequency here for more advanced effects\n\n            // Optional: Update color alpha smoothly\n            // pulseColor.a = Mathf.Sin(t * 2f + phase) + 0.5f;\n        }\n\n        // Handle shaking (visual effect)\n        if (renderer != null && shakeStrength > 0)\n        {\n            float angle = Time.time * shakeStrength * 6f; // Simple shake\n            transform.localRotation = Quaternion.Euler(0, angle, 0);\n        }\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        // Optional: Reset timer if player collides (specify as needed)\n        // If you want to reset on player collision:\n        // if (other.CompareTag(\"Player\")) Start();\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        // Optionally, detect specific trigger (e.g., player overlaps)\n        // For now, just handle the timer explosion\n        if (timer <= 0.01f)\n        {\n            ExplodeAtFinish();\n        }\n    }\n\n    void explodethread()\n    {\n        // Run explosion logic on a separate thread for smoothness\n        StartCoroutine(ExplosionCoroutine());\n    }\n\n    IEnumerator ExplosionCoroutine()\n    {\n        yield return new WaitForSeconds(0.01f);\n\n        ApplyExplosionEffect();\n        Destroy(gameObject);\n    }\n\n    private void ApplyExplosionEffect()\n    {\n        // Apply force to nearby objects within 20 units (using physics)\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 20f, LayerMask.GetMask(\"Everything\")); // Adjust layer mask as needed\n        foreach (var c in colliders)\n        {\n            if (c.CompareTag(\"Player\") || c.CompareTag(\"Enemy\")) // Only affect players/enemies for example\n            {\n                Rigidbody rb = c.GetComponent<Rigidbody>();\n                if (rb != null)\n                    rb.AddForce(transform.forward * -10000f, ForceMode.Impulse);\n            }\n        }\n\n        // Play explosion sound\n        if (audioSource != null && !audioSource.isPlaying)\n            audioSource.PlayOneShot(new AudioClip(\"Explosion\", new int[] { 8000 }, 44100, 1));\n\n        // Spawn fire particles (example code, replace with actual particle system)\n        ParticleSystem ps = Instantiate(ParticleSystem prefab or create one here);\n        ps.position = transform.position;\n        ps.gravityScale = 0f; // Disable gravity for upward velocity\n        ps.startSpeed = 20f;\n        ps.lifetime = 5f;\n        ps.startRotation = Quaternion.identity;\n        // Set velocity (example: upwards)\n        ps.velocity = new Vector3(0, 30f, 0);\n\n        // Destroy self\n        Destroy(gameObject);\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 6,
        "code_quality": 5,
        "completeness": 6,
        "best_practices": 5,
        "total": 29,
        "justification": "Mostly implements the core functionality, but has some incomplete implementations. Handles timer, beeping, and explosion mechanics, but code is somewhat cluttered and lacks some error handling."
      },
      "ir": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 8,
        "completeness": 9,
        "best_practices": 8,
        "total": 42,
        "justification": "Demonstrates a more structured and comprehensive approach. Better abstraction, clearer separation of concerns, and more robust implementation of the time bomb mechanics."
      },
      "winner": "ir",
      "key_differences": [
        "The IR approach uses a more systematic, declarative approach to defining component behavior",
        "IR method provides better separation between logic and implementation",
        "IR generates more modular and easily maintainable code",
        "Oneshot approach is more imperative and tightly coupled"
      ],
      "advantages": [
        "Better code generation through intermediate representation",
        "More flexible and extensible design",
        "Clearer separation of concerns",
        "More consistent handling of Unity component interactions",
        "Easier to modify and extend the time bomb behavior"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 10,
    "prompt": "Make a script that gradually transforms an object over 30 seconds: it smoothly rotates 360 degrees, scales from 1x to 2x and back, changes color through the rainbow spectrum, moves in a figure-8 pattern, and plays a continuous musical note that shifts pitch based on the current transformation phase. All transformations must be perfectly synchronized.",
    "timestamp": "2026-01-07T14:47:56.032427",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\nusing UnityEngine.UI; // For possible UI elements like Sliders\n\npublic class TransformAndSoundMorph : MonoBehaviour\n{\n    [Header(\"Transformation Parameters\")]\n    public float morphDuration = 30f; // Total time for full cycle in seconds\n    private float timer = 0f;\n    private float phase = 0f; // 0:Rotate, 1:ScaleUp, 2:ScaleDown, 3:Color\n\n    [Header(\"Rotation & Movement\")]\n    public Transform movePoint; // Target point for figure-8 movement (set in inspector)\n    public float figureEightSpeed = 10f;\n    Vector3 figureEightDirection = new Vector3(1f, 0f, 1f);\n    Vector3 currentPosition;\n\n    [Header(\"Color Animation\")]\n    System.Collections.Generic.List<Color> rainbowColors = new List<Color>\n    {\n        Color.red,\n        Color.orange,\n        Color.yellow,\n        Color.green,\n        Color.blue,\n        Color.purple\n    };\n    int colorIndex = 0;\n    float colorProgress = 0f;\n\n    [Header(\"Audio\")]\n    public AudioSource audioSource; // Assign in inspector or make static if using Unity's default\n    public AudioClip noteClip;      // Assign sound asset (e.g., a short C4 note)\n\n    void Start()\n    {\n        currentPosition = transform.position;\n        timer = 0f;\n        phase = 0f; // Start at rotation\n        colorProgress = 0f;\n        StartCoroutine(MorphRoutine());\n    }\n\n    IEnumerator MorphRoutine()\n    {\n        while (true)\n        {\n            if (timer >= morphDuration) // Reset for next cycle\n                timer = 0f;\n\n            UpdateTransformations();\n\n            yield return new WaitForSeconds(1f / 30f); // ~30 fps, approx 30 sec cycle\n            timer += Time.deltaTime;\n        }\n    }\n\n    void UpdateTransformations()\n    {\n        float t = timer / morphDuration; // 0..1 over the whole cycle\n\n        // Phase calculation (each phase is 8 seconds)\n        phase = (int)(t * 4f) % 4f;\n\n        switch (phase)\n        {\n            case when (0): // Rotate\n                Rotate(t);\n                break;\n            case when (1): // Scale up then down, centered at midpoint\n                Scale(t);\n                break;\n            case when (2): // Color shift\n                ColorShift(t);\n                break;\n            case when (3): // Figure-8 movement (repeat)\n                MoveFigureEight(t);\n                break;\n        }\n\n        // Color & Pitch Sync: Map phase to rainbow and pitch\n        Color currentColor = GetSynchronizedColor(t);\n        SetObjectColor(transform.gameObject, currentColor);\n\n        if (audioSource != null)\n        {\n            float pitchFactor = 1 + 0.5f * Mathf-abs(Mathf-sin(phase*6f)); // 0->1->3->0 over cycle for pitch\n            audioSource.pitch = 1f / (2f + pitchFactor); // higher pitch value means lower frequency (0.5 to 1)\n            NotePlay(currentColor, pitchFactor);\n        }\n    }\n\n    void Rotate(float t)\n    {\n        float angle = 360f * t; // 0..360 degrees\n        transform.rotation = Quaternion.Euler(0f, angle, 0f);\n    }\n\n    void Scale(float t)\n    {\n        float amt = Mathf-min(max(t-0.5f, 0f),1f); // -0.5 to +0.5 around center (0..1)\n        Vector3 originalScale = transform.localScale;\n        transform.localScale = new Vector3(1f + amt, 1f + amt, 1f + amt);\n    }\n\n    void ColorShift(float t)\n    {\n        colorProgress += (t/8f); // Each phase is 8 seconds\n        if (colorProgress >= rainbowColors.Count) colorProgress -= rainbowColors.Count;\n        colorIndex = (int)(colorProgress * rainbowColors.Count);\n        currentColor = rainbowColors[colorIndex % rainbowColors.Count];\n        ColorShiftSmooth(colorProgress);\n    }\n\n    void MoveFigureEight(float t)\n    {\n        // Figure-8: alternate direction every half cycle\n        float cycle = t / 2f; // Each half-cycle (15s each)\n        if (cycle % (morphDuration/4f) < morphDuration/8f) // first half\n            figureEightDirection.z *= -1;\n        currentPosition = MoveAlongFigureEight(cycle);\n        transform.position = Vector3.Lerp(currentPosition, movePoint.position, 1f - Mathf-abs(Mathf-cos(figureEightSpeed * cycle)) *0.5f); // Simple sinusoidal path\n    }\n\n    void ColorShiftSmooth(float progress)\n    {\n        // Animate color between current and next in the rainbow list (smooth)\n        int idx = (int)progress;\n        if (idx >= rainbowColors.Count) idx = 0;\n        Color fromColor = rainbowColors[idx];\n        Color toColor = rainbowColors[(idx+1)%rainbowColors.Count];\n        float blend = progress % 1f; // 0..1\n        transform.gameObject.color = Vector3.Lerp(fromColor, toColor, blend);\n    }\n\n    void SetObjectColor GameObject, Color c)\n    {\n        if (GameObject.GetComponent<Renderer>() != null)\n            GameObject.GetComponent<Renderer>().material.color = c;\n        else if (GameObject.hasComponent(typeof(Renderer))) // Fallback for custom renderers\n            ((Renderer)GameObject.GetComponent<RenderRoot>().renderer).color = c; // Not perfect but works in most cases\n    }\n\n    void MoveAlongFigureEight(float s)\n    {\n        float x = Mathf-Cos(s * figureEightSpeed) * 2f;\n        float z = Mathf-Sin(s * figureEightSpeed) * 2f;\n        return new Vector3(x, 0f, z);\n    }\n\n    // Helper to sync color and pitch (could be optimized, but keeps phase alignment)\n    Color GetSynchronizedColor(float t)\n    {\n        float phaseValue = (int)(t*4f) % 4f; // 0-3\n        return rainbowColors[phaseValue % rainbowColors.Count];\n    }\n\n    void NotePlay(Color color, float pitchFactor)\n    {\n        if (noteClip != null)\n        {\n            noteClip.pitch = 1f / (2f + pitchFactor);\n            noteClip.Play();\n            // Optionally stop after duration for one note, or loop as desired\n        }\n        else\n        {\n            Debug.LogWarning(\"Note clip not assigned. Assign an AudioClip to play sound.\");\n        }\n    }\n}",
    "ir_json": {
      "class_name": "TransformationOrchestration",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "duration\": \"30.0"
        },
        {
          "name": "rotationSpeed\": \"12.0"
        },
        {
          "name": "scaleStart\": \"1.0"
        },
        {
          "name": "scaleEnd\": \"2.0"
        },
        {
          "name": "colorPhase\": \"0.0"
        },
        {
          "name": "figureEightSpeedX\": \"10.0"
        },
        {
          "name": "figureEightSpeedY\": \"8.0"
        },
        {
          "name": "audioPitchShift\": \"50"
        }
      ],
      "behaviors": [
        {
          "name": "SynchronizedTransformation",
          "trigger": "Time reaches 30 seconds or user input",
          "actions": [
            "Apply rotation over time using rotationSpeed",
            "Smoothly scale object from scaleStart to scaleEnd and back to scaleStart within duration",
            "Lerp color through rainbow spectrum based on colorPhase (0-1 cycle)",
            "Move position in XZ plane with sinusoidal motion for figure-8 pattern: pos = (sin(t*π) * figureEightSpeedX, 0, cos(t*π)*figureEightSpeedY)",
            "Adjust AudioSource pitch by audioPitchShift percentage based on current scale value"
          ]
        },
        {
          "name": "ColorTransition",
          "trigger": "colorPhase increments every (duration/120) seconds",
          "actions": [
            "Set material color using HSL to (360*colorPhase, 1.0, 0.5)"
          ]
        },
        {
          "name": "AudioPitchShifting",
          "trigger": "At each animation step when scaling changes significantly",
          "actions": [
            "Calculate current scale factor, set AudioSource.pitch = min(2.0, basePitch * (currentScale - 1.0)/ (scaleEnd - 1.0)) where basePitch is original pitch"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\n[RequireComponent(typeof(AudioSource))]\npublic class TransformationOrchestration : MonoBehaviour\n{\n    public float duration = 30.0f;\n    public float rotationSpeed = 12.0f;\n    [SerializeField] private Transform transformComponent;\n    [SerializeField] private Material colorMaterial; // For color transitions (if needed)\n    [SerializeField] private AudioSource audioSource;\n\n    private Rigidbody rb;\n    private Vector3 position;\n    private Quaternion initialRotation;\n    private Color currentColor;\n    private float colorPhase = 0.0f;\n    private float figureEightTime = 0.0f;\n    private bool isSynchronized = true;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        transformComponent = transform ?? GetComponent<Transform>();\n        if (colorMaterial == null && transformComponent != null)\n            colorMaterial = transformComponent.material; // fallback, assign to first component's material\n        audioSource = GetComponent<AudioSource>();\n    }\n\n    void Update()\n    {\n        float t = Time.time / duration;\n        colorPhase += (1.0f / 120.0f) * Time.deltaTime;\n\n        if (isSynchronized)\n        {\n            HandleSynchronizedTransformation(t);\n        }\n\n        // Audio Pitch Shifting on significant scale change\n        float currentScale = GetCurrentLocalScale();\n        if (currentScale != 0 && Math.Abs(currentScale - 1.0f) > 0.01f)\n        {\n            AdjustAudioPitch(currentScale);\n        }\n\n        ApplyColorTransition();\n\n        figureEightTime += Time.deltaTime * 0.05f;\n    }\n\n    void HandleSynchronizedTransformation(float time)\n    {\n        if (time >= duration || Input.GetKeyDown(KeyCode.Space))\n        {\n            float elapsed = Mathf.Clamp(time % 1, 0, 1);\n            float phase = (elapsed * rotationSpeed) % 360f;\n\n            // Use localScale for pitch calculation instead of transform.gameObject\n            Vector3 localScale = GetLocalScale();\n            float currentScaleValue = localScale.x; // or use magnitude if you want\n\n            Quaternion targetRotation = Quaternion.Euler(0, phase, 0) * initialRotation;\n            transformComponent.rotation = Quaternion.Slerp(initialRotation, targetRotation, time);\n\n            // Scale: Figure-8 + smooth transition\n            float figureEightScale = GetFigureEightPosition(time);\n            Vector3 lerpScale = Vector3.Lerp(scaleComponent.startValue, scaleComponent.endValue, 2 * time);\n            lerpScale.x *= figureEightScale; // apply figure eight modulation to x (scale)\n            transformComponent.localScale = lerpScale;\n\n            position = new Vector3(\n                Mathf.Lerp(scaleComponent.startValue, scaleComponent.endValue, 2 * time) *\n                (Mathf.Sin(figureEightTime * rotationSpeed * 2f) * 10f + \n                 Mathf.Cos(figureEightTime * rotationSpeed * 2f) * 8f),\n                0,\n                Mathf.Lerp(scaleComponent.startValue, scaleComponent.endValue, 2 * time) *\n                  (Mathf.Sin(figureEightTime * rotationSpeed * 2f + Mathf.PI / 2f) * 8f)\n            );\n\n            currentColor = Color.HSLToRGB((360.0f * colorPhase) % 360.0f, 1.0f, 0.5f);\n            if (colorMaterial != null)\n                colorMaterial.color = currentColor;\n\n            float basePitch = audioSource.basePitch;\n            float scaledPitchFactor = Mathf.Clamp01((currentScaleValue - 1.0f) / (2.0f));\n            float adjustedPitch = basePitch * (1.0f + (audioPitchShift / 100.0f) * scaledPitchFactor);\n            audioSource.pitch = adjustedPitch;\n\n            figureEightTime = (figureEightTime + Time.deltaTime * rotationSpeed) % (2 * Mathf.PI);\n            if (time >= duration)\n                isSynchronized = false;\n        }\n    }\n\n    float GetLocalScale()\n    {\n        return transformComponent.localScale.x;\n    }\n\n    float GetFigureEightPosition(float time)\n    {\n        float cycle = 2f * Mathf.PI * (time / duration);\n        float xSpeed = figureEightSpeedX * (1 + GetLocalScale());\n        float ySpeed = figureEightSpeedY * (1 + GetLocalScale());\n        return (Mathf.Sin(cycle) * xSpeed + Mathf.Cos(cycle) * ySpeed) /\n               (xSpeed + ySpeed + 1e-6f);\n    }\n\n    void ApplyColorTransition()\n    {\n        if (colorMaterial != null)\n            colorMaterial.color = Color.HSLToRGB((360.0f * colorPhase) % 360.0f, 1.0f, 0.5f);\n    }\n\n    void AdjustAudioPitch(float currentScaleValue)\n    {\n        float base = audioSource.basePitch;\n        float scaleFactor = (currentScaleValue - 1.0f) / 2.0f; // from 0 to 1\n        float pitchAdjust = (audioPitchShift / 100.0f) * Mathf.Max(0, scaleFactor);\n        audioSource.pitch = base * (1.0f + pitchAdjust);\n    }\n\n    [SerializeField] private ScaleComponent scaleComponent;\n}\n\n// Note: If you don't have a ScaleComponent, create one as a helper or use transform.localScale directly.",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 7,
        "api_usage": 8,
        "code_quality": 6,
        "completeness": 7,
        "best_practices": 6,
        "total": 34,
        "justification": "Mostly correct implementation with comprehensive transformation logic, but some methods are incomplete and have syntax errors. Good use of coroutines and systematic approach to synchronizing transformations."
      },
      "ir": {
        "correctness": 8,
        "api_usage": 9,
        "code_quality": 8,
        "completeness": 9,
        "best_practices": 8,
        "total": 42,
        "justification": "More robust implementation with cleaner separation of concerns, better component management, and more precise transformation calculations. Demonstrates advanced Unity scripting techniques."
      },
      "winner": "ir",
      "key_differences": [
        "IR approach uses more modular and configurable design",
        "IR generates more optimized and type-safe code",
        "Oneshot approach relies more on manual implementation details",
        "IR uses intermediate representation for more predictable code generation"
      ],
      "advantages": [
        "More flexible component configuration",
        "Better separation of transformation logic",
        "More robust error handling",
        "Easier to extend and modify transformations",
        "Generates more idiomatic Unity/C# code"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 11,
    "prompt": "Create a visualizer that reacts to audio: when a sound plays, the object's scale increases proportionally to the audio volume, its color shifts based on the audio frequency (low = red, mid = green, high = blue), it rotates based on the audio waveform, and spawns particles that move outward in sync with the beat. The object should analyze the AudioSource's spectrum data in real-time.",
    "timestamp": "2026-01-07T14:50:29.548176",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class AudioVisualizer : MonoBehaviour\n{\n    [Header(\"Visual Settings\")]\n    public float scaleMultiplier = 1.2f; // How much to scale per decibel over baseline\n    public Color lowColor   = new Color(1f, 0f, 0f, 0.5f); // Red for low freq\n    public Color midColor  = new Color(0f, 1f, 0f, 0.7f); // Green for mid\n    public Color highColor = new Color(0f, 0f, 1f, 0.6f); // Blue for high\n\n    [Header(\"Particle Settings\")]\n    public ParticleSystem particleSystem;\n    public float particleSpeed = 8f;\n    public int maxParticles = 20;\n\n    private Vector3 lastPosition;\n    private float lastBeatTime = 0f;\n    private float rotationAngle = 0f;\n    private float waveformPhase = 0f;\n\n    [SerializeField] Transform transform;\n    [SerializeField] Rigidbody rb; // For scale inertia if needed\n    [SerializeField] Collider collider; // For trigger detection\n\n    void Start()\n    {\n        particleSystem.enabled = false; // Disable until triggered\n    }\n\n    void Update()\n    {\n        if (particleSystem == null) return;\n\n        float volume = GetAudioVolume();\n        float freq = GetAverageFrequency();\n\n        // Color shift based on frequency\n        Color c = ColorLerp(lowColor, highColor, freq / 2000f); // 20-20kHz approx\n\n        // Scale based on volume (relative to 0.5 for center)\n        float relVol = Mathf.Max(0f, (volume - 0.5f) * scaleMultiplier);\n\n        SetScale(new Vector3(relVol, relVol, relVol));\n\n        // Rotation: Map audio waveform to rotation\n        float waveform = GetWaveformPeak();\n        rotationAngle += (waveform - 0.5f) * Time.deltaTime * 100f; // Adjust sensitivity\n        transform.rotation = Quaternion.Euler(rotationAngle, 0f, 0f);\n\n        // Waveform phase for movement\n        waveformPhase += (waveform - 0.5f) * Time.deltaTime * 360f;\n\n        // Particle spawn/trigger on beat detection (simple approach)\n        if (IsBeatTime())\n        {\n            SpawnParticles();\n        }\n\n        // Optional: Smooth color transition over time for visual effect\n        // c = Color.Lerp(c, new Color(1-f,0,0), Time.deltaTime*5f);\n    }\n\n    float GetAudioVolume()\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource == null) return 0f;\n        return audioSource.volume * 2f - 1f; // Normalize to [-1,1]\n    }\n\n    float GetAverageFrequency()\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource == null || !audioSource.isPlaying) return 0f;\n\n        int samples = 128;\n        float totalFreq = 0f;\n        float samplePeriod = 1f / audioSource.sampleRate;\n        float timeStep = samplePeriod / samples; // For each sample\n        float[] buffer = new float[samples];\n\n        audioSource.GetSpectrumAtFrequency(0, samples, buffer); // Get spectrum data\n\n        for (int i = 0; i < samples; i++)\n        {\n            totalFreq += buffer[i] * (i + 0.5f) / samples; // Weighted average\n        }\n        return totalFreq / samples;\n    }\n\n    float GetWaveformPeak()\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource == null || !audioSource.isPlaying) return 0f;\n\n        int frames = 64;\n        float max = -float.MaxValue, sum = 0f;\n        for (int i = 0; i < frames; i++)\n        {\n            float[] buffer = new float[2];\n            audioSource.GetWaveData(buffer); // Read X (left-right), Y (volume)\n            float waveform = Mathf.Sqrt(buffer[0] * buffer[0] + buffer[1] * buffer[1]);\n            if (waveform > max) max = waveform;\n        }\n        return max;\n    }\n\n    bool IsBeatTime()\n    {\n        // Simple beat detection using envelope (attack/release)\n        float vol = GetAudioVolume();\n        float env = EnvelopeDetector.GetEnvelopePeak(vol); // Use Unity's built-in or DIY\n        if (env > 0.6f) return true; // Beat detected\n        return false;\n    }\n\n    void SpawnParticles()\n    {\n        particleSystem.enabled = true;\n        lastPosition = transform.position;\n        for (int i = 0; i < maxParticles; i++)\n        { \n            Particle p = Instantiate(particleSystem.gameObject, new Vector3(lastPosition.x + Random.Range(-5f, 5f), 0f, lastPosition.z + Random.Range(-5f, 5f)), transform.rotation);\n            p.transform.localEulerAngles = new Vector3(0f, (float)(Math.random()*360), 0f); // Random Y\n            p.GetComponent<ParticleMove>().direction = (transform.position - lastPosition).normalized;\n        }\n    }\n\n    class ParticleMove : MonoBehaviour\n    {\n        public Vector3 direction;\n        public float speed = particleSpeed;\n\n        void Update()\n        {\n            transform.position += direction * speed * Time.deltaTime;\n            if (transform.position.distanceTo(lastPosition) > 10f)\n                Destroy(gameObject);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "AudioVisualizer",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "scaleMultiplier",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "color",
          "type": "Vector3",
          "default": [
            1,
            1,
            1
          ]
        },
        {
          "name": "rotation",
          "type": "Transform",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "UpdateVisuals",
          "trigger": "OnAudioBufferEnd or OnAudioDataReceived",
          "actions": [
            "Calculate audio volume from AudioSource.volume",
            "Calculate dominant frequency from audio spectrum data (using FFT)",
            "Set object color based on frequency: <0.5Hz->red, 0.5-2kHz->green, >2kHz->blue",
            "Update scale by multiplying with (volume * scaleMultiplier)",
            "Compute waveform envelope from current buffer for rotation input",
            "Apply rotation using sine of waveform peak index",
            "Spawn particles: for each beat detected in the audio, create a ParticleSystem at position + direction * amplitude",
            "Set particle system's speed and lifetime based on beat strength"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class AudioVisualizer : MonoBehaviour\n{\n    public Vector3 color = new Vector3(1f, 1f, 1f);\n    public Transform rotation;\n\n    [SerializeField] private float scaleMultiplier = 1.0f;\n    [SerializeField] private Color currentColor;\n    [SerializeField] private Transform rotationTarget;\n    [SerializeField] private ParticleSystem[] particleSystems;\n\n    private AudioSource audioSource;\n\n    void Start()\n    {\n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null)\n        {\n            Debug.LogError(\"AudioVisualizer must be attached to an object with an AudioSource.\");\n            return;\n        }\n\n        currentColor = new Color(1f, 1f, 1f);\n        rotationTarget = transform;\n    }\n\n    void Update()\n    {\n        if (!audioSource.isPlaying || audioSource == null)\n            return;\n\n        // Use AudioSource.volume for current volume\n        float currentVolume = audioSource.volume;\n\n        // Compute FFT (must implement proper FFT in real code)\n        float dominantFrequency = 0.0f; // Placeholder, should be replaced with actual FFT logic\n        if (TryGetFftDataAndFrequency(out float[] fftData, out float freq))\n        {\n            dominantFrequency = freq;\n        }\n\n        Color freqColor;\n        if (dominantFrequency < 0.5f)\n            freqColor = new Color(1f, 0f, 0f);\n        else if (dominantFrequency > 2000f)\n            freqColor = new Color(0f, 0f, 1f);\n        else\n            freqColor = new Color(0f, 1f, 0f);\n\n        currentColor = Vector3.Lerp(currentColor.rgb, freqColor.rgb, Time.deltaTime * 0.5f);\n\n        float newScale = Mathf.Clamp(currentVolume * scaleMultiplier, 0.1f, 2.0f);\n        transform.localScale = new Vector3(newScale) * Vector3.one;\n\n        // No AudioSource.currentData in Unity; use audioSource to read data when playing\n        if (audioSource.isPlaying && audioSource.data != null && audioSource.data.length > 0)\n        {\n            float[] samples = new float[audioSource.data.samples];\n            audioSource.GetSampleData(samples);\n            int nSamples = samples.Length;\n\n            // Simple envelope estimation (use first sample for demo)\n            waveformPeakIndex = (samples[0] > 0.5f) ? (float)nSamples / 2 : 0;\n        }\n\n        if (rotationTarget != null && audioSource.data != null && audioSource.data.length > 0)\n        {\n            float t = (waveformPeakIndex / (float)samples.Length) * Mathf.PI;\n            rotationTarget.rotation = Quaternion.Euler(0, (int)(Math.Sin(t) * 30f), 0);\n        }\n\n        // Beat detection for particle spawning\n        if (audioSource.isPlaying && audioSource.data != null && audioSource.data.length > 0)\n        {\n            float sampleLevel = samples[0];\n            if (sampleLevel > 0.3f)\n            {\n                // Very basic beat timer logic\n                if (Time.unscaledDeltaTime * currentVolume >= 0.5f)\n                {\n                    // Spawn particle system\n                    for (int i = 0; i < particleSystems.Length; i++)\n                    {\n                        if (!particleSystems[i].enabled)\n                        {\n                            ParticleSystem ps = new ParticleSystem();\n                            ps.startNew();\n                            ps.position = transform.position + Vector3.up * currentVolume * 2f;\n                            ps.particleColor = currentColor;\n                            ps.lifetime = 1.5f;\n                            ps.speed = 10f;\n                            particleSystems[i] = ps; // Or assign as needed\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Placeholder for FFT helper (must implement actual FFT)\n    private bool TryGetFftDataAndFrequency(out float[] fftData, out float freq)\n    {\n        // In real code: compute FFT and fill in values here.\n        // For now, just return dummy\n        fftData = null;\n        freq = 0.0f;\n        return false;\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 7,
        "completeness": 8,
        "best_practices": 7,
        "total": 39,
        "justification": "Comprehensive implementation with detailed audio analysis methods. Handles spectrum, volume, and waveform extraction with granular control. Includes explicit frequency-based color mapping and scale transformation."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 5,
        "code_quality": 5,
        "completeness": 6,
        "best_practices": 4,
        "total": 26,
        "justification": "Somewhat abstract implementation with placeholder methods. Lacks robust audio spectrum analysis. Relies on oversimplified frequency and volume calculations. Contains several unimplemented methods and theoretical placeholders."
      },
      "winner": "oneshot",
      "key_differences": [
        "OneShot approach provides explicit, concrete implementation of audio visualization techniques",
        "OneShot has more granular audio spectrum and waveform analysis",
        "IR approach is more conceptual and lacks specific Unity-specific optimizations"
      ],
      "advantages": [
        "Direct, readable implementation",
        "Explicit audio data extraction methods",
        "More robust error handling",
        "Closer alignment with Unity audio processing patterns",
        "More precise visual transformation logic"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 12,
    "prompt": "Make a singing crystal that, when touched, plays a sequence of 5 musical notes in a chord progression. Each note lights up a different part of the crystal (top, middle, bottom, left, right), and the entire crystal pulses with the rhythm. After the sequence completes, it plays a final harmonious note and creates a burst of light particles.",
    "timestamp": "2026-01-07T14:52:23.957471",
    "oneshot_code": "using System.Collections;\nusing UnityEngine;\n\npublic class SingingCrystal : MonoBehaviour\n{\n    [Header(\"Musical Settings\")]\n    public float beatDuration = 0.2f; // Time each note lasts (seconds)\n    public int notesInSequence = 5;\n    public Chord[] chordProgression; // Assign in Inspector: array of Chord structs or use arrays of note frequencies\n\n    [Header(\"Visual & Audio Components\")]\n    [SerializeField] private Transform topLight;\n    [SerializeField] private Transform middleLight;\n    [SerializeField] private Transform bottomLight;\n    [SerializeField] private Transform leftLight;\n    [SerializeField] private Transform rightLight;\n\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private ParticleSystem burstParticleSystem;\n\n    int currentNoteIndex = 0;\n\n    void Start()\n    {\n        // Initialize\n        if (audioSource == null) audioSource = GetComponent<AudioSource>();\n        if (burstParticleSystem == null) burstParticleSystem = GetComponent<ParticleSystem>();\n\n        StartCoroutine(PlaySequence());\n    }\n\n    IEnumerator PlaySequence()\n    {\n        while (currentNoteIndex < notesInSequence)\n        {\n            // Play the current chord/note\n            PlayChordAndPulse();\n\n            // Advance to next note after beatDuration\n            yield return new WaitForSeconds(beatDuration);\n\n            currentNoteIndex++;\n        }\n\n        // Final harmonious note and light burst\n        PlayFinalHarmony();\n        yield return new WaitForSeconds(0.1f); // Short pause before effects end\n        StopAllCoroutines(); // Optional: stop any other coroutines if needed\n    }\n\n    void PlayChordAndPulse()\n    {\n        if (currentNoteIndex >= chordProgression.Length) return;\n\n        var chord = chordProgression[currentNoteIndex];\n\n        // Play the chord notes as a sequence (simple approach: play all at once, or staggered)\n        foreach (var freq in chord.Frequencies)\n        {\n            audioSource.PlayOneShot(new SoundClip(freq), 0.05f * currentNoteIndex); // Adjust timing for effect\n        }\n\n        // Pulse animation (example: scale up and down on the whole object)\n        transform.localScale = Vector3.one * (1 + 0.2f * Mathf.Sin(Time.time * 5f));\n        yield return null;\n\n        // Light up specific parts\n        ShowLightElements(chord.NoteIndex); // Map chord index to light order if needed\n\n        audioSource.Play(); // If you want continuous playback, otherwise use PlayOneShot above\n    }\n\n    void ShowLightElements(int whichPart)\n    {\n        switch (whichPart)\n        {\n            case 0: topLight.gameObject.SetActive(true); break;\n            case 1: middleLight.gameObject.SetActive(true); break;\n            case 2: bottomLight.gameObject.SetActive(true); break;\n            case 3: leftLight.gameObject.SetActive(true); break;\n            case 4: rightLight.gameObject.SetActive(true); break;\n            default: { }\n        }\n    }\n\n    // Helper: Assume Chord struct is a list of frequencies (for simplicity)\n    struct Chord\n    {\n        public int[] Frequencies; // e.g. [261, 329, 392] for C-E-G major triad\n        public int NoteIndex;\n    }\n\n    void PlayFinalHarmony()\n    {\n        if (chordProgression != null && chordProgression.Length > 0)\n        {\n            var finalChord = chordProgression[notesInSequence % chordProgression.Length]; // Loop or end\n            foreach (var freq in finalChord.Frequencies)\n            {\n                audioSource.PlayOneShot(new SoundClip(freq), 0.2f);\n            }\n\n            // Burst of light particles\n            burstParticleSystem.Play();\n        }\n    }\n\n    // Helper to create a simple SoundClip\n    class SoundClip :MonoBehaviour\n    {\n        public float frequency;\n        public float duration = 0.15f;\n\n        public void Start()\n        {\n            // Use Unity's built-in tone generator for demonstration (not recommended for production)\n            var audio = new AudioSource();\n            audio.frequency = frequency * 1000; // Hz to samples\n            audio.duration = duration * Time.deltaTime;\n            audio.start();\n        }\n    }\n\n    // Optionally, add event handlers for touching the crystal:\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Hand\"))\n        {\n            StopAllCoroutines(); // Reset so sequence starts fresh on touch\n            Start();\n        }\n    }\n\n    void OnTriggerExit(Collider other)\n    {\n        // Optional: stop audio/particles when released\n        if (audioSource.isPlaying) audioSource.Stop();\n        if (burstParticleSystem != null && burstParticleSystem.isPlaying) burstParticleSystem.Stop();\n    }\n\n    void Update()\n    {\n        // No additional logic needed unless you want visual rhythm indicators, etc.\n    }\n}",
    "ir_json": {
      "class_name": "SingingCrystal",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "position",
          "type": "Vector3",
          "default": [
            0,
            1,
            0
          ]
        },
        {
          "name": "scale",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "noteSequence",
          "type": "string",
          "default": ""
        }
      ],
      "behaviors": [
        {
          "name": "OnTouched",
          "trigger": "physics.rigidbody.isTriggered && (touching object)",
          "actions": [
            {
              "name": "playFirstNote",
              "parameters": {
                "note": "C4",
                "channel": 0
              }
            },
            {
              "name": "lightPartTop",
              "params": {
                "color": [
                  1,
                  1,
                  1
                ],
                "duration": 0.2
              }
            },
            {
              "name": "scheduleNextBeat",
              "params": {
                "delay": 0.5
              }
            },
            {
              "name": "playSecondNote",
              "parameters": {
                "note": "E4",
                "channel": 1
              }
            },
            {
              "name": "lightPartMiddle",
              "params": {
                "color": [
                  0,
                  255,
                  0
                ],
                "duration": 0.2
              }
            },
            {
              "name": "scheduleNextBeat",
              "params": {
                "delay": 0.5
              }
            },
            {
              "name": "playThirdNote",
              "parameters": {
                "note": "G4",
                "channel": 2
              }
            },
            {
              "name": "lightPartBottom",
              "params": {
                "color": [
                  255,
                  0,
                  0
                ],
                "duration": 0.2
              }
            },
            {
              "name": "scheduleNextBeat",
              "params": {
                "delay": 0.5
              }
            },
            {
              "name": "playFourthNote",
              "parameters": {
                "note": "C5",
                "channel": 0
              }
            },
            {
              "name": "lightPartLeft",
              "params": {
                "color": [
                  100,
                  100,
                  255
                ],
                "duration": 0.2
              }
            },
            {
              "name": "scheduleFinalBeat"
            },
            {
              "name": "playFifthNote",
              "parameters": {
                "note": "G#4",
                "channel": 3
              }
            },
            {
              "name": "lightPartRight",
              "params": {
                "color": [
                  200,
                  100,
                  50
                ],
                "duration": 0.2
              }
            },
            {
              "name": "finishSequence"
            },
            {
              "name": "playHarmoniousFinaleNote",
              "parameters": {
                "note": "A4",
                "channel": 4
              }
            },
            {
              "name": "emitLightBurst",
              "params": {
                "particles": "Explosion",
                "count": 50
              }
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class SingingCrystal : MonoBehaviour\n{\n    [SerializeField] private Rigidbody rb;\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private Vector3 position = new Vector3(0, 1, 0);\n    [SerializeField] private float scale = 1.0f;\n    [SerializeField] private string noteSequence;\n\n    void Start()\n    {\n        if (string.IsNullOrEmpty(noteSequence))\n            noteSequence = \"C4-E4-G4-C5-G#4-A4\";\n    }\n\n    void Update()\n    {\n        // Optional: Remove if not needed\n        // if (rb.isTriggered) PlayNoteSequence();\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Self\") && !other.gameObject.isPrefabRoot)\n            PlayNoteSequence();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        GizmoUtility.ApplyGizmoInfo(this, new Gizmo() { color = Color.white });\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"PartTop\") || other.CompareTag(\"PartMiddle\")\n            || other.CompareTag(\"PartBottom\") || other.CompareTag(\"PartLeft\")\n            || other.CompareTag(\"PartRight\"))\n        {\n            LightAndPlayBeats();\n        }\n    }\n\n    private void LightAndPlayBeats()\n    {\n        // Use Color32 for gizmos if needed, but use Color here as it's simpler\n        DrawLightGizmo(transform.root, \"Top\", Color.white, 0.2f);\n        DrawLightGizmo(transform.root, \"Middle\", Color.green, 0.2f);\n        DrawLightGizmo(transform.root, \"Bottom\", Color.red, 0.2f);\n        DrawLightGizmo(transform.root, \"Left\",   Color.aqua, 0.2f);\n        DrawLightGizmo(transform.root, \"Right\",  Color.yellow, 0.2f);\n\n        ScheduleFinalBeat();\n    }\n\n    private void DrawLightGizmo(Transform parent, string partName, Color color, float duration)\n    {\n        // GizmosUtility.CreateMeshGridPart is not valid for drawing spheres.\n        // Instead, use GizmoUtility to draw a simple sphere as a visual gizmo\n        GameObject gizmo = new GameObject(\"LightGizmo\" + partName);\n        gizmo.transform.SetParent(parent);\n\n        MeshFilter mesh = gizmo.AddComponent<MeshFilter>();\n        MeshRenderer renderer = gizmo.AddComponent<MeshRenderer>();\n        renderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n        renderer.SetColor(\"_Color\", color);\n        renderer.SetSize(0.3f, 0.3f); // Dummy size for sphere\n        renderer.SetPosition(gizmo.transform.position);\n\n        // Optionally: Use a simple sphere mesh if you want to be more precise\n        Mesh sphereMesh = new Mesh();\n        sphereMesh.vertices = new float[] {\n            -0.5f, -0.5f,  0,\n             0.5f, -0.5f,  0,\n             0,    0.5f,  0,\n             0,   -0.5f,  0,\n             0,     0,  1,\n             0,     0, -1\n        };\n        sphereMesh.triangles = new int[] {\n            0,1,2, 2,3,0, // front top left to right\n            4,5,6, 6,7,4, // back bottom right to left\n            2,4,5, 5,3,6, // etc (minimal for demo)\n        };\n        sphereMesh.RecalculateNormals();\n\n        renderer.mesh = sphereMesh;\n    }\n\n    private void ScheduleFinalBeat()\n    {\n        if (!rb.isKinematic)\n        {\n            audioSource.PlayOneShot(GenerateSoundBuffer(\"A4\"));\n            EmitLightBurst();\n        }\n    }\n\n    private void EmitLightBurst()\n    {\n        GameObject burst = new GameObject(\"Light Burst\");\n        burst.transform.position = transform.position;\n        burst.transform.rotation = Quaternion.identity;\n\n        // Use ParticleSystem for explosion instead of custom component\n        ParticleSystem explosion = Instantiate(new ParticleSystem(\"Burst\"), transform.position, Quaternion.identity)\n            ?.GetComponent<ParticleSystem>();\n\n        if (explosion != null)\n            explosion.Play();\n    }\n\n    private AudioClip GenerateSoundBuffer(string notes)\n    {\n        int sampleRate = 44100;\n        float noteDuration = 0.1f; // C4\n        float totalTime = 0.5f; // Default sequence length\n\n        if (!string.IsNullOrEmpty(notes))\n            totalTime = float.Parse(notes.Split('-')[0].Replace(\"C4\", \"\").Length > 0 ? (float)notes.Length * 0.15 : 1);\n\n        int channels = 1;\n        int lengthSamples = (int)Math.Ceiling(sampleRate * totalTime);\n        AudioClip clip = new Audioclip(); // Fixed: use AudioSource for play, but return Audioclip if needed\n        clip.sampleRate = sampleRate;\n        clip.Length = lengthSamples;\n\n        float currentTime = 0f;\n        int semistepsMap = new Dictionary<string, int>() {\n            { \"C4\", 48 }, { \"D4\", 52 }, { \"E4\", 56 },\n            { \"F4\", 64 }, { \"G4\", 72 }, { \"A4\", 80 }, { \"B4\", 88 },\n            { \"C5\", 96 }, { \"D5\", 104 }, { \"E5\", 112 },\n            { \"F5\", 120 }, { \"G#4\", 110 }, // approximate frequencies\n        };\n\n        foreach (var note in noteSequence.Split('-'))\n        {\n            int baseStep = semistepsMap.TryGetValue(note, out var freqIndex) ? freqIndex : 0; // Default C4 if not found\n            float freq = freqIndex / 12f * 440 + 220; // Simple approximation\n\n            float duration = (note == \"A4\") ? noteDuration : noteDuration * 1.5f;\n            int noteSamples = (int)Math.Ceiling(sampleRate * duration);\n\n            float[] samples = new float[noteSamples];\n            for (int i = 0; i < noteSamples; i++)\n            {\n                float t = (i / (float)noteSamples) * duration - duration/2f;\n                if (t < 0 || t >= duration)\n                    continue;\n                samples[i] = (float)Math.Sin(2 * Mathf.PI * freq * (currentTime + t / sampleRate));\n            }\n            clip.AddBuffer(new Float32Array(samples), 0, channels, noteSamples);\n            currentTime += duration;\n        }\n\n        return clip;\n    }\n\n    private float GetNoteFreq(string note)\n    {\n        int baseNote = note[0] - 'C' + 1; // C=0\n        int accidental = 0;\n        if (note.Length > 1 && note[1] == '#') accidental += 1;\n        if (note.Length >=3 && char.IsDigit(note[2])) accidental = int.Parse(note.Substring(2));\n\n        return 130f * (1 << ((baseNote + accidental) / 12));\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 8,
        "api_usage": 7,
        "code_quality": 6,
        "completeness": 7,
        "best_practices": 6,
        "total": 34,
        "justification": "Direct implementation captures most requirements. Strong use of coroutines and Unity components. Some complexity in chord/note handling, but fundamentally sound approach."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 5,
        "code_quality": 4,
        "completeness": 5,
        "best_practices": 3,
        "total": 23,
        "justification": "Intermediate representation approach introduces unnecessary complexity. Generated code is fragmented, contains incomplete implementations, and relies on non-existent utility methods."
      },
      "winner": "oneshot",
      "key_differences": [
        "Direct implementation vs code generation",
        "More explicit control flow in oneshot approach",
        "Better integration with Unity's component system"
      ],
      "advantages": [
        "More readable and maintainable code",
        "Direct use of Unity coroutines and component references",
        "Clearer musical sequence and lighting logic",
        "Less abstraction overhead"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 13,
    "prompt": "Build a pressure plate system: when weight is applied (detected via collision), it plays a click sound, changes color to green, and starts a 5-second timer. If weight is removed before 5 seconds, it resets. If weight stays for 5 seconds, it plays a success sound, spawns a reward object, and triggers all nearby pressure plates to also activate. Each pressure plate remembers how many times it's been activated.",
    "timestamp": "2026-01-07T14:54:41.967586",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Pressure Plate Settings\")]\n    public GameObject clickSoundPrefab; // Assign in inspector\n    public Color normalColor = Color brown;\n    public Color activeGreen = Color.green;\n    public int activationCountThreshold = 1; // How many activations to trigger the big event\n\n    [Header(\"Timer and Events\")]\n    public float timerDuration = 5f;\n    private float activationTimer = 0f;\n    private bool isBigEventTriggered = false;\n\n    [Header(\"References\")]\n    [SerializeField] private GameObject successSoundPrefab; // Optional, for success sound\n    [SerializeField] private GameObject rewardPrefab;     // Assign in inspector\n\n    [Tooltip(\"List of nearby pressure plates to trigger on big event (use tag or layer)\")]\n    public List<PressurePlate> nearbyPlates = new List<PressurePlate>();\n\n    [Header(\"State\")]\n    public int activationCount = 0;\n\n    void Start()\n    {\n        // Optionally: Assign sound and reward prefabs in inspector\n    }\n\n    void Update()\n    {\n        if (isBigEventTriggered)\n        {\n            // Reset timer when event is done\n            if (activationTimer <= 0f) \n            {\n                PlaySuccessSound();\n                SpawnReward();\n                // Trigger nearby plates here if needed, or already handled by propagation below\n                // Or loop through and trigger their activation (if desired)\n            }\n            else\n            {\n                activationTimer -= Time.deltaTime;\n            }\n        }\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        // Detect weight: assume the plate is on ground, and \"other\" is the object placed on it\n        if (IsWeightOnPlate(other))\n        {\n            ActivatePlate();\n        }\n    }\n\n    void OnTriggerExit(Collider other)\n    {\n        // Only reset timer if not in big event state\n        if (!isBigEventTriggered && activationTimer > 0f)\n        {\n            ResetPlate();\n        }\n    }\n\n    private bool IsWeightOnPlate(Collider other)\n    {\n        // Customize detection as needed (e.g., check layer, tag or component type for \"weight\")\n        // For example: only if the object has a Rigidbody and is on this collider\n        var rb = other.GetComponent<Rigidbody>();\n        if (rb != null && transform.parent == rb.gameObject.transform) \n            // This assumes plate is child of weight's rigidbody; adjust as needed\n            return true;\n        // Default to false unless you have a better check\n        return false;\n    }\n\n    void ActivatePlate()\n    {\n        activationCount++;\n        color = activeGreen;\n\n        if (activationCount >= activationCountThreshold)\n        {\n            StartBigEvent();\n        }\n        else\n        {\n            PlayClickSound();\n        }\n    }\n\n    void StartBigEvent()\n    {\n        isBigEventTriggered = true;\n        activationTimer = timerDuration;\n        // Optionally: Change color to indicate \"big event in progress\"\n        color = new Color(0, 1, 0.8f, 0.5f); // Orange for progress\n        Debug.Log(\"Pressure plate activated enough times! Big event starting.\");\n    }\n\n    void PlayClickSound()\n    {\n        if (clickSoundPrefab != null)\n        {\n            var sound = Instantiate(clickSoundPrefab, transform.position, Quaternion.identity);\n            sound.Play();\n        }\n    }\n\n    void PlaySuccessSound()\n    {\n        if (successSoundPrefab != null)\n        {\n            var sound = Instantiate(successSoundPrefab, transform.position, Quaternion.identity);\n            sound.Play();\n        }\n    }\n\n    void SpawnReward()\n    {\n        if (rewardPrefab != null)\n        {\n            var instance = Instantiate(rewardPrefab, transform.position, Quaternion.identity);\n            // You may want to add a tag or component so other plates can detect proximity\n        }\n    }\n\n    void ResetPlate()\n    {\n        color = normalColor;\n        activationCount = 0; // Optional: reset count per individual plate if desired\n        isBigEventTriggered = false;\n        activationTimer = 0f;\n    }\n}",
    "ir_json": {
      "class_name": "PressurePlate",
      "components": [
        "Collider",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "activationCount",
          "type": "int",
          "default": 0
        },
        {
          "name": "isActivated",
          "type": "bool",
          "default": false
        },
        {
          "name": "timerActive",
          "type": "bool",
          "default": false
        }
      ],
      "behaviors": [
        {
          "name": "OnCollisionEnter",
          "trigger": "Physics.OverlapSphere detects a collider with isTrigger == false and this Collider is not PressurePlate itself",
          "actions": [
            "play audio (audioAsset: ClickSound)",
            "set color to green (gameObject: this)",
            "set isActivated to true"
          ]
        },
        {
          "name": "UpdateTimer",
          "trigger": "gameTime <= 5.0 && isActivated",
          "actions": [
            "increase timerActive to true"
          ]
        },
        {
          "name": "DecrementTimerWhenReleased",
          "trigger": "Physics.OverlapSphere detects no collider in detection radius AND isActivated AND not timerActive",
          "actions": [
            "set timerActive to false",
            "if timer <= 5.0 then reset timer and set isActivated to false and reset activationCount to 0"
          ]
        },
        {
          "name": "OnTimerCompleted",
          "trigger": "timerActive == true && (gameTime >= 5.0 || collision detected that ends timer)",
          "actions": [
            "play audio (audioAsset: SuccessSound)",
            "instantiate (GameObject: RewardObject) at position (Vector3: this.transform.position)",
            "for each nearby PressurePlate (distance < 10f) do trigger OnCollisionEnter"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class PressurePlate : MonoBehaviour\n{\n    public int activationCount = 0;\n    [SerializeField] private bool isActivated = false;\n    [SerializeField] private bool timerActive = false;\n\n    private Rigidbody rb;\n    private AudioSource clickAudio;\n    private AudioSource successAudio;\n    private GameObject rewardObject;\n    private Collider[] overlapSphereResult;\n    private float timer = 5f;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        clickAudio = GetComponent<AudioSource>();\n        successAudio = FindObjectOfType<AudioSource>();\n        // Optionally set RewardObject in inspector\n    }\n\n    void Update()\n    {\n        if (timerActive)\n        {\n            // Decrement timer every frame while active\n            if (gameTime < timer)\n                timer -= Time.deltaTime;\n        }\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || !other.isTrigger && !other.CompareTag(\"PressurePlate\")) // Adjust tag logic as needed\n        {\n            if (!isActivated) \n            {\n                clickAudio.Play();\n                GetComponent<Renderer>().material.color = Color.green;\n                isActivated = true;\n                activationCount++;\n                if (activationCount >= 2)\n                {\n                    timerActive = true;\n                }\n            }\n        }\n    }\n\n    void OnTriggerExit(Collider other)\n    {\n        // Only reset timer if no collider is currently overlapping and plate is activated\n        if (!timerActive && isActivated && !Physics.OverlapSphere(this.transform.position, 0.1f, null).Length > 0)\n        {\n            DecrementTimerWhenReleased();\n        }\n    }\n\n    void OnTriggerStay(Collider other)\n    {\n        // Maintain timer while active\n        if (timerActive)\n        {\n            if (!Physics.OverlapSphere(this.transform.position, 0.1f, other.gameObject))\n                timer = 5f; // Reset timer if no contact detected in small radius\n        }\n    }\n\n    void DecrementTimerWhenReleased()\n    {\n        if (isActivated && !timerActive)\n        {\n            timerActive = false;\n            if (timer <= 0)\n            {\n                timer = 5f; // Refill for next activation or as per design\n                isActivated = false;\n                activationCount = 0;\n                // Optionally reset audio here if desired\n            }\n            else\n            {\n                timer -= Time.deltaTime;\n            }\n        }\n    }\n\n    void OnTimerCompleted()\n    {\n        if (timerActive)\n        {\n            successAudio.Play();\n            if (rewardObject != null)\n            {\n                Instantiate(rewardObject, transform.position, Quaternion.identity);\n            }\n\n            // Trigger nearby PressurePlates\n            overlapSphereResult = Physics.OverlapSphere(transform.position, 10f, null);\n            foreach (var hit in overlapSphereResult)\n            {\n                if (hit.CompareTag(\"Player\") || !hit.CompareTag(\"PressurePlate\"))\n                    hit.TriggerCollision(new Collider[1] { self = this });\n            }\n\n            isActivated = false;\n            activationCount = 0;\n            timerActive = false;\n        }\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 8,
        "api_usage": 7,
        "code_quality": 9,
        "completeness": 8,
        "best_practices": 8,
        "total": 40,
        "justification": "One-shot approach provides more explicit control, clear method decomposition, and comprehensive error handling. It has detailed comments and modular design with explicit methods for each behavior."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 5,
        "code_quality": 6,
        "completeness": 7,
        "best_practices": 6,
        "total": 30,
        "justification": "IR approach generates more generic code with less precise control. Some edge cases might be missed, and the implementation feels more mechanical than intentional."
      },
      "winner": "oneshot",
      "key_differences": [
        "One-shot approach allows more granular control over game logic",
        "Oneshot method has more explicit state management",
        "IR approach generates more generic, less tailored code"
      ],
      "advantages": [
        "More readable and maintainable code",
        "Better separation of concerns",
        "More explicit error handling",
        "Easier to debug and modify",
        "More idiomatic Unity C# implementation"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 14,
    "prompt": "Create a combo system: hitting an object once makes it glow yellow and play a low note. Hitting it again within 2 seconds makes it glow orange and play a higher note. A third hit within 2 seconds makes it glow red and play an even higher note. A fourth hit within 2 seconds creates an explosion effect, plays a victory sound, and spawns 5 bonus objects. Missing the 2-second window resets the combo.",
    "timestamp": "2026-01-07T14:55:41.631389",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class ComboSystem : MonoBehaviour\n{\n    [Header(\"Combo State\")]\n    public int currentCombo = 0;\n    [SerializeField] private float cooldownTimer = 0f;\n    [SerializeField] private float baseCoolDown = 2f;\n\n    // Hit levels and note frequencies (arbitrary, adjust as needed)\n    private const int notesPerLevel = 3; // Yellow:1, Orange:2, Red:3\n    private const float noteFrequencies[] = { 110f, 220f, 440f }; // C4, D4, E5\n\n    [Header(\"Visuals\")]\n    public GameObject yellowGlow;\n    public GameObject orangeGlow;\n    public GameObject redGlow;\n\n    [Header(\"Audio\")]\n    public AudioSource lowNoteSource;\n    public AudioSource highNoteSource1;\n    public AudioSource highNoteSource2;\n    public AudioSource victorySound;\n    public AudioSource explosionSound;\n\n    [Header(\"Effects\")]\n    public ParticleSystem explosionParticles;\n    public GameObject bonusPrefab;\n\n    void Start()\n    {\n        cooldownTimer = baseCoolDown;\n    }\n\n    void Update()\n    {\n        // Handle combo cooldown\n        if (cooldownTimer > 0)\n            cooldownTimer -= Time.deltaTime;\n\n        if (cooldownTimer <= 0f && currentCombo >= 4)\n        {\n            // Fourth hit triggered explosion\n            TriggerExplosion();\n        }\n    }\n\n    void OnTriggerEnter2D(Collider2D other)\n    {\n        // Only trigger on object collision (e.g., 2D)\n        if (!other.CompareTag(\"Player\")) return;\n\n        float timeSinceLastHit = Time.time - cooldownTimer;\n\n        switch (currentCombo)\n        {\n            case 0: // First hit\n                ApplyComboState(1);\n                break;\n            case 1: // Second hit, within first 2s?\n                if (timeSinceLastHit < baseCoolDown)\n                {\n                    ApplyComboState(2);\n                }\n                else\n                {\n                    currentCombo = 0; // Missed the window\n                }\n                break;\n            case 2: // Third hit, within next 2s?\n                if (timeSinceLastHit < baseCoolDown)\n                {\n                    ApplyComboState(3);\n                }\n                else\n                {\n                    currentCombo = 0; // Missed the window\n                }\n                break;\n            default: // Should not reach here unless logic is wrong, but handle anyway\n                currentCombo = 0;\n                break;\n        }\n\n        // Always reset cooldown on hit (overwritten by case logic)\n    }\n\n    void ApplyComboState(int level)\n    {\n        currentCombo = level;\n\n        // Set glow effect based on combo level\n        switch (level)\n        {\n            case 1: SetGlow(yellowGlow); break;\n            case 2: SetGlow(orangeGlow); break;\n            case 3: SetGlow(redGlow); break;\n        }\n\n        // Play sound based on level\n        switch (level)\n        {\n            case 1:\n                lowNoteSource.Play();\n                break;\n            case 2:\n                highNoteSource1.Play();\n                break;\n            case 3:\n                highNoteSource2.Play();\n                break;\n        }\n\n        // Reset cooldown timer after first hit, or on each new level\n        if (level > 0)\n            cooldownTimer = baseCoolDown; // Resets window for next hits\n    }\n\n    void OnTriggerExit2D(Collider2D other)\n    {\n        // Optional: reset state if player leaves\n        currentCombo = 0;\n        cooldownTimer = 0f;\n    }\n\n    void TriggerExplosion()\n    {\n        if (explosionParticles != null)\n            explosionParticles.Play();\n\n        if (victorySound != null)\n            victorySound.Play();\n\n        // Spawn bonus objects\n        for (int i = 0; i < 5; i++)\n        {\n            Vector3 pos = transform.position + new Vector3(2 * Random.Range(-1f, 1f), 0f, 2 * Random.Range(-1f, 1f));\n            Instantiate(bonusPrefab, pos, Quaternion.identity);\n        }\n\n        // Reset combo after explosion\n        currentCombo = 0;\n        cooldownTimer = baseCoolDown; // Reset timer for next potential combo\n    }\n\n    void SetGlow(GameObject glow)\n    {\n        if (glow != null && !glow.isPrefab())\n            glow.SetActive(true);\n        else\n            glow.SetActive(false);\n\n        // Optionally, disable others\n        foreach (var g in new[] {yellowGlow, orangeGlow, redGlow})\n            if (g != glow) g.SetActive(false);\n    }\n}",
    "ir_json": {
      "class_name": "ComboSystem",
      "components": [
        "Collider",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "currentState",
          "type": "enum",
          "default": 0
        },
        {
          "name": "lastHitTime",
          "type": "float",
          "default": 0
        }
      ],
      "behaviors": [
        {
          "name": "OnFirstHit",
          "trigger": "Collider.isTriggered && currentState == 0",
          "actions": [
            "Set object to yellow color",
            "Play low note using AudioSource"
          ]
        },
        {
          "name": "OnSecondHit",
          "trigger": "Collider.isTriggered && currentState == 1 && (currentTime - lastHitTime) < 2.0f",
          "actions": [
            "Set object to orange color",
            "Play higher note using AudioSource"
          ]
        },
        {
          "name": "OnThirdHit",
          "trigger": "Collider.isTriggered && currentState == 2 && (currentTime - lastHitTime) < 2.0f",
          "actions": [
            "Set object to red color",
            "Play even higher note using AudioSource"
          ]
        },
        {
          "name": "OnFourthHit",
          "trigger": "Collider.isTriggered && currentState == 3 && (currentTime - lastHitTime) < 2.0f",
          "actions": [
            "Apply explosion effect",
            "Play victory sound using AudioSource",
            "Spawn 5 bonus GameObjects"
          ]
        },
        {
          "name": "ResetOnMiss",
          "trigger": "(Collider.isTriggered == false) || (currentTime - lastHitTime) >= 2.0f && currentState > 3",
          "actions": [
            "Set currentState to 0",
            "Reset glow and audio"
          ]
        },
        {
          "name": "UpdateLastHitTime",
          "trigger": "Collider.isTriggered",
          "actions": [
            "Set lastHitTime = currentTime"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic enum ComboState { None, First, Second, Third, Fourth }\n\npublic class ComboSystem : MonoBehaviour\n{\n    [SerializeField] private float lastHitTime = 0f;\n    public ComboState currentState = (ComboState)0;\n\n    Rigidbody rb;\n    Collider col;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        col = GetComponent<Collider>();\n    }\n\n    void Update()\n    {\n        UpdateLastHitTime();\n        if (col.isTriggered)\n            EvaluateCombo();\n    }\n\n    void UpdateLastHitTime()\n    {\n        lastHitTime = Time.time;\n    }\n\n    void EvaluateCombo()\n    {\n        float elapsedSinceLastHit = Time.time - lastHitTime;\n\n        switch (currentState)\n        {\n            case ComboState.None:\n                if (elapsedSinceLastHit < 0.1f)\n                {\n                    currentState = ComboState.First; // Use enum, not field directly\n                    ChangeBlendState(BlendingState.SwitchToDefault); // Replace with Rendering.BlendState logic if needed\n                    PlayFirstHit();\n                }\n                break;\n            case ComboState.First:\n                if (elapsedSinceLastHit < 2f)\n                {\n                    currentState = ComboState.Second;\n                    ChangeSearchViewState(Search.SearchViewStateFirst); // Hypothetical, use actual search state as per docs if available\n                    PlaySecondHit();\n                }\n                else\n                {\n                    ResetOnMiss();\n                }\n                break;\n            case ComboState.Second:\n                if (elapsedSinceLastHit < 2f)\n                {\n                    currentState = ComboState.Third;\n                    // No direct blend or search state, just proceed\n                    PlayThirdHit();\n                }\n                else\n                {\n                    ResetOnMiss();\n                }\n                break;\n            case ComboState.Third:\n                if (elapsedSinceLastHit < 2f)\n                {\n                    currentState = ComboState.Fourth;\n                    // Use a custom blend or search state if required by your system, otherwise skip\n                    PlayFourthHit();\n                }\n                else\n                {\n                    ResetOnMiss();\n                }\n                break;\n            case ComboState.Fourth:\n                ResetOnMiss();\n                break;\n            default\n            {\n                ResetOnMiss();\n            }\n        }\n    }\n\n    void ChangeBlendState(BlendingState blendState)\n    {\n        // If you want to use a Unity rendering state, set it here (example for Third or Fourth if needed)\n        // e.g., if (currentState == ComboState.Third) blendState = Rendering.BlendState.blendState3;\n        // But since the spec is unclear, this remains generic\n    }\n\n    void ChangeSearchViewState(Search.ViewState vs)\n    {\n        // If Second needs Search.SearchViewState, assign accordingly. Example placeholder:\n        if (currentState == ComboState.Second)\n            vs = Search.SearchViewStateFirst; // Replace with actual enum as per your design\n    }\n\n    void PlayFirstHit()\n    {\n        gameObject.color = Color.yellow;\n        if (rb != null && rb.hasGravity)\n            rb.AddForce(Vector3.down * 5f, ForceMode.Impulse);\n\n        if (GetComponent<AudioSource>() != null)\n            GetComponent<AudioSource>().Play(0.2f, 500f);\n    }\n\n    void PlaySecondHit()\n    {\n        gameObject.color = Color.orange;\n        if (GetComponent<AudioSource>() != null)\n            GetComponent<AudioSource>().Play(0.3f, 400f);\n    }\n\n    void PlayThirdHit()\n    {\n        gameObject.color = Color.red;\n        if (GetComponent<AudioSource>() != null)\n            GetComponent<AudioSource>().Play(0.4f, 300f);\n    }\n\n    void PlayFourthHit()\n    {\n        GameObject explosionPrefab = transform.Find(\"ExplosionEffect\") as GameObject;\n        if (explosionPrefab != null)\n        {\n            Vector3 hitPoint = col.transform.position + col.center;\n            Instantiate(explosionPrefab, hitPoint, Quaternion.identity);\n        }\n\n        if (GetComponent<AudioSource>() != null)\n        {\n            GetComponent<AudioSource>().Play(0.5f, 1000f);\n        }\n\n        for (int i = 0; i < 5; i++)\n        {\n            Instantiate(new GameObject(\"Bonus\" + i), hitPoint, Quaternion.identity);\n        }\n\n        ResetOnMiss();\n    }\n\n    void ResetOnMiss()\n    {\n        currentState = ComboState.None;\n        lastHitTime = 0f;\n        gameObject.color = Color.white;\n\n        if (GetComponent<AudioSource>() != null)\n            GetComponent<AudioSource>().Stop();\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 9,
        "api_usage": 8,
        "code_quality": 7,
        "completeness": 9,
        "best_practices": 8,
        "total": 41,
        "justification": "Direct implementation with clear state management, comprehensive combo logic, and explicit handling of each hit stage. Correctly implements all requested features with precise timing and state transitions."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 5,
        "code_quality": 6,
        "completeness": 7,
        "best_practices": 5,
        "total": 29,
        "justification": "Incomplete implementation with placeholder methods, inconsistent Unity API usage, and missing critical implementation details. The generated code lacks full functionality and contains hypothetical method calls."
      },
      "winner": "oneshot",
      "key_differences": [
        "Oneshot approach provides explicit, detailed implementation",
        "IR approach relies on code generation with many unresolved placeholders",
        "Oneshot method has more precise state management and error handling"
      ],
      "advantages": [
        "More direct and readable code",
        "Complete implementation of combo system",
        "Explicit handling of edge cases",
        "Better use of Unity-specific APIs and components",
        "More predictable and debuggable implementation"
      ]
    },
    "error": null
  },
  {
    "prompt_num": 15,
    "prompt": "Make a portal that, when you enter it, plays a whoosh sound, rotates you 180 degrees instantly, reverses your velocity, changes your color to a random hue, scales you to 0.5x size, and teleports you to a random location within 50 units, all while creating a visual distortion effect at both the entry and exit points.",
    "timestamp": "2026-01-07T14:57:21.249720",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\nusing Random = UnityEngine.Random;\n\npublic class Portal : MonoBehaviour\n{\n    [Header(\"Portal Effects\")]\n    public SoundEffect whooshSound;\n\n    [SerializeField] private Transform entrancePoint;\n    [SerializeField] private Transform exitPoint;\n    [SerializeField] private Sprite distortionSprite;\n\n    [Space(10)]\n    // Target player to affect\n    public GameObject playerToPort;\n    public LayerMask playerLayer; // Assign in inspector or set in code\n\n    private void Start()\n    {\n        SetupPortal();\n    }\n\n    private void Update()\n    {\n        if (playerToPort != null)\n        {\n            CheckForPlayerInPortal();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Optional: Show gizmos for setup\n        if (entrancePoint != null)\n            Gizmos.color = Color.yellow;\n        if (exitPoint != null)\n            Gizmos.color = Color.green;\n        if (distortionSprite != null)\n            Gizmos.DrawWireSphere(transform.position, 0.3f);\n    }\n\n    private void CheckForPlayerInPortal()\n    {\n        if (playerToPort == null) return;\n\n        Collider playerCollider = Physics.OverlapSphere(playerToPort.transform.position, 0.2f, playerLayer);\n\n        if (playerCollider && playerCollider.CompareTag(\"Player\"))\n        {\n            // Handle entrance\n            PlayWhoosh();\n            RotateAndReversePlayer(playerToPort);\n            ChangeColorAndScale(playerToPort);\n            CreateDistortionAtEntrance();\n\n            // Teleport and reset scale/color after exit effect\n            Wait(0.3f);\n\n            // Reverse movement to maintain direction at destination (optional)\n            Vector3 dir = (playerToPort.transform.position - playerToPort.prevPosition).normalized;\n            if (dir.sqrMagnitude > 0.1f)\n                playerToPort.velocity = -dir * playerToPort.velocity.magnitude;\n\n            // Play exit distortion\n            CreateDistortionAtExit();\n            TeleportPlayer(playerToPort);\n            ResetSizeAndColor(playerToPort);\n\n        }\n    }\n\n    private void PlayWhoosh()\n    {\n        if (whooshSound != null && !whooshSound.isPlaying)\n            whooshSound.PlayOneShot();\n    }\n\n    private void RotateAndReversePlayer(GameObject target)\n    {\n        // Instant 180 rotation about local Y\n        Quaternion rot = Quaternion.Euler(0, 180f, 0);\n        target.transform.rotation = rot * target.transform.rotation;\n\n        // Reverse velocity (relative to the portal's forward direction)\n        Vector3 portalForward = transform.forward;\n        if (portalForward.sqrMagnitude > 0.01f)\n        {\n            Vector3 velRelToPortal = target.transform.velocity - (transform.forward * target.transform.forward.dot(target.transform.velocity));\n            target.transform.velocity = -(velRelToPortal + (transform.forward * (target.transform.position - transform.position).dot(transform.forward)));\n        }\n    }\n\n    private void ChangeColorAndScale(GameObject target)\n    {\n        Color newColor = RandomHue();\n        target.GetComponent<SpriteRenderer>().color = newColor;\n        target.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);\n    }\n\n    private Color RandomHue()\n    {\n        return new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0.7f, 1f)); // Slightly transparent\n    }\n\n    private void CreateDistortionAtEntrance()\n    {\n        CreateDistortion(transform.position);\n    }\n\n    private void CreateDistortionAtExit()\n    {\n        // Use exitPoint for visual effect at teleport destination\n        CreateDistortion(exitPoint.position);\n    }\n\n    private void CreateDistortion(Vector3 pos)\n    {\n        if (distortionSprite == null) return;\n\n        // Spawn a temporary GameObject with the distortion sprite and position it\n        GameObject distObj = new GameObject(\"PortalDistortion\");\n        distObj.transform.SetParent(transform.root, false);\n        distObj.transform.position = pos;\n        distObj.GetComponent<SpriteRenderer>().sprite = distortionSprite;\n        distObj.SetActive(true);\n\n        // Animate in/out for effect (simple fade)\n        float duration = 0.25f;\n        distObj.SetActive(false);\n        Invoke(\"FadeIn\", 0f);\n        Destroy(distObj, duration + 0.1f);\n\n        void FadeIn()\n        {\n            distObj.SetActive(true);\n            float t = Time.time / duration;\n            distObj.sprite.color.a = 1f - t; // fully opaque at start\n        }\n    }\n\n    private void TeleportPlayer(GameObject player)\n    {\n        Vector3 exitPos = exitPoint.position;\n        // Random destination within 50 units from exitPoint (not portal center!)\n        float maxDist = 50f;\n        Vector3 dest = exitPoint.position + Random.insideUnitSphere.normalized * maxDist;\n\n        player.transform.position = dest;\n        // Optionally preserve rotation\n        player.transform.rotation = Quaternion.identity; // Or apply old rotation if needed\n\n        // If you want to keep parent, set it back here as necessary\n    }\n\n    private void ResetSizeAndColor(GameObject target)\n    {\n        target.GetComponent<SpriteRenderer>().color = target.color;\n        target.transform.localScale = Vector3.one;\n    }\n\n    // Helper for player layer detection setup (set in inspector if needed)\n    [Tooltip(\"Player Layer Mask to detect the player entering the portal.\")]\n    public int PlayerLayer = 1; // Default: 1 is Player, adjust as required\n}",
    "ir_json": {
      "class_name": "PortalBehavior",
      "components": [
        "Rigidbody",
        "Animator"
      ],
      "fields": [
        {
          "name": "entryPoint",
          "type": "Transform",
          "default": null
        },
        {
          "name": "exitPoint",
          "type": "Transform",
          "default": null
        },
        {
          "name": "duration",
          "type": "float",
          "default": 0.1
        }
      ],
      "behaviors": [
        {
          "name": "OnEnterPortal",
          "trigger": "Rigidbody enters PortalBehavior component",
          "actions": [
            "play audio (sound: portal_whoosh.wav)",
            "apply force (-velocity * 2, transform.forward)",
            "rotate entity 180 degrees around local up axis",
            "set entity color to random hue",
            "scale entity to 0.5",
            "create visual distortion at entryPoint (duration: 0.3 seconds)",
            "create visual distortion at exitPoint (duration: 0.3 seconds)",
            "teleport entity to random point within 50 units of center"
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class PortalBehavior : MonoBehaviour\n{\n    [Header(\"Portal Settings\")]\n    public Transform entryPoint;\n    public Transform exitPoint;\n    public float duration = 0.1f;\n\n    [SerializeField] private Rigidbody rigidbody;\n    [SerializeField] private Animator animator;\n\n    void Start()\n    {\n        if (rigidbody == null)\n            rigidbody = GetComponent<Rigidbody>();\n        if (animator == null)\n            animator = GetComponent<Animator>();\n\n        if (entryPoint == null) entryPoint = transform;\n        if (exitPoint == null) exitPoint = transform;\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && rigidbody != null && animator != null)\n        {\n            // Play portal whoosh sound\n            var sound = Resources.Load<Sound>(\"portal_whoosh.wav\");\n            if (sound != null)\n                sound.Play();\n\n            // Calculate direction and apply force along -forward\n            Vector3 forward = transform.forward;\n            float forceMagnitude = 2f * rigidbody.velocity.magnitude;\n            rigidbody.AddForce(-forward * forceMagnitude, ForceMode.VelocityChange);\n\n            // Rotate player 180 around local up (assuming Y is up)\n            // Assume right is X and up is Z for rotation axis\n            Vector3 upAxis = transform.right; // Or use transform.forward if you define it as up\n            Quaternion rotation = Quaternion.AngleAxis(180f, upAxis);\n            transform.rotation = rotation * transform.rotation;\n\n            // Set random hue (example: assign to a Renderer component if available)\n            // For demonstration, skip unless you have a reference\n\n            // Scale entity\n            transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);\n\n            // Visual distortion at entry and exit points using coroutines\n            StartCoroutine(ShowDistortionAtPoint(entryPoint, 0.3f));\n            StartCoroutine(ShowDistortionAtPoint(exitPoint, 0.3f));\n\n            // Teleport to random point within 50 units from center\n            Vector3 randOffset;\n            Random.insideUnitSphere.Sample(out randOffset, 0.5f); // Sample in unit sphere for randomness\n            randOffset *= 50f; // Max distance 25 => scale to 50\n            Vector3 center = transform.position;\n            Vector3 targetPos = (center + randOffset).normalized * 50f;\n            transform.position = targetPos;\n        }\n    }\n\n    IEnumerator ShowDistortionAtPoint(Transform point, float time)\n    {\n        yield return new WaitForSeconds(time);\n        // Implement your visual distortion effect here\n        Debug.Log(\"Distortion at \" + point.name);\n    }\n\n    void Update()\n    {\n        // Optional: Reset effects or player state after teleport if needed\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "grade": {
      "oneshot": {
        "correctness": 8,
        "api_usage": 7,
        "code_quality": 6,
        "completeness": 9,
        "best_practices": 7,
        "total": 37,
        "justification": "Handles most requirements directly with explicit implementation. Slightly over-complicated but comprehensive. Good attention to details like velocity reversal and random color generation."
      },
      "ir": {
        "correctness": 6,
        "api_usage": 8,
        "code_quality": 9,
        "completeness": 7,
        "best_practices": 9,
        "total": 39,
        "justification": "More abstracted and clean approach. Leverages Unity's component system well. Slightly less precise in implementation details but more modular and readable."
      },
      "winner": "ir",
      "key_differences": [
        "Oneshot approach is more procedural and explicit",
        "IR approach is more declarative and component-oriented",
        "Oneshot has more granular control, IR has better structure"
      ],
      "advantages": [
        "More concise code",
        "Better separation of concerns",
        "More maintainable and extensible design",
        "Follows Unity's component-based architecture more closely",
        "Easier to modify and iterate on behavior"
      ]
    },
    "error": null
  }
]