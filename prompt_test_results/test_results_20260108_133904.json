[
  {
    "prompt_num": 1,
    "prompt": "Create a script that makes an object spin faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase.",
    "timestamp": "2026-01-08T13:35:32.476798",
    "oneshot_code": "using UnityEngine;\n\npublic class SpinUpExplosion : MonoBehaviour\n{\n    [SerializeField] private float maxSpinSpeed = 50f;\n    [SerializeField] private AudioClip explosionSound;\n    [SerializeField] private MaterialColorShifter materialColorShifter;\n    \n    private AudioSource audioSource;\n    private Rigidbody rb;\n    private Vector3 initialRotation;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        audioSource = GetComponent<AudioSource>();\n        materialColorShifter = GetComponent<MaterialColorShifter>();\n\n        // Save initial rotation\n        initialRotation = transform.rotation.eulerAngles;\n    }\n\n    private void Update()\n    {\n        if (rb != null && !rb.isKinematic)\n        {\n            // Spin up the object\n            rb.angularVelocity *= Time.deltaTime * 10f;\n\n            // Play sound that gets louder\n            audioSource.volume += Time.deltaTime * 0.5f;\n            \n            // Check for max spin speed\n            if (rb.angularVelocity.magnitude >= maxSpinSpeed)\n            {\n                StopSpinUp();\n            }\n\n            // Shift material color from blue to red\n            if (materialColorShifter != null)\n            {\n                materialColorShifter.ShiftMaterialColor(initialRotation);\n            }\n        }\n    }\n\n    private void StopSpinUp()\n    {\n        // Play explosion sound\n        audioSource.PlayOneShot(explosionSound);\n\n        // Destroy the original object and spawn 10 smaller pieces\n        SpawnExplosionPieces();\n\n        // Reset rotation to initial state\n        transform.rotation = Quaternion.Euler(initialRotation);\n    }\n\n    private void SpawnExplosionPieces()\n    {\n        // Create explosion particles or effects (not included in code snippet)\n        \n        // Spawn 10 smaller objects\n        for (int i = 0; i < 10; i++)\n        {\n            GameObject explosionPiece = Instantiate(gameObject, transform.position, Quaternion.identity);\n            \n            // Apply random rotation and scale to each piece\n            explosionPiece.transform.Rotate(Random.insideUnitSphere * 30f);\n            explosionPiece.transform.localScale *= Random.Range(0.5f, 1.5f);\n\n            // Play unique sound effect for each piece (not included in code snippet)\n        }\n    }\n\n    private void OnDestroy()\n    {\n        // Clean up references\n        if (audioSource != null)\n        {\n            audioSource.Stop();\n            Destroy(audioSource);\n        }\n        \n        if (rb != null)\n        {\n            Destroy(rb);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "SpinUpExplosion",
      "components": [
        {
          "component_type": "Rigidbody"
        },
        {
          "component_type": "AudioSource"
        }
      ],
      "fields": [
        {
          "name": "spinSpeed",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "maxSpinDuration",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "explosionForce",
          "type": "float",
          "default": 500.0
        },
        {
          "name": "explosionRadius",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "materialColorStart",
          "type": "Color",
          "default": "#0000FF"
        },
        {
          "name": "materialColorEnd",
          "type": "Color",
          "default": "#FF0000"
        }
      ],
      "behaviors": [
        {
          "name": "spinUp",
          "trigger": "when object starts spinning",
          "actions": [
            {
              "action": "increase spin speed over time"
            },
            {
              "action": "change material color from start to end"
            }
          ]
        },
        {
          "name": "explosion",
          "trigger": "when maximum spin reached",
          "actions": [
            {
              "action": "play explosion sound effect"
            },
            {
              "action": "destroy object and spawn smaller pieces"
            },
            {
              "action": "apply explosion force to remaining pieces"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class SpinUpExplosion : MonoBehaviour\n{\n    [SerializeField] private float spinSpeed = 10.0f;\n    [SerializeField] private float maxSpinDuration = 2.0f;\n    [SerializeField] private float explosionForce = 500.0f;\n    [SerializeField] private float explosionRadius = 3.0f;\n\n    [SerializeField] private Color materialColorStart = Color.blue;\n    [SerializeField] private Color materialColorEnd = Color.red;\n\n    private Material material;\n    private Rigidbody rb;\n    private bool isSpinning = false;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody component not found!\");\n        }\n\n        material = GetComponent<Renderer>().material;\n        if (material == null)\n        {\n            Debug.LogError(\"Renderer component not found or no material assigned!\");\n        }\n    }\n\n    private void Update()\n    {\n        if (!isSpinning && spinSpeed > 0.0f)\n        {\n            StartCoroutine(SpinUpCoroutine());\n        }\n    }\n\n    private IEnumerator SpinUpCoroutine()\n    {\n        isSpinning = true;\n        \n        float rotationAngle = 0.0f;\n\n        while (rotationAngle < 360.0f * maxSpinDuration && !isDestroyed)\n        {\n            material.color = Color.LerpUnclamped(materialColorStart, materialColorEnd, rotationAngle / 360.0f);\n            \n            rotationAngle += Time.deltaTime * spinSpeed;\n            rb.MoveRotation(rb.rotation * Quaternion.Euler(0, 0, rotationAngle));\n\n            yield return null;\n        }\n\n        StopCoroutine(SpinUpCoroutine());\n        isSpinning = false;\n\n        SpawnExplosion();\n    }\n\n    private void SpawnExplosion()\n    {\n        // Destroy current object\n        Destroy(gameObject);\n\n        // Create explosion particles\n        Instantiate(explosionPrefab, transform.position, Quaternion.identity);\n        \n        // Apply force to remaining pieces\n        Collider[] colliders = GetComponents<Collider>();\n        foreach (Collider col in colliders)\n        {\n            Rigidbody rbChild = col.GetComponent<Rigidbody>();\n            if (rbChild != null)\n            {\n                rbChild.AddExplosionForce(explosionForce, transform.position, explosionRadius);\n            }\n        }\n    }\n\n    // Add any required explosion prefab or other setup\n    private GameObject explosionPrefab;\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "ir_rag_doc_names": [
      "Color.LerpUnclamped (0.53)",
      "MaterialPropertyBlock.GetFloat (0.40)",
      "MaterialPropertyBlock.GetInteger (0.39)",
      "MaterialPropertyBlock.GetInt (0.39)",
      "ColorGamutUtility.GetWhitePoint (0.38)",
      "Handheld.GetActivityIndicatorStyle (0.38)",
      "Terrain.CreateTerrainGameObject (0.38)",
      "ColorGamutUtility.GetColorPrimaries (0.38)"
    ],
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 2,
    "prompt": "Make a gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center, all while rotating the entire gravity well slowly.",
    "timestamp": "2026-01-08T13:36:05.250066",
    "oneshot_code": "using UnityEngine;\n\npublic class GravityWell : MonoBehaviour\n{\n    [SerializeField] private float gravityStrength = 10f;\n    [SerializeField] private AudioClip rumbleSound;\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private Light light;\n    [SerializeField] private ParticleSystem particleSystem;\n    \n    private void Start()\n    {\n        // Initialize audio source\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n        \n        // Initialize light\n        if (light == null)\n            light = GetComponent<Light>();\n        \n        // Play rumble sound on start\n        PlayRumbleSound();\n    }\n\n    private void Update()\n    {\n        // Calculate average distance to nearby rigidbodies\n        float totalDistance = 0f;\n        int numObjects = 0;\n\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 5f);\n        foreach (Collider collider in colliders)\n        {\n            Rigidbody rb = collider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 distanceVector = transform.position - rb.transform.position;\n                float distance = distanceVector.magnitude;\n\n                totalDistance += distance;\n                numObjects++;\n            }\n        }\n\n        // Apply gravity based on average distance\n        if (numObjects > 0)\n        {\n            float avgDistance = totalDistance / numObjects;\n            Vector3 forceDirection = transform.up.normalized * -gravityStrength * avgDistance;\n            GetComponent<Rigidbody>().AddForce(forceDirection);\n        }\n    }\n\n    private void PlayRumbleSound()\n    {\n        // Play rumble sound\n        audioSource.PlayOneShot(rumbleSound);\n\n        // Increase volume based on distance to nearby objects\n        float volumeMultiplier = 1f + numObjects * 0.5f;\n        audioSource.volume *= volumeMultiplier;\n\n        // Change light intensity based on number of objects being pulled\n        light.intensity = Mathf.Lerp(0.2f, 1f, numObjects / 10f);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Spawn particle effect when object collides with center\n        if (collision.transform.CompareTag(\"Player\"))\n        {\n            particleSystem.Play();\n        }\n    }\n}",
    "ir_json": {
      "class_name": "GravityWellBehavior",
      "components": [
        "Rigidbody",
        "AudioSource",
        "Collider"
      ],
      "fields": [
        {
          "name": "gravity_strength",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "rumble_volume_multiplier",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "light_intensity_factor",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "particle_emission_rate",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "rotation_speed",
          "type": "float",
          "default": 2.0
        }
      ],
      "behaviors": [
        {
          "name": "pull_objects",
          "trigger": "when object enters gravity field",
          "actions": [
            {
              "action": "apply gravitational force to nearby rigidbodies"
            },
            {
              "action": "increase rumble volume based on distance"
            }
          ]
        },
        {
          "name": "change_light_intensity",
          "trigger": "when number of pulled objects changes",
          "actions": [
            {
              "action": "adjust light intensity based on count"
            }
          ]
        },
        {
          "name": "create_particle_effects",
          "trigger": "when object collides with gravity center",
          "actions": [
            {
              "action": "spawn particle effects at collision point"
            }
          ]
        },
        {
          "name": "rotate_gravity_well",
          "trigger": "continuously over time",
          "actions": [
            {
              "action": "slowly rotate gravity well around its axis"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class GravityWellBehavior : MonoBehaviour\n{\n    // IR-specified fields (auto-injected)\n    public float gravityStrength = 10f;\n    public float rumbleVolumeMultiplier = 2f;\n    public float lightIntensityFactor = 0.5f;\n    public ParticleSystem particleEffectPrefab;\n    public float particleEmissionRate = 1f;\n\n    [Header(\"Rotation Settings\")]\n    public float rotationSpeed = 2f;\n    public Transform axisOfRotation;\n\n    private Rigidbody gravityRigidbody;\n    private AudioSource rumbleSource;\n    private Light lightComponent;\n    private ParticleSystem[] particleSystems;\n\n    private void Start()\n    {\n        // Get references to components\n        gravityRigidbody = GetComponent<Rigidbody>();\n        rumbleSource = GetComponent<AudioSource>();\n        lightComponent = GetComponent<Light>();\n\n        // Initialize particle system array if needed\n        particleSystems = GetComponentsInChildren<ParticleSystem>();\n    }\n\n    private void Update()\n    {\n        // Rotate the gravity well around its axis\n        transform.Rotate(axisOfRotation.forward * rotationSpeed * Time.deltaTime);\n    }\n\n    private void FixedUpdate()\n    {\n        // Apply gravity to nearby objects\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 10f);\n\n        foreach (Collider collider in colliders)\n        {\n            Rigidbody rigidbody = collider.GetComponent<Rigidbody>();\n\n            if (rigidbody != null && rigidbody != gravityRigidbody)\n            {\n                Vector3 directionToCenter = transform.position - rigidbody.transform.position;\n                rigidbody.AddForce(directionToCenter * gravityStrength, ForceMode.Acceleration);\n            }\n        }\n\n        // Increase rumble volume based on nearby objects\n        int numObjectsNearby = Physics.OverlapSphere(transform.position, 10f).Length;\n\n        if (numObjectsNearby > 0)\n        {\n            rumbleSource.volume *= Mathf.Pow(rumbleVolumeMultiplier, numObjectsNearby);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Handle particle effects on object collision\n        if (particleEffectPrefab != null && other.CompareTag(\"Grabbable\"))\n        {\n            ParticleSystem newParticle = Instantiate(particleEffectPrefab, transform.position, Quaternion.identity);\n\n            if (newParticle != null)\n            {\n                newParticle.Play();\n                Destroy(newParticle.gameObject, 2f); // Destroy after 2 seconds\n            }\n        }\n\n        // Handle light intensity change based on number of grabbed objects\n        int numObjectsGrabbed = Physics.OverlapSphere(transform.position, 10f).Length;\n\n        if (lightComponent != null)\n        {\n            lightComponent.intensity *= Mathf.Pow(lightIntensityFactor, numObjectsGrabbed);\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        // Reset light intensity and particle effects when object leaves\n        if (other.CompareTag(\"Grabbable\"))\n        {\n            ParticleSystem[] particleEffects = GetComponentsInChildren<ParticleSystem>();\n\n            foreach (ParticleSystem effect in particleEffects)\n            {\n                Destroy(effect.gameObject);\n            }\n\n            if (lightComponent != null)\n            {\n                lightComponent.intensity = 1f;\n            }\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "ir_rag_doc_names": [
      "Collider.GetGeometry (0.65)",
      "Rigidbody.OnCollisionEnter (0.64)",
      "Collider2D.CreateMesh (0.63)",
      "Collider.OnCollisionEnter (0.63)",
      "Collider.OnCollisionStay (0.63)",
      "Rigidbody.OnCollisionStay (0.63)",
      "Rigidbody.IsSleeping (0.63)",
      "Collider2D.GetShapeBounds (0.62)"
    ],
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 3,
    "prompt": "Build a script that turns any object into a musical instrument - when you collide with it, it plays a note based on where you hit it (top plays high notes, bottom plays low notes), the object's color shifts to match the note's frequency, it vibrates with the sound, and leaves a trail of particles that fade out over 2 seconds.",
    "timestamp": "2026-01-08T13:36:51.767401",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class MusicalInstrument : MonoBehaviour {\n\n    [SerializeField] private AudioClip[] instrumentSounds = new AudioClip[16];\n    [SerializeField] private Color[] noteColors = new Color[16];\n\n    private AudioSource audioSource;\n\n    void Start() {\n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null) {\n            audioSource = gameObject.AddComponent<AudioSource>();\n            audioSource.playOnAwake = false;\n            audioSource.loop = true;\n        }\n    }\n\n    public void PlayNoteAt(Vector3 hitPoint, int noteIndex) {\n        // Calculate pitch based on hit point\n        float pitchMultiplier = 1f + (hitPoint.y / transform.localScale.y);\n        \n        // Play sound\n        audioSource.pitch = instrumentSounds[noteIndex].pitch * pitchMultiplier;\n        audioSource.PlayOneShot(instrumentSounds[noteIndex]);\n\n        // Change color to match note frequency\n        GetComponent<Renderer>().material.color = noteColors[noteIndex];\n\n        // Vibrations and particle trail\n        StartCoroutine(VibrateAndFade(hitPoint));\n    }\n\n    private IEnumerator VibrateAndFade(Vector3 hitPoint) {\n        // Vibrations\n        float vibrationIntensity = 0.1f;\n        transform.Rotate(0, -vibrationIntensity * Time.deltaTime, 0);\n        \n        // Particle trail\n        GameObject[] particleEmitters = GetComponentsInChildren<ParticleSystem>();\n        foreach (ParticleSystem emitter in particleEmitters) {\n            emitter.Play();\n        }\n\n        yield return new WaitForSeconds(2f);\n\n        // Fade out particles\n        for (int i = 0; i < particleEmitters.Length; i++) {\n            ParticleSystem particleSystem = particleEmitters[i];\n            while (particleSystem.IsAlive()) {\n                particleSystem.Stop(true);\n                break;\n            }\n        }\n\n        GetComponent<Renderer>().material.color = Color.clear;\n    }\n}",
    "ir_json": {
      "class_name": "MusicalInstrumentCollider",
      "components": [
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "play_note_on_collision",
          "type": "bool",
          "default": true
        },
        {
          "name": "note_mapping",
          "type": "dict",
          "default": {
            "top": "C4",
            "middle": "G3",
            "bottom": "C2"
          }
        },
        {
          "name": "color_shift_speed",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "vibration_strength",
          "type": "float",
          "default": 1.0
        }
      ],
      "behaviors": [
        {
          "name": "play_note",
          "trigger": "when object collides with other object",
          "actions": [
            {
              "action": "play audio source note"
            },
            {
              "action": "change color based on note frequency"
            },
            {
              "action": "vibrate object"
            }
          ]
        },
        {
          "name": "color_shift",
          "trigger": "when object is played",
          "actions": [
            {
              "action": "shift color over time"
            }
          ]
        },
        {
          "name": "particle_trail",
          "trigger": "when object is played",
          "actions": [
            {
              "action": "emit particle trail"
            },
            {
              "action": "fade particles out over 2 seconds"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class MusicalInstrumentCollider : MonoBehaviour {\n    // IR-specified fields (auto-injected)\n    public bool play_note_on_collision = true;\n    public dict note_mapping = {'top': 'C4', 'middle': 'G3', 'bottom': 'C2'};\n    public float color_shift_speed = 0.5f;\n    public float vibration_strength = 1.0f;\n\n    [Header(\"Play settings\")]\n    public bool playNoteOnCollision = true;\n    public float noteVolumeMultiplier = 1.0f;\n    public AudioClip[] notesToPlay;\n\n    [Header(\"Visual effects\")]\n    public Color normalColor;\n    public Color playingColor;\n    public Color vibratedColor;\n    public Material colorMaterial;\n\n    [Header(\"Vibration settings\")]\n    public bool applyVibrationOnCollision = true;\n    public float vibrationDuration = 0.5f;\n    public int numVibrations = 3;\n\n    private AudioSource audioSource;\n    private Rigidbody rb;\n    private Color currentColor;\n\n    void Start() {\n        audioSource = GetComponent<AudioSource>();\n        rb = GetComponent<Rigidbody>();\n\n        if (colorMaterial == null) {\n            colorMaterial = new Material(Shader.Find(\"Standard\"));\n        }\n        \n        // Default to normal color\n        currentColor = normalColor;\n    }\n\n    void OnCollisionEnter(Collision collision) {\n        if (!playNoteOnCollision) return;\n\n        // Play note\n        PlayRandomNote();\n\n        // Color shift\n        ShiftColor(collision);\n\n        // Vibration\n        ApplyVibration(collision);\n    }\n\n    private void PlayRandomNote() {\n        int randomIndex = Random.Range(0, notesToPlay.Length);\n        audioSource.PlayOneShot(notesToPlay[randomIndex], noteVolumeMultiplier);\n    }\n\n    private void ShiftColor(Collision collision) {\n        // Calculate color shift based on collision normal\n        Vector3 colorDirection = (collision.contacts[0].point - transform.position).normalized;\n        \n        // Apply color shift\n        currentColor = Color.Lerp(currentColor, playingColor, Time.deltaTime * 10f);\n    }\n\n    private void ApplyVibration(Collision collision) {\n        if (!applyVibrationOnCollision || rb == null) return;\n\n        // Vibrate object\n        rb.AddForce(collision.contacts[0].point - transform.position, ForceMode.Impulse);\n\n        // Fade color over vibration duration\n        StartCoroutine(FadeColor(vibratedColor));\n    }\n\n    private IEnumerator FadeColor(Color targetColor) {\n        float fadeDuration = vibrationDuration;\n        float currentAlpha = 1.0f;\n\n        while (currentAlpha > 0) {\n            currentAlpha -= Time.deltaTime / fadeDuration;\n\n            colorMaterial.color = Color.Lerp(currentColor, vibratedColor, Mathf.Clamp01(currentAlpha));\n\n            yield return null;\n        }\n\n        // Reset to normal color\n        colorMaterial.color = normalColor;\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 8,
    "ir_rag_doc_names": [
      "AudioSource.GamepadSpeakerSupportsOutputType (0.66)",
      "AudioSource.PlayOneShot (0.65)",
      "AudioSource.PlayOnGamepad (0.64)",
      "Collider.OnCollisionExit (0.64)",
      "Collider.OnTriggerExit (0.64)",
      "Collider.OnTriggerEnter (0.64)",
      "ParticleSystemShapeMultiModeValue.Loop (0.42)",
      "ParticleSystemOverlapAction.Callback (0.41)"
    ],
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 4,
    "prompt": "Create a creature that has 5 states: idle (sits still, plays ambient breathing), curious (slowly approaches player if within 10 units, plays questioning sound), scared (runs away from player, plays panic sound, color turns red), aggressive (chases player, plays roar, color turns dark, applies force toward player), and exhausted (stops moving, plays tired sound, color fades to gray). It transitions between states based on player distance and how long it's been in current state.",
    "timestamp": "2026-01-08T13:37:33.482751",
    "oneshot_code": "using UnityEngine;\n\npublic class CreatureStateController : MonoBehaviour\n{\n    [Header(\"States\")]\n    public State[] states;\n    \n    private State currentState;\n    private float transitionTimer = 0f;\n    private float maxTransitionTime = 2f;\n    \n    // Start is called before the first frame update\n    void Start()\n    {\n        currentState = states[0]; // Set initial state (idle)\n    }\n    \n    // Update is called once per frame\n    void Update()\n    {\n        HandleStateTransitions();\n        ApplyCurrentStateActions();\n    }\n\n    private void HandleStateTransitions()\n    {\n        if (currentState == null) return;\n\n        // Check for player proximity to decide transition\n        float playerDistance = Vector3.Distance(transform.position, PlayerController.instance.transform.position);\n        \n        if (playerDistance < currentState.minPlayerDist)\n        {\n            // Too close - transition to scared or aggressive state\n            TransitionToNextState();\n        }\n        else if (playerDistance > currentState.maxPlayerDist && currentState != states[0])\n        {\n            // Too far away - transition back to idle\n            TransitionToNextState();\n        }\n    }\n\n    private void ApplyCurrentStateActions()\n    {\n        currentState.ApplyStateActions();\n    }\n\n    private void TransitionToNextState()\n    {\n        if (currentState == null) return;\n\n        // Calculate time since last transition\n        float elapsedTime = Time.time - currentState.transitionStartTime;\n        \n        // Check if enough time has passed for a new transition\n        if (elapsedTime >= maxTransitionTime)\n        {\n            // Find next state in sequence\n            int nextStateIndex = Array.IndexOf(states, currentState) + 1;\n            if (nextStateIndex < states.Length)\n            {\n                currentState = states[nextStateIndex];\n                currentState.transitionStartTime = Time.time;\n\n                Debug.Log($\"Transitioning to {currentState.name}\");\n            }\n        }\n    }\n\n    [System.Serializable]\n    public class State\n    {\n        [Header(\"Settings\")]\n        [Tooltip(\"Minimum player distance for state activation\")]\n        public float minPlayerDist;\n        [Tooltip(\"Maximum player distance before transitioning back\")]\n        public float maxPlayerDist;\n\n        // Add any other configurable settings here\n\n        [SerializeField] private CreatureStateController creatureController;\n        \n        [HideInInspector]\n        public bool isActive = true; // Flag to track current state activation\n        [HideInInspector]\n        public float transitionStartTime = 0f; // Timestamp for last transition\n        \n        public virtual void ApplyStateActions()\n        {\n            // Implement specific behaviors for each state here\n\n            // Example: Play idle breathing sound\n            creatureController.PlayIdleBreathingSound();\n        }\n    }\n\n    // Add methods to handle individual states' actions\n    public void PlayIdleBreathingSound() { ... }\n    public void PlayCuriousApproachSound() { ... }\n    public void PlayScaredPanicSound() { ... }\n    public void PlayAggressiveRoar() { ... }\n    public void PlayExhaustedTiredSound() { ... }\n\n    // Add methods to handle state transitions\n    public void TransitionToIdle() { ... }\n    public void TransitionToCurious() { ... }\n    public void TransitionToScared() { ... }\n    public void TransitionToAggressive() { ... }\n    public void TransitionToExhausted() { ... }\n}",
    "ir_json": {
      "class_name": "PlayerBehavior",
      "components": [
        "Rigidbody",
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "current_state",
          "type": "string",
          "default": "idle"
        },
        {
          "name": "last_transition_time",
          "type": "float",
          "default": 0.0
        },
        {
          "name": "state_duration",
          "type": "float",
          "default": 5.0
        }
      ],
      "behaviors": [
        {
          "name": "state_machine",
          "trigger": "change in player distance or time elapsed",
          "actions": [
            {
              "action": "check if within range for curious state"
            },
            {
              "action": "play curiosity sound if curious"
            },
            {
              "action": "check if scared of player"
            },
            {
              "action": "change to scared state and play panic sound"
            },
            {
              "action": "check if aggressive towards player"
            },
            {
              "action": "change to aggressive state, play roar, apply force"
            },
            {
              "action": "check for exhaustion after long time in state"
            },
            {
              "action": "change to exhausted state and fade color"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class PlayerBehavior : MonoBehaviour {\n    // IR-specified fields (auto-injected)\n    public string current_state = \"idle\";\n    public float last_transition_time = 0.0f;\n    public float state_duration = 5.0f;\n\n\n    [Header(\"Player Settings\")]\n    public float chaseSpeed = 5f;\n    public float attackRange = 10f;\n    public LayerMask targetLayer;\n    public bool isChasing = false;\n    public bool isAttacking = false;\n\n    private Transform playerTarget;\n    private Vector3 targetDirection;\n    private Rigidbody rb;\n\n    private void Start() {\n        rb = GetComponent<Rigidbody>();\n        if (rb == null) {\n            Debug.LogError(\"Player must have a Rigidbody component!\");\n        }\n    }\n\n    private void Update() {\n        // Check for player input\n        if (Input.GetMouseButtonDown(0)) {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n\n            // Check if mouse click is on target layer\n            if (Physics.Raycast(ray, out hit, attackRange, targetLayer)) {\n                playerTarget = hit.transform;\n                isChasing = true;\n                StartCoroutine(ChasePlayer());\n            }\n        }\n\n        // Cancel chase and attack if no longer targeting\n        else if (playerTarget == null) {\n            isChasing = false;\n            isAttacking = false;\n        }\n    }\n\n    private IEnumerator ChasePlayer() {\n        while (isChasing && playerTarget != null) {\n            targetDirection = playerTarget.position - transform.position;\n            float distanceToTarget = Vector3.Distance(transform.position, playerTarget.position);\n\n            // Slow down as player gets closer\n            chaseSpeed = Mathf.Lerp(chaseSpeed, 0.5f, 1 - (distanceToTarget / attackRange));\n\n            rb.velocity = targetDirection.normalized * chaseSpeed;\n\n            yield return null;\n        }\n\n        isChasing = false;\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 8,
    "ir_rag_doc_names": [
      "Rigidbody.IsSleeping (0.63)",
      "Rigidbody.AddExplosionForce (0.62)",
      "Rigidbody.AddForce (0.62)",
      "AudioSource.PlayDelayed (0.60)",
      "AudioSource.GamepadSpeakerSupportsOutputType (0.60)",
      "Collider.ClosestPointOnBounds (0.59)",
      "AudioSource.PlayOneShot (0.59)",
      "Collider.OnTriggerStay (0.58)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class GeneratedBehavior : MonoBehaviour\n{\n    // No fields required\n\n    void Start() {\n        // Behavior 1: Play sound when game starts\n        if (GetComponent<AudioSource>() != null) {\n            GetComponent<AudioSource>().Play();\n        }\n    }\n\n    void Update() {\n        // Behavior 2: Move forward based on WASD input\n        if (Input.GetKey(KeyCode.W)) {\n            transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed);\n        }\n        if (Input.GetKey(KeyCode.S)) {\n            transform.Translate(Vector3.back * Time.deltaTime * moveSpeed);\n        }\n        if (Input.GetKey(KeyCode.A)) {\n            transform.Rotate(0, -90f, 0);\n        }\n        if (Input.GetKey(KeyCode.D)) {\n            transform.Rotate(0, 90f, 0);\n        }\n\n        // Behavior 3: Detect collision with other game object\n        foreach (Collider other in Physics.OverlapSphere(transform.position, detectionRadius)) {\n            if (other.CompareTag(\"OtherObject\")) {\n                Debug.Log(\"Detected collision!\");\n                // Handle collision logic here\n            }\n        }\n    }\n\n    [SerializeField] private float moveSpeed = 5f;\n    [SerializeField] private float detectionRadius = 1f;\n\n}",
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": {},
    "grade": null,
    "error": null
  }
]