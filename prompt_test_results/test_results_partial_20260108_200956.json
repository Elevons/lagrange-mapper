[
  {
    "prompt_num": 1,
    "prompt": "Create a script that makes an object spin faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase.",
    "timestamp": "2026-01-08T19:59:44.140511",
    "oneshot_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpinningExplosion : MonoBehaviour\n{\n    [Header(\"Spin Settings\")]\n    [SerializeField] private float _spinSpeed = 2f;\n    [SerializeField] private bool _reverseDirection = false;\n    [SerializeField] private float _spinDuration = 3f;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private int _explosionCount = 10;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 10f;\n    [SerializeField] private bool _destroyParentOnExplode = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _spinSounds;\n    [SerializeField] private AudioClip[] _explodeSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Color _startColor = Color.blue;\n    [SerializeField] private Color _endColor = Color.red;\n    [SerializeField] private AnimationCurve _colorTransition = AnimationCurve.EaseInOut(0f, 1f);\n    \n    private Vector3 _spinDirection;\n    private float _spinTime;\n    private bool _isSpinning = false;\n    private List<ExplosionParticle> _explosionParticles = new List<ExplosionParticle>();\n    \n    [System.Serializable]\n    public class ExplosionParticle\n    {\n        public GameObject prefab;\n        public Transform explosionPoint;\n        public AudioSource audioSource;\n        public AudioClip explosionSound;\n        public float velocity;\n        public float force;\n        \n        public ExplosionParticle(GameObject go, Vector3 point, float vel, float forced)\n        {\n            prefab = go.transform.gameObject;\n            explosionPoint = point;\n            velocity = vel;\n            force = forced;\n            \n            if (audioSource == null)\n                audioSource = go.GetComponent<AudioSource>();\n                \n            if (audioSource != null && explosionSound != null)\n                audioSource.clip = explosionSound;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        CreateExplosionParticles();\n        \n        // Play initial spin sound\n        PlaySpinSound(0);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null && gameObject.transform.parent != null)\n            _audioSource = gameObject.transform.parent.GetComponent<AudioSource>();\n    }\n    \n    private void CreateExplosionParticles()\n    {\n        List<Vector3> explosionPoints = new List<Vector3>();\n        \n        // Calculate positions around the spinning object\n        float angleStep = 360f / _explosionCount;\n        float currentAngle = 0f;\n        \n        for (int i = 0; i < _explosionCount; i++)\n        {\n            Vector3 direction = transform.forward;\n            direction.y = Mathf.Sin(currentAngle * Mathf.Deg2Rad) * 1.5f;\n            direction.z = Mathf.Cos(currentAngle * Mathf.Deg2Rad) * 1.5f;\n            \n            float positionOffset = direction * _explosionRadius;\n            Vector3 explosionPoint = transform.position + positionOffset;\n            \n            // Create particle\n            GameObject particlePrefab = Instantiate(_prefab, explosionPoint, Quaternion.identity);\n            ExplosionParticle particle = new ExplosionParticle(particlePrefab, explosionPoint, 0f, _force);\n            \n            if (_destroyParentOnExplode)\n                Destroy(gameObject);\n                \n            _explosionParticles.Add(particle);\n            explosionPoints.Add(explodePoint);\n            \n            currentAngle += angleStep;\n        }\n        \n        // Assign audio sources to particles\n        for (int i = 0; i < _explosionCount; i++)\n        {\n            if (_explodeSounds[i] != null && _explosionParticles[i].audioSource == null)\n                _explosionParticles[i].audioSource.clip = _explodeSounds[i];\n        }\n    }\n    \n    private void PlaySpinSound(int index)\n    {\n        if (_spinSounds[index] == null || _audioSource == null) return;\n        \n        _audioSource.PlayOneShot(_spinSounds[index]);\n    }\n    \n    private void Update()\n    {\n        if (!_isSpinning) return;\n        \n        _spinTime += Time.deltaTime * _spinSpeed;\n        \n        float normalizedTime = _spinTime / _spinDuration;\n        float curveValue = _colorTransition.Evaluate(normalizedTime);\n        \n        // Calculate spin direction\n        Vector3 currentDirection = transform.forward;\n        if (_reverseDirection)\n            currentDirection = -currentDirection;\n            \n        // Apply color transition\n        Color targetColor = Color.Lerp(_startColor, _endColor, curveValue);\n        GetComponent<Renderer>().material.color = targetColor;\n        \n        // Rotate object around Y axis\n        transform.Rotate(Vector3.up * _spinSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isSpinning) return;\n        \n        // Trigger explosion when touched by player or other trigger objects\n        PlayExplosion();\n    }\n    \n    private void PlayExplosion()\n    {\n        _audioSource.PlayOneShot(_explodeSounds[Random.Range(0, _explosionCount)] ?? _explodeSounds[0]);\n        \n        for (int i = 0; i < _explosionParticles.Count; i++)\n        {\n            if (_explosionParticles[i].prefab != null)\n            {\n                // Apply force to particle\n                Vector3 forceDirection = (transform.position - _explosionPoints[i]).normalized;\n                _explosionParticles[i].force = Force direction:forceDirection * _explosionForce;\n                \n                // Play explosion sound if audio source and clip exist\n                if (_explosionParticles[i].audioSource != null && _explosionParticles[i].audioSource.clip != null)\n                    _explosionParticles[i].audioSource.Play();\n            }\n        }\n        \n        // Destroy the original object\n        Destroy(gameObject);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 2,
    "prompt": "Make a gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center, all while rotating the entire gravity well slowly.",
    "timestamp": "2026-01-08T20:00:58.536102",
    "oneshot_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class GravityWell : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _maxPullForce = 1000f;\n    [SerializeField] private float _pullRadius = 20f;\n    [SerializeField] private bool _useInverseSquare = true;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _rumbleClips;\n    [SerializeField] private float _minRumbleVolume = 0.1f;\n    [SerializeField] private float _maxRumbleVolume = 0.8f;\n    [SerializeField] private float _rumblePitchRange = 0.5f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem[] _particleSystems;\n    [SerializeField] private int _particlesPerClip = 50;\n    [SerializeField] private float _particleLifetime = 2f;\n    [SerializeField] private bool _enableParticlesOnContact = true;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Light _wellLight;\n    [SerializeField] private Color _baseColor = Color.red;\n    [SerializeField] private float _rotationSpeed = 0.1f;\n    [SerializeField] private AnimationCurve _brightnessCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private List<Rigidbody> _affectedRigidbodies = new List<Rigidbody>();\n    private int _currentAffectedCount;\n    private float _distanceToClosestObject = Mathf.Infinity;\n    private float _rumbleVolume = _minRumbleVolume;\n    private float _pitchMultiplier = 1f;\n    \n    void Start()\n    {\n        InitializeAudio();\n        InitializeParticles();\n        UpdateBrightness();\n        \n        if (_wellLight != null)\n            _wellLight.intensity = 0.3f;\n        else\n            CreateDefaultLight();\n    }\n    \n    void Update()\n    {\n        RotateWell();\n        \n        foreach (Rigidbody rb in _affectedRigidbodies)\n        {\n            ApplyGravityPull(rb);\n            UpdateAudioBasedOnDistance(rb);\n        }\n    }\n    \n    void InitializeAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rumbleClips.Length == 0 || _audioSource.clip == null)\n        {\n            CreateRumbleClip();\n        }\n        \n        _currentAffectedCount = 0;\n        _distanceToClosestObject = Mathf.Infinity;\n    }\n    \n    void InitializeParticles()\n    {\n        foreach (ParticleSystem particle in _particleSystems)\n        {\n            if (particle != null)\n                particle.Stop();\n        }\n    }\n    \n    void CreateRumbleClip()\n    {\n        if (_rumbleClips.Length == 0)\n        {\n            AudioClip clip = new AudioClip(_rumbleClips[0].length ? _rumbleClips[0] : null);\n            if (clip != null)\n                _audioSource.clip = clip;\n            else\n                _audioSource.clip = new AudioClip(300, 1f, 1f);\n        }\n    }\n    \n    void CreateDefaultLight()\n    {\n        Light light = new Light();\n        light.type = LightType.Point;\n        light.intensity = 0.3f;\n        light.color = _baseColor;\n        light.range = 15f;\n        \n        transform.SetParent(null, false);\n        transform.AddChild(light);\n    }\n    \n    void ApplyGravityPull(Rigidbody rb)\n    {\n        if (rb == null) return;\n        \n        float distanceToCenter = Vector3.Distance(rb.position, transform.position);\n        if (distanceToCenter > _pullRadius)\n            return;\n        \n        float force = CalculatePullForce(distanceToCenter, rb.mass);\n        rb.AddForce(Vector3.down * force * Time.deltaTime, ForceMode.Force);\n    }\n    \n    float CalculatePullForce(float distance, float mass)\n    {\n        float pullAmount = 0f;\n        \n        if (_useInverseSquare)\n        {\n            pullAmount = _maxPullForce / (distance * distance);\n        }\n        else\n        {\n            pullAmount = _maxPullForce / distance;\n        }\n        \n        return pullAmount * mass;\n    }\n    \n    void UpdateAudioBasedOnDistance(Rigidbody rb)\n    {\n        float currentDistance = Vector3.Distance(rb.position, transform.position);\n        if (currentDistance < 0.1f && _distanceToClosestObject > currentDistance)\n            _distanceToClosestObject = currentDistance;\n        \n        float volumeRatio = Mathf.Max(0f, (_distanceToClosestObject - currentDistance) / 2f);\n        _rumbleVolume = Mathf.Lerp(_minRumbleVolume, _maxRumbleVolume, volumeRatio);\n        _pitchMultiplier = 1f + (currentDistance / 10f) * _rumblePitchRange;\n        \n        if (_audioSource != null)\n        {\n            _audioSource.pitch = _pitchMultiplier;\n            _audioSource.PlayOneShot(_audioSource.clip, 0.5f * _rumbleVolume);\n        }\n    }\n    \n    void RotateWell()\n    {\n        transform.Rotate(Vector3.up * _rotationSpeed * Time.deltaTime);\n        \n        if (_wellLight != null)\n        {\n            float verticalAngle = -_wellLight.transform.eulerAngles.y;\n            _wellLight.transform.rotation = Quaternion.Euler(0, Mathf.Sin(verticalAngle * 2f * Mathf.PI) * 90f, 0);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && !ContainsAffectedRigidbody(rb))\n        {\n            AddAffectedRigidbody(rb);\n            UpdateAudioBasedOnDistance(rb);\n            \n            if (_enableParticlesOnContact && _particleSystems.Length > 0)\n                PlayParticleEffect();\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && ContainsAffectedRigidbody(rb))\n        {\n            RemoveAffectedRigidbody(rb);\n            \n            if (_enableParticlesOnContact && _particleSystems.Length > 0)\n                StopParticleEffect();\n        }\n    }\n    \n    bool ContainsAffectedRigidbody(Rigidbody rb)\n    {\n        return _affectedRigidbodies.Contains(rb);\n    }\n    \n    void AddAffectedRigidbody(Rigidbody rb)\n    {\n        _affectedRigidbodies.Add(rb);\n        _currentAffectedCount++;\n    }\n    \n    void RemoveAffectedRigidbody(Rigidbody rb)\n    {\n        _affectedRigidbodies.Remove(rb);\n        _currentAffectedCount--;\n    }\n    \n    void PlayParticleEffect()\n    {\n        if (_particleSystems.Length > 0 && _enableParticlesOnContact)\n        {\n            for (int i = 0; i < _particleSystems.Length; i++)\n                _particleSystems[i].Play();\n            \n            StartCoroutine(ResetParticles());\n        }\n    }\n    \n    System.Collections.IEnumerator ResetParticles()\n    {\n        foreach (ParticleSystem particle in _particleSystems)\n        {\n            if (particle != null && particle.isPlaying)\n                particle.Stop();\n        }\n        \n        yield return new WaitForSeconds(_particleLifetime);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _pullRadius * 0.5f);\n        \n        if (_wellLight != null)\n            Gizmos.color = _wellLight.color;\n            Gizmos.DrawLine(transform.position, _wellLight.transform.position);\n    }\n    \n    void OnValidate()\n    {\n        _maxPullForce = Mathf.Max(1f, _maxPullForce);\n        _pullRadius = Mathf.Max(0.1f, _pullRadius);\n        _minRumbleVolume = Mathf.Min(_maxRumbleVolume, _minRumbleVolume);\n        _maxRumbleVolume = Mathf.Max(_minRumbleVolume, _maxRumbleVolume);\n        _rumblePitchRange = Mathf.Max(0.01f, _rumblePitchRange);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 3,
    "prompt": "Build a script that turns any object into a musical instrument - when you collide with it, it plays a note based on where you hit it (top plays high notes, bottom plays low notes), the object's color shifts to match the note's frequency, it vibrates with the sound, and leaves a trail of particles that fade out over 2 seconds.",
    "timestamp": "2026-01-08T20:02:17.891429",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MusicalInstrument : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _baseVolume = 0.5f;\n    [SerializeField] private float _pitchRange = 1f;\n    [SerializeField] private float _volumeRange = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _particleEffect;\n    [SerializeField] private Color _originalColor;\n    [SerializeField] private AnimationCurve _colorTransitionCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _bounceForce = 5f;\n    [SerializeField] private float _slideDistance = 3f;\n    [SerializeField] private LayerMask _groundLayer = -1;\n    \n    [Header(\"Collision Detection\")]\n    private Collider _collider;\n    private Rigidbody _rigidbody;\n    private List<Collider> _hitColliders = new List<Collider>();\n    private Dictionary<Collider, float> _lastHitPointPositions = new Dictionary<Collider, Vector3>();\n    private Dictionary<Collider, float> _hitTimes = new Dictionary<Collider, float>();\n    \n    private void Start()\n    {\n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n            _collider = gameObject.AddComponent<BoxCollider>();\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>(Physics.gravity);\n            \n        _originalColor = _collider.material.color;\n        \n        // Initialize particle system\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            main.startLifetime = 2f;\n            main.startSpeed = 5f;\n            main.maxParticles = 1000f;\n        }\n    }\n    \n    private void Update()\n    {\n        PlayInstrumentSound();\n        \n        // Handle particle effects\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            float time = Time.time - _lastHitTime;\n            main.startLifetime = Mathf.Max(0f, 2f * (1f - Mathf.Clamp01(time / 2f)));\n            \n            // Update particle positions\n            Vector3[] positions = new Vector3[main.numParticles];\n            for (int i = 0; i < main.numParticles; i++)\n                positions[i] = _particleEffect.transform.position + Random.insideUnitSphere * 5f;\n            \n            main.SetPositionData(positions);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        PlayHitEffects(other);\n        \n        // Store hit position and time\n        if (_hitColliders.Count < 10)\n        {\n            _hitColliders.Add(other);\n            _lastHitPointPositions[other] = other.transform.position;\n            _lastHitTime = Time.time;\n        }\n        \n        // Handle physics interactions\n        if (_rigidbody != null && other.CompareTag(\"Player\"))\n        {\n            Vector3 hitPoint = _lastHitPointPositions[other];\n            Vector3 slideDirection = (hitPoint - other.transform.position).normalized;\n            \n            // Slide rigidbody toward the hit point\n            _rigidbody.velocity = new Vector3(\n                slideDirection.x * 5f,\n                _rigidbody.velocity.y,\n                slideDirection.z * 5f\n            );\n        }\n        \n        // Bounce if hitting solid surface\n        if (Physics.CheckSphere(hitPoint, 0.1f) && other.CompareTag(\"Ground\"))\n        {\n            Vector3 normal = -_rigidbody.velocity.normalized;\n            _rigidbody.AddForce(normal * _bounceForce);\n        }\n    }\n    \n    private void PlayHitEffects(Collider hit)\n    {\n        // Play sound at hit point\n        PlaySoundAtPoint(hit.transform.position);\n        \n        // Apply color shift based on hit position relative to center\n        float verticalRatio = (hit.transform.position.y - transform.position.y) / _baseHeight;\n        Color targetColor = GetTargetColor(verticalRatio);\n        if (_collider != null)\n            _collider.material.color = Color.Lerp(_originalColor, targetColor, \n                _colorTransitionCurve.Evaluate(Mathf.Abs(verticalRatio)));\n    }\n    \n    private void PlaySoundAtPoint(Vector3 hitPoint)\n    {\n        if (_audioSource == null)\n            return;\n            \n        // Calculate frequency based on vertical position\n        float targetPitch = 440f * Mathf.Pow(0.5f + (hitPoint.y - transform.position.y) / _baseHeight, 1f);\n        targetPitch = Mathf.Clamp(targetPitch, 20f, 20000f); // Clamp to playable range\n        \n        // Calculate volume based on horizontal distance from center\n        float horizontalRatio = Vector3.Distance(hitPoint, new Vector3(transform.position.x, transform.position.y, transform.position.z), \n            new Vector3(transform.position.x, transform.position.y, hitPoint.z)) / _baseWidth;\n        float targetVolume = _baseVolume * Mathf.Pow(0.5f + horizontalRatio, 1f);\n        \n        // Apply pitch and volume\n        _audioSource.pitch = targetPitch / 440f; // Convert Hz to Unity pitch\n        _audioSource.volume = targetVolume;\n        _audioSource.Play();\n    }\n    \n    private Color GetTargetColor(float verticalRatio)\n    {\n        float baseFrequency = 220f + (verticalRatio * 1000f); // Base frequency range\n        float noteValue = Mathf.Abs(Mathf.Log10(baseFrequency / 440f)) / 12f; // Semitone offset\n        \n        float hue = 0f;\n        switch (Mathf.RoundToInt(noteValue))\n        {\n            case 0: return _originalColor;\n            case 1: hue = 120f; break;\n            case 2: hue = 240f; break;\n            case 3: hue = 360f; break;\n            default:\n                float baseAngle = (Mathf.Abs(noteValue) * 90f);\n                hue = baseAngle + (verticalRatio * 180f);\n                break;\n        }\n        \n        return Color.HSVToRGB(hue % 360f, 0.8f, 1f);\n    }\n    \n    private float _baseHeight;\n    private float _baseWidth;\n    private float _baseHeight = 2f;\n    private float _baseWidth = 1f;\n    private float _lastHitTime = 0f;\n    \n    private void OnValidate()\n    {\n        if (_baseHeight <= 0f) _baseHeight = 0.5f;\n        if (_baseWidth <= 0f) _baseWidth = 0.5f;\n        \n        // Clamp pitch range\n        _pitchRange = Mathf.Min(1f, Mathf.Log10(_baseFrequencyMax / _baseFrequencyMin));\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _originalColor;\n        Gizmos.DrawWireCube(transform.position, new Vector3(_baseWidth * 0.5f, _baseHeight * 0.5f, _baseWidth * 0.5f));\n        \n        // Draw hit point indicator\n        if (_hitColliders.Count > 0)\n        {\n            Vector3 hitPoint = _lastHitPointPositions[_hitColliders[0]];\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(hitPoint, 0.1f);\n            \n            // Draw frequency range arc\n            float angle = (hitPoint.y - transform.position.y) / (_baseHeight * 0.5f) * 90f;\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position + new Vector3(0f, _baseHeight * 0.25f, 0f), \n                transform.position + new Vector3(Mathf.Cos(angle * Mathf.Deg2Rad) * _baseWidth * 0.5f, \n                _baseHeight * 0.5f, -Mathf.Sin(angle * Mathf.Deg2Rad) * _baseWidth * 0.5f));\n        }\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 4,
    "prompt": "Create a creature that has 5 states: idle (sits still, plays ambient breathing), curious (slowly approaches player if within 10 units, plays questioning sound), scared (runs away from player, plays panic sound, color turns red), aggressive (chases player, plays roar, color turns dark, applies force toward player), and exhausted (stops moving, plays tired sound, color fades to gray). It transitions between states based on player distance and how long it's been in current state.",
    "timestamp": "2026-01-08T20:03:36.783168",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class StateMachine : MonoBehaviour\n{\n    [System.Serializable]\n    public class State\n    {\n        public string name;\n        public bool isActive = true;\n        public List<TriggerCondition> triggers = new List<TriggerCondition>();\n        public List<ExecuteAction> actions = new List<ExecuteAction>();\n        \n        public State(string name)\n        {\n            this.name = name;\n        }\n    }\n\n    [System.Serializable]\n    public class TriggerCondition\n    {\n        public string conditionType;\n        public string conditionKey;\n        public float threshold;\n        public bool usesTime;\n        public int timeInterval;\n\n        public TriggerCondition(string type, string key, float t = 0f)\n        {\n            this.conditionType = type;\n            this.conditionKey = key;\n            this.threshold = t;\n            this.usesTime = false;\n            this.timeInterval = 1;\n        }\n    }\n\n    [System.Serializable]\n    public class ExecuteAction\n    {\n        public string actionType;\n        public ActionFunction actionMethod;\n\n        public ExecuteAction(string type, ActionFunction method)\n        {\n            this.actionType = type;\n            this.actionMethod = method;\n        }\n    }\n\n    [System.Serializable]\n    private class ActionFunction\n    {\n        public delegate void UnityAction();\n        public UnityAction unityAction;\n        \n        public ActionFunction(UnityAction action) => unityAction = action;\n        public ActionFunction() { unityAction = null; }\n    }\n\n    [Header(\"State Definitions\")]\n    [SerializeField] private List<State> _states = new List<State>();\n    \n    [Header(\"Component References\")]\n    [SerializeField] private Transform _stateMachineTransform;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private Animator _animator;\n    [SerializeField] private Renderer _renderer;\n\n    [Header(\"State Transitions\")]\n    [SerializeField] private Dictionary<string, State> _currentState = new Dictionary<string, State>();\n    [SerializeField] private float _transitionDelay = 0.1f;\n    [SerializeField] private bool _allowSimultaneousTransitions = false;\n\n    private List<TriggerCondition> _currentTriggers = new List<TriggerCondition>();\n    private List<ExecuteAction> _currentActions = new List<ExecuteAction>();\n\n    private Dictionary<string, float> _triggerTimers = new Dictionary<string, float>();\n    private Dictionary<string, float> _actionTimers = new Dictionary<string, float>();\n\n    private void Start()\n    {\n        InitializeStates();\n        SetupStateTransitions();\n        SetInitialState();\n    }\n\n    private void Update()\n    {\n        if (!_currentState.ContainsKey(_states[0].name))\n            return;\n\n        EvaluateTriggers();\n\n        if (_allowSimultaneousTransitions)\n        {\n            HandleSimultaneousTransitions();\n        }\n        else\n        {\n            PerformSingleTransition();\n        }\n        \n        ExecuteCurrentActions();\n    }\n\n    private void InitializeStates()\n    {\n        foreach (var state in _states)\n        {\n            _currentState[state.name] = state;\n        }\n\n        if (_animator != null)\n        {\n            _animator.enabled = false;\n        }\n    }\n\n    private void SetupStateTransitions()\n    {\n        foreach (var state in _states)\n        {\n            for (int i = 0; i < state.triggers.Count; i++)\n            {\n                var trigger = state.triggers[i];\n                \n                if (trigger.conditionType == \"Distance\")\n                {\n                    trigger.threshold = 10f;\n                }\n                else if (trigger.conditionType == \"Time\")\n                {\n                    trigger.threshold = Time.deltaTime * trigger.timeInterval;\n                }\n\n                // Create transition key\n                string transitionKey = $\"Transition_{state.name}_{trigger.conditionType}_{trigger.conditionKey}\";\n                \n                // Add transition to state machine\n                _states[0].triggers.Add(new TriggerCondition(\"Distance\", \"distanceToPlayer\", 10f));\n                _states[0].actions.Add(new ExecuteAction(\"ChangeState\", new ActionFunction(() => EnterNewState(transitionKey))));\n            }\n        }\n\n        foreach (var state in _states)\n        {\n            var transitionKey = $\"Transition_{state.name}_Enter\";\n            _states[0].triggers.Add(new TriggerCondition(transitionKey, \"trigger\", 0f));\n            _states[0].actions.Add(new ExecuteAction(\"ChangeState\", new ActionFunction(() => EnterNewState(transitionKey))));\n        }\n    }\n\n    private void EvaluateTriggers()\n    {\n        foreach (var trigger in _currentTriggers)\n        {\n            bool shouldTrigger = false;\n\n            if (trigger.conditionType == \"Distance\")\n            {\n                float distanceToPlayer = Vector3.Distance(_stateMachineTransform.position, PlayerController.transform.position);\n                shouldTrigger = distanceToPlayer <= trigger.threshold;\n            }\n            else if (trigger.conditionType == \"Time\")\n            {\n                float elapsed = Time.time - _triggerTimers[trigger.conditionKey];\n                shouldTrigger = elapsed >= trigger.threshold && !trigger.usesTime || elapsed >= trigger.threshold * 0.5f;\n            }\n\n            if (shouldTrigger)\n            {\n                TriggerCondition oldTrigger = _currentTriggers.Find(t => t.conditionKey == trigger.conditionKey);\n                if (oldTrigger != null)\n                    _currentTriggers.Remove(oldTrigger);\n\n                _currentTriggers.Add(trigger);\n                \n                // Reset timers for this trigger\n                _triggerTimers[trigger.conditionKey] = Time.time;\n            }\n        }\n\n        RemoveExpiredTimers();\n    }\n\n    private void RemoveExpiredTimers()\n    {\n        foreach (var timer in _triggerTimers)\n        {\n            if (!timer.Value.Equals(Time.time))\n            {\n                _currentTriggers.Remove(timer.Key);\n                _triggerTimers.Remove(timer.Key);\n            }\n        }\n    }\n\n    private void HandleSimultaneousTransitions()\n    {\n        List<string> transitionKeys = new List<string>();\n        \n        foreach (var trigger in _currentTriggers)\n        {\n            string transitionKey = $\"Transition_{trigger.conditionKey}\";\n            if (!_transitionDelay keys.Contains(transitionKey))\n                transitionKeys.Add(transitionKey);\n        }\n\n        foreach (string key in transitionKeys)\n        {\n            if (_currentState.ContainsKey(key))\n            {\n                EnterNewState(key);\n                _currentTriggers.Clear();\n                _triggerTimers.Clear();\n                _actionTimers.Clear();\n                \n                // Reset all triggers for this state\n                var targetState = _states.Find(s => s.name == key.Split(\"_\")[1]);\n                if (targetState != null)\n                {\n                    foreach (var t in targetState.triggers)\n                        _currentTriggers.Add(t);\n                }\n            }\n        }\n    }\n\n    private void PerformSingleTransition()\n    {\n        string transitionKey = _states[0].triggers.Find(t => t.conditionKey == \"trigger\");\n        \n        EnterNewState(transitionKey);\n        _currentTriggers.Clear();\n        _triggerTimers.Clear();\n        _actionTimers.Clear();\n\n        // Reset all triggers for this state\n        var targetState = _currentState[transitionKey];\n        if (targetState != null)\n        {\n            foreach (var t in targetState.triggers)\n                _currentTriggers.Add(t);\n        }\n    }\n\n    private void EnterNewState(string transitionKey)\n    {\n        string newStateName = transitionKey.Split(\"_\")[1];\n\n        if (!_currentState.ContainsKey(newStateName))\n        {\n            State new_state = _states.Find(s => s.name == newStateName) ?? CreateDefaultState(newStateName);\n            _currentState[newStateName] = new_state;\n        }\n\n        _currentTriggers.Clear();\n        _triggerTimers.Clear();\n        _actionTimers.Clear();\n\n        foreach (var trigger in _states[newStateName].triggers)\n        {\n            _currentTriggers.Add(trigger);\n        }\n    }\n\n    private State CreateDefaultState(string name)\n    {\n        var state = new State(name);\n        state.triggers.Add(new TriggerCondition(\"Distance\", \"distanceToPlayer\", 10f));\n        return state;\n    }\n\n    private void ExecuteCurrentActions()\n    {\n        foreach (var action in _currentActions)\n        {\n            if (action.unityAction != null)\n                action.unityAction.Invoke();\n            \n            // Check for action timer expiration\n            if (_actionTimers.ContainsKey(action.actionType))\n            {\n                float elapsed = Time.time - _actionTimers[action.actionType];\n                if (elapsed >= 1f)\n                {\n                    _currentActions.Remove(action.actionType);\n                    _actionTimers.Remove(action.actionType);\n                }\n            }\n        }\n\n        // Remove expired action timers\n        foreach (var timer in _actionTimers)\n        {\n            if (!timer.Value.Equals(Time.time))\n            {\n                _currentActions.Remove(timer.Key);\n                _actionTimers.Remove(timer.Key);\n            }\n        }\n    }\n\n    private void EnterState(string newStateName)\n    {\n        State targetState = _states.Find(s => s.name == newStateName) ?? CreateDefaultState(newStateName);\n\n        // Add all triggers from the new state\n        foreach (var trigger in targetState.triggers)\n        {\n            _currentTriggers.Add(trigger);\n        }\n\n        // Clear any existing actions for this state\n        _currentActions.Clear();\n\n        // Add all actions from the new state\n        foreach (var action in targetState.actions)\n        {\n            _currentActions.Add(action);\n        }\n\n        // Start timer tracking for each trigger and action\n        foreach (var trigger in targetState.triggers)\n        {\n            _triggerTimers[trigger.conditionKey] = Time.time;\n        }\n\n        foreach (var action in targetState.actions)\n        {\n            if (action.unityAction != null)\n                _actionTimers[action.actionType] = Time.time + 1f;\n        }\n    }\n\n    private void ExitCurrentState()\n    {\n        // Reset all timers for current state\n        foreach (var timer in _triggerTimers)\n        {\n            _currentTriggers.Remove(timer.Key);\n            _triggerTimers.Remove(timer.Key);\n        }\n\n        foreach (var timer in _actionTimers)\n        {\n            if (_actionTimers.ContainsKey(timer.Key))\n            {\n                _currentActions.Remove(timer.Key);\n                _actionTimers.Remove(timer.Key);\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_stateMachineTransform.position, 0.5f);\n\n        // Draw state indicators\n        if (_currentState.ContainsKey(\"Idle\"))\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_stateMachineTransform.position + transform.up * 1f, 0.3f);\n        }\n\n        if (_currentState.ContainsKey(\"Curious\"))\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(_stateMachineTransform.position + transform.forward * 0.5f, 0.3f);\n        }\n\n        if (_currentState.ContainsKey(\"Scared\"))\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(_stateMachineTransform.position - transform.up * 1f, 0.3f);\n        }\n\n        if (_currentState.ContainsKey(\"Aggressive\"))\n        {\n            Gizmos.color = Color.darkgray;\n            Gizmos.DrawWireCube(_stateMachineTransform.position + transform.forward * 2f, 0.3f);\n        }\n\n        if (_currentState.ContainsKey(\"Exhausted\"))\n        {\n            Gizmos.color = Color.gray;\n            Gizmos.DrawWireCube(_stateMachineTransform.position - transform.up * 1.5f, 0.3f);\n        }\n    }\n\n    private Transform PlayerController\n    {\n        get => GameObject.FindGameObjectWithTag(\"Player\").transform;\n    }\n\n    // Helper methods\n    public void AddState(string stateName)\n    {\n        if (!_states.Contains(new State(stateName)))\n            _states.Add(new State(stateName));\n    }\n\n    public void RemoveState(string stateName)\n    {\n        var state = _states.Find(s => s.name == stateName);\n        if (state != null && _states.Contains(state))\n            _states.Remove(state);\n    }\n\n    public void AddTriggerToState(string stateName, string triggerType, string triggerKey, float threshold = 0f)\n    {\n        State state = _states.Find(s => s.name == stateName) ?? CreateDefaultState(stateName);\n        TriggerCondition newTrigger = new TriggerCondition(triggerType, triggerKey, threshold);\n\n        if (!_triggerExists(state, newTrigger))\n            state.triggers.Add(newTrigger);\n    }\n\n    public void AddActionToState(string stateName, string actionType, ActionFunction actionMethod)\n    {\n        State state = _states.Find(s => s.name == stateName) ?? CreateDefaultState(stateName);\n        ExecuteAction newAction = new ExecuteAction(actionType, actionMethod);\n\n        if (!_triggerExists(state, \"execute\", 0f))\n            state.actions.Add(newAction);\n    }\n\n    private bool _triggerExists(State state, string triggerKey)\n    {\n        foreach (var t in state.triggers)\n        {\n            if (t.conditionKey == triggerKey)\n                return true;\n        }\n        return false;\n    }\n\n    public void SetState(string newStateName)\n    {\n        if (!_currentState.ContainsKey(newStateName))\n        {\n            CreateDefaultState(newStateName);\n        }\n\n        EnterState(newStateName);\n    }\n\n    private void PlayAudioClip(AudioClip clip, float pitch = 1f)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.pitch = pitch;\n            clip.Play();\n        }\n    }\n\n    private void ApplyForceToPlayer(float force)\n    {\n        if (PlayerController != null)\n        {\n            // Use rigidbody or character movement\n            var rb = PlayerController.GetComponent<Rigidbody>();\n            if (rb != null)\n                rb.AddForce(transform.forward * force, ForceMode.Impulse);\n            else\n            {\n                // Fallback: apply local force to player transform\n                Vector3 direction = (PlayerController.position - _stateMachineTransform.position).normalized;\n                float distance = Vector3.Distance(_stateMachineTransform.position, PlayerController.position);\n                if (distance > 0.1f)\n                    direction.Normalize();\n                \n                Vector3 forceVector = direction * force;\n                PlayerController.Move(forceVector * Time.deltaTime);\n            }\n        }\n    }\n\n    private void OnApplicationQuit()\n    {\n        ExitCurrentState();\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 5,
    "prompt": "Make a door that has locked, unlocking, open, and closing states. When locked, it plays a rattle sound and shakes slightly. When unlocking, it plays a key-turning sound for 3 seconds while rotating slowly, then transitions to open. When open, it plays a creak and stays open for 10 seconds, then automatically starts closing. During closing, it rotates back while playing a slam sound, then locks again. The door's material emission color changes with each state.",
    "timestamp": "2026-01-08T20:05:37.431651",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class Door : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _unlockRotationDuration = 3f;\n    [SerializeField] private float _openDuration = 10f;\n    [SerializeField] private bool _autoClose = true;\n    [SerializeField] private float _autoCloseDelay = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _rattleSounds;\n    [SerializeField] private AudioClip[] _unlockSounds;\n    [SerializeField] private AudioClip[] _openSounds;\n    [SerializeField] private AudioClip[] _closeSounds;\n    [SerializeField] private AudioClip[] _lockSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _doorParticles;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private AudioSource _audioSource;\n    \n    private bool _isLocked = true;\n    private bool _isUnlocking = false;\n    private bool _isOpen = false;\n    private bool _wasOpenedThisFrame = false;\n    private float _lastOpenTime;\n    private Coroutine _currentCoroutine;\n    \n    private void Start()\n    {\n        if (_trailRenderer == null)\n            _trailRenderer = GetComponent<TrailRenderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_doorParticles != null && !_doorParticles.isPlaying)\n            _doorParticles.Play();\n    }\n    \n    private void Update()\n    {\n        HandleDoorRotation();\n        CheckAutoClose();\n        \n        if (!_wasOpenedThisFrame && _isOpen)\n        {\n            _lastOpenTime = Time.time;\n            _wasOpenedThisFrame = true;\n        }\n    }\n    \n    public void ToggleDoor(bool lockState)\n    {\n        if (_isLocked == lockState) return;\n        \n        _isLocked = lockState;\n        \n        if (!_isUnlocking && !_isOpen)\n        {\n            StartCoroutine(UnlockDoor());\n        }\n        else if (_isUnlocking || _isOpen)\n        {\n            StopCoroutine(_currentCoroutine);\n            _currentCoroutine = null;\n            \n            if (_isUnlocking)\n            {\n                StartCoroutine(OpenDoor());\n            }\n            else\n            {\n                CloseDoor();\n            }\n        }\n    }\n    \n    private void HandleDoorRotation()\n    {\n        float targetAngle = _isLocked ? 0f : -90f * Mathf.Sin(Time.time * _rotationSpeed);\n        \n        transform.rotation = Quaternion.Euler(0, targetAngle, 0);\n    }\n    \n    private void CheckAutoClose()\n    {\n        if (_autoClose && Time.time >= _lastOpenTime + _autoCloseDelay)\n        {\n            CloseDoor();\n        }\n    }\n    \n    private IEnumerator UnlockDoor()\n    {\n        _isUnlocking = true;\n        \n        transform.Rotate(0, -90f * Time.deltaTime);\n        \n        for (int i = 0; i < _unlockRotationDuration / 2f; i++)\n        {\n            yield return new WaitForSeconds(1f / _unlockRotationDuration);\n            transform.Rotate(0, -90f * Time.deltaTime);\n        }\n        \n        if (_isLocked)\n        {\n            PlayLockSound();\n            _isLocked = false;\n            _isOpen = true;\n            \n            if (!_wasOpenedThisFrame && _audioSource != null)\n                _audioSource.PlayOneShot(_openSounds[Random.Range(0, _openSounds.Length)]);\n                \n            yield return new WaitForSeconds(_autoCloseDelay);\n        }\n        \n        StopCoroutine(_currentCoroutine);\n        _currentCoroutine = null;\n    }\n    \n    private IEnumerator OpenDoor()\n    {\n        _isUnlocking = false;\n        _isOpen = true;\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        PlayOpenSound();\n        \n        yield return new WaitForSeconds(_autoCloseDelay);\n        \n        StopCoroutine(_currentCoroutine);\n        _currentCoroutine = null;\n    }\n    \n    private void CloseDoor()\n    {\n        _isOpen = false;\n        _isUnlocking = false;\n        _wasOpenedThisFrame = false;\n        \n        PlayCloseSound();\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = true;\n            \n        transform.Rotate(0, 90f * Time.deltaTime);\n        \n        if (_audioSource != null && !Mathf.Approximately(transform.eulerAngles.y, -90f))\n        {\n            PlayLockSound();\n            _isLocked = true;\n        }\n        \n        StopCoroutine(_currentCoroutine);\n        _currentCoroutine = null;\n    }\n    \n    private void PlayLockSound()\n    {\n        if (_lockSounds == null || _lockSounds.Length <= 0)\n            return;\n            \n        int randomIndex = Random.Range(0, _lockSounds.Length);\n        _audioSource.PlayOneShot(_lockSounds[randomIndex]);\n    }\n    \n    private void PlayUnlockSound()\n    {\n        if (_unlockSounds == null || _unlockSounds.Length <= 0)\n            return;\n            \n        int randomIndex = Random.Range(0, _unlockSounds.Length);\n        _audioSource.PlayOneShot(_unlockSounds[randomIndex]);\n    }\n    \n    private void PlayOpenSound()\n    {\n        if (_openSounds == null || _openSounds.Length <= 0)\n            return;\n            \n        int randomIndex = Random.Range(0, _openSounds.Length);\n        _audioSource.PlayOneShot(_openSounds[randomIndex]);\n    }\n    \n    private void PlayCloseSound()\n    {\n        if (_closeSounds == null || _closeSounds.Length <= 0)\n            return;\n            \n        int randomIndex = Random.Range(0, _closeSounds.Length);\n        _audioSource.PlayOneShot(_closeSounds[randomIndex]);\n    }\n    \n    public bool IsLocked() => _isLocked;\n    public bool IsOpen() => _isOpen;\n    public bool IsUnlocking() => _isUnlocking;\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n        \n        if (_trailRenderer != null)\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position - Vector3.up * 0.5f, transform.position + Vector3.up * 0.5f);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 6,
    "prompt": "Create a bouncy ball that, every time it hits a surface, bounces higher than the previous bounce, plays a pitch that increases with each bounce, changes color based on bounce count, and leaves a temporary trail. After 10 bounces, it explodes into confetti particles while playing a celebration sound.",
    "timestamp": "2026-01-08T20:06:50.174640",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class BouncyBall : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _bounceHeightMultiplier = 1.2f;\n    [SerializeField] private float _bounceAngleVariation = 30f;\n    [SerializeField] private int _maxBounces = 10;\n    \n    [Header(\"Pitch Settings\")]\n    [SerializeField] private AudioSource _pitchAudioSource;\n    [SerializeField] private AudioClip[] _pitchClips;\n    [SerializeField] private float _pitchSpeed = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _confettiParticleSystem;\n    [SerializeField] private AudioClip _celebrationSound;\n    [SerializeField] private float _trailLifetime = 5f;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private int _baseRampLength = 20;\n    [SerializeField] private Color _startColor = Color.red;\n    [SerializeField] private Color _endColor = Color.yellow;\n    [SerializeField] private AnimationCurve _colorRamp = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);\n    \n    private int _bounceCount = 0;\n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private bool _hasExploded = false;\n    private List<Collider> _hitColliders = new List<Collider>();\n    \n    void Start()\n    {\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        \n        if (_pitchAudioSource == null)\n            _pitchAudioSource = GetComponent<AudioSource>();\n            \n        if (_confettiParticleSystem == null && _celebrationSound != null)\n        {\n            GameObject go = new GameObject(\"Celebration\");\n            go.transform.SetParent(transform);\n            _confettiParticleSystem = go.AddComponent<ParticleSystem>();\n            _confettiParticleSystem.add(new ParticleSystem(prefab: require(typeof(ParticleSystem)).GetComponent<Prefab>(\"ConfettiParticles\"));\n            go.AddComponent<AudioSource>(name: \"CelebrateSoundSource\", pitch: 0.5f, loop: true);\n        }\n        \n        if (_pitchClips.Length == 0)\n        {\n            _pitchAudioSource.clip = _celebrationSound;\n            _pitchAudioSource.loop = false;\n        }\n    }\n    \n    void Update()\n    {\n        if (_hasExploded) return;\n        \n        // Bounce physics\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 bounceDirection = rb.velocity.normalized * -1f;\n            bounceDirection.y *= -1f; // Keep bouncing up\n            \n            // Apply bounce force with increasing height\n            float currentBounceForce = _bounceHeightMultiplier ^ _bounceCount;\n            rb.AddForce(bounceDirection * currentBounceForce, ForceMode.Impulse);\n            \n            // Add random variation to angle\n            Vector3 variation = new Vector3(\n                Random.Range(-_bounceAngleVariation, _bounceAngleVariation),\n                0f,\n                Random.Range(-_bounceAngleVariation, _bounceAngleVariation)\n            );\n            rb.AddForce(variation, ForceMode.Acceleration);\n        }\n        \n        // Play pitch sound with increasing speed\n        if (_pitchAudioSource != null && !_hasExploded)\n        {\n            float pitchSpeedMultiplier = 1f + (_bounceCount / _baseRampLength);\n            _pitchAudioSource.pitch = pitchSpeedMultiplier;\n            \n            int clipIndex = _bounceCount % _pitchClips.Length;\n            if (clipIndex >= 0 && clipIndex < _pitchClips.Length)\n                _pitchAudioSource.PlayOneShot(_pitchClips[clipIndex]);\n        }\n        \n        // Color ramp effect\n        Color targetColor = GetRampColor(_bounceCount / _baseRampLength);\n        Color currentColor = transform.color;\n        \n        if (currentColor != targetColor)\n        {\n            float t = _bounceCount / _baseRampLength;\n            currentColor = Color.Lerp(currentColor, targetColor, t);\n            \n            // Animate color over time\n            float alpha = 1f - Mathf.Abs(1f - t) * 0.5f;\n            transform.color = new Color(currentColor.r, currentColor.g, currentColor.b, alpha);\n        }\n        \n        // Trail effect\n        if (_trailLifetime > 0f)\n        {\n            GameObject trailObject = new GameObject(\"Trail\");\n            trailObject.transform.SetParent(transform);\n            trailObject.AddComponent<ParticleSystem>();\n            \n            trailObject.GetComponent<ParticleSystem>().Add(new ParticleSystem(prefab: require(typeof(ParticleSystem)).GetComponent<Prefab>(\"TrailParticles\"));\n            trailObject.GetComponent<ParticleSystem>().play();\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_hasExploded) return;\n        \n        // Store hit collider\n        _hitColliders.Add(other);\n        \n        // Apply bounce physics when hitting ground or surface\n        if (other.CompareTag(\"Ground\") || other.CompareTag(\"Wall\"))\n        {\n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 normal = -rb.velocity.normalized;\n                float currentBounceForce = _bounceHeightMultiplier ^ _bounceCount;\n                rb.AddForce(normal * currentBounceForce, ForceMode.Impulse);\n                \n                // Store original position for centering\n                _originalPosition = transform.position;\n            }\n            \n            _bounceCount++;\n            \n            // Reset trail effect\n            if (_trailLifetime > 0f)\n            {\n                GameObject trailObject = new GameObject(\"Trail\");\n                trailObject.transform.SetParent(transform);\n                trailObject.AddComponent<ParticleSystem>();\n                \n                trailObject.GetComponent<ParticleSystem>().Add(new ParticleSystem(prefab: require(typeof(ParticleSystem)).GetComponent<Prefab>(\"TrailParticles\"));\n                trailObject.GetComponent<ParticleSystem>().play();\n            }\n            \n            // Update color\n            Color targetColor = GetRampColor(_bounceCount / _baseRampLength);\n            Color currentColor = transform.color;\n            \n            if (currentColor != targetColor)\n            {\n                float t = _bounceCount / _baseRampLength;\n                currentColor = Color.Lerp(currentColor, targetColor, t);\n                transform.color = new Color(currentColor.r, currentColor.g, currentColor.b, 1f);\n            }\n        }\n    }\n    \n    private Color GetRampColor(float normalizedValue)\n    {\n        if (normalizedValue >= 0.5f) return _endColor;\n        else return _startColor;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_originalPosition, 0.3f);\n        \n        // Draw bounce indicator\n        Vector3 direction = (transform.position - _originalPosition).normalized;\n        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;\n        Gizmos.DrawLine(_originalPosition + direction * 0.5f, \n            _originalPosition + new Vector3(Mathf.Cos(angle), 0f, Mathf.Sin(angle)) * 0.5f);\n    }\n    \n    void OnDrawGizmosSelected_Bounce(int bounce)\n    {\n        if (bounce < 1 && _hasExploded) return;\n        \n        Gizmos.color = Color.blue;\n        float height = Mathf.Pow(_bounceHeightMultiplier, bounce) * 0.3f;\n        Vector3 targetPos = _originalPosition + new Vector3(\n            Random.Range(-0.5f, 0.5f),\n            height,\n            Random.Range(-0.5f, 0.5f)\n        );\n        \n        Gizmos.DrawWireSphere(targetPos, height);\n    }\n    \n    void Explode()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        \n        // Play celebration sound\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource != null && _celebrationSound != null)\n            audioSource.PlayOneShot(_celebrationSound);\n        \n        // Spawn confetti particles\n        ParticleSystem confetti = _confettiParticleSystem;\n        confetti.Play();\n        \n        // Add random rotation for visual effect\n        transform.Rotate(0f, Random.Range(0f, 360f), 0f);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 7,
    "prompt": "Make an object that floats upward when you're near it (within 5 units), but falls faster when you're far away. It plays a humming sound that gets higher pitched as it rises, and lower pitched as it falls. The object also rotates opposite to its vertical movement direction, and its scale pulses in sync with the audio frequency.",
    "timestamp": "2026-01-08T20:08:13.594999",
    "oneshot_code": "using UnityEngine;\n\npublic class FloatingObject : MonoBehaviour\n{\n    [Header(\"Floating Settings\")]\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _maxFloatHeight = 10f;\n    [SerializeField] private bool _loop = true;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private bool _rotate = true;\n    [SerializeField] private float _rotationSpeed = 100f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.up;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _hummingSounds;\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchMultiplier = 2f;\n    [SerializeField] private float _minPitch = 0.5f;\n    [SerializeField] private float _maxPitch = 4f;\n    \n    [Header(\"Scale Pulse Settings\")]\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);\n    \n    private Vector3 _currentPosition;\n    private bool _isActive = true;\n    private int _currentSoundIndex = 0;\n    private float _originalScale;\n    private float _targetPitch;\n    private float _pulseTimer;\n    \n    void Start()\n    {\n        _currentPosition = transform.position;\n        _originalScale = transform.localScale.x;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupAudio();\n    }\n    \n    void Update()\n    {\n        HandleFloating();\n        HandleRotation();\n        HandlePulse();\n        UpdateAudio();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null || _hummingSounds.Length == 0)\n            return;\n            \n        _targetPitch = _basePitch * Mathf.Lerp(_minPitch, _maxPitch, (float)Random.Range(0f, 1f));\n        _currentSoundIndex = Random.Range(0, _hummingSounds.Length);\n        \n        PlayHummingSound();\n    }\n    \n    private void HandleFloating()\n    {\n        if (!_isActive) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, Camera.main.transform.position);\n        float pitchMultiplier = Mathf.Lerp(_minPitch, _maxPitch, distanceToPlayer / 5f);\n        pitchMultiplier = Mathf.Clamp01(pitchMultiplier);\n        \n        _targetPitch = _basePitch * pitchMultiplier;\n        \n        if (distanceToPlayer <= 5f)\n        {\n            Vector3 targetPosition = _currentPosition + Vector3.up * _floatSpeed * Time.deltaTime;\n            targetPosition.y = Mathf.Min(_maxFloatHeight, targetPosition.y);\n            transform.position = targetPosition;\n        }\n        else\n        {\n            float fallSpeed = _floatSpeed * (1f - distanceToPlayer / 10f);\n            Vector3 targetPosition = _currentPosition + Vector3.up * -fallSpeed * Time.deltaTime;\n            targetPosition.y = Mathf.Max(-_maxFloatHeight, targetPosition.y);\n            transform.position = targetPosition;\n        }\n    }\n    \n    private void HandleRotation()\n    {\n        if (!_rotate) return;\n        \n        float rotationAmount = _rotationSpeed * Time.deltaTime;\n        Vector3 rotationAxis = _rotationAxis;\n        \n        if (_isActive && transform.position.y > 0f)\n        {\n            rotationAxis.y *= -1f; // Rotate opposite to upward movement\n        }\n        \n        Quaternion targetRotation = Quaternion.Euler(rotationAxis * rotationAmount);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * _rotationSpeed);\n    }\n    \n    private void HandlePulse()\n    {\n        if (!_isActive) return;\n        \n        _pulseTimer += Time.deltaTime * _pulseSpeed;\n        float pulseValue = _pulseCurve.Evaluate(_pulseTimer % (1f / _pulseSpeed));\n        transform.localScale = new Vector3(_originalScale * pulseValue, 1f, _originalScale * pulseValue);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (!_isActive || _audioSource == null) return;\n        \n        float pitchOffset = (_targetPitch - _basePitch) / (2f * Mathf.PI);\n        float timeMultiplier = 1f + Mathf.Sin(Time.time * _pulseSpeed * 2f) * 0.5f; // Add slight pulse variation\n        \n        if (_currentSoundIndex >= _hummingSounds.Length)\n            _currentSoundIndex = 0;\n        \n        _audioSource.pitch = _basePitch * timeMultiplier * (1f + pitchOffset);\n        _audioSource.clip = _hummingSounds[_currentSoundIndex];\n        _audioSource.Play();\n    }\n    \n    public void Activate()\n    {\n        _isActive = true;\n    }\n    \n    public void Deactivate()\n    {\n        _isActive = false;\n        if (_audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n            Activate();\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n            Deactivate();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + Vector3.up * _floatSpeed * 0.1f;\n        \n        if (_isActive && transform.position.y > 0f)\n            endPos.y *= -1f; // Show rotation direction\n        \n        Gizmos.DrawLine(startPos, endPos);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": null,
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": null,
    "grade": null,
    "error": null
  }
]