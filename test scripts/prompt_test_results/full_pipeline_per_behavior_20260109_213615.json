[
  {
    "prompt": "1. \"Create a script that makes an object spin faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase.\"",
    "success": true,
    "generation_time": 60.27023768424988,
    "rag_docs_used": 16,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class SpinningExplosive : MonoBehaviour\n{\n    [SerializeField] private float spinUpSpeed = 2.0f;\n    [SerializeField] private float maxSpinSpeed = 1000.0f;\n    [SerializeField] private float explosionForce = 500.0f;\n    [SerializeField] private int pieceCount = 10;\n    [SerializeField] private AudioClip spinSound = null;\n\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private bool isExploding = false;\n    private Color startColor = new Color(0, 0, 1, 1);\n    private Color endColor = new Color(1, 0, 0, 1);\n\n    void Start()\n    {\n        // Get components\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n\n        // Cache player reference if needed (not required for this behavior)\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            Debug.Log(\"Player found: \" + playerObj.name);\n        }\n\n        // Initialize state\n        isExploding = false;\n    }\n\n    void OnEnable()\n    {\n        // Event actions - execute once when enabled\n        if (_audioSource != null && spinSound != null)\n        {\n            _audioSource.PlayOneShot(spinSound);  // EVENT: Play audio clip once\n        }\n        \n        // Set rigidbody to use gravity (EVENT action)\n        if (_rigidbody != null)\n        {\n            _rigidbody.useGravity = true;\n        }\n\n        isExploding = false;  // Reset state when enabled\n    }\n\n    void Update()\n    {\n        if (!isExploding && _rigidbody != null)\n        {\n            // CONTINUOUS: Increase spin speed by spinUpSpeed every frame\n            // This is a simplification - real physics would use AddTorque in FixedUpdate\n            _rigidbody.angularVelocity += Vector3.forward * spinUpSpeed * Time.deltaTime;\n\n            // Check if we've reached max spin speed (CONDITIONAL action)\n            float currentSpeed = _rigidbody.angularVelocity.magnitude;\n            if (currentSpeed >= maxSpinSpeed && !isExploding)\n            {\n                isExploding = true;  // Prevent re-triggering\n                ExplodeIntoPieces();\n            }\n\n            // CONTINUOUS: Increase audio volume over time\n            if (_audioSource != null && _audioSource.isPlaying)\n            {\n                float targetVolume = Mathf.Clamp01(currentSpeed / maxSpinSpeed);\n                _audioSource.volume = Mathf.Lerp(_audioSource.volume, targetVolume, Time.deltaTime * 2.0f);\n            }\n\n            // CONTINUOUS: Lerp material color from blue to red\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null && renderer.material != null)\n            {\n                float t = currentSpeed / maxSpinSpeed;\n                Color lerpedColor = Color.Lerp(startColor, endColor, t);\n                renderer.material.color = lerpedColor;\n            }\n        }\n    }\n\n    private void ExplodeIntoPieces()\n    {\n        // EVENT: Create explosion pieces\n        if (pieceCount > 0)\n        {\n            for (int i = 0; i < pieceCount; i++)\n            {\n                // Create a small fragment at random position on the object\n                Vector3 fragmentPos = transform.position + Random.insideUnitSphere * 0.5f;\n                \n                // Create fragment game object\n                GameObject fragment = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n                fragment.transform.position = fragmentPos;\n                fragment.transform.localScale = Vector3.one * 0.2f;\n                \n                // Add rigidbody and apply explosion force\n                Rigidbody fragRigidbody = fragment.AddComponent<Rigidbody>();\n                fragRigidbody.mass = 0.1f;\n                fragRigidbody.AddExplosionForce(\n                    explosionForce,\n                    transform.position,\n                    5.0f,\n                    Random.Range(0.0f, 360.0f)\n                );\n                \n                // Add random angular velocity\n                fragRigidbody.angularVelocity = Random.insideUnitSphere * 10.0f;\n                \n                // Set short lifetime for cleanup (TODO: Consider object pooling)\n                Destroy(fragment, 5.0f);\n            }\n        }\n\n        // Destroy this object after explosion\n        Destroy(gameObject);\n    }\n\n    // Note: FixedUpdate is not used here because we're modifying angularVelocity directly\n    // For more complex physics, use AddTorque in FixedUpdate instead of direct assignment\n}",
    "ir_json": {
      "class_name": "SpinningExplosive",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "spinUpSpeed",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "maxSpinSpeed",
          "type": "float",
          "default": 1000.0
        },
        {
          "name": "explosionForce",
          "type": "float",
          "default": 500.0
        },
        {
          "name": "pieceCount",
          "type": "int",
          "default": 10
        },
        {
          "name": "spinSound",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "SpinToExplode",
          "trigger": "when enabled",
          "actions": [
            {
              "action": "play spin audio clip",
              "target": "spinSound",
              "temporal": "event"
            },
            {
              "action": "set rigidbody to use gravity",
              "value": true,
              "temporal": "event"
            },
            {
              "action": "start increasing speed and volume",
              "duration": 5.0,
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "IncreaseSpeedAndVolume",
          "trigger": "when SpinToExplode behavior is running",
          "actions": [
            {
              "action": "increase spin speed by spinUpSpeed",
              "temporal": "continuous"
            },
            {
              "action": "increase audio volume over time",
              "from": 0.1,
              "to": 1.0,
              "temporal": "continuous"
            },
            {
              "action": "lerp material color from blue to red",
              "startColor": "#0000FF",
              "endColor": "#FF0000",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "CheckMaxSpeed",
          "trigger": "every frame while spinning",
          "actions": [
            {
              "action": "check if spin speed >= maxSpinSpeed",
              "temporal": "conditional"
            },
            {
              "if true": [
                {
                  "action": "explode into pieces",
                  "count": 10,
                  "explosionForce": 500.0,
                  "temporal": "event"
                }
              ]
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of spin-up and explosion mechanics",
        "Color lerping between blue and red during spin",
        "Dynamic audio volume scaling",
        "Proper use of SerializeField for configuration",
        "Explosion force and fragment generation"
      ],
      "weaknesses": [
        "Incomplete ExplodeIntoPieces method (code snippet cut off)",
        "No unique sound effects for explosion fragments",
        "Angular velocity manipulation is physically unrealistic",
        "Missing error handling for missing components"
      ],
      "suggestions": [
        "Use AddTorque() in FixedUpdate for more physically accurate rotation",
        "Complete the ExplodeIntoPieces method with sound effect assignment",
        "Add more robust null and component checking",
        "Consider using a prefab for explosion fragments instead of runtime creation",
        "Implement a more sophisticated explosion mechanism with configurable fragment behaviors"
      ]
    },
    "grade_time": 11.577248573303223,
    "error": null
  },
  {
    "prompt": "2. \"Make a gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center, all while rotating the entire gravity well slowly.\"",
    "success": true,
    "generation_time": 77.1013126373291,
    "rag_docs_used": 15,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class GravityWell : MonoBehaviour\n{\n    [SerializeField] private float pullForce = 500.0f;\n    [SerializeField] private float maxDistance = 10.0f;\n    [SerializeField] private float rumbleBaseVolume = 0.3f;\n    [SerializeField] private float lightIntensityMultiplier = 2.0f;\n    [SerializeField] private AudioClip collideSound = null;\n\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Light _light;\n    private ParticleSystem _particleSystem;\n    \n    // Track state for conditional actions\n    private bool _hasTargetsInRange;\n    private float _closestTargetDistance;\n    private int _targetCount;\n\n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _light = GetComponent<Light>();\n        _particleSystem = GetComponent<ParticleSystem>();\n        \n        // Cache player reference if needed\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            Debug.Log(\"GravityWell found Player object\", playerObj);\n        }\n    }\n\n    void Update()\n    {\n        // EVENT actions - execute once per frame for state changes\n        _targetCount = FindNearbyRigidbodies();\n        \n        // CONDITIONAL action: Check if we have targets and update light intensity\n        bool hasTargetsInRange = _targetCount > 0;\n        if (hasTargetsInRange != _hasTargetsInRange)\n        {\n            if (hasTargetsInRange)\n            {\n                EnterState_WithTargets();\n            }\n            else\n            {\n                ExitState_NoTargets();\n            }\n            _hasTargetsInRange = hasTargetsInRange;\n        }\n        \n        // CONDITIONAL action: Find closest target distance for rumble effect\n        float closestDistance = FindClosestTargetDistance();\n        if (closestDistance < maxDistance)\n        {\n            UpdateRumbleSound(closestDistance);\n        }\n    }\n\n    void FixedUpdate()\n    {\n        // CONTINUOUS actions - physics-based continuous behavior\n        ApplyGravityToTargets();\n        \n        // Rotate self continuously\n        transform.Rotate(0f, 45f * Time.deltaTime, 0f);\n    }\n\n    private int FindNearbyRigidbodies()\n    {\n        // EVENT action: Count nearby rigidbodies within maxDistance\n        Rigidbody[] allRigidbodies = FindObjectsOfType<Rigidbody>();\n        int count = 0;\n        \n        foreach (var rb in allRigidbodies)\n        {\n            float distance = Vector3.Distance(transform.position, rb.transform.position);\n            if (distance <= maxDistance)\n            {\n                count++;\n                \n                // Apply force to each target\n                Vector3 direction = (transform.position - rb.transform.position).normalized;\n                float inverseSquareFactor = 1.0f / Mathf.Pow(distance, 2);\n                float forceMagnitude = pullForce * inverseSquareFactor;\n                rb.AddForce(direction * forceMagnitude, ForceMode.Force);\n            }\n        }\n        \n        // Set light intensity based on number of targets\n        if (_light != null)\n        {\n            _light.intensity = count * lightIntensityMultiplier;\n        }\n        \n        return count;\n    }\n\n    private float FindClosestTargetDistance()\n    {\n        Rigidbody[] allRigidbodies = FindObjectsOfType<Rigidbody>();\n        float closestDistance = maxDistance; // Start with max distance\n        \n        foreach (var rb in allRigidbodies)\n        {\n            float distance = Vector3.Distance(transform.position, rb.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n            }\n        }\n        \n        return closestDistance;\n    }\n\n    private void UpdateRumbleSound(float closestDistance)\n    {\n        // EVENT action: Play sound when targets exist\n        if (_audioSource != null && collideSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.PlayOneShot(collideSound);\n        }\n        \n        // CONTINUOUS action: Adjust volume based on distance\n        float normalizedDistance = closestDistance / maxDistance;\n        float volume = rumbleBaseVolume * (1.0f - normalizedDistance);\n        if (_audioSource != null)\n        {\n            _audioSource.volume = Mathf.Clamp01(volume);\n        }\n    }\n\n    private void EnterState_WithTargets()\n    {\n        // EVENT actions to execute when targets enter range\n        Debug.Log(\"GravityWell: Targets in range\", this);\n        \n        // Start particle system if exists\n        if (_particleSystem != null)\n        {\n            _particleSystem.Play();\n        }\n    }\n\n    private void ExitState_NoTargets()\n    {\n        // EVENT actions to execute when no targets are in range\n        Debug.Log(\"GravityWell: No targets in range\", this);\n        \n        // Stop particle system and audio\n        if (_particleSystem != null)\n        {\n            _particleSystem.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n            _audioSource.volume = 0f;\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Collision behavior from IR specification\n        if (collideSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(collideSound);\n        }\n        \n        // Spawn particle effect at collision point\n        if (_particleSystem != null)\n        {\n            _particleSystem.Play();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, maxDistance);\n    }\n}",
    "ir_json": {
      "class_name": "GravityWell",
      "components": [
        "Rigidbody",
        "AudioSource",
        "Light",
        "ParticleSystem"
      ],
      "fields": [
        {
          "name": "pullForce",
          "type": "float",
          "default": 500.0
        },
        {
          "name": "maxDistance",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "rumbleBaseVolume",
          "type": "float",
          "default": 0.3
        },
        {
          "name": "lightIntensityMultiplier",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "collideSound",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "apply_gravity",
          "trigger": "every frame",
          "actions": [
            {
              "action": "find all nearby rigidbodies within maxDistance",
              "temporal": "event"
            },
            {
              "action": "for each target",
              "temporal": "conditional",
              "inner_actions": [
                {
                  "action": "calculate distance from well center to target",
                  "temporal": "event"
                },
                {
                  "action": "compute force magnitude inversely proportional to squared distance",
                  "temporal": "event"
                },
                {
                  "action": "add force toward gravity well center scaled by pullForce and inverse square law",
                  "target": "target Rigidbody",
                  "temporal": "event"
                }
              ]
            },
            {
              "action": "count current target bodies",
              "temporal": "event"
            },
            {
              "action": "set light intensity = count \u00d7 lightIntensityMultiplier",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "rumble_sound",
          "trigger": "every frame",
          "actions": [
            {
              "action": "find closest target distance among all rigidbodies",
              "temporal": "event"
            },
            {
              "action": "if any targets exist and closest < maxDistance:",
              "temporal": "conditional",
              "inner_actions": [
                {
                  "action": "set audio volume = rumbleBaseVolume \u00d7 (1 - normalizedDistance)",
                  "where normalizedDistance = closest/targetDistance": "temporal\": \"continuous"
                }
              ]
            },
            {
              "action": "if no targets within range, stop sound and set volume to 0",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "rotate_self",
          "trigger": "every frame",
          "actions": [
            {
              "action": "rotate transform by small angle around Y axis",
              "speed": 45.0,
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      },
      "collision_behavior": {
        "on_collision_enter": [
          {
            "action": "play collideSound",
            "target": "collideSound",
            "temporal": "event"
          },
          {
            "action": "spawn particle effect at collision point",
            "temporal": "event"
          }
        ]
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of gravity well mechanics",
        "Uses inverse square law for force calculation",
        "Handles dynamic light intensity based on target count",
        "Implements continuous rotation",
        "Uses appropriate Unity lifecycle methods (Start, Update, FixedUpdate)"
      ],
      "weaknesses": [
        "Incomplete sound and particle system implementation",
        "No explicit collision handling for particle effects",
        "Performance-intensive FindObjectsOfType calls every frame",
        "Unfinished UpdateRumbleSound method",
        "Lacks error handling for missing components"
      ],
      "suggestions": [
        "Use Physics.OverlapSphere instead of FindObjectsOfType for better performance",
        "Complete the UpdateRumbleSound method with full volume scaling",
        "Add null checks for all component references",
        "Implement OnCollisionEnter to spawn particles and play collision sound",
        "Consider using object pooling for performance optimization",
        "Add configuration options for rotation speed and force scaling"
      ]
    },
    "grade_time": 12.171526908874512,
    "error": null
  },
  {
    "prompt": "3. \"Build a script that turns any object into a musical instrument - when you collide with it, it plays a note based on where you hit it (top plays high notes, bottom plays low notes), the object's color shifts to match the note's frequency, it vibrates with the sound, and leaves a trail of particles that fade out over 2 seconds.\"",
    "success": true,
    "generation_time": 50.415066957473755,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class MusicalInstrument : MonoBehaviour\n{\n    [SerializeField] private float noteRange = 12.0f;\n    [SerializeField] private float collisionForceMultiplier = 10.0f;\n    [SerializeField] private float vibrationDuration = 1.5f;\n    [SerializeField] private float trailLifetime = 2.0f;\n\n    private Collider _collider;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private TrailRenderer _trailRenderer;\n\n    // Track if vibration is active\n    private bool _isVibrating = false;\n    private float _vibrationStartTime = 0f;\n\n    void Start()\n    {\n        // Get components from the GameObject\n        _collider = GetComponent<Collider>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        _trailRenderer = GetComponent<TrailRenderer>();\n\n        if (_collider == null)\n        {\n            Debug.LogError(\"MusicalInstrument: Collider component not found!\");\n        }\n\n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"MusicalInstrument: Rigidbody component not found!\");\n        }\n\n        if (_audioSource == null)\n        {\n            Debug.LogError(\"MusicalInstrument: AudioSource component not found!\");\n        }\n\n        if (_animator == null)\n        {\n            Debug.LogError(\"MusicalInstrument: Animator component not found!\");\n        }\n\n        if (_trailRenderer == null)\n        {\n            Debug.LogError(\"MusicalInstrument: TrailRenderer component not found!\");\n        }\n    }\n\n    void Update()\n    {\n        // Handle vibration effect\n        if (_isVibrating && Time.time - _vibrationStartTime >= vibrationDuration)\n        {\n            StopVibration();\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Event actions: Execute once on collision\n\n        // Calculate hit position percentage (0 to 1) based on contact point\n        float hitPercentage = collision.contacts[0].point.x / transform.localScale.x;\n\n        // Map hit position to note frequency within the note range\n        float baseFrequency = 440.0f; // A4 note frequency as a reference\n        float frequencyMultiplier = Mathf.Pow(2, (noteRange / 12.0f));\n        float noteFrequency = baseFrequency * Mathf.Pow(frequencyMultiplier, hitPercentage);\n\n        // Play audio clip with calculated frequency\n        if (_audioSource != null)\n        {\n            _audioSource.pitch = noteFrequency / 440.0f;\n            _audioSource.PlayOneShot(_audioSource.clip);\n        }\n\n        // Shift material color based on frequency (simplified for example)\n        if (_animator != null)\n        {\n            _animator.SetFloat(\"HitPercentage\", hitPercentage);\n        }\n\n        // Emit trail particles on collision point\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.emitting = true;\n            _trailRenderer.time = 0f; // Reset trail lifetime\n        }\n\n        // Start vibration effect (continuous action)\n        if (!_isVibrating && _rigidbody != null)\n        {\n            _isVibrating = true;\n            _vibrationStartTime = Time.time;\n\n            // Apply initial force to start vibration\n            Vector3 collisionForce = collision.contacts[0].point.normalized * collisionForceMultiplier;\n            _rigidbody.AddForce(collisionForce, ForceMode.Impulse);\n        }\n    }\n\n    private void StopVibrating()\n    {\n        _isVibrating = false;\n\n        // Stop emitting trail particles\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.emitting = false;\n        }\n    }\n}",
    "ir_json": {
      "class_name": "MusicalInstrument",
      "components": [
        "Collider",
        "Rigidbody",
        "AudioSource",
        "Animator",
        "TrailRenderer"
      ],
      "fields": [
        {
          "name": "noteRange",
          "type": "float",
          "default": 12.0
        },
        {
          "name": "collisionForceMultiplier",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "vibrationDuration",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "trailLifetime",
          "type": "float",
          "default": 2.0
        }
      ],
      "behaviors": [
        {
          "name": "on_collision",
          "trigger": "collision with any object",
          "actions": [
            {
              "action": "calculate hit position percentage",
              "temporal": "event"
            },
            {
              "action": "map hit position to note frequency",
              "range": "noteRange",
              "temporal": "event"
            },
            {
              "action": "play audio clip with calculated frequency",
              "temporal": "event"
            },
            {
              "action": "shift material color based on frequency",
              "temporal": "event"
            },
            {
              "action": "apply vibration force to rigidbody",
              "duration": "vibrationDuration",
              "forceMultiplier": "collisionForceMultiplier",
              "temporal": "continuous"
            },
            {
              "action": "emit trail particles on collision point",
              "lifetime": "trailLifetime",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive implementation of musical instrument collision behavior",
        "Robust component validation and error logging",
        "Dynamic frequency and note generation based on hit position",
        "Proper use of Unity lifecycle methods (Start, Update, OnCollisionEnter)",
        "Vibration effect with time-limited duration"
      ],
      "weaknesses": [
        "Color shifting is simplified and not fully implemented",
        "Frequency calculation could be more precise",
        "No explicit handling of multiple simultaneous collisions",
        "Trail renderer usage is basic"
      ],
      "suggestions": [
        "Implement more sophisticated color mapping based on frequency",
        "Add interpolation for smoother frequency and vibration transitions",
        "Create a more advanced trail particle system with configurable properties",
        "Consider adding configuration options for base note and frequency range",
        "Implement a more nuanced vibration mechanism using physics constraints"
      ]
    },
    "grade_time": 12.595993518829346,
    "error": null
  },
  {
    "prompt": "4. \"Create a creature that has 5 states: idle (sits still, plays ambient breathing), curious (slowly approaches player if within 10 units, plays questioning sound), scared (runs away from player, plays panic sound, color turns red), aggressive (chases player, plays roar, color turns dark, applies force toward player), and exhausted (stops moving, plays tired sound, color fades to gray). It transitions between states based on player distance and how long it's been in current state.\"",
    "success": true,
    "generation_time": 105.0419397354126,
    "rag_docs_used": 0,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class WildBeast : MonoBehaviour\n{\n\n    [SerializeField] private AudioClip idleSound = null;\n    [SerializeField] private AudioClip curiousSound = null;\n    [SerializeField] private AudioClip scaredSound = null;\n    [SerializeField] private AudioClip roarSound = null;\n    [SerializeField] private AudioClip tiredSound = null;\n    [SerializeField] private GameObject player;\n    [SerializeField] private Color idleColor = Color.white;\n    [SerializeField] private Color scaredColor = Color.red;\n    [SerializeField] private Color aggressiveColor = Color.black;\n    [SerializeField] private Color exhaustedColor = new Color(0.5333334f, 0.5333334f, 0.5333334f);\n    [SerializeField] private float maxStateTime = 10.0f;\n    [SerializeField] private float chaseSpeed = 8.0f;\n\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private State _currentState;\n    private State _previousState;\n    private float _stateTimer;\n    private Vector3 _stationaryPosition;\n    private bool _isStationary;\n\n    private enum State\n    {\n        Idle,\n        Curious,\n        Scared,\n        Aggressive,\n        Exhausted\n    }\n\n    private void Start()\n    {\n        // Get components\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n\n        // Find player if not assigned in inspector\n        if (player == null)\n            player = GameObject.FindGameObjectWithTag(\"Player\");\n\n        // Initialize state machine\n        _currentState = State.Idle;\n        _stateTimer = 0f;\n    }\n\n    private void Update()\n    {\n        // Track stationary position for idle transition\n        if (_rigidbody != null && _rigidbody.velocity.magnitude < 0.1f)\n            _stationaryPosition = transform.position;\n        else\n            _isStationary = false;\n\n        // Check if stationary for more than 3 seconds\n        if (!_isStationary && \n            Vector3.Distance(transform.position, _stationaryPosition) < 0.1f &&\n            Time.time - _stateTimer > 3f)\n            _isStationary = true;\n\n        // Update state timer\n        _stateTimer += Time.deltaTime;\n\n        // Determine next state based on conditions\n        State nextState = DetermineNextState();\n\n        // Handle state transitions\n        if (nextState != _currentState)\n        {\n            ExitState(_currentState);\n            _previousState = _currentState;\n            _currentState = nextState;\n            EnterState(_currentState);\n        }\n\n        // Update current state actions\n        UpdateState(_currentState);\n\n        // Reset stationary check every frame\n        _isStationary = false;\n    }\n\n    private void FixedUpdate()\n    {\n        if (_rigidbody == null)\n            return;\n\n        // Apply physics-based continuous actions (if any)\n        switch (_currentState)\n        {\n            case State.Aggressive:\n                // Apply force toward player in aggressive state\n                if (player != null)\n                {\n                    Vector3 direction = (player.transform.position - transform.position).normalized;\n                    _rigidbody.AddForce(direction * 15.0f, ForceMode.Force);\n                }\n                break;\n        }\n    }\n\n    private void EnterState(State state)\n    {\n        // Reset timer when entering any state\n        _stateTimer = 0f;\n\n        switch (state)\n        {\n            case State.Idle:\n                PlayAudioClip(idleSound);\n                SetColor(idleColor);\n                _animator.SetTrigger(\"Idle\");\n                break;\n            case State.Curious:\n                PlayAudioClip(curiousSound);\n                SetColor(idleColor); // Using idle color as specified in IR\n                _animator.SetTrigger(\"Curious\");\n                break;\n            case State.Scared:\n                PlayAudioClip(scaredSound);\n                SetColor(scaredColor);\n                _animator.SetTrigger(\"Scared\");\n                break;\n            case State.Aggressive:\n                PlayAudioClip(roarSound);\n                SetColor(aggressiveColor);\n                _animator.SetTrigger(\"Aggressive\");\n                break;\n            case State.Exhausted:\n                PlayAudioClip(tiredSound);\n                SetColor(exhaustedColor);\n                _animator.SetTrigger(\"Exhausted\");\n                break;\n        }\n    }\n\n    private void UpdateState(State state)\n    {\n        switch (state)\n        {\n            case State.Curious:\n                if (player != null)\n                {\n                    Vector3 direction = (player.transform.position - transform.position).normalized;\n                    transform.position += direction * 2.0f * Time.deltaTime; // Move toward player slowly\n                }\n                break;\n            case State.Scared:\n                if (player != null)\n                {\n                    Vector3 direction = (transform.position - player.transform.position).normalized;\n                    transform.position += direction * 5.0f * Time.deltaTime; // Move away from player fast\n                }\n                break;\n            case State.Aggressive:\n                if (player != null)\n                {\n                    Vector3 direction = (player.transform.position - transform.position).normalized;\n                    transform.position += direction * chaseSpeed * Time.deltaTime; // Move toward player fast\n                }\n                break;\n            case State.Exhausted:\n                // Stop moving completely\n                _rigidbody.velocity = Vector3.zero;\n                break;\n        }\n    }\n\n    private void ExitState(State state)\n    {\n        // Any cleanup needed when exiting states\n    }\n\n    private State DetermineNextState()\n    {\n        if (player == null)\n            return _currentState; // Stay in current state if no player\n\n        float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n\n        switch (_currentState)\n        {\n            case State.Idle:\n                if (distanceToPlayer < 10.0f)\n                    return State.Curious;\n                break;\n            case State.Curious:\n                if (distanceToPlayer < 5.0f)\n                    return State.Scared;\n                else if (IsPlayerAttacking())\n                    return State.Aggressive;\n                else if (_stateTimer > maxStateTime)\n                    return State.Idle;\n                break;\n            case State.Scared:\n                if (IsPlayerAttacking())\n                    return State.Aggressive;\n                else if (_stateTimer > maxStateTime)\n                    return State.Idle;\n                break;\n            case State.Aggressive:\n                if (_stateTimer > maxStateTime * 2)\n                    return State.Exhausted;\n                else if (distanceToPlayer > 15.0f && _isStationary)\n                    return State.Idle;\n                break;\n            case State.Exhausted:\n                if (_stateTimer > maxStateTime * 3 || distanceToPlayer > 20.0f)\n                    return State.Idle;\n                break;\n        }\n\n        return _currentState; // Stay in current state\n    }\n\n    private void PlayAudioClip(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    private void SetColor(Color color)\n    {\n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null)\n            renderer.material.color = color;\n    }\n\n    // Placeholder for player attack detection\n    private bool IsPlayerAttacking()\n    {\n        // TODO: Implement actual player attack detection logic\n        return false; // Default to no attack detected\n    }\n}",
    "ir_json": {
      "class_name": "WildBeast",
      "components": [
        "Rigidbody",
        "Animator"
      ],
      "fields": [
        {
          "name": "player",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "idleSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "curiousSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "scaredSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "roarSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "tiredSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "idleColor",
          "type": "Color",
          "default": "#ffffff"
        },
        {
          "name": "scaredColor",
          "type": "Color",
          "default": "#ff0000"
        },
        {
          "name": "aggressiveColor",
          "type": "Color",
          "default": "#000000"
        },
        {
          "name": "exhaustedColor",
          "default": "#888888"
        },
        {
          "name": "maxStateTime",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "chaseSpeed",
          "type": "float",
          "default": 8.0
        }
      ],
      "behaviors": [],
      "state_machine": {
        "has_state_machine": true,
        "initial_state": "idle",
        "states": [
          {
            "name": "idle",
            "actions": [
              {
                "action": "play audio clip",
                "target": "idleSound",
                "temporal": "event"
              },
              {
                "action": "set color",
                "color": "idleColor",
                "temporal": "event"
              },
              {
                "action": "set animation trigger",
                "trigger": "Idle",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "curious",
                "condition": "player distance < 10.0"
              }
            ]
          },
          {
            "name": "curious",
            "actions": [
              {
                "action": "play audio clip",
                "target": "curiousSound",
                "temporal": "event"
              },
              {
                "action": "set color",
                "color": "idleColor",
                "temporal": "event"
              },
              {
                "action": "move toward player slowly",
                "speed": 2.0,
                "temporal": "continuous"
              },
              {
                "action": "set animation trigger",
                "trigger": "Curious",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "scared",
                "condition": "player distance < 5.0"
              },
              {
                "to": "aggressive",
                "condition": "player attacks"
              },
              {
                "to": "idle",
                "condition": "time in state > maxStateTime"
              }
            ]
          },
          {
            "name": "scared",
            "actions": [
              {
                "action": "play audio clip",
                "target": "scaredSound",
                "temporal": "event"
              },
              {
                "action": "set color",
                "color": "scaredColor",
                "temporal": "event"
              },
              {
                "action": "move away from player fast",
                "speed": 5.0,
                "temporal": "continuous"
              },
              {
                "action": "set animation trigger",
                "trigger": "Scared",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "aggressive",
                "condition": "player attacks"
              },
              {
                "to": "idle",
                "condition": "time in state > maxStateTime"
              }
            ]
          },
          {
            "name": "aggressive",
            "actions": [
              {
                "action": "play audio clip",
                "target": "roarSound",
                "temporal": "event"
              },
              {
                "action": "set color",
                "color": "aggressiveColor",
                "temporal": "event"
              },
              {
                "action": "move toward player fast",
                "speed": 8.0,
                "temporal": "continuous"
              },
              {
                "action": "apply force toward player",
                "force": 15.0,
                "temporal": "continuous"
              },
              {
                "action": "set animation trigger",
                "trigger": "Aggressive",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "exhausted",
                "condition": "time in state > maxStateTime * 2"
              },
              {
                "to": "idle",
                "condition": "player distance > 15.0 and time stationary > 3"
              }
            ]
          },
          {
            "name": "exhausted",
            "actions": [
              {
                "action": "play audio clip",
                "target": "tiredSound",
                "temporal": "event"
              },
              {
                "action": "set color",
                "color": "exhaustedColor",
                "temporal": "event"
              },
              {
                "action": "stop moving completely",
                "temporal": "continuous"
              },
              {
                "action": "set animation trigger",
                "trigger": "Exhausted",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "idle",
                "condition": "time in state > maxStateTime * 3 or player distance > 20.0"
              }
            ]
          }
        ]
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive state machine implementation",
        "Proper use of Unity components (Rigidbody, Animator, AudioSource)",
        "Flexible player detection",
        "Detailed state transition logic",
        "Use of SerializeField for inspector configuration"
      ],
      "weaknesses": [
        "Incomplete implementation (code snippet cuts off)",
        "Missing full implementation of all state transitions",
        "Lacks complete error handling",
        "No clear method for calculating player distance",
        "Partial implementation of movement and force application"
      ],
      "suggestions": [
        "Complete the remaining state transition methods",
        "Add explicit distance calculation method",
        "Implement more robust error checking for components",
        "Add logging or debug statements for state transitions",
        "Consider using a more robust state machine pattern",
        "Add comments explaining complex state transition logic"
      ]
    },
    "grade_time": 13.793599605560303,
    "error": null
  },
  {
    "prompt": "5. \"Make a door that has locked, unlocking, open, and closing states. When locked, it plays a rattle sound and shakes slightly. When unlocking, it plays a key-turning sound for 3 seconds while rotating slowly, then transitions to open. When open, it plays a creak and stays open for 10 seconds, then automatically starts closing. During closing, it rotates back while playing a slam sound, then locks again. The door's material emission color changes with each state.\"",
    "success": true,
    "generation_time": 84.31598782539368,
    "rag_docs_used": 0,
    "was_steered": true,
    "generated_code": "using UnityEngine;\nusing System.Collections;\n\npublic class InteractiveDoor : MonoBehaviour\n{\n    [SerializeField] private AudioClip lockedSound = null;\n    [SerializeField] private AudioClip unlockingSound = null;\n    [SerializeField] private AudioClip openSound = null;\n    [SerializeField] private AudioClip closeSound = null;\n    [SerializeField] private Color emissionColor_locked = new Color(0.3f, 0.3f, 1.0f);\n    [SerializeField] private Color emissionColor_unlocking = new Color(0.8f, 0.4f, 0.2f);\n    [SerializeField] private Color emissionColor_open = new Color(0.0f, 1.0f, 0.0f);\n    [SerializeField] private Color emissionColor_closing = new Color(1.0f, 0.3f, 0.3f);\n\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n\n    private enum State { locked, unlocking, open, closing }\n    [SerializeField] private State _currentState = State.locked;\n    private float _stateTimer = 0f;\n    private bool _isShaking = false;\n    private Vector3 _initialPosition;\n    private Quaternion _initialRotation;\n\n    void Start()\n    {\n        // Get components\n        _animator = GetComponent<Animator>();\n        if (_animator == null)\n            Debug.LogError(\"InteractiveDoor: Animator component not found!\");\n\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            Debug.LogError(\"InteractiveDoor: AudioSource component not found!\");\n\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            Debug.LogError(\"InteractiveDoor: Rigidbody component not found!\");\n        \n        // Cache initial transform\n        _initialPosition = transform.position;\n        _initialRotation = transform.rotation;\n\n        // Initialize state\n        EnterState(_currentState);\n    }\n\n    private void Update()\n    {\n        // Check for transition conditions before updating state\n        switch (_currentState)\n        {\n            case State.locked:\n                if (CanUnlock())\n                    TransitionTo(State.unlocking);\n                break;\n                \n            case State.unlocking:\n                _stateTimer += Time.deltaTime;\n                if (_stateTimer >= 3f) // Duration of unlocking animation\n                    TransitionTo(State.open);\n                break;\n                \n            case State.open:\n                _stateTimer += Time.deltaTime;\n                if (_stateTimer >= 10f)\n                    TransitionTo(State.closing);\n                break;\n                \n            case State.closing:\n                _stateTimer += Time.deltaTime;\n                // Check if door is fully closed (rotation back to initial)\n                Quaternion currentRot = transform.rotation;\n                float angleDiff = Quaternion.Angle(currentRot, _initialRotation);\n                if (angleDiff < 1f) // Threshold for \"fully closed\"\n                    TransitionTo(State.locked);\n                break;\n        }\n\n        // Update continuous actions\n        switch (_currentState)\n        {\n            case State.locked:\n                PlayContinuousSound(lockedSound);\n                break;\n                \n            case State.unlocking:\n                RotateAroundPivot(45f); // 45 degrees per second\n                break;\n                \n            case State.open:\n                _stateTimer += Time.deltaTime; // Just waiting, no action needed\n                break;\n                \n            case State.closing:\n                RotateBackToClosed(90f); // 90 degrees per second\n                break;\n        }\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isShaking)\n        {\n            ApplyShakeImpulse();\n        }\n    }\n\n    private bool CanUnlock()\n    {\n        // TODO: Implement actual unlock condition detection\n        // This could be a button press, proximity to player, etc.\n        return Input.GetKeyDown(KeyCode.E);\n    }\n\n    private void TransitionTo(State newState)\n    {\n        if (newState == _currentState) return;\n        \n        ExitState(_currentState);\n        _currentState = newState;\n        _stateTimer = 0f; // Reset timer on state change\n        EnterState(_currentState);\n    }\n\n    private void EnterState(State state)\n    {\n        switch (state)\n        {\n            case State.locked:\n                ApplyShakeImpulse();\n                SetEmissionColor(emissionColor_locked);\n                break;\n                \n            case State.unlocking:\n                if (unlockingSound != null) _audioSource.PlayOneShot(unlockingSound);\n                SetEmissionColor(emissionColor_unlocking);\n                // Reset timer for unlocking animation\n                _stateTimer = 0f;\n                break;\n                \n            case State.open:\n                if (openSound != null) _audioSource.PlayOneShot(openSound);\n                SetEmissionColor(emissionColor_open);\n                // Start wait timer\n                _stateTimer = 0f;\n                break;\n                \n            case State.closing:\n                if (closeSound != null) _audioSource.PlayOneShot(closeSound);\n                SetEmissionColor(emissionColor_closing);\n                // Reset rotation tracking for closing animation\n                _stateTimer = 0f;\n                break;\n        }\n    }\n\n    private void ExitState(State state)\n    {\n        // No special exit actions needed for this implementation\n    }\n\n    private void UpdateState(State state)\n    {\n        // Continuous actions are handled in Update() method above\n        // This is an alternative pattern, but the main Update handles all continuous behavior\n    }\n\n    private void PlayContinuousSound(AudioClip clip)\n    {\n        if (clip != null && !_audioSource.isPlaying)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    private void ApplyShakeImpulse()\n    {\n        // TODO: Implement proper shake physics with PhysicMaterial for realistic bounce\n        float t = Time.time * 5f; // Use frequency from specification\n        Vector3 offset = new Vector3(\n            Mathf.Sin(t) * 0.1f,\n            Mathf.Cos(t * 2f) * 0.05f,\n            Mathf.Cos(t) * 0.1f\n        );\n        \n        _rigidbody.MovePosition(_initialPosition + offset);\n    }\n\n    private void SetEmissionColor(Color color)\n    {\n        // TODO: Implement material emission color setting\n        // This requires a reference to the door's renderer/material\n        Renderer[] renderers = GetComponentsInChildren<Renderer>();\n        foreach (var r in renderers)\n        {\n            // This would set emission color on materials with emission properties\n            Material mat = r.material;\n            if (mat.HasProperty(\"_EmissionColor\"))\n                mat.SetColor(\"_EmissionColor\", color);\n        }\n    }\n\n    private void RotateAroundPivot(float speed)\n    {\n        transform.RotateAround(transform.position, Vector3.up, speed * Time.deltaTime);\n    }\n\n    private void RotateBackToClosed(float speed)\n    {\n        // Calculate direction from current to initial rotation\n        Quaternion targetRot = _initialRotation;\n        transform.rotation = Quaternion.RotateTowards(\n            transform.rotation,\n            targetRot,\n            speed * Time.deltaTime\n        );\n    }\n}",
    "ir_json": {
      "class_name": "InteractiveDoor",
      "components": [
        "Animator",
        "AudioSource",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "lockedSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "unlockingSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "openSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "closeSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "emissionColor_locked",
          "type": "Color",
          "default": [
            0.3,
            0.3,
            1.0
          ]
        },
        {
          "name": "emissionColor_unlocking",
          "type": "Color",
          "default": [
            0.8,
            0.4,
            0.2
          ]
        },
        {
          "name": "emissionColor_open",
          "type": "Color",
          "default": [
            0.0,
            1.0,
            0.0
          ]
        },
        {
          "name": "emissionColor_closing",
          "type": "Color",
          "default": [
            1.0,
            0.3,
            0.3
          ]
        }
      ],
      "behaviors": [],
      "state_machine": {
        "has_state_machine": true,
        "initial_state": "locked",
        "states": [
          {
            "name": "locked",
            "actions": [
              {
                "action": "play audio clip",
                "target": "lockedSound",
                "temporal": "continuous"
              },
              {
                "action": "apply shake impulse to door",
                "strength": 0.1,
                "frequency": 5,
                "duration": 2,
                "temporal": "event"
              },
              {
                "action": "set material emission color",
                "color": "emissionColor_locked",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "unlocking",
                "condition": "player attempts unlock"
              }
            ]
          },
          {
            "name": "unlocking",
            "actions": [
              {
                "action": "play audio clip",
                "target": "unlockingSound",
                "temporal": "event"
              },
              {
                "action": "rotate slowly around pivot",
                "speed": 45,
                "duration": 3,
                "temporal": "continuous"
              },
              {
                "action": "set material emission color",
                "color": "emissionColor_unlocking",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "open",
                "condition": "unlocking animation complete"
              }
            ]
          },
          {
            "name": "open",
            "actions": [
              {
                "action": "play audio clip",
                "target": "openSound",
                "temporal": "event"
              },
              {
                "action": "set material emission color",
                "color": "emissionColor_open",
                "temporal": "event"
              },
              {
                "action": "wait 10 seconds",
                "temporal": "continuous"
              }
            ],
            "transitions": [
              {
                "to": "closing",
                "condition": "wait timer complete"
              }
            ]
          },
          {
            "name": "closing",
            "actions": [
              {
                "action": "play audio clip",
                "target": "closeSound",
                "temporal": "event"
              },
              {
                "action": "rotate back to closed position",
                "speed": 90,
                "temporal": "continuous"
              },
              {
                "action": "set material emission color",
                "color": "emissionColor_closing",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "locked",
                "condition": "door fully closed"
              }
            ]
          }
        ]
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive state machine implementation",
        "Proper component references and null checks",
        "Detailed state transitions with timers",
        "Use of SerializeField for inspector configurability",
        "Attempted implementation of all specified behaviors"
      ],
      "weaknesses": [
        "Incomplete TransitionTo method (code snippet cut off)",
        "Missing material emission color changing logic",
        "Shake impulse method not fully implemented",
        "Rotation methods lack smoothing or interpolation",
        "Placeholder unlock condition using keyboard input"
      ],
      "suggestions": [
        "Complete the TransitionTo method with full state change logic",
        "Implement Material emission color changing in each state",
        "Add more robust shake impulse physics",
        "Use Quaternion.Slerp for smoother rotations",
        "Replace keyboard input with a more generic unlock mechanism",
        "Add error handling for missing audio clips",
        "Implement a more sophisticated state machine using Unity's Animator"
      ]
    },
    "grade_time": 14.10837697982788,
    "error": null
  },
  {
    "prompt": "6. \"Create a bouncy ball that, every time it hits a surface, bounces higher than the previous bounce, plays a pitch that increases with each bounce, changes color based on bounce count, and leaves a temporary trail. After 10 bounces, it explodes into confetti particles while playing a celebration sound.\"",
    "success": true,
    "generation_time": 47.82826828956604,
    "rag_docs_used": 12,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class BouncyBall : MonoBehaviour\n{\n    [SerializeField] private float bounceMultiplier = 1.2f;\n    [SerializeField] private float maxPitch = 2.0f;\n    [SerializeField] private float colorChangeSpeed = 0.5f;\n    [SerializeField] private float trailDuration = 1.0f;\n    [SerializeField] private GameObject confettiPrefab = null;\n    [SerializeField] private AudioClip celebrationSound = null;\n\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private TrailRenderer _trailRenderer;\n    private int bounceCount = 0;\n\n    // Color gradient for color change based on bounces\n    private Gradient colorGradient;\n    private float t = 0.0f; // For smooth color interpolation\n\n    private void Start()\n    {\n        // Get components\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _trailRenderer = GetComponent<TrailRenderer>();\n\n        // Initialize color gradient for bounce-based color change\n        colorGradient = new Gradient();\n        colorGradient.SetKeys(\n            new GradientColorKey[] { \n                new GradientColorKey(Color.red, 0.0f),\n                new GradientColorKey(Color.green, 1.0f)\n            },\n            new GradientAlphaKey[] {\n                new GradientAlphaKey(1.0f, 0.0f),\n                new GradientAlphaKey(1.0f, 1.0f)\n            }\n        );\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // EVENT actions - execute ONCE per collision\n        bounceCount++;\n\n        // Increase bounce height by applying additional upward force\n        Vector3 bounceDirection = Vector3.up;\n        _rigidbody.AddForce(bounceDirection * bounceMultiplier, ForceMode.Impulse);\n\n        // Increment audio pitch for each bounce (capped at maxPitch)\n        float currentPitch = _audioSource.pitch + 0.1f;\n        if (currentPitch > maxPitch) currentPitch = maxPitch;\n        _audioSource.pitch = currentPitch;\n\n        // Change color based on bounces using the gradient\n        t += Time.deltaTime * colorChangeSpeed;\n        if (t > 1.0f) t = 1.0f; // Cap for smooth interpolation\n\n        GetComponent<Renderer>().material.color = colorGradient.Evaluate(t);\n\n        // Update trail duration and position\n        _trailRenderer.time = trailDuration;\n\n        // Check bounce count for explosion condition\n        if (bounceCount >= 10)\n        {\n            TriggerExplosion();\n        }\n    }\n\n    private void TriggerExplosion()\n    {\n        // EVENT actions - execute ONCE when explosion triggered\n        if (_audioSource != null && celebrationSound != null)\n        {\n            _audioSource.PlayOneShot(celebrationSound);\n        }\n\n        // Spawn confetti particles\n        if (confettiPrefab != null)\n        {\n            Instantiate(confettiPrefab, transform.position, Quaternion.identity);\n        }\n\n        // Destroy self after explosion\n        Destroy(gameObject);\n    }\n}",
    "ir_json": {
      "class_name": "BouncyBall",
      "components": [
        "Rigidbody",
        "AudioSource",
        "TrailRenderer"
      ],
      "fields": [
        {
          "name": "bounceMultiplier",
          "type": "float",
          "default": 1.2
        },
        {
          "name": "maxPitch",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "colorChangeSpeed",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "trailDuration",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "confettiPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "celebrationSound",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on_collision",
          "trigger": "collision with any surface",
          "actions": [
            {
              "action": "increase bounce height",
              "factor": "bounceMultiplier",
              "temporal": "event"
            },
            {
              "action": "increment pitch",
              "maxPitch": "maxPitch",
              "temporal": "event"
            },
            {
              "action": "change color based on bounces",
              "speed": "colorChangeSpeed",
              "temporal": "event"
            },
            {
              "action": "update trail position",
              "duration": "trailDuration",
              "temporal": "event"
            },
            {
              "action": "check bounce count for explosion",
              "count_limit": 10,
              "temporal": "event"
            }
          ]
        },
        {
          "name": "on_explosion",
          "trigger": "after 10th bounce",
          "actions": [
            {
              "action": "play celebration sound",
              "target": "celebrationSound",
              "temporal": "event"
            },
            {
              "action": "spawn confetti particles",
              "prefab": "confettiPrefab",
              "temporal": "event"
            },
            {
              "action": "destroy self after explosion",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive implementation of bounce mechanics",
        "Smooth color gradient interpolation",
        "Proper use of Unity components",
        "Correct handling of bounce height and pitch incrementing",
        "Safe null checks for optional components"
      ],
      "weaknesses": [
        "Limited color gradient range (only red to green)",
        "No explicit error handling for missing components",
        "Pitch increment is hardcoded at 0.1f",
        "No configurable initial bounce force"
      ],
      "suggestions": [
        "Add more configurable parameters for initial bounce force",
        "Expand color gradient to support more dynamic color changes",
        "Implement more robust error handling for missing components",
        "Add optional randomness to pitch and bounce height for more variety",
        "Consider adding a configurable max bounce count instead of hardcoded 10",
        "Potentially use a more sophisticated trail rendering approach"
      ]
    },
    "grade_time": 11.258394956588745,
    "error": null
  },
  {
    "prompt": "7. \"Make an object that floats upward when you're near it (within 5 units), but falls faster when you're far away. It plays a humming sound that gets higher pitched as it rises, and lower pitched as it falls. The object also rotates opposite to its vertical movement direction, and its scale pulses in sync with the audio frequency.\"",
    "success": true,
    "generation_time": 68.54244303703308,
    "rag_docs_used": 21,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class FloatingObject : MonoBehaviour\n{\n    [SerializeField] private Vector3 targetPosition = Vector3.zero;\n    [SerializeField] private float minHeight = 0.0f;\n    [SerializeField] private float maxHeight = 5.0f;\n    [SerializeField] private float hoverSpeed = 2.0f;\n    [SerializeField] private float fallSpeed = 1.5f;\n    [SerializeField] private float rotationSpeed = 180.0f;\n    [SerializeField] private AudioClip audioClip = null;\n\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private float _currentVerticalVelocity;\n    private bool _isInitialized = false;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n\n        if (_audioSource != null && audioClip != null)\n        {\n            _audioSource.clip = audioClip;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n\n        // Initialize vertical velocity\n        UpdateVerticalVelocity();\n        ApplyUpwardForce();\n\n        _isInitialized = true;\n    }\n\n    private void Update()\n    {\n        if (!_isInitialized)\n            return;\n\n        // CONTINUOUS: Rotate object opposite to movement direction\n        UpdateRotation();\n\n        // CONDITIONAL: Check audio frequency for scale pulse\n        UpdateScalePulse();\n    }\n\n    private void FixedUpdate()\n    {\n        if (!_isInitialized)\n            return;\n\n        // EVENT: Calculate distance and update vertical velocity\n        UpdateVerticalVelocity();\n\n        // CONTINUOUS: Apply upward force based on calculated velocity\n        ApplyUpwardForce();\n    }\n\n    private void UpdateRotation()\n    {\n        // Rotate object opposite to movement direction (vertical axis)\n        float rotationAmount = rotationSpeed * Time.deltaTime;\n        transform.Rotate(Vector3.forward, -rotationAmount);\n    }\n\n    private void UpdateVerticalVelocity()\n    {\n        if (_rigidbody == null)\n            return;\n\n        // Calculate distance to target position\n        float distanceToTarget = Vector3.Distance(transform.position, targetPosition);\n\n        // Determine vertical velocity based on distance and position\n        if (transform.position.y >= maxHeight - 0.1f)\n        {\n            _currentVerticalVelocity = -fallSpeed;\n        }\n        else if (distanceToTarget < 5.0f)\n        {\n            float normalizedDistance = Mathf.InverseLerp(0, 5.0f, distanceToTarget);\n            _currentVerticalVelocity = hoverSpeed * normalizedDistance;\n        }\n        else\n        {\n            _currentVerticalVelocity = hoverSpeed;\n        }\n\n        // EVENT: Adjust audio pitch based on position\n        UpdateAudioPitch();\n    }\n\n    private void ApplyUpwardForce()\n    {\n        if (_rigidbody == null)\n            return;\n\n        Vector3 upwardForce = Vector3.up * _currentVerticalVelocity;\n        _rigidbody.AddForce(upwardForce, ForceMode.Force);\n    }\n\n    private void UpdateAudioPitch()\n    {\n        if (_audioSource == null || audioClip == null)\n            return;\n\n        // Adjust pitch based on vertical position\n        float heightRatio = transform.position.y / maxHeight;\n        float pitch = Mathf.Lerp(0.5f, 2.0f, heightRatio);\n        _audioSource.pitch = pitch;\n    }\n\n    private void UpdateScalePulse()\n    {\n        if (_audioSource == null || audioClip == null)\n            return;\n\n        // Pulse scale with audio frequency (simplified implementation)\n        float playbackSpeed = _audioSource.isPlaying ? _audioSource.timeSamples / (float)AudioSettings.outputSampleRate : 0;\n        float frequencyFactor = playbackSpeed / audioClip.length;\n\n        float scaleAmount = Mathf.Lerp(0.8f, 1.2f, frequencyFactor);\n        transform.localScale = Vector3.one * scaleAmount;\n    }\n}",
    "ir_json": {
      "class_name": "FloatingObject",
      "components": [
        "Rigidbody",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "targetPosition",
          "type": "Vector3",
          "default": null
        },
        {
          "name": "minHeight",
          "type": "float",
          "default": 0.0
        },
        {
          "name": "maxHeight",
          "type": "float",
          "default": 5.0
        },
        {
          "name": "hoverSpeed",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "fallSpeed",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "rotationSpeed",
          "type": "float",
          "default": 180.0
        },
        {
          "name": "audioClip",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "update_position",
          "trigger": "every frame",
          "actions": [
            {
              "action": "calculate distance to target position",
              "target": "targetPosition",
              "temporal": "event"
            },
            {
              "action": "set vertical velocity based on distance",
              "near_threshold": 5.0,
              "max_height": "maxHeight",
              "min_height": "minHeight",
              "hover_speed": "hoverSpeed",
              "fall_speed": "fallSpeed",
              "temporal": "event"
            },
            {
              "action": "apply upward force to rigidbody",
              "direction": "upward",
              "speed": "calculated vertical velocity",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "update_rotation",
          "trigger": "every frame",
          "actions": [
            {
              "action": "rotate object opposite to movement direction",
              "rotation_speed": "rotationSpeed",
              "movement_direction": "vertical",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "update_audio",
          "trigger": "every frame",
          "actions": [
            {
              "action": "play audio clip continuously",
              "audio_source": "AudioSource",
              "clip": "audioClip",
              "loop": true,
              "temporal": "continuous"
            },
            {
              "action": "adjust pitch based on position",
              "pitch_min": 0.5,
              "pitch_max": 2.0,
              "height_ratio": "current vertical position / maxHeight",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "update_scale_pulse",
          "trigger": "every frame",
          "actions": [
            {
              "action": "pulse scale with audio frequency",
              "audio_source": "AudioSource",
              "scale_min": 0.8,
              "scale_max": 1.2,
              "frequency_factor": "current playback speed / clip length",
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive implementation of all requested features",
        "Careful handling of initialization and state tracking",
        "Robust null checks and component references",
        "Smooth vertical movement with distance-based velocity",
        "Audio pitch and scale manipulation implemented creatively"
      ],
      "weaknesses": [
        "Scale pulse calculation is somewhat simplistic",
        "No explicit handling of minimum/maximum height constraints",
        "Rotation direction might not perfectly match movement direction"
      ],
      "suggestions": [
        "Implement more precise height boundary checks",
        "Add configurable rotation axis based on movement direction",
        "Consider using more sophisticated audio frequency analysis for scale pulsing",
        "Add error logging for missing components",
        "Provide inspector tooltips for serialized fields"
      ]
    },
    "grade_time": 13.567741394042969,
    "error": null
  },
  {
    "prompt": "8. \"Build a physics-based pendulum that swings naturally, but when it reaches the bottom of its swing, it applies an explosive force to any rigidbody it touches, plays a bell sound, and creates a shockwave particle effect. The pendulum's rope length can be adjusted, and the swing speed affects the volume of the bell sound.\"",
    "success": true,
    "generation_time": 57.02267670631409,
    "rag_docs_used": 16,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class ExplosivePendulum : MonoBehaviour\n{\n    [SerializeField] private float ropeLength = 10.0f;\n    [SerializeField] private float swingSpeedMultiplier = 1.0f;\n    [SerializeField] private float explosionForce = 100.0f;\n    [SerializeField] private AudioClip bellSound = null;\n    [SerializeField] private GameObject shockwavePrefab = null;\n\n    private HingeJoint _hingeJoint;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Transform _pivotPoint;\n    private bool _isSwinging = false;\n    private float _lastBellPlayTime = 0f;\n    private const float BellCooldown = 1.0f; // Prevent bell sound spamming\n\n    void Start()\n    {\n        // Get components\n        _hingeJoint = GetComponent<HingeJoint>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n\n        // Find pivot point (assumed parent of pendulum)\n        if (_hingeJoint != null && transform.parent != null)\n        {\n            _pivotPoint = transform.parent;\n        }\n    }\n\n    void Update()\n    {\n        // Check if pendulum is swinging\n        if (_hingeJoint != null && IsSwinging())\n        {\n            float swingSpeed = CalculateSwingSpeed();\n            \n            // Modulate bell sound volume based on swing speed\n            if (bellSound != null && _audioSource != null)\n            {\n                float volume = Mathf.Clamp01(swingSpeed * swingSpeedMultiplier);\n                _audioSource.volume = volume;\n                \n                // Play bell sound when swinging and not recently played\n                if (!_audioSource.isPlaying && Time.time - _lastBellPlayTime > BellCooldown)\n                {\n                    _audioSource.PlayOneShot(bellSound);  // EVENT action: play once\n                    _lastBellPlayTime = Time.time;\n                }\n            }\n            \n            // Check for bottom of swing (angle near 0\u00b0)\n            if (IsNearBottomOfSwing())\n            {\n                TriggerBottomOfSwing();\n            }\n        }\n    }\n\n    private bool IsSwinging()\n    {\n        return Mathf.Abs(_hingeJoint.angle) > 10f; // Consider swinging if angle is significant\n    }\n\n    private float CalculateSwingSpeed()\n    {\n        // Get angular velocity in degrees per second\n        float angularVelocity = _hingeJoint.velocity;\n        \n        // Convert to linear swing speed at pivot point\n        // Linear speed = angular velocity * radius (rope length)\n        return Mathf.Abs(angularVelocity) * ropeLength;\n    }\n\n    private bool IsNearBottomOfSwing()\n    {\n        // Check if angle is near 0\u00b0 (bottom of swing)\n        float angle = _hingeJoint.angle;\n        return (angle > -5f && angle < 5f);\n    }\n\n    private void TriggerBottomOfSwing()\n    {\n        // EVENT actions: execute once when reaching bottom\n        SpawnShockwave();\n    }\n\n    private void SpawnShockwave()\n    {\n        if (shockwavePrefab != null)\n        {\n            Vector3 spawnPosition = transform.position;\n            Quaternion spawnRotation = Quaternion.identity;\n            \n            GameObject shockwave = Instantiate(shockwavePrefab, spawnPosition, spawnRotation);\n            \n            // Add ShockwaveCollision component if not present\n            if (shockwave != null)\n            {\n                ShockwaveCollision collisionHandler = shockwave.AddComponent<ShockwaveCollision>();\n                collisionHandler.explosionForce = explosionForce;\n                collisionHandler.pendulumPivot = _pivotPoint;\n            }\n        }\n    }\n\n    // Helper class to handle shockwave collisions\n    private class ShockwaveCollision : MonoBehaviour\n    {\n        public Transform pendulumPivot;\n\n        void OnCollisionEnter(Collision collision)\n        {\n            Rigidbody targetRigidbody = collision.gameObject.GetComponent<Rigidbody>();\n            \n            if (targetRigidbody != null && pendulumPivot != null)\n            {\n                // Apply explosion force away from pivot point\n                Vector3 direction = (transform.position - pendulumPivot.position).normalized;\n                targetRigidbody.AddExplosionForce(explosionForce, transform.position, 5.0f);\n                \n                // EVENT action: apply force once on collision\n                // This is handled by AddExplosionForce which is an EVENT action\n            }\n        }\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        if (_pivotPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(transform.position, _pivotPoint.position);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "ExplosivePendulum",
      "components": [
        "HingeJoint",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "ropeLength",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "swingSpeedMultiplier",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "explosionForce",
          "type": "float",
          "default": 100.0
        },
        {
          "name": "bellSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "shockwavePrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on_swing",
          "trigger": "every frame when pendulum is swinging",
          "actions": [
            {
              "action": "calculate swing speed based on angle velocity and rope length",
              "temporal": "continuous"
            },
            {
              "action": "modulate bell sound volume by swingSpeedMultiplier * swingSpeed",
              "target": "bellSound",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "on_bottom_of_swing",
          "trigger": "when pendulum reaches bottom of swing (angle near 0\u00b0)",
          "actions": [
            {
              "action": "play bell sound",
              "target": "bellSound",
              "temporal": "event"
            },
            {
              "action": "spawn shockwave particle effect",
              "prefab": "shockwavePrefab",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "on_shockwave_collision",
          "trigger": "when shockwave collides with rigidbody",
          "actions": [
            {
              "action": "apply explosion force to collided rigidbody",
              "force": "explosionForce",
              "direction": "away from pendulum pivot",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of pendulum physics",
        "Dynamic sound volume based on swing speed",
        "Modular shockwave spawn mechanism",
        "Good use of SerializeField for configuration",
        "Safe null checks throughout code"
      ],
      "weaknesses": [
        "Incomplete ShockwaveCollision implementation",
        "No explicit error handling for missing components",
        "Hardcoded angle thresholds without configurability",
        "Potential performance overhead with per-frame calculations"
      ],
      "suggestions": [
        "Complete the ShockwaveCollision class to handle full explosion force logic",
        "Add configuration options for angle detection thresholds",
        "Implement interface for more flexible component interactions",
        "Consider caching component references to reduce GetComponent calls",
        "Add logging or debug warnings for missing required components"
      ]
    },
    "grade_time": 9.65788722038269,
    "error": null
  },
  {
    "prompt": "9. \"Create a time bomb that beeps every second, with the beep frequency increasing as time runs down. The object's color pulses red in sync with beeps, and it shakes more violently as time decreases. After 10 seconds, it explodes with a massive force affecting all rigidbodies in a 20-unit radius, plays an explosion sound, and spawns fire particles that last 5 seconds.\"",
    "success": true,
    "generation_time": 60.978474140167236,
    "rag_docs_used": 21,
    "was_steered": true,
    "generated_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeBomb : MonoBehaviour\n{\n    [SerializeField] private float explosionForce = 1000.0f;\n    [SerializeField] private float explosionRadius = 20.0f;\n    [SerializeField] private AudioClip beepSound = null;\n    [SerializeField] private GameObject particleSystemPrefab = null;\n\n    private AudioSource _audioSource;\n    private ParticleSystem _particleSystem;\n    private Rigidbody _rigidbody;\n    \n    // Timer state\n    private float _countdownTimer = 10.0f;  // Start at 10 seconds\n    private bool _isActivated = false;\n    private bool _timerStarted = false;\n\n    void Start()\n    {\n        // Get required components\n        _audioSource = GetComponent<AudioSource>();\n        _particleSystem = GetComponent<ParticleSystem>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        // Validate required components exist before continuing\n        if (_audioSource == null)\n            Debug.LogError(\"TimeBomb requires an AudioSource component\", gameObject);\n            \n        if (_particleSystem == null)\n            Debug.LogError(\"TimeBomb requires a ParticleSystem component\", gameObject);\n            \n        if (_rigidbody == null)\n            Debug.LogError(\"TimeBomb requires a Rigidbody component\", gameObject);\n    }\n\n    void Update()\n    {\n        // Only run timer logic when bomb is activated\n        if (!_isActivated || _countdownTimer <= 0.0f)\n            return;\n        \n        // Decrement timer every frame\n        _countdownTimer -= Time.deltaTime;\n        _countdownTimer = Mathf.Max(0.0f, _countdownTimer);\n        \n        // Trigger explosion when timer reaches zero\n        if (_countdownTimer <= 0.0f && !_timerStarted)\n        {\n            Explode();\n            return;\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Activate bomb on trigger enter (if not already active)\n        if (!_isActivated)\n        {\n            _isActivated = true;\n            StartCountdown();\n        }\n    }\n\n    private void StartCountdown()\n    {\n        // Initialize timer state\n        _timerStarted = true;\n        _countdownTimer = 10.0f;  // Reset to full duration\n        \n        Debug.Log(\"Bomb activated - countdown started\", gameObject);\n        \n        // Play initial beep sound if available\n        if (_audioSource != null && beepSound != null)\n            _audioSource.PlayOneShot(beepSound);\n    }\n\n    private void Explode()\n    {\n        // Apply explosion force to all rigidbodies in radius\n        Collider[] colliders = Physics.OverlapSphere(transform.position, explosionRadius);\n        \n        foreach (Collider collider in colliders)\n        {\n            Rigidbody targetRigidbody = collider.GetComponent<Rigidbody>();\n            \n            if (targetRigidbody != null && targetRigidbody != _rigidbody)\n            {\n                Vector3 direction = (collider.transform.position - transform.position).normalized;\n                float distance = Vector3.Distance(collider.transform.position, transform.position);\n                \n                // Apply force with falloff based on distance\n                float normalizedDistance = Mathf.Clamp01(1.0f - (distance / explosionRadius));\n                float forceMagnitude = explosionForce * normalizedDistance;\n                \n                targetRigidbody.AddExplosionForce(forceMagnitude, transform.position, explosionRadius);\n            }\n        }\n        \n        // Play explosion sound if available\n        if (_audioSource != null && beepSound != null)\n            _audioSource.PlayOneShot(beepSound);  // \u2713 EVENT action - play once\n        \n        // Spawn particle system for visual effect\n        if (particleSystemPrefab != null && _particleSystem != null)\n        {\n            StartCoroutine(SpawnExplosionParticles());\n        }\n        \n        // Destroy bomb object after explosion\n        Destroy(gameObject);\n    }\n\n    private IEnumerator SpawnExplosionParticles()\n    {\n        // Create particle system instance at bomb position\n        GameObject particles = Instantiate(particleSystemPrefab, transform.position, Quaternion.identity);\n        \n        // Play and wait for duration\n        ParticleSystem ps = particles.GetComponent<ParticleSystem>();\n        if (ps != null)\n            yield return new WaitForSeconds(ps.main.duration);\n        \n        // Clean up\n        Destroy(particles);\n    }\n}",
    "ir_json": {
      "class_name": "TimeBomb",
      "components": [
        "AudioSource",
        "ParticleSystem",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "explosionForce",
          "type": "float",
          "default": 1000.0
        },
        {
          "name": "explosionRadius",
          "type": "float",
          "default": 20.0
        },
        {
          "name": "beepSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "particleSystemPrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "timer",
          "trigger": "when bomb is activated",
          "actions": [
            {
              "action": "start countdown timer for 10 seconds",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "beep_timer",
          "trigger": "every second while timer > 0",
          "actions": [
            {
              "action": "play beep sound",
              "target": "beepSound",
              "temporal": "continuous"
            },
            {
              "action": "increase beep frequency over time",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "color_pulse_timer",
          "trigger": "every 0.1 seconds while timer > 0",
          "actions": [
            {
              "action": "pulse red color in sync with beeps",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "shake_intensity_timer",
          "trigger": "update as time decreases",
          "actions": [
            {
              "action": "increase shake intensity over time",
              "temporal": "continuous"
            }
          ]
        },
        {
          "name": "explosion_trigger",
          "trigger": "after 10 seconds",
          "actions": [
            {
              "action": "apply explosion force to all rigidbodies in radius",
              "radius": 20,
              "force": 1000,
              "temporal": "event"
            },
            {
              "action": "play explosion sound",
              "target": "explosionSound",
              "temporal": "event"
            },
            {
              "action": "spawn fire particles for 5 seconds",
              "prefab": "particleSystemPrefab",
              "duration": 5,
              "temporal": "event"
            },
            {
              "action": "destroy bomb object after explosion",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Robust component validation in Start()",
        "Careful explosion force calculation with distance falloff",
        "Trigger-based activation mechanism",
        "Comprehensive error logging",
        "Proper use of SerializeField for inspector configurability"
      ],
      "weaknesses": [
        "Incomplete SpawnExplosionParticles() coroutine (code cut off)",
        "Missing color pulsing and shake intensity implementation",
        "Beep frequency increase not implemented",
        "No visual feedback for countdown progression"
      ],
      "suggestions": [
        "Implement color pulsing using a Renderer component and lerping",
        "Add shake intensity using transform.localPosition or cinemachine",
        "Complete SpawnExplosionParticles() coroutine with timed particle emission",
        "Create a more sophisticated beep frequency increase algorithm",
        "Add configurable shake and color pulse intensity curves"
      ]
    },
    "grade_time": 13.679898977279663,
    "error": null
  },
  {
    "prompt": "10. \"Make a script that gradually transforms an object over 30 seconds: it smoothly rotates 360 degrees, scales from 1x to 2x and back, changes color through the rainbow spectrum, moves in a figure-8 pattern, and plays a continuous musical note that shifts pitch based on the current transformation phase. All transformations must be perfectly synchronized.\"",
    "success": true,
    "generation_time": 50.39494609832764,
    "rag_docs_used": 12,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class TransformationSynchronizer : MonoBehaviour\n{\n    [SerializeField] private float duration = 30.0f;\n    [SerializeField] private float rotationSpeed = 1.0f;\n    [SerializeField] private float scaleAmplitude = 1.0f;\n    [SerializeField] private float colorSpeed = 0.5f;\n    [SerializeField] private float figure8Radius = 3.0f;\n    [SerializeField] private float basePitch = 220.0f;\n\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private float _elapsedTime = 0f;\n    private bool _isInitialized = false;\n\n    // EVENT actions for synchronize_transformations\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n\n        if (_audioSource != null && _animator != null)\n        {\n            InitializeTransformationPhases();\n            _audioSource.PlayOneShot(_audioSource.clip); // EVENT action - play once at start\n            _isInitialized = true;\n        }\n    }\n\n    private void InitializeTransformationPhases()\n    {\n        // TODO: Implement phase initialization logic if needed\n        Debug.Log(\"Initializing transformation phases\");\n    }\n\n    // CONTINUOUS actions for update_transformation\n    void Update()\n    {\n        if (!_isInitialized || _elapsedTime >= duration)\n            return;\n\n        float t = _elapsedTime / duration;\n        \n        CalculatePhaseProgress(t);\n        ApplyRotation(t);\n        ApplyScaleOscillation(t);\n        UpdateColorGradient(t);\n        CalculateFigure8Position(t);\n        SetPitchBasedOnPhase(t);\n\n        _elapsedTime += Time.deltaTime;\n    }\n\n    private void CalculatePhaseProgress(float t)\n    {\n        // TODO: Implement phase progress calculation\n        Debug.Log($\"Phase progress: {t}\");\n    }\n\n    private void ApplyRotation(float t)\n    {\n        transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime, Space.World);\n    }\n\n    private void ApplyScaleOscillation(float t)\n    {\n        float scale = 1.0f + Mathf.Sin(t * Mathf.PI * 2) * scaleAmplitude;\n        transform.localScale = Vector3.one * scale;\n    }\n\n    private void UpdateColorGradient(float t)\n    {\n        // TODO: Implement color gradient update\n        Color color = new Color(\n            Mathf.Sin(t * colorSpeed),\n            Mathf.Cos(t * colorSpeed),\n            Mathf.Sin(t * colorSpeed + Mathf.PI / 2),\n            1.0f);\n        \n        GetComponent<Renderer>()?.material.color = color;\n    }\n\n    private void CalculateFigure8Position(float t)\n    {\n        float x = figure8Radius * Mathf.Sin(t * Mathf.PI * 2);\n        float z = figure8Radius * Mathf.Sin(t * Mathf.PI * 2 + Mathf.PI / 2);\n        \n        transform.position = new Vector3(x, transform.position.y, z);\n    }\n\n    private void SetPitchBasedOnPhase(float t)\n    {\n        if (_audioSource != null)\n        {\n            float pitch = basePitch + Mathf.Sin(t * Mathf.PI * 2) * 100;\n            _audioSource.pitch = pitch;\n        }\n    }\n}",
    "ir_json": {
      "class_name": "TransformationSynchronizer",
      "components": [
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "duration",
          "type": "float",
          "default": 30.0
        },
        {
          "name": "rotationSpeed",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "scaleAmplitude",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "colorSpeed",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "figure8Radius",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "basePitch",
          "type": "float",
          "default": 220.0
        }
      ],
      "behaviors": [
        {
          "name": "synchronize_transformations",
          "trigger": "when script starts",
          "actions": [
            {
              "action": "initialize transformation phases",
              "temporal": "event"
            },
            {
              "action": "start audio playback",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "update_transformation",
          "trigger": "every frame for duration",
          "actions": [
            {
              "action": "calculate phase progress",
              "temporal": "continuous"
            },
            {
              "action": "apply rotation",
              "speed": "rotationSpeed",
              "temporal": "continuous"
            },
            {
              "action": "apply scale oscillation",
              "amplitude": "scaleAmplitude",
              "temporal": "continuous"
            },
            {
              "action": "update color gradient",
              "speed": "colorSpeed",
              "temporal": "continuous"
            },
            {
              "action": "calculate figure8 position",
              "radius": "figure8Radius",
              "temporal": "continuous"
            },
            {
              "action": "set pitch based on phase",
              "basePitch": "basePitch",
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of transformation synchronization",
        "Good use of time-based interpolation",
        "Proper component retrieval in Start()",
        "Flexible serialized fields for customization",
        "Handles initialization and duration tracking"
      ],
      "weaknesses": [
        "Incomplete color gradient implementation",
        "Figure-8 movement might not be perfectly centered",
        "Audio playback uses PlayOneShot instead of continuous play",
        "Some TODO comments left unimplemented",
        "No error handling for missing components"
      ],
      "suggestions": [
        "Implement a more precise rainbow color spectrum calculation",
        "Use AudioSource.Play() for continuous sound instead of PlayOneShot",
        "Add more robust error handling and logging",
        "Consider using Mathf.Lerp for smoother transformations",
        "Implement a more precise figure-8 movement calculation",
        "Add option to reset or loop transformations after duration"
      ]
    },
    "grade_time": 13.18232250213623,
    "error": null
  },
  {
    "prompt": "11. \"Create a visualizer that reacts to audio: when a sound plays, the object's scale increases proportionally to the audio volume, its color shifts based on the audio frequency (low = red, mid = green, high = blue), it rotates based on the audio waveform, and spawns particles that move outward in sync with the beat. The object should analyze the AudioSource's spectrum data in real-time.\"",
    "success": true,
    "generation_time": 51.29231643676758,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class AudioVisualizer : MonoBehaviour\n{\n    [SerializeField] private float targetScaleMultiplier = 2.0f;\n    [SerializeField] private float colorShiftSpeed = 0.5f;\n    [SerializeField] private float rotationIntensity = 1.0f;\n    [SerializeField] private GameObject particlePrefab = null;\n\n    private AudioSource _audioSource;\n    private Transform _transform;\n    private Renderer _renderer;\n    private Vector3 baseScale;\n    private float[] spectrumData = new float[128];\n    private float currentColorShift = 0.0f;\n    private bool isAudioPlaying = false;\n\n    void Start()\n    {\n        // Get required components\n        _audioSource = GetComponent<AudioSource>();\n        _transform = GetComponent<Transform>();\n        _renderer = GetComponent<Renderer>();\n\n        if (_audioSource == null)\n        {\n            Debug.LogError(\"AudioSource component not found on \" + gameObject.name);\n            return;\n        }\n\n        if (_renderer == null)\n        {\n            Debug.LogError(\"Renderer component not found on \" + gameObject.name);\n            return;\n        }\n\n        // Store base scale for later use\n        baseScale = _transform.localScale;\n\n        // Start audio playback if available\n        if (_audioSource.isPlaying || _audioSource.clip != null)\n        {\n            isAudioPlaying = true;\n        }\n    }\n\n    void Update()\n    {\n        // Check if audio is playing and update state accordingly\n        if (!isAudioPlaying && (_audioSource.isPlaying || (_audioSource.clip != null && !_audioSource.isPlaying)))\n        {\n            isAudioPlaying = _audioSource.isPlaying;\n        }\n\n        // Only process audio when it's actually playing\n        if (isAudioPlaying)\n        {\n            // Get spectrum data - EVENT action (once per frame while audio is playing)\n            _audioSource.GetSpectrumData(spectrumData, 0, FFTWindow.BlackmanHarris);\n\n            // Calculate average volume level for scaling\n            float totalVolume = 0.0f;\n            int sampleCount = Mathf.Min(64, spectrumData.Length); // Use first 64 frequency bands\n\n            for (int i = 0; i < sampleCount; i++)\n            {\n                totalVolume += spectrumData[i];\n            }\n\n            float averageVolume = totalVolume / sampleCount;\n\n            // SCALE OBJECT BASED ON AVERAGE VOLUME LEVEL - CONTINUOUS action\n            Vector3 newScale = baseScale * (1.0f + targetScaleMultiplier * averageVolume);\n            _transform.localScale = newScale;\n\n            // SHIFT COLOR BASED ON FREQUENCY BANDS - CONTINUOUS action\n            currentColorShift += colorShiftSpeed * Time.deltaTime;\n            if (currentColorShift > 3.0f) // Cycle through frequency bands every 3 seconds\n                currentColorShift = 0.0f;\n\n            float lowFreqWeight = Mathf.Clamp01(spectrumData[0] + spectrumData[1] + spectrumData[2]);\n            float midFreqWeight = Mathf.Clamp01(spectrumData[16] + spectrumData[17] + spectrumData[18]);\n            float highFreqWeight = Mathf.Clamp01(spectrumData[64] + spectrumData[65] + spectrumData[66]);\n\n            // Interpolate between frequency colors\n            Color currentColor;\n\n            if (currentColorShift < 1.0f)\n            {\n                // Low frequencies dominant\n                currentColor = Color.Lerp(Color.red, Color.yellow, lowFreqWeight);\n            }\n            else if (currentColorShift < 2.0f)\n            {\n                // Mid frequencies dominant\n                currentColor = Color.Lerp(Color.yellow, Color.green, midFreqWeight);\n            }\n            else\n            {\n                // High frequencies dominant\n                currentColor = Color.Lerp(Color.green, Color.blue, highFreqWeight);\n            }\n\n            _renderer.material.color = currentColor;\n\n            // ROTATE OBJECT BASED ON WAVEFORM AMPLITUDE - CONTINUOUS action\n            float waveformAmplitude = 0.0f;\n            for (int i = 0; i < sampleCount; i++)\n            {\n                waveformAmplitude += Mathf.Abs(spectrumData[i]);\n            }\n\n            // Create rotation based on waveform amplitude\n            Vector3 rotationVector = new Vector3(\n                waveformAmplitude * rotationIntensity,\n                waveformAmplitude * rotationIntensity,\n                waveformAmplitude * rotationIntensity);\n\n            _transform.localEulerAngles = rotationVector;\n\n            // TODO: Consider adding particle effects that spawn in response to audio levels\n        }\n    }\n\n    void OnDisable()\n    {\n        // Reset audio state when object is disabled\n        isAudioPlaying = false;\n    }\n}",
    "ir_json": {
      "class_name": "AudioVisualizer",
      "components": [
        "AudioSource",
        "Transform"
      ],
      "fields": [
        {
          "name": "targetScaleMultiplier",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "colorShiftSpeed",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "rotationIntensity",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "particlePrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on_audio_update",
          "trigger": "every frame while audio is playing",
          "actions": [
            {
              "action": "get spectrum data from AudioSource component",
              "temporal": "event"
            },
            {
              "action": "scale object based on average volume level",
              "formula": "baseScale multiplied by (1 plus targetScaleMultiplier times normalizedVolume)",
              "temporal": "continuous"
            },
            {
              "action": "shift color based on frequency bands",
              "lowFreqColor": "#FF0000",
              "midFreqColor": "#00FF00",
              "highFreqColor": "#0000FF",
              "temporal": "continuous"
            },
            {
              "action": "rotate object based on waveform amplitude",
              "intensity": "rotationIntensity times waveformValue",
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive spectrum data analysis",
        "Dynamic color shifting based on frequency bands",
        "Scale and volume correlation",
        "Robust component checking in Start method",
        "Use of SerializeField for inspector configurability"
      ],
      "weaknesses": [
        "Incomplete rotation implementation",
        "No particle spawning logic",
        "Incomplete spectrum data processing",
        "Missing error handling for particle prefab",
        "Abruptly cut-off code in the last method"
      ],
      "suggestions": [
        "Complete the waveform-based rotation logic",
        "Implement particle spawning method",
        "Add more granular frequency band analysis",
        "Implement a more sophisticated color transition",
        "Add optional debug logging for audio visualization",
        "Complete the unfinished Update method"
      ]
    },
    "grade_time": 13.967238664627075,
    "error": null
  },
  {
    "prompt": "12. \"Make a singing crystal that, when touched, plays a sequence of 5 musical notes in a chord progression. Each note lights up a different part of the crystal (top, middle, bottom, left, right), and the entire crystal pulses with the rhythm. After the sequence completes, it plays a final harmonious note and creates a burst of light particles.\"",
    "success": true,
    "generation_time": 47.6820912361145,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class SingingCrystal : MonoBehaviour\n{\n    [SerializeField] private string[] chordNotes = { \"C4\", \"E4\", \"G4\" };\n    [SerializeField] private float pulseSpeed = 1.5f;\n    [SerializeField] private GameObject lightBurstPrefab = null;\n    [SerializeField] private GameObject[] noteLights = new GameObject[0];\n\n    private MeshRenderer _meshRenderer;\n    private Animator _animator;\n    private AudioSource _audioSource;\n\n    // State tracking for conditional actions\n    private bool isChordPlaying = false;\n    private float chordCompletionTime = 0f;\n    private const float CHORD_DURATION = 0.5f; // Duration to wait before playing final note\n\n    void Start()\n    {\n        // Get required components\n        _meshRenderer = GetComponent<MeshRenderer>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n\n        // Initialize state\n        isChordPlaying = false;\n        chordCompletionTime = 0f;\n\n        // Cache player reference if needed (example)\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            Debug.Log(\"Player found: \" + playerObj.name);\n        }\n    }\n\n    void Update()\n    {\n        // Handle conditional action for chord completion\n        if (isChordPlaying && Time.time - chordCompletionTime >= CHORD_DURATION)\n        {\n            PlayFinalHarmoniousNote();\n            isChordPlaying = false;\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            // Execute EVENT actions for crystal touch\n            PlayChordProgression();\n            LightUpSectionsInSequence();\n            StartCrystalPulseAnimation();\n            SpawnLightBurstParticles();\n\n            isChordPlaying = true;\n            chordCompletionTime = Time.time; // Set start time for conditional action\n        }\n    }\n\n    private void PlayChordProgression()\n    {\n        if (_audioSource == null) return;\n\n        foreach (string note in chordNotes)\n        {\n            _audioSource.PlayOneShot(GetAudioClipForNote(note));\n        }\n    }\n\n    private void LightUpSectionsInSequence()\n    {\n        // Example: light up sections sequentially\n        int count = 0;\n        foreach (GameObject light in noteLights)\n        {\n            if (light != null)\n            {\n                // Use a slight delay between lights for sequence effect\n                Invoke(\"LightUpSection\", count * 0.1f);\n                count++;\n            }\n        }\n\n        void LightUpSection()\n        {\n            _meshRenderer.material.color = Color.yellow;\n        }\n    }\n\n    private void StartCrystalPulseAnimation()\n    {\n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Pulse\");\n        }\n    }\n\n    private void PlayFinalHarmoniousNote()\n    {\n        if (_audioSource == null) return;\n\n        // Harmonize the chord notes (example: play last note as final harmonious sound)\n        string finalNote = \"A4\"; // Example - replace with actual harmonization logic\n        _audioSource.PlayOneShot(GetAudioClipForNote(finalNote));\n    }\n\n    private void SpawnLightBurstParticles()\n    {\n        if (lightBurstPrefab != null && transform.position != null)\n        {\n            Instantiate(lightBurstPrefab, transform.position, Quaternion.identity);\n        }\n    }\n\n    // Helper method to get audio clip for note\n    private AudioClip GetAudioClipForNote(string noteName)\n    {\n        // Replace with actual logic to find and return the appropriate AudioClip\n        Debug.LogWarning(\"GetAudioClipForNote not implemented - returning null\");\n        return null;\n    }\n}",
    "ir_json": {
      "class_name": "SingingCrystal",
      "components": [
        "MeshRenderer",
        "Animator",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "chordNotes",
          "type": "string[]",
          "default": [
            "C4",
            "E4",
            "G4"
          ]
        },
        {
          "name": "pulseSpeed",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "lightBurstPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "noteLights",
          "type": "GameObject[]",
          "default": []
        }
      ],
      "behaviors": [
        {
          "name": "on_crystal_touch",
          "trigger": "player collision or raycast hit",
          "actions": [
            {
              "action": "play chord progression",
              "notes": "chordNotes",
              "temporal": "event"
            },
            {
              "action": "light up sections in sequence",
              "sections": [
                "top",
                "middle",
                "bottom",
                "left",
                "right"
              ],
              "temporal": "event"
            },
            {
              "action": "start crystal pulse animation",
              "speed": "pulseSpeed",
              "temporal": "event"
            },
            {
              "action": "wait for chord completion",
              "duration": 0.5,
              "temporal": "conditional"
            },
            {
              "action": "play final harmonious note",
              "note": "harmonize(chordNotes)",
              "temporal": "event"
            },
            {
              "action": "spawn light burst particles",
              "prefab": "lightBurstPrefab",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of touch-triggered crystal behavior",
        "Proper use of Unity lifecycle methods (Start, Update, OnTriggerEnter)",
        "Conditional logic for chord progression and final note",
        "Good use of SerializeField for configurable parameters",
        "Modular method design with clear separation of concerns"
      ],
      "weaknesses": [
        "GetAudioClipForNote method is not implemented",
        "Light sequence logic is simplistic",
        "No error handling for missing components",
        "Harmonization logic is placeholder",
        "No volume or pitch control for audio"
      ],
      "suggestions": [
        "Implement a robust audio clip lookup mechanism for notes",
        "Add more sophisticated light sequencing with individual section controls",
        "Create a more detailed harmonization algorithm",
        "Add error logging for missing components",
        "Implement audio volume and pitch variation",
        "Consider using a ScriptableObject for note configuration",
        "Add comments explaining complex logic sections"
      ]
    },
    "grade_time": 11.706455707550049,
    "error": null
  },
  {
    "prompt": "13. \"Build a pressure plate system: when weight is applied (detected via collision), it plays a click sound, changes color to green, and starts a 5-second timer. If weight is removed before 5 seconds, it resets. If weight stays for 5 seconds, it plays a success sound, spawns a reward object, and triggers all nearby pressure plates to also activate. Each pressure plate remembers how many times it's been activated.\"",
    "success": true,
    "generation_time": 79.80714392662048,
    "rag_docs_used": 17,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class PressurePlate : MonoBehaviour\n{\n\n    [SerializeField] private GameObject rewardPrefab = null;\n    [SerializeField] private AudioClip activationSound;\n    [SerializeField] private AudioClip successSound;\n    [SerializeField] private Color activeColor = new Color(0, 1, 0, 1);\n    [SerializeField] private Color inactiveColor = new Color(1, 1, 1, 1);\n    [SerializeField] private int activationCount = 0;\n    [SerializeField] private float timerDuration = 5.0f;\n\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private State _currentState = State.Inactive;\n    private State _previousState;\n    private float _timerStart;\n    private bool _weightApplied = false;\n    private bool _wasWeightApplied = false;\n\n    // Component references\n    private Collider _collider;\n\n    private enum State\n    {\n        Inactive,\n        Activated,\n        Success\n    }\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n\n        if (_renderer != null)\n        {\n            _renderer.material.color = inactiveColor;\n        }\n    }\n\n    private void Update()\n    {\n        State nextState = DetermineNextState();\n\n        // Detect state changes\n        if (nextState != _currentState)\n        {\n            ExitState(_currentState);\n            _previousState = _currentState;\n            _currentState = nextState;\n            EnterState(_currentState);  // EVENT actions here (temporal: \"event\")\n        }\n\n        UpdateState(_currentState);  // CONTINUOUS actions here (temporal: \"continuous\")\n\n        // Track weight application state\n        _wasWeightApplied = _weightApplied;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Weight\"))\n        {\n            _weightApplied = true;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Weight\"))\n        {\n            _weightApplied = false;\n        }\n    }\n\n    private State DetermineNextState()\n    {\n        switch (_currentState)\n        {\n            case State.Inactive:\n                return _weightApplied ? State.Activated : State.Inactive;\n\n            case State.Activated:\n                if (!_weightApplied && !_wasWeightApplied)\n                {\n                    // Weight removed before timer complete\n                    return State.Inactive;\n                }\n                \n                if (Time.time - _timerStart >= timerDuration)\n                {\n                    return State.Success;\n                }\n                return State.Activated;\n\n            case State.Success:\n                return State.Inactive;\n\n            default:\n                return State.Inactive;\n        }\n    }\n\n    private void EnterState(State state)\n    {\n        // EVENT actions execute here (temporal: \"event\")\n        switch (state)\n        {\n            case State.Inactive:\n                if (_renderer != null)\n                {\n                    _renderer.material.color = inactiveColor;\n                }\n                break;\n\n            case State.Activated:\n                _timerStart = Time.time;\n                \n                if (_audioSource != null && activationSound != null)\n                {\n                    _audioSource.PlayOneShot(activationSound);\n                }\n                \n                if (_renderer != null)\n                {\n                    _renderer.material.color = activeColor;\n                }\n                break;\n\n            case State.Success:\n                if (_audioSource != null && successSound != null)\n                {\n                    _audioSource.PlayOneShot(successSound);\n                }\n                \n                activationCount++;\n                \n                if (rewardPrefab != null)\n                {\n                    Instantiate(rewardPrefab, transform.position, Quaternion.identity);\n                }\n                break;\n        }\n    }\n\n    private void UpdateState(State state)\n    {\n        // CONTINUOUS actions execute here (temporal: \"continuous\")\n        switch (state)\n        {\n            case State.Activated:\n                // No continuous actions needed for this state\n                break;\n\n            case State.Inactive:\n                // No continuous actions needed for this state\n                break;\n\n            case State.Success:\n                // No continuous actions needed for this state\n                break;\n        }\n    }\n\n    private void ExitState(State state)\n    {\n        switch (state)\n        {\n            case State.Activated:\n                if (_renderer != null)\n                {\n                    _renderer.material.color = inactiveColor;\n                }\n                break;\n\n            case State.Success:\n                // No cleanup needed for success state\n                break;\n\n            case State.Inactive:\n                // No cleanup needed for inactive state\n                break;\n        }\n    }\n\n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n    }\n}",
    "ir_json": {
      "class_name": "PressurePlate",
      "components": [
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "activationSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "successSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "rewardPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "activeColor",
          "type": "Color",
          "default": "0, 1, 0, 1"
        },
        {
          "name": "inactiveColor",
          "type": "Color",
          "default": "1, 1, 1, 1"
        },
        {
          "name": "activationCount",
          "type": "int",
          "default": 0
        },
        {
          "name": "timerDuration",
          "type": "float",
          "default": 5.0
        }
      ],
      "behaviors": [
        {
          "name": "on_weight_applied",
          "trigger": "collision with tagged object",
          "actions": [
            {
              "action": "play audio clip",
              "target": "activationSound",
              "temporal": "event"
            },
            {
              "action": "set material color to activeColor",
              "temporal": "event"
            },
            {
              "action": "start activation timer",
              "duration": "timerDuration",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "on_timer_complete",
          "trigger": "5 seconds after weight applied",
          "actions": [
            {
              "action": "play audio clip",
              "target": "successSound",
              "temporal": "event"
            },
            {
              "action": "increment activation count",
              "target": "activationCount",
              "temporal": "event"
            },
            {
              "action": "spawn reward object",
              "prefab": "rewardPrefab",
              "position": "transform.position",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "on_timer_reset",
          "trigger": "when weight removed before timer complete",
          "actions": [
            {
              "action": "set material color to inactiveColor",
              "temporal": "event"
            },
            {
              "action": "stop activation timer",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": true,
        "initial_state": "inactive",
        "states": [
          {
            "name": "inactive",
            "actions": [
              {
                "action": "set material color to inactiveColor",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "activated",
                "condition": "weight applied"
              }
            ]
          },
          {
            "name": "activated",
            "actions": [
              {
                "action": "play audio clip",
                "target": "activationSound",
                "temporal": "event"
              },
              {
                "action": "set material color to activeColor",
                "temporal": "event"
              },
              {
                "action": "start timer for 5 seconds",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "success",
                "condition": "timer complete"
              },
              {
                "to": "inactive",
                "condition": "weight removed"
              }
            ]
          },
          {
            "name": "success",
            "actions": [
              {
                "action": "play audio clip",
                "target": "successSound",
                "temporal": "event"
              },
              {
                "action": "increment activation count",
                "temporal": "event"
              },
              {
                "action": "spawn reward object",
                "prefab": "rewardPrefab",
                "position": "transform.position",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "inactive",
                "condition": "always"
              }
            ]
          }
        ]
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Well-implemented state machine approach",
        "Robust state transition logic",
        "Comprehensive event handling",
        "Safe null checks on components",
        "Proper use of SerializeField for inspector configuration"
      ],
      "weaknesses": [
        "Incomplete implementation (code snippet is cut off)",
        "Missing nearby pressure plate activation feature",
        "No explicit error handling for missing components",
        "State machine could be more explicit with transitions"
      ],
      "suggestions": [
        "Complete the reward spawning logic in the Success state",
        "Implement method to activate nearby pressure plates",
        "Add explicit error logging for missing required components",
        "Consider using UnityEvents for more flexible event handling",
        "Add debug logging for state transitions"
      ]
    },
    "grade_time": 14.826001167297363,
    "error": null
  },
  {
    "prompt": "14. \"Create a combo system: hitting an object once makes it glow yellow and play a low note. Hitting it again within 2 seconds makes it glow orange and play a higher note. A third hit within 2 seconds makes it glow red and play an even higher note. A fourth hit within 2 seconds creates an explosion effect, plays a victory sound, and spawns 5 bonus objects. Missing the 2-second window resets the combo.\"",
    "success": true,
    "generation_time": 54.67595362663269,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class ComboSystem : MonoBehaviour\n{\n    [SerializeField] private Color baseColor = new Color(1f, 1f, 1f);\n    [SerializeField] private GameObject explosionPrefab = null;\n    [SerializeField] private AudioClip victorySound = null;\n\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private float lastHitTime = -10f; // Initialize to ensure first hit works\n    private int comboStage = 0;\n    private bool isProcessing = false;\n\n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = baseColor;\n        }\n    }\n\n    public void ProcessHit()\n    {\n        // EVENT action: Record combo timing\n        lastHitTime = Time.time;\n        \n        bool isComboActive = (Time.time - lastHitTime < 2f);\n        \n        if (!isProcessing)\n        {\n            isProcessing = true;\n            \n            if (isComboActive)\n            {\n                // CONDITIONAL check for combo progress\n                if (comboStage == 0)\n                {\n                    // First hit in sequence\n                    _audioSource.PlayOneShot(victorySound); // EVENT action\n                    _renderer.material.color = Color.yellow; // EVENT action\n                    \n                    comboStage++;\n                }\n                else if (comboStage == 1)\n                {\n                    // Second hit within time window\n                    _audioSource.PlayOneShot(victorySound);\n                    _renderer.material.color = Color.orange;\n                    \n                    comboStage++;\n                }\n                else if (comboStage == 2)\n                {\n                    // Third hit within time window\n                    _audioSource.PlayOneShot(victorySound);\n                    _renderer.material.color = Color.red;\n                    \n                    comboStage++;\n                }\n                else if (comboStage == 3)\n                {\n                    // Fourth hit - completion!\n                    _audioSource.PlayOneShot(victorySound);\n                    _renderer.material.color = Color.white; // Reset to base color\n                    \n                    // Trigger explosion and victory effects\n                    if (explosionPrefab != null)\n                    {\n                        Instantiate(explosionPrefab, transform.position, Quaternion.identity); // EVENT action\n                    }\n                    \n                    comboStage = 0;\n                }\n            }\n            else\n            {\n                // Combo timeout - reset\n                _audioSource.PlayOneShot(victorySound);\n                _renderer.material.color = baseColor; // Reset to base color\n                \n                comboStage = 0;\n            }\n            \n            isProcessing = false;\n        }\n    }\n\n    void Update()\n    {\n        // Check for combo completion every frame\n        if (comboStage == 4 && Time.time - lastHitTime < 2f)\n        {\n            // Combo completed successfully!\n            ProcessHit();\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // EVENT action: Triggered when object is hit\n        ProcessHit();\n    }\n}\n\n// TODO: Implement time tracking system to enforce 2-second windows\n// TODO: Add physics considerations for explosion force (complex physics)\n// TODO: Optimize particle systems for visual effects\n// TODO: Ensure renderer component exists before color changes",
    "ir_json": {
      "class_name": "ComboSystem",
      "components": [
        "AudioSource",
        "Renderer"
      ],
      "fields": [
        {
          "name": "baseColor",
          "type": "Color",
          "default": "#FFFFFF"
        },
        {
          "name": "explosionPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "victorySound",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "process_hit",
          "trigger": "when object is hit",
          "actions": [
            {
              "action": "record combo timing",
              "temporal": "event",
              "details": {
                "combo_id": "unique identifier for this combo attempt"
              }
            },
            {
              "action": "check combo progress",
              "temporal": "conditional",
              "condition": "time since last hit < 2 seconds",
              "then": [
                {
                  "action": "increment combo stage",
                  "temporal": "event"
                },
                {
                  "action": "play escalating sound",
                  "temporal": "event"
                },
                {
                  "action": "change glow color",
                  "color": "yellow/orange/red",
                  "temporal": "event"
                }
              ],
              "else": [
                {
                  "action": "reset combo",
                  "temporal": "event"
                },
                {
                  "action": "play failed sound",
                  "temporal": "event"
                }
              ]
            },
            {
              "action": "check for completion",
              "temporal": "conditional",
              "condition": "combo stage == 4 and time < 2 seconds",
              "then": [
                {
                  "action": "trigger explosion",
                  "target": "explosionPrefab",
                  "temporal": "event"
                },
                {
                  "action": "play victory sound",
                  "clip": "victorySound",
                  "temporal": "event"
                },
                {
                  "action": "spawn bonus objects",
                  "count": 5,
                  "temporal": "event"
                }
              ]
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      },
      "notes": [
        "TODO: Implement time tracking system to enforce 2-second windows",
        "TODO: Add physics considerations for explosion force (complex physics)",
        "TODO: Optimize particle systems for visual effects",
        "TODO: Ensure renderer component exists before color changes"
      ]
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 8,
      "strengths": [
        "Accurately implements the combo system logic",
        "Handles time-based combo progression",
        "Uses appropriate Unity components (AudioSource, Renderer)",
        "Implements hit detection via OnCollisionEnter",
        "Includes TODO comments for future improvements"
      ],
      "weaknesses": [
        "Potential race condition with isProcessing flag",
        "Overloading victorySound for different combo stages",
        "Lack of separate audio clips for different stages",
        "Bonus object spawning not implemented",
        "Update method might be inefficient for combo tracking"
      ],
      "suggestions": [
        "Create separate audio clips for each combo stage",
        "Implement a more robust state machine for combo progression",
        "Use a concurrent timer system instead of Update method",
        "Add error handling for missing components",
        "Implement actual bonus object spawning logic",
        "Consider using a more thread-safe approach for processing hits"
      ]
    },
    "grade_time": 12.46370005607605,
    "error": null
  },
  {
    "prompt": "15. \"Make a portal that, when you enter it, plays a whoosh sound, rotates you 180 degrees instantly, reverses your velocity, changes your color to a random hue, scales you to 0.5x size, and teleports you to a random location within 50 units, all while creating a visual distortion effect at both the entry and exit points.\"",
    "success": true,
    "generation_time": 43.72318172454834,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class PortalBehavior : MonoBehaviour\n{\n    [SerializeField] private AudioClip whooshSound = null;\n    [SerializeField] private GameObject distortionEffect = null;\n\n    private AudioSource _audioSource;\n    private SpriteRenderer _spriteRenderer;\n    private Animator _animator;\n    private Transform _player;\n\n    void Start()\n    {\n        // Get required components\n        _audioSource = GetComponent<AudioSource>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        _animator = GetComponent<Animator>();\n\n        // Cache player reference safely\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _player == other.transform)\n        {\n            // EVENT actions - execute once when entering portal\n            ExecutePortalEnterEffects();\n        }\n    }\n\n    private void ExecutePortalEnterEffects()\n    {\n        // 1. Play whoosh sound\n        if (_audioSource != null && whooshSound != null)\n        {\n            _audioSource.PlayOneShot(whooshSound);\n        }\n\n        // 2. Create entry distortion effect\n        if (distortionEffect != null)\n        {\n            Instantiate(distortionEffect, transform.position, Quaternion.identity);\n        }\n\n        // 3. Rotate player 180 degrees\n        if (_player != null)\n        {\n            _player.Rotate(Vector3.up * 180f);\n        }\n\n        // 4. Reverse player velocity vector (requires Rigidbody component)\n        Rigidbody playerRigidbody = _player?.GetComponent<Rigidbody>();\n        if (playerRigidbody != null)\n        {\n            Vector3 currentVelocity = playerRigidbody.velocity;\n            playerRigidbody.velocity = -currentVelocity; // Reverse direction\n        }\n\n        // 5. Set random hue color\n        if (_spriteRenderer != null)\n        {\n            float hue = Random.value; // Random hue between 0 and 1\n            _spriteRenderer.color = Color.HSVToRGB(hue, 1f, 1f);\n        }\n\n        // 6. Scale to 0.5x size\n        if (_player != null)\n        {\n            _player.localScale *= 0.5f;\n        }\n\n        // 7. Teleport to random location within range of 50 units\n        if (_player != null)\n        {\n            Vector3 randomOffset = Random.insideUnitSphere * 50f;\n            _player.position += randomOffset;\n        }\n\n        // 8. Create exit distortion effect\n        if (distortionEffect != null && _player != null)\n        {\n            Instantiate(distortionEffect, _player.position, Quaternion.identity);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "PortalBehavior",
      "components": [
        "AudioSource",
        "SpriteRenderer",
        "Animator"
      ],
      "fields": [
        {
          "name": "whooshSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "distortionEffect",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on_enter_portal",
          "trigger": "player enters collision area",
          "actions": [
            {
              "action": "play whoosh sound",
              "temporal": "event"
            },
            {
              "action": "create entry distortion effect",
              "target": "distortionEffect",
              "temporal": "event"
            },
            {
              "action": "rotate player 180 degrees",
              "temporal": "event"
            },
            {
              "action": "reverse player velocity vector",
              "temporal": "event"
            },
            {
              "action": "set random hue color",
              "temporal": "event"
            },
            {
              "action": "scale to 0.5x size",
              "factor": 0.5,
              "temporal": "event"
            },
            {
              "action": "teleport to random location",
              "range": 50,
              "temporal": "event"
            },
            {
              "action": "create exit distortion effect",
              "target": "distortionEffect",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive implementation of all specified portal behaviors",
        "Safe null checking for components and references",
        "Modular approach with separate ExecutePortalEnterEffects method",
        "Proper use of Unity lifecycle methods (Start, OnTriggerEnter)",
        "Correct use of SerializeField for inspector-configurable properties"
      ],
      "weaknesses": [
        "No error handling for missing Rigidbody component",
        "Assumes single player object with 'Player' tag",
        "No option to configure portal effect intensity or randomness",
        "Potential performance overhead with multiple Instantiate calls"
      ],
      "suggestions": [
        "Add error logging for missing components",
        "Create configurable parameters for portal effect intensity",
        "Consider object pooling for distortion effect instantiation",
        "Add optional configuration for teleport range and scaling",
        "Implement optional cooldown or transition between portal uses"
      ]
    },
    "grade_time": 10.773602724075317,
    "error": null
  },
  {
    "prompt": "16. \"Create a mimic chest: it looks like a normal chest until you get within 3 units, then it opens its lid (rotates 90 degrees), plays a creak sound, and reveals glowing eyes. If you touch it, it snaps shut (plays slam sound), applies a strong force pushing you away, changes to a dark material, and spawns 3 smaller mimic objects that chase you while playing menacing sounds.\"",
    "success": true,
    "generation_time": 98.28120756149292,
    "rag_docs_used": 17,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class MimicChest : MonoBehaviour\n{\n    [SerializeField] private float triggerDistance = 3.0f;\n    [SerializeField] private AudioClip openSound = null;\n    [SerializeField] private AudioClip closeSound = null;\n    [SerializeField] private GameObject revealEffect = null;\n\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private State _currentState = State.Idle;\n    private State _previousState;\n\n    private enum State\n    {\n        Idle,\n        Revealing,\n        Guarded,\n        Activated,\n        Disabled\n    }\n\n    private void Start()\n    {\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n\n        // Find player using tag, cache for efficiency\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n\n    private void Update()\n    {\n        State nextState = DetermineNextState();\n\n        // Detect state changes to prevent re-triggering EVENT actions\n        if (nextState != _currentState)\n        {\n            ExitState(_currentState);\n            _previousState = _currentState;\n            _currentState = nextState;\n            EnterState(_currentState);  // Execute EVENT actions ONCE per transition\n        }\n\n        UpdateState(_currentState);  // Execute CONTINUOUS actions EVERY FRAME while in state\n    }\n\n    private State DetermineNextState()\n    {\n        switch (_currentState)\n        {\n            case State.Idle:\n                if (IsPlayerNear())\n                {\n                    return State.Revealing;\n                }\n                break;\n\n            case State.Revealing:\n                // Wait for animation to complete - using a simple heuristic\n                if (_animator.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1.0f)\n                {\n                    return State.Guarded;\n                }\n                break;\n\n            case State.Guarded:\n                if (IsPlayerTouchingChest())\n                {\n                    return State.Activated;\n                }\n                break;\n\n            // Activated and Disabled states don't transition in this simple implementation\n        }\n\n        return _currentState;  // Stay in current state until conditions met\n    }\n\n    private void EnterState(State newState)\n    {\n        switch (newState)\n        {\n            case State.Idle:\n                // Set animation speed to 0 when idle\n                if (_animator != null)\n                {\n                    _animator.speed = 0;\n                }\n                break;\n\n            case State.Revealing:\n                // EVENT actions: Execute ONCE per transition\n                if (openSound != null && _audioSource != null)\n                {\n                    _audioSource.PlayOneShot(openSound);\n                }\n\n                if (_animator != null)\n                {\n                    _animator.SetTrigger(\"OpenLid\");\n                }\n\n                if (revealEffect != null)\n                {\n                    Instantiate(revealEffect, transform.position, Quaternion.identity);\n                }\n                break;\n\n            case State.Guarded:\n                // EVENT actions: Execute ONCE per transition\n                // No immediate actions required for this state change\n\n                // CONTINUOUS actions: Start playing menacing sound\n                if (_audioSource != null)\n                {\n                    _audioSource.clip = Resources.Load<AudioClip>(\"Sounds/MenacingSound\");  // TODO: Replace with actual resource path\n                    _audioSource.loop = true;\n                    _audioSource.Play();\n                }\n                break;\n\n            case State.Activated:\n                // EVENT actions: Execute ONCE per transition\n                if (closeSound != null && _audioSource != null)\n                {\n                    _audioSource.PlayOneShot(closeSound);\n                }\n\n                if (_animator != null)\n                {\n                    _animator.SetTrigger(\"CloseLid\");\n                }\n\n                ApplyForceAwayFromPlayer();\n\n                // TODO: Change material to dark - need reference to Renderer component\n                // Find renderer component and change material\n                Renderer[] renderers = GetComponentsInChildren<Renderer>();\n                foreach (var r in renderers)\n                {\n                    Material newMaterial = Resources.Load<Material>(\"Materials/DarkMaterial\");  // TODO: Replace with actual resource path\n                    if (newMaterial != null)\n                    {\n                        r.material = newMaterial;\n                    }\n                }\n\n                // Spawn minions - spawn at player position as specified\n                if (_player != null)\n                {\n                    for (int i = 0; i < 3; i++)\n                    {\n                        GameObject minionPrefab = Resources.Load<GameObject>(\"Prefabs/MiniMimic\");  // TODO: Replace with actual resource path\n                        if (minionPrefab != null)\n                        {\n                            Instantiate(minionPrefab, _player.position + Random.insideUnitSphere * 2.0f, Quaternion.identity);\n                        }\n                    }\n                }\n                break;\n\n            case State.Disabled:\n                // EVENT actions: Execute ONCE per transition\n                if (_audioSource != null)\n                {\n                    _audioSource.Stop();\n                }\n\n                if (_animator != null)\n                {\n                    _animator.speed = 0;\n                }\n                break;\n        }\n    }\n\n    private void UpdateState(State currentState)\n    {\n        switch (currentState)\n        {\n            case State.Guarded:\n                // CONTINUOUS actions: Play menacing sound continuously\n                if (_audioSource != null && _audioSource.clip != null && !_audioSource.isPlaying)\n                {\n                    _audioSource.Play();\n                }\n                break;\n        }\n    }\n\n    private void ExitState(State oldState)\n    {\n        // Stop any looping audio when exiting a state\n        switch (oldState)\n        {\n            case State.Guarded:\n                if (_audioSource != null && _audioSource.isPlaying)\n                {\n                    _audioSource.Stop();\n                }\n                break;\n        }\n    }\n\n    private bool IsPlayerNear()\n    {\n        return _player != null && Vector3.Distance(transform.position, _player.position) < triggerDistance;\n    }\n\n    private bool IsPlayerTouchingChest()\n    {\n        // Simple collision check - in Unity, this would be handled by a separate collider\n        // This is a placeholder for the actual collision detection\n        return false;  // TODO: Implement proper collision detection between player and chest\n    }\n\n    private void ApplyForceAwayFromPlayer()\n    {\n        if (_player != null && _audioSource != null)\n        {\n            Vector3 direction = (transform.position - _player.position).normalized;\n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                // Apply force away from player with a strength of 50.0\n                rb.AddForce(direction * 50.0f, ForceMode.Impulse);\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize trigger distance in editor\n        if (_player != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, triggerDistance);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "MimicChest",
      "components": [
        "Animator",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "triggerDistance",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "openSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "closeSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "revealEffect",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "detect_player",
          "trigger": "player enters trigger zone",
          "actions": [
            {
              "action": "play audio clip",
              "target": "openSound",
              "temporal": "event"
            },
            {
              "action": "set animation trigger",
              "trigger": "OpenLid",
              "temporal": "event"
            },
            {
              "action": "spawn particle effect",
              "effect": "revealEffect",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "on_player_touch",
          "trigger": "player enters chest collider",
          "actions": [
            {
              "action": "play audio clip",
              "target": "closeSound",
              "temporal": "event"
            },
            {
              "action": "set animation trigger",
              "trigger": "CloseLid",
              "temporal": "event"
            },
            {
              "action": "apply force away from player",
              "strength": 50.0,
              "temporal": "event"
            },
            {
              "action": "change material to dark",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "spawn_minions",
          "trigger": "player touches chest",
          "actions": [
            {
              "action": "spawn prefab",
              "count": 3,
              "prefab": "MiniMimic",
              "target": "player.position",
              "temporal": "event"
            },
            {
              "action": "play audio clip",
              "target": "menacingSound",
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": true,
        "initial_state": "idle",
        "states": [
          {
            "name": "idle",
            "actions": [
              {
                "action": "check player distance",
                "temporal": "conditional"
              },
              {
                "action": "set animation speed to 0",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "revealing",
                "condition": "player distance < triggerDistance"
              }
            ]
          },
          {
            "name": "revealing",
            "actions": [
              {
                "action": "play audio clip",
                "target": "openSound",
                "temporal": "event"
              },
              {
                "action": "set animation trigger",
                "trigger": "OpenLid",
                "temporal": "event"
              },
              {
                "action": "spawn particle effect",
                "effect": "revealEffect",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "guarded",
                "condition": "animation complete"
              }
            ]
          },
          {
            "name": "guarded",
            "actions": [
              {
                "action": "check player proximity",
                "temporal": "conditional"
              },
              {
                "action": "play menacing sound",
                "target": "menacingSound",
                "temporal": "continuous"
              }
            ],
            "transitions": [
              {
                "to": "activated",
                "condition": "player touches chest collider"
              }
            ]
          },
          {
            "name": "activated",
            "actions": [
              {
                "action": "play audio clip",
                "target": "closeSound",
                "temporal": "event"
              },
              {
                "action": "set animation trigger",
                "trigger": "CloseLid",
                "temporal": "event"
              },
              {
                "action": "apply force away from player",
                "strength": 50.0,
                "temporal": "event"
              },
              {
                "action": "change material to dark",
                "temporal": "event"
              },
              {
                "action": "spawn prefab",
                "count": 3,
                "prefab": "MiniMimic",
                "target": "player.position",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "disabled",
                "condition": "minions destroyed"
              }
            ]
          },
          {
            "name": "disabled",
            "actions": [
              {
                "action": "stop audio",
                "target": "menacingSound",
                "temporal": "event"
              },
              {
                "action": "set animation speed to 0",
                "temporal": "event"
              }
            ],
            "transitions": []
          }
        ]
      }
    },
    "grade": {
      "overall_score": 6.5,
      "correctness": 7,
      "code_quality": 6,
      "completeness": 6,
      "unity_best_practices": 7,
      "strengths": [
        "Well-structured state machine approach",
        "Careful state transition handling",
        "Use of SerializeField for inspector configurability",
        "Efficient player reference caching",
        "Modular state management method"
      ],
      "weaknesses": [
        "Incomplete implementation (code cuts off mid-method)",
        "Missing full physics interaction details",
        "No explicit implementation of force application",
        "Incomplete minion spawning logic",
        "Lacks material change mechanism"
      ],
      "suggestions": [
        "Complete the Activated state implementation",
        "Add explicit physics force application method",
        "Implement material change via Renderer component",
        "Add error handling for missing components",
        "Create a separate method for spawning minion prefabs",
        "Add comments explaining state machine logic",
        "Implement IPoolable interface for performance optimization"
      ]
    },
    "grade_time": 14.62239956855774,
    "error": null
  },
  {
    "prompt": "17. \"Build a weather controller: when activated, it spawns rain particles that fall downward, plays rain sound effects, makes all objects in the scene slightly dampen (reduce bounce), changes ambient lighting to be darker, and after 10 seconds of rain, spawns lightning bolts (bright flashes) that play thunder sounds and briefly illuminate everything.\"",
    "success": true,
    "generation_time": 46.352723121643066,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class WeatherController : MonoBehaviour\n{\n    [SerializeField] private float rainIntensity = 1.0f;\n    [SerializeField] private int lightningInterval = 10;\n    [SerializeField] private float thunderChance = 0.7f;\n    [SerializeField] private float ambientDarkeningAmount = 0.6f;\n\n    private ParticleSystem _rainParticles;\n    private AudioSource _rainSoundSource;\n    private AudioSource _thunderSoundSource;\n    private Light _ambientLight;\n    private bool _isWeatherActive = false;\n    private float _lastLightningTime = 0f;\n    private const float LightningCooldown = 10f;\n\n    void Start()\n    {\n        // Get components\n        _rainParticles = GetComponentInChildren<ParticleSystem>();\n        _rainSoundSource = GetComponent<AudioSource>();\n\n        if (_rainParticles == null || _rainSoundSource == null)\n        {\n            Debug.LogError(\"WeatherController requires ParticleSystem and AudioSource components\");\n            return;\n        }\n\n        // Find ambient light (assuming it's tagged \"AmbientLight\")\n        GameObject lightObj = GameObject.FindGameObjectWithTag(\"AmbientLight\");\n        if (lightObj != null)\n        {\n            _ambientLight = lightObj.GetComponent<Light>();\n        }\n    }\n\n    void Update()\n    {\n        if (!_isWeatherActive) return;\n\n        // EVENT actions - spawn rain particles and play sound\n        if (_rainParticles != null && !_rainParticles.isEmitting)\n        {\n            _rainParticles.Play();\n        }\n\n        if (_rainSoundSource != null && !_rainSoundSource.isPlaying)\n        {\n            _rainSoundSource.PlayOneShot(_rainSoundSource.clip);\n        }\n\n        // CONTINUOUS actions - reduce gravity scale and fade ambient lighting\n        Physics2D.gravity *= 0.7f;\n\n        if (_ambientLight != null)\n        {\n            _ambientLight.intensity = Mathf.Lerp(1f, ambientDarkeningAmount, Time.time * rainIntensity);\n        }\n\n        // Check for lightning interval\n        if (Time.time - _lastLightningTime >= LightningCooldown)\n        {\n            SpawnLightning();\n            PlayThunder();\n            _lastLightningTime = Time.time;\n        }\n    }\n\n    private void SpawnLightning()\n    {\n        // TODO: Implement lightning bolt spawning logic\n        Debug.Log(\"Spawning 3 lightning bolts\");\n        // Example: Instantiate lightning prefabs at random positions\n        for (int i = 0; i < 3; i++)\n        {\n            Vector3 randomPosition = new Vector3(Random.Range(-10f, 10f), Random.Range(-5f, 5f), 0f);\n            GameObject lightningBolt = Instantiate(Resources.Load(\"LightningPrefab\"), randomPosition, Quaternion.identity) as GameObject;\n            Destroy(lightningBolt, 2f); // Destroy after 2 seconds\n        }\n    }\n\n    private void PlayThunder()\n    {\n        if (_thunderSoundSource != null && Random.value < thunderChance)\n        {\n            _thunderSoundSource.PlayOneShot(_thunderSoundSource.clip);\n        }\n    }\n\n    public void ActivateWeather()\n    {\n        _isWeatherActive = true;\n    }\n\n    public void DeactivateWeather()\n    {\n        _isWeatherActive = false;\n\n        if (_rainParticles != null)\n        {\n            _rainParticles.Stop();\n        }\n\n        if (_rainSoundSource != null)\n        {\n            _rainSoundSource.Stop();\n        }\n    }\n}",
    "ir_json": {
      "class_name": "WeatherController",
      "components": [
        "ParticleSystem",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "rainIntensity",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "lightningInterval",
          "type": "int",
          "default": 10
        },
        {
          "name": "thunderChance",
          "type": "float",
          "default": 0.7
        },
        {
          "name": "ambientDarkeningAmount",
          "type": "float",
          "default": 0.6
        }
      ],
      "behaviors": [
        {
          "name": "activate_weather",
          "trigger": "when activated by script or input",
          "actions": [
            {
              "action": "spawn rain particles",
              "temporal": "event"
            },
            {
              "action": "play rain sound effect",
              "looped": true,
              "target": "rainSound",
              "temporal": "event"
            },
            {
              "action": "reduce gravity scale on all physics objects",
              "factor": 0.7,
              "duration": 10,
              "temporal": "continuous"
            },
            {
              "action": "fade ambient lighting",
              "darkness": "ambientDarkeningAmount",
              "temporal": "continuous"
            },
            {
              "action": "wait 10 seconds",
              "then": [
                {
                  "action": "spawn lightning bolts",
                  "count": 3,
                  "temporal": "event"
                },
                {
                  "action": "play thunder sound effect",
                  "target": "thunderSound",
                  "temporal": "event"
                }
              ]
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive weather control implementation",
        "Good use of Unity component references",
        "Modular approach with ActivateWeather/DeactivateWeather methods",
        "Safe null checks for components",
        "Use of SerializeField for inspector configuration"
      ],
      "weaknesses": [
        "Lightning spawning is placeholder (TODO)",
        "Physics gravity modification is global, not object-specific",
        "No gradual object dampening implementation",
        "Ambient light intensity change is simplistic"
      ],
      "suggestions": [
        "Implement proper lightning bolt visual effects",
        "Create a method to reduce bounce/physics for specific objects",
        "Add more sophisticated ambient lighting transition",
        "Consider using a coroutine for time-based weather effects",
        "Add error handling for missing audio/particle system resources"
      ]
    },
    "grade_time": 11.092639446258545,
    "error": null
  },
  {
    "prompt": "18. \"Create a gravity field that inverts gravity for all objects within its radius, plays a space-warp sound, creates a visual distortion shader effect, and gradually rotates the entire affected area. Objects that enter the field should smoothly transition their gravity direction over 1 second, and when they exit, they should transition back to normal gravity over 1 second.\"",
    "success": true,
    "generation_time": 41.940884828567505,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class GravityInverter : MonoBehaviour\n{\n    [SerializeField] private float radius = 10.0f;\n    [SerializeField] private float transitionTime = 1.0f;\n    [SerializeField] private AudioClip warpSound = null;\n    [SerializeField] private GameObject visualEffectPrefab = null;\n\n    private SphereCollider _collider;\n    private AudioSource _audioSource;\n\n    // State tracking for conditional actions\n    private bool _wasInRange = false;\n\n    void Start()\n    {\n        // Get required components\n        _collider = GetComponent<SphereCollider>();\n        if (_collider == null)\n        {\n            Debug.LogError(\"GravityInverter requires a SphereCollider component\");\n            return;\n        }\n\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            Debug.LogError(\"GravityInverter requires an AudioSource component\");\n            return;\n        }\n\n        // Set collider radius from field\n        _collider.radius = radius;\n\n        // Cache player reference for later use (if needed)\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            Debug.Log(\"Player found: \" + playerObj.name);\n        }\n    }\n\n    void Update()\n    {\n        // Check if any object is within the gravity field\n        bool inRange = Physics.CheckSphere(\n            transform.position,\n            radius,\n            LayerMask.GetMask(\"Default\"),  // Adjust layer mask as needed\n            QueryTriggerInteraction.Collide);\n\n        // Detect condition change (temporal: \"conditional\")\n        if (inRange && !_wasInRange)\n        {\n            OnEnterGravityField();\n        }\n        else if (!inRange && _wasInRange)\n        {\n            OnExitGravityField();\n        }\n\n        _wasInRange = inRange;\n\n        // Update rotation effect continuously\n        UpdateRotationEffect(inRange);\n    }\n\n    private void OnEnterGravityField()\n    {\n        // EVENT actions - execute once when entering gravity field\n\n        // Play warp sound (EVENT action)\n        if (_audioSource != null && warpSound != null)\n        {\n            _audioSource.PlayOneShot(warpSound);  // \u2713 Once per trigger\n        }\n\n        // Spawn visual effect prefab (EVENT action)\n        if (visualEffectPrefab != null)\n        {\n            Instantiate(\n                visualEffectPrefab,\n                transform.position,\n                Quaternion.identity);\n        }\n    }\n\n    private void OnExitGravityField()\n    {\n        // EVENT actions - execute once when exiting gravity field\n        Debug.Log(\"Exited gravity field\");\n    }\n\n    private void UpdateRotationEffect(bool inRange)\n    {\n        if (inRange)\n        {\n            // CONTINUOUS action - rotate object while in gravity field\n            transform.Rotate(Vector3.up * 45.0f * Time.deltaTime);\n        }\n    }\n\n    // For completeness, also handle collision events directly\n    private void OnTriggerEnter(Collider other)\n    {\n        Debug.Log(\"Trigger entered by: \" + other.name);\n        // This can be used for additional trigger-specific logic if needed\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        Debug.Log(\"Trigger exited by: \" + other.name);\n    }\n}",
    "ir_json": {
      "class_name": "GravityInverter",
      "components": [
        "SphereCollider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "radius",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "transitionTime",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "warpSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "visualEffectPrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on trigger enter",
          "trigger": "when collider enters gravity field",
          "actions": [
            {
              "action": "play audio clip",
              "target": "warpSound",
              "temporal": "event"
            },
            {
              "action": "spawn visual effect prefab",
              "position": "object position",
              "temporal": "event"
            },
            {
              "action": "start rotation effect",
              "speed": 45,
              "axis": "upward vector",
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Comprehensive implementation of gravity field detection",
        "Proper use of Unity components",
        "Event-based trigger handling",
        "Safe component retrieval with error logging",
        "Flexible serialized fields for configuration"
      ],
      "weaknesses": [
        "Missing gravity inversion logic for affected objects",
        "No smooth transition of gravity direction",
        "Lacks detailed visual distortion shader effect",
        "Limited object interaction handling"
      ],
      "suggestions": [
        "Implement a gravity direction transition method using Coroutine or Lerp",
        "Add a shader-based visual distortion effect",
        "Create a more robust object tracking mechanism",
        "Implement physics-based gravity redirection for affected objects",
        "Add configuration for rotation speed and direction"
      ]
    },
    "grade_time": 12.315561532974243,
    "error": null
  },
  {
    "prompt": "19. \"Make a script that watches itself: it counts how many times its Update method has been called, and every 1000 calls, it plays a different sound, changes its own material, and spawns a clone of itself. The clone also has this same behavior, but starts its counter at 0. Each generation of clones plays a slightly higher-pitched sound than its parent.\"",
    "success": true,
    "generation_time": 46.34843730926514,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class SelfObservingObject : MonoBehaviour\n{\n    [SerializeField] private int updateCount = 0;\n    [SerializeField] private AudioClip[] sounds = null;\n    [SerializeField] private Material materialToChange = null;\n    [SerializeField] private GameObject clonePrefab = null;\n\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private bool _wasMultipleOf1000 = false;\n\n    private void Start()\n    {\n        // Get required components\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n\n        // Validate required components\n        if (_audioSource == null)\n            Debug.LogError(\"AudioSource component is missing!\");\n        if (_renderer == null)\n            Debug.LogError(\"Renderer component is missing!\");\n    }\n\n    private void Update()\n    {\n        // EVENT action: Increment update counter (temporal: \"event\")\n        updateCount++;\n\n        // CONDITIONAL action: Check if multiple of 1000\n        bool isMultipleOf1000 = updateCount % 1000 == 0 && updateCount > 0;\n        \n        // Detect condition change to prevent re-triggering\n        if (isMultipleOf1000 && !_wasMultipleOf1000)\n        {\n            _wasMultipleOf1000 = true;\n            \n            // EVENT actions: Execute once when condition is met\n            int index = (updateCount / 1000) - 1;\n            if (index < sounds.Length && sounds[index] != null)\n            {\n                _audioSource.PlayOneShot(sounds[index]);\n            }\n            \n            // Modify clone sound pitch for next generation\n            // This requires tracking state between generations, which would need a more complex system\n            // TODO: Implement proper pitch modification logic\n            \n            if (materialToChange != null)\n            {\n                _renderer.material = materialToChange;\n            }\n\n            if (clonePrefab != null)\n            {\n                Vector3 position = transform.position + new Vector3(0f, 2f, 0f);\n                Instantiate(clonePrefab, position, Quaternion.identity);\n            }\n        }\n    }\n}",
    "ir_json": {
      "class_name": "SelfObservingObject",
      "components": [
        "AudioSource",
        "Renderer"
      ],
      "fields": [
        {
          "name": "updateCount",
          "type": "int",
          "default": 0
        },
        {
          "name": "sounds",
          "type": "AudioClip[]",
          "default": null
        },
        {
          "name": "materialToChange",
          "type": "Material",
          "default": null
        },
        {
          "name": "clonePrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "self_observing_behavior",
          "trigger": "every frame (Update())",
          "actions": [
            {
              "action": "increment update counter",
              "temporal": "event",
              "description": "increase the updateCount by one"
            },
            {
              "action": "check if multiple of 1000",
              "temporal": "conditional",
              "condition": "updateCount is divisible by 1000 and greater than zero",
              "then_actions": [
                {
                  "action": "play sound",
                  "target": "sounds array at index (updateCount divided by 1000 minus one)",
                  "temporal": "event"
                },
                {
                  "action": "modify clone sound pitch",
                  "amount": 0.01,
                  "description": "increase the pitch of the next generation's sound by 1%"
                },
                {
                  "action": "change material",
                  "target": "materialToChange",
                  "temporal": "event"
                },
                {
                  "action": "spawn clone",
                  "position": "current transform position plus two units up in the vertical direction",
                  "rotation": "no rotation (identity)",
                  "prefab": "clonePrefab"
                }
              ]
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Correctly implements update count tracking",
        "Proper component retrieval in Start method",
        "Prevents repeated triggering of 1000-count event",
        "Uses SerializeField for inspector-configurable variables",
        "Includes error logging for missing components"
      ],
      "weaknesses": [
        "Pitch modification for clones is not implemented",
        "No explicit handling of sound array length limitations",
        "Lacks flexibility in clone spawning mechanism"
      ],
      "suggestions": [
        "Implement a generation tracking mechanism to manage sound pitch",
        "Add more robust error checking for sounds and clone prefab",
        "Consider making clone spawning more configurable",
        "Add a method to reset update count for each clone to ensure consistent behavior"
      ]
    },
    "grade_time": 13.424685955047607,
    "error": null
  },
  {
    "prompt": "20. \"Create a self-modifying object: it starts with basic properties, but every time it collides with something, it increases its own mass by 10%, plays a growth sound, scales up by 5%, and adds a new random color tint to its material. After 10 collisions, it splits into two identical objects, each with half the accumulated properties, and both continue the same behavior.\"",
    "success": true,
    "generation_time": 54.385903120040894,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class SelfModifyingObject : MonoBehaviour\n{\n    [SerializeField] private float initialMass = 1.0f;\n    [SerializeField] private AudioClip growthSound = null;\n    [SerializeField] private int collisionCount = 0;\n    [SerializeField] private Vector3 baseScale = new Vector3(1, 1, 1);\n    [SerializeField] private GameObject splitPrefab = null;\n\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private const int COLLISION_THRESHOLD = 10;\n\n    private void Start()\n    {\n        // Get required components\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            Debug.LogError(\"SelfModifyingObject: Rigidbody component not found!\");\n\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            Debug.LogError(\"SelfModifyingObject: AudioSource component not found!\");\n\n        // Initialize mass\n        _rigidbody.mass = initialMass;\n\n        // Cache base scale for future scaling operations\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // EVENT actions - execute once per trigger\n        if (collisionCount >= COLLISION_THRESHOLD && splitPrefab != null)\n        {\n            TriggerSplitBehavior();\n        }\n        \n        collisionCount++;\n        _audioSource.PlayOneShot(growthSound);\n        \n        float massIncrease = _rigidbody.mass * 0.1f;\n        _rigidbody.mass += massIncrease;\n        \n        transform.localScale = baseScale * 1.05f;\n        \n        ApplyRandomColorTint();\n    }\n\n    private void TriggerSplitBehavior()\n    {\n        // EVENT actions - execute once when condition is met\n        if (splitPrefab != null)\n        {\n            GameObject child1 = Instantiate(splitPrefab, transform.position + Vector3.right * 0.5f, transform.rotation);\n            GameObject child2 = Instantiate(splitPrefab, transform.position + Vector3.left * 0.5f, transform.rotation);\n\n            Rigidbody childRb1 = child1.GetComponent<Rigidbody>();\n            Rigidbody childRb2 = child2.GetComponent<Rigidbody>();\n\n            if (childRb1 != null && childRb2 != null)\n            {\n                float halfMass = _rigidbody.mass / 2;\n                childRb1.mass = halfMass;\n                childRb2.mass = halfMass;\n\n                SelfModifyingObject[] childrenScripts = child1.GetComponentsInChildren<SelfModifyingObject>();\n                foreach (var script in childrenScripts)\n                {\n                    script.collisionCount = 0; // Reset collision counter\n                    script.baseScale = transform.localScale / 2;\n                }\n            }\n\n            Destroy(gameObject); // Remove original object after splitting\n        }\n    }\n\n    private void ApplyRandomColorTint()\n    {\n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            Color randomColor = new Color(\n                Random.Range(0.5f, 1.0f),\n                Random.Range(0.5f, 1.0f),\n                Random.Range(0.5f, 1.0f)\n            );\n            \n            renderer.material.color *= randomColor;\n        }\n    }\n}",
    "ir_json": {
      "class_name": "SelfModifyingObject",
      "components": [
        "Rigidbody",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "initialMass",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "growthSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "collisionCount",
          "type": "int",
          "default": 0
        },
        {
          "name": "baseScale",
          "type": "Vector3",
          "default": [
            1,
            1,
            1
          ]
        },
        {
          "name": "splitPrefab",
          "type": "GameObject",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "on_collision",
          "trigger": "collision with any object",
          "actions": [
            {
              "action": "increment collision count by one"
            },
            {
              "action": "play growth sound from AudioSource component using AudioClip stored in growthSound field"
            },
            {
              "action": "increase Rigidbody mass by 10% of its current value"
            },
            {
              "action": "scale object up by 5% relative to baseScale field values"
            },
            {
              "action": "apply random RGB color tint to material component"
            },
            {
              "action": "check if collision count exceeds threshold of ten, trigger split behavior if true"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      },
      "split_behavior": {
        "trigger": "collision count reaches ten",
        "actions": [
          {
            "action": "instantiate two child objects from prefab stored in splitPrefab field"
          },
          {
            "action": "divide Rigidbody mass and transform scale equally between the two instantiated children"
          },
          {
            "action": "reset collision counter to zero on both resulting objects"
          }
        ]
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive implementation of self-modifying object behavior",
        "Proper component retrieval and error handling",
        "Detailed split behavior with mass and scale distribution",
        "Random color tinting implementation",
        "Safe null checks and component validation"
      ],
      "weaknesses": [
        "Color tinting multiplies existing color instead of purely replacing",
        "No fallback for missing audio or split prefab",
        "Potential performance concern with repeated material color modifications"
      ],
      "suggestions": [
        "Add a default audio clip or null check before playing growth sound",
        "Consider using MaterialPropertyBlock for more efficient color tinting",
        "Add error handling for missing split prefab",
        "Implement optional max size or mass limit to prevent unbounded growth",
        "Consider adding a configuration scriptable object for easy tuning of growth parameters"
      ]
    },
    "grade_time": 10.199799537658691,
    "error": null
  },
  {
    "prompt": "21. \"Build a script that only works during specific conditions: it checks if the current time of day (using System.DateTime) is between 2 AM and 4 AM. If true, it makes the object glow, play spooky sounds, and move erratically. If false, it does nothing. The object should also check if there are exactly 7 other objects with Rigidbody components in the scene, and only then activate its full behavior.\"",
    "success": true,
    "generation_time": 46.39250135421753,
    "rag_docs_used": 12,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class NightmareObject : MonoBehaviour\n{\n    [SerializeField] private Material glowMaterial = null;\n    [SerializeField] private AudioClip spookySound = null;\n    [SerializeField] private float movementSpeed = 10.0f;\n\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private int _rigidbodyCount;\n    private System.DateTime _currentHour;\n    private bool _isNightmareActive = false;\n    private Vector3 _randomDirection;\n    private float _timer = 0f;\n\n    void Start()\n    {\n        // Get components\n        _animator = GetComponent<Animator>();\n        if (_animator == null)\n        {\n            Debug.LogError(\"Animator component not found\");\n        }\n\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            Debug.LogError(\"AudioSource component not found\");\n        }\n\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody != null)\n        {\n            // Ensure rigidbody is active\n            _rigidbody.WakeUp();\n        }\n        else\n        {\n            Debug.LogWarning(\"Rigidbody component not found, using transform for movement\");\n        }\n\n        // Count rigidbodies in scene\n        _rigidbodyCount = FindObjectsOfType<Rigidbody>().Length;\n\n        // Get current hour\n        _currentHour = System.DateTime.Now;\n    }\n\n    void Update()\n    {\n        // Check conditions only once per frame to avoid multiple triggers\n        if (CheckConditions())\n        {\n            ActivateNightmare();\n        }\n\n        // If nightmare is active, update behavior\n        if (_isNightmareActive)\n        {\n            // Apply glow material - continuous action\n            if (glowMaterial != null && _animator != null)\n            {\n                _animator.speed = 1.0f; // Ensure animation plays at normal speed\n                // This is a placeholder for actual material application\n                // In practice, you would apply the material to a renderer component\n            }\n\n            // Move erratically - continuous action with frame-rate independence\n            if (_rigidbody != null)\n            {\n                _timer += Time.deltaTime;\n                if (_timer >= 1.0f) // Change direction every second\n                {\n                    _randomDirection = new Vector3(\n                        Random.Range(-1f, 1f),\n                        Random.Range(-1f, 1f),\n                        Random.Range(-1f, 1f)\n                    ).normalized;\n                    _timer = 0f;\n                }\n\n                // Apply force in random direction\n                _rigidbody.AddForce(_randomDirection * movementSpeed * Time.deltaTime, ForceMode.Force);\n            }\n        }\n    }\n\n    private bool CheckConditions()\n    {\n        // This is an EVENT action - execute ONCE per frame\n        // Count rigidbodies and get current hour\n        int currentRigidbodyCount = FindObjectsOfType<Rigidbody>().Length;\n        System.DateTime currentHour = System.DateTime.Now;\n\n        // Check if conditions are met: count = 7 and (hour >= 2 AND hour <= 4)\n        return currentRigidbodyCount == 7 &&\n               currentHour.Hour >= 2 && currentHour.Hour <= 4;\n    }\n\n    private void ActivateNightmare()\n    {\n        if (!_isNightmareActive)\n        {\n            // This is an EVENT action - execute ONCE when conditions are met\n            _isNightmareActive = true;\n\n            // Play spooky sound repeatedly (in a loop)\n            if (_audioSource != null && spookySound != null)\n            {\n                _audioSource.clip = spookySound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n    }\n\n    private void OnDisable()\n    {\n        // Clean up when object is disabled\n        if (_rigidbody != null)\n        {\n            _rigidbody.Sleep();\n        }\n    }\n}",
    "ir_json": {
      "class_name": "NightmareObject",
      "components": [
        "Animator",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "glowMaterial",
          "type": "Material",
          "default": null
        },
        {
          "name": "spookySound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "movementSpeed",
          "type": "float",
          "default": 10.0
        }
      ],
      "behaviors": [
        {
          "name": "check_conditions",
          "trigger": "on awake and update",
          "actions": [
            {
              "action": "count rigidbodies in scene",
              "temporal": "event"
            },
            {
              "action": "get current hour",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "nightmare_activation",
          "trigger": "when conditions met: count = 7 and (hour >= 2 AND hour <= 4)",
          "actions": [
            {
              "action": "apply glow material",
              "target": "glowMaterial",
              "temporal": "continuous"
            },
            {
              "action": "play spooky sound repeatedly",
              "clip": "spookySound",
              "temporal": "event"
            },
            {
              "action": "move erratically in random directions",
              "speed": 10,
              "temporal": "continuous"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 8.5,
      "correctness": 9,
      "code_quality": 8,
      "completeness": 8,
      "unity_best_practices": 9,
      "strengths": [
        "Comprehensive condition checking",
        "Robust component validation",
        "Frame-rate independent movement",
        "Safe null checks",
        "Detailed error logging"
      ],
      "weaknesses": [
        "Material application is a placeholder",
        "Performance overhead from FindObjectsOfType() every frame",
        "No explicit handling of edge cases for missing components"
      ],
      "suggestions": [
        "Cache Rigidbody count instead of calling FindObjectsOfType() every update",
        "Implement actual material glow effect (e.g., using shader or emission)",
        "Add configurable randomness parameters for erratic movement",
        "Consider using Object.FindObjectsOfType<Rigidbody>() sparingly or cache results",
        "Add optional debug logging for condition checks"
      ]
    },
    "grade_time": 9.548810005187988,
    "error": null
  },
  {
    "prompt": "22. \"Create a quantum object that exists in two states simultaneously: when observed (player is looking at it, detected via raycast), it collapses to one state (visible, plays observation sound). When not observed, it exists in superposition (flickers between two positions, plays quantum hum, has translucent material). The object should track whether it's currently being observed every frame.\"",
    "success": true,
    "generation_time": 46.44778847694397,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class QuantumObject : MonoBehaviour\n{\n\n    [SerializeField] private AudioClip quantumHumLoop = null;\n    [SerializeField] private Material translucentMaterial = null;\n    [SerializeField] private Material visibleMaterial = null;\n    [SerializeField] private Vector3[] superpositionPositions = new Vector3[2];\n    [SerializeField] private AudioClip observationSound;\n\n    private MeshRenderer _meshRenderer;\n    private BoxCollider _boxCollider;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private bool _isObserved = false;\n    private float _lastQuantumHumTime = 0f;\n    private const float QuantumHumCooldown = 1.5f;\n\n    void Start()\n    {\n        // Get required components\n        _meshRenderer = GetComponent<MeshRenderer>();\n        _boxCollider = GetComponent<BoxCollider>();\n        \n        // Initialize audio source if needed\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.loop = true;\n        }\n        \n        // Find player object with tag \"Player\"\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n\n    void Update()\n    {\n        // Check observation state using raycast\n        bool wasObserved = _isObserved;\n        _isObserved = IsObjectBeingLookedAt();\n        \n        // Detect state change\n        if (_isObserved && !wasObserved)\n        {\n            OnEnterObservationState();\n        }\n        else if (!wasObserved && _isObserved)\n        {\n            OnExitObservationState();\n        }\n\n        // Update continuous behaviors based on observation state\n        if (_isObserved)\n        {\n            // Observed state - visible and stable\n            // No flickering, just maintain current position and material\n            MaintainVisibleState();\n        }\n        else\n        {\n            // Not observed - quantum superposition behavior\n            ApplyQuantumSuperpositionEffects();\n            \n            // Play quantum hum loop with cooldown to avoid overlapping audio\n            if (_audioSource != null && \n                !_audioSource.isPlaying && \n                Time.time - _lastQuantumHumTime > QuantumHumCooldown)\n            {\n                _audioSource.clip = quantumHumLoop;\n                _audioSource.Play();\n                _lastQuantumHumTime = Time.time;\n            }\n        }\n    }\n\n    private bool IsObjectBeingLookedAt()\n    {\n        if (_player == null || _camera == null) return false;\n        \n        // Create ray from camera through object\n        Vector3 directionToTarget = transform.position - _camera.transform.position;\n        RaycastHit hit;\n        \n        // Check if raycast hits this object\n        if (Physics.Raycast(_camera.transform.position, directionToTarget, out hit))\n        {\n            return hit.collider == _boxCollider;\n        }\n        \n        return false;\n    }\n\n    private void OnEnterObservationState()\n    {\n        // Collapse to visible state when observed\n        if (_meshRenderer != null)\n        {\n            _meshRenderer.material = visibleMaterial;\n        }\n        \n        // Play observation sound once\n        if (_audioSource != null && observationSound != null)\n        {\n            _audioSource.clip = observationSound;\n            _audioSource.PlayOneShot(observationSound);\n        }\n    }\n\n    private void OnExitObservationState()\n    {\n        // Switch back to translucent material when not observed\n        if (_meshRenderer != null)\n        {\n            _meshRenderer.material = translucentMaterial;\n        }\n        \n        // Stop any looping sounds\n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n    }\n\n    private void MaintainVisibleState()\n    {\n        // When observed, maintain visible state with no flickering\n        // This is a placeholder for actual quantum collapse behavior\n        // In a real implementation, this would trigger quantum state resolution\n    }\n\n    private void ApplyQuantumSuperpositionEffects()\n    {\n        if (superpositionPositions.Length < 2 || \n            superpositionPositions[0] == null || \n            superpositionPositions[1] == null)\n        {\n            return; // Need at least two positions for flickering\n        }\n        \n        // Simple position flickering between superposition states\n        float t = Mathf.PingPong(Time.time * 2f, 1f);\n        transform.position = Vector3.Lerp(superpositionPositions[0], superpositionPositions[1], t);\n    }\n\n    private Camera _camera;\n    \n    void OnWillRenderObject()\n    {\n        // This is called when the camera is about to render this object\n        if (_player != null)\n        {\n            _camera = _player.GetComponentInChildren<Camera>();\n        }\n    }\n}",
    "ir_json": {
      "class_name": "QuantumObject",
      "components": [
        "MeshRenderer",
        "BoxCollider"
      ],
      "fields": [
        {
          "name": "superpositionPositions",
          "type": "Vector3[]",
          "default": [
            null,
            null
          ]
        },
        {
          "name": "observationSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "quantumHumLoop",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "translucentMaterial",
          "type": "Material",
          "default": null
        },
        {
          "name": "visibleMaterial",
          "type": "Material",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "toggle_observation_state",
          "trigger": "every frame check if player is looking at object via raycast",
          "actions": [
            {
              "action": "if observed: collapse to visible state, play observation sound, switch material",
              "temporal": "conditional"
            },
            {
              "action": "if not observed: flicker between superposition positions, play quantum hum loop, use translucent material",
              "temporal": "conditional"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Robust implementation of observation state tracking",
        "Comprehensive handling of audio and visual state changes",
        "Good use of raycast for observation detection",
        "Proper component initialization in Start()",
        "Careful state management between observed and unobserved states"
      ],
      "weaknesses": [
        "Incomplete implementation (code snippet cuts off)",
        "Missing implementation of quantum superposition flickering",
        "No explicit handling of _camera reference",
        "Lack of error handling for missing components",
        "No configurable flickering parameters"
      ],
      "suggestions": [
        "Complete the MaintainVisibleState() and ApplyQuantumSuperpositionEffects() methods",
        "Add null checks for all serialized fields",
        "Implement a more sophisticated quantum flickering mechanism",
        "Add configuration options for flickering frequency and amplitude",
        "Consider using a more robust player/camera detection method",
        "Add logging or debug options for tracking quantum state"
      ]
    },
    "grade_time": 13.765070676803589,
    "error": null
  },
  {
    "prompt": "23. \"Make a particle fountain that spawns 100 particles per second, each with its own physics, unique color based on spawn time, and individual audio source playing a unique pitch. Each particle should track the nearest other particle and create a visual line between them if within 2 units. After 5 seconds, all particles should simultaneously explode outward while playing a chord made of all their individual pitches combined.\"",
    "success": true,
    "generation_time": 57.539567947387695,
    "rag_docs_used": 19,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class ParticleFountain : MonoBehaviour\n{\n    [SerializeField] private float spawnRate = 1.0f;\n    [SerializeField] private float particleLifetime = 5.0f;\n    [SerializeField] private float basePitch = 220.0f;\n    [SerializeField] private float pitchRange = 440.0f;\n\n    private ParticleSystem _particleSystem;\n    private AudioSource _audioSource;\n    private float _spawnTimer;\n    private bool _hasExploded;\n    private Transform[] _particles;\n\n    void Start()\n    {\n        _particleSystem = GetComponent<ParticleSystem>();\n        _audioSource = GetComponent<AudioSource>();\n        _spawnTimer = 0f;\n        _hasExploded = false;\n        _particles = new Transform[100];\n    }\n\n    void Update()\n    {\n        if (_particleSystem == null || _audioSource == null)\n            return;\n\n        // Spawn particles every second\n        _spawnTimer += Time.deltaTime;\n        if (_spawnTimer >= spawnRate && !_hasExploded)\n        {\n            CreateParticles();\n            _spawnTimer = 0f;\n        }\n\n        TrackParticleDistances();\n\n        // Explode after 5 seconds\n        if (Time.time > particleLifetime + 5f && !_hasExploded)\n        {\n            ExplodeParticles();\n            _hasExploded = true;\n        }\n    }\n\n    private void CreateParticles()\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            // EVENT actions - create particles and assign unique color\n            var particle = new GameObject(\"Particle\").AddComponent<ParticleSystem>();\n            particle.transform.position = transform.position + Random.insideUnitSphere * 2f;\n            particle.startLifetime = particleLifetime;\n            particle.startSpeed = 5f;\n            particle.startSize = 0.5f;\n\n            // Assign unique color based on spawn time\n            float hue = (Time.time % 1) / 1;\n            Color color = Color.HSVToRGB(hue, 1, 1);\n            var main = particle.main;\n            main.startColor = color;\n\n            _particles[i] = particle.transform;\n\n            // EVENT action - create individual audio source for each particle\n            AudioSource particleAudio = particle.gameObject.AddComponent<AudioSource>();\n            float pitch = basePitch + Random.Range(0, pitchRange);\n            particleAudio.pitch = pitch / 440f; // Normalize to A4 pitch\n\n            // Play sound at particle position\n            particleAudio.PlayOneShot(_audioSource.clip); // TODO: Replace with actual audio clip\n        }\n    }\n\n    private void TrackParticleDistances()\n    {\n        float minDistance = float.MaxValue;\n        Transform closestA = null, closestB = null;\n\n        for (int i = 0; i < _particles.Length - 1; i++)\n        {\n            if (_particles[i] == null) continue;\n            for (int j = i + 1; j < _particles.Length; j++)\n            {\n                if (_particles[j] == null) continue;\n\n                float dist = Vector3.Distance(_particles[i].position, _particles[j].position);\n                if (dist < minDistance && dist <= 2f)\n                {\n                    minDistance = dist;\n                    closestA = _particles[i];\n                    closestB = _particles[j];\n                }\n            }\n        }\n\n        // CONDITIONAL action - create visual line between closest particles\n        if (closestA != null && closestB != null)\n        {\n            Debug.DrawLine(closestA.position, closestB.position, Color.red);\n        }\n    }\n\n    private void ExplodeParticles()\n    {\n        for (int i = 0; i < _particles.Length; i++)\n        {\n            if (_particles[i] == null) continue;\n\n            // EVENT action - apply explosion force to all particles\n            Rigidbody rb = _particles[i].gameObject.AddComponent<Rigidbody>();\n            rb.AddExplosionForce(100f, transform.position, 10f);\n\n            // EVENT action - combine and play chord of all particle pitches\n            if (_audioSource != null)\n            {\n                // Combine pitches into a chord (simplified implementation)\n                float[] pitches = new float[_particles.Length];\n                for (int j = 0; j < _particles.Length; j++)\n                {\n                    if (_particles[j] != null && _particles[j].GetComponent<AudioSource>() != null)\n                    {\n                        pitches[j] = _particles[j].GetComponent<AudioSource>().pitch;\n                    }\n                }\n\n                // Play combined chord sound\n                // TODO: Implement actual chord synthesis or play multiple notes in harmony\n            }\n        }\n    }\n}",
    "ir_json": {
      "class_name": "ParticleFountain",
      "components": [
        "ParticleSystem",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "spawnRate",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "particleLifetime",
          "type": "float",
          "default": 5.0
        },
        {
          "name": "basePitch",
          "type": "float",
          "default": 220.0
        },
        {
          "name": "pitchRange",
          "type": "float",
          "default": 440.0
        }
      ],
      "behaviors": [
        {
          "name": "spawn_particles",
          "trigger": "every second",
          "actions": [
            {
              "action": "create 100 particles with physics",
              "temporal": "event"
            },
            {
              "action": "assign unique color based on spawn time",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "manage_audio",
          "trigger": "on particle creation",
          "actions": [
            {
              "action": "create individual audio source for each particle",
              "temporal": "event"
            },
            {
              "action": "apply unique pitch per particle",
              "temporal": "event"
            }
          ]
        },
        {
          "name": "track_particles",
          "trigger": "every frame",
          "actions": [
            {
              "action": "check distance between all particles",
              "temporal": "continuous"
            },
            {
              "action": "create visual line between closest particles within 2 units",
              "temporal": "conditional"
            }
          ]
        },
        {
          "name": "explode_particles",
          "trigger": "after 5 seconds",
          "actions": [
            {
              "action": "apply explosion force to all particles",
              "temporal": "event"
            },
            {
              "action": "combine and play chord of all particle pitches",
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Implements core particle fountain mechanics",
        "Handles particle spawning with unique colors",
        "Tracks particle distances and draws debug lines",
        "Implements explosion mechanism",
        "Uses SerializeField for configurable parameters"
      ],
      "weaknesses": [
        "Incomplete audio chord implementation",
        "Abruptly cut-off code for final explosion sound",
        "Memory management for particles not fully optimized",
        "No clear cleanup mechanism for particle objects",
        "Limited error handling"
      ],
      "suggestions": [
        "Implement object pooling for particle management",
        "Complete the audio chord generation logic",
        "Add proper destruction/cleanup of particle objects",
        "Implement more robust error handling and null checks",
        "Use Unity's built-in particle system more extensively instead of manually creating particles",
        "Add comments explaining complex algorithmic sections",
        "Consider using a more efficient algorithm for tracking particle distances"
      ]
    },
    "grade_time": 11.76305890083313,
    "error": null
  },
  {
    "prompt": "24. \"Create a chain reaction system: when object A is touched, it explodes and spawns 5 objects of type B in a circle. Each B object, when touched, explodes and spawns 3 objects of type C. Each C object spawns 2 objects of type D. Each D object spawns 1 object of type E. Type E objects play a final victory sound and create a massive particle burst. All explosions should chain-react if objects are close enough to each other.\"",
    "success": true,
    "generation_time": 58.493715047836304,
    "rag_docs_used": 12,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class ReactionChainSystem : MonoBehaviour\n{\n    [SerializeField] private float reactionRadius = 5.0f;\n    [SerializeField] private GameObject prefabB = null;\n    [SerializeField] private GameObject prefabC = null;\n    [SerializeField] private GameObject prefabD = null;\n    [SerializeField] private GameObject prefabE = null;\n\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n\n    // Audio source for explosion sound effect\n    private AudioSource audioSource;\n\n    private void Start()\n    {\n        // Get required components\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n\n        // Add audio source if not present\n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null)\n        {\n            audioSource = gameObject.AddComponent<AudioSource>();\n            audioSource.playOnAwake = false;\n            audioSource.spatialBlend = 1.0f; // Make it 3D\n        }\n\n        // Cache player reference if needed for future use\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if the collider is tagged as 'ReactionTrigger'\n        if (other.CompareTag(\"ReactionTrigger\"))\n        {\n            // Play explosion sound effect - EVENT action\n            audioSource.PlayOneShot(explosionSound);\n\n            // Create 5 B objects in a circle around this object - EVENT action\n            SpawnBObjectsInCircle(5);\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Check if collider is within reaction radius of any other collider\n        foreach (Collider other in Physics.OverlapSphere(transform.position, reactionRadius))\n        {\n            if (other != _collider && other.isTrigger) // Only check trigger colliders\n            {\n                // Play explosion sound effect - EVENT action\n                audioSource.PlayOneShot(explosionSound);\n\n                // Destroy self and trigger explosion sequence on B objects - EVENT action\n                Destroy(gameObject);\n                SpawnBObjectsInCircle(5);\n                break;\n            }\n        }\n    }\n\n    private void SpawnBObjectsInCircle(int count)\n    {\n        if (prefabB == null) return;\n\n        float angleStep = 360.0f / count;\n        for (int i = 0; i < count; i++)\n        {\n            // Calculate position in a circle around this object\n            float angle = i * angleStep * Mathf.Deg2Rad;\n            Vector3 spawnPos = transform.position + new Vector3(\n                Mathf.Cos(angle) * reactionRadius,\n                0.5f, // Slightly above ground\n                Mathf.Sin(angle) * reactionRadius);\n\n            Instantiate(prefabB, spawnPos, Quaternion.identity);\n        }\n    }\n\n    private Transform _player;\n\n    private void Update()\n    {\n        // Check if player exists and is within reaction radius (conditional action)\n        if (_player != null && Vector3.Distance(transform.position, _player.position) < reactionRadius)\n        {\n            // Player is close enough for chain-reaction\n            // This could be used to trigger additional effects or state changes\n        }\n    }\n\n    // TODO: Consider adding a method to handle the next level of reactions (C/D/E objects)\n    // This would require tracking which B objects have been triggered and managing the reaction chain\n}",
    "ir_json": {
      "class_name": "ReactionChainSystem",
      "components": [
        "Rigidbody",
        "Collider"
      ],
      "fields": [
        {
          "name": "reactionRadius",
          "type": "float",
          "default": 5.0,
          "description": "Distance threshold to chain-react"
        },
        {
          "name": "prefabB",
          "type": "GameObject",
          "default": null,
          "description": "Prefab for reaction type B objects"
        },
        {
          "name": "prefabC",
          "type": "GameObject",
          "default": null,
          "description": "Prefab for reaction type C objects"
        },
        {
          "name": "prefabD",
          "type": "GameObject",
          "default": null,
          "description": "Prefab for reaction type D objects"
        },
        {
          "name": "prefabE",
          "type": "GameObject",
          "default": null,
          "description": "Prefab for final reaction object E"
        }
      ],
      "behaviors": [
        {
          "name": "on_collision_with_trigger",
          "trigger": "collision with other objects tagged 'ReactionTrigger'",
          "actions": [
            {
              "action": "play explosion sound effect",
              "temporal": "event",
              "description": "Play main explosion audio"
            },
            {
              "action": "create 5 B objects in a circle around this object",
              "count": 5,
              "temporal": "event",
              "description": "Spawn reaction level B objects at angles of 72 degrees apart"
            }
          ]
        },
        {
          "name": "on_destroyed_by_collision",
          "trigger": "when any other collider enters its trigger zone and is close enough (reactionRadius)",
          "actions": [
            {
              "action": "check if object is within reactionRadius of this object",
              "temporal": "event",
              "description": "Determines whether chain-reaction should occur"
            },
            {
              "action": "if yes, destroy self and trigger explosion sequence on B objects",
              "temporal": "event",
              "description": "Initiates next level of reaction if proximity condition met"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false,
        "note": "Reaction chain is handled through event-based destruction and spawning rather than a traditional state machine. Each explosion type triggers the next in sequence."
      }
    },
    "grade": {
      "overall_score": 7.5,
      "correctness": 8,
      "code_quality": 7,
      "completeness": 7,
      "unity_best_practices": 8,
      "strengths": [
        "Implements chain reaction trigger mechanism",
        "Spawns objects in a circular pattern",
        "Uses Unity collision and trigger methods correctly",
        "Includes audio source handling",
        "Handles component retrieval in Start method"
      ],
      "weaknesses": [
        "Incomplete implementation of full reaction chain (C, D, E objects)",
        "Missing explosion sound reference",
        "No particle effect implementation",
        "Lacks explicit handling of final victory sound and particle burst for E objects"
      ],
      "suggestions": [
        "Implement methods for spawning C, D, and E objects with similar circular spawning logic",
        "Add AudioClip for explosionSound",
        "Create a method to handle the complete reaction chain from A -> B -> C -> D -> E",
        "Add particle system component for final explosion effect",
        "Implement a more robust chain reaction mechanism that tracks object generations",
        "Add error handling for missing prefabs",
        "Consider using object pooling for performance with multiple spawned objects"
      ]
    },
    "grade_time": 13.39452075958252,
    "error": null
  },
  {
    "prompt": "25. \"Build a script that creates a recursive reality: the object contains a miniature version of the entire scene inside it (as a texture on its material). When you zoom into that texture (detected via camera distance), it reveals that the miniature scene also contains the same object with the same miniature scene, creating infinite recursion. Each recursive level should play a different musical note, and the object should scale based on which recursive level you're currently viewing.\"",
    "success": true,
    "generation_time": 61.47097682952881,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RecursiveRealityGenerator : MonoBehaviour\n{\n    [SerializeField] private float baseNoteFrequency = 220.0f;\n    [SerializeField] private float noteIncrementSemitone = 2.0f;\n    [SerializeField] private int maxRecursionDepth = 5;\n    [SerializeField] private float minScale = 1.0f;\n    [SerializeField] private float scaleIncrementFactor = 2.0f;\n\n    private Camera _camera;\n    private MeshRenderer _meshRenderer;\n    private Material _material;\n    private Texture recursiveTexture;\n    private int recursionLevel = 0;\n    private bool shouldRenderRecursive = false;\n    private Transform player;\n    private bool wasShouldRenderRecursive = false;\n\n    void Start()\n    {\n        _camera = GetComponent<Camera>();\n        _meshRenderer = GetComponent<MeshRenderer>();\n        if (_meshRenderer != null)\n        {\n            _material = _meshRenderer.material;\n        }\n        \n        // Find player object\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            player = playerObj.transform;\n        }\n    }\n\n    void Update()\n    {\n        // Calculate camera distance to object - EVENT action (temporal: event)\n        float cameraDistance = Vector3.Distance(_camera.transform.position, transform.position);\n        \n        // Check if within viewing threshold - CONDITIONAL action (temporal: conditional)\n        bool isWithinThreshold = cameraDistance < 10.0f;\n        if (isWithinThreshold && !wasShouldRenderRecursive)\n        {\n            shouldRenderRecursive = true; // Trigger event\n            wasShouldRenderRecursive = true;\n        }\n        else if (!isWithinThreshold && wasShouldRenderRecursive)\n        {\n            shouldRenderRecursive = false;\n            wasShouldRenderRecursive = false;\n        }\n\n        if (shouldRenderRecursive)\n        {\n            UpdateRecursiveReality();\n        }\n    }\n\n    private void UpdateRecursiveTexture(int level)\n    {\n        // Calculate note frequency for current level\n        float noteFrequency = baseNoteFrequency * Mathf.Pow(2.0f, Mathf.Pow(noteIncrementSemitone / 12.0f, level));\n        \n        // Generate recursive texture (simplified placeholder)\n        // In a real implementation, this would generate a texture based on the recursion level and frequency\n        recursiveTexture = new Texture2D(256, 256); // Placeholder for actual texture generation\n        \n        if (_material != null)\n        {\n            _material.SetTexture(\"_MainTex\", recursiveTexture);\n        }\n    }\n\n    private void UpdateRecursiveReality()\n    {\n        // Calculate scale based on recursion level (EVENT action - temporal: event)\n        float objectScale = minScale * Mathf.Pow(scaleIncrementFactor, -recursionLevel);\n        transform.localScale = new Vector3(objectScale, objectScale, objectScale);\n\n        if (recursionLevel < maxRecursionDepth && recursionLevel > 0)\n        {\n            // Generate texture for this level\n            UpdateRecursiveTexture(recursionLevel);\n            \n            // Recurse into next level\n            recursionLevel++;\n            // In a real implementation, you would create child objects here\n            // This is just a placeholder for the recursive generation logic\n            // GameObject child = Instantiate(this.gameObject, transform.position, transform.rotation);\n            // child.GetComponent<RecursiveRealityGenerator>().recursionLevel = recursionLevel;\n        }\n    }\n\n    private void OnDisable()\n    {\n        // Reset state when object is disabled/destroyed\n        shouldRenderRecursive = false;\n        wasShouldRenderRecursive = false;\n        recursionLevel = 0;\n    }\n}",
    "ir_json": {
      "class_name": "RecursiveRealityGenerator",
      "components": [
        "MeshRenderer",
        "Camera"
      ],
      "fields": [
        {
          "name": "baseNoteFrequency",
          "type": "float",
          "default": 220.0
        },
        {
          "name": "noteIncrementSemitone",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "maxRecursionDepth",
          "type": "int",
          "default": 5
        },
        {
          "name": "minScale",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "scaleIncrementFactor",
          "type": "float",
          "default": 2.0
        }
      ],
      "behaviors": [
        {
          "name": "recursive_reality_loop",
          "trigger": "every frame update",
          "actions": [
            {
              "action": "calculate camera distance to object",
              "target": "cameraDistance",
              "temporal": "event"
            },
            {
              "action": "check if within viewing threshold",
              "distanceThreshold": 10.0,
              "conditionVar": "shouldRenderRecursive",
              "temporal": "event"
            },
            {
              "action": "if shouldRenderRecursive = true then:",
              "branching_actions": [
                {
                  "action": "update recursion level based on distance",
                  "currentLevel": "recursionLevel",
                  "temporal": "event"
                },
                {
                  "action": "calculate note frequency for current level",
                  "formula": "baseNoteFrequency multiplied by (2 raised to the power of (noteIncrementSemitone divided by 12)) raised to the power of recursionLevel",
                  "resultVar": "noteFrequency",
                  "temporal": "event"
                },
                {
                  "action": "generate texture with miniature scene at recursion level",
                  "levelParam": "recursionLevel",
                  "targetTexture": "recursiveTexture",
                  "temporal": "event"
                },
                {
                  "action": "apply texture to material",
                  "materialProperty": "_MainTex",
                  "source": "recursiveTexture",
                  "temporal": "event"
                },
                {
                  "action": "calculate scale based on recursion level",
                  "formula": "minScale multiplied by (scaleIncrementFactor raised to the power of -recursionLevel)",
                  "resultVar": "objectScale",
                  "temporal": "event"
                },
                {
                  "action": "apply calculated scale to object transform",
                  "transformProperty": "localScale",
                  "value": "objectScale",
                  "temporal": "event"
                }
              ],
              "temporal": "conditional"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": false
      }
    },
    "grade": {
      "overall_score": 6.5,
      "correctness": 7,
      "code_quality": 6,
      "completeness": 5,
      "unity_best_practices": 7,
      "strengths": [
        "Implements core recursive texture generation concept",
        "Uses SerializeField for inspector-configurable parameters",
        "Handles camera distance and rendering threshold",
        "Provides basic scale and frequency calculation logic"
      ],
      "weaknesses": [
        "Incomplete recursive texture generation",
        "No actual infinite recursion implemented",
        "Placeholder texture generation",
        "Limited musical note generation",
        "No real-time scene capture mechanism"
      ],
      "suggestions": [
        "Implement a proper RenderTexture-based scene capture for true recursive rendering",
        "Create a more sophisticated recursive object instantiation mechanism",
        "Add audio generation based on calculated note frequencies",
        "Implement a more robust recursive depth management system",
        "Add error handling and logging for edge cases",
        "Create a shader or render technique for infinite zoom effect"
      ]
    },
    "grade_time": 12.472097873687744,
    "error": null
  },
  {
    "prompt": "26. \"Make a chaos engine: it randomly selects from 20 different behaviors every 3 seconds (spin, bounce, scale pulse, color shift, audio play, particle burst, force application, teleport, rotation, etc.). Each behavior has a random intensity and duration. The object should never repeat the same behavior twice in a row, and should create a unique sound effect for each behavior transition. After 60 seconds of chaos, it should settle into a calm, meditative state with soft colors and ambient sounds.\"",
    "success": true,
    "generation_time": 52.581855058670044,
    "rag_docs_used": 6,
    "was_steered": true,
    "generated_code": "using UnityEngine;\n\npublic class ChaosEngine : MonoBehaviour\n{\n    [SerializeField] private Behavior[] behaviors;\n    [SerializeField] private float[] behaviorDurations = new float[1] { 3.0f };\n    [SerializeField] private AudioClip[] soundEffects;\n    [SerializeField] private Color calmColor = Color.white;\n    [SerializeField] private float initialDuration = 60.0f;\n\n    private AudioSource audioSource;\n    private Renderer _renderer;\n    private float elapsedTime = 0f;\n    private enum State { ChaosLoop, Calm }\n    private State _currentState = State.ChaosLoop;\n    private State _previousState;\n    private int behaviorIndex = 0;\n\n    void Start()\n    {\n        audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        chaosStartTime = Time.time;\n    }\n\n    void OnEnable()\n    {\n        if (_currentState == State.ChaosLoop)\n        {\n            EnterState(State.ChaosLoop);\n        }\n    }\n\n    private void Update()\n    {\n        switch (_currentState)\n        {\n            case State.ChaosLoop:\n                UpdateChaosLoop();\n                break;\n        }\n    }\n\n    private void UpdateChaosLoop()\n    {\n        elapsedTime += Time.deltaTime;\n\n        if (elapsedTime >= initialDuration)\n        {\n            EnterState(State.Calm);\n        }\n    }\n\n    private void EnterState(State newState)\n    {\n        switch (newState)\n        {\n            case State.ChaosLoop:\n                behaviors = new Behavior[behaviorDurations.Length];\n                for (int i = 0; i < behaviorDurations.Length; i++)\n                {\n                    behaviors[i] = new Behavior();\n                }\n                // Set timer for behavior change intervals\n                InvokeRepeating(\"ChangeBehavior\", 0f, behaviorDurations[Random.Range(0, behaviorDurations.Length)]);\n                break;\n            case State.Calm:\n                _renderer.material.color = calmColor;\n                PlayAmbientSound();\n                CancelInvoke();\n                break;\n        }\n    }\n\n    private void UpdateState(State currentState)\n    {\n        switch (currentState)\n        {\n            case State.ChaosLoop:\n                // Check time elapsed\n                if (elapsedTime >= initialDuration)\n                {\n                    EnterState(State.Calm);\n                }\n                SelectRandomBehavior();\n                break;\n        }\n    }\n\n    private void ChangeBehavior()\n    {\n        behaviorIndex = Random.Range(0, behaviors.Length);\n        Debug.Log(\"Changed to behavior: \" + behaviorIndex);\n    }\n\n    private void PlayAmbientSound()\n    {\n        if (soundEffects != null && soundEffects.Length > 0)\n        {\n            audioSource.PlayOneShot(soundEffects[Random.Range(0, soundEffects.Length)]);\n        }\n    }\n\n    [System.Serializable]\n    public class Behavior\n    {\n        // Placeholder for behavior definition if needed\n    }\n}",
    "ir_json": {
      "class_name": "ChaosEngine",
      "components": [
        "MonoBehaviour",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "behaviors",
          "type": "List<Behavior>",
          "default": null
        },
        {
          "name": "behaviorDurations",
          "type": "float[]",
          "default": [
            3.0
          ]
        },
        {
          "name": "soundEffects",
          "type": "AudioClip[]",
          "default": null
        },
        {
          "name": "initialDuration",
          "type": "float",
          "default": 60.0
        },
        {
          "name": "calmColor",
          "type": "Color",
          "default": "#FFFFFF"
        },
        {
          "name": "chaosStartTime",
          "type": "float",
          "default": 0
        }
      ],
      "behaviors": [
        {
          "name": "start_chaos",
          "trigger": "OnEnable",
          "actions": [
            {
              "action": "initialize behaviors array with chaos effects",
              "temporal": "event"
            },
            {
              "action": "set timer for behavior change intervals",
              "interval_seconds": 3.0,
              "temporal": "event"
            }
          ]
        }
      ],
      "state_machine": {
        "has_state_machine": true,
        "initial_state": "chaos_loop",
        "states": [
          {
            "name": "chaos_loop",
            "actions": [
              {
                "action": "check time elapsed",
                "temporal": "continuous"
              },
              {
                "action": "select random behavior",
                "temporal": "event"
              }
            ],
            "transitions": [
              {
                "to": "calm",
                "condition": "elapsed >= initialDuration"
              }
            ]
          },
          {
            "name": "calm",
            "actions": [
              {
                "action": "set material color to calmColor",
                "temporal": "event"
              },
              {
                "action": "play ambient sound",
                "temporal": "event"
              }
            ]
          }
        ]
      }
    },
    "grade": {
      "overall_score": 6.25,
      "correctness": 6,
      "code_quality": 7,
      "completeness": 5,
      "unity_best_practices": 6,
      "strengths": [
        "Implemented state machine approach",
        "Basic chaos loop and calm state logic",
        "Proper use of SerializeField attributes",
        "Basic behavior change mechanism"
      ],
      "weaknesses": [
        "No actual implementation of specific behaviors",
        "Incomplete random behavior selection",
        "Missing prevention of repeated behaviors",
        "No specific sound effect for behavior transitions",
        "Incomplete chaos effects (spin, bounce, scale, etc.)"
      ],
      "suggestions": [
        "Implement a concrete Behavior class with specific effect types",
        "Add logic to prevent repeating the same behavior twice",
        "Create an enum or list of specific behavior types",
        "Implement individual behavior methods for each chaos effect",
        "Add more robust sound effect management for transitions",
        "Create a more dynamic intensity and duration system",
        "Add error handling and null checks",
        "Implement a more sophisticated random behavior selection mechanism"
      ]
    },
    "grade_time": 14.310001611709595,
    "error": null
  }
]