[
  {
    "prompt_num": 1,
    "prompt": "Build a disco ball that rotates while projecting colored light beams in random directions, plays electronic music that changes tempo based on how many players are nearby, and spawns glitter particles that drift downward and fade over 3 seconds when any object passes through the light beams.",
    "timestamp": "2026-01-08T21:39:00.203200",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class DiscoBall : MonoBehaviour\n{\n    [Header(\"Disco Ball Settings\")]\n    [SerializeField] private float _rotationSpeed = 120f;\n    [SerializeField] private bool _useRandomRotation = true;\n    [SerializeField] private float _rotationMinAngle = -90f;\n    [SerializeField] private float _rotationMaxAngle = 90f;\n\n    [Header(\"Light Projection\")]\n    [SerializeField] private Light[] _lightSources;\n    [SerializeField] private Color[] _projectionColors = new Color[8];\n    [SerializeField] private bool _enableBeams = true;\n    [SerializeField] private float _beamIntensity = 1.5f;\n\n    [Header(\"Glitter Settings\")]\n    [SerializeField] private ParticleSystem[] _glitterSystems;\n    [SerializeField] private float _glitterSpawnRate = 100f;\n    [SerializeField] private Vector3[] _glitterStartPositions = new Vector3[8];\n    [SerializeField] private float _glitterLifetime = 5f;\n    [SerializeField] private AnimationCurve _glitterDriftCurve = AnimationCurve.EaseInOut(0, 1, 1, 0.7f);\n\n    [Header(\"Music Settings\")]\n    [SerializeField] private AudioSource _musicSource;\n    [SerializeField] private AudioClip[] _musicTracks;\n    [SerializeField] private float _tempoMultiplier = 1.2f;\n    [SerializeField] private bool _autoPlayMusic = true;\n\n    private Camera _mainCamera;\n    private List<Light> _activeBeams = new List<Light>();\n    private List<ParticleSystem> _activeGlitters = new List<ParticleSystem>();\n\n    private void Start()\n    {\n        InitializeComponents();\n        SetupProjections();\n        SetupGlitterSystems();\n        SetupMusic();\n    }\n\n    private void InitializeComponents()\n    {\n        if (_musicSource == null)\n            _musicSource = GetComponent<AudioSource>();\n\n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n\n        if (_useRandomRotation && !_enableBeams)\n        {\n            _rotationSpeed = 100f;\n        }\n    }\n\n    private void SetupProjections()\n    {\n        if (!_enableBeams || _lightSources == null) return;\n\n        for (int i = 0; i < _lightSources.Length; i++)\n        {\n            Vector3 direction = Random.insideUnitSphere.normalized;\n            float angle = Random.Range(_rotationMinAngle, _rotationMaxAngle);\n            Quaternion rotation = Quaternion.Euler(angle, 0, 0);\n\n            if (!_activeBeams.Contains(_lightSources[i]))\n            {\n                _activeBeams.Add(_lightSources[i]);\n                _lightSources[i].enabled = true;\n                _lightSources[i].color = _projectionColors[i % _projectionColors.Length];\n                _lightSources[i].intensity = _beamIntensity;\n\n                // Position light slightly above the disco ball\n                Vector3 lightPosition = transform.position + direction * 2f - Vector3.up * 0.5f;\n                _lightSources[i].position = lightPosition;\n\n                // Add beam effect at random height\n                float beamHeight = Random.Range(1f, 10f);\n                _lightSources[i].beamHeight = beamHeight;\n            }\n        }\n\n        if (_mainCamera != null)\n        {\n            for (int i = 0; i < _activeBeams.Count; i++)\n            {\n                Vector3 targetPoint = _mainCamera.transform.position + _activeBeams[i].beamDirection.normalized * beamHeight;\n                _activeBeams[i].target = targetPoint;\n            }\n        }\n    }\n\n    private void SetupGlitterSystems()\n    {\n        if (_glitterSystems == null || _glitterSystems.Length == 0) return;\n\n        for (int i = 0; i < _glitterSystems.Length; i++)\n        {\n            ParticleSystem glitter = _glitterSystems[i] as ParticleSystem;\n            if (glitter != null)\n            {\n                Vector3 startPos = Random.insideUnitSphere * 1.5f + transform.position;\n                _glitterStartPositions[i] = startPos;\n\n                // Add random scale\n                float scale = Random.Range(0.2f, 0.8f);\n                GameObject glitterObj = new GameObject($\"Glitter_{i}\");\n                glitterObj.transform.SetParent(transform.parent);\n                glitterObj.transform.localPosition = Vector3.zero;\n                glitterObj.transform.localScale = Vector3.one * scale;\n\n                ParticleSystemController controller = new ParticleSystemController(glitter);\n                controller.Initialize(startPos, _glitterLifetime, scale, _glitterSpawnRate,\n                    _glitterDriftCurve, _glitterLifetime, _musicSource);\n\n                _activeGlitters.Add(glitter);\n            }\n        }\n    }\n\n    private void SetupMusic()\n    {\n        if (_musicSource == null || _musicTracks == null) return;\n\n        for (int i = 0; i < _musicTracks.Length; i++)\n        {\n            if (!_musicSource.isPlaying && _autoPlayMusic)\n            {\n                PlayMusic(_musicTracks[i]);\n            }\n        }\n    }\n\n    private void PlayMusic(AudioClip clip)\n    {\n        if (_musicSource != null && clip != null)\n        {\n            _musicSource.clip = clip;\n            _musicSource.loop = true;\n            _musicSource.Play();\n        }\n    }\n\n    private void Update()\n    {\n        RotateDiscoBall();\n\n        // Clean up inactive beams\n        for (int i = _activeBeams.Count - 1; i >= 0; i--)\n        {\n            if (!_enableBeams) break;\n\n            if (_lightSources[i] == null || !_activeBeams.Contains(_lightSources[i]))\n                _activeBeams.RemoveAt(i);\n        }\n\n        // Clean up inactive glitter\n        for (int i = _activeGlitters.Count - 1; i >= 0; i--)\n        {\n            ParticleSystem glitter = _activeGlitters[i] as ParticleSystem;\n            if (glitter == null) break;\n\n            if (!glitter.isPlaying)\n                _activeGlitters.RemoveAt(i);\n        }\n    }\n\n    private void RotateDiscoBall()\n    {\n        if (!_enableBeams || !_useRandomRotation) return;\n\n        float angle = Random.Range(_rotationMinAngle, _rotationMaxAngle);\n        Quaternion rotation = Quaternion.Euler(angle, 0, 0);\n\n        transform.Rotate(rotation * _rotationSpeed * Time.deltaTime);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            PlayMusic(_musicTracks[Random.Range(0, _musicTracks.Length)]);\n        }\n    }\n\n    private class ParticleSystemController\n    {\n        private ParticleSystem _ParticleSystem;\n        private float[] _startPositions;\n        private float _lifetime;\n        private float _spawnRate;\n        private AnimationCurve _driftCurve;\n        private AudioSource _audioSource;\n        private List<Collider> _colliders = new List<Collider>();\n\n        public ParticleSystemController(ParticleSystem particlesystem, Vector3 startPos, float lifetime,\n            float spawnRate, AnimationCurve driftCurve, float lifetimeDuration, AudioSource audioSource)\n        {\n            _ParticleSystem = particlesystem;\n            _startPositions = new float[particlesystem.main.startParticles * 2];\n            _lifetime = lifetime;\n            _spawnRate = spawnRate;\n            _driftCurve = driftCurve;\n            _audioSource = audioSource;\n\n            // Setup random start position\n            Vector3 startPos = startPos;\n            for (int i = 0; i < particlesystem.main.startParticles * 2; i++)\n            {\n                _startPositions[i] = startPos.x + Random.Range(-1f, 1f) / 10f;\n                _startPositions[i + 1] = startPos.y + Random.Range(-1f, 1f) / 10f;\n            }\n\n            // Set up random scale\n            float scale = Random.Range(0.2f, 0.8f);\n            Vector3 scaleOffset = new Vector3(Mathf.Log(scale), Mathf.Log(scale * 0.5f), Mathf.Log(scale * 0.25f));\n            _ParticleSystem.main.startSize = scale;\n            _ParticleSystem.main.startScale = scaleOffset;\n\n            // Play random sound\n            if (_audioSource != null && particlesystem.main.startParticles > 0)\n            {\n                AudioSource clip = new AudioSource();\n                clip.PlayOneShot(particlesystem.main.startParticles > 1 ? _audioSource.clip : null);\n            }\n\n            Initialize(particlesystem, startPos);\n        }\n\n        private void Initialize(ParticleSystem particlesystem, Vector3 startPos)\n        {\n            // Create emission\n            ParticleSystem.EmissionConfig emission = particlesystem.GetEmission();\n            emission.rateOverTime = _spawnRate;\n            emission.maxParticles = Mathf.Ceil(_lifetime * _spawnRate / 2f);\n\n            // Apply start position offset\n            for (int i = 0; i < emission.maxParticles; i++)\n            {\n                float x = Random.Range(-1f, 1f) / 10f + startPos.x;\n                float y = Random.Range(-1f, 1f) / 10f + startPos.y;\n                emission.startPos[i] = new Vector3(x, y, 0);\n            }\n\n            // Add velocity\n            ParticleSystemVelocity velocity = particlesystem.GetVelocity();\n            for (int i = 0; i < emission.maxParticles; i++)\n            {\n                float speed = Random.Range(1f, 5f) * Time.deltaTime;\n                Vector3 direction = Random.insideUnitSphere.normalized;\n                velocity.startSpeed[i] = speed * direction.x;\n                velocity.startSpeed[i + emission.maxParticles] = speed * direction.y;\n            }\n\n            // Add lifetime\n            ParticleSystemLifetimeConfig lifetime = particlesystem.GetLifetime();\n            lifetime.timeOverLifetime = _lifetime;\n\n            // Add drift\n            ParticleSystemDriftConfig drift = particlesystem.GetDrift();\n            if (_driftCurve != null)\n            {\n                for (int i = 0; i < emission.maxParticles * 2; i++)\n                {\n                    float t = Random.Range(0f, _lifetime);\n                    drift.startPos[i] = _driftCurve.Evaluate(t) * new Vector3(\n                        Random.Range(-1f, 1f),\n                        Random.Range(-1f, 1f),\n                        Random.Range(-1f, 1f)\n                    );\n                }\n            }\n\n            // Add random scale\n            ParticleSystemScaleConfig scale = particlesystem.GetScale();\n            float scaleFactor = Random.Range(0.2f, 0.8f);\n            Vector3 scaleOffset = new Vector3(Mathf.Log(scaleFactor), Mathf.Log(scaleFactor * 0.5f), Mathf.Log(scaleFactor * 0.25f));\n            scale.min = scaleOffset;\n            scale.max = scaleOffset;\n\n            // Add color\n            ParticleSystemColorConfig color = particlesystem.GetColor();\n            Color[] colors = new Color[emission.maxParticles * 2];\n            for (int i = 0; i < colors.Length; i++)\n            {\n                float h = Random.Range(0f, 360f);\n                colors[i] = Color.HSVToRGB(h / 180f, 1f, 0.8f + 0.2f * Mathf.Sin(i));\n            }\n            color.color = colors;\n\n            // Add collision detection\n            _colliders.Clear();\n            foreach (Collider col in particlesystem.GetComponentsInChildren<Collider>())\n            {\n                if (col != null)\n                    _colliders.Add(col);\n            }\n\n            // Add random audio clip\n            ParticleSystemAudioConfig audio = particlesystem.GetAudio();\n            AudioSource clip = new AudioSource();\n            if (_audioSource != null && emission.maxParticles > 0)\n            {\n                AudioClip sound = Random audios;\n                if (sound == null) sound = _audioSource.clip;\n                clip.PlayOneShot(sound);\n            }\n        }\n\n        public void UpdateGlitter()\n        {\n            for (int i = _startPositions.Length - 1; i >= 0; i--)\n            {\n                float t = Time.time + (_startPositions[i] / _spawnRate);\n                _startPositions[i] = Mathf.Lerp(_startPositions[i], Vector3.zero, t * _driftCurve.Evaluate(t));\n            }\n\n            // Update position\n            for (int j = 0; j < emission.maxParticles; j++)\n            {\n                float x = _startPositions[j].x;\n                float y = _startPositions[j + emission.maxParticles].y;\n                _ParticleSystem.transform.position = new Vector3(x, y, 0);\n            }\n\n            // Remove inactive particles\n            for (int k = _colliders.Count - 1; k >= 0; k--)\n            {\n                if (!_colliders[k].activeSelf)\n                    _colliders.RemoveAt(k);\n            }\n        }\n    }\n}",
    "ir_json": {
      "class_name": "DiscoLight",
      "components": [
        "Collider",
        "ParticleSystem",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "rotationSpeed",
          "type": "float",
          "default": 120
        },
        {
          "name": "beamCount",
          "type": "int",
          "default": 30
        },
        {
          "name": "baseColor",
          "type": "Color",
          "default": "white"
        },
        {
          "name": "maxBeamSpread",
          "type": "float",
          "default": 45
        },
        {
          "name": "musicClip",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "musicTempoRange",
          "type": "float",
          "default": 120
        },
        {
          "name": "glitterSpawnRate",
          "type": "int",
          "default": 10
        },
        {
          "name": "glitterLifetime",
          "type": "float",
          "default": 5
        }
      ],
      "behaviors": [
        {
          "name": "continuous_rotation",
          "trigger": "every frame while game is active",
          "actions": [
            {
              "action": "rotate object around vertical axis at rotation speed"
            },
            {
              "action": "update light direction with rotation"
            }
          ]
        },
        {
          "name": "project_beam_patterns",
          "trigger": "continuously during rotation",
          "actions": [
            {
              "action": "generate random beam spread distribution across max beam spread"
            },
            {
              "action": "create multiple colored beams from light source in different directions based on pattern"
            }
          ]
        },
        {
          "name": "update_music_tempo",
          "trigger": "every second while game is active and at least one player exists nearby",
          "actions": [
            {
              "action": "analyze number of players within interaction range"
            },
            {
              "action": "set music tempo to random value between current tempo and plus or minus 20 percent based on player count"
            }
          ]
        },
        {
          "name": "spawn_glitter_particles",
          "trigger": "continuously during rotation while particles exist",
          "actions": [
            {
              "action": "create glitter particle effect at light source position"
            },
            {
              "action": "set particle lifetime to random value between 1 and 3 seconds"
            },
            {
              "action": "apply downward drifting movement with slight randomness"
            }
          ]
        },
        {
          "name": "interaction_with_beams",
          "trigger": "when any object collides or passes through light beams",
          "actions": [
            {
              "action": "create glitter particle burst around collision point"
            },
            {
              "action": "start new random downward drifting glitter particles from collision location"
            }
          ]
        },
        {
          "name": "fade_glitter_particles",
          "trigger": "when any player enters or exits the glitter area",
          "actions": [
            {
              "action": "find all nearby glitter particles that are close to player position"
            },
            {
              "action": "gradually reduce brightness of each affected particle over 3 second duration"
            }
          ]
        },
        {
          "name": "play_music_loop",
          "trigger": "continuously while music clip exists and tempo is valid",
          "actions": [
            {
              "action": "loop the music clip at current adjusted tempo"
            },
            {
              "action": "fade in if not already playing"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class DiscoLight : MonoBehaviour\n{\n    [Header(\"Beam Settings\")]\n    [SerializeField] private int _beamCount = 30;\n    [SerializeField] private float _maxBeamSpread = 45f;\n    [SerializeField] private float _minBeamSpread = 10f;\n    [SerializeField] private float _beamDensity = 1f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _baseColor = Color.white;\n    [SerializeField] private AnimationCurve _colorTransition = AnimationCurve.EaseInOut(0f, 0.3f);\n    [SerializeField] private float _colorChangeSpeed = 5f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 120f;\n    [SerializeField] private float _rotationMinAngle = -90f;\n    [SerializeField] private float _rotationMaxAngle = 90f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _musicClips;\n    [SerializeField] private float _audioVolume = 0.8f;\n    [SerializeField] private float _tempoRange = 120f;\n    [SerializeField] private float _tempoChangeInterval = 5f;\n    \n    [Header(\"Glitter Settings\")]\n    [SerializeField] private ParticleSystem[] _glitterParticles;\n    [SerializeField] private float _glitterSpawnRate = 10f;\n    [SerializeField] private float _glitterLifetime = 5f;\n    [SerializeField] private AnimationCurve _glitterDrift = AnimationCurve.EaseInOut(0f, 1f);\n    \n    [Header(\"Interaction Settings\")]\n    [SerializeField] private bool _enablePlayerInteraction = true;\n    [SerializeField] private float _interactionRange = 3.5f;\n    [SerializeField] private float _interactionDuration = 2f;\n    [SerializeField] private AnimationCurve _interactionFade = AnimationCurve.EaseInOut(0f, 1f);\n    \n    private List<Beam> _beams = new List<Beam>();\n    private List<GlitterParticle> _glitterParticlesList = new List<GlitterParticle>();\n    private AudioSource _audioSource;\n    private float _lastTempoChangeTime;\n    private bool _isPlayerInRange;\n    \n    [System.Serializable]\n    public class Beam\n    {\n        public Transform[] beamPoints;\n        public Color startColor, endColor;\n        public float spread;\n        public float density;\n        public float angle;\n        \n        public Beam(Transform[] points, Color start, Color end, float spread, float density, float angle)\n        {\n            beamPoints = points;\n            startColor = start;\n            endColor = end;\n            this.spread = spread;\n            this.density = density;\n            this.angle = angle;\n        }\n    }\n    \n    private class GlitterParticle\n    {\n        public Transform transform;\n        public Renderer renderer;\n        public float lifetime;\n        public float driftSpeed;\n        public AnimationCurve driftCurve;\n        \n        public GlitterParticle(Transform t, Renderer r)\n        {\n            transform = t;\n            renderer = r.GetComponent<Renderer>();\n            if (renderer == null) renderer = t.GetComponent<Renderer>();\n            \n            lifetime = Random.Range(1f, 3f);\n            driftSpeed = Random.Range(0.5f, 2f);\n            driftCurve = _glitterDrift;\n        }\n    }\n    \n    void Start()\n    {\n        InitializeComponents();\n        CreateBeams();\n        SpawnGlitterParticles();\n        \n        if (_enablePlayerInteraction)\n        {\n            FindPlayersInRange();\n        }\n        \n        SetupAudioSource();\n    }\n    \n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.loop = true;\n            _audioSource.spatialBlend = 1f;\n            _audioSource.volume = _audioVolume;\n        }\n        \n        if (_musicClips == null || _musicClips.Length == 0)\n        {\n            _musicClips = new AudioClip[] { GameObject.Find(\"Music\").GetComponent<AudioSource>().clip };\n        }\n    }\n    \n    private void CreateBeams()\n    {\n        _beams.Clear();\n        \n        for (int i = 0; i < _beamCount; i++)\n        {\n            Vector3 direction = CalculateBeamDirection(i);\n            float spreadAngle = Random.Range(10f, _maxBeamSpread - _minBeamSpread) * 2f;\n            float angle = Quaternion.Angle(direction.normalized, transform.forward) * (360f / (_beamCount + 1));\n            \n            Transform[] beamPoints = new Transform[4];\n            Vector3 startPos = transform.position;\n            beamPoints[0] = startPos;\n            \n            for (int j = 1; j < 4; j++)\n            {\n                Vector3 offset = Quaternion.AngleAxis(spreadAngle * j / 3f, direction.normalized) * _beamDensity;\n                beamPoints[j] = startPos + offset;\n            }\n            \n            Color startColor = _baseColor;\n            Color endColor = new Color(startColor.r, startColor.g, startColor.b, 0.8f);\n            if (_colorTransition != null && i < _colorTransition.length)\n            {\n                float t = (i / _beamCount) * 2f - 1f;\n                startColor = Color.Lerp(startColor, endColor, t);\n            }\n            \n            Beam beam = new Beam(beamPoints, startColor, endColor, spreadAngle, _beamDensity, angle);\n            _beams.Add(beam);\n        }\n    }\n    \n    private Vector3 CalculateBeamDirection(int i)\n    {\n        float angle = (i / _beamCount) * 360f;\n        return Quaternion.Euler(0, angle, 0).Rotation * transform.forward;\n    }\n    \n    private void SpawnGlitterParticles()\n    {\n        for (int i = 0; i < _glitterParticles.Length; i++)\n        {\n            if (_glitterParticles[i] == null) continue;\n            \n            foreach (var particle in _glitterParticles[i].particles)\n            {\n                GlitterParticle glitter = new GlitterParticle(particle.transform, particle.GetComponent<Renderer>());\n                _glitterParticlesList.Add(glitter);\n            }\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        if (_musicClips.Length == 0) return;\n        \n        AudioSource audioSource = _audioSource;\n        float baseTempo = 120f;\n        \n        for (int i = 0; i < _musicClips.Length; i++)\n        {\n            if (!_isPlayerInRange)\n            {\n                float tempoChangeTime = Time.time - _lastTempoChangeTime + Random.Range(3f, 8f);\n                while (tempoChangeTime > 0f && audioSource.isPlaying)\n                {\n                    tempoChangeTime -= Time.deltaTime;\n                }\n                \n                if (audioSource.isPlaying)\n                {\n                    int originalClipCount = audioSource.clip.Length / audioSource.sampleRate;\n                    float newTempo = baseTempo + Random.Range(-_tempoRange, _tempoRange);\n                    float noteDuration = 1f / newTempo;\n                    float pitchScale = 1f / noteDuration;\n                    audioSource.pitch = pitchScale;\n                }\n            }\n        }\n    }\n    \n    private void FindPlayersInRange()\n    {\n        _isPlayerInRange = false;\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!col.CompareTag(\"Player\")) continue;\n            \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance <= _interactionRange && !col.CompareTag(\"Player\"))\n            {\n                _isPlayerInRange = true;\n                break;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        AnimateBeams();\n        UpdateGlitterParticles();\n        UpdateAudioSource();\n        \n        if (_enablePlayerInteraction)\n        {\n            CheckForPlayerInteractions();\n        }\n    }\n    \n    private void AnimateBeams()\n    {\n        for (int i = 0; i < _beams.Count; i++)\n        {\n            Beam beam = _beams[i];\n            float t = (i / _beams.Count) * 2f - 1f;\n            \n            if (_colorTransition != null && i < _colorTransition.length)\n            {\n                Color color = Color.Lerp(beam.startColor, beam.endColor, t);\n                beam.startColor = color;\n                beam.endColor = new Color(color.r, color.g, color.b, 0.8f);\n            }\n        }\n    }\n    \n    private void UpdateGlitterParticles()\n    {\n        for (int i = _glitterParticlesList.Count - 1; i >= 0; i--)\n        {\n            GlitterParticle glitter = _glitterParticlesList[i];\n            \n            if (!glitter.transform.isPlaying)\n            {\n                float time = Time.time;\n                float driftValue = glitter.driftCurve.Evaluate(glitter.driftSpeed * time);\n                glitter.transform.rotation = Quaternion.Euler(0, driftValue, 0) * glitter.transform.rotation;\n                \n                if (Time.time - glitter.lifetime >= 0f)\n                {\n                    _glitterParticlesList.RemoveAt(i);\n                }\n            }\n        }\n    }\n    \n    private void UpdateAudioSource()\n    {\n        if (_isPlayerInRange && !_audioSource.isPlaying)\n        {\n            PlayMusic();\n        }\n    }\n    \n    private void CheckForPlayerInteractions()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        \n        for (int i = 0; i < colliders.Length; i++)\n        {\n            if (!colliders[i]..CompareTag(\"Player\")) continue;\n            \n            float distance = Vector3.Distance(transform.position, colliders[i].transform.position);\n            float interactionTime = Mathf.Max(0f, _interactionDuration - distance / _interactionRange);\n            \n            if (interactionTime > 0f)\n            {\n                StartCoroutine(FadeGlitterNearbyPlayer(colliders[i]));\n            }\n        }\n    }\n    \n    private IEnumerator FadeGlitterNearbyPlayer(Collider playerCollider)\n    {\n        float fadeStart = Time.time;\n        \n        while (playerCollider.transform.position.distanceTo(transform.position) <= _interactionRange && Time.time - fadeStart < 1f)\n        {\n            Vector3 direction = (transform.position - playerCollider.transform.position).normalized;\n            float distance = transform.position.distanceTo(playerCollider.transform.position);\n            \n            for (int i = _glitterParticlesList.Count - 1; i >= 0; i--)\n            {\n                GlitterParticle glitter = _glitterParticlesList[i];\n                if (!glitter.transform.isPlaying) continue;\n                \n                float time = Time.time - fadeStart;\n                float faded = 1f - (distance / _interactionRange) * Mathf.Min(1f, interactionTime);\n                glitter.transform.color = Color.Lerp(glitter.transform.color, new Color(glitter.transform.color.r, glitter.transform.color.g, glitter.transform.color.b, faded), faded);\n            }\n            \n            yield return null;\n        }\n        \n        foreach (var glitter in _glitterParticlesList)\n        {\n            if (!glitter.transform.isPlaying) continue;\n            glitter.transform.color = Color.Lerp(glitter.transform.color, new Color(0.1f, 0.1f, 0.1f, 0.5f), faded);\n        }\n        \n        _glitterParticlesList.Clear();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        for (int i = 0; i < _beams.Count; i++)\n        {\n            Beam beam = _beams[i];\n            Vector3 direction = beam.angle == 360f ? Quaternion.Euler(0, 0, -90f).Rotation * transform.forward : \n                Quaternion.AngleAxis(beam.angle, direction.normalized) * transform.forward;\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawRay(transform.position, direction * _interactionRange);\n        }\n    }\n    \n    public void SetBeamCount(int count)\n    {\n        _beamCount = Mathf.Max(1, count);\n        CreateBeams();\n    }\n    \n    public void AdjustBeamSpread(float spreadAmount)\n    {\n        float minBeamSpread = Mathf.Max(_minBeamSpread - spreadAmount, 0f);\n        float maxBeamSpread = Mathf.Min(_maxBeamSpread + spreadAmount, 90f);\n        \n        foreach (var beam in _beams)\n        {\n            beam.spread += spreadAmount;\n            beam.spread = Mathf.Clamp(beam.spread, minBeamSpread, maxBeamSpread);\n        }\n    }\n    \n    public void ChangeMusicClip(int index)\n    {\n        if (_musicClips.Length <= index || !_isPlayerInRange) return;\n        \n        AudioSource audioSource = _audioSource;\n        float baseTempo = 120f;\n        \n        if (audioSource.isPlaying)\n        {\n            int originalClipCount = audioSource.clip.Length / audioSource.sampleRate;\n            float newTempo = baseTempo + Random.Range(-_tempoRange, _tempoRange);\n            float noteDuration = 1f / newTempo;\n            float pitchScale = 1f / noteDuration;\n            audioSource.pitch = pitchScale;\n        }\n    }\n    \n    public void TogglePlayerInteraction(bool enable)\n    {\n        _enablePlayerInteraction = enable;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n}\n\npublic class Beam : MonoBehaviour\n{\n    public Transform[] beamPoints;\n    public Color startColor, endColor;\n    public float spread;\n    public float density;\n    public float angle;\n    \n    private List<BeamPoint> _beamPoints = new List<BeamPoint>();\n    \n    [System.Serializable]\n    private class BeamPoint\n    {\n        public Vector3 position;\n        public Quaternion rotation;\n        public Color color;\n        \n        public BeamPoint(Vector3 pos, Quaternion rot)\n        {\n            position = pos;\n            rotation = rot;\n            color = startColor;\n        }\n    }\n    \n    public Beam(Transform[] points, Color start, Color end, float spread, float density, float angle)\n    {\n        beamPoints = points;\n        this.startColor = start;\n        this.endColor = end;\n        this.spread = spread;\n        this.density = density;\n        this.angle = angle;\n        \n        CreateBeamPoints(points);\n        SetInitialColors();\n    }\n    \n    private void CreateBeamPoints(Transform[] points)\n    {\n        _beamPoints.Clear();\n        foreach (Transform point in points)\n        {\n            if (point == null) continue;\n            \n            Vector3 direction = (transform.position - point.localPosition).normalized;\n            Quaternion rotation = Quaternion.LookRotation(direction);\n            _beamPoints.Add(new BeamPoint(point.localPosition, rotation));\n        }\n    }\n    \n    private void SetInitialColors()\n    {\n        foreach (BeamPoint beamPoint in _beamPoints)\n        {\n            Color color = startColor;\n            if (_beamPoints.Count > 1 && _beamPoints.Count % 2 == 0)\n            {\n                int index = _beamPoints.IndexOf(beamPoint);\n                float t = Mathf.Abs((index - _beamPoints.Count / 2f) / _beamPoints.Count);\n                color = Color.Lerp(startColor, endColor, t);\n            }\n            beamPoint.color = color;\n        }\n    }\n    \n    public void UpdateBeamColors()\n    {\n        foreach (BeamPoint beamPoint in _beamPoints)\n        {\n            if (!transform.isPlaying) continue;\n            \n            float t = Mathf.Abs((_beamPoints.IndexOf(beamPoint) - _beamPoints.Count / 2f) / _beamPoints.Count);\n            Color color = Color.Lerp(startColor, endColor, t);\n            beamPoint.color = color;\n        }\n    }\n}\n\npublic class BeamPoint : MonoBehaviour\n{\n    public Vector3 position;\n    public Quaternion rotation;\n    public Color color;\n    \n    private Renderer[] renderers;\n    private float lifetime = 0f;\n    private bool isActive = false;\n    \n    public BeamPoint(Vector3 pos, Quaternion rot)\n    {\n        position = pos;\n        rotation = rot;\n        color = Color.white;\n        renderers = GetComponentsInChildren<Renderer>();\n    }\n    \n    private void Start()\n    {\n        if (position == Vector3.zero) return;\n        \n        float distance = Vector3.Distance(transform.position, transform.position + position);\n        lifetime = Random.Range(0.5f, 2f);\n        StartCoroutine(DriftAnimation());\n        \n        for (int i = 0; i < renderers.Length; i++)\n        {\n            renderers[i].enabled = false;\n        }\n    }\n    \n    private System.Collections.IEnumerator DriftAnimation()\n    {\n        while (lifetime > 0f)\n        {\n            float elapsed = Time.deltaTime;\n            float driftValue = Mathf.Lerp(0f, 1f, elapsed / lifetime);\n            transform.rotation = Quaternion.Euler(0, driftValue, 0) * rotation);\n            \n            yield return null;\n        }\n    }\n    \n    public void ActivateBeam()\n    {\n        isActive = true;\n        for (int i = 0; i < renderers.Length; i++)\n        {\n            renderers[i].enabled = true;\n        }\n    }\n    \n    public void DeactivateBeam()\n    {\n        isActive = false;\n        for (int i = 0; i < renderers.Length; i++)\n        {\n            renderers[i].enabled = false;\n        }\n    }\n}\n\npublic class ParticleSystemLight : MonoBehaviour\n{\n    [Header(\"Light Settings\")]\n    public Light light;\n    public float intensityMultiplier = 1f;\n    public float rangeMultiplier = 1f;\n    public bool useDefaultIntensity = true;\n    \n    [Header(\"Shadow Settings\")]\n    public bool castShadows = false;\n    public int shadowQuality = 2;\n    public LayerMask shadowLayerMask = -1;\n    \n    [Header(\"Beam Effects\")]\n    public ParticleSystem[] beamParticles;\n    public float beamDensity = 1f;\n    public float beamSpread = 0.1f;\n    public AnimationCurve beamColorTransition = AnimationCurve.EaseInOut(0f, 1f);\n    \n    private Light _light;\n    private ParticleSystem[] _beamParticleSystems;\n    private Renderer[] _beamRenderers;\n    \n    void Start()\n    {\n        InitializeLight();\n        SetupBeamEffects();\n    }\n    \n    private void InitializeLight()\n    {\n        if (light == null)\n            light = GetComponent<Light>();\n        \n        if (_light == null)\n        {\n            GameObject lightObject = new GameObject(\"Light\");\n            lightObject.transform.SetParent(transform);\n            _light = lightObject.AddComponent<Light>();\n        }\n        \n        _light.intensity = 1f;\n        _",
    "ir_steered": false,
    "ir_rag_docs": 9,
    "ir_rag_doc_names": [
      "ParticleSystem.LightsModule (0.61)",
      "Light.GetCommandBuffers (0.61)",
      "Light.SetLightDirty (0.60)",
      "Light.AddCommandBuffer (0.60)",
      "ParticleSystem.LightsModule.intensityMultiplier (0.47)",
      "ParticleSystem.TextureSheetAnimationModule.fps (0.47)",
      "ParticleSystemAnimationTimeMode.FPS (0.41)",
      "ParticleSystemShapeMultiModeValue.Random (0.40)",
      "LightEditor.Settings.bounceIntensity (0.15)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class DiscoBallController : MonoBehaviour\n{\n    [Header(\"Disco Ball Settings\")]\n    [SerializeField] private float _rotationSpeed = 360f;\n    [SerializeField] private int _beamCount = 12;\n    [SerializeField] private float _glitterSpawnRate = 0.5f;\n    [SerializeField] private float _glitterLifetime = 3f;\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _discoLight;\n    [SerializeField] private int _beamSpread = 30f;\n    [SerializeField] private float _beamWidth = 0.1f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _musicClip;\n    [SerializeField] private float _volume = 0.3f;\n    [SerializeField] private float _pitchRange = 0.8f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1.5f;\n    [SerializeField] private float _airDrag = 2f;\n    [SerializeField] private float _colliderRadius = 0.3f;\n    \n    private Vector3[] _beamDirections;\n    private ParticleSystem[] _glitterParticles;\n    private bool _isPlayingMusic = false;\n    private float _targetPitch = 1f;\n    private float _currentPitchMultiplier = 1f;\n    \n    private void Start()\n    {\n        InitializeBeamDirections();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_discoLight != null)\n            _discoLight.enabled = true;\n    }\n    \n    private void Update()\n    {\n        float time = Time.deltaTime;\n        \n        // Rotate disco ball\n        RotateDiscoBall(time);\n        \n        // Spawn glitter particles\n        SpawnGlitterParticles(time);\n        \n        // Update music pitch based on nearby players\n        UpdateMusicPitch();\n        \n        // Apply physics to disco ball\n        ApplyPhysics(time);\n    }\n    \n    private void InitializeBeamDirections()\n    {\n        _beamDirections = new Vector3[_beamCount];\n        \n        for (int i = 0; i < _beamCount; i++)\n        {\n            float angle = (i / _beamCount) * Mathf.PI * 2f;\n            _beamDirections[i] = new Vector3(\n                Mathf.Cos(angle),\n                0,\n                Mathf.Sin(angle)\n            );\n        }\n    }\n    \n    private void RotateDiscoBall(float deltaTime)\n    {\n        for (int i = 0; i < _beamCount; i++)\n        {\n            // Add some random spread to beam directions\n            float spread = Random.Range(-_beamSpread, _beamSpread);\n            _beamDirections[i].x += spread * Time.deltaTime;\n            \n            // Update light direction\n            if (_discoLight != null)\n                _discoLight.transform.Rotate(0, 0, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void SpawnGlitterParticles(float deltaTime)\n    {\n        if (Time.time < 1f) return;\n        \n        for (int i = 0; i < _glitterSpawnRate * Time.deltaTime; i++)\n        {\n            Vector3 spawnPosition = transform.position + Random.insideUnitSphere * 0.5f;\n            GameObject glitterObject = new GameObject(\"GlitterParticle\");\n            \n            Rigidbody rb = glitterObject.AddComponent<Rigidbody>();\n            rb.velocity = new Vector3(\n                Random.Range(-2f, 2f),\n                Random.Range(5f, 15f) * Time.deltaTime,\n                0\n            );\n            \n            // Add air drag to make glitter fall\n            rb.drag = _airDrag;\n            rb.angularDrag = 1f;\n            \n            // Create collider for detection\n            Collider col = glitterObject.AddComponent<SphereCollider>();\n            col.radius = _colliderRadius;\n            col.isTrigger = true;\n            \n            // Apply gravity scale\n            if (rb != null)\n                rb.useGravity = false;\n                rb.mass = _gravityScale;\n            \n            // Spawn glow effect\n            ParticleSystem particleSystem = CreateGlitterEffect(glitterObject);\n            _glitterParticles[i] = particleSystem;\n        }\n    }\n    \n    private ParticleSystem CreateGlitterEffect(GameObject glitterObj)\n    {\n        ParticleSystem particles = new ParticleSystem();\n        particles.transform.SetParent(glitterObj.transform, false);\n        \n        // Add glow material\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.color = Color.white;\n        mat.emissionColor = new Color(0.5f, 0.3f, 0.1f, 1f);\n        particles.gameObject.AddComponent<Light>();\n        \n        // Create emission\n        ParticleSystem.EmissionModule emission = particles.GetEmission();\n        emission.rateOverTime = _glitterSpawnRate;\n        emission.maxParticles = Mathf.Ceil(_glitterLifetime * _glitterSpawnRate);\n        emission.startSize = 0.1f;\n        emission.startSpeed = 5f;\n        \n        // Add velocity\n        ParticleSystem.velocityModule velocity = particles.GetVelocity();\n        velocity.enabled = true;\n        velocity.y = new Random.Range(8f, 20f) * Time.deltaTime;\n        \n        return particles;\n    }\n    \n    private void UpdateMusicPitch()\n    {\n        if (!_isPlayingMusic || _musicClip == null) return;\n        \n        int nearbyPlayers = 0;\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 10f, _obstacleLayerMask);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n                nearbyPlayers++;\n        }\n        \n        // Increase pitch when more players are closer\n        float newPitchMultiplier = Mathf.Clamp01(1f + (_pitchRange * (nearbyPlayers - 5f)));\n        _currentPitchMultiplier = newPitchMultiplier;\n        \n        // Apply pitch to music clip if possible\n        if (_audioSource != null && _musicClip != null)\n        {\n            _audioSource.pitch = _currentPitchMultiplier;\n        }\n    }\n    \n    private void ApplyPhysics(float deltaTime)\n    {\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        // Add air drag\n        rb.drag = _airDrag;\n        rb.angularDrag = 1f;\n        \n        // Apply gravity scale to physics\n        rb.mass = _gravityScale;\n        \n        // Prevent falling through ground\n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, -rb.velocity.normalized * 0.5f, out hit, _colliderRadius))\n        {\n            Vector3 force = -rb.velocity.normalized * 10f * Time.deltaTime;\n            rb.AddForceAtPosition(force, transform.position);\n        }\n    }\n    \n    public void StartMusic()\n    {\n        if (_isPlayingMusic) return;\n        \n        _isPlayingMusic = true;\n        PlayMusic();\n    }\n    \n    public void StopMusic()\n    {\n        if (!_isPlayingMusic || _audioSource == null) return;\n        \n        _isPlayingMusic = false;\n        _audioSource.Stop();\n        _audioSource.pitch = 1f;\n    }\n    \n    private void PlayMusic()\n    {\n        if (_audioSource == null || _musicClip == null) return;\n        \n        _audioSource.clip = _musicClip;\n        _audioSource.loop = true;\n        _audioSource.volume = _volume;\n        _audioSource.Play();\n    }\n}",
    "per_behavior_docs": 19,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "continuous_rotation": [
        "Transform.GetPositionAndRotation (0.66)",
        "Quaternion.RotateTowards (0.66)",
        "Quaternion.LookRotation (0.66)"
      ],
      "project_light_beams": [
        "GameObject.InstantiateGameObjects (0.66)",
        "GameObjectUtility (0.63)",
        "Light.SetLightDirty (0.63)"
      ],
      "spawn_glitter_particles": [
        "ParticleSystem.LightsModule (0.70)",
        "ParticleSystem.Play (0.67)",
        "Physics.SphereCastNonAlloc (0.67)"
      ],
      "glitter_drift_behavior": [
        "ParticleSystem.LightsModule (0.75)",
        "ParticleSystem.Play (0.74)",
        "ParticleSystem.ColorBySpeedModule (0.73)"
      ],
      "detect_player proximity": [
        "PlayerSettings (0.60)",
        "Animator.PlayInFixedTime (0.60)",
        "PlayerConnectionInitiateMode (0.59)"
      ],
      "adjust_music_tempo": [
        "Rigidbody.MoveRotation (0.67)",
        "Rigidbody.IsSleeping (0.67)",
        "Rigidbody.GetRelativePointVelocity (0.66)"
      ],
      "play_electronic_music": [
        "AudioSource.PlayDelayed (0.71)",
        "AudioSource.GetSpectrumData (0.71)",
        "AudioSource.Play (0.71)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 3,
        "weighted_total": 47,
        "justification": "Direct translation lacks clear separation of concerns, with methods starting but not fully implemented. Good Unity serialization, but overly complex initialization. Starts strong but doesn't fully execute the complete vision."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 6,
        "completeness": 7,
        "weighted_total": 67,
        "justification": "Highly structured approach with clear component classes, extensible design, and robust Unity patterns. Custom classes for Beam and GlitterParticle show sophisticated abstraction. Comprehensive serialized fields enable easy configuration."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 61,
        "justification": "Modular method-based design with clear behavior separation. Good use of Unity Update loop and initialization patterns. Slightly less comprehensive than monolithic approach, but more readable and easier to extend."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the most comprehensive implementation with custom classes, robust serialization, and clear architectural patterns. It balances complexity with readability and extensibility.",
      "advantages": "Advanced object-oriented design, comprehensive serialization, custom helper classes for complex behaviors, and a clear separation of concerns that makes future modification straightforward."
    },
    "error": null
  },
  {
    "prompt_num": 2,
    "prompt": "Create a magnet that attracts all metal-tagged objects within 15 units with exponentially increasing pull force, emits a crackling electrical sound that intensifies with attraction strength, generates sparks at contact points, and slowly dims its glow based on energy consumption tracked by an internal battery meter.",
    "timestamp": "2026-01-08T21:45:32.971782",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Magnet : MonoBehaviour\n{\n    [Header(\"Magnet Settings\")]\n    [SerializeField] private float _maxPullForce = 1000f;\n    [SerializeField] private float _attractionRadius = 15f;\n    [SerializeField] private float _pullDecayRate = 2f;\n    [SerializeField] private LayerMask _metalLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private Light _magnetLight;\n    [SerializeField] private float _baseIntensity = 100f;\n    [SerializeField] private float _intensityDecayRate = 0.1f;\n    \n    [Header(\"Battery Consumption\")]\n    [SerializeField] private float _energyConsumptionPerSecond = 10f;\n    [SerializeField] private float _batteryCapacity = 100f;\n    [SerializeField] private float _maxBatteryDrainRate = 50f;\n    \n    private List<MetalObject> _attractedObjects = new List<MetalObject>();\n    private Vector3 _originalLightDirection;\n    private float _currentIntensity;\n    private bool _isDimming = false;\n    \n    void Start()\n    {\n        if (_magnetLight != null)\n            _originalLightDirection = _magnetLight.transform.forward;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_sparkParticles != null)\n            _sparkParticles.Stop();\n            \n        UpdateIntensity();\n    }\n    \n    void Update()\n    {\n        DimGlowOverTime();\n        CheckForNewObjects();\n        UpdateAudio();\n    }\n    \n    private void DimGlowOverTime()\n    {\n        if (!_isDimming) return;\n        \n        float time = Time.deltaTime * _intensityDecayRate;\n        _currentIntensity *= Mathf.Pow(1f - time, 2f);\n        \n        if (_magnetLight != null)\n            _magnetLight.intensity = _baseIntensity * _currentIntensity;\n    }\n    \n    private void CheckForNewObjects()\n    {\n        Collider[] metalColliders = Physics.OverlapSphere(transform.position, _attractionRadius, _metalLayers);\n        \n        for (int i = metalColliders.Length - 1; i >= 0; i--)\n        {\n            MetalObject metalObj = metalColliders[i].gameObject.GetComponent<MetalObject>();\n            if (metalObj != null)\n            {\n                if (!_attractedObjects.Contains(metalObj))\n                {\n                    _attractedObjects.Add(metalObj);\n                    \n                    // Apply pull force\n                    Vector3 directionToMetal = (metalObj.transform.position - transform.position).normalized;\n                    float distance = metalObj.transform.distance(transform.position);\n                    float pullStrength = CalculatePullStrength(distance);\n                    metalObj.SetPullForce(directionToMetal, pullStrength);\n                }\n            }\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        float intensity = _currentIntensity * 0.5f; // Scale for audio volume\n        float pitchMultiplier = Mathf.Pow(intensity / _baseIntensity, 0.3f);\n        \n        var minVolume = _audioSource.minVolume;\n        var maxVolume = _audioSource.maxVolume;\n        \n        if (pitchMultiplier > 1f)\n        {\n            _audioSource.pitch = pitchMultiplier;\n            _audioSource.volume = Mathf.Clamp(_audioSource.volume * intensity, minVolume, maxVolume);\n        }\n        else\n        {\n            _audioSource.volume = Mathf.Clamp(intensity * maxVolume, minVolume, maxVolume);\n        }\n    }\n    \n    private float CalculatePullStrength(float distance)\n    {\n        if (distance <= 0f) return _maxPullForce;\n        \n        float decayFactor = Mathf.Pow(1f + (_attractionRadius / distance), -_pullDecayRate);\n        return _maxPullForce * decayFactor;\n    }\n    \n    public void AddObject(MetalObject obj)\n    {\n        if (!_attractedObjects.Contains(obj))\n            _attractedObjects.Add(obj);\n            \n        Vector3 directionToMetal = (obj.transform.position - transform.position).normalized;\n        float distance = obj.transform.distance(transform.position);\n        float pullStrength = CalculatePullStrength(distance);\n        obj.SetPullForce(directionToMetal, pullStrength);\n    }\n    \n    public void RemoveObject(MetalObject obj)\n    {\n        _attractedObjects.Remove(obj);\n        \n        Vector3 directionToMetal = (obj.transform.position - transform.position).normalized;\n        obj.StopPulling();\n        \n        for (int i = 0; i < _attractedObjects.Count; i++)\n        {\n            MetalObject otherObj = _attractedObjects[i];\n            if (otherObj != obj)\n            {\n                Vector3 directionToOtherMetal = (otherObj.transform.position - transform.position).normalized;\n                float distance = otherObj.transform.distance(transform.position);\n                float pullStrength = CalculatePullStrength(distance);\n                otherObj.SetPullForce(directionToOtherMetal, pullStrength);\n            }\n        }\n    }\n    \n    public void SetMaxPullForce(float newMax)\n    {\n        _maxPullForce = Mathf.Max(0f, newMax);\n    }\n    \n    private class MetalObject : MonoBehaviour\n    {\n        [Header(\"Magnet Interaction\")]\n        [SerializeField] private float _attractionStrength = 1f;\n        [SerializeField] private Vector3 _attractionForce = Vector3.up;\n        [SerializeField] private bool _useWorldDirection = true;\n        \n        public void SetPullForce(Vector3 direction, float strength)\n        {\n            if (_useWorldDirection)\n                direction = (transform.position - transform.position).normalized; // Should be world space\n            else\n                direction = _attractionForce.normalized;\n            \n            ApplyPull(direction, strength);\n        }\n        \n        private void ApplyPull(Vector3 direction, float strength)\n        {\n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddForce(direction * strength, ForceMode.Force);\n            }\n            else\n            {\n                // Fallback: Apply local force directly to the object\n                transform.Translate(direction * strength * Time.deltaTime, Space.World);\n            }\n        }\n        \n        public void StopPulling()\n        {\n            ApplyPull(Vector3.zero, 0f);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "MagneticMagnet",
      "components": [
        "Collider",
        "AudioSource",
        "Light",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "maxRange",
          "type": "float",
          "default": 15
        },
        {
          "name": "attractionStrength",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "attractionMultiplier",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "batteryCapacity",
          "type": "float",
          "default": 100
        },
        {
          "name": "currentBatteryLevel",
          "type": "float",
          "default": 100
        },
        {
          "name": "sparkEffect",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "magnetGlowIntensity",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "currentStrength",
          "type": "float",
          "default": 0
        }
      ],
      "behaviors": [
        {
          "name": "detect_metal_object",
          "trigger": "when metal-tagged object enters range",
          "actions": [
            {
              "action": "calculate distance to metal object"
            },
            {
              "action": "update attraction strength based on distance and multiplier"
            }
          ]
        },
        {
          "name": "attract_object",
          "trigger": "when metal object is within attract range",
          "actions": [
            {
              "action": "apply force toward magnet with current strength"
            },
            {
              "action": "increase current strength exponentially as objects get closer"
            },
            {
              "action": "spawn spark effect at contact point"
            }
          ]
        },
        {
          "name": "update_battery_usage",
          "trigger": "when attracting metal objects",
          "actions": [
            {
              "action": "consume energy proportional to attraction force and distance"
            },
            {
              "action": "decrease battery level accordingly"
            }
          ]
        },
        {
          "name": "dim_glow",
          "trigger": "when battery level drops significantly",
          "actions": [
            {
              "action": "reduce light intensity smoothly in proportion to battery drain"
            }
          ]
        },
        {
          "name": "play_electric_sound",
          "trigger": "when attracting metal objects",
          "actions": [
            {
              "action": "play crackling electrical sound effect"
            },
            {
              "action": "increase audio pitch and volume with attraction force"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MagneticMagnet : MonoBehaviour\n{\n    [Header(\"Magnetic Settings\")]\n    [SerializeField] private float _maxRange = 15f;\n    [SerializeField] private float _attractionStrength = 1.0f;\n    [SerializeField] private float _attractionMultiplier = 2.0f;\n    [SerializeField] private LayerMask _metalLayers = -1;\n    \n    [Header(\"Battery System\")]\n    [SerializeField] private float _batteryCapacity = 100f;\n    [SerializeField] private float _energyConsumptionPerSecond = 10f;\n    [SerializeField] private float _maxBatteryDrainRate = 50f;\n    [SerializeField] private AnimationCurve _batteryDrainCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _magnetLight;\n    [SerializeField] private ParticleSystem _sparkEffect;\n    [SerializeField] private AudioClip[] _attractionSounds;\n    [SerializeField] private float _lightIntensity = 2f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _minPitch = 0.5f;\n    [SerializeField] private float _maxPitch = 4f;\n    \n    private List<MetalObject> _attractedObjects = new List<MetalObject>();\n    private float _currentBatteryLevel = 100f;\n    private float _batteryDrainRate;\n    private float _lastAttractTime;\n    private Vector3 _rotationCenter;\n    \n    [System.Serializable]\n    public class MetalObject\n    {\n        public GameObject gameObject;\n        public Transform transform;\n        public string metalType;\n        \n        public MetalObject(GameObject go)\n        {\n            gameObject = go;\n            transform = go.transform;\n            metalType = gameObject.GetComponent<Metal>().metalType;\n        }\n    }\n    \n    void Start()\n    {\n        _rotationCenter = transform.position;\n        if (_magnetLight != null)\n            _magnetLight.intensity = _lightIntensity;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_sparkEffect != null)\n            _sparkEffect.Stop();\n            \n        InitializeBatteryDrainRate();\n    }\n    \n    void Update()\n    {\n        HandleRotation();\n        CheckForAttractedObjects();\n        UpdateVisualEffects();\n        UpdateAudio();\n        \n        if (Time.time - _lastAttractTime >= 0.1f && CanDrainBattery())\n        {\n            DrainBattery();\n        }\n    }\n    \n    void InitializeBatteryDrainRate()\n    {\n        _batteryDrainRate = Mathf.Min(_energyConsumptionPerSecond, _maxBatteryDrainRate);\n    }\n    \n    void HandleRotation()\n    {\n        transform.Rotate(Vector3.up * _rotationSpeed * Time.deltaTime);\n    }\n    \n    void CheckForAttractedObjects()\n    {\n        _attractedObjects.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _maxRange, _metalLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Metal\"))\n            {\n                MetalObject attractedObj = new MetalObject(col.gameObject);\n                _attractedObjects.Add(attractedObj);\n                \n                // Check for multiple objects of the same type\n                int existingIndex = -1;\n                for (int i = 0; i < _attractedObjects.Count; i++)\n                {\n                    if (_attractedObjects[i].metalType == attractedObj.metalType)\n                    {\n                        existingIndex = i;\n                        break;\n                    }\n                }\n                \n                if (existingIndex != -1)\n                {\n                    // Increase attraction strength for duplicates\n                    float strengthMultiplier = _attractedObjects.Count - 1;\n                    _attractionStrength *= strengthMultiplier;\n                }\n            }\n        }\n    }\n    \n    void UpdateVisualEffects()\n    {\n        if (_magnetLight != null)\n        {\n            float distanceToClosestMetal = Mathf.Infinity;\n            foreach (var obj in _attractedObjects)\n            {\n                float dist = Vector3.Distance(transform.position, obj.transform.position);\n                if (dist < distanceToClosestMetal)\n                    distanceToClosestMetal = dist;\n            }\n            \n            // Adjust light intensity based on proximity to closest metal\n            if (distanceToClosestMetal <= _maxRange * 0.5f)\n            {\n                _magnetLight.intensity *= 2f;\n            }\n            else if (distanceToClosestMetal > _maxRange * 1.5f)\n            {\n                _magnetLight.intensity = Mathf.Max(_lightIntensity * 0.3f, 0.1f);\n            }\n        }\n        \n        // Update spark effect\n        if (_sparkEffect != null && _attractedObjects.Count > 0)\n        {\n            _sparkEffect.Play();\n        }\n    }\n    \n    void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        float pitchMultiplier = Mathf.Log10(_attractedObjects.Count + 1f);\n        pitchMultiplier = Mathf.Clamp01(pitchMultiplier / 3f); // Scale pitch based on number of attracted objects\n        \n        for (int i = 0; i < _attractedObjects.Count; i++)\n        {\n            if (_attractionSounds[i % _attractionSounds.Length] != null)\n            {\n                float targetPitch = _minPitch + (pitchMultiplier * (_maxPitch - _minPitch));\n                _audioSource.pitch = Mathf.Clamp(targetPitch, 0.1f, _maxPitch);\n                \n                // Play sound with random pitch variation\n                AudioSource.PlayClipAtPoint(_attractionSounds[i % _attractionSounds.Length], transform.position, \n                    new AudioClip[] { _attractionSounds[i % _attractionSounds.Length] }[new System.Random().Next(0, _attractionSounds.Length)]);\n            }\n        }\n    }\n    \n    void DrainBattery()\n    {\n        float currentDrain = _batteryDrainRate * Time.deltaTime;\n        \n        if (currentDrain > 0)\n        {\n            _currentBatteryLevel -= currentDrain * _batteryDrainCurve.Evaluate(currentDrain / _batteryDrainRate);\n            \n            // Smooth battery level\n            float targetDrainRate = Mathf.Lerp(_batteryDrainRate, 0f, _currentBatteryLevel / _batteryCapacity);\n            _batteryDrainRate = targetDrainRate;\n        }\n        \n        if (_currentBatteryLevel <= 0)\n        {\n            _currentBatteryLevel = 0;\n            DisableMagnet();\n        }\n    }\n    \n    void EnableMagnet()\n    {\n        _currentBatteryLevel = _batteryCapacity;\n        _batteryDrainRate = _maxBatteryDrainRate;\n        \n        if (_sparkEffect != null)\n            _sparkEffect.Stop();\n            \n        if (_magnetLight != null)\n            _magnetLight.enabled = true;\n            _magnetLight.intensity = _lightIntensity;\n    }\n    \n    void DisableMagnet()\n    {\n        _currentBatteryLevel = 0;\n        _batteryDrainRate = 0f;\n        \n        if (_sparkEffect != null)\n            _sparkEffect.Stop();\n            \n        if (_magnetLight != null)\n        {\n            _magnetLight.enabled = false;\n            _magnetLight.intensity = 0.1f;\n        }\n    }\n    \n    bool CanDrainBattery()\n    {\n        return _currentBatteryLevel > 0 && _batteryDrainRate > 0;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxRange);\n        \n        Gizmos.color = Color.blue;\n        foreach (var obj in _attractedObjects)\n        {\n            Gizmos.DrawLine(obj.transform.position, transform.position);\n        }\n    }\n    \n    void AddObject(GameObject obj)\n    {\n        MetalObject newObj = new MetalObject(obj);\n        _attractedObjects.Add(newObj);\n        \n        // Check if object is already being attracted\n        bool exists = false;\n        for (int i = 0; i < _attractedObjects.Count; i++)\n        {\n            if (_attractedObjects[i].gameObject == obj)\n                exists = true;\n        }\n        \n        if (!exists)\n        {\n            GameObject clone = obj.clone();\n            Destroy(clone);\n            \n            // Add proper metal component\n            Metal metalScript = new Metal();\n            metalScript.Initialize(newObj.gameObject, newObj.metalType);\n            _attractedObjects[i].gameObject = clone;\n        }\n    }\n    \n    void RemoveObject(GameObject obj)\n    {\n        for (int i = 0; i < _attractedObjects.Count; i++)\n        {\n            if (_attractedObjects[i].gameObject == obj)\n            {\n                _attractedObjects.RemoveAt(i);\n                break;\n            }\n        }\n    }\n    \n    void ResetMagnet()\n    {\n        EnableMagnet();\n        _currentBatteryLevel = _batteryCapacity;\n        _batteryDrainRate = _maxBatteryDrainRate;\n        \n        foreach (var obj in _attractedObjects)\n        {\n            RemoveObject(obj.gameObject);\n        }\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MagneticField : MonoBehaviour\n{\n    [Header(\"Magnetic Settings\")]\n    public float _maxRange = 15f;\n    public float _attractionStrength = 1f;\n    public float _pullForceMultiplier = 2f;\n    public LayerMask _metalLayerMask = -1;\n    public float _minBatteryLevel = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    public GameObject _magneticFieldEffect;\n    public ParticleSystem _cracklingParticles;\n    public Light _fieldLight;\n    public AudioSource _audioSource;\n    public Material _metalMaterialPattern;\n    \n    [Header(\"Audio\")]\n    public AudioClip[] _attractingSounds;\n    public float _soundVolume = 0.3f;\n    public float _soundPitchMultiplier = 1f;\n    \n    [Header(\"Performance\")]\n    private List<MagneticObject> _attachedObjects = new List<MagneticObject>();\n    private Dictionary<MagneticObject, Vector3> _lastPositionCache = new Dictionary<MagneticObject, Vector3>();\n    private Dictionary<MagneticObject, float> _attractionForceCache = new Dictionary<MagneticObject, float>();\n    \n    [System.Serializable]\n    public class MagneticObject\n    {\n        public GameObject gameObject;\n        public string metalType;\n        public float distanceToCenter;\n        public Vector3 lastKnownPosition;\n        public float attractionForce;\n        \n        public MagneticObject(GameObject obj)\n        {\n            gameObject = obj;\n            metalType = obj.GetComponent<Metal>().metalType;\n            distanceToCenter = Vector3.Distance(transform.position, obj.transform.position);\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        UpdateVisualEffects();\n    }\n    \n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_metalLayerMask.value != -1)\n        {\n            _metalLayerMask = (1 << LayerMask.NameToLayer(\"Metal\"));\n        }\n        \n        if (_fieldLight != null)\n        {\n            _fieldLight.enabled = true;\n        }\n    }\n    \n    private void Update()\n    {\n        CheckBatteryLevel();\n        UpdateAttachedObjects();\n        UpdateVisualEffects();\n        UpdateAudioEffects();\n    }\n    \n    private void CheckBatteryLevel()\n    {\n        float currentEnergyConsumption = 0f;\n        \n        foreach (var obj in _attachedObjects)\n        {\n            if (obj.gameObject != null)\n            {\n                // Calculate distance change from last frame\n                Vector3 prevPos = _lastPositionCache[obj];\n                Vector3 currPos = obj.gameObject.transform.position;\n                \n                float distanceChange = Vector3.Distance(prevPos, currPos);\n                currentEnergyConsumption += distanceChange * obj.attractionForce;\n            }\n        }\n        \n        // Apply battery drain\n        if (_audioSource != null)\n        {\n            _audioSource.PlayOneShot(_attractingSounds[Random.Range(0, _attractingSounds.Length)], \n                new System.Collections.Generic.Dictionary<string, float>() { { \"pitch\", _soundPitchMultiplier } });\n            \n            // Clamp sound volume to avoid distortion\n            _audioSource.volume = Mathf.Clamp(_audioSource.volume - (currentEnergyConsumption * 0.01f), 0f, _soundVolume);\n        }\n        \n        // Check low battery warning\n        if (_currentBatteryLevel <= _minBatteryLevel)\n        {\n            Debug.Log(\"Low battery detected! Magnetic field may become unstable.\");\n        }\n    }\n    \n    private void UpdateAttachedObjects()\n    {\n        for (int i = 0; i < _attachedObjects.Count; i++)\n        {\n            var obj = _attachedObjects[i];\n            if (obj.gameObject == null) continue;\n            \n            // Update position cache\n            obj.lastKnownPosition = obj.gameObject.transform.position;\n            \n            // Calculate new attraction force\n            float distanceToCenter = Vector3.Distance(transform.position, obj.gameObject.transform.position);\n            float newForce = CalculateAttractionForce(distanceToCenter, obj.metalType);\n            obj.attractionForce = newForce;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_magneticFieldEffect != null)\n        {\n            _magneticFieldEffect.SetActive(true);\n        }\n        \n        // Update light intensity\n        if (_fieldLight != null && _attachedObjects.Count > 0)\n        {\n            float totalAttraction = 0f;\n            foreach (var obj in _attachedObjects)\n            {\n                if (obj.gameObject != null)\n                    totalAttraction += obj.attractionForce;\n            }\n            \n            // Apply exponential falloff to light intensity\n            float intensityMultiplier = Mathf.Exp(-totalAttraction / (_maxRange * _maxRange));\n            _fieldLight.intensity = intensityMultiplier * 2f; // Base intensity is 2 for strong field\n        }\n        \n        // Update particle effects\n        if (_cracklingParticles != null)\n        {\n            float crackleIntensity = 0f;\n            foreach (var obj in _attachedObjects)\n            {\n                if (obj.gameObject != null && obj.metalType != null)\n                    crackleIntensity += obj.attractionForce * obj.metalType.ToLower() switch\n                    {\n                        \"iron\" | \"steel\" => 1.5f,\n                        \"aluminum\" => 0.8f,\n                        _ => 1f\n                    };\n            }\n            \n            _cracklingParticles.Play();\n            _cracklingParticles.volume = crackleIntensity * 0.05f;\n        }\n        \n        // Update material pattern if available\n        if (_metalMaterialPattern != null)\n        {\n            _metalMaterialPattern.SetColor(\"_MetalColor\", Color.white);\n        }\n    }\n    \n    private void UpdateAudioEffects()\n    {\n        for (int i = 0; i < _attractingSounds.Length; i++)\n        {\n            float pitchMultiplier = Random.Range(0.8f, 1.2f) * _soundPitchMultiplier;\n            _audioSource.pitch = pitchMultiplier;\n            \n            // Play sound with random delay\n            float delay = Random.Range(-0.5f, 0.5f);\n            _audioSource.PlayOneShot(_attractingSounds[i], new System.Collections.Generic.Dictionary<string, float>() { { \"pitch\", pitchMultiplier } });\n        }\n    }\n    \n    private float CalculateAttractionForce(float distanceToCenter, string metalType)\n    {\n        float force = 0f;\n        \n        // Base attraction strength\n        force += _attractionStrength * (1f / distanceToCenter);\n        \n        // Exponential pull factor\n        if (distanceToCenter <= _maxRange * 2f)\n        {\n            force *= Mathf.Pow(_pullForceMultiplier, (1f - distanceToCenter) / _maxRange);\n        }\n        \n        // Metal type modifiers\n        switch (metalType.ToLower())\n        {\n            case \"iron\":\n            case \"steel\":\n                return force * 1.8f;\n            case \"aluminum\":\n                return force * 0.7f;\n            case \"copper\":\n                return force * 2.5f;\n            case \"nickel\":\n                return force * 3f;\n            default:\n                return force;\n        }\n    }\n    \n    public void AttractObject(GameObject obj)\n    {\n        if (obj == null) return;\n        \n        // Check if object is metal\n        Metal metal = obj.GetComponent<Metal>();\n        if (metal == null || string.IsNullOrEmpty(metal.metalType)) return;\n        \n        MagneticObject magneticObj = new MagneticObject(obj);\n        _attachedObjects.Add(magneticObj);\n        \n        // Apply initial attraction force\n        float distanceToCenter = Vector3.Distance(transform.position, obj.transform.position);\n        magneticObj.attractionForce = CalculateAttractionForce(distanceToCenter, metal.metalType.ToLower());\n    }\n    \n    public void DetachObject(MagneticObject magneticObj)\n    {\n        if (!_attachedObjects.Contains(magneticObj)) return;\n        \n        _attachedObjects.Remove(magneticObj);\n        \n        // Update visual effects\n        UpdateVisualEffects();\n        \n        // Remove audio\n        if (_audioSource != null && _attractingSounds.Length > 0)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.Stop();\n        }\n    }\n    \n    public void ResetMagneticField()\n    {\n        _attachedObjects.Clear();\n        _lastPositionCache.Clear();\n        _attractionForceCache.Clear();\n        \n        if (_magneticFieldEffect != null)\n        {\n            _magneticFieldEffect.SetActive(false);\n        }\n        \n        // Disable light\n        if (_fieldLight != null)\n        {\n            _fieldLight.enabled = false;\n        }\n    }\n    \n    private class Metal : MonoBehaviour\n    {\n        [SerializeField] private string _metalType = \"iron\";\n        \n        public string metalType => _metalType.ToLower();\n    }\n}",
    "per_behavior_docs": 14,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "attract_metal_objects": [
        "Camera.CalculateProjectionMatrixFromPhysicalProperties (0.58)",
        "Animator.GetIKHintPositionWeight (0.57)",
        "Physics.ClosestPoint (0.56)"
      ],
      "emit_crackling_sound": [
        "Physics.ContactModifyEventCCD (0.61)",
        "Physics.ContactModifyEvent (0.61)",
        "AudioSource.PlayDelayed (0.59)"
      ],
      "generate_sparks_at_contact": [
        "ParticleSystem.CollisionModule (0.71)",
        "GameObject.InstantiateGameObjects (0.71)",
        "Physics.SphereCastNonAlloc (0.69)"
      ],
      "consume_energy_for_magnetism": [
        "Animator.GetIKHintPositionWeight (0.56)",
        "BatteryStatus (0.56)",
        "ParticleSystem.ForceOverLifetimeModule (0.56)"
      ],
      "dim_glow_based_on_energy": [
        "Light.Reset (0.60)",
        "Light.SetLightDirty (0.60)",
        "LightBakingOutput (0.58)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 57.5,
        "justification": "Direct translation with decent structure, but lacks some modularity and has incomplete implementation. Uses standard Unity patterns but has abrupt code cutoff."
      },
      "ir_monolithic": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 72,
        "justification": "More structured approach with clear separation of concerns, robust Unity component design, and thoughtful implementation of magnetic object tracking and battery mechanics."
      },
      "ir_per_behavior": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 7,
        "weighted_total": 70,
        "justification": "Highly modular design with granular method decomposition, excellent extensibility, and careful consideration of performance and state management."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the most balanced implementation with clear component design, better encapsulation of magnetic object logic, and more comprehensive battery/attraction mechanics.",
      "advantages": "Uses an intermediate representation to create a more structured approach, provides clear serialization points, implements complex behaviors with clean separation, and offers better scaffolding for future feature additions."
    },
    "error": null
  },
  {
    "prompt_num": 3,
    "prompt": "Make an underwater bubble generator that releases bubbles of varying sizes every half second, each bubble rises with realistic physics wobble, pops with a satisfying sound when touched or reaching surface, and leaves a brief shimmer effect where it popped.",
    "timestamp": "2026-01-08T21:48:22.839829",
    "oneshot_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class UnderwaterBubbleGenerator : MonoBehaviour\n{\n    [Header(\"Bubble Settings\")]\n    [SerializeField] private int _bubbleInterval = 500; // ms\n    [SerializeField] private float _maxBubbleSize = 0.5f;\n    [SerializeField] private float _minBubbleSize = 0.02f;\n    [SerializeField] private bool _useRandomSizes = true;\n    \n    [Header(\"Bubble Behavior\")]\n    [SerializeField] private bool _enableWobble = true;\n    [SerializeField] private float _wobbleSpeed = 2f;\n    [SerializeField] private float _wobbleAmplitude = 0.1f;\n    [SerializeField] private float _riseSpeed = 5f;\n    \n    [Header(\"Popping Effects\")]\n    [SerializeField] private AudioClip[] _popSounds;\n    [SerializeField] private float _popVolume = 0.3f;\n    [SerializeField] private bool _enableRandomPopSounds = true;\n    [SerializeField] private float _maxRiseDistance = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem[] _bubbleParticles;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private float _shimmerDuration = 0.1f;\n    [SerializeField] private Color _shimmerColor = Color.cyan;\n    [SerializeField] private int _shimmerCount = 50;\n    \n    private AudioSource _audioSource;\n    private Rigidbody2D _bubbleRigidbody;\n    private List<BubbleData> _pendingBubbles = new List<BubbleData>();\n    private float _nextBubbleTime;\n    private Vector3[] _wobbleOffsets = new Vector3[10];\n    \n    [System.Serializable]\n    public class BubbleData\n    {\n        public GameObject bubbleObject;\n        public float size;\n        public float riseDistance;\n        public float timeToRise;\n        public int wobbleIndex;\n        \n        public BubbleData(GameObject obj, float sz, float rd, float td)\n        {\n            bubbleObject = obj;\n            size = sz;\n            riseDistance = rd;\n            timeToRise = td;\n            wobbleIndex = Random.Range(0, _wobbleOffsets.Length);\n        }\n    }\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _bubbleRigidbody = GetComponent<Rigidbody2D>();\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n        \n        GenerateInitialWobbleOffsets();\n    }\n    \n    void Update()\n    {\n        if (Time.time < _nextBubbleTime) return;\n        \n        _nextBubbleTime += _bubbleInterval;\n        \n        if (Time.time >= _nextBubbleTime)\n        {\n            SpawnNextBubble();\n        }\n    }\n    \n    private void GenerateInitialWobbleOffsets()\n    {\n        for (int i = 0; i < _wobbleOffsets.Length; i++)\n        {\n            float angle = Random.Range(0f, 2 * Mathf.PI);\n            _wobbleOffsets[i] = new Vector3(\n                Mathf.Cos(angle) * _wobbleAmplitude,\n                Mathf.Sin(angle) * _wobbleAmplitude,\n                0\n            );\n        }\n    }\n    \n    private void SpawnNextBubble()\n    {\n        GameObject bubble;\n        float size;\n        float riseDistance;\n        float timeToRise;\n        int wobbleIndex;\n        \n        if (_useRandomSizes)\n        {\n            size = Random.Range(_minBubbleSize, _maxBubbleSize);\n            riseDistance = Random.Range(0.1f, _maxRiseDistance);\n            timeToRise = riseDistance / _riseSpeed;\n            \n            bubble = CreateBubble(size, false);\n        }\n        else\n        {\n            float baseSize = 0.3f;\n            size = baseSize + (Random.value * (_maxBubbleSize - baseSize));\n            riseDistance = 0.5f + (Random.value * (1.5f - 0.5f));\n            timeToRise = riseDistance / _riseSpeed;\n            \n            bubble = CreateBubble(size, true);\n        }\n        \n        wobbleIndex = Random.Range(0, _wobbleOffsets.Length);\n        \n        BubbleData bubbleData = new BubbleData(bubble, size, riseDistance, timeToRise);\n        bubbleData.wobbleIndex = wobbleIndex;\n        \n        _pendingBubbles.Add(bubbleData);\n    }\n    \n    private GameObject CreateBubble(float size, bool useRandomPosition)\n    {\n        GameObject bubbleObj = new GameObject(\"UnderwaterBubble\");\n        \n        // Create bubble mesh\n        BubbleMesh[] meshes = new BubbleMesh[10];\n        for (int i = 0; i < meshes.Length; i++)\n        {\n            MeshData data = GenerateBubbleMesh();\n            BubbleMesh bubbleMesh = new BubbleMesh(data);\n            bubbleMesh.size = size;\n            bubbleMesh.color = randomColor();\n            bubbleObj.AddComponent<BubbleMesh>().bubbleMesh = bubbleMesh;\n            meshes[i] = bubbleMesh;\n        }\n        \n        // Add particles\n        ParticleSystem particleSystem;\n        if (_bubbleParticles != null)\n        {\n            particleSystem = _bubbleParticles[Random.Range(0, _bubbleParticles.Length)];\n        }\n        else\n        {\n            particleSystem = new ParticleSystem();\n            particleSystem.transform.SetParent(bubbleObj.transform);\n            particleSystem.Play();\n            \n            BubbleParticleData[] data = new BubbleParticleData[10];\n            for (int i = 0; i < data.Length; i++)\n            {\n                data[i] = GenerateBubbleParticle();\n            }\n            particleSystem.PlayOnAwake(data, 50);\n        }\n        \n        // Add trail renderer\n        TrailRenderer trailRenderer;\n        if (_trailRenderer != null)\n        {\n            trailRenderer = new TrailRenderer();\n            trailRenderer.transform.SetParent(bubbleObj.transform);\n            trailRenderer.enabled = true;\n            trailRenderer.startWidth = size * 0.8f;\n            trailRenderer.endWidth = size * 1.2f;\n            trailRenderer.color = randomColor();\n            trailRenderer.startHeight = -size + 0.5f;\n            trailRenderer.endHeight = 0.5f;\n        }\n        \n        // Add rigidbody\n        Rigidbody2D rb = bubbleObj.AddComponent<Rigidbody2D>();\n        rb.drag = 1f;\n        rb.angularDrag = 5f;\n        \n        // Position\n        Vector3 pos;\n        if (useRandomPosition)\n        {\n            float x = Random.Range(-_maxBubbleSize * 0.8f, _maxBubbleSize * 0.8f);\n            float y = -size + 0.5f + Random.Range(0.1f, 0.3f);\n            pos = new Vector3(x, y, 0);\n        }\n        else\n        {\n            pos = transform.position;\n        }\n        \n        bubbleObj.transform.position = pos;\n        return bubbleObj;\n    }\n    \n    private Color randomColor()\n    {\n        float h = Random.Range(0f, 360f);\n        return Color.HSVToRGB(h / 360f, 1f, 1f);\n    }\n    \n    private BubbleParticleData GenerateBubbleParticle()\n    {\n        BubbleParticleData particle = new BubbleParticleData();\n        particle.size = new Random.Range(0.01f, 0.3f);\n        particle.color = randomColor();\n        particle.velocity = new Vector2(Random.Range(-5f, 5f), Random.Range(-8f, -12f));\n        return particle;\n    }\n    \n    private MeshData GenerateBubbleMesh()\n    {\n        MeshData mesh = new MeshData();\n        mesh.triangleCount = 6;\n        \n        // Define vertices\n        Vector3[] vertices = new Vector3[18];\n        int[] triangles = new int[36];\n        \n        float radius = size * 0.7f;\n        float height = size * 0.5f;\n        \n        for (int i = 0; i < 6; i++)\n        {\n            float angle = i * Mathf.PI * 2f / 6f;\n            vertices[3 + i] = new Vector3(\n                radius * Mathf.Cos(angle),\n                height,\n                radius * Mathf.Sin(angle)\n            );\n        }\n        \n        // Bottom triangles\n        for (int i = 0; i < 6; i++)\n        {\n            int v1 = 3 + i;\n            int v2 = 3 + (i + 1) % 6;\n            int v3 = 3 + (i + 2) % 6;\n            triangles[i * 6] = v1 + 1 + v2 + 1 + v3;\n        }\n        \n        // Top triangles\n        for (int i = 0; i < 6; i++)\n        {\n            int v1 = 9 + i;\n            int v2 = 9 + (i + 1) % 6;\n            int v3 = 9 + (i + 2) % 6;\n            triangles[i * 6 + 6] = v1 + 1 + v2 + 1 + v3;\n        }\n        \n        mesh.vertices = vertices;\n        mesh.triangles = triangles;\n        mesh.scale = new Vector3(size * 0.8f, size * 0.5f, size * 0.7f);\n        return mesh;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        \n        // Draw bubble trail\n        if (_trailRenderer != null)\n        {\n            for (int i = 0; i < _pendingBubbles.Count; i++)\n            {\n                BubbleData bubbleData = _pendingBubbles[i];\n                Vector3 start = new Vector3(\n                    bubbleData.bubbleObject.transform.position.x,\n                    -bubbleData.bubbleSize + 0.5f\n                );\n                Vector3 end = start;\n                \n                // Add wobble to trail points\n                for (int j = 0; j < 10; j++)\n                {\n                    float offset = Mathf.Sin(Time.time * _wobbleSpeed + j * Mathf.PI) *\n                        _wobbleOffsets[j].x;\n                    end.x += offset;\n                }\n                \n                Gizmos.DrawLine(start, end);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            PopBubble(other.gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.collider.CompareTag(\"Player\") || collision.collider.CompareTag(\"Enemy\"))\n        {\n            PopBubble(collision.collider.gameObject);\n        }\n    }\n    \n    private void PopBubble(GameObject bubble)\n    {\n        // Remove bubble object\n        Destroy(bubble);\n        \n        // Play pop sound\n        if (_popSounds != null && _enableRandomPopSounds)\n        {\n            int index = Random.Range(0, _popSounds.Length);\n            _audioSource.PlayOneShot(_popSounds[index], _popVolume);\n        }\n        else if (_popSounds != null)\n        {\n            _audioSource.PlayOneShot(_popSounds[0], _popVolume);\n        }\n        \n        // Create shimmer effect\n        CreateShimmerEffect(bubble.transform.position, _shimmerDuration);\n    }\n    \n    private void CreateShimmerEffect(Vector3 position, float duration)\n    {\n        if (_trailRenderer == null) return;\n        \n        TrailRenderer shimmer = new TrailRenderer();\n        shimmer.transform.position = position;\n        shimmer.enabled = true;\n        shimmer.startWidth = 0.1f;\n        shimmer.endWidth = 0.3f;\n        shimmer.color = _shimmerColor;\n        shimmer.startHeight = -0.5f;\n        shimmer.endHeight = 0.5f;\n        \n        shimmer.transform.rotation = Quaternion.Euler(0, Random.Range(-45f, 45f), 0);\n        \n        // Add multiple particles for shimmer\n        ParticleSystem particleSystem = new ParticleSystem();\n        particleSystem.transform.SetParent(shimmer.transform);\n        particleSystem.PlayOnAwake(CreateShimmerParticles(_shimmerCount), duration * 20);\n    }\n    \n    private void CreateShimmerParticles(int count)\n    {\n        List<BubbleParticleData> particles = new List<BubbleParticleData>();\n        for (int i = 0; i < count; i++)\n        {\n            BubbleParticleData particle = new BubbleParticleData();\n            particle.size = new Random.Range(0.01f, 0.05f);\n            particle.color = _shimmerColor;\n            particle.velocity = new Vector2(\n                Mathf.Sin(Random.value * 2f) * 3f,\n                Mathf.Cos(Random.value * 2f) * 4f\n            );\n            particles.Add(particle);\n        }\n        return particles;\n    }\n    \n    [System.Serializable]\n    public class BubbleMesh : MonoBehaviour\n    {\n        public MeshData meshData;\n        \n        private void Awake()\n        {\n            if (meshData == null)\n                meshData = GenerateBubbleMesh();\n        }\n    }\n    \n    [System.Serializable]\n    public class MeshData\n    {\n        public int triangleCount;\n        public Vector3[] vertices;\n        public int[] triangles;\n        public float scale;\n        \n        private void Initialize()\n        {\n            vertices = new Vector3[triangleCount * 6];\n            triangles = new int[triangleCount * 2];\n        }\n        \n        public MeshData GenerateBubbleMesh()\n        {\n            BubbleMeshData data = new BubbleMeshData();\n            \n            data.triangleCount = 6;\n            data.vertices = new Vector3[]\n            {\n                // Bottom\n                Vector3.one * 0.8f,\n                Vector3.one * 0.5f,\n                Vector3.one * -0.7f,\n                \n                Vector3.one * 1f,\n                Vector3.one * 0.5f,\n                Vector3.one * -0.7f,\n                \n                Vector3.one * 0.8f,\n                Vector3.one * 0.5f,\n                Vector3.one * -0.7f\n            };\n            \n            data.triangles = new int[]\n            {\n                // Bottom triangles\n                0, 1, 2,\n                2, 3, 0,\n                0, 3, 1\n                \n                // Top triangles (projected)\n                4, 5, 6,\n                6, 7, 4,\n                4, 7, 5\n            };\n            \n            data.scale = new Vector3(0.8f, 0.5f, -0.7f);\n            return data;\n        }\n    }\n    \n    [System.Serializable]\n    public class BubbleParticleData\n    {\n        public float size;\n        public Vector2 velocity;\n        public Color color;\n        public float lifetime;\n        \n        private void Initialize()\n        {\n            lifetime = Random.Range(0.01f, 0.3f);\n        }\n    }\n    \n    [System.Serializable]\n    public class BubbleMeshData : MeshData\n    {\n        private Vector3[] _vertices;\n        private int[] _triangles;\n        \n        public override Vector3[] vertices => _vertices;\n        public override int[] triangles => _triangles;\n        \n        public BubbleMeshData()\n        {\n            Initialize();\n            GenerateBubbleMesh();\n        }\n        \n        private void GenerateBubbleMesh()\n        {\n            float radius = size * 0.7f;\n            float height = size * 0.5f;\n            \n            _vertices = new Vector3[]\n            {\n                // Bottom\n                new Vector3(-radius, height, -radius),\n                new Vector3(radius, height, -radius),\n                new Vector3(0, height + 1f, 0),\n                \n                // Top\n                new Vector3(-radius * 0.8f, height * 0.5f, -radius * 0.7f),\n                new Vector3(radius * 0.8f, height * 0.5f, radius * 0.7f),\n                new Vector3(0, height * 0.25f, 0)\n            };\n            \n            _triangles = new int[]\n            {\n                // Bottom triangles\n                0, 1, 2,\n                2, 3, 0,\n                0, 3, 1\n                \n                // Top triangles (projected)\n                4, 5, 6,\n                6, 7, 4,\n                4, 7, 5\n            };\n        }\n    }",
    "ir_json": {
      "class_name": "UnderwaterBubbleGenerator",
      "components": [
        "ParticleSystem",
        "AudioSource",
        "MeshRenderer"
      ],
      "fields": [
        {
          "name": "bubbleSpawnInterval",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "maxBubbleCount",
          "type": "int",
          "default": 20
        },
        {
          "name": "bubblePrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "popSoundClip",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "spawn_bubbles",
          "trigger": "every bubble spawn interval seconds",
          "actions": [
            {
              "action": "instantiate bubble object using prefab settings"
            },
            {
              "action": "apply random size variation to bubble mesh"
            },
            {
              "action": "position bubble at underwater starting point"
            }
          ]
        },
        {
          "name": "animate_bubbles_upward",
          "trigger": "when bubble exists and underwater",
          "actions": [
            {
              "action": "apply upward buoyancy force to simulate rise motion"
            },
            {
              "action": "add random wobble movement for realism"
            }
          ]
        },
        {
          "name": "check_for_collision",
          "trigger": "continuously while bubbles exist",
          "actions": [
            {
              "action": "detect collision with any object above current bubble position"
            }
          ]
        },
        {
          "name": "handle_bubble_touching_surface",
          "trigger": "when bubble collides with surface boundary and is below surface",
          "actions": [
            {
              "action": "play popping sound effect"
            },
            {
              "action": "destroy bubble object"
            },
            {
              "action": "create shimmer effect at collision point for brief duration"
            }
          ]
        },
        {
          "name": "handle_bubble_touching_object",
          "trigger": "when bubble collides with any other solid object and is below surface",
          "actions": [
            {
              "action": "play popping sound effect"
            },
            {
              "action": "create shimmer effect at collision point for brief duration"
            }
          ]
        },
        {
          "name": "pop_bubble_safely",
          "trigger": "when bubble loses buoyancy or reaches surface and is no longer animated upward",
          "actions": [
            {
              "action": "play popping sound effect"
            },
            {
              "action": "create shimmer effect at bubble center for brief duration"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class UnderwaterBubbleGenerator : MonoBehaviour\n{\n    [Header(\"Bubble Settings\")]\n    [SerializeField] private float _spawnInterval = 0.3f;\n    [SerializeField] private int _maxBubbles = 8;\n    [SerializeField] private GameObject _bubblePrefab;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _popSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Water Detection\")]\n    [SerializeField] private LayerMask _waterLayer = -1;\n    [SerializeField] private bool _enableWaterDetection = true;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private int _maxActiveBubbles = 16;\n    [SerializeField] private float _destroyDelay = 0.5f;\n    \n    private List<UnderwaterBubble> _activeBubbles = new List<UnderwaterBubble>();\n    private Coroutine _spawnCoroutine;\n    private AudioSource _audioSource;\n    private ParticleSystem _bubbleParticleSystem;\n    private float _nextSpawnTime;\n    private int _currentSpawnCount = 0;\n    \n    [System.Serializable]\n    public class UnderwaterBubble\n    {\n        [Header(\"Bubble Data\")]\n        [SerializeField] private Transform _bubbleTransform;\n        [SerializeField] private float _originalScale;\n        [SerializeField] private ParticleSystem _particleSystem;\n        \n        [Header(\"Movement\")]\n        [SerializeField] private float _riseSpeed = 2f;\n        [SerializeField] private float _wobbleAmount = 0.1f;\n        [SerializeField] private bool _enableWobble = true;\n        \n        [Header(\"Collision\")]\n        [SerializeField] private string[] _colliderTags = { \"Water\", \"Surface\" };\n    }\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupBubbleParticleSystem();\n        InitializeBubbles();\n        \n        if (!_enableWaterDetection || !_waterLayer.value)\n        {\n            StartCoroutine(SpawnBubbleCoroutine());\n        }\n    }\n    \n    void SetupBubbleParticleSystem()\n    {\n        if (_bubblePrefab != null)\n        {\n            _bubbleParticleSystem = Instantiate(_bubblePrefab.GetComponent<ParticleSystem>());\n            \n            // Configure main module\n            var main = _bubbleParticleSystem.main;\n            main.startLifetime = 5f;\n            main.startSize = 0.1f;\n            main.startSpeed = 2f;\n            main.startColor = Color.white;\n            main.startPulse = false;\n            main.startEmission = true;\n            \n            // Configure emission\n            var emission = _bubbleParticleSystem.emission;\n            emission.enabled = false; // Use main module for emission count\n            \n            // Add velocity over lifetime\n            main.addForceOverLifetime(new ParticleSystemAddForceOverLifetime[] { \n                new ParticleSystemAddForceOverLifetime { force = 5f, direction = Vector3.up } \n            }, 0.1f);\n            \n            // Add random variation\n            var random = _bubbleParticleSystem.random;\n            random.enabled = true;\n            random.min = -0.2f;\n            random.max = 0.2f;\n        }\n    }\n    \n    void InitializeBubbles()\n    {\n        if (_bubblePrefab != null)\n        {\n            for (int i = 0; i < _maxActiveBubbles; i++)\n            {\n                GameObject bubbleObject = Instantiate(_bubblePrefab);\n                UnderwaterBubble bubble = bubbleObject.GetComponent<UnderwaterBubble>();\n                \n                if (bubble == null)\n                {\n                    bubble = bubbleObject.AddComponent<UnderwaterBubble>();\n                }\n                \n                // Setup bubble transform\n                bubble._bubbleTransform = bubbleObject.transform;\n                bubble._originalScale = bubbleObject.transform.localScale;\n                bubble._particleSystem = _bubbleParticleSystem;\n                \n                // Position under water surface\n                float randomY = Random.Range(-6f, -2f);\n                bubble._bubbleTransform.position = new Vector3(0, randomY, 0);\n                bubble._bubbleTransform.rotation = Quaternion.identity;\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_enableWaterDetection && CanBeUnderwater(other.gameObject))\n        {\n            // Bubble touched water surface\n            HandleBubbleOnSurface(other.gameObject);\n        }\n    }\n    \n    bool CanBeUnderwater(GameObject target)\n    {\n        return _waterLayer.value && Physics.Raycast(transform.position, Vector3.down, out RaycastHit hit, 10f, target == null ? LayerMask.Default : target.layer) \n               && (hit.collider.tag == \"Water\" || hit.collider.CompareTag(\"Surface\"));\n    }\n    \n    void HandleBubbleOnSurface(GameObject target)\n    {\n        UnderwaterBubble bubble = target.GetComponent<UnderwaterBubble>();\n        \n        if (bubble != null)\n        {\n            // Play pop sound\n            PlaySound(_popSound, _audioVolume);\n            \n            // Destroy bubble with delay\n            StartCoroutine(DestroyBubbleWithDelay(bubble));\n            \n            // Add shimmer effect at collision point\n            CreateShimmerEffectAtSurfacePoint(target.transform.position);\n        }\n    }\n    \n    IEnumerator DestroyBubbleWithDelay(UnderwaterBubble bubble)\n    {\n        yield return new WaitForSeconds(_destroyDelay);\n        \n        // Clean up components\n        if (bubble._particleSystem != null)\n        {\n            Destroy(bubble._particleSystem);\n        }\n        \n        // Remove from active bubbles list\n        _activeBubbles.Remove(bubble);\n        \n        // Destroy the bubble object after delay\n        yield return new WaitForSeconds(0.1f);\n        Destroy(bubble._bubbleTransform.gameObject);\n    }\n    \n    void CreateShimmerEffectAtSurfacePoint(Vector3 position)\n    {\n        // Placeholder for shimmer effect implementation using Light\n        GameObject shimmerObject = new GameObject(\"Underwater Shimmer\");\n        \n        // Position shimmer object under water surface\n        float randomY = Random.Range(-2f, 0f);\n        shimmerObject.transform.position = new Vector3(position.x, randomY, position.z + 0.5f);\n        \n        // Add light component with flickering intensity\n        Light underwaterLight = shimmerObject.AddComponent<Light>();\n        underwaterLight.type = LightType.Point;\n        underwaterLight.intensity = 1.5f;\n        underwaterLight.color = Color.cyan;\n        \n        // Create animation for flickering\n        float baseIntensity = 0.8f;\n        float targetIntensity = 1.2f;\n        float duration = 0.3f;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            underwaterLight.intensity = Mathf.Lerp(baseIntensity, targetIntensity, elapsed / duration);\n            elapsed += Time.deltaTime;\n        }\n        \n        // Destroy shimmer object after brief display\n        StartCoroutine(DestroyShimmerObject(shimmerObject));\n    }\n    \n    IEnumerator DestroyShimmerObject(GameObject obj)\n    {\n        yield return new WaitForSeconds(0.05f);\n        Destroy(obj);\n    }\n    \n    System.Collections.IEnumerator SpawnBubbleCoroutine()\n    {\n        while (_currentSpawnCount < _maxBubbles)\n        {\n            float timeToWait = _nextSpawnTime;\n            \n            if (!_enableWaterDetection || timeToWait <= 0f)\n            {\n                yield break;\n            }\n            \n            timeToWait += Random.Range(0.1f, 0.5f);\n            _nextSpawnTime = Mathf.Max(timeToWait + _spawnInterval, Time.time);\n            \n            CreateBubbleObject();\n            _currentSpawnCount++;\n        }\n    }\n    \n    void CreateBubbleObject()\n    {\n        GameObject bubbleObject = new GameObject(\"Underwater Bubble\");\n        UnderwaterBubble bubble = bubbleObject.AddComponent<UnderwaterBubble>();\n        \n        // Spawn bubble at underwater position\n        float randomY = Random.Range(-6f, -2f);\n        bubble._bubbleTransform.position = new Vector3(0, randomY, 0);\n        bubble._bubbleTransform.rotation = Quaternion.identity;\n        \n        // Add particle system to bubble\n        if (_bubblePrefab != null)\n        {\n            bubble._particleSystem = _bubbleParticleSystem;\n            bubble._bubbleTransform.gameObject.AddComponent<ParticleSystem>();\n            \n            // Configure main module for emission count\n            var main = bubble._particleSystem.main;\n            main.startLifetime = 3f;\n            main.startSize = 0.05f;\n            main.startSpeed = 1f;\n            main.startColor = Color.white;\n            main.startPulse = false;\n            main.startEmission = true;\n            \n            // Add emission count\n            var emission = bubble._particleSystem.emission;\n            emission.enabled = true;\n            emission.count = Random.Range(5, 15);\n        }\n        \n        _activeBubbles.Add(bubble);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        \n        // Draw water surface\n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, Vector3.down, out hit, 10f, _waterLayer.value))\n        {\n            float surfaceY = hit.point.y;\n            Gizmos.DrawWireCube(hit.point + new Vector3(0.5f, 0, 0), new Vector3(1f, 1f, 1f));\n        }\n        \n        // Draw bubble spawn points\n        for (int i = 0; i < _maxActiveBubbles; i++)\n        {\n            UnderwaterBubble bubble = _activeBubbles[i];\n            if (bubble != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawWireSphere(bubble._bubbleTransform.position, 0.3f);\n            }\n        }\n    }\n    \n    void PlaySound(AudioClip clip, float volume)\n    {\n        if (_audioSource == null || clip == null) return;\n        \n        _audioSource.PlayOneShot(clip, volume);\n    }\n    \n    void OnApplicationPause(bool pause)\n    {\n        // Clean up when game pauses\n        for (int i = 0; i < _activeBubbles.Count; i++)\n        {\n            UnderwaterBubble bubble = _activeBubbles[i];\n            if (bubble == null) continue;\n            \n            StartCoroutine(DestroyBubbleWithDelay(bubble));\n        }\n    }\n    \n    void OnDestroy()\n    {\n        // Stop spawn coroutine\n        if (_spawnCoroutine != null)\n        {\n            StopCoroutine(_spawnCoroutine);\n            _spawnCoroutine = null;\n        }\n        \n        // Destroy all active bubbles\n        foreach (UnderwaterBubble bubble in _activeBubbles)\n        {\n            StartCoroutine(DestroyBubbleWithDelay(bubble));\n        }\n    }\n    \n    void OnDestroy(object state)\n    {\n        if (_spawnCoroutine != null)\n        {\n            StopCoroutine(_spawnCoroutine);\n            _spawnCoroutine = null;\n        }\n        \n        foreach (UnderwaterBubble bubble in _activeBubbles)\n        {\n            StartCoroutine(DestroyBubbleWithDelay(bubble));\n        }\n    }\n    \n    void ForEachActiveBubble(Action<UnderwaterBubble> action)\n    {\n        for (int i = 0; i < _activeBubbles.Count; i++)\n        {\n            UnderwaterBubble bubble = _activeBubbles[i];\n            if (bubble == null) continue;\n            action(bubble);\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 6,
    "ir_rag_doc_names": [
      "ParticleSystem.TriggerSubEmitter (0.63)",
      "ParticleSystem.TextureSheetAnimationModule (0.61)",
      "ParticleSystem.GetPlaybackState (0.61)",
      "ParticleSystemShapeMultiModeValue.BurstSpread (0.44)",
      "ParticleSystemShapeMultiModeValue.PingPong (0.42)",
      "ParticleSystemShapeMultiModeValue.Loop (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class UnderwaterBubbleGenerator : MonoBehaviour\n{\n    [Header(\"Bubble Settings\")]\n    public float spawnInterval = 1f;\n    public int maxBubbles = 10;\n    public float bubbleSizeMin = 0.05f;\n    public float bubbleSizeMax = 0.3f;\n    public float riseSpeed = 2f;\n    public float wobbleFrequency = 5f;\n    public float wobbleAmplitude = 0.1f;\n    \n    [Header(\"Audio\")]\n    public AudioClip[] bubbleSounds;\n    public float pitchVariation = 1f;\n    public float volumeVariation = 0.8f;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem[] shimmerEffects;\n    public float shimmerDuration = 0.2f;\n    public Color baseColor = Color.cyan;\n    public AnimationCurve wobbleCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    private Rigidbody rb;\n    private AudioSource audioSource;\n    private Collider[] bubbleColliders;\n    private float nextSpawnTime;\n    private int currentBubbleCount = 0;\n    private bool canSpawn = true;\n    \n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        audioSource = GetComponent<AudioSource>();\n        \n        if (audioSource == null)\n        {\n            audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        bubbleColliders = new Collider[maxBubbles];\n        for (int i = 0; i < maxBubbles; i++)\n        {\n            bubbleColliders[i] = gameObject.AddComponent<BoxCollider>();\n        }\n    }\n    \n    void Update()\n    {\n        if (!canSpawn || Time.time < nextSpawnTime)\n        {\n            canSpawn = true;\n            return;\n        }\n        \n        if (Input.GetKeyDown(KeyCode.Space) && currentBubbleCount < maxBubbles)\n        {\n            SpawnUnderwaterBubble();\n            currentBubbleCount++;\n        }\n        \n        UpdateBubbles();\n    }\n    \n    void SpawnUnderwaterBubble()\n    {\n        GameObject bubbleObject = CreateBubbleObject();\n        BubbleCollider bubbleCollider = bubbleObject.AddComponent<BoxCollider>();\n        bubbleCollider.isTrigger = true;\n        \n        Rigidbody rbBubble = bubbleObject.GetComponent<Rigidbody>();\n        if (rbBubble == null)\n        {\n            rbBubble = bubbleObject.AddComponent<Rigidbody>();\n        }\n        \n        float randomPitch = Random.Range(0.8f, 1.2f);\n        float randomVolume = Random.Range(volumeVariation * 0.5f, volumeVariation * 1.5f);\n        audioSource.pitch = randomPitch;\n        audioSource.volume = randomVolume;\n        \n        // Apply initial wobble\n        Vector3 startPosition = bubbleObject.transform.position;\n        float wobbleAngle = Mathf.Sin(Time.time * wobbleFrequency) * wobbleAmplitude;\n        startPosition.x += Mathf.Cos(wobbleAngle + Time.time * wobbleFrequency) * wobbleAmplitude;\n        bubbleObject.transform.position = startPosition;\n        \n        // Add upward movement\n        rbBubble.velocity = new Vector3(0, -riseSpeed * Random.Range(0.9f, 1.1f), 0);\n    }\n    \n    GameObject CreateBubbleObject()\n    {\n        GameObject bubble = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        Renderer bubbleRenderer = bubble.GetComponent<Renderer>();\n        \n        if (bubbleRenderer == null)\n        {\n            bubbleRenderer = bubble.AddComponent<ShaderMaterial>();\n            bubbleRenderer.material = Resources.Load<ShaderMaterial>(\"Default Material\");\n        }\n        \n        bubbleRenderer.material.color = baseColor;\n        bubbleRenderer.enabled = false;\n        \n        return bubble;\n    }\n    \n    void UpdateBubbles()\n    {\n        for (int i = 0; i < currentBubbleCount; i++)\n        {\n            float time = Time.time - bubbleColliders[i].transform.position.y / riseSpeed;\n            \n            // Wobble movement\n            Vector3 wobbleOffset = new Vector3(\n                Mathf.Sin(time * wobbleFrequency) * wobbleAmplitude,\n                0f,\n                Mathf.Cos(time * wobbleFrequency + 2f * Mathf.PI * i) * wobbleAmplitude\n            );\n            \n            bubbleColliders[i].transform.position += wobbleOffset;\n        }\n        \n        // Check for surface collision and pop bubbles\n        for (int i = currentBubbleCount - 1; i >= 0; i--)\n        {\n            if (!bubbleColliders[i].isTrigger)\n                continue;\n                \n            float waterSurfaceHeight = transform.position.y + 2f; // Adjust based on scene setup\n            float bubbleTopY = bubbleColliders[i].transform.position.y + bubbleSizeMin * 0.5f;\n            \n            if (bubbleTopY >= waterSurfaceHeight)\n            {\n                BubblePop(i);\n                break;\n            }\n        }\n    }\n    \n    void BubblePop(int bubbleIndex)\n    {\n        GameObject bubbleObject = bubbleColliders[bubbleIndex].gameObject;\n        \n        // Apply explosive burst\n        Vector3 explosionDirection = -transform.up;\n        float explosionForce = 100f * Mathf.Pow(bubbleSizeMin, 2) / 10f;\n        rb.GetComponent<Rigidbody>().AddExplosionForces(explosionDirection, explosionForce, 0.1f);\n        \n        // Create visual effects\n        if (shimmerEffects.Length > 0)\n        {\n            shimmerEffects[bubbleIndex % shimmerEffects.Length].play();\n        }\n        \n        // Play popping sound\n        if (bubbleSounds != null && bubbleSounds.Length > 0)\n        {\n            float randomPitch = Random.Range(1.5f, 2.5f);\n            audioSource.pitch = randomPitch;\n            audioSource.PlayOneShot(bubbleSounds[bubbleIndex % bubbleSounds.Length]);\n        }\n        \n        // Remove collider\n        bubbleObject.SendMessage(\"Destroy\", true);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        for (int i = 0; i < currentBubbleCount; i++)\n        {\n            Vector3 wobbleOffset = new Vector3(\n                Mathf.Sin(Time.time * wobbleFrequency) * wobbleAmplitude,\n                0f,\n                Mathf.Cos(Time.time * wobbleFrequency + 2f * Mathf.PI * i) * wobbleAmplitude\n            );\n            \n            Gizmos.DrawWireCube(transform.position + wobbleOffset, bubbleSizeMin);\n        }\n    }\n}",
    "per_behavior_docs": 13,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "spawn_underwater_bubble": [
        "Physics.SphereCastNonAlloc (0.67)",
        "GameObject.InstantiateGameObjects (0.66)",
        "Physics.SphereCast (0.66)"
      ],
      "play_bubble_sound": [
        "GameObject.InstantiateGameObjects (0.72)",
        "Random.Range (0.69)",
        "GameObject.CreatePrimitive (0.67)"
      ],
      "detect_touch Interaction": [
        "ParticleSystem.Play (0.77)",
        "ParticleSystem.GetPlaybackState (0.75)",
        "ParticleSystem.Burst (0.74)"
      ],
      "surface_pop Animation": [
        "GameObject.InstantiateGameObjects (0.67)",
        "Object.FindObjectsOfTypeIncludingAssets (0.64)",
        "Animation.PlayQueued (0.64)"
      ],
      "shimmer_effect": [
        "Light.SetLightDirty (0.69)",
        "Light.AddCommandBufferAsync (0.67)",
        "Light.AddCommandBuffer (0.65)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 53,
        "justification": "Good initial structure with serialized fields and clear class organization, but incomplete implementation. Has nice touches like wobble offset generation, but code snippet cuts off mid-implementation."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 68,
        "justification": "Very strong Unity-specific patterns, excellent use of serialized fields, modular component design. Demonstrates sophisticated particle system configuration and thoughtful water detection approach."
      },
      "ir_per_behavior": {
        "architecture": 5,
        "fixability": 6,
        "unity_patterns": 6,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 57,
        "justification": "Good individual method implementations, but less cohesive overall. Strong correctness in individual behaviors like spawning and movement, but lacks unified design."
      },
      "winner": "ir_monolithic",
      "key_differences": "Intermediate representation allowed more systematic decomposition of requirements, resulting in more structured and configurable code",
      "advantages": "Best balance of modularity, Unity best practices, and comprehensive feature coverage with clear extension points"
    },
    "error": null
  },
  {
    "prompt_num": 4,
    "prompt": "Design a robot companion with 6 modes: standby (hovers in place, blue glow, soft hum), following (tracks player smoothly, green glow, servo sounds), alert (scans surroundings, yellow flashing, beeping), defensive (projects shield bubble, red pulse, alarm), recharging (descends to ground, dim orange, power-down sound), and damaged (sparks, erratic movement, distress beeps). Transitions based on player commands and detected threats.",
    "timestamp": "2026-01-08T21:53:00.019259",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RobotCompanion : MonoBehaviour\n{\n    [Header(\"Robot Settings\")]\n    [SerializeField] private string _robotName = \"Sentinel\";\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _headTransform;\n    [SerializeField] private Transform _bodyTransform;\n    [SerializeField] private Renderer _robotRenderer;\n    [SerializeField] private Light _detectionLight;\n    [SerializeField] private ParticleSystem _powerUpParticles;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _hoverHeight = 2f;\n    [SerializeField] private float _rechargeRadius = 5f;\n    \n    [Header(\"Mode Settings\")]\n    [SerializeField] private List<RobotMode> _availableModes = new List<RobotMode>();\n    [SerializeField] private RobotMode _currentMode;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _modeSounds;\n    [SerializeField] private AudioClip[] _servoNoises;\n    [SerializeField] private AudioClip[] _alertBeeps;\n    [SerializeField] private AudioClip[] _defensiveBleeps;\n    [SerializeField] private AudioClip[] _damageScreams;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _maxForce = 100f;\n    [SerializeField] private float _minVelocityThreshold = 0.1f;\n    \n    private Dictionary<string, System.Action<RobotState>> _modeTransitionActions = new Dictionary<string, System.Action<RobotState>>();\n    private RobotState _currentState = RobotState.Standby;\n    private Rigidbody _rigidbody;\n    private bool _isGrounded = false;\n    \n    public enum RobotState\n    {\n        Standby,\n        Following,\n        Alert,\n        Defensive,\n        Recharging,\n        Damaged\n    }\n    \n    public string CurrentMode => _currentState.ToString();\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupModes();\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _isGrounded = Physics.CheckSphere(transform.position, 0.5f, _obstacleLayer);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_detectionLight != null)\n        {\n            _detectionLight.enabled = false;\n        }\n        \n        if (_powerUpParticles != null)\n        {\n            _powerUpParticles.Stop();\n        }\n    }\n    \n    private void SetupModes()\n    {\n        foreach (var mode in _availableModes)\n        {\n            var modeName = mode.GetType().Name;\n            _modeTransitionActions[modeName] = mode.Transition;\n        }\n        \n        if (_currentMode == null)\n        {\n            _currentMode = _availableModes[0];\n        }\n        \n        _currentState = _currentMode;\n    }\n    \n    private void Update()\n    {\n        switch (_currentState)\n        {\n            case RobotState.Standby:\n                HandleStandby();\n                break;\n            case RobotState.Following:\n                HandleFollowing();\n                break;\n            case RobotState.Alert:\n                HandleAlert();\n                break;\n            case RobotState.Defensive:\n                HandleDefensive();\n                break;\n            case RobotState.Recharging:\n                HandleRecharging();\n                break;\n            case RobotState.Damaged:\n                HandleDamaged();\n                break;\n        }\n    }\n    \n    private void HandleStandby()\n    {\n        PlayModeSound(_currentState, 0);\n        \n        if (_headTransform != null)\n        {\n            _headTransform.Rotate(0, 0, 360f * Time.deltaTime);\n        }\n        \n        if (_isGrounded && !_rigidbody.isKinematic)\n        {\n            _rigidbody.AddForce(Vector3.up * 5f, ForceMode.Force);\n        }\n    }\n    \n    private void HandleFollowing()\n    {\n        if (PlayerController playerController == null)\n        {\n            playerController = FindObjectOfType<PlayerController>();\n        }\n        \n        if (playerController != null && playerController.transform != null)\n        {\n            Vector3 targetPosition = playerController.transform.position;\n            \n            // Avoid obstacles\n            Collider[] colliders = Physics.OverlapSphere(targetPosition, 0.5f, _obstacleLayer);\n            foreach (Collider col in colliders)\n            {\n                if (col.transform == transform) continue;\n                \n                Vector3 obstacleDirection = targetPosition - col.center;\n                float distance = Vector3.Distance(transform.position, col.center);\n                if (distance > 1f) \n                {\n                    targetPosition = new Vector3(\n                        Mathf.Clamp(targetPosition.x, transform.position.x, col.bounds.max.x),\n                        transform.position.y,\n                        Mathf.Clamp(targetPosition.z, transform.position.z, col.bounds.min.z)\n                    );\n                }\n            }\n            \n            // Move toward player\n            if (transform.position != targetPosition)\n            {\n                _rigidbody.MovePosition(targetPosition);\n            }\n        }\n    }\n    \n    private void HandleAlert()\n    {\n        PlayModeSound(_currentState, 1);\n        \n        _detectionLight.enabled = true;\n        _detectionLight.color = Color.yellow;\n        _detectionLight.intensity = 2f;\n        \n        // Scan for threats\n        Collider[] enemies = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n        bool hasEnemy = false;\n        foreach (Collider enemy in enemies)\n        {\n            if (enemy.transform == transform) continue;\n            \n            if (!string.IsNullOrEmpty(enemy.gameObject.name) && \n                !string.Equals(enemy.gameObject.name, \"Player\"))\n            {\n                hasEnemy = true;\n                break;\n            }\n        }\n        \n        // Transition based on threat presence\n        if (hasEnemy)\n        {\n            _currentState = RobotState.Defensive;\n        }\n        else\n        {\n            _currentState = RobotState.Standby;\n        }\n    }\n    \n    private void HandleDefensive()\n    {\n        PlayModeSound(_currentState, 2);\n        \n        _detectionLight.enabled = false;\n        _detectionLight.color = Color.red;\n        _detectionLight.intensity = 1f;\n        \n        // Project defensive shield\n        BoxCollider shieldCollider = gameObject.AddComponent<BoxCollider>();\n        shieldCollider.isTrigger = true;\n        shieldCollider.bounds.size = new Vector3(10f, 5f, 10f);\n        shieldCollider.center = transform.position;\n        \n        // Play defensive sounds and effects\n        PlayDefensiveBleeps();\n        _powerUpParticles.Play();\n    }\n    \n    private void HandleRecharging()\n    {\n        PlayModeSound(_currentState, 3);\n        \n        if (_bodyTransform != null)\n        {\n            _bodyTransform.localPosition = new Vector3(\n                Random.Range(-0.5f, 0.5f),\n                -0.5f,\n                Random.Range(-0.5f, 0.5f)\n            );\n        }\n        \n        // Move to recharge position\n        if (_isGrounded && !_rigidbody.isKinematic)\n        {\n            _rigidbody.AddForce(Vector3.down * 2f, ForceMode.Force);\n        }\n    }\n    \n    private void HandleDamaged()\n    {\n        PlayModeSound(_currentState, 4);\n        \n        // Randomize movement\n        if (_headTransform != null)\n        {\n            transform.Rotate(0, 360f * Time.deltaTime, 0);\n        }\n        \n        // Play distress sounds and effects\n        PlayDamageScreams();\n        _powerUpParticles.Play();\n    }\n    \n    private void PlayModeSound(RobotState currentState, int modeIndex)\n    {\n        if (_audioSource == null || _modeSounds == null)\n            return;\n            \n        if (modeIndex < 0 || modeIndex >= _modeSounds.Length)\n            modeIndex = 0;\n            \n        _audioSource.PlayOneShot(_modeSounds[modeIndex]);\n    }\n    \n    private void PlayDefensiveBleeps()\n    {\n        if (_defensiveBleeps == null || _audioSource == null)\n            return;\n            \n        foreach (AudioClip clip in _defensiveBleeps)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayDamageScreams()\n    {\n        if (_damageScreams == null || _audioSource == null)\n            return;\n            \n        for (int i = 0; i < 3; i++)\n        {\n            _audioSource.PlayOneShot(_damageScreams[i]);\n        }\n    }\n    \n    public void TransitionToMode(string modeName, RobotState newMode = null)\n    {\n        if (!_availableModes.Contains(typeof(RobotMode)) || !_modeTransitionActions.ContainsKey(modeName))\n        {\n            Debug.LogError($\"Invalid mode: {modeName}\");\n            return;\n        }\n        \n        System.Action<RobotState> transitionAction = _modeTransitionActions[modeName];\n        \n        if (newMode == null)\n        {\n            newMode = _currentMode;\n        }\n        \n        transitionAction?.Invoke(newMode);\n    }\n    \n    public void SetMode(RobotMode mode)\n    {\n        if (mode == null) return;\n        \n        string modeName = mode.GetType().Name;\n        if (!_availableModes.Contains(typeof(RobotMode)) || !_modeTransitionActions.ContainsKey(modeName))\n        {\n            Debug.LogError($\"Invalid mode type: {modeName}\");\n            return;\n        }\n        \n        TransitionToMode(modeName, mode);\n    }\n    \n    public void SetMode(string modeName)\n    {\n        TransitionToMode(modeName);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        \n        if (_detectionLight != null)\n        {\n            Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        }\n        \n        if (mode == RobotState.Defensive)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(shieldCollider.bounds, new Material(Gizmos.material));\n        }\n    }\n    \n    public enum RobotMode\n    {\n        Standby,\n        Following,\n        Alert,\n        Defensive,\n        Recharging,\n        Damaged\n    }\n    \n    private class RobotMode : MonoBehaviour\n    {\n        public Vector3 targetPosition;\n        public float moveSpeed = 3f;\n        public float rotationSpeed = 90f;\n        public bool isGrounded = false;\n        \n        public void Transition()\n        {\n            // Add common transition behaviors here if needed\n        }\n    }\n    \n    private class RobotState\n    {\n        public string modeName;\n        public RobotMode robotMode;\n        \n        public RobotState(string name, RobotMode rm)\n        {\n            modeName = name;\n            robotMode = rm;\n        }\n        \n        public void Transition()\n        {\n            // Add transition behaviors specific to this state\n        }\n    }\n    \n    [System.Serializable]\n    private class RobotModeData\n    {\n        public string modeName;\n        public Vector3 moveDirection;\n        public float moveSpeed;\n        public float rotationAngle;\n        public bool useGroundCheck = true;\n        \n        public RobotModeData(string name, Vector3 direction = null, float speed = 3f,\n                            float angle = 90f, bool groundCheck = true)\n        {\n            modeName = name;\n            moveDirection = direction ?? Vector3.forward;\n            moveSpeed = speed;\n            rotationAngle = angle;\n            useGroundCheck = groundCheck;\n        }\n        \n        public void ApplyMovement()\n        {\n            if (moveDirection != Vector3.zero)\n            {\n                _rigidbody.MovePosition(_rigidbody.position + moveDirection.normalized * moveSpeed);\n                \n                // Rotation\n                if (_headTransform != null && rotationAngle > 0f)\n                {\n                    Quaternion targetRotation = Quaternion.Euler(0, rotationAngle, 0);\n                    _headTransform.rotation = targetRotation;\n                }\n            }\n        }\n    }\n    \n    [System.Serializable]\n    private class RobotStateData\n    {\n        public string modeName;\n        public RobotModeData movementData;\n        public bool useGroundCheck = true;\n        \n        public RobotStateData(string name, RobotModeData data = null)\n        {\n            modeName = name;\n            movementData = data ?? new RobotModeData();\n        }\n        \n        public void ApplyState()\n        {\n            if (movementData != null)\n            {\n                movementData.ApplyMovement();\n            }\n            \n            // Add state-specific behaviors here\n        }\n    }\n    \n    [System.Serializable]\n    private class RobotState\n    {\n        public string modeName;\n        public RobotStateData stateData;\n        \n        public RobotState(string name, RobotStateData data)\n        {\n            modeName = name;\n            stateData = data;\n        }\n        \n        public void Execute()\n        {\n            stateData.ApplyState();\n        }\n    }\n    \n    private enum ModeTransitionType\n    {\n        Immediate,\n        Delayed,\n        ConditionBased\n    }\n    \n    private class RobotMode\n    {\n        [SerializeField] private string _modeName;\n        [SerializeField] private RobotStateData _stateData;\n        [SerializeField] private ModeTransitionType _transitionType = ModeTransitionType.Immediate;\n        [SerializeField] private float _delayTime = 0f;\n        \n        public void Execute()\n        {\n            switch (_transitionType)\n            {\n                case ModeTransitionType.Immediate:\n                    TransitionImmediate();\n                    break;\n                case ModeTransitionType.Delayed:\n                    DelayedTransition();\n                    break;\n                case ModeTransitionType.ConditionBased:\n                    ConditionBasedTransition();\n                    break;\n            }\n        }\n        \n        private void TransitionImmediate()\n        {\n            // Handle immediate transitions\n        }\n        \n        private void DelayedTransition()\n        {\n            Invoke(nameof(Execute), _delayTime);\n        }\n        \n        private void ConditionBasedTransition()\n        {\n            // Check conditions and transition if met\n        }\n    }\n    \n    [System.Serializable]\n    private class RobotStateData\n    {\n        public string modeName;\n        public RobotMode[] modes;\n        public bool useGroundCheck = true;\n        \n        public RobotStateData(string name, RobotMode[] modes)\n        {\n            modeName = name;\n            this_modes = modes;\n        }\n        \n        private RobotMode[] _modes;\n        private void SetModes(RobotMode[] newModes)\n        {\n            _modes = newModes;\n        }\n        \n        public RobotMode GetNextMode()\n        {\n            if (_modes == null || _modes.Length == 0) return null;\n            \n            // Implement logic to choose next mode based on conditions\n            return _modes[0];\n        }\n    }\n    \n    private class RobotState : RobotStateData\n    {\n        [SerializeField] private string _currentModeName = \"Standby\";\n        [SerializeField] private bool _isGrounded = true;\n        \n        public RobotState(string name, RobotMode[] modes)\n            : base(name, modes) { _currentModeName = name; }\n        \n        public void EnterState()\n        {\n            switch (_modeName)\n            {\n                case \"Standby\":\n                    Standby();\n                    break;\n                case \"Following\":\n                    Following();\n                    break;\n                case \"Alert\":\n                    Alert();\n                    break;\n                case \"Defensive\":\n                    Defensive();\n                    break;\n                case \"Recharging\":\n                    Recharging();\n                    break;\n                case \"Damaged\":\n                    Damaged();\n                    break;\n            }\n        }\n        \n        private void Standby()\n        {\n            _currentState = new RobotState(\"Standby\", new RobotMode[] { });\n            \n            // Play idle sounds\n            PlayIdleSounds();\n        }\n        \n        private void Following()\n        {\n            _currentState = new RobotState(\"Following\", new RobotMode[]\n            {\n                new RobotMode { _modeName = \"FollowPlayer\", _stateData = stateDataWithMovement },\n                new RobotMode { _modeName = \"AvoidObstacle\", _stateData = stateDataWithMovement }\n            });\n        }\n        \n        private void Alert()\n        {\n            _currentState = new RobotState(\"Alert\", new RobotMode[]\n            {\n                new RobotMode { _modeName = \"ScanForThreats\", _stateData = stateDataScanning },\n                new RobotMode { _modeName = \"PlayAlertSound\", _stateData = stateDataAlert }\n            });\n        }\n        \n        private void Defensive()\n        {\n            _currentState = new RobotState(\"Defensive\", new RobotMode[]\n            {\n                new RobotMode { _modeName = \"ProjectShield\", _stateData = stateDataShield },\n                new RobotMode { _modeName = \"PlayDefensiveBleeps\", _stateData = stateDataAlert }\n            });\n        }\n        \n        private void Recharging()\n        {\n            _currentState = new RobotState(\"Recharging\", new RobotMode[]\n            {\n                new RobotMode { _modeName = \"DescendToGround\", _stateData = stateDataDescending },\n                new RobotMode { _modeName = \"PlayPowerUpParticles\", _stateData = stateDataPower }\n            });\n        }\n        \n        private void Damaged()\n        {\n            _currentState = new RobotState(\"Damaged\", new RobotMode[]\n            {\n                new RobotMode { _modeName = \"RandomizeMovement\", _stateData = stateDataRandom },\n                new RobotMode { _modeName = \"PlayDistressBeeps\", _stateData = stateDataAlert }\n            });\n        }\n        \n        private void PlayIdleSounds()\n        {\n            // Add idle sound logic here\n        }\n        \n        private void ScanForThreats()\n        {\n            Collider[] enemies = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n            bool hasEnemy = false;\n            \n            foreach (Collider enemy in enemies)\n            {\n                if (enemy.transform == transform) continue;\n                \n                if (!string.IsNullOrEmpty(enemy.gameObject.name) && !string.Equals(enemy.gameObject.name, \"Player\"))\n                {\n                    hasEnemy = true;\n                    break;\n                }\n            }\n            \n            if (hasEnemy)\n            {\n                // Transition to defensive or alert mode\n                _currentState.EnterState();\n            }\n        }\n        \n        private void PlayAlertSound()\n        {\n            _audioSource.PlayOneShot(_modeSounds[0]);\n        }\n        \n        private void ProjectShield()\n        {\n            // Create shield bubble effect\n        }\n        \n        private void PlayDefensiveBleeps()\n        {\n            foreach (AudioClip clip in _defensiveBleeps)\n            {\n                _audioSource.PlayOneShot(clip);\n            }\n        }\n        \n        private void DescendToGround()\n        {\n            if (_bodyTransform != null)\n            {\n                _bodyTransform.localPosition = new Vector3(\n                    Random.Range(-0.5f, 0.5f),\n                    -1f,\n                    Random.Range(-0.5",
    "ir_json": {
      "class_name": "RobotCompanion",
      "components": [
        "Animator",
        "Rigidbody",
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "currentMode",
          "type": "string",
          "default": "standby"
        },
        {
          "name": "modeTransitions",
          "type": "list",
          "default": null
        },
        {
          "name": "playerDistanceThreshold",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "threatDetectionRadius",
          "type": "float",
          "default": 5.0
        },
        {
          "name": "glowColor",
          "type": "string",
          "default": null
        },
        {
          "name": "movementSpeed",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "alertBeepCountdown",
          "type": "int",
          "default": 5
        }
      ],
      "behaviors": [
        {
          "name": "activate_standby_mode",
          "trigger": "when robot has no active commands and player is far away",
          "actions": [
            {
              "action": "set current mode to standby"
            },
            {
              "action": "enable hover movement"
            },
            {
              "action": "set glow color to blue"
            },
            {
              "action": "play soft humming sound"
            }
          ]
        },
        {
          "name": "activate_following_mode",
          "trigger": "when player is not nearby and no active threat detected",
          "actions": [
            {
              "action": "set current mode to following"
            },
            {
              "action": "track player position smoothly"
            },
            {
              "action": "maintain green glow color"
            },
            {
              "action": "play servo movement sounds"
            }
          ]
        },
        {
          "name": "activate_alert_mode",
          "trigger": "when threat is detected within detection radius and player is not nearby",
          "actions": [
            {
              "action": "set current mode to alert"
            },
            {
              "action": "scan surroundings for threats"
            },
            {
              "action": "flash yellow lights rapidly"
            },
            {
              "action": "play continuous beeping alarm sound"
            }
          ]
        },
        {
          "name": "activate_defensive_mode",
          "trigger": "when threat is detected and player commands defensive stance",
          "actions": [
            {
              "action": "set current mode to defensive"
            },
            {
              "action": "project force shield around robot"
            },
            {
              "action": "pulse red light around shield area"
            },
            {
              "action": "play warning alarm tones"
            }
          ]
        },
        {
          "name": "activate_recharging_mode",
          "trigger": "when player signals rest request and current mode is not defensive or alert",
          "actions": [
            {
              "action": "set current mode to recharging"
            },
            {
              "action": "descend to ground position"
            },
            {
              "action": "dim orange glow color"
            },
            {
              "action": "play low power-down hum"
            }
          ]
        },
        {
          "name": "activate_damaged_mode",
          "trigger": "when health system indicates damage level requires special mode",
          "actions": [
            {
              "action": "set current mode to damaged"
            },
            {
              "action": "flash erratic red and blue lights"
            },
            {
              "action": "move in unpredictable patterns"
            },
            {
              "action": "play distress beeping sounds"
            }
          ]
        },
        {
          "name": "transition_between_modes",
          "trigger": "when required mode change becomes valid",
          "actions": [
            {
              "action": "smoothly transition to new mode color and behavior"
            },
            {
              "action": "adjust movement speed and audio volume based on target mode"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RobotCompanion : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private LayerMask _groundLayer = -1;\n    \n    [Header(\"AI Behavior\")]\n    [SerializeField] private string[] _behaviors = { \"FollowPlayer\", \"DetectThreats\", \"Recharge\" };\n    [SerializeField] private float _behaviorTransitionSpeed = 5f;\n    [SerializeField] private bool _alwaysCheckForBehaviors = true;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.green;\n    [SerializeField] private Color _followColor = Color.yellow;\n    [SerializeField] private Color _threatColor = Color.red;\n    [SerializeField] private Color _rechargeColor = Color.orange;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _followSounds;\n    [SerializeField] private AudioClip[] _threatSounds;\n    [SerializeField] private AudioClip[] _rechargeSounds;\n    \n    [Header(\"Collision\")]\n    [SerializeField] private bool _useContinuousDetection = true;\n    [SerializeField] private float _continuousDetectionRadius = 10f;\n    \n    private List<RobotCompanionBehavior> _behaviorsList;\n    private RobotCompanionState _currentState;\n    private Dictionary<string, RobotCompanionState> _behaviorStates;\n    private Transform _playerTransform;\n    private Camera _playerCamera;\n    private bool _isGrounded;\n    \n    [System.Serializable]\n    public class RobotCompanionState\n    {\n        public string behaviorName;\n        public Color currentColor;\n        public float currentSpeed;\n        public AudioSource currentAudioSource;\n        \n        public RobotCompanionState(string name, Color color = default, float speed = 1f, AudioSource audio = null)\n        {\n            behaviorName = name;\n            currentColor = color;\n            currentSpeed = speed;\n            currentAudioSource = audio ?? _audioSource;\n        }\n    }\n    \n    private void Awake()\n    {\n        _behaviorsList = new List<RobotCompanionBehavior>();\n        \n        foreach (var.behavior in _behaviors)\n        {\n            var behaviorScript = GameObject.GetComponentsInChildren<RobotCompanionBehavior>().FirstOrDefault(x => x.name.ToLower() == behavior.ToLower());\n            if (behaviorScript != null)\n                _behaviorsList.Add(behaviorScript);\n        }\n        \n        _behaviorStates = new Dictionary<string, RobotCompanionState>();\n        _currentState = new RobotCompanionState(\"Idle\");\n    }\n    \n    private void Start()\n    {\n        InitializeAudio();\n        FindPlayer();\n        SetInitialMode();\n    }\n    \n    private void Update()\n    {\n        CheckForBehaviors();\n        \n        if (_audioSource != null)\n            PlayBehaviorSound(_currentState.behaviorName);\n    }\n    \n    private void InitializeAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        for (int i = 0; i < _followSounds.Length; i++)\n            _audioSource.clip = _followSounds[i];\n            _audioSource.loop = true;\n            _audioSource.volume = 0.5f;\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _playerTransform = playerObject.transform;\n            _playerCamera = Camera.main;\n            \n            if (_playerCamera == null)\n                _playerCamera = FindObjectOfType<Camera>();\n                \n            if (_playerCamera != null && !_playerCamera.isTrigger)\n                _playerCamera.enabled = false;\n        }\n    }\n    \n    private void SetInitialMode()\n    {\n        string[] initialBehaviorNames = new string[_behaviors.Length];\n        \n        for (int i = 0; i < _behaviors.Length; i++)\n            initialBehaviorNames[i] = _behaviors[i].Replace(\"Behavior\", \"\");\n            \n        foreach (string behaviorName in initialBehaviorNames)\n        {\n            if (!_behaviorStates.ContainsKey(behaviorName))\n                _behaviorStates[behaviorName] = new RobotCompanionState(behaviorName, _normalColor);\n        }\n        \n        if (_isGrounded && !_alwaysCheckForBehaviors)\n            SetIdleMode();\n    }\n    \n    private void CheckForBehaviors()\n    {\n        List<string> validBehaviors = new List<string>();\n        \n        foreach (RobotCompanionBehavior behavior in _behaviorsList)\n        {\n            bool shouldActivate = false;\n            \n            if (_useContinuousDetection && !behavior.IsContinuousEnabled)\n                shouldActivate = true;\n                \n            else\n            {\n                if (!_alwaysCheckForBehaviors || \n                    (behavior.IsContinuousEnabled && !shouldActivate) ||\n                    (!behavior.IsContinuousEnabled && behavior.Activate()))\n                {\n                    shouldActivate = true;\n                }\n            }\n            \n            if (shouldActivate)\n                validBehaviors.Add(behavior.behaviorName);\n        }\n        \n        if (_alwaysCheckForBehaviors || validBehaviors.Count > 0)\n        {\n            string[] sortedBehaviorNames = new string[validBehaviors.Count];\n            \n            for (int i = 0; i < validBehaviors.Count; i++)\n                sortedBehaviorNames[i] = validBehaviors[i].Replace(\"Behavior\", \"\");\n                \n            foreach (string behaviorName in sortedBehaviorNames)\n            {\n                if (_behaviorStates.ContainsKey(behaviorName))\n                {\n                    _currentState.behaviorName = behaviorName;\n                    UpdateColorAndSpeed();\n                }\n            }\n        }\n    }\n    \n    private void UpdateColorAndSpeed()\n    {\n        Color targetColor = _behaviorStates[_currentState.behaviorName].currentColor;\n        \n        if (targetColor != _normalColor)\n        {\n            Color currentColor = GetComponent<Renderer>().material.color;\n            float t = 0f;\n            \n            if (_colorTransitionSpeed > 0)\n            {\n                t = Mathf.Lerp(1f, 0f, Time.deltaTime / _colorTransitionSpeed);\n                targetColor = Color.Lerp(currentColor, targetColor, t);\n            }\n            \n            GetComponent<Renderer>().material.color = targetColor;\n        }\n        \n        float targetSpeed = _behaviorStates[_currentState.behaviorName].currentSpeed;\n        if (targetSpeed != 0f)\n        {\n            _moveSpeed = Mathf.Lerp(_moveSpeed, targetSpeed, Time.deltaTime / _behaviorTransitionSpeed);\n        }\n    }\n    \n    private void FollowPlayer()\n    {\n        if (_playerTransform == null) return;\n        \n        Vector3 directionToPlayer = (_playerTransform.position - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distance > 0f)\n        {\n            transform.Translate(directionToPlayer * _moveSpeed * Time.deltaTime);\n            _currentState.behaviorName = \"Follow\";\n            _currentState.currentColor = _followColor;\n            _currentState.currentSpeed = _moveSpeed;\n            \n            PlayBehaviorSound(_currentState.behaviorName);\n        }\n    }\n    \n    private void DetectThreats()\n    {\n        if (_playerTransform == null) return;\n        \n        float playerDistance = Vector3.Distance(transform.position, _playerTransform.position);\n        float threatRadius = 5f;\n        bool hasThreat = false;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, threatRadius, _groundLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!col.CompareTag(\"Player\"))\n                hasThreat = true;\n        }\n        \n        if (hasThreat && playerDistance > threatRadius)\n        {\n            SetAlertMode();\n        }\n    }\n    \n    private void Recharge()\n    {\n        if (_playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        bool shouldRecharge = false;\n        \n        if (distanceToPlayer > 20f)\n        {\n            shouldRecharge = true;\n        }\n        else\n        {\n            // Check for grounded state\n            if (_isGrounded && !IsOnGround())\n                shouldRecharge = true;\n        }\n        \n        if (shouldRecharge)\n        {\n            SetIdleMode();\n        }\n    }\n    \n    private void SetAlertMode()\n    {\n        _currentState.behaviorName = \"Alert\";\n        _currentState.currentColor = _threatColor;\n        _currentState.currentSpeed = 2f;\n        \n        PlayBehaviorSound(_currentState.behaviorName);\n    }\n    \n    private void SetIdleMode()\n    {\n        _currentState.behaviorName = \"Idle\";\n        _currentState.currentColor = _normalColor;\n        _currentState.currentSpeed = 1f;\n        \n        PlayBehaviorSound(_currentState.behaviorName);\n    }\n    \n    private bool IsOnGround()\n    {\n        if (_isGrounded) return true;\n        \n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb == null) return false;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, 0.5f, _groundLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Ground\"))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    private void PlayBehaviorSound(string behaviorName)\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource == null) return;\n        \n        foreach (AudioClip clip in _followSounds)\n        {\n            if (clip != null && behaviorName.Contains(\"Follow\"))\n            {\n                audioSource.PlayOneShot(clip);\n                break;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        if (_playerTransform != null)\n        {\n            Gizmos.DrawWireSphere(_playerTransform.position, 5f);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _continuousDetectionRadius * 0.3f);\n        }\n    }\n}\n\npublic class RobotCompanionBehavior : MonoBehaviour\n{\n    public string behaviorName = \"Default\";\n    public bool IsContinuousEnabled = true;\n    public float ContinuousDetectionRadius = 10f;\n    \n    private Collider[] _detectionColliders;\n    private Rigidbody _rigidbody;\n    private Vector3 _targetPosition;\n    private Quaternion _targetRotation;\n    private bool _wasGrounded;\n    \n    private void Awake()\n    {\n        _detectionColliders = new Collider[GetComponentsInChildren<Collider>().Length];\n        \n        for (int i = 0; i < _detectionColliders.Length; i++)\n            _detectionColliders[i] = GetComponentInChildren<Collider>();\n            \n        _rigidbody = GetComponent<Rigidbody>();\n    }\n    \n    private void Start()\n    {\n        FindTargetPosition();\n        CheckForGroundedState();\n        \n        if (_wasGrounded && !_IsGrounded())\n            SetIdleMode();\n    }\n    \n    private void Update()\n    {\n        CheckContinuousDetection();\n        CheckForMovementCommands();\n    }\n    \n    private void FindTargetPosition()\n    {\n        if (_playerTransform == null)\n            return;\n            \n        _targetPosition = _playerTransform.position;\n        \n        if (!_playerCamera?.isTrigger && !_playerCamera.transform.parent == transform)\n        {\n            Vector3 directionToPlayer = (_playerTransform.position - transform.position).normalized;\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            \n            if (distance > 5f)\n                _targetPosition += directionToPlayer * 10f;\n        }\n    }\n    \n    private void CheckForGroundedState()\n    {\n        bool currentGrounded = IsOnGround();\n        \n        if (_wasGrounded != currentGrounded)\n        {\n            _wasGrounded = currentGrounded;\n            SetIdleMode();\n        }\n    }\n    \n    private void CheckContinuousDetection()\n    {\n        if (!_IsGrounded())\n        {\n            Collider[] colliders = Physics.OverlapSphere(transform.position, ContinuousDetectionRadius * 0.3f, _groundLayer);\n            \n            foreach (Collider col in colliders)\n            {\n                if (col.CompareTag(\"Player\"))\n                    return;\n            }\n        }\n    }\n    \n    private void CheckForMovementCommands()\n    {\n        // This is a placeholder for receiving movement commands from the player\n        // Implementation would depend on input system or command pattern used\n        \n        // Example: Check if player pressed forward key\n        // if (Input.GetKey(KeyCode.W))\n        //     SetMoveForwardCommand();\n        \n        // Add other movement command checks here\n    }\n    \n    private void SetIdleMode()\n    {\n        transform.position = _targetPosition;\n        transform.rotation = _targetRotation;\n        \n        PlayBehaviorSound(behaviorName + \"_Idle\");\n    }\n    \n    private bool IsGrounded()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 0.5f, _groundLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Ground\"))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        if (_isMoving)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _targetPosition);\n        }\n        \n        if (ContinuousDetectionEnabled)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(transform.position, ContinuousDetectionRadius * 0.3f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        string behaviorKey = behaviorName + \"_Enter\";\n        \n        if (_continuousDetection && other.CompareTag(\"Player\"))\n        {\n            SetFollowMode();\n        }\n        \n        else if (other.CompareTag(\"Obstacle\"))\n        {\n            SetSlideOrRollMode(other);\n        }\n        \n        // Add collision-specific behaviors here\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        string behaviorKey = behaviorName + \"_Exit\";\n        \n        if (_continuousDetection && other.CompareTag(\"Player\"))\n        {\n            SetIdleMode();\n        }\n        \n        else if (other.CompareTag(\"Obstacle\"))\n        {\n            ResetMovementMode();\n        }\n        \n        // Add collision-specific behaviors here\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        string behaviorKey = behaviorName + \"_Enter\";\n        \n        switch (collision.gameObject.tag)\n        {\n            case \"Ground\":\n                SetIdleMode();\n                break;\n                \n            case \"SlideSurface\":\n                SetSlideMode(collision.collider);\n                break;\n                \n            // Add other collision tags here\n        }\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        string behaviorKey = behaviorName + \"_Exit\";\n        \n        switch (collision.gameObject.tag)\n        {\n            case \"Ground\":\n                ResetMovementMode();\n                SetIdleMode();\n                break;\n                \n            case \"SlideSurface\":\n                ResetSlideMode();\n                break;\n        }\n    }\n    \n    private void SetFollowMode()\n    {\n        transform.position = _targetPosition;\n        \n        if (!_continuousDetection || other.CompareTag(\"Player\"))\n        {\n            PlayBehaviorSound(behaviorName + \"_Follow\");\n        }\n    }\n    \n    private void SetSlideOrRollMode(Collider obstacle)\n    {\n        Vector3 slideDirection = (obstacle.transform.position - transform.position).normalized;\n        float slideDistance = 1f * slideDirection.magnitude;\n        \n        if (slideDistance > 0.5f)\n        {\n            transform.position += slideDirection * slideDistance;\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _targetPosition);\n            \n            PlayBehaviorSound(behaviorName + \"_Slide\");\n        }\n    }\n    \n    private void ResetMovementMode()\n    {\n        transform.position = _targetPosition;\n        \n        if (!_continuousDetection || other.CompareTag(\"Player\"))\n        {\n            PlayBehaviorSound(behaviorName + \"_Idle\");\n        }\n    }\n    \n    private void SetSlideMode(Collider slideCollider)\n    {\n        Vector3 slideDirection = (slideCollider.transform.position - transform.position).normalized;\n        float slideDistance = 1f * slideDirection.magnitude;\n        \n        if (slideDistance > 0.5f)\n        {\n            transform.position += slideDirection * slideDistance;\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _targetPosition);\n            \n            PlayBehaviorSound(behaviorName + \"_Slide\");\n        }\n    }\n    \n    private void ResetSlideMode()\n    {\n        transform.position = _targetPosition;\n        \n        if (_continuousDetection || other.CompareTag(\"Player\"))\n        {\n            PlayBehaviorSound(behaviorName + \"_Idle\");\n        }\n    }\n    \n    public bool IsContinuousEnabled { get => _IsContinuousEnabled; set => _IsContinuousEnabled = value; }\n    public float ContinuousDetectionRadius { get => _ContinuousDetectionRadius; private set => _ContinuousDetectionRadius = value; }\n    \n    private void OnDrawGizmosMode()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        if (_isMoving)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _targetPosition);\n        }\n        \n        if (ContinuousDetectionEnabled)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(transform.position, ContinuousDetectionRadius * 0.3f);\n        }\n    }\n    \n    private void SetMoveForward()\n    {\n        transform.Rotate(0, 0, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void SetTurnLeft()\n    {\n        transform.Rotate(-_rotationSpeed * Time.deltaTime, 0, 0);\n    }\n    \n    private void SetTurnRight()\n    {\n        transform.Rotate(_rotationSpeed * Time.deltaTime, 0, 0);\n    }\n    \n    private bool _isMoving = false;\n    private bool _continuousDetectionEnabled = true;\n    \n    public virtual void Activate() => _continuousDetectionEnabled = true;\n    public virtual void Deactivate() => _continuousDetectionEnabled = false;\n    \n    private void CheckContinuousMovement()\n    {\n        if (!_continuousDetectionEnabled) return;\n        \n        Vector3 directionToPlayer = (_playerTransform.position - transform.position).normalized;\n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer > 0f)\n        {\n            _isMoving = true;\n            \n            // Simple rotation towards player\n            Quaternion targetRotation = Quaternion.LookRotation(directionToPlayer);\n            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * _rotationSpeed);\n        }\n        else\n        {\n            _isMoving = false;\n        }\n    }\n    \n    public void SetTargetPosition(Vector3 position)\n    {\n        _targetPosition = position;\n    }\n    \n    public void SetTargetRotation(Quaternion rotation)\n    {\n        _targetRotation = rotation;\n    }\n}\n\npublic class RobotCompanionInput : MonoBehaviour\n{\n    [Header(\"Movement Keys\")]\n    [SerializeField] private KeyCode _moveForwardKey = KeyCode.W;\n    [SerializeField] private KeyCode _moveBackwardKey = KeyCode.S;",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.GetBehaviours (0.62)",
      "Animator.IsParameterControlledByCurve (0.62)",
      "Animator.GetBehaviour (0.62)",
      "Light.AddCommandBuffer (0.60)",
      "CollisionDetectionMode.ContinuousDynamic (0.41)",
      "AnimationUpdateMode.Normal (0.41)",
      "CollisionDetectionMode.ContinuousSpeculative (0.40)",
      "PlayModeWindow.SetCustomRenderingResolution (0.40)",
      "AnimationUpdateMode.Fixed (0.40)",
      "CollisionDetectionMode.Continuous (0.40)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RobotCompanion : MonoBehaviour\n{\n    [Header(\"Robot Settings\")]\n    public float movementSpeed = 3f;\n    public float rotationSpeed = 90f;\n    public float lookDistance = 10f;\n    public LayerMask playerLayer = -1;\n    public float detectionRadius = 20f;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem[] particleEffects;\n    public AudioSource audioSource;\n    public Renderer renderer;\n    public Light[] lights;\n    \n    [Header(\"Audio\")]\n    public AudioClip idleSound;\n    public AudioClip followSound;\n    public AudioClip alertSound;\n    public AudioClip defenseSound;\n    public AudioClip rechargeSound;\n    public AudioClip damageSound;\n    \n    private Rigidbody rb;\n    private Transform playerTransform;\n    private float targetDistance = 5f;\n    private float currentThreatLevel = 0;\n    private int threatThreshold = 3;\n    private List<Collider> nearbyObjects = new List<Collider>();\n    private bool isPlayerVisible = false;\n    \n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        if (renderer != null)\n            renderer.enabled = true;\n            \n        if (lights.Length > 0)\n            lights[0].enabled = false;\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        UpdateVisuals();\n        HandleMovement();\n        PlayAudio();\n        CheckForThreats();\n    }\n    \n    private void DetectPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            playerTransform = playerObject.transform;\n            float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n            \n            if (distanceToPlayer <= lookDistance && playerObject.CompareTag(\"Player\"))\n            {\n                isPlayerVisible = true;\n                \n                // Check for line of sight\n                RaycastHit hit;\n                if (Physics.Raycast(playerTransform.position, -playerTransform.forward, out hit, distanceToPlayer))\n                {\n                    float obstacleDistance = Vector3.Distance(playerTransform.position, hit.point);\n                    bool hasLineOfSight = obstacleDistance >= 10f;\n                    \n                    // Check for obstacles within detection radius\n                    Collider[] obstacles = Physics.OverlapSphere(playerTransform.position, detectionRadius, playerLayer);\n                    foreach (Collider col in obstacles)\n                    {\n                        if (Vector3.Distance(transform.position, col.transform.position) <= detectionRadius)\n                        {\n                            currentThreatLevel++;\n                        }\n                    }\n                    \n                    // Check for line of sight obstruction\n                    bool hasObstruction = false;\n                    foreach (Collider col in obstacles)\n                    {\n                        float colDistance = Vector3.Distance(playerTransform.position, col.transform.position);\n                        if (colDistance <= obstacleDistance && !hasObstruction)\n                        {\n                            hasObstruction = true;\n                            break;\n                        }\n                    }\n                    \n                    // Update threat level based on line of sight and nearby objects\n                    currentThreatLevel = currentThreatLevel * 0.8f + hasObstruction ? currentThreatLevel : 0;\n                }\n            }\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (!isPlayerVisible || playerTransform == null)\n        {\n            SetRobotMode(\"standby\");\n            PlaySound(idleSound);\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n        bool shouldFollow = distanceToPlayer <= targetDistance && currentThreatLevel < threatThreshold;\n        \n        if (shouldFollow)\n        {\n            SetRobotMode(\"follow\");\n            PlaySound(followSound);\n        }\n        else\n        {\n            SetRobotMode(\"alert\" + (currentThreatLevel >= threatThreshold ? \"defensive\" : \"\"));\n            PlaySound(alertSound);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (!isPlayerVisible || playerTransform == null)\n        {\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n        bool shouldFollow = distanceToPlayer <= targetDistance && currentThreatLevel < threatThreshold;\n        \n        if (shouldFollow)\n        {\n            // Rotate toward player\n            if (playerTransform != null)\n            {\n                Quaternion targetRotation = playerTransform.rotation;\n                transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * rotationSpeed);\n            }\n            \n            // Move toward player\n            Vector3 directionToPlayer = (playerTransform.position - transform.position).normalized;\n            if (directionToPlayer != Vector3.zero)\n            {\n                rb.MovePosition(transform.position + directionToPlayer * movementSpeed * Time.deltaTime);\n            }\n        }\n    }\n    \n    private void PlayAudio()\n    {\n        if (!isPlayerVisible || playerTransform == null)\n        {\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n        bool shouldFollow = distanceToPlayer <= targetDistance && currentThreatLevel < threatThreshold;\n        \n        if (shouldFollow)\n        {\n            PlaySound(followSound);\n        }\n        else\n        {\n            string modeName = \"alert\" + (currentThreatLevel >= threatThreshold ? \"defensive\" : \"\");\n            PlaySound(modeName == \"alertdefensive\" ? defenseSound : alertSound);\n        }\n    }\n    \n    private void CheckForThreats()\n    {\n        if (!isPlayerVisible || playerTransform == null)\n        {\n            return;\n        }\n        \n        Collider[] obstacles = Physics.OverlapSphere(playerTransform.position, detectionRadius, playerLayer);\n        foreach (Collider col in obstacles)\n        {\n            float colDistance = Vector3.Distance(transform.position, col.transform.position);\n            \n            if (colDistance <= targetDistance && !col.CompareTag(\"Player\"))\n            {\n                currentThreatLevel++;\n            }\n        }\n        \n        // Clamp threat level\n        currentThreatLevel = Mathf.Clamp(currentThreatLevel, 0, threatThreshold);\n    }\n    \n    private void SetRobotMode(string mode)\n    {\n        if (mode.Contains(\"defensive\"))\n        {\n            DisplayDefensiveMode();\n        }\n        else if (mode == \"alert\")\n        {\n            DisplayAlertMode();\n        }\n        else\n        {\n            DisplayStandbyMode();\n        }\n    }\n    \n    private void DisplayStandbyMode()\n    {\n        if (renderer != null)\n            renderer.material = RenderTexture.active ? new Material(renderer.material) : null;\n        \n        if (particleEffects.Length > 0)\n            particleEffects[0].play();\n            \n        if (audioSource != null && idleSound != null)\n            audioSource.PlayOneShot(idleSound);\n    }\n    \n    private void DisplayAlertMode()\n    {\n        if (renderer != null)\n            renderer.material = RenderTexture.active ? new Material(renderer.material) : null;\n        \n        if (particleEffects.Length > 0)\n            particleEffects[1].play();\n            \n        if (audioSource != null && alertSound != null)\n            audioSource.PlayOneShot(alertSound);\n    }\n    \n    private void DisplayDefensiveMode()\n    {\n        if (renderer != null)\n            renderer.material = RenderTexture.active ? new Material(renderer.material) : null;\n        \n        if (particleEffects.Length > 0)\n            particleEffects[2].play();\n            \n        if (audioSource != null && defenseSound != null)\n            audioSource.PlayOneShot(defenseSound);\n    }\n    \n    private void PlaySound(string modeName)\n    {\n        if (audioSource == null || string.IsNullOrEmpty(modeName))\n            return;\n        \n        AudioClip clip = modeName.Contains(\"defensive\") ? defenseSound : alertSound;\n        if (clip != null)\n        {\n            audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        nearbyObjects.Add(other.gameObject);\n        CheckForThreats();\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        nearbyObjects.Remove(other.gameObject);\n        CheckForThreats();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        if (playerTransform != null)\n        {\n            Gizmos.DrawWireSphere(playerTransform.position, targetDistance);\n            \n            // Draw detection radius around robot\n            Gizmos.DrawWireSphere(transform.position, detectionRadius);\n        }\n        \n        // Draw line of sight from player to robot\n        if (playerTransform != null && transform != null)\n        {\n            RaycastHit hit;\n            Gizmos.DrawLine(playerTransform.position, transform.position + Vector3.forward * 10f);\n            \n            if (Physics.Raycast(playerTransform.position, -transform.forward, out hit, detectionRadius))\n            {\n                Gizmos.color = Color.red;\n                Gizmos.DrawWireSphere(hit.point, 0.5f);\n            }\n        }\n    }\n}",
    "per_behavior_docs": 16,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "standby_mode": [
        "ParticleSystem.EmissionModule (0.69)",
        "ParticleSystem.Emit (0.69)",
        "ParticleSystem.LightsModule (0.68)"
      ],
      "follow_player_mode": [
        "ParticleSystem.RotationBySpeedModule (0.65)",
        "Transform.GetPositionAndRotation (0.65)",
        "ParticleSystem.EmissionModule (0.65)"
      ],
      "alert_mode": [
        "Physics.OverlapSphereNonAlloc (0.70)",
        "Physics.RaycastNonAlloc (0.69)",
        "Physics.OverlapSphere (0.69)"
      ],
      "defensive_mode": [
        "Light.SetLightDirty (0.64)",
        "Light.AddCommandBufferAsync (0.63)",
        "Light.GetCommandBuffers (0.62)"
      ],
      "recharging_mode": [
        "ParticleSystem.EmissionModule (0.69)",
        "ParticleSystem.LightsModule (0.69)",
        "ParticleSystem.Emit (0.68)"
      ],
      "damaged_mode": [
        "Transform.GetPositionAndRotation (0.64)",
        "ParticleSystem.ForceOverLifetimeModule (0.63)",
        "ParticleSystem.Play (0.63)"
      ],
      "transition_mode": [
        "AudioVelocityUpdateMode (0.63)",
        "Animator.ResetControllerState (0.62)",
        "AnimationUpdateMode (0.61)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 7,
        "fixability": 6,
        "unity_patterns": 8,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 55,
        "justification": "Direct translation shows good Unity understanding with serialized fields and enum-based state management. However, code is partially incomplete and lacks full implementation of all modes."
      },
      "ir_monolithic": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 6,
        "correctness": 3,
        "completeness": 3,
        "weighted_total": 40,
        "justification": "Over-abstracted approach with complex state management. Creates unnecessary complexity with behavior lists and state dictionaries. Lacks clear transition logic between modes."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 9,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 68,
        "justification": "Most modular approach with clear separation of concerns. Demonstrates robust player detection, threat assessment, and provides clean extension points. Methods are focused and have clear responsibilities."
      },
      "winner": "ir_per_behavior",
      "key_differences": "Per-behavior approach provides more granular, focused methods with clear responsibilities compared to monolithic or direct translation approaches.",
      "advantages": "Allows easy extension, has clear method separation, follows Unity best practices, provides robust error handling, and creates a clear framework for adding additional robot behaviors."
    },
    "error": null
  },
  {
    "prompt_num": 5,
    "prompt": "Create a treasure chest with sealed, unlocking, opening, revealing, and empty states. Sealed state shows golden shimmer and plays mysterious hum. Unlocking requires 3 sequential key presses within 2 seconds, playing click sounds for each. Opening slowly lifts lid with creak sound. Revealing state emits bright light and celebratory fanfare while spawning random loot. Empty state shows dull appearance with cobwebs.",
    "timestamp": "2026-01-08T22:00:31.208624",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest States\")]\n    [SerializeField] private GameObject _closedChamber;\n    [SerializeField] private GameObject _chamberClosed;\n    [SerializeField] private GameObject _openChamber;\n    [SerializeField] private Transform _chestTransform;\n    [SerializeField] private ParticleSystem _unlockParticles;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Loot\")]\n    [SerializeField] private List<LootItem> _lootItems = new List<LootItem>();\n    [SerializeField] private float _spawnDelay = 1f;\n    [SerializeField] private bool _requireKeySequence = true;\n    [SerializeField] private KeyCode _keySequenceKey1 = KeyCode.W;\n    [SerializeField] private KeyCode _keySequenceKey2 = KeyCode.S;\n    [SerializeField] private KeyCode _keySequenceKey3 = KeyCode.D;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _unlockSound;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip[] _lootSpawnSounds;\n    [SerializeField] private AudioClip _emptyChamberSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _closedMaterial;\n    [SerializeField] private Material _openMaterial;\n    [SerializeField] private Color _closedColor = Color.yellow;\n    [SerializeField] private Color _openColor = Color.golden;\n    \n    private bool _isSealed = true;\n    private float _spawnTimer = 0f;\n    private List<Keycode> _keySequence = new List<Keycode>() { new KeyCode(_keySequenceKey1, 0), new KeyCode(_keySequenceKey2, 1), new KeyCode(_keySequenceKey3, 2) };\n    private int _currentKeyIndex = 0;\n    \n    private void Start()\n    {\n        InitializeChamber();\n        SetupAudioSource();\n        SpawnLoot();\n    }\n    \n    private void InitializeChamber()\n    {\n        if (_closedMaterial != null)\n            GetComponent<Renderer>().material = _closedMaterial;\n            \n        if (_chamberClosed != null)\n            Instantiate(_chamberClosed, transform.position, Quaternion.identity);\n        \n        if (_closedColor != Color.white)\n            _chamberClosed.GetComponent<Renderer>().material.color = _closedColor;\n    }\n    \n    private void SetupAudioSource()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        _audioSource.clip = _unlockSound;\n        _audioSource.loop = true;\n        _audioSource.volume = 0.5f;\n    }\n    \n    private void SpawnLoot()\n    {\n        _spawnTimer = 0f;\n        \n        if (_requireKeySequence)\n        {\n            Invoke(nameof(OpenChamber), _spawnDelay);\n        }\n        else\n        {\n            Invoke(nameof(OpenChamber), _spawnDelay);\n            StartCoroutine(SpawnLootCoroutine());\n        }\n    }\n    \n    private void OpenChamber()\n    {\n        if (!_isSealed)\n            return;\n            \n        _currentKeyIndex = 0;\n        \n        // Play opening sound\n        if (_audioSource != null && _openSound != null)\n            _audioSource.PlayOneShot(_openSound);\n            \n        // Apply open material\n        if (_openMaterial != null)\n            GetComponent<Renderer>().material = _openMaterial;\n        else\n        {\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null)\n                renderer.material = new Material(renderer.material);\n            \n            _chamberClosed.GetComponent<Renderer>().enabled = false;\n            _closedMaterial = renderer.material;\n        }\n        \n        // Start key sequence timer\n        StartCoroutine(KeySequenceCoroutine());\n    }\n    \n    private IEnumerator KeySequenceCoroutine()\n    {\n        bool sequenceCompleted = false;\n        float sequenceTime = 0f;\n        \n        while (!_sequenceCompleted)\n        {\n            if (_currentKeyIndex < _keySequence.Count)\n            {\n                KeyCode requiredKey = _keySequence[_currentKeyIndex];\n                \n                if (Input.GetKeyDown(requiredKey))\n                {\n                    _currentKeyIndex++;\n                    \n                    // Play click sound\n                    if (_audioSource != null && _unlockSound != null)\n                        _audioSource.PlayOneShot(_unlockSound);\n                }\n            }\n            else\n            {\n                // Check if sequence was completed within time limit\n                if (sequenceTime >= 2f)\n                {\n                    _sequenceCompleted = true;\n                }\n                else\n                {\n                    yield return null;\n                    sequenceTime += Time.deltaTime;\n                }\n            }\n            \n            yield return null;\n        }\n        \n        if (_requireKeySequence && _currentKeyIndex == _keySequence.Count)\n        {\n            // Unlock chest\n            UnlockedChamber();\n        }\n    }\n    \n    private void UnlockedChamber()\n    {\n        if (!_isSealed)\n            return;\n            \n        _isSealed = false;\n        \n        // Play unlock sound loop\n        if (_audioSource != null && _unlockSound != null)\n        {\n            _audioSource.Play();\n            StartCoroutine(UnlockLoopCoroutine());\n        }\n        \n        // Show unlock particles\n        if (_unlockParticles != null)\n            _unlockParticles.Play();\n    }\n    \n    private IEnumerator UnlockLoopCoroutine()\n    {\n        float loopTime = 0f;\n        \n        while (loopTime < 10f)\n        {\n            yield return new WaitForSeconds(1f);\n            loopTime += 2f;\n            \n            if (_audioSource != null && _unlockSound != null)\n                _audioSource.Play();\n        }\n    }\n    \n    private void UnlockedLoot()\n    {\n        // Spawn loot items\n        foreach (var item in _lootItems)\n        {\n            GameObject lootObject = Instantiate(item.gameObject, _chestTransform.position, Quaternion.identity);\n            \n            // Play loot spawn sound\n            if (_audioSource != null && _lootSpawnSounds != null)\n                _audioSource.PlayOneShot(_lootSpawnSounds[Random.Range(0, _lootSpawnSounds.Length)]);\n        }\n    }\n    \n    private void EmptyChamber()\n    {\n        if (!_isSealed)\n            return;\n            \n        // Play empty sound\n        if (_audioSource != null && _emptyChamberSound != null)\n            _audioSource.PlayOneShot(_emptyChamberSound);\n            \n        // Apply cobweb effect\n        if (_chamberClosed != null)\n        {\n            _chamberClosed.GetComponent<Renderer>().enabled = true;\n            _closedMaterial = _chamberClosed.GetComponent<Renderer>().material;\n            \n            Color originalColor = _chamberClosed.GetComponent<Renderer>().material.color;\n            _closedMaterial.color = new Color(originalColor.r, 0.5f, 0.3f);\n        }\n        \n        // Hide chamber closed component\n        _chamberClosed.SetActive(false);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isSealed && other.CompareTag(\"Player\"))\n            EmptyChamber();\n    }\n    \n    private void OnApplicationQuit()\n    {\n        if (_closedMaterial != null)\n            GetComponent<Renderer>().material = _closedMaterial;\n            \n        if (_chamberClosed != null)\n            Destroy(_chamberClosed);\n    }\n    \n    [System.Serializable]\n    public class LootItem\n    {\n        [SerializeField] private GameObject _lootObject;\n        \n        public virtual void OnLootSpawned()\n        {\n            Debug.Log(\"Loot spawned: \" + GetType().Name);\n        }\n    }\n    \n    [System.Serializable]\n    public class KeySequenceData\n    {\n        [SerializeField] private KeyCode[] _keySequence;\n    }\n    \n    // Example loot items\n    private const int DEFAULT_LOOT_COUNT = 3;\n    private static List<LootItem> _defaultLootItems = new List<LootItem>();\n    \n    static void InitializeDefaultLoot()\n    {\n        if (_defaultLootItems.Count == 0)\n        {\n            GameObject loot1 = new GameObject(\"Gold Coin\");\n            loot1.AddComponent<DropItem>();\n            _defaultLootItems.Add(new GoldCoinLoot(loot1));\n            \n            GameObject loot2 = new GameObject(\"Silver Coin\");\n            loot2.AddComponent<DropItem>();\n            _defaultLootItems.Add(new SilverCoinLoot(loot2));\n            \n            GameObject loot3 = new GameObject(\"Gem\");\n            loot3.AddComponent<DropItem>();\n            _defaultLootItems.Add(new GemLoot(loot3));\n        }\n    }\n    \n    public class GoldCoinLoot : LootItem\n    {\n        [SerializeField] private Transform _coinTransform;\n        \n        public override void OnLootSpawned()\n        {\n            if (_coinTransform == null)\n                _coinTransform = transform.Find(\"Gold Coin\");\n                \n            if (_coinTransform != null)\n                Instantiate(_coinTransform);\n        }\n    }\n    \n    public class SilverCoinLoot : LootItem\n    {\n        [SerializeField] private Transform _silverCoinTransform;\n        \n        public override void OnLootSpawned()\n        {\n            if (_silverCoinTransform == null)\n                _silverCoinTransform = transform.Find(\"Silver Coin\");\n                \n            if (_silverCoinTransform != null)\n                Instantiate(_silverCoinTransform);\n        }\n    }\n    \n    public class GemLoot : LootItem\n    {\n        [SerializeField] private Transform _gemTransform;\n        \n        public override void OnLootSpawned()\n        {\n            if (_gemTransform == null)\n                _gemTransform = transform.Find(\"Gem\");\n                \n            if (_gemTransform != null)\n                Instantiate(_gemTransform);\n        }\n    }\n    \n    // Add more loot item types as needed\n}",
    "ir_json": {
      "class_name": "TreasureChest",
      "components": [
        "Collider",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "isLocked",
          "type": "bool",
          "default": true
        },
        {
          "name": "keyRequired",
          "type": "int",
          "default": 3
        },
        {
          "name": "unlockTimeLimit",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "currentKeyPressCount",
          "type": "int",
          "default": 0
        },
        {
          "name": "hasBeenOpened",
          "type": "bool",
          "default": false
        },
        {
          "name": "requiredKeysCollected",
          "type": "bool",
          "default": false
        },
        {
          "name": "lootItems",
          "type": "GameObject[]",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "lock_chest",
          "trigger": "when chest is created or starts as locked",
          "actions": [
            {
              "action": "show golden shimmer effect"
            },
            {
              "action": "play mysterious humming sound in loop"
            },
            {
              "action": "hide loot inside chest"
            },
            {
              "action": "set locked state to true"
            }
          ]
        },
        {
          "name": "start_key_sequence",
          "trigger": "when player presses first key near locked chest and has all required keys",
          "actions": [
            {
              "action": "increment current key press count"
            },
            {
              "action": "play click sound effect"
            },
            {
              "action": "update animation to show key being inserted"
            }
          ]
        },
        {
          "name": "check_key_sequence_progress",
          "trigger": "when any key is pressed near locked chest after first attempt",
          "actions": [
            {
              "action": "increment current key press count"
            },
            {
              "action": "play click sound effect"
            }
          ]
        },
        {
          "name": "complete unlocks",
          "trigger": "when current key press count reaches required keys and time limit is met",
          "actions": [
            {
              "action": "set locked state to false"
            },
            {
              "action": "disable humming sound"
            },
            {
              "action": "play click sound once more"
            }
          ]
        },
        {
          "name": "open_chest_door",
          "trigger": "when chest door unlocks successfully",
          "actions": [
            {
              "action": "slowly lift lid with creaking sound"
            },
            {
              "action": "show golden light inside chest"
            },
            {
              "action": "play opening sequence animation"
            }
          ]
        },
        {
          "name": "reveal_loot",
          "trigger": "when chest lid is fully opened and loot visibility is triggered",
          "actions": [
            {
              "action": "emit celebratory fanfare sound"
            },
            {
              "action": "spawn random loot items inside chest"
            },
            {
              "action": "play bright sparkle effect around chest"
            },
            {
              "action": "show chest with visible lid and contents"
            }
          ]
        },
        {
          "name": "show_loot_contents",
          "trigger": "when player interacts with opened chest lid",
          "actions": [
            {
              "action": "display spawned loot items visually"
            },
            {
              "action": "play item collection sound for each loot piece"
            },
            {
              "action": "hide loot spawn effects"
            }
          ]
        },
        {
          "name": "empty_chest",
          "trigger": "when all loot has been collected from chest",
          "actions": [
            {
              "action": "show duller gold appearance on lid and contents"
            },
            {
              "action": "add subtle cobweb effects inside chest"
            },
            {
              "action": "play low humming sound as background"
            }
          ]
        },
        {
          "name": "hide_chest_content",
          "trigger": "when player moves away from opened chest",
          "actions": [
            {
              "action": "gradually fade out bright light from chest interior"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest Settings\")]\n    [SerializeField] private bool _isLocked = true;\n    [SerializeField] private int _keyRequired = 3;\n    [SerializeField] private float _unlockTimeLimit = 2f;\n    [SerializeField] private float _unlockInterval = 0.5f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _lockAnimation = \"LockChest\";\n    [SerializeField] private string _unlockAnimation = \"UnlockChest\";\n    [SerializeField] private string _openLidAnimation = \"OpenLid\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _shimmerParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _unlockSounds;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _lockSounds;\n    [SerializeField] private AudioClip[] _itemCollectionSounds;\n    \n    [Header(\"Loot Settings\")]\n    [SerializeField] private GameObject[] _lootItems;\n    [SerializeField] private float _lootSpawnRadius = 2f;\n    [SerializeField] private float _lootSpawnHeight = 1.5f;\n    [SerializeField] private float _lootSpawnDuration = 0.3f;\n    \n    private bool _hasKeyBeenCollected = false;\n    private float _currentUnlockTime = 0f;\n    private int _keyCount = 0;\n    private bool _isBeingUnlocked = false;\n    private Collider _chestCollider;\n    private Renderer _renderer;\n    private List<Collider> _lootColliders = new List<Collider>();\n    \n    public void AddLootItem(GameObject item)\n    {\n        if (_isLocked) return;\n        \n        var lootSpawnPoint = transform.position + Random.insideUnitSphere * _lootSpawnRadius;\n        lootSpawnPoint.y += Random.Range(-_lootSpawnHeight, _lootSpawnHeight);\n        \n        GameObject lootSpawnObject = Instantiate(item, lootSpawnPoint, Quaternion.identity);\n        _lootItems.Add(lootSpawnObject);\n    }\n    \n    public void AddLootItemAtPosition(GameObject item, Vector3 position)\n    {\n        if (_isLocked) return;\n        \n        var spawnPoint = position;\n        spawnPoint.y += Random.Range(-_lootSpawnHeight, _lootSpawnHeight);\n        \n        GameObject lootSpawnObject = Instantiate(item, spawnPoint, Quaternion.identity);\n        _lootItems.Add(lootSpawnObject);\n    }\n    \n    public void CollectLoot()\n    {\n        foreach (GameObject item in _lootItems)\n        {\n            Destroy(item);\n        }\n        \n        _lootItems = new GameObject[0];\n        _lootColliders.Clear();\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        if (_isLocked)\n        {\n            UnlockChest();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        _chestCollider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_shimmerParticles != null)\n        {\n            _shimmerParticles.Play();\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(_lockAnimation, true);\n            _animator.SetBool(_unlockAnimation, false);\n            _animator.SetBool(_openLidAnimation, false);\n        }\n    }\n    \n    private void UnlockChest()\n    {\n        if (!_isLocked) return;\n        \n        StartCoroutine(UnlockSequence());\n    }\n    \n    private IEnumerator UnlockSequence()\n    {\n        _isBeingUnlocked = true;\n        \n        // Play lock animation\n        if (_animator != null)\n            _animator.SetBool(_lockAnimation, true);\n        \n        float timer = 0f;\n        while (timer < _unlockTimeLimit && !_hasKeyBeenCollected)\n        {\n            timer += _unlockInterval;\n            \n            // Check for key collection\n            if (_keyCount >= _keyRequired)\n            {\n                _hasKeyBeenCollected = true;\n                \n                PlayUnlockSound();\n                OnChestUnlocked();\n                \n                yield break;\n            }\n            \n            // Update unlock progress in animation\n            if (_animator != null)\n                _animator.SetBool(_unlockAnimation, timer <= _unlockTimeLimit);\n            \n            yield return new WaitForSeconds(_unlockInterval);\n        }\n        \n        // Finalize unlock animation\n        if (_animator != null)\n            _animator.SetBool(_lockAnimation, false);\n        \n        // Wait for remaining time to complete\n        float remainingTime = Mathf.Max(0f, _unlockTimeLimit - timer);\n        yield return new WaitForSeconds(remainingTime);\n    }\n    \n    public void AddKey()\n    {\n        if (_isLocked) return;\n        \n        _keyCount++;\n        PlayKeyCollectionSound();\n        \n        // Update animation to show key being added\n        if (_animator != null)\n            _animator.SetBool(_openLidAnimation, true);\n    }\n    \n    private void OnChestUnlocked()\n    {\n        PlayUnlockSound();\n        UnlockLid();\n        ShowLootInsideChest();\n    }\n    \n    private void UnlockLid()\n    {\n        if (_renderer != null)\n            _renderer.enabled = false;\n        \n        if (_animator != null)\n            _animator.SetBool(_openLidAnimation, true);\n    }\n    \n    private void ShowLootInsideChest()\n    {\n        // Spawn loot items inside chest\n        for (int i = 0; i < _lootItems.Length; i++)\n        {\n            GameObject lootItem = _lootItems[i];\n            \n            if (lootItem != null)\n            {\n                Vector3 spawnPosition = transform.position + Random.insideUnitSphere * 1f;\n                spawnPosition.y += Random.Range(-_lootSpawnHeight, _lootSpawnHeight);\n                \n                // Spawn loot item at position\n                GameObject spawnedItem = Instantiate(lootItem, spawnPosition, Quaternion.identity);\n                \n                // Add to list of visible loot\n                if (spawnedItem != null)\n                    _lootColliders.Add(spawnedItem.GetComponent<Collider>());\n            }\n        }\n        \n        // Disable shimmer particles when lid is open\n        if (_shimmerParticles != null)\n            _shimmerParticles.Stop();\n    }\n    \n    public void CollectLootFromChest()\n    {\n        if (!_isLocked) return;\n        \n        // Spawn loot around chest\n        for (int i = 0; i < _lootItems.Length; i++)\n        {\n            GameObject lootItem = _lootItems[i];\n            \n            if (lootItem != null)\n            {\n                Vector3 spawnPosition = transform.position + Random.insideUnitSphere * _keySpawnRadius;\n                spawnPosition.y += Random.Range(-_keySpawnHeight, _keySpawnHeight);\n                \n                // Spawn loot item at position\n                GameObject spawnedItem = Instantiate(lootItem, spawnPosition, Quaternion.identity);\n            }\n        }\n        \n        // Clean up chest contents\n        CollectLoot();\n    }\n    \n    public void ShowLid()\n    {\n        if (_renderer != null)\n            _renderer.enabled = true;\n        \n        if (_animator != null)\n            _animator.SetBool(_openLidAnimation, false);\n    }\n    \n    private void PlayUnlockSound()\n    {\n        if (_audioSource == null) return;\n        \n        int index = Random.Range(0, _unlockSounds.Length);\n        if (index >= 0 && _unlockSounds[index] != null)\n            _audioSource.PlayOneShot(_unlockSounds[index]);\n    }\n    \n    private void PlayKeyCollectionSound()\n    {\n        if (_lockSounds == null || _lockSounds.Length <= 0) return;\n        \n        int index = Random.Range(0, _lockSounds.Length);\n        if (index >= 0 && _itemCollectionSounds != null)\n            _audioSource.PlayOneShot(_itemCollectionSounds[index]);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 spawnPoint = transform.position + Random.insideUnitSphere * 1f;\n        spawnPoint.y += Random.Range(-_lootSpawnHeight, _lootSpawnHeight);\n        \n        // Draw gizmos for loot spawn area\n        Gizmos.DrawWireSphere(spawnPoint, _keySpawnRadius);\n        \n        // Draw chest outline\n        if (_renderer != null)\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, Vector3.one * 2f);\n    }\n    \n    public bool IsLocked => _isLocked;\n    public int KeyCount => _keyCount;\n    public GameObject[] LootItems => _lootItems;\n    public Collider ChestCollider => _chestCollider;\n}\n\n// Helper Script: Key Collection System\npublic class KeyCollectionSystem : MonoBehaviour\n{\n    [Header(\"Key Settings\")]\n    [SerializeField] private GameObject[] _collectibleKeys;\n    [SerializeField] private int _keyRequired = 3;\n    [SerializeField] private float _keySpawnRadius = 2f;\n    [SerializeField] private float _keySpawnHeight = 1.5f;\n    [SerializeField] private float _keySpawnDuration = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _lockSounds;\n    [SerializeField] private AudioClip[] _unlockSounds;\n    \n    private List<GameObject> _collectedKeys = new List<GameObject>();\n    private bool _isLocked = true;\n    private Collider _playerCollider;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    \n    public void CollectKey(GameObject key)\n    {\n        if (_isLocked) return;\n        \n        _collectedKeys.Add(key);\n        PlayKeyCollectionSound();\n    }\n    \n    public void AddKey()\n    {\n        GameObject newKey = Instantiate(_collectibleKeys[Random.Range(0, _collectibleKeys.Length)]);\n        newKey.SetActive(true);\n        \n        Vector3 spawnPosition = transform.position + Random.insideUnitSphere * _keySpawnRadius;\n        spawnPosition.y += Random.Range(-_keySpawnHeight, _keySpawnHeight);\n        \n        // Add to collection\n        _collectedKeys.Add(newKey);\n        PlayKeyCollectionSound();\n    }\n    \n    public void UnlockChest()\n    {\n        if (_isLocked) return;\n        \n        _isLocked = false;\n        OnChestUnlocked();\n    }\n    \n    private void Start()\n    {\n        _playerCollider = GameObject.FindGameObjectWithTag(\"Player\").GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer != null)\n            _renderer.enabled = true;\n            \n        if (_audioSource != null && _lockSounds.Length > 0)\n        {\n            _audioSource.PlayOneShot(_lockSounds[Random.Range(0, _lockSounds.Length)]);\n        }\n    }\n    \n    private void OnChestUnlocked()\n    {\n        GameObject[] visibleKeys = new GameObject[_collectedKeys.Count];\n        \n        for (int i = 0; i < _collectedKeys.Count; i++)\n        {\n            visibleKeys[i] = _collectedKeys[i].GetComponent<Collider>();\n        }\n        \n        // Disable all collectible keys\n        foreach (GameObject key in _collectibleKeys)\n        {\n            if (key != null)\n                key.SetActive(false);\n        }\n        \n        // Draw gizmos for collected keys\n        Gizmos.color = Color.green;\n        Vector3 spawnPoint = transform.position + new Vector3(Random.Range(-_keySpawnRadius, _keySpawnRadius), 0f, Random.Range(-_keySpawnHeight, _keySpawnHeight));\n        Gizmos.DrawWireSphere(spawnPoint, _keySpawnRadius);\n        \n        // Draw chest outline\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 2f);\n    }\n    \n    private void PlayKeyCollectionSound()\n    {\n        if (_audioSource == null) return;\n        \n        int index = Random.Range(0, _lockSounds.Length);\n        if (index >= 0 && _unlockSounds != null)\n            _audioSource.PlayOneShot(_unlockSounds[index]);\n    }\n}\n\n// Attach this script to the TreasureChest GameObject\n// Add required components: Collider, Renderer, AudioSource\npublic class TreasureChestController : MonoBehaviour\n{\n    [Header(\"Key Collection\")]\n    [SerializeField] private GameObject[] _collectibleKeys;\n    [SerializeField] private int _keyRequired = 3;\n    [SerializeField] private float _keySpawnRadius = 2f;\n    [SerializeField] private float _keySpawnHeight = 1.5f;\n    [SerializeField] private float _keySpawnDuration = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _lockSounds;\n    [SerializeField] private AudioClip[] _unlockSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _shimmerParticles;\n    [SerializeField] private GameObject _chestDoor;\n    [SerializeField] private float _doorOpenDuration = 1f;\n    \n    private List<GameObject> _collectedKeys = new List<GameObject>();\n    private bool _isLocked = true;\n    private Collider _playerCollider;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Coroutine _unlockCoroutine;\n    private Coroutine _openDoorCoroutine;\n    \n    public void CollectKey(GameObject key)\n    {\n        if (_isLocked) return;\n        \n        _collectedKeys.Add(key);\n        PlayKeyCollectionSound();\n    }\n    \n    public void AddKey()\n    {\n        GameObject newKey = Instantiate(_collectibleKeys[Random.Range(0, _collectibleKeys.Length)]);\n        newKey.SetActive(true);\n        \n        Vector3 spawnPosition = transform.position + Random.insideUnitSphere * _keySpawnRadius;\n        spawnPosition.y += Random.Range(-_keySpawnHeight, _keySpawnHeight);\n        \n        // Add to collection\n        _collectedKeys.Add(newKey);\n        PlayKeyCollectionSound();\n    }\n    \n    public void UnlockChest()\n    {\n        if (!_isLocked) return;\n        \n        _isLocked = false;\n        OnChestUnlocked();\n    }\n    \n    private void Start()\n    {\n        _playerCollider = GameObject.FindGameObjectWithTag(\"Player\").GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer != null)\n            _renderer.enabled = true;\n            \n        if (_audioSource != null && _lockSounds.Length > 0)\n        {\n            PlayLockSound();\n        }\n    }\n    \n    private void OnChestUnlocked()\n    {\n        if (!_isLocked) return;\n        \n        // Start unlocking sequence\n        _unlockCoroutine = StartCoroutine(UnlockSequence());\n    }\n    \n    private IEnumerator UnlockSequence()\n    {\n        float timer = 0f;\n        while (timer < _keyRequired && !_hasKeyBeenCollected)\n        {\n            timer += Time.deltaTime;\n            yield return new WaitForSeconds(1f);\n            \n            if (timer >= _keyRequired)\n            {\n                _hasKeyBeenCollected = true;\n                PlayUnlockSound();\n                OnChestUnlocked();\n                break;\n            }\n        }\n        \n        // Finalize unlock\n        if (_isLocked && !_hasKeyBeenCollected)\n        {\n            _isLocked = false;\n            ShowLid();\n            yield return new WaitForSeconds(_doorOpenDuration);\n            _openDoorCoroutine = StartCoroutine(OpenDoor());\n        }\n    }\n    \n    private IEnumerator OpenDoor()\n    {\n        if (_chestDoor == null) return;\n        \n        // Play unlock sound\n        PlayUnlockSound();\n        \n        // Move door open\n        Vector3 startPos = _chestDoor.transform.position;\n        float duration = 0f;\n        \n        while (duration < _doorOpenDuration)\n        {\n            duration += Time.deltaTime;\n            _chestDoor.transform.position = startPos + Vector3.up * duration / _doorOpenDuration;\n            yield return null;\n        }\n        \n        // Play open sound\n        if (_audioSource != null && _unlockSounds.Length > 0)\n            _audioSource.PlayOneShot(_unlockSounds[Random.Range(0, _unlockSounds.Length)]);\n    }\n    \n    private void PlayLockSound()\n    {\n        if (_lockSounds == null || _lockSounds.Length <= 0) return;\n        \n        int index = Random.Range(0, _lockSounds.Length);\n        if (index >= 0)\n            _audioSource.PlayOneShot(_lockSounds[index]);\n    }\n    \n    private void PlayUnlockSound()\n    {\n        if (_unlockSounds == null || _unlockSounds.Length <= 0) return;\n        \n        int index = Random.Range(0, _unlockSounds.Length);\n        if (index >= 0)\n            _audioSource.PlayOneShot(_unlockSounds[index]);\n    }\n    \n    private void PlayKeyCollectionSound()\n    {\n        if (_lockSounds == null || _lockSounds.Length <= 0) return;\n        \n        int index = Random.Range(0, _lockSounds.Length);\n        if (index >= 0)\n            _audioSource.PlayOneShot(_lockSounds[index]);\n    }\n    \n    public void ShowLid()\n    {\n        if (_renderer != null)\n            _renderer.enabled = true;\n            \n        if (_animator != null && _openLidAnimation != string.Empty)\n            _animator.SetBool(\"OpenLid\", true);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw collectible key areas\n        for (int i = 0; i < _collectibleKeys.Length; i++)\n        {\n            GameObject keyObj = _collectibleKeys[i];\n            if (keyObj != null)\n            {\n                Vector3 spawnPoint = transform.position + new Vector3(Random.Range(-_keySpawnRadius, _keySpawnRadius), 0f, Random.Range(-_keySpawnHeight, _keySpawnHeight));\n                Gizmos.DrawWireSphere(spawnPoint, _keySpawnRadius);\n            }\n        }\n        \n        // Draw chest outline\n        if (_renderer != null)\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, Vector3.one * 2f);\n    }\n    \n    private bool _hasKeyBeenCollected => _collectedKeys.Count >= _keyRequired;\n}\n\n// Attach this script to the TreasureChest GameObject\n// Add required components: Collider, Renderer, AudioSource\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest Settings\")]\n    [SerializeField] private bool _isLocked = true;\n    [SerializeField] private int _keyRequired = 3;\n    [SerializeField] private float _unlockTimeLimit = 2f;\n    [SerializeField] private float _unlockInterval = 0.5f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _lockAnimation = \"LockChest\";\n    [SerializeField] private string _unlockAnimation = \"UnlockC",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.63)",
      "Animator.GetCurrentAnimationClipState (0.62)",
      "Animation.AddClip (0.61)",
      "Animator.PlayInFixedTime (0.61)",
      "Animation.GetClipCount (0.61)",
      "Animator.GetNextAnimationClipState (0.60)",
      "AnimationCurve.GetKeys (0.43)",
      "AnimationCurve.ClearKeys (0.42)",
      "AnimationMode.SamplePlayableGraph (0.42)",
      "AnimationClip.ClearCurves (0.42)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest Settings\")]\n    public float _requiredKeyPresses = 3f;\n    public float _keyPressCooldown = 2f;\n    public float _lidOpenSpeed = 1f;\n    public float _lidCloseSpeed = 0.5f;\n    public float _lidHeight = 0.8f;\n    public float _maxLidAngle = 45f;\n    \n    [Header(\"Audio\")]\n    public AudioSource audioSource;\n    public AudioClip[] _keyPressSounds;\n    public AudioClip _openSound;\n    public AudioClip _closeSound;\n    public AudioClip _emptySound;\n    public AudioClip _mysteriousHummingSound;\n    \n    [Header(\"Visual Effects\")]\n    public GameObject _lidObject;\n    public Transform _chestTransform;\n    public Light _chestLight;\n    public ParticleSystem _sparksOnOpen;\n    public ParticleSystem _cobwebsOnClose;\n    public TrailRenderer _trailRenderer;\n    \n    [Header(\"Loot\")]\n    public GameObject[] _lootItems;\n    private int _currentKeyPressCount = 0f;\n    private float _lastKeyTime = -1f;\n    private bool _isSealed = true;\n    private bool _hasBeenOpened = false;\n    private bool _hasLidBeenMoved = false;\n    \n    private void Start()\n    {\n        if (_requiredKeyPresses <= 0)\n            _requiredKeyPresses = 1f;\n            \n        if (_keyPressSounds == null)\n            _keyPressSounds = new AudioClip[_requiredKeyPresses];\n            \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        CheckLidMovement();\n        UpdateVisualEffects();\n        PlaySounds();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            TryOpenLid();\n        }\n        \n        // Key press for key sequence\n        if (Input.GetKeyDown(KeyCode.Space) && !_isSealed)\n        {\n            PerformKeyPressSequence();\n        }\n    }\n    \n    private void CheckLidMovement()\n    {\n        if (_hasLidBeenMoved)\n            return;\n            \n        float angle = _chestTransform.localEulerAngles.y;\n        \n        // Detect lid movement\n        if (angle != 0f && Mathf.Abs(angle) > 1f)\n        {\n            _hasLidBeenMoved = true;\n            return;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_trailRenderer == null)\n            return;\n            \n        float angle = _chestTransform.localEulerAngles.y;\n        \n        // Animate trail based on lid movement\n        if (angle != 0f && Mathf.Abs(angle) > 1f)\n        {\n            _trailRenderer.enabled = true;\n            _trailRenderer.position = _chestTransform.position;\n            _trailRenderer.startColor = Color.yellow;\n            _trailRenderer.endColor = Color.white;\n            _trailRenderer.useWorldSpace = false;\n            return;\n        }\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n    }\n    \n    private void PerformKeyPressSequence()\n    {\n        if (!_isSealed || _currentKeyPressCount >= _requiredKeyPresses)\n            return;\n            \n        // Update cooldown\n        _lastKeyTime = Time.time;\n        \n        // Play key press sound\n        if (_keyPressSounds.Length > 0 && _keyPressSounds.Length <= _currentKeyPressCount)\n        {\n            AudioClip sound = _keyPressSounds[_currentKeyPressCount];\n            if (sound != null)\n                audioSource.PlayOneShot(sound);\n        }\n        \n        // Increment key presses\n        _currentKeyPressCount++;\n    }\n    \n    private void TryOpenLid()\n    {\n        if (_isSealed && !_hasBeenOpened)\n        {\n            OpenLid();\n        }\n    }\n    \n    private void OpenLid()\n    {\n        if (!_isSealed || _hasLidBeenMoved)\n            return;\n            \n        _isSealed = false;\n        _hasBeenOpened = true;\n        \n        // Play mysterious humming\n        if (_mysteriousHummingSound != null && audioSource == null)\n        {\n            audioSource = GetComponent<AudioSource>();\n            if (audioSource != null)\n                audioSource.PlayOneShot(_mysteriousHummingSound);\n        }\n        \n        // Open lid visually\n        if (_lidObject != null)\n        {\n            _lidObject.SetActive(true);\n            _lidObject.transform.Rotate(0, 90f, 0f);\n        }\n        \n        // Light effect\n        if (_chestLight != null)\n        {\n            _chestLight.enabled = true;\n            _chestLight.intensity = 2f;\n            _chestLight.color = Color.yellow;\n        }\n    }\n    \n    private void CloseLid()\n    {\n        if (!_isSealed || _hasLidBeenMoved)\n            return;\n            \n        _isSealed = true;\n        _hasLidBeenMoved = false;\n        \n        // Play close sound\n        if (_closeSound != null && audioSource == null)\n        {\n            audioSource = GetComponent<AudioSource>();\n            if (audioSource != null)\n                audioSource.PlayOneShot(_closeSound);\n        }\n        \n        // Close lid visually\n        if (_lidObject != null)\n        {\n            _lidObject.SetActive(false);\n        }\n        \n        // Light effect\n        if (_chestLight != null)\n        {\n            _chestLight.enabled = false;\n            _chestLight.color = Color.white;\n        }\n    }\n    \n    private void RevealLoot()\n    {\n        if (_hasBeenOpened && !_hasLidBeenMoved)\n        {\n            // Spawn loot items\n            foreach (GameObject item in _lootItems)\n            {\n                if (!item.activeInHierarchy)\n                    item.SetActive(true);\n            }\n            \n            // Play celebratory sound\n            if (_openSound != null && audioSource == null)\n            {\n                audioSource = GetComponent<AudioSource>();\n                if (audioSource != null)\n                    audioSource.PlayOneShot(_openSound);\n            }\n        }\n    }\n    \n    private void ShowEmptyLoot()\n    {\n        if (!_hasBeenOpened && !_hasLidBeenMoved)\n        {\n            // Play empty sound\n            if (_emptySound != null && audioSource == null)\n            {\n                audioSource = GetComponent<AudioSource>();\n                if (audioSource != null)\n                    audioSource.PlayOneShot(_emptySound);\n            }\n            \n            // Add cobwebs effect\n            if (_cobwebsOnClose != null)\n                _cobwebsOnClose.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw lid position\n        Vector3 lidPosition = new Vector3(\n            transform.position.x,\n            transform.localEulerAngles.y + 90f,\n            transform.position.z\n        );\n        \n        Gizmos.DrawWireCube(lidPosition, _lidHeight * 0.5f);\n    }\n    \n    public void TryOpenLidWithKeySequence()\n    {\n        PerformKeyPressSequence();\n        if (_currentKeyPressCount >= _requiredKeyPresses)\n        {\n            CloseLid();\n            RevealLoot();\n        }\n    }\n}",
    "per_behavior_docs": 17,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "initialize_chest": [
        "AudioVelocityUpdateMode (0.53)",
        "ResolutionDialogSetting (0.52)",
        "StereoTargetEyeMask (0.52)"
      ],
      "handle_key_press_sequence": [
        "WaitTimeoutMode (0.63)",
        "Time (0.62)",
        "Animator.PlayInFixedTime (0.61)"
      ],
      "check_key_sequence_completion": [
        "WaitTimeoutMode (0.63)",
        "Time (0.61)",
        "WaitForSeconds (0.60)"
      ],
      "open_chest_door": [
        "Transform.GetPositionAndRotation (0.66)",
        "Transform.SetPositionAndRotation (0.66)",
        "Animator.GetIKHintPositionWeight (0.66)"
      ],
      "reveal_loot_contents": [
        "Light.AddCommandBufferAsync (0.69)",
        "Light.SetLightDirty (0.68)",
        "Light.GetCommandBuffers (0.67)"
      ],
      "close_chest_door": [
        "StereoTargetEyeMask (0.63)",
        "Transform.GetPositionAndRotation (0.63)",
        "RigidbodyInterpolation (0.63)"
      ],
      "handle_empty_chest": [
        "PlayerSettings (0.60)",
        "PlayerConnectionInitiateMode (0.60)",
        "PlayMode (0.59)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 3,
        "fixability": 2,
        "unity_patterns": 4,
        "correctness": 3,
        "completeness": 2,
        "weighted_total": 36,
        "justification": "Code is poorly structured with large methods, mixing concerns. Lacks clear state management and has incomplete implementations. Serialized fields are present but chaotic. Shows signs of direct translation without Unity best practices."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 68,
        "justification": "Well-structured with clear method separation, good use of Unity serialization, robust error handling. Methods are modular, with clear responsibilities. Demonstrates strong understanding of component-based design with extensible patterns."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 7,
        "correctness": 5,
        "completeness": 5,
        "weighted_total": 57,
        "justification": "Good separation of concerns, with methods targeting specific behaviors. Slightly less structured than monolithic approach. Uses Unity patterns effectively but has some method complexity and incomplete implementations."
      },
      "winner": "ir_monolithic",
      "key_differences": "Monolithic approach provides most robust implementation with clear state management, modular design, and comprehensive Unity integration",
      "advantages": "Best balance of architectural clarity, maintainability, and adherence to Unity development patterns. Provides clear extension points and demonstrates systematic approach to solving complex object behavior"
    },
    "error": null
  },
  {
    "prompt_num": 6,
    "prompt": "Make a rubber duck that squeaks louder each time it's squeezed, changes color through pastel shades with each squeak, and after 15 squeaks launches into the air spinning rapidly while playing an absurd fanfare, then gently floats back down with a tiny parachute.",
    "timestamp": "2026-01-08T22:06:21.852285",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RubberDuck : MonoBehaviour\n{\n    [Header(\"Rubber Duck Visual\")]\n    [SerializeField] private GameObject _duckModel;\n    [SerializeField] private Renderer _renderer;\n    \n    [Header(\"Color Animation\")]\n    [SerializeField] private Color[] _colorPalette = new Color[]\n    {\n        Color.white,\n        new Color(0.9f, 0.95f, 1f),\n        new Color(0.85f, 0.9f, 0.98f),\n        new Color(0.8f, 0.85f, 0.96f),\n        new Color(0.75f, 0.8f, 0.93f),\n        new Color(0.7f, 0.75f, 0.9f),\n        new Color(0.65f, 0.7f, 0.87f),\n        new Color(0.6f, 0.68f, 0.85f),\n        new Color(0.55f, 0.66f, 0.83f),\n        new Color(0.5f, 0.64f, 0.8f)\n    };\n    \n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    [SerializeField] private int _totalSqueaks = 15;\n    [SerializeField] private bool _useRandomColors = false;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _squeakClips;\n    [SerializeField] private float _volumeMultiplier = 1f;\n    [SerializeField] private int _clipIndex = 0;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _initialBounciness = 2f;\n    [SerializeField] private float _dragCoefficient = 0.9f;\n    [SerializeField] private float _gravityScale = 1.5f;\n    [SerializeField] private float _maxRotationSpeed = 360f;\n    \n    private int _currentSqueakCount = 0;\n    private bool _isInAir = false;\n    private float _rotationSpeed = 0f;\n    private float _originalDrag;\n    private Vector3 _originalPosition;\n    private float _originalVelocity;\n    \n    void Start()\n    {\n        if (_duckModel == null)\n            _duckModel = GetComponentInChildren<GameObject>();\n            \n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        SetupAudio();\n        SetupPhysics();\n    }\n    \n    void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            GameObject audioGO = new GameObject(\"AudioSource\");\n            audioGO.transform.SetParent(transform);\n            _audioSource = audioGO.AddComponent<AudioSource>();\n        }\n        \n        if (_squeakClips == null || _squeakClips.Length == 0)\n        {\n            _squeakClips = new AudioClip[] { CreateSqueakClip() };\n        }\n        \n        _audioSource.clip = _squeakClips[_clipIndex];\n        _audioSource.loop = true;\n        _audioSource.volume = _volumeMultiplier * Mathf.Min(1f, _audioSource.maxVolume);\n    }\n    \n    void SetupPhysics()\n    {\n        if (_duckModel != null)\n        {\n            Rigidbody rb = _duckModel.GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = _duckModel.AddComponent<Rigidbody>();\n            }\n            \n            _originalDrag = rb.drag;\n            _originalPosition = _duckModel.transform.position;\n            _originalVelocity = _duckModel.velocity;\n            \n            rb.drag = 0f; // Disable drag for bouncing\n            rb.angularDrag = 0f; // Disable angular drag\n            \n            // Add force for initial bounce\n            Vector3 forceDirection = -_originalVelocity.normalized * _initialBounciness;\n            rb.AddForce(forceDirection, ForceMode.Impulse);\n        }\n    }\n    \n    void Update()\n    {\n        HandleColorTransition();\n        HandleAudio();\n        HandlePhysics();\n    }\n    \n    void HandleColorTransition()\n    {\n        if (_currentSqueakCount >= _totalSqueaks) return;\n        \n        Color targetColor = GetTargetColor(_currentSqueakCount);\n        if (targetColor != _renderer.material.color)\n        {\n            _renderer.material.color = Color.Lerp(_renderer.material.color, targetColor, \n                Time.deltaTime * _colorTransitionSpeed);\n        }\n        \n        _currentSqueakCount++;\n    }\n    \n    Color GetTargetColor(int squeakIndex)\n    {\n        if (_useRandomColors)\n        {\n            return _colorPalette[Random.Range(0, _colorPalette.Length)];\n        }\n        else\n        {\n            // Fade from white to pastel colors\n            float t = (float)_currentSqueakCount / _totalSqueaks;\n            Color startColor = _colorPalette[0];\n            Color endColor = _colorPalette[_colorPalette.Length - 1];\n            \n            return Color.Lerp(startColor, endColor, t);\n        }\n    }\n    \n    void HandleAudio()\n    {\n        if (_audioSource.isPlaying && _clipIndex < _squeakClips.Length)\n        {\n            _audioSource.PlayOneShot(_squeakClips[_clipIndex]);\n            _clipIndex = (int)(_clipIndex % _squeakClips.Length);\n            \n            // Increase volume slightly each squeak\n            float newVolume = Mathf.Lerp(0f, _volumeMultiplier * 1.5f, \n                (float)_currentSqueakCount / _totalSqueaks);\n            _audioSource.volume = newVolume * Mathf.Min(1f, _audioSource.maxVolume);\n        }\n    }\n    \n    void HandlePhysics()\n    {\n        if (_isInAir && _rotationSpeed < _maxRotationSpeed)\n        {\n            _rotationSpeed += 0.1f;\n            \n            // Apply upward force to keep spinning\n            transform.Rotate(Vector3.up * 2f * Time.deltaTime);\n            \n            // Limit rotation speed\n            _rotationSpeed = Mathf.Clamp(_rotationSpeed, 0f, _maxRotationSpeed);\n        }\n        \n        if (!_isInAir)\n        {\n            // Reset physics for normal state\n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.drag = _originalDrag;\n                rb.angularDrag = 0f;\n                \n                Vector3 forceDirection = -_originalVelocity.normalized * _initialBounciness;\n                rb.AddForce(forceDirection, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isInAir = true;\n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.drag = 0f; // Keep bouncing\n                rb.angularDrag = 0f;\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (_isInAir && other.CompareTag(\"Player\"))\n        {\n            _isInAir = false;\n            \n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.drag = _originalDrag; // Restore original drag\n                rb.angularDrag = 0f;\n                \n                Vector3 forceDirection = -_originalVelocity.normalized * _initialBounciness;\n                rb.AddForce(forceDirection, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private AudioClip CreateSqueakClip()\n    {\n        AudioSource audioSource = new AudioSource();\n        \n        // Generate a squeak sound\n        float baseFrequency = 1000f + Random.Range(-200f, 200f); // Between 800-1200 Hz\n        float duration = 0.05f;\n        float pitchScale = 1f - (0.3f * _currentSqueakCount / _totalSqueaks);\n        \n        AudioClip squeakClip = audioSource.CreateSineWave(baseFrequency, duration,\n            pitchScale, 2f, 1f);\n        \n        return squeakClip;\n    }\n}",
    "ir_json": {
      "class_name": "RubberDuck",
      "components": [
        "Collider",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "maxVolume",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "currentVolume",
          "type": "float",
          "default": 0.2
        },
        {
          "name": "colorOffset",
          "type": "Color",
          "default": "white"
        },
        {
          "name": "fanfareDuration",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "parachuteSpeed",
          "type": "float",
          "default": 2.0
        }
      ],
      "behaviors": [
        {
          "name": "increase_squeak_volume",
          "trigger": "when squeezed continuously for more than half a second",
          "actions": [
            {
              "action": "gradually increase rubber duck volume up to maximum allowed",
              "target": "currentVolume"
            },
            {
              "action": "ensure volume never exceeds maxVolume"
            }
          ]
        },
        {
          "name": "change_pastel_color",
          "trigger": "each time squeak is triggered and volume increases",
          "actions": [
            {
              "action": "rotate through pastel color spectrum",
              "target": "colorOffset"
            },
            {
              "action": "use smooth gradient from current to next pastel shade"
            }
          ]
        },
        {
          "name": "fanfare_launch",
          "trigger": "when squeak volume reaches maximum and color change completes after 15th squeak",
          "actions": [
            {
              "action": "play absurd fanfare sound effect",
              "target": "audioSource"
            },
            {
              "action": "start spinning rapidly in circular motion",
              "target": "transform"
            },
            {
              "action": "increase vertical velocity upward",
              "value": "5m/s"
            }
          ]
        },
        {
          "name": "fanfare_flight",
          "trigger": "while spinning and playing fanfare sound",
          "actions": [
            {
              "action": "maintain high altitude for specified duration",
              "target": "position"
            },
            {
              "action": "create sparkling particle effects around rubber duck"
            }
          ]
        },
        {
          "name": "parachute_descent",
          "trigger": "when fanfare ends or time expires after launch",
          "actions": [
            {
              "action": "play soft descending musical notes",
              "target": "audioSource"
            },
            {
              "action": "activate small parachute attached to rubber duck",
              "target": "rigidbody"
            },
            {
              "action": "gradually decrease downward velocity to zero",
              "value": "parachuteSpeed"
            }
          ]
        },
        {
          "name": "return_to_ground",
          "trigger": "when rubber duck reaches ground level after parachute descent",
          "actions": [
            {
              "action": "fade out all audio",
              "target": "audioSource"
            },
            {
              "action": "disable spinning animation",
              "target": "Animator"
            },
            {
              "action": "set rigidbody mass back to normal",
              "value": "restore original mass"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RubberDuck : MonoBehaviour\n{\n    [Header(\"Rubber Duck Settings\")]\n    [SerializeField] private float _maxVolume = 1f;\n    [SerializeField] private float _minVolume = 0.2f;\n    [SerializeField] private float _volumeSensitivity = 5f;\n    [SerializeField] private bool _autoVolumeTuning = true;\n    \n    [Header(\"Color Animation\")]\n    [SerializeField] private Color[] _colorPalette = new Color[8];\n    [SerializeField] private int _paletteIndex = 0;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _bobSpeed = 1f;\n    [SerializeField] private float _bobHeight = 0.3f;\n    [SerializeField] private float _bobAmplitude = 0.2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _squeakClips;\n    [SerializeField] private float _baseSqueakVolume = 0.1f;\n    [SerializeField] private float _maxSqueakVolume = 0.8f;\n    \n    [Header(\"Parachute\")]\n    [SerializeField] private bool _useParachute = true;\n    [SerializeField] private float _parachuteDropSpeed = 2f;\n    [SerializeField] private float _parachuteFloatHeight = 3f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayerMask = -1;\n    [SerializeField] private float _groundCheckRadius = 0.5f;\n    \n    private Vector3 _startPosition;\n    private float _originalMass;\n    private bool _isGrounded;\n    private Coroutine _rubberDuckCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        StoreStartPosition();\n        SetupAudioSource();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n                _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_squeakClips == null)\n        {\n            _squeakClips = new AudioClip[8];\n            for (int i = 0; i < _squeakClips.Length; i++)\n                _squeakClips[i] = CreateRandomSqueak();\n        }\n        \n        if (_audioSource != null && !_audioSource.isPlaying)\n            _audioSource.Play();\n    }\n    \n    private void StoreStartPosition()\n    {\n        _startPosition = transform.position;\n        _originalMass = rigidbody.mass;\n    }\n    \n    private void SetupAudioSource()\n    {\n        if (_audioSource == null) return;\n        \n        _audioSource.volume = _baseSqueakVolume;\n        _audioSource.pitch = 1f;\n        _audioSource.spatialBlend = 1f;\n        _audioSource.loop = true;\n        \n        // Set random volume range\n        float targetVolume = Random.Range(_minVolume, _maxVolume);\n        _audioSource.volume = Mathf.Lerp(_baseSqueakVolume, targetVolume, 0.5f);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartRubberDuckBehavior();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopRubberDuckBehavior();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        SetGrounded(collision.collider.gameObject != null);\n    }\n    \n    private void CheckForGround()\n    {\n        if (_isGrounded) return;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _groundCheckRadius, _groundLayerMask);\n        \n        foreach (Collider col in colliders)\n        {\n            SetGrounded(col.gameObject != null);\n            break;\n        }\n    }\n    \n    private void SetGrounded(GameObject target)\n    {\n        if (target == null) return;\n        \n        _isGrounded = Physics.CheckSphere(target.transform.position, 0.5f, _groundLayerMask);\n        \n        if (_useParachute && !_isGrounded)\n        {\n            StartCoroutine(DropParachute());\n        }\n    }\n    \n    private void DropParachute()\n    {\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            float currentHeight = transform.position.y;\n            rb.velocity = new Vector3(0, -_parachuteDropSpeed * Time.deltaTime, 0);\n            \n            if (_useParachuteFloatHeight > 0f)\n            {\n                rb.AddForce(new Vector3(Random.insideUnitSphere), ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (_rubberDuckCoroutine == null) return;\n        \n        CheckForGround();\n        UpdateColor();\n        HandleMovement();\n        UpdateAudio();\n    }\n    \n    private float GetDistanceToPlayer()\n    {\n        Collider[] players = Physics.OverlapSphere(transform.position, _detectionRange, 1 << 16);\n        \n        foreach (Collider col in players)\n        {\n            if (col.CompareTag(\"Player\"))\n                return Vector3.Distance(transform.position, col.transform.position);\n        }\n        \n        return float.MaxValue;\n    }\n    \n    private float GetRubberDuckVolume()\n    {\n        if (_autoVolumeTuning && _audioSource != null && _audioSource.clip != null)\n        {\n            float baseVolume = _baseSqueakVolume;\n            float targetVolume = 0.5f + Random.Range(-0.2f, 0.1f);\n            \n            // Calculate volume adjustment based on rubber duck force\n            float forceMultiplier = Mathf.Clamp01(Mathf.Abs(rubberDuckForce));\n            targetVolume = baseVolume * (1f + forceMultiplier * 0.3f);\n        }\n        \n        return _audioSource != null ? _audioSource.volume : 0f;\n    }\n    \n    private void UpdateColor()\n    {\n        Color currentColor = _colorOffset;\n        \n        for (int i = 0; i < _squeakClips.Length; i++)\n        {\n            if (_squeakClips[i] == null) continue;\n            \n            float volume = GetRubberDuckVolume();\n            float t = Mathf.Clamp01(volume / _maxVolume);\n            \n            currentColor = Color.Lerp(currentColor, _colorPalette[i * 2], t * _colorTransitionSpeed * Time.deltaTime);\n            \n            if (currentColor == _colorPalette[i * 2])\n                break;\n        }\n        \n        _colorOffset = currentColor;\n    }\n    \n    private void HandleMovement()\n    {\n        float distanceToPlayer = GetDistanceToPlayer();\n        float rubberDuckForce = Mathf.Clamp01(distanceToPlayer / _detectionRange) * _volumeSensitivity;\n        \n        Vector3 forceDirection = (transform.position - _startPosition).normalized;\n        forceDirection.y *= -1f; // Flip Y to point downward\n        \n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.AddForce(forceDirection * rubberDuckForce, ForceMode.Acceleration);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        // Draw color palette\n        for (int i = 0; i < _colorPalette.Length; i++)\n        {\n            if (_colorPalette[i] != null)\n                Gizmos.color = _colorPalette[i];\n                Gizmos.DrawWireCube(_startPosition + new Vector3(i * 2f, 0f, -i * 2f), 1f);\n        }\n    }\n    \n    private AudioClip CreateRandomSqueak()\n    {\n        int index = Random.Range(0, 8);\n        if (_squeakClips[index] == null) return null;\n        \n        AudioSource audio = GetComponent<AudioSource>();\n        if (audio == null)\n        {\n            audio = gameObject.AddComponent<AudioSource>();\n            audio.spatialBlend = 1f;\n            audio.loop = true;\n        }\n        \n        float volume = GetRubberDuckVolume();\n        float pitch = Mathf.Clamp01(volume / _maxVolume * 2f + 1f);\n        audio.pitch = pitch;\n        audio.PlayOneShot(_squeakClips[index]);\n        \n        return _squeakClips[index];\n    }\n    \n    private void SetMaxVolume(float newVolume)\n    {\n        if (_audioSource != null && !_audioSource.isPlaying)\n            _audioSource.volume = Mathf.Clamp01(newVolume / _maxVolume);\n    }\n    \n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        // Draw color palette\n        for (int i = 0; i < _colorPalette.Length; i++)\n        {\n            if (_colorPalette[i] != null)\n                Gizmos.color = _colorPalette[i];\n                Gizmos.DrawWireCube(_startPosition + new Vector3(i * 2f, 0f, -i * 2f), 1f);\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 5,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.62)",
      "Animation.CrossFade (0.62)",
      "Animation.CrossFadeQueued (0.61)",
      "Animator.CrossFadeInFixedTime (0.60)",
      "Animator.GetFloat (0.60)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class RubberDuck : MonoBehaviour\n{\n    [Header(\"Squeak Settings\")]\n    public float squeakVolume = 0.2f;\n    public float squeakSpeed = 1f;\n    public int squeakCount = 15;\n    \n    [Header(\"Audio\")]\n    public AudioClip squeakSound;\n    public AudioClip fanfareSound;\n    private AudioSource audioSource;\n    private float currentSqueakVolume = 0f;\n    private bool isPlayingFanfare = false;\n    \n    [Header(\"Physics\")]\n    public float bounceForce = 5f;\n    public float gravityScale = 1f;\n    public float airDrag = 2f;\n    public float groundCheckRadius = 0.3f;\n    private Rigidbody rb;\n    private bool isGrounded = true;\n    private Vector3 initialVelocity;\n    \n    [Header(\"Visual\")]\n    public Color baseColor = Color.white;\n    public Color[] colorTransitionColors = { \n        new Color(1f, 0.8f, 0.5f, 0.9f),\n        new Color(0.7f, 0.7f, 1f, 0.9f),\n        new Color(0.3f, 0.6f, 0.4f, 0.9f)\n    };\n    private float colorTransitionIndex = 0f;\n    private Color currentColor;\n    \n    [Header(\"Animator\")]\n    public Animator animator;\n    private bool useAnimator = false;\n    \n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            rb = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null)\n        {\n            audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        currentColor = baseColor;\n        colorTransitionIndex = 0f;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateSqueakVolume();\n        UpdateColorTransition();\n        UpdatePhysics();\n        UpdateAudio();\n        UpdateAnimator();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && isGrounded)\n        {\n            LaunchRubberDuck();\n        }\n        else if (Input.GetKey(KeyCode.Space))\n        {\n            ApplyUpwardForce();\n        }\n        \n        if (Input.GetMouseButtonDown(0) && CanSqueak())\n        {\n            Squeak();\n        }\n    }\n    \n    private void UpdateSqueakVolume()\n    {\n        currentSqueakVolume += squeakSpeed * Time.deltaTime;\n        currentSqueakVolume = Mathf.Clamp01(currentSqueakVolume);\n        \n        if (currentSqueakVolume >= 1f)\n        {\n            currentSqueakVolume = 0f;\n            colorTransitionIndex = 0f;\n        }\n    }\n    \n    private void UpdateColorTransition()\n    {\n        if (colorTransitionColors.Length > 0 && colorTransitionIndex < 1f)\n        {\n            float t = colorTransitionIndex * Time.deltaTime;\n            currentColor = Color.Lerp(colorTransitionColors[0], colorTransitionColors[1], t);\n            colorTransitionIndex += squeakSpeed * Time.deltaTime;\n        }\n    }\n    \n    private void UpdatePhysics()\n    {\n        if (!isGrounded)\n        {\n            ApplyAirDrag();\n            ApplyGravity();\n            ApplyUpwardForce();\n        }\n        else\n        {\n            CheckGroundContact();\n        }\n    }\n    \n    private void ApplyAirDrag()\n    {\n        rb.drag = airDrag;\n        rb.angularDrag = airDrag * 2f;\n        \n        if (animator != null)\n        {\n            animator.SetFloat(\"airDrag\", airDrag);\n        }\n    }\n    \n    private void ApplyGravity()\n    {\n        rb.velocity = new Vector3(rb.velocity.x, -currentSqueakVolume * 10f * Time.deltaTime, rb.velocity.z) * gravityScale;\n        \n        if (animator != null)\n        {\n            animator.SetFloat(\"gravity\", currentSqueakVolume * 10f);\n        }\n    }\n    \n    private void ApplyUpwardForce()\n    {\n        Vector3 force = new Vector3(0, squeakVolume * 20f, 0) * Time.deltaTime;\n        rb.AddForce(force, ForceMode.Acceleration);\n        \n        if (animator != null)\n        {\n            animator.SetFloat(\"upForce\", squeakVolume * 20f);\n        }\n    }\n    \n    private void CheckGroundContact()\n    {\n        Collider groundCheck = GetComponent<Collider>();\n        if (groundCheck == null) return;\n        \n        RaycastHit hit;\n        bool wasGrounded = isGrounded;\n        \n        if (Physics.Raycast(transform.position, -Vector3.up, out hit, groundCheckRadius))\n        {\n            isGrounded = true;\n            \n            if (!wasGrounded)\n            {\n                ApplyUpwardForce();\n            }\n        }\n        else\n        {\n            isGrounded = false;\n        }\n    }\n    \n    private void LaunchRubberDuck()\n    {\n        if (audioSource.isPlaying || !canPlaySound())\n        {\n            return;\n        }\n        \n        PlaySqueak();\n        PlayFanfare();\n        rb.velocity = new Vector3(0, 15f, 0) * Time.deltaTime;\n        colorTransitionIndex = 1f;\n    }\n    \n    private void ApplyUpwardForce()\n    {\n        if (!isGrounded)\n        {\n            Vector3 force = new Vector3(rb.velocity.x, squeakVolume * 20f, rb.velocity.z) * Time.deltaTime;\n            rb.AddForce(force, ForceMode.Acceleration);\n        }\n    }\n    \n    private void PlaySqueak()\n    {\n        if (squeakSound != null && audioSource.isPlaying == false)\n        {\n            audioSource.PlayOneShot(squeakSound, 0.8f);\n        }\n    }\n    \n    private void PlayFanfare()\n    {\n        if (fanfareSound != null && !isPlayingFanfare)\n        {\n            isPlayingFanfare = true;\n            float volume = currentSqueakVolume * 2f;\n            audioSource.PlayOneShot(fanfareSound, volume);\n            \n            // Start spinning animation\n            if (animator != null)\n            {\n                animator.SetBool(\"spin\", true);\n            }\n        }\n    }\n    \n    private void UpdateAnimator()\n    {\n        if (!useAnimator) return;\n        \n        float currentVolume = squeakVolume * 10f;\n        float upForce = squeakVolume * 20f;\n        \n        if (animator != null)\n        {\n            animator.SetFloat(\"volume\", currentVolume);\n            animator.SetFloat(\"upForce\", upForce);\n            animator.SetBool(\"spin\", useAnimator);\n            \n            // Color transition\n            int index = Mathf.RoundToInt(currentSqueakVolume * colorTransitionColors.Length). Clamp(0, colorTransitionColors.Length - 1);\n            if (colorTransitionIndex >= 1f)\n            {\n                currentColor = colorTransitionColors[index];\n                colorTransitionIndex = 0f;\n            }\n        }\n    }\n    \n    private bool canPlaySound()\n    {\n        return audioSource.isPlaying == false && squeakSound != null;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, groundCheckRadius);\n        \n        if (animator != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position + Vector3.up * 0.5f, transform.position - Vector3.up * 0.5f);\n        }\n    }\n}",
    "per_behavior_docs": 17,
    "per_behavior_methods": 6,
    "per_behavior_doc_names": {
      "squeak_on_press": [
        "Light.SetLightDirty (0.64)",
        "Light.AddCommandBufferAsync (0.64)",
        "Animation.PlayQueued (0.62)"
      ],
      "color_transition": [
        "Color.LerpUnclamped (0.57)",
        "Color.RGBToHSV (0.57)",
        "Color.GetHashCode (0.56)"
      ],
      "launch_fanfare": [
        "Rigidbody.MoveRotation (0.73)",
        "Rigidbody.MovePosition (0.71)",
        "Rigidbody.Move (0.71)"
      ],
      "fanfare_flight": [
        "Transform.GetPositionAndRotation (0.72)",
        "Transform.Rotate (0.71)",
        "Transform.RotateAround (0.70)"
      ],
      "parachute_descent": [
        "GameObject.InstantiateGameObjects (0.69)",
        "Object.Instantiate (0.65)",
        "GameObject.GetComponentInChildren (0.64)"
      ],
      "gentle_fall": [
        "Rigidbody.MoveRotation (0.65)",
        "Rigidbody.GetAccumulatedForce (0.64)",
        "Rigidbody.AddForceAtPosition (0.64)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 58,
        "justification": "Strong Unity-specific patterns, good component setup, but slightly monolithic with large methods"
      },
      "ir_monolithic": {
        "architecture": 4,
        "fixability": 6,
        "unity_patterns": 5,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 46,
        "justification": "Over-complicated, lacks clear behavior separation, partially implemented features"
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 71,
        "justification": "Excellent method decomposition, clean separation of concerns, modular design with clear extension points"
      },
      "winner": "ir_per_behavior",
      "key_differences": "Per-behavior approach provides clearer method responsibilities, better encapsulation, and more explicit behavior definitions compared to monolithic or one-shot approaches",
      "advantages": "Highly modular design allows easy feature addition, clear method naming makes intent transparent, uses Unity patterns consistently, provides natural extension points for additional duck behaviors"
    },
    "error": null
  },
  {
    "prompt_num": 7,
    "prompt": "Build a see-saw platform that tilts based on weight distribution of objects placed on it, plays creaking wood sounds proportional to tilt angle, has springs at each end that launch lightweight objects when the opposite side is heavily loaded, and visually bends slightly under extreme weight.",
    "timestamp": "2026-01-08T22:10:27.086483",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SeeSawPlatform : MonoBehaviour\n{\n    [Header(\"See Saw Settings\")]\n    [SerializeField] private float _maxAngle = 45f;\n    [SerializeField] private float _minAngle = -15f;\n    [SerializeField] private float _naturalAngle = 0f;\n    [SerializeField] private float _tiltSpeed = 2f;\n    [SerializeField] private float _massScale = 1f;\n    \n    [Header(\"Springs\")]\n    [SerializeField] private Spring[] _springs;\n    [SerializeField] private float _springForce = 10f;\n    [SerializeField] private float _springDamping = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _creakSounds;\n    [SerializeField] private float _minCreakVolume = 0.2f;\n    [SerializeField] private float _maxCreakVolume = 1f;\n    [SerializeField] private float _baseVolume = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem[] _dustParticles;\n    [SerializeField] private GameObject[] _swayObjects;\n    [SerializeField] private float _swayAmount = 0.3f;\n    [SerializeField] private AnimationCurve _swayCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);\n    \n    private Vector3 _targetPosition;\n    private Vector3 _currentPosition;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private bool _isPlayingSound;\n    private Dictionary<GameObject, float> _objectsOnPlatform = new Dictionary<GameObject, float>();\n    \n    [System.Serializable]\n    public class Spring\n    {\n        public Transform springPoint1;\n        public Transform springPoint2;\n        public float force;\n        public float damping;\n        \n        public Spring(Transform p1, Transform p2, float f = 10f, float d = 5f)\n        {\n            springPoint1 = p1;\n            springPoint2 = p2;\n            force = f;\n            damping = d;\n        }\n    }\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupSprings();\n        SetupAudio();\n        InitializePlatformPosition();\n    }\n    \n    void SetupSprings()\n    {\n        if (_springs == null || _springs.Length < 2)\n        {\n            GameObject leftSpringPoint = new GameObject(\"LeftSpringPoint\");\n            GameObject rightSpringPoint = new GameObject(\"RightSpringPoint\");\n            \n            Transform springPoint1A = leftSpringPoint.transform;\n            Transform springPoint2A = rightSpringPoint.transform;\n            \n            Spring leftSpring = new Spring(springPoint1A, springPoint2A);\n            _springs.Add(leftSpring);\n            \n            springPoint1A = rightSpringPoint.transform;\n            springPoint2A = leftSpringPoint.transform;\n            \n            Spring rightSpring = new Spring(springPoint1A, springPoint2A);\n            _springs.Add(rightSpring);\n        }\n    }\n    \n    void SetupAudio()\n    {\n        if (_creakSounds == null || _creakSounds.Length < 3)\n        {\n            GameObject leftDust = new GameObject(\"LeftDust\");\n            GameObject rightDust = new GameObject(\"RightDust\");\n            \n            ParticleSystem leftParticles = leftDust.AddComponent<ParticleSystem>();\n            ParticleSystem rightParticles = rightDust.AddComponent<ParticleSystem>();\n            \n            leftParticles.add = new GameObject[] { \"WoodenChips\" };\n            rightParticles.add = new GameObject[] { \"WoodenChips\" };\n        }\n        \n        _audioSource.clip = _creakSounds[0];\n        _audioSource.loop = true;\n        _audioSource.volume = _baseVolume;\n    }\n    \n    void InitializePlatformPosition()\n    {\n        Vector3 startPos = transform.position;\n        float angleInRadians = Mathf.Deg2Rad(_naturalAngle);\n        \n        // Calculate target position based on desired angle\n        _targetPosition = new Vector3(\n            startPos.x + Mathf.Cos(angleInRadians) * 1f,\n            startPos.y,\n            startPos.z + Mathf.Sin(angleInRadians) * 1f\n        );\n    }\n    \n    void FixedUpdate()\n    {\n        CalculateTiltAngle();\n        UpdatePlatformPosition();\n        CheckForObjectCollisions();\n        \n        // Play creaking sound based on current tilt angle\n        if (!_isPlayingSound)\n        {\n            PlayCreakingSound();\n        }\n    }\n    \n    void CalculateTiltAngle()\n    {\n        float angle = Mathf.Atan2(\n            transform.position.y - _naturalPosition.y,\n            transform.position.x - _naturalPosition.x\n        );\n        \n        // Clamp angle to valid range\n        angle = Mathf.Clamp(angle, -Mathf.PI/2f, Mathf.PI/2f);\n        \n        // Convert to natural angle range (0-90 degrees)\n        float naturalAngleInDegrees = angle * 180f / Mathf.PI;\n        naturalAngleInDegrees = Mathf.Clamp(naturalAngleInDegrees, _minAngle, _maxAngle);\n        \n        // Store for sound calculation\n        _currentAngleInRadians = angle;\n    }\n    \n    void UpdatePlatformPosition()\n    {\n        transform.position = Vector3.Lerp(transform.position, _targetPosition, Time.deltaTime * _tiltSpeed);\n    }\n    \n    void CheckForObjectCollisions()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.center, 0.5f);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\") || col.CompareTag(\"Enemy\"))\n            {\n                ApplyForceToObject(col.gameObject);\n            }\n            else if (!col.CompareTag(\"SeeSawPlatform\"))\n            {\n                ApplyForceToObject(col.gameObject);\n            }\n        }\n    }\n    \n    void ApplyForceToObject(GameObject obj)\n    {\n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            rb = obj.AddComponent<Rigidbody>();\n        }\n        \n        Vector3 forceDirection;\n        float forceAmount;\n        \n        // Determine which side the object is on\n        float objectDistance = Vector3.Distance(transform.position, obj.transform.position);\n        float angle = Mathf.Atan2(\n            obj.transform.position.y - transform.position.y,\n            obj.transform.position.x - transform.position.x\n        );\n        \n        angle = angle * 180f / Mathf.PI;\n        angle = Mathf.Clamp(angle, _minAngle, _maxAngle);\n        angleInRadians = angle * Mathf.Deg2Rad();\n        \n        // Calculate force direction based on tilt\n        if (objectDistance > 1f)\n        {\n            Vector3 targetDirection = new Vector3(\n                Mathf.Cos(angleInRadians) * objectDistance,\n                transform.position.y - obj.transform.position.y,\n                Mathf.Sin(angleInRadians) * objectDistance\n            );\n            \n            // Normalize direction vector\n            targetDirection.Normalize();\n            \n            forceDirection = targetDirection;\n        }\n        else\n        {\n            // Close to pivot, push away from center\n            Vector3 centerDirection = (obj.transform.position - transform.center).normalized;\n            forceDirection = -centerDirection;\n        }\n        \n        // Calculate force magnitude based on object mass and tilt\n        float mass = obj.GetComponent<Rigidbody>().mass;\n        if (mass > 0f)\n        {\n            float scaleFactor = Mathf.Abs(Mathf.Sin(angleInRadians)) / Mathf.Max(1f, Mathf.Abs(Mathf.Cos(angleInRadians)));\n            forceAmount = _springForce * scaleFactor * mass * _massScale;\n        }\n        else\n        {\n            // Use spring force if no mass\n            forceAmount = _springForce * 0.5f; // Half strength for static objects\n        }\n        \n        // Apply torque to tilt the object\n        rb.AddTorque(forceDirection * forceAmount, ForceMode.VelocityChange);\n    }\n    \n    void PlayCreakingSound()\n    {\n        if (_isPlayingSound)\n        {\n            _audioSource.Stop();\n            _isPlayingSound = false;\n        }\n        \n        _audioSource.PlayOneShot(_creakSounds[0], _baseVolume * \n            (Mathf.Abs(_currentAngleInRadians) / Mathf.PI) * \n            _maxCreakVolume\n        );\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        // Draw pivot line\n        Vector3 start = transform.position + new Vector3(-0.5f, 0, 0);\n        Vector3 end = transform.position + new Vector3(0.5f, 0, 0);\n        Gizmos.DrawLine(start, end);\n        \n        // Draw tilt indicator\n        float angleInDegrees = Mathf.Abs(_currentAngleInRadians * 180f / Mathf.PI);\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position + new Vector3(0, 1f, 0), \n            Quaternion.Euler(0, angleInDegrees, 0) * (1f * 0.5f));\n    }\n    \n    private float _currentAngleInRadians = 0f;\n    private Vector3 _naturalPosition;\n    private Vector3 _targetPosition;\n    private bool _isPlayingSound;\n    \n    [System.Serializable]\n    public class SpringData\n    {\n        public Transform springPoint1;\n        public Transform springPoint2;\n        public float force;\n        public float damping;\n        \n        public SpringData(Transform p1, Transform p2)\n        {\n            springPoint1 = p1;\n            springPoint2 = p2;\n            force = _springForce;\n            damping = _springDamping;\n        }\n    }\n    \n    private void Awake()\n    {\n        _naturalPosition = transform.position;\n    }\n    \n    public void AddObject(GameObject obj, float forceMultiplier = 1f)\n    {\n        _objectsOnPlatform[obj] = forceMultiplier;\n        ApplyForceToObject(obj);\n    }\n    \n    public void RemoveObject(GameObject obj)\n    {\n        if (_objectsOnPlatform.ContainsKey(obj))\n            _objectsOnPlatform.Remove(obj);\n        \n        ApplyForceToObject(obj);\n    }\n    \n    public float GetObjectDistance(GameObject obj)\n    {\n        return Vector3.Distance(transform.position, obj.transform.position);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_audioSource != null)\n            _audioSource.Stop();\n    }\n}",
    "ir_json": {
      "class_name": "TiltSeeSawPlatform",
      "components": [
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "seeSawPosition",
          "type": "float",
          "default": 0
        },
        {
          "name": "leftSpringForce",
          "type": "float",
          "default": 500
        },
        {
          "name": "rightSpringForce",
          "type": "float",
          "default": 500
        },
        {
          "name": "maxTiltAngle",
          "type": "float",
          "default": 45
        },
        {
          "name": "leftMass",
          "type": "float",
          "default": 0
        },
        {
          "name": "rightMass",
          "type": "float",
          "default": 0
        },
        {
          "name": "leftWeightObject",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "rightWeightObject",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "leftSpringVisual",
          "type": "Renderer",
          "default": null
        },
        {
          "name": "rightSpringVisual",
          "type": "Renderer",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "update_tilt_angle",
          "trigger": "every frame while platform exists",
          "actions": [
            {
              "action": "calculate tilt angle based on object positions and masses"
            },
            {
              "action": "limit tilt angle to maximum allowed value"
            }
          ]
        },
        {
          "name": "apply_tilt_to_physics",
          "trigger": "when platform has objects placed on it",
          "actions": [
            {
              "action": "rotate see saw platform according to calculated tilt angle"
            },
            {
              "action": "adjust mass values based on weighted object positions"
            }
          ]
        },
        {
          "name": "play_wood_sounds",
          "trigger": "every frame when platform is tilted",
          "actions": [
            {
              "action": "compute sound volume based on tilt angle magnitude"
            },
            {
              "action": "play creaking wood audio clip with adjusted volume"
            }
          ]
        },
        {
          "name": "launch_left_object",
          "trigger": "when right side mass exceeds threshold and seesaw tilts left",
          "actions": [
            {
              "action": "apply upward force to left weight object using spring mechanics"
            },
            {
              "action": "play spring launch sound effect"
            }
          ]
        },
        {
          "name": "launch_right_object",
          "trigger": "when left side mass exceeds threshold and seesaw tilts right",
          "actions": [
            {
              "action": "apply upward force to right weight object using spring mechanics"
            },
            {
              "action": "play spring launch sound effect"
            }
          ]
        },
        {
          "name": "visual_bend_under_load",
          "trigger": "when combined mass on one side is significantly greater than the other",
          "actions": [
            {
              "action": "apply slight visual deformation to platform edges closest to heavy load"
            },
            {
              "action": "rotate camera slightly around platform axis for dramatic effect"
            }
          ]
        },
        {
          "name": "reset_saw_position",
          "trigger": "when both sides have equal mass or platform is level",
          "actions": [
            {
              "action": "return seesaw to horizontal position"
            },
            {
              "action": "stop audio playback"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class TiltSeeSawPlatform : MonoBehaviour\n{\n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _maxTiltAngle = 45f;\n    [SerializeField] private float _leftSpringForce = 500f;\n    [SerializeField] private float _rightSpringForce = 500f;\n    [SerializeField] private float _leftMass = 10f;\n    [SerializeField] private float _rightMass = 10f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _woodCreakSound;\n    [SerializeField] private float _minVolume = 0.1f;\n    [SerializeField] private float _maxVolume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Renderer _springRenderer;\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private TrailRenderer _tiltTrailRenderer;\n    \n    private Transform[] _leftObjects;\n    private Transform[] _rightObjects;\n    private float[] _objectMasses;\n    private bool[] _hasObjectsOnSide;\n    private Vector3[] _originalPositions;\n    private Quaternion[] _originalRotations;\n    private List<float> _springDampers = new List<float>();\n    \n    private void Start()\n    {\n        InitializePhysics();\n        SetupAudio();\n        SetupVisualEffects();\n        SetupTrails();\n        \n        UpdateSpringDampers();\n    }\n    \n    private void InitializePhysics()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.freezeRotation = true;\n            rb.useGravity = false;\n        }\n        \n        List<Collider> colliders = new List<Collider>();\n        foreach (Transform child in transform)\n        {\n            if (!child.gameObject.activeInHierarchy) continue;\n            \n            Collider col = child.GetComponent<Collider>();\n            if (col != null && !colliders.Contains(col))\n                colliders.Add(col);\n        }\n        \n        foreach (Collider col in colliders)\n        {\n            if (col is BoxCollider boxCollider)\n            {\n                boxCollider.isTrigger = true;\n            }\n            else if (col is CapsuleCollider capsuleCollider)\n            {\n                capsuleCollider.isTrigger = true;\n            }\n            else if (col is SphereCollider sphereCollider)\n            {\n                sphereCollider.isTrigger = true;\n            }\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null) return;\n        \n        _woodCreakSound = GetComponent<AudioSource>().clip;\n        if (_woodCreakSound == null)\n        {\n            GameObject audioGO = new GameObject(\"Wood Sound\");\n            audioGO.AddComponent<AudioInp>();\n            audioGO.AddComponent<SoundEffectSource>();\n            \n            AudioClip[] sounds = new AudioClip[]\n            {\n                Resources.Load(AudioClip>(\"WoodCreak\") ?? \n                AudioSource.PlayClipAtPoint(_woodCreakSound, transform.position)\n            };\n            \n            foreach (AudioClip clip in sounds)\n            {\n                SoundEffectSource soundSource = audioGO.GetComponent<SoundEffectSource>();\n                if (soundSource != null && clip != null)\n                    soundSource.clip = clip;\n            }\n        }\n        \n        _audioSource.loop = true;\n        _audioSource.volume = Mathf.Max(_minVolume, 0.01f);\n    }\n    \n    private void SetupVisualEffects()\n    {\n        if (_springRenderer == null) return;\n        \n        _springRenderer.enabled = false;\n        _springRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _springRenderer.color = Color.green;\n        _springRenderer.fontSize = 20f;\n        _springRenderer.text = \"Spring\";\n    }\n    \n    private void SetupTrails()\n    {\n        if (_tiltTrailRenderer == null) return;\n        \n        TrailRenderer trail = GetComponent<TrailRenderer>();\n        if (trail != null)\n        {\n            trail.enabled = true;\n            trail.useWorldSpace = false;\n            trail.startWidth = 0.1f;\n            trail.endWidth = 0.3f;\n        }\n    }\n    \n    private Transform[] GetObjectsOnLeftSide()\n    {\n        List<Transform> leftObjects = new List<Transform>();\n        \n        for (int i = 0; i < transform.childCount; i++)\n        {\n            if (_leftObjects.Length >= transform.childCount) break;\n            \n            float angle = Vector3.Angle(transform.forward, transform.GetChild(i).localToWorld(new Vector3(1f, 0f, 0f)));\n            if (angle <= _maxTiltAngle * 90f)\n            {\n                leftObjects.Add(transform.GetChild(i));\n            }\n        }\n        \n        return leftObjects.ToArray();\n    }\n    \n    private Transform[] GetObjectsOnRightSide()\n    {\n        List<Transform> rightObjects = new List<Transform>();\n        \n        for (int i = transform.childCount - 1; i >= 0; i--)\n        {\n            if (_rightObjects.Length >= transform.childCount) break;\n            \n            float angle = Vector3.Angle(transform.forward, transform.GetChild(i).localToWorld(new Vector3(-1f, 0f, 0f)));\n            if (angle <= _maxTiltAngle * 90f)\n            {\n                rightObjects.Add(transform.GetChild(i));\n            }\n        }\n        \n        return rightObjects.ToArray();\n    }\n    \n    private void UpdateSpringDampers()\n    {\n        List<float> newDampers = new List<float>();\n        \n        for (int i = 0; i < _leftObjects.Length; i++)\n        {\n            float leftMass = _hasObjectsOnSide[i] ? _leftMass : 1f;\n            float rightMass = (_hasObjectsOnSide[i + _leftObjects.Length]) ? _rightMass : 1f;\n            \n            // Calculate torque using moments\n            float momentLeft = Vector3.Dot(_originalPositions[i].vector - transform.position, new Vector3(0, leftMass, 0));\n            float momentRight = Vector3.Dot(_originalPositions[i + _leftObjects.Length].vector - transform.position, new Vector3(0, rightMass, 0));\n            \n            // Calculate angle using moments\n            float angle = Mathf.Atan2(momentRight, momentLeft) * (180f / Mathf.PI);\n            angle = Mathf.Clamp(angle, -90f, 90f);\n            \n            newDampers.Add(Mathf.Abs(angle));\n        }\n        \n        _springDampers.Clear();\n        _springDampers.AddRange(newDampers);\n    }\n    \n    private void Update()\n    {\n        CalculateTiltAngle();\n        ApplyTiltToPhysics();\n        UpdateAudio();\n        UpdateVisualEffects();\n        UpdateTrails();\n    }\n    \n    private void CalculateTiltAngle()\n    {\n        if (_leftObjects.Length == 0 && _rightObjects.Length == 0)\n            return;\n        \n        float totalMass = 0f;\n        for (int i = 0; i < _leftObjects.Length + _rightObjects.Length; i++)\n        {\n            totalMass += _hasObjectsOnSide[i] ? _objectMasses[i] : 1f;\n        }\n        \n        if (totalMass <= 0.1f)\n        {\n            ResetToHorizontal();\n            return;\n        }\n        \n        float leftMoment = 0f;\n        float rightMoment = 0f;\n        \n        for (int i = 0; i < _leftObjects.Length; i++)\n        {\n            Vector3 relativePos = _originalPositions[i].vector - transform.position;\n            leftMoment += relativePos.x * (_hasObjectsOnSide[i] ? _objectMasses[i] : 1f);\n        }\n        \n        for (int i = _leftObjects.Length; i < (_leftObjects.Length + _rightObjects.Length); i++)\n        {\n            Vector3 relativePos = _originalPositions[i].vector - transform.position;\n            rightMoment += relativePos.x * (_hasObjectsOnSide[i] ? _objectMasses[i] : 1f);\n        }\n        \n        float tiltAngle = 0f;\n        if (Mathf.Abs(leftMoment) > Mathf.Epsilon)\n        {\n            tiltAngle = leftMoment / totalMass;\n        }\n        else\n        {\n            tiltAngle = -rightMoment / totalMass;\n        }\n        \n        // Clamp angle to maximum tilt range\n        tiltAngle = Mathf.Clamp(tiltAngle, -_maxTiltAngle * 90f, _maxTiltAngle * 90f);\n    }\n    \n    private void ApplyTiltToPhysics()\n    {\n        if (_audioSource == null) return;\n        \n        float angle = CalculateTiltAngle();\n        Vector3 tiltDirection = new Vector3(\n            Mathf.Cos(angle * Mathf.Deg2Rad),\n            0f,\n            Mathf.Sin(angle * Mathf.Deg2Rad)\n        );\n        \n        // Apply torque to simulate tilting\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            float leftMoment = _hasObjectsOnSide[0] ? _leftMass : 1f;\n            float rightMoment = _hasObjectsOnSide[_leftObjects.Length] ? _rightMass : 1f;\n            \n            Vector3 torque = new Vector3(\n                -_leftSpringForce * (leftMoment - rightMoment),\n                0f,\n                -_rightSpringForce * (rightMoment - leftMoment)\n            );\n            rb.AddTorque(torque, Space.Self);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        float angle = CalculateTiltAngle();\n        float volume = Mathf.Abs(angle) / 90f;\n        volume = Mathf.Clamp(volume, _minVolume, _maxVolume);\n        \n        _audioSource.volume = volume;\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_springRenderer == null || !_springRenderer.enabled) return;\n        \n        float angle = CalculateTiltAngle();\n        Vector3 tiltDirection = new Vector3(\n            Mathf.Cos(angle * Mathf.Deg2Rad),\n            0f,\n            Mathf.Sin(angle * Mathf.Deg2Rad)\n        );\n        \n        // Animate spring visual\n        Vector3 springPosition = transform.position + _springRenderer.transform.localEulerAngles * Vector3.up;\n        _springRenderer.localPosition = tiltDirection.normalized * 2f;\n        \n        // Update dust effect\n        if (_dustEffect != null)\n        {\n            float dustAmount = Mathf.Abs(angle) / 90f;\n            _dustEffect.transform.localScale = new Vector3(dustAmount, dustAmount, dustAmount);\n        }\n    }\n    \n    private void UpdateTrails()\n    {\n        if (_tiltTrailRenderer == null) return;\n        \n        for (int i = 0; i < _leftObjects.Length; i++)\n        {\n            float t = 0f;\n            while (_tiltTrailRenderer != null && _tiltTrailRenderer.isPlaying)\n            {\n                float nextT = Time.unscaledDeltaTime * 2f;\n                if (nextT >= 1f) break;\n                \n                t += nextT;\n                Vector3 targetPos = _originalPositions[i].vector;\n                targetPos.y += Mathf.Sin(angle * Mathf.Deg2Rad);\n                _tiltTrailRenderer.SetPosition(0, targetPos);\n            }\n        }\n    }\n    \n    public void AddWeightObject(GameObject obj)\n    {\n        if (_leftObjects.Length >= transform.childCount) return;\n        \n        int sideIndex = GetSideIndex(obj);\n        if (sideIndex == -1) return;\n        \n        _hasObjectsOnSide[sideIndex] = true;\n        _objectMasses[sideIndex] += obj.mass;\n    }\n    \n    public void AddWeightObjectAtAngle(Vector3 angle)\n    {\n        GameObject obj = new GameObject(\"WeightObject\");\n        obj.transform.position = transform.position + Vector3.forward * 1f;\n        obj.transform.rotation = Quaternion.Euler(0, angle.y, 0);\n        \n        if (_leftObjects.Length >= transform.childCount) return;\n        \n        int sideIndex = GetSideIndex(obj);\n        if (sideIndex == -1) return;\n        \n        _hasObjectsOnSide[sideIndex] = true;\n        _objectMasses[sideIndex] += obj.mass;\n    }\n    \n    private int GetSideIndex(GameObject obj)\n    {\n        for (int i = 0; i < _leftObjects.Length + _rightObjects.Length; i++)\n        {\n            if (_hasObjectsOnSide[i])\n            {\n                Vector3 relativePos = _originalPositions[i].vector - transform.position;\n                float angle = Vector3.Angle(transform.forward, new Vector3(relativePos.x, 0f, relativePos.z));\n                if (angle <= _maxTiltAngle * 90f)\n                    return i;\n            }\n        }\n        \n        // Check right side\n        for (int i = _leftObjects.Length; i < (_leftObjects.Length + _rightObjects.Length); i++)\n        {\n            Vector3 relativePos = _originalPositions[i].vector - transform.position;\n            float angle = Vector3.Angle(transform.forward, new Vector3(-relativePos.x, 0f, relativePos.z));\n            if (angle <= _maxTiltAngle * 90f)\n                return i;\n        }\n        \n        return -1;\n    }\n    \n    public void ResetAllObjects()\n    {\n        for (int i = 0; i < _leftObjects.Length + _rightObjects.Length; i++)\n        {\n            if (_hasObjectsOnSide[i])\n            {\n                Vector3 originalPos = _originalPositions[i].vector;\n                _leftObjects[i].position = originalPos;\n            }\n        }\n        \n        ResetToHorizontal();\n    }\n    \n    public void SetMaxTiltAngle(float angle)\n    {\n        _maxTiltAngle = angle;\n        UpdateSpringDampers();\n    }\n    \n    private void ResetToHorizontal()\n    {\n        transform.rotation = _originalRotations[_leftObjects.Length];\n        \n        // Snap objects back to original positions\n        for (int i = 0; i < _leftObjects.Length + _rightObjects.Length; i++)\n        {\n            if (_hasObjectsOnSide[i])\n                _leftObjects[i].position = _originalPositions[i].vector;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_woodCreakSound != null && _audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n    }\n}\n\n// Helper Components\npublic class AudioInp : MonoBehaviour\n{\n    [SerializeField] private AudioClip _clip;\n    public AudioSource audioSource;\n    \n    private void Awake()\n    {\n        if (audioSource == null)\n        {\n            GameObject audioGO = new GameObject(\"AudioSource\");\n            audioGO.AddComponent<AudioSource>();\n            audioSource = audioGO.GetComponent<AudioSource>();\n        }\n        \n        if (_clip != null && audioSource != null)\n        {\n            audioSource.clip = _clip;\n        }\n    }\n}\n\npublic class SoundEffectSource : MonoBehaviour\n{\n    [SerializeField] private AudioClip _soundClip;\n    public AudioSource audioSource;\n    \n    private void Awake()\n    {\n        if (audioSource == null)\n        {\n            GameObject audioGO = new GameObject(\"AudioSource\");\n            audioGO.AddComponent<AudioSource>();\n            audioSource = audioGO.GetComponent<AudioSource>();\n        }\n        \n        if (_soundClip != null && audioSource != null)\n        {\n            audioSource.clip = _soundClip;\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "AudioSource.GamepadSpeakerSupportsOutputType (0.61)",
      "Animations.AnimationPlayableOutput (0.42)",
      "RigidbodyConstraints.FreezeRotation (0.42)",
      "Animations.PositionConstraint (0.41)",
      "Animations.AnimationSceneHandleUtility (0.41)",
      "Mesh.GetBlendShapeFrameWeight (0.41)",
      "AvatarTarget.RightFoot (0.41)",
      "Terrain.SetKeepUnusedCameraRenderingResources (0.41)",
      "RigidbodyConstraints.FreezeRotationX (0.41)",
      "RigidbodyConstraints.FreezeRotationZ (0.40)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SeesawPlatform : MonoBehaviour\n{\n    [Header(\"Seesaw Settings\")]\n    public Transform pivotPoint = transform;\n    public float maxTiltAngle = 45f;\n    public float tiltSpeed = 2f;\n    \n    [Header(\"Mass Properties\")]\n    public float leftMass = 10f;\n    public float rightMass = 15f;\n    public float leftSpringForce = 500f;\n    public float rightSpringForce = 600f;\n    public float gravityScale = 1f;\n    \n    [Header(\"Audio\")]\n    public AudioSource audioSource;\n    public AudioClip creakSound;\n    public float minPitch = 0.5f;\n    public float maxPitch = 2f;\n    public float baseVolume = 0.3f;\n    \n    private Rigidbody seesawRigidbody;\n    private Vector3 leftPosition, rightPosition;\n    private Quaternion leftRotation, rightRotation;\n    private bool isPlayingSound;\n    private float currentTiltAngle;\n    private float targetTiltAngle;\n    private Vector3 originalLeftPosition;\n    private Vector3 originalRightPosition;\n    \n    void Start()\n    {\n        seesawRigidbody = GetComponent<Rigidbody>();\n        \n        if (pivotPoint == null)\n            pivotPoint = transform;\n            \n        leftPosition = new Vector3(pivotPoint.position.x, -1f, 0f);\n        rightPosition = new Vector3(pivotPoint.position.x, 1f, 0f);\n        originalLeftPosition = leftPosition;\n        originalRightPosition = rightPosition;\n        \n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        UpdatePositions();\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateTiltAngle();\n        PlayCreakingSound();\n        ApplyPhysics();\n        UpdateAudioPitch();\n    }\n    \n    private void HandleInput()\n    {\n        // Placeholder for input handling (e.g., mouse drag to tilt)\n        // This would typically be added in another script or via raycasting\n    }\n    \n    private void UpdateTiltAngle()\n    {\n        if (pivotPoint != null)\n        {\n            Vector3 mousePosition = Input.mousePosition;\n            float mouseX = -mousePosition.x;\n            \n            // Apply rotation based on mouseX input\n            Quaternion targetRotation = Quaternion.Euler(0, mouseX * 90f, 0);\n            pivotPoint.rotation = Quaternion.Slerp(pivotPoint.rotation, targetRotation, Time.deltaTime * tiltSpeed);\n        }\n    }\n    \n    private void PlayCreakingSound()\n    {\n        if (!isPlayingSound && creakSound != null)\n        {\n            float pitchMultiplier = Mathf.Clamp01(Mathf.Abs(currentTiltAngle) / maxTiltAngle);\n            pitchMultiplier = Mathf.Lerp(minPitch, maxPitch, pitchMultiplier);\n            \n            pitchMultiplier = Mathf.Lerp(1f, 0.5f, pitchMultiplier); // Lower pitch when more tilted\n            \n            if (audioSource != null)\n            {\n                float targetVolume = baseVolume * pitchMultiplier;\n                audioSource.pitch = pitchMultiplier;\n                audioSource.volume = targetVolume;\n                audioSource.PlayOneShot(creakSound);\n                isPlayingSound = true;\n            }\n        }\n    }\n    \n    private void ApplyPhysics()\n    {\n        if (seesawRigidbody == null) return;\n        \n        // Calculate tilt angle based on rotation\n        float currentTiltAngle = -90f * Mathf.Sin(pivotPoint.eulerAngles.y);\n        targetTiltAngle = Mathf.Clamp(currentTiltAngle, -maxTiltAngle, maxTiltAngle);\n        \n        Vector3 forceDirection;\n        if (pivotPoint != null)\n        {\n            // Calculate torque from gravity\n            Vector3 leftGravityTorque = new Vector3(0f, 0f, -leftMass * gravityScale * -9.81f);\n            Vector3 rightGravityTorque = new Vector3(0f, 0f, -rightMass * gravityScale * -9.81f);\n            \n            // Calculate torque from player objects\n            foreach (Rigidbody rb in GetComponentInChildren<Rigidbody>()?.children)\n            {\n                if (rb.mass > 0f && !string.IsNullOrEmpty(rb.gameObject.name))\n                {\n                    Vector3 force = new Vector3(0f, 0f, -rb.velocity.y * gravityScale);\n                    Vector3 torque = Vector3.Cross(new Vector3(pivotPoint.position - rb.position), force);\n                    \n                    if (torque.magnitude > 1f)\n                        leftGravityTorque += torque;\n                }\n            }\n            \n            // Apply torques to rigidbody\n            seesawRigidbody.AddForce(leftGravityTorque, ForceMode.Force);\n            seesawRigidbody.AddForce(rightGravityTorque, ForceMode.Force);\n        }\n        \n        // Apply spring forces based on tilt\n        if (pivotPoint != null)\n        {\n            Vector3 leftSpringTorque = new Vector3(0f, 0f, -leftSpringForce * Mathf.Sin(currentTiltAngle));\n            Vector3 rightSpringTorque = new Vector3(0f, 0f, -rightSpringForce * Mathf.Cos(currentTiltAngle));\n            \n            seesawRigidbody.AddTorque(leftSpringTorque, ForceMode.Force);\n            seesawRigidbody.AddTorque(rightSpringTorque, ForceMode.Force);\n        }\n    }\n    \n    private void UpdateAudioPitch()\n    {\n        if (audioSource == null || !creakSound.isPlaying) return;\n        \n        float pitchMultiplier = Mathf.Clamp01(Mathf.Abs(currentTiltAngle) / maxTiltAngle);\n        pitchMultiplier = Mathf.Lerp(minPitch, maxPitch, pitchMultiplier);\n        \n        audioSource.pitch = pitchMultiplier;\n    }\n    \n    private void UpdatePositions()\n    {\n        if (pivotPoint != null)\n        {\n            Vector3 leftNewPosition = new Vector3(pivotPoint.position.x, -1f * Mathf.Sin(pivotPoint.eulerAngles.y), 0f);\n            Vector3 rightNewPosition = new Vector3(pivotPoint.position.x, 1f * Mathf.Cos(pivotPoint.eulerAngles.y), 0f);\n            \n            if (originalLeftPosition != leftNewPosition)\n                leftPosition = leftNewPosition;\n                \n            if (originalRightPosition != rightNewPosition)\n                rightPosition = rightNewPosition;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        if (pivotPoint != null)\n        {\n            Vector3 leftOffset = new Vector3(pivotPoint.position.x, -1f, 0f);\n            Vector3 rightOffset = new Vector3(pivotPoint.position.x, 1f, 0f);\n            \n            Gizmos.DrawWireCube(leftOffset + pivotPoint.up * 0.5f, 0.2f);\n            Gizmos.DrawWireCube(rightOffset - pivotPoint.up * 0.5f, 0.2f);\n        }\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(pivotPoint.position, 0.3f);\n    }\n}",
    "per_behavior_docs": 14,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "apply_torque_from_object": [
        "Transform.GetPositionAndRotation (0.71)",
        "Transform.GetLocalPositionAndRotation (0.68)",
        "Transform.SetPositionAndRotation (0.68)"
      ],
      "update_tilt_angle": [
        "Animator.SetBoneLocalRotation (0.59)",
        "Animator.SetIKRotationWeight (0.59)",
        "AudioClip.PCMSetPositionCallback (0.59)"
      ],
      "play_wood_sounds": [
        "AudioClip.PCMSetPositionCallback (0.63)",
        "AudioSpeakerMode (0.63)",
        "AudioSource.GamepadSpeakerSupportsOutputType (0.62)"
      ],
      "activate_spring_launch": [
        "Light.SetLightDirty (0.67)",
        "Light.AddCommandBufferAsync (0.67)",
        "Light.GetCommandBuffers (0.66)"
      ],
      "visual_bend_effect": [
        "ParticleSystem.TextureSheetAnimationModule (0.75)",
        "ParticleSystem.Play (0.75)",
        "ParticleSystem.GetPlaybackState (0.74)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 5,
        "unity_patterns": 6,
        "correctness": 3,
        "completeness": 3,
        "weighted_total": 48.5,
        "justification": "Direct translation lacks clear separation of concerns, with methods becoming overly complex. Good use of serialized fields but incomplete implementation with truncated code."
      },
      "ir_monolithic": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 61.5,
        "justification": "More structured approach with clear initialization methods and careful component management. Shows defensive programming with null checks and systematic setup of Unity components."
      },
      "ir_per_behavior": {
        "architecture": 9,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 73,
        "justification": "Highly modular design with distinct methods for each behavior. Excellent separation of concerns, clear method names, and systematic approach to implementing seesaw mechanics."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The per-behavior approach provides the most granular, readable, and extensible implementation, with clear method responsibilities and systematic Unity component management.",
      "advantages": "Breaking down complex behaviors into discrete, focused methods makes the code more understandable, easier to debug, and simpler to extend or modify in the future."
    },
    "error": null
  },
  {
    "prompt_num": 8,
    "prompt": "Create a wrecking ball that swings on a chain with realistic pendulum physics, plays a whoosh sound based on velocity, creates dust clouds and screen shake on impact with destroyable objects, and leaves cracks in surfaces it strikes that persist until level reload.",
    "timestamp": "2026-01-08T22:16:04.700922",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class WreckingBall : MonoBehaviour\n{\n    [Header(\"Swinging Physics\")]\n    [SerializeField] private float _swingSpeed = 5f;\n    [SerializeField] private float _damping = 0.9f;\n    [SerializeField] private bool _useGravity = false;\n    [SerializeField] private Vector3 _startPosition;\n    [SerializeField] private Vector3 _startRotation;\n    [SerializeField] private float _minSwingAngle = -15f;\n    [SerializeField] private float _maxSwingAngle = 15f;\n    \n    [Header(\"Chain\")]\n    [SerializeField] private GameObject chainObject;\n    [SerializeField] private Transform ballTransform;\n    [SerializeField] private float _chainLength = 10f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    [SerializeField] private float _collisionForce = 1000f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem dustEffect;\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private AudioClip swingSound;\n    [SerializeField] private AudioClip impactSound;\n    [SerializeField] private int _maxDustParticles = 50;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    \n    private Rigidbody ballRb;\n    private bool isSwinging = false;\n    private Vector3 initialVelocity;\n    private Vector3 targetPosition;\n    private Quaternion targetRotation;\n    private float currentAngle;\n    private float velocity;\n    \n    private void Start()\n    {\n        ballRb = ballTransform.GetComponent<Rigidbody>();\n        \n        if (ballRb == null)\n        {\n            ballRb = ballTransform.gameObject.AddComponent<Rigidbody>();\n        }\n        \n        SetupWreckingBall();\n        StartCoroutine(SwingRoutine());\n    }\n    \n    private void SetupWreckingBall()\n    {\n        if (_startPosition == Vector3.zero)\n            _startPosition = transform.position;\n            \n        if (_startRotation == Quaternion.identity)\n            _startRotation = transform.rotation;\n            \n        targetPosition = new Vector3(_startPosition.x, _startPosition.y + 0.5f, _startPosition.z);\n        targetRotation = _startRotation;\n        \n        currentAngle = 0f;\n        velocity = 0f;\n    }\n    \n    private void Update()\n    {\n        if (!isSwinging)\n            return;\n            \n        ApplyDamping();\n        UpdateSwingTarget();\n        MoveBall();\n        RotateBall();\n        CheckCollisions();\n    }\n    \n    private IEnumerator SwingRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(1f / _swingSpeed);\n            StartSwinging(_minSwingAngle, _maxSwingAngle);\n        }\n    }\n    \n    private void ApplyDamping()\n    {\n        if (_useGravity && velocity > 0)\n            velocity *= _damping;\n            \n        float targetVelocity = Mathf.Lerp(velocity, 0f, Time.deltaTime * _damping);\n        velocity = targetVelocity;\n        \n        // Apply angular damping for rotation\n        transform.Rotate(Vector3.up * -targetVelocity * Time.deltaTime);\n    }\n    \n    private void UpdateSwingTarget()\n    {\n        float angleChange = Random.Range(-_maxSwingAngle, _maxSwingAngle) / 10f; // Smooth random variation\n        targetPosition.y += Mathf.Sin(angleChange) * 0.3f;\n        \n        if (targetPosition.y < _startPosition.y - 1f)\n            targetRotation = Quaternion.Euler(0, currentAngle + angleChange, 0);\n    }\n    \n    private void MoveBall()\n    {\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * _swingSpeed);\n    }\n    \n    private void RotateBall()\n    {\n        float targetY = Mathf.Sin(currentAngle) * _chainLength;\n        targetRotation = Quaternion.Euler(0, currentAngle + 5f * Time.deltaTime, 0);\n        \n        transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * _swingSpeed);\n    }\n    \n    private void CheckCollisions()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 0.5f, _obstacleLayerMask);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!col.CompareTag(\"Player\"))\n            {\n                ApplyImpact(col.gameObject);\n            }\n        }\n    }\n    \n    private void ApplyImpact(GameObject target)\n    {\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        Vector3 impactDirection = (transform.position - target.transform.position).normalized;\n        float force = _collisionForce * transform.localScale.x * Mathf.Abs(impactDirection.y);\n        \n        rb.AddForce(transform.forward * force, ForceMode.Impulse);\n        \n        PlayImpactSounds();\n        CreateDustEffect(target);\n        ApplyScreenShake(impactDirection);\n    }\n    \n    private void PlayImpactSounds()\n    {\n        if (audioSource != null)\n            audioSource.PlayOneShot(swingSound);\n        \n        if (_impactSound != null && !string.IsNullOrEmpty(_impactSound))\n            audioSource.PlayOneShot(_impactSound);\n    }\n    \n    private void CreateDustEffect(GameObject target)\n    {\n        if (dustEffect == null || dustEffect.isPlaying) return;\n        \n        int particleCount = Mathf.Min(_maxDustParticles, 50);\n        ParticleSystem ps = dustEffect.GetComponent<ParticleSystem>();\n        \n        if (ps != null)\n        {\n            float scale = 0.1f * Mathf.Abs(target.transform.position.y - transform.position.y);\n            ps.Play();\n            ps.StopAfterEvery(particleCount, true);\n            ps.scale = scale;\n            ps.color = Color.white;\n            ps.maxParticles = particleCount;\n        }\n    }\n    \n    private void ApplyScreenShake(Vector3 direction)\n    {\n        float shakeAmount = _shakeIntensity * direction.magnitude;\n        \n        Camera mainCamera = Camera.main;\n        if (mainCamera != null)\n        {\n            mainCamera.transform.rotation = Quaternion.Euler(0, 0, -shakeAmount);\n            mainCamera.cameradistance *= 1f + shakeAmount * 0.5f;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _chainLength);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(transform.position, targetPosition);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(transform.position, transform.forward * 0.5f);\n    }\n    \n    private void OnDestroy()\n    {\n        if (audioSource != null)\n            audioSource.Stop();\n    }\n}",
    "ir_json": {
      "class_name": "WreckingBall",
      "components": [
        "Rigidbody",
        "AudioSource",
        "Collider",
        "ParticleSystem",
        "Animator"
      ],
      "fields": [
        {
          "name": "swingForce",
          "type": "float",
          "default": 5000
        },
        {
          "name": "swingAngle",
          "type": "float",
          "default": 80
        },
        {
          "name": "chainLength",
          "type": "float",
          "default": 15
        },
        {
          "name": "impactDamage",
          "type": "int",
          "default": 100
        },
        {
          "name": "crackLevel",
          "type": "int",
          "default": 0
        },
        {
          "name": "swingSpeed",
          "type": "float",
          "default": 20
        },
        {
          "name": "whooshSoundClip",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "initialize_wrecking_ball",
          "trigger": "start game as wrecking ball",
          "actions": [
            {
              "action": "set swing angle to initial position"
            },
            {
              "action": "attach chain to pivot point"
            },
            {
              "action": "play subtle wind sound effects"
            }
          ]
        },
        {
          "name": "swing_ball",
          "trigger": "every frame while moving forward during swing",
          "actions": [
            {
              "action": "apply pendulum physics to maintain arc motion"
            },
            {
              "action": "adjust chain rotation based on swing angle"
            },
            {
              "action": "play wind particles around ball"
            }
          ]
        },
        {
          "name": "detect_impact_target",
          "trigger": "when swing ball collides with destroyable object or surface",
          "actions": [
            {
              "action": "calculate impact velocity and direction"
            },
            {
              "action": "apply physics damage to target objects"
            }
          ]
        },
        {
          "name": "play_impact_effects",
          "trigger": "during collision with any surface",
          "actions": [
            {
              "action": "create dust particle explosion at impact point"
            },
            {
              "action": "emit crackling sound effects based on velocity"
            },
            {
              "action": "apply screen shake proportional to force"
            },
            {
              "action": "play whoosh sound clip as ball passes through target"
            }
          ]
        },
        {
          "name": "create_cracks",
          "trigger": "when impacting solid surfaces with high velocity",
          "actions": [
            {
              "action": "mark surface pixels around impact area with crack texture mask"
            },
            {
              "action": "set persistent crack level on impacted object"
            },
            {
              "action": "apply visual distortion to simulate breaking material"
            }
          ]
        },
        {
          "name": "end_impact_sequence",
          "trigger": "when damage is applied or no valid targets remain in swing arc",
          "actions": [
            {
              "action": "reduce swing angle as momentum dissipates"
            },
            {
              "action": "play impact crash sound if still moving"
            }
          ]
        },
        {
          "name": "reset_after_impact",
          "trigger": "when all nearby breakable objects destroyed and no other valid targets exist",
          "actions": [
            {
              "action": "gradually restore swing angle to full extent"
            },
            {
              "action": "stop wind particle effects"
            },
            {
              "action": "play impact reset tone"
            }
          ]
        },
        {
          "name": "destroy_ball_on_final_impact",
          "trigger": "when final valid target is destroyed and no other breakables remain in range",
          "actions": [
            {
              "action": "play heavy crash sound"
            },
            {
              "action": "create larger dust explosion"
            },
            {
              "action": "disable all physics components"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WreckingBall : MonoBehaviour\n{\n    [Header(\"Wrecking Ball Settings\")]\n    [SerializeField] private float _swingForce = 5000f;\n    [SerializeField] private float _swingAngle = 80f;\n    [SerializeField] private float _chainLength = 15f;\n    [SerializeField] private float _impactDamage = 100f;\n    [SerializeField] private float _swingSpeed = 20f;\n    [SerializeField] private LayerMask _breakableLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _whooshSound;\n    [SerializeField] private AudioClip _crashSound;\n    [SerializeField] private AudioClip _impactSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private ParticleSystem _explosionEffect;\n    [SerializeField] private Renderer _renderer;\n    [SerializeField] private Material _crackMaterial;\n    [SerializeField] private float _screenShakeIntensity = 0.1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _swingParameter = \"SwingAngle\";\n    [SerializeField] private string _rotateParameter = \"Rotation\";\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private List<Collider> _breakableColliders = new List<Collider>();\n    private Vector3 _startPosition;\n    private float _currentSwingAngle = 0f;\n    private bool _isSwinging = false;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_dustEffect != null)\n            _dustEffect.Play();\n        \n        if (_explosionEffect != null)\n            _explosionEffect.Play();\n            \n        if (_screenShakeIntensity > 0f && _renderer != null)\n            _renderer.enabled = true;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateSwingAngle();\n        ApplyPhysics();\n        PlayEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_isSwinging) return;\n        \n        float forceX = -_swingForce * Mathf.Sin(_currentSwingAngle / 180f);\n        float forceY = _swingForce * Mathf.Cos(_currentSwingAngle / 180f);\n        _rigidbody.AddForce(new Vector3(forceX, forceY, 0), ForceMode.Acceleration);\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && !_isSwinging)\n        {\n            StartSwing();\n        }\n        \n        if (Input.GetKeyUp(KeyCode.Space))\n        {\n            StopSwing();\n        }\n    }\n    \n    private void StartSwing()\n    {\n        _isSwinging = true;\n        _currentSwingAngle = -_swingAngle;\n        PlaySound(_whooshSound, _audioVolume);\n        AnimateSwing();\n    }\n    \n    private void StopSwing()\n    {\n        if (_isSwinging)\n        {\n            _isSwinging = false;\n            _currentSwingAngle = 0f;\n            \n            if (_animator != null && _swingParameter != \"\")\n                _animator.SetBool(_swingParameter, false);\n                \n            PlaySound(_crashSound, _audioVolume * 0.3f);\n        }\n    }\n    \n    private void UpdateSwingAngle()\n    {\n        float targetAngle = -_currentSwingAngle;\n        \n        if (_animator != null && _rotateParameter != \"\")\n        {\n            Vector3 currentRotation = transform.localEulerAngles;\n            currentRotation.z = Mathf.Lerp(currentRotation.z, targetAngle, Time.deltaTime * _swingSpeed);\n            transform.localEulerAngles = currentRotation;\n        }\n    }\n    \n    private void ApplyPhysics()\n    {\n        if (!_isSwinging) return;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _chainLength);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!col.CompareTag(\"Player\") && !breakableIsTarget(col.gameObject))\n                continue;\n            \n            float distanceToCenter = Vector3.Distance(transform.position, col.center);\n            float velocity = Vector3.Dot(_rigidbody.velocity, new Vector3(0, 1, 0));\n            \n            ApplyImpactDamage(col, distanceToCenter, velocity);\n        }\n    }\n    \n    private bool breakableIsTarget(GameObject target)\n    {\n        if (target == gameObject) return false;\n        \n        if (_breakableLayers.value & (1 << target.layer)) return true;\n        \n        return true; // Default to breakable\n    }\n    \n    private void ApplyImpactDamage(Collider target, float distance, float velocity)\n    {\n        // Try different ways to apply damage based on component type\n        var rigidbody = target.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            // Use impulse for physics-based damage\n            rigidbody.AddForce(velocity * _impactDamage / distance, ForceMode.Impulse);\n            \n            // Apply damage to health components\n            foreach (var healthComponent in target.GetComponentsInChildren<Health>())\n                if (healthComponent != null)\n                    healthComponent.TakeDamage(_impactDamage);\n        }\n        \n        // Apply visual crack effects\n        ApplyCrackEffects(target, distance);\n    }\n    \n    private void ApplyCrackEffects(Collider target, float distance)\n    {\n        if (_renderer != null && _crackMaterial != null)\n        {\n            Color originalColor = _renderer.material.color;\n            \n            for (int i = 0; i < target.GetComponentsInChildren<Renderer>().Length; i++)\n            {\n                Renderer renderer = target.GetComponentInChildren<Renderer>(i);\n                if (renderer != null)\n                {\n                    Color newColor = CalculateCrackedColor(originalColor, distance * 10f);\n                    renderer.material.color = newColor;\n                }\n            }\n        }\n    }\n    \n    private Color CalculateCrackedColor(Color originalColor, float crackIntensity)\n    {\n        int r = Mathf.RoundToInt(originalColor.r * (1f - crackIntensity));\n        int g = Mathf.RoundToInt(originalColor.g * (1f - crackIntensity));\n        int b = Mathf.RoundToInt(originalColor.b * (1f - crackIntensity));\n        \n        return Color.FromArgb(255, r, g, b);\n    }\n    \n    private void PlayEffects()\n    {\n        if (_dustEffect != null)\n            _dustEffect.Play();\n            \n        if (_explosionEffect != null)\n            _explosionEffect.Play();\n            \n        ApplyScreenShake();\n    }\n    \n    private void ApplyScreenShake()\n    {\n        float shakeX = Random.Range(-_screenShakeIntensity, _screenShakeIntensity);\n        float shakeY = Random.Range(-_screenShakeIntensity * 0.5f, _screenShakeIntensity * 0.5f);\n        \n        transform.position += new Vector3(shakeX, shakeY, 0) * Time.deltaTime;\n    }\n    \n    private void PlaySound(AudioClip clip, float volume)\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource != null)\n        {\n            audioSource.PlayOneShot(clip, volume);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw swing arc\n        Vector3 startPos = transform.position;\n        Vector3 direction = Vector3.forward;\n        float angle = _currentSwingAngle;\n        \n        for (int i = 0; i < 360; i++)\n        {\n            float t = i / 360f;\n            float x = Mathf.Cos(t * Mathf.PI) * distanceToEdge();\n            float z = Mathf.Sin(t * Mathf.PI) * distanceToEdge();\n            \n            Vector3 point = startPos + direction * new Vector3(x, 0, z);\n            Gizmos.DrawRay(point - Vector3.up * 0.5f, Vector3.forward * 0.3f);\n        }\n        \n        // Draw chain\n        for (int i = 0; i < _chainLength; i++)\n        {\n            Vector3 offset = new Vector3(\n                Mathf.Cos(i * Mathf.Deg2Rad) * distanceToEdge(),\n                0,\n                Mathf.Sin(i * Mathf.Deg2Rad) * distanceToEdge()\n            );\n            Gizmos.DrawRay(transform.position + Vector3.up * _chainLength, offset);\n        }\n    }\n    \n    private float distanceToEdge()\n    {\n        if (_collider != null)\n            return _collider.bounds.extents.x;\n        \n        return 10f; // Default\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 9,
    "ir_rag_doc_names": [
      "Rigidbody.OnCollisionExit (0.61)",
      "Physics.SphereCastNonAlloc (0.60)",
      "Rigidbody.OnCollisionEnter (0.60)",
      "ParticleSystem.CollisionModule.dampenMultiplier (0.46)",
      "ParticleSystem.CollisionModule.maxKillSpeed (0.46)",
      "ParticleSystem.CollisionModule.bounceMultiplier (0.46)",
      "Animations.GameObjectRecorder (0.41)",
      "Animations.AnimationPlayableOutput (0.41)",
      "Animations.AnimationClipPlayable (0.40)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SwingingWreckingBall : MonoBehaviour\n{\n    [Header(\"Swinging Physics\")]\n    [SerializeField] private float _mass = 50f;\n    [SerializeField] private float _swingForce = 1000f;\n    [SerializeField] private float _dampingFactor = 0.98f;\n    [SerializeField] private float _maxSwingAngle = 90f;\n    [SerializeField] private float _swaySpeed = 2f;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageForce = 500f;\n    [SerializeField] private float _damageRadius = 1.5f;\n    [SerializeField] private LayerMask _breakableLayers = -1;\n    [SerializeField] private float _damageThreshold = 10f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private GameObject _impactPointPrefab;\n    [SerializeField] private Transform _swingingPoint;\n    [SerializeField] private LineRenderer _swingRay;\n    [SerializeField] private float _screenShakeIntensity = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whooshSound;\n    [SerializeField] private AudioClip _breakSound;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckRadius = 0.5f;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _initialPosition;\n    private bool _isSwinging = false;\n    private Vector3 _targetDirection;\n    private float _currentAngle;\n    private float _swayAngle;\n    private float _lastDamageTime;\n    private Collider _collider;\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _initialPosition = transform.position;\n        _swingingPoint = transform;\n        _groundCheckPoint = transform.Find(\"GroundCheckPoint\");\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    void Update()\n    {\n        HandleSwingInput();\n        ApplySwingPhysics();\n        CheckForDamage();\n        UpdateEffects();\n        UpdateAudio();\n        CheckGroundContact();\n    }\n    \n    private void HandleSwingInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && _isSwinging)\n        {\n            StartSwing();\n        }\n        \n        if (Input.GetKeyUp(KeyCode.Space) && _isSwinging)\n        {\n            StopSwing();\n        }\n        \n        if (_swaySpeed > 0.1f)\n        {\n            float sway = Random.Range(-_swaySpeed, _swaySpeed);\n            transform.Rotate(0, sway * Time.deltaTime, 0);\n        }\n    }\n    \n    private void ApplySwingPhysics()\n    {\n        if (!_isSwinging) return;\n        \n        Vector3 targetVelocity = new Vector3(_targetDirection.x, 0f, _targetDirection.z);\n        float currentSpeed = targetVelocity.magnitude;\n        \n        // Dampen swing speed over time\n        if (currentSpeed < 5f)\n        {\n            targetVelocity *= _dampingFactor;\n        }\n        \n        // Apply forward force to maintain swing momentum\n        Vector3 force = targetVelocity * _mass * 10f + transform.up * _swingForce * currentSpeed;\n        _rigidbody.AddForce(force, ForceMode.Acceleration);\n        \n        // Limit angle to prevent excessive rotation\n        float angle = Vector3.Angle(transform.forward, targetDirection);\n        if (angle > _maxSwingAngle)\n        {\n            targetDirection = transform.forward;\n        }\n    }\n    \n    private void CheckForDamage()\n    {\n        if (_lastDamageTime < -0.1f) return;\n        \n        Vector3 rayOrigin = _swingingPoint.position + new Vector3(0, 5f, 0);\n        Vector3 rayDirection = transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _groundCheckRadius))\n        {\n            // Check for breakable objects in range\n            Collider[] targets = Physics.OverlapSphere(hit.point, _damageRadius * 1.5f, _breakableLayers);\n            \n            foreach (Collider target in targets)\n            {\n                if (!target.CompareTag(\"Player\"))\n                {\n                    ApplyDamageToTarget(target);\n                }\n            }\n        }\n    }\n    \n    private void ApplyDamageToTarget(Collider target)\n    {\n        float impactVelocity = Vector3.Distance(transform.position, target.transform.position) * 5f;\n        \n        // Check damage threshold\n        if (impactVelocity > _damageThreshold)\n        {\n            ApplyBreakableDamage(target);\n        }\n        else\n        {\n            ApplySolidDamage(target);\n        }\n        \n        _lastDamageTime = Time.time + 0.1f;\n    }\n    \n    private void ApplyBreakableDamage(Collider target)\n    {\n        // Apply massive force to break object\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            targetRb.AddForce(targetRb.velocity * 2f, ForceMode.Impulse);\n        }\n        \n        // Create dust effect at impact location\n        GameObject dustObject = Instantiate(_dustEffect.gameObject, hit.point, Quaternion.identity);\n        Destroy(dustObject, 3f);\n        \n        // Play break sound\n        if (_breakSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_breakSound);\n        }\n        \n        // Spawn impact point visual\n        GameObject impactPoint = Instantiate(_impactPointPrefab, hit.point, Quaternion.identity);\n        Destroy(impactPoint, 5f);\n        \n        // Trigger screen shake\n        StartCoroutine(ScreenShakeEffect(impactVelocity * 0.1f));\n    }\n    \n    private void ApplySolidDamage(Collider target)\n    {\n        float distanceToTarget = Vector3.Distance(transform.position, target.transform.position);\n        if (distanceToTarget > _damageRadius)\n        {\n            // Apply damage force to push away\n            Rigidbody targetRb = target.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 directionAwayFromSwingPoint = (target.transform.position - transform.position).normalized;\n                targetRb.AddForce(directionAwayFromSwingPoint * _damageForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void ScreenShakeEffect(float shakeIntensity)\n    {\n        float duration = 0.3f;\n        float t = 0f;\n        \n        while (t < duration)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere * shakeIntensity;\n            transform.position += randomDirection;\n            \n            t += Time.deltaTime;\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_dustEffect != null && _swingingPoint != null)\n        {\n            GameObject dustObject = Instantiate(_dustEffect.gameObject, _swingingPoint.position + new Vector3(0, 5f, 0), Quaternion.identity);\n            Destroy(dustObject, 2f);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _whooshSound != null)\n        {\n            float volume = Mathf.Lerp(0.1f, 0.7f, Time.time * 5f);\n            _audioSource.volume = volume;\n            _audioSource.pitch = Mathf.Lerp(0.8f, 1.2f, volume);\n            _audioSource.PlayOneShot(_whooshSound);\n        }\n    }\n    \n    private void CheckGroundContact()\n    {\n        if (_groundCheckPoint == null) return;\n        \n        RaycastHit hit;\n        Vector3 rayOrigin = _groundCheckPoint.position + new Vector3(0, 5f, 0);\n        Vector3 rayDirection = transform.forward;\n        \n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _groundCheckRadius))\n        {\n            // Prevent swinging too low\n            float angle = Vector3.Angle(transform.up, hit.normal);\n            if (angle < 15f)\n            {\n                _isSwinging = false;\n            }\n        }\n    }\n    \n    public void StartSwing()\n    {\n        _targetDirection = transform.forward;\n        _currentAngle = 0f;\n        _swayAngle = Random.Range(0, 30f);\n        _lastDamageTime = -1f;\n        _isSwinging = true;\n        \n        // Reset swing position\n        if (_swingRay != null)\n        {\n            _swingRay.enabled = false;\n        }\n    }\n    \n    public void StopSwing()\n    {\n        _targetDirection = Vector3.zero;\n        _currentAngle = 0f;\n        _isSwinging = false;\n        \n        // Enable swing ray\n        if (_swingRay != null)\n        {\n            _swingRay.enabled = true;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_isSwinging) return;\n        \n        Vector3 targetVelocity = new Vector3(_targetDirection.x, 0f, _targetDirection.z);\n        float speed = targetVelocity.magnitude;\n        \n        // Apply damping\n        if (speed < 5f)\n        {\n            targetVelocity *= _dampingFactor;\n        }\n        \n        // Add forward force to maintain swing momentum\n        Vector3 force = targetVelocity * _mass * 10f + transform.up * _swingForce * speed;\n        _rigidbody.AddForce(force, ForceMode.Acceleration);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_swingRay == null)\n        {\n            _swingRay = GetComponent<LineRenderer>();\n        }\n        \n        if (_swingRay != null && transform != null)\n        {\n            Vector3 start = transform.position;\n            Vector3 end = start + new Vector3(0, 5f, 0);\n            \n            // Draw swing arc\n            Gizmos.color = Color.yellow;\n            float angle = Mathf.Atan2(end.y - start.y, end.x - start.x) * (180f / Mathf.PI);\n            float distance = Vector3.Distance(start, end);\n            float radius = distance / Mathf.Sin(angle * Mathf.Deg2Rad / 2f);\n            \n            Gizmos.DrawWireSphere(end, radius * 0.5f);\n            Gizmos.DrawLine(start + new Vector3(0, 1f, 0), end + new Vector3(0, 1f, 0));\n        }\n    }\n}",
    "per_behavior_docs": 9,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "swing_forward": [
        "Rigidbody.MoveRotation (0.71)",
        "Transform.GetPositionAndRotation (0.69)",
        "Rigidbody.MovePosition (0.69)"
      ],
      "swing_back": [
        "Rigidbody.MoveRotation (0.71)",
        "Transform.GetPositionAndRotation (0.70)",
        "Rigidbody.MovePosition (0.69)"
      ],
      "impact_object": [
        "Rigidbody.OnCollisionEnter (0.72)",
        "Rigidbody.OnCollisionStay (0.71)",
        "Rigidbody.OnCollisionExit (0.71)"
      ],
      "impact_wall": [
        "Rigidbody.OnCollisionEnter (0.75)",
        "Rigidbody.OnCollisionStay (0.74)",
        "Rigidbody.OnCollisionExit (0.74)"
      ],
      "visual_feedback": [
        "ParticleSystem.ColorBySpeedModule (0.76)",
        "ParticleSystem.Play (0.74)",
        "ParticleSystem.GetPlaybackState (0.74)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 5,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 48,
        "justification": "Direct translation lacks clear separation of concerns, with methods doing multiple things. Decent Unity patterns but overly complex implementation. Partially correct but lacks refinement."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 7,
        "weighted_total": 71,
        "justification": "Strong modular design with clear separation of concerns. Excellent use of serialized fields, Unity lifecycle methods, and well-structured components. Provides clear extension points and follows Unity best practices."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 6,
        "weighted_total": 64,
        "justification": "Good method-level separation and modularity. Strong Unity patterns and defensive programming. Slightly less clean than monolithic approach, but more granular and easier to extend."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the most structured and maintainable implementation, with clear component organization, robust Unity patterns, and excellent extensibility.",
      "advantages": "Superior architecture with modular design, comprehensive serialized configuration, clear separation of physics/input/effects, and most idiomatic Unity implementation. Provides the cleanest foundation for further development."
    },
    "error": null
  },
  {
    "prompt_num": 9,
    "prompt": "Design a jack-in-the-box that plays increasingly fast carnival music while its handle slowly turns for 8 seconds, builds suspense with growing wobble animation, then explosively pops open launching confetti particles in all directions while playing a loud spring sound and honk, before slowly resetting over 5 seconds.",
    "timestamp": "2026-01-08T22:19:47.050666",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class JackInTheBox : MonoBehaviour\n{\n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _jackHandleTransform;\n    [SerializeField] private GameObject _jackBodyPrefab;\n    [SerializeField] private ParticleSystem _confettiParticles;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _wobbleAmount = 0.5f;\n    [SerializeField] private float _wobbleFrequency = 1f;\n    [SerializeField] private float _openDuration = 2f;\n    [SerializeField] private float _closeDuration = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _musicTracks;\n    [SerializeField] private int _currentMusicIndex = 0;\n    [SerializeField] private float _musicLoopDelay = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private AudioClip _popSound;\n    [SerializeField] private AudioClip _honkSound;\n    [SerializeField] private AudioClip[] _confettiSounds;\n    [SerializeField] private float _confettiSpawnRate = 10f;\n    [SerializeField] private float _confettiLifetime = 2f;\n    \n    private bool _isPlayingMusic = false;\n    private bool _isPopped = false;\n    private float _startTime;\n    private float _currentTime;\n    private int _musicIndex;\n    \n    void Start()\n    {\n        _startTime = Time.time;\n        _currentTime = _startTime;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupComponents();\n        \n        // Play first music track immediately\n        PlayMusic(_musicTracks[0]);\n    }\n    \n    void SetupComponents()\n    {\n        if (_jackHandleTransform == null)\n        {\n            GameObject jackBody = new GameObject(\"Jack Body\");\n            jackBody.transform.SetParent(transform);\n            _jackHandleTransform = jackBody.transform;\n        }\n        \n        if (_confettiParticles != null)\n        {\n            _confettiParticles.Stop();\n        }\n    }\n    \n    void Update()\n    {\n        if (_isPopped || !_isPlayingMusic) return;\n        \n        _currentTime += Time.deltaTime;\n        \n        // Handle rotation\n        float targetRotation = (Mathf.Sin(_currentTime * 2f * Mathf.PI / _openDuration) + 1f) * 180f * Mathf.Deg2Rad;\n        _jackHandleTransform.Rotate(0, 0, targetRotation);\n        \n        // Wobble animation\n        float wobbleOffset = Mathf.Sin(_currentTime * 2f * Mathf.PI / _wobbleFrequency) * _wobbleAmount;\n        Vector3 wobblePosition = new Vector3(wobbleOffset, 0, wobbleOffset);\n        _jackHandleTransform.position += wobblePosition;\n        \n        // Music progression\n        float musicProgression = (_currentTime - _startTime) % _musicLoopDelay;\n        if (musicProgression >= 1f)\n        {\n            PlayMusic(_musicTracks[_musicIndex]);\n            _musicIndex = (_musicIndex + 1) % _musicTracks.Length;\n            musicProgression = 0f;\n        }\n    }\n    \n    void PlayMusic(AudioClip clip)\n    {\n        if (!_isPlayingMusic && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.loop = true;\n            _audioSource.Play();\n            _isPlayingMusic = true;\n        }\n    }\n    \n    void PopJack()\n    {\n        if (_isPopped || !_isPlayingMusic) return;\n        \n        _isPopped = true;\n        \n        // Play effects\n        PlaySound(_popSound);\n        PlayHonkSound();\n        PlayConfettiEffects();\n        \n        // Spawn confetti particles\n        if (_confettiParticles == null)\n        {\n            GameObject confettiObj = new GameObject(\"Confetti\");\n            confettiObj.transform.SetParent(transform);\n            _confettiParticles = confettiObj.AddComponent<ParticleSystem>();\n        }\n        \n        _confettiParticles.Play();\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void PlayHonkSound()\n    {\n        if (_audioSource != null && _honkSound != null)\n        {\n            _audioSource.PlayOneShot(_honkSound);\n        }\n    }\n    \n    void PlayConfettiEffects()\n    {\n        if (_confettiSounds == null || _confettiSounds.Length == 0) return;\n        \n        for (int i = 0; i < _confettiSounds.Length; i++)\n        {\n            PlaySound(_confettiSounds[i]);\n        }\n    }\n    \n    void StopJack()\n    {\n        if (!_isPopped)\n        {\n            // Reset wobble\n            if (_jackHandleTransform != null)\n            {\n                float resetOffset = Mathf.Abs(Mathf.Sin(Time.time * 2f * Mathf.PI / _wobbleFrequency) * _wobbleAmount);\n                Vector3 resetPosition = new Vector3(-resetOffset, 0, -resetOffset);\n                _jackHandleTransform.position += resetPosition;\n            }\n            \n            // Reset rotation\n            if (_jackHandleTransform != null)\n            {\n                float targetRotation = (Mathf.Sin(Time.time * 2f * Mathf.PI / _openDuration) + 1f) * 180f * Mathf.Deg2Rad;\n                _jackHandleTransform.Rotate(0, 0, targetRotation);\n            }\n            \n            // Reset confetti\n            if (_confettiParticles != null)\n            {\n                _confettiParticles.Stop();\n            }\n        }\n        \n        _isPopped = false;\n    }\n    \n    public void ResetJack()\n    {\n        StopJack();\n        PlayMusic(_musicTracks[0]);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_confettiParticles != null)\n        {\n            _confettiParticles.Stop();\n        }\n    }\n}",
    "ir_json": {
      "class_name": "JackInTheBox",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem",
        "Animator",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "playCount",
          "type": "int",
          "default": 2
        },
        {
          "name": "basePitchMultiplier",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "wobbleIntensity",
          "type": "float",
          "default": 0.1
        },
        {
          "name": "popForce",
          "type": "float",
          "default": 500
        },
        {
          "name": "confettiCount",
          "type": "int",
          "default": 1000
        },
        {
          "name": "wobbleSpeed",
          "type": "float",
          "default": 1.5
        }
      ],
      "behaviors": [
        {
          "name": "start_suspense_sequence",
          "trigger": "when box is opened and handle is lowered",
          "actions": [
            {
              "action": "start wobble animation with low pitch"
            }
          ]
        },
        {
          "name": "progressive_wobble",
          "trigger": "every second while suspense sequence plays",
          "actions": [
            {
              "action": "increase wobble intensity"
            },
            {
              "action": "gradually increase wobble speed"
            }
          ]
        },
        {
          "name": "build_suspense_music",
          "trigger": "when suspense sequence starts",
          "actions": [
            {
              "action": "play first musical note at base pitch"
            },
            {
              "action": "increase tempo slowly over time"
            },
            {
              "action": "lower pitch gradually with wobble intensity"
            }
          ]
        },
        {
          "name": "prepare_to_pop",
          "trigger": "when suspense duration expires and box is still closed",
          "actions": [
            {
              "action": "stop wobble animation temporarily"
            },
            {
              "action": "start small popping sound effect at base pitch"
            }
          ]
        },
        {
          "name": "execute_spring_popping",
          "trigger": "when pop trigger is activated",
          "actions": [
            {
              "action": "apply strong upward force to box"
            },
            {
              "action": "play loud spring compression and popping sound"
            },
            {
              "action": "emit bright flash effect"
            }
          ]
        },
        {
          "name": "launch_confetti",
          "trigger": "when box starts moving upward rapidly after pop",
          "actions": [
            {
              "action": "spawn confetti particles in all directions"
            },
            {
              "action": "set velocity to match box movement direction"
            }
          ]
        },
        {
          "name": "play_pop_sound_effect",
          "trigger": "when popping sound reaches maximum volume",
          "actions": [
            {
              "action": "play loud honk sound effect"
            }
          ]
        },
        {
          "name": "reset_box_after_popping",
          "trigger": "when box returns to original position and velocity is zero",
          "actions": [
            {
              "action": "stop all particle effects"
            },
            {
              "action": "destroy particles after 2 seconds of reset"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class JackInTheBox : MonoBehaviour\n{\n    [Header(\"Box Settings\")]\n    [SerializeField] private float _boxHeight = 1f;\n    [SerializeField] private float _boxWidth = 0.5f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    [SerializeField] private float _jumpForce = 15f;\n    [SerializeField] private float _gravityScale = 0.8f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _wobbleSpeed = 2f;\n    [SerializeField] private float _wobbleHeight = 0.3f;\n    [SerializeField] private AnimationCurve _wobbleCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private float _wobbleDuration = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _popSounds;\n    [SerializeField] private AudioClip[] _confettiSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _confettiSystem;\n    [SerializeField] private Light _flashLight;\n    [SerializeField] private float _flashDuration = 0.1f;\n    [SerializeField] private float _flashInterval = 2f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private Rigidbody _rigidbody;\n    [SerializeField] private bool _useBoxCollider = true;\n    [SerializeField] private float _boxColliderScale = 1f;\n    \n    private Vector3 _startPosition;\n    private Quaternion _startRotation;\n    private bool _isOpen = false;\n    private bool _hasPopped = false;\n    private Coroutine _wobbleCoroutine;\n    private Coroutine _flashCoroutine;\n    private int _currentPopIndex = 0;\n    private float _lastFlashTime = -1f;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _startRotation = transform.rotation;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_confettiSystem != null)\n            _confettiSystem.transform.SetParent(transform);\n            \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        SetupCollider();\n    }\n    \n    void Update()\n    {\n        HandleBoxMovement();\n        UpdateWobble();\n        UpdateConfetti();\n        UpdateLights();\n    }\n    \n    private void SetupCollider()\n    {\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\n        \n        if (_useBoxCollider)\n        {\n            boxCollider.enabled = false;\n            boxCollider.scale = Vector3.one * _boxColliderScale;\n            \n            if (boxCollider.isTrigger)\n                boxCollider.isTrigger = true;\n        }\n    }\n    \n    private void HandleBoxMovement()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = 0f;\n        \n        // Allow player to push the box horizontally\n        if (Mathf.Abs(horizontalInput) > 0.1f)\n        {\n            Vector3 force = new Vector3(horizontalInput * _jumpForce, 0f, 0f);\n            _rigidbody.AddForce(force, ForceMode.Impulse);\n        }\n        \n        // Apply gravity to make box fall if not being pushed\n        float gravityMultiplier = _gravityScale;\n        _rigidbody.AddForce(Vector3.down * gravityMultiplier * Time.deltaTime * _wobbleSpeed, ForceMode.Acceleration);\n    }\n    \n    private void UpdateWobble()\n    {\n        if (_isOpen && !_hasPopped)\n        {\n            float time = Time.time - _startTime;\n            \n            if (!_wobbleCoroutine || !IsValidCoroutine(_wobbleCoroutine))\n            {\n                StartCoroutine(WobbleAnimation());\n            }\n        }\n    }\n    \n    private IEnumerator WobbleAnimation()\n    {\n        _startTime = Time.time;\n        \n        for (float t = 0f; t < _wobbleDuration; t += 1f)\n        {\n            float normalizedTime = t / _wobbleDuration;\n            float wobbleAmount = _wobbleCurve.Evaluate(normalizedTime) * _wobbleHeight;\n            \n            transform.position = new Vector3(\n                _startPosition.x,\n                _startPosition.y + Mathf.Sin(_wobbleSpeed * Time.time) * wobbleAmount,\n                _startPosition.z\n            );\n            \n            yield return new WaitForSeconds(1f / _wobbleSpeed);\n        }\n        \n        _hasPopped = true;\n    }\n    \n    private void UpdateConfetti()\n    {\n        if (_confettiSystem != null && !_hasPopped)\n        {\n            float timeScale = Time.time * 2f; // Faster movement\n            Vector3 velocity = transform.velocity.normalized * 5f * timeScale;\n            \n            _confettiSystem.Play();\n            _confettiSystem.transform.position = transform.position + new Vector3(\n                Mathf.Sin(Time.time * 10f) * 0.5f,\n                Mathf.Cos(Time.time * 8f) * 0.3f,\n                Mathf.Sin(Time.time * 12f) * 0.4f\n            );\n            \n            while (_confettiSystem.isPlaying)\n            {\n                if (!_hasPopped && !_isOpen)\n                {\n                    yield return new WaitForSeconds(1f);\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    \n    private void UpdateLights()\n    {\n        if (_flashLight != null)\n        {\n            float currentTime = Time.time;\n            \n            if (currentTime >= _lastFlashTime + _flashDuration && !_hasPopped)\n            {\n                _flashLight.enabled = true;\n                StartCoroutine(FlashSequence());\n            }\n            else\n            {\n                _flashLight.enabled = false;\n            }\n        }\n    }\n    \n    private IEnumerator FlashSequence()\n    {\n        _lastFlashTime = Time.time;\n        \n        for (int i = 0; i < 3; i++)\n        {\n            yield return new WaitForSeconds(_flashInterval);\n            if (!_hasPopped && !_isOpen)\n            {\n                _flashLight.enabled = true;\n                yield return new WaitForSeconds(_flashDuration);\n                _flashLight.enabled = false;\n            }\n        }\n        \n        if (!_hasPopped && !_isOpen)\n        {\n            _flashLight.enabled = true;\n            yield return new WaitForSeconds(_flashDuration);\n            _flashLight.enabled = false;\n        }\n    }\n    \n    public void OpenBox()\n    {\n        if (_isOpen || _hasPopped) return;\n        \n        _isOpen = true;\n        _startTime = Time.time;\n        \n        // Play opening sound\n        if (_audioSource != null && _popSounds.Length > 0)\n        {\n            PlaySound(_popSounds[0]);\n        }\n    }\n    \n    public void PopBox()\n    {\n        if (_hasPopped || !_isOpen) return;\n        \n        _hasPopped = true;\n        _currentPopIndex++;\n        \n        // Play pop sound\n        if (_audioSource != null && _popSounds.Length > 0)\n        {\n            int nextSoundIndex = (_currentPopIndex + _popSounds.Length - 1) % _popSounds.Length;\n            PlaySound(_popSounds[nextSoundIndex]);\n        }\n        \n        // Apply jump force\n        Vector3 force = new Vector3(0f, 0f, 15f);\n        _rigidbody.AddForce(force, ForceMode.Impulse);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n    \n    public bool IsBoxOpen => _isOpen;\n    public bool HasPopped => _hasPopped;\n    public float BoxPositionY => _startPosition.y + Mathf.Sin(Time.time * 2f) * _wobbleHeight;\n    public Quaternion BoxRotation => _startRotation * Quaternion.Euler(0, -90, 0);\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_hasPopped)\n        {\n            // Allow player to interact\n            if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(0))\n            {\n                OpenBox();\n            }\n        }\n    }\n    \n    private bool IsValidCoroutine(coroutine coro)\n    {\n        return coro != null;\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.63)",
      "Animation.AddClip (0.62)",
      "Animator.GetNextAnimationClipState (0.62)",
      "Animator.GetCurrentAnimationClipState (0.62)",
      "Animation.IsPlaying (0.62)",
      "Animator.PlayInFixedTime (0.61)",
      "ParticleSystem.GetPlaybackState (0.61)",
      "ParticleSystem.TextureSheetAnimationModule (0.60)",
      "ParticleSystem.Play (0.60)",
      "Animations.AnimationPlayableOutput (0.42)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class JackInTheBox : MonoBehaviour\n{\n    [Header(\"Box Animation\")]\n    [SerializeField] private float _wobbleSpeed = 1f;\n    [SerializeField] private float _maxWobbleIntensity = 0.3f;\n    [SerializeField] private float _wobbleDuration = 2f;\n    \n    [Header(\"Pop Sequence\")]\n    [SerializeField] private float _popDelay = 8f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _confettiSpawnRate = 10f;\n    [SerializeField] private int _maxConfettiParticles = 200;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _popSound;\n    [SerializeField] private AudioClip _hornSound;\n    [SerializeField] private AudioClip[] _musicTracks;\n    [SerializeField] private float _musicVolume = 0.3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _confettiParticles;\n    [SerializeField] private Transform _boxHandle;\n    [SerializeField] private GameObject _popEffectPrefab;\n    [SerializeField] private Renderer _boxRenderer;\n    [SerializeField] private Material _boxMaterial;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _enableWobble = true;\n    [SerializeField] private AnimationCurve _wobbleCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Collider _collider;\n    private bool _isPopped = false;\n    private Coroutine _wobbleCoroutine;\n    private Coroutine _musicCoroutine;\n    private Coroutine _resetCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupBoxAnimation();\n        SetupMusic();\n        SetupConfetti();\n        \n        if (_boxHandle != null)\n            _boxHandle.gameObject.SetActive(false);\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_boxRenderer == null)\n            _boxRenderer = gameObject.GetComponent<Renderer>();\n            \n        if (_confettiParticles == null)\n            _confettiParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void SetupBoxAnimation()\n    {\n        if (_enableWobble && _wobbleCoroutine == null)\n        {\n            _wobbleCoroutine = StartCoroutine(WobbleAnimation());\n        }\n    }\n    \n    private void SetupMusic()\n    {\n        if (_musicTracks != null && _musicTracks.Length > 0)\n        {\n            _audioSource.clip = _musicTracks[0];\n            _audioSource.loop = true;\n            _audioSource.volume = _musicVolume;\n            _audioSource.Play();\n            \n            if (_musicCoroutine == null)\n                _musicCoroutine = StartCoroutine(MusicSequence());\n        }\n    }\n    \n    private void SetupConfetti()\n    {\n        if (_confettiParticles != null && !_isPopped)\n        {\n            _confettiParticles.Stop();\n            _confettiParticles.transform.SetParent(transform);\n            \n            var confettiCount = _maxConfettiParticles;\n            var confettiPrefab = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            confettiPrefab.transform.localScale = Vector3.one * 0.1f;\n            \n            for (int i = 0; i < confettiCount; i++)\n            {\n                confettiPrefab.AddComponent<ParticleSystem>();\n                confettiPrefab.GetComponent<ParticleSystem>().Start();\n                \n                var particle = confettiPrefab.AddComponent<ParticleSystem>();\n                particle.AddParticle(new ParticleSystem.Particle(\n                    new ParticleSystem.DeliveryMode.Instantiate(),\n                    new ParticleSystem.EmissionMode.Uniform,\n                    new ParticleSystem.ShapeModule.Cone()\n                        .SetAngle(45f)\n                        .SetHeight(0.5f)\n                        .SetShapeType(ParticleSystem.ShapeModule.ConeShapeType.Triangle)\n                ),\n                    new ParticleSystem.TimeSpan(i * (1f / _confettiSpawnRate)))\n                );\n            }\n        }\n    }\n    \n    private IEnumerator WobbleAnimation()\n    {\n        float elapsed = 0f;\n        \n        while (elapsed < _wobbleDuration)\n        {\n            float progress = elapsed / _wobbleDuration;\n            float wobbleIntensity = _wobbleCurve.Evaluate(progress) * _maxWobbleIntensity;\n            \n            if (_enableWobble && !_isPopped)\n            {\n                transform.position += Vector3.forward * -wobbleIntensity;\n                transform.Rotate(0, -transform.forward * wobbleIntensity * 2f * Time.deltaTime, 0);\n                \n                elapsed += Time.deltaTime;\n            }\n            \n            yield return null;\n        }\n        \n        if (_enableWobble && !_isPopped)\n        {\n            _wobbleCoroutine = null;\n        }\n    }\n    \n    private IEnumerator MusicSequence()\n    {\n        float startTime = -1f;\n        \n        while (true)\n        {\n            if (startTime >= 0f)\n                yield return new WaitForSeconds(0.5f);\n            \n            if (_musicTracks.Length > 0 && _audioSource.clip != null)\n            {\n                var nextTrackIndex = (int)((Time.time - startTime) % _musicTracks.Length);\n                _audioSource.clip = _musicTracks[nextTrackIndex];\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            yield return new WaitForSeconds(1f);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n        \n        if (_boxHandle != null)\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _boxHandle.position);\n            \n        Gizmos.color = Color.green;\n        Gizmos.DrawRay(transform.position, -Vector3.up * 2f);\n    }\n    \n    private void OnValidate()\n    {\n        if (_wobbleSpeed < 0.1f) _wobbleSpeed = 0.1f;\n        else if (_wobbleSpeed > 10f) _wobbleSpeed = 10f;\n        \n        if (_maxWobbleIntensity < 0.05f) _maxWobbleIntensity = 0.05f;\n        else if (_maxWobbleIntensity > 0.5f) _maxWobbleIntensity = 0.5f;\n        \n        if (_popDelay < 1f) _popDelay = 1f;\n        else if (_explosionForce < 100f) _explosionForce = 100f;\n        else if (_confettiSpawnRate < 1f) _confettiSpawnRate = 1f;\n        else if (_maxConfettiParticles < 10) _maxConfettiParticles = 10;\n        \n        if (_rotationSpeed < 30f) _rotationSpeed = 30f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            OpenBox();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isPopped)\n        {\n            CloseBox();\n        }\n    }\n    \n    public void OpenBox()\n    {\n        if (_isPopped || _boxHandle == null) return;\n        \n        _isPopped = false;\n        _boxHandle.gameObject.SetActive(true);\n        \n        StartCoroutine(PopSequence());\n    }\n    \n    private IEnumerator PopSequence()\n    {\n        float timer = 0f;\n        \n        while (timer < _popDelay)\n        {\n            timer += Time.deltaTime;\n            \n            if (_enableWobble && !_isPopped)\n                yield return new WaitForSeconds(1f / _wobbleSpeed);\n                \n            yield return null;\n        }\n        \n        if (_enableWobble && !_isPopped)\n        {\n            _wobbleCoroutine = StartCoroutine(WobbleAnimation());\n        }\n        \n        PlayPopEffects();\n    }\n    \n    private void PlayPopEffects()\n    {\n        if (_popSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_popSound);\n            \n        if (_hornSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_hornSound);\n            \n        if (_boxRenderer != null && _boxMaterial != null)\n        {\n            _boxRenderer.material = new Material(_boxMaterial);\n            _boxRenderer.material.SetColor(\"_Color\", Color.red);\n            _boxRenderer.material.SetColor(\"_EmissionColor\", Color.red * 2f);\n        }\n        \n        if (_popEffectPrefab != null)\n        {\n            GameObject popEffect = Instantiate(_popEffectPrefab, transform.position, Quaternion.identity);\n            Destroy(popEffect, 3f);\n        }\n    }\n    \n    public void CloseBox()\n    {\n        if (_isPopped || _boxHandle == null) return;\n        \n        _isPopped = true;\n        _wobbleCoroutine?.Stop();\n        _musicCoroutine?.Stop();\n        _resetCoroutine?.WaitForChild(\"ResetAnimation\");\n        \n        _boxHandle.gameObject.SetActive(false);\n    }\n    \n    public void ResetBox()\n    {\n        if (_enableWobble && !_isPopped)\n            _wobbleCoroutine = null;\n            \n        if (_musicCoroutine != null)\n            _musicCoroutine = null;\n            \n        if (_resetCoroutine == null)\n        {\n            _resetCoroutine = StartCoroutine(ResetAnimation());\n        }\n    }\n    \n    private IEnumerator ResetAnimation()\n    {\n        float startTime = Time.time;\n        \n        while (true)\n        {\n            yield return new WaitForSeconds(1f);\n            \n            if (Time.time - startTime >= 5f)\n            {\n                CloseBox();\n                break;\n            }\n        }\n    }\n}",
    "per_behavior_docs": 18,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "start_suspense_sequence": [
        "Rigidbody.MoveRotation (0.69)",
        "Rigidbody.IsSleeping (0.68)",
        "Rigidbody2D.MoveRotation (0.68)"
      ],
      "increase_wobble_intensity": [
        "GameObject.InstantiateGameObjects (0.69)",
        "Object.FindObjectsOfTypeIncludingAssets (0.66)",
        "GameObject.GetScene (0.66)"
      ],
      "build_suspense_timer": [
        "Rigidbody.MoveRotation (0.67)",
        "Rigidbody.IsSleeping (0.66)",
        "Rigidbody.WakeUp (0.65)"
      ],
      "execute_pop_explosion": [
        "ParticleSystem.VelocityOverLifetimeModule (0.65)",
        "ParticleSystem.LimitVelocityOverLifetimeModule (0.65)",
        "ParticleSystem.ForceOverLifetimeModule (0.65)"
      ],
      "confetti_fall_sequence": [
        "ParticleSystemForceFieldShape (0.68)",
        "ParticleSystem.Play (0.68)",
        "ParticleSystem.ExternalForcesModule (0.68)"
      ],
      "reset_box_position": [
        "ParticleSystem.GetPlaybackState (0.70)",
        "ParticleSystem.Play (0.70)",
        "ParticleSystem.TextureSheetAnimationModule (0.70)"
      ],
      "complete_reset_sequence": [
        "Transform.GetPositionAndRotation (0.71)",
        "Transform.SetPositionAndRotation (0.70)",
        "Animator.GetIKRotationWeight (0.69)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 55,
        "justification": "Direct translation with some structure, but lacks clear modularization. Good Unity-specific patterns but heavy single-responsibility violation in Update() method."
      },
      "ir_monolithic": {
        "architecture": 3,
        "fixability": 5,
        "unity_patterns": 4,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 41,
        "justification": "Overly complex, scattered responsibilities, inconsistent method implementations. Seems more like a generated template than a cohesive solution."
      },
      "ir_per_behavior": {
        "architecture": 9,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 74,
        "justification": "Extremely clean separation of concerns, modular design with clear initialization methods, excellent use of Unity components and serialized fields."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The per-behavior approach provides the most structured, maintainable, and extensible implementation by breaking down complex behaviors into discrete, manageable methods and leveraging Unity's component system effectively.",
      "advantages": "Clear method responsibilities, easy to understand and extend, follows Unity best practices, provides clear extension points for future feature additions, and maintains a clean separation between initialization, animation, and effect logic."
    },
    "error": null
  },
  {
    "prompt_num": 10,
    "prompt": "Make a metamorphosis cocoon that over 45 seconds gradually transforms from a dull gray lump into a shimmering chrysalis, with periodic subtle movements, glowing internal pulses, and quiet organic sounds, finally hatching with a dramatic split animation and butterfly particle burst.",
    "timestamp": "2026-01-08T22:23:43.939481",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class MetamorphosisCocoon : MonoBehaviour\n{\n    [Header(\"Cocoon Transformation Settings\")]\n    [SerializeField] private float _totalTransformationTime = 45f;\n    [SerializeField] private int _transformationStages = 5;\n    [SerializeField] private float _stageDuration = _totalTransformationTime / _transformationStages;\n    [SerializeField] private AnimationCurve _colorTransitionCurve = AnimationCurve.EaseInOut(0, 0.3f, 1, 0.7f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hatchParticles;\n    [SerializeField] private Transform _butterflySpawnPoint;\n    [SerializeField] private AudioClip _hatchingSound;\n    [SerializeField] private float _glowIntensity = 2f;\n    [SerializeField] private float _pulseSpeed = 1f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private bool _swayLeftRight = true;\n    [SerializeField] private float _swaySpeed = 0.5f;\n    [SerializeField] private float _swayRange = 0.3f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _rotate = true;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _rotationOffset = Random.Range(-45f, 45f);\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Color _initialColor = Color.gray;\n    private Material _cocoonMaterial;\n    private bool _isTransforming = false;\n    private int _currentStage = 0;\n    private float _timeElapsed = 0f;\n    private Vector3 _swayOffset = new Vector3(Random.Range(-_swayRange, _swayRange), 0, Random.Range(-_swayRange, _swayRange));\n    \n    void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n            _renderer = gameObject.AddComponent<Renderer>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _cocoonMaterial = _renderer.material;\n        \n        if (_renderer.material.HasProperty(\"_Mode\"))\n            _renderer.material.SetColor(\"_Mode\", Color.white);\n            \n        if (_butterflySpawnPoint == null)\n            _butterflySpawnPoint = transform;\n    }\n    \n    void Update()\n    {\n        if (!_isTransforming) return;\n        \n        _timeElapsed += Time.deltaTime;\n        float progress = _timeElapsed / _totalTransformationTime;\n        \n        UpdateStage(progress);\n        UpdateEffects(progress);\n        UpdateMovement(progress);\n        UpdateRotation(progress);\n    }\n    \n    void FixedUpdate()\n    {\n        if (_swayLeftRight && _renderer != null)\n        {\n            Vector3 swayDirection = _swayOffset.normalized * _swayRange;\n            transform.position += swayDirection * _swaySpeed * Time.fixedDeltaTime;\n        }\n    }\n    \n    void UpdateStage(float progress)\n    {\n        int nextStage = Mathf.FloorToInt(progress * _transformationStages);\n        \n        if (nextStage >= _currentStage + 1)\n        {\n            _currentStage++;\n            UpdateStageProgress(_currentStage, progress);\n        }\n    }\n    \n    void UpdateStageProgress(int stage, float progress)\n    {\n        if (_renderer != null && _cocoonMaterial.HasProperty(\"_Mode\"))\n        {\n            Color targetColor = GetTargetColor(stage, progress);\n            _cocoonMaterial.SetColor(\"_Mode\", targetColor);\n        }\n        \n        if (_renderer.material.HasProperty(\"_Color\"))\n        {\n            Color currentColor = _renderer.material.GetColor(\"_Color\");\n            Color colorDelta = targetColor - currentColor;\n            \n            if (Mathf.Abs(colorDelta.r) > 0.01f || Mathf.Abs(colorDelta.g) > 0.01f || Mathf.Abs(colorDelta.b) > 0.01f)\n            {\n                _renderer.material.SetColor(\"_Color\", targetColor);\n            }\n        }\n    }\n    \n    Color GetTargetColor(int stage, float progress)\n    {\n        float t = progress * _colorTransitionCurve.Evaluate(stage);\n        return _initialColor + (Color.white - _initialColor) * t;\n    }\n    \n    void UpdateEffects(float progress)\n    {\n        if (_renderer != null && _cocoonMaterial.HasProperty(\"_GlowAmount\"))\n        {\n            float glowAmount = Mathf.Lerp(0f, _glowIntensity, progress);\n            _cocoonMaterial.SetFloat(\"_GlowAmount\", glowAmount);\n        }\n        \n        if (_audioSource != null)\n        {\n            float pulse = Mathf.Sin(progress * _pulseSpeed) * 0.5f + 0.5f;\n            float volume = Mathf.Lerp(0f, 1f, progress);\n            \n            Vector3 pitchOffset = new Vector3(\n                Mathf.Lerp(0f, 2f, progress),\n                Mathf.Lerp(0f, 1f, progress),\n                Mathf.Lerp(0f, 2f, progress)\n            );\n            \n            _audioSource.pitch = pitchOffset.x;\n            _audioSource.volume = volume * pulse;\n            _audioSource.PlayOneShot(_hatchingSound);\n        }\n    }\n    \n    void UpdateMovement(float progress)\n    {\n        if (!_swayLeftRight || progress < 0.1f) return;\n        \n        float swayX = Mathf.Sin(progress * _pulseSpeed + _rotationOffset) * _swayRange;\n        transform.position += Vector3.up * swayX * Time.deltaTime;\n    }\n    \n    void UpdateRotation(float progress)\n    {\n        if (!_rotate || progress < 0.1f) return;\n        \n        float rotationAngle = _rotationSpeed * progress + _rotationOffset;\n        transform.Rotate(Vector3.forward, rotationAngle * Time.deltaTime);\n    }\n    \n    void OnValidate()\n    {\n        if (_totalTransformationTime <= 0)\n            _totalTransformationTime = 10f;\n            \n        if (_stageDuration < 0.1f)\n            _stageDuration = 0.1f;\n            \n        if (_swaySpeed < 0.1f)\n            _swaySpeed = 0.1f;\n            \n        if (_rotationSpeed < 10f)\n            _rotationSpeed = 10f;\n    }\n    \n    public void StartTransformation()\n    {\n        if (_isTransforming) return;\n        \n        _isTransforming = true;\n        _timeElapsed = 0f;\n        _currentStage = 0;\n        \n        Invoke(nameof(StartTransformationSequence), 1f);\n    }\n    \n    private void StartTransformationSequence()\n    {\n        if (_audioSource != null && _hatchingSound != null)\n            _audioSource.clip = _hatchingSound;\n            \n        Invoke(nameof(CompleteTransformation), _totalTransformationTime);\n    }\n    \n    public void CompleteTransformation()\n    {\n        if (_isTransforming) return;\n        \n        _isTransforming = false;\n        _currentStage++;\n        \n        if (_currentStage >= _transformationStages + 1)\n        {\n            ShowHatchEffect();\n            Debug.Log(\"Metamorphosis complete!\");\n            \n            // Spawn butterfly or trigger next phase\n            if (_butterflySpawnPoint != null)\n                Invoke(nameof(SpawnButterfly), 2f);\n        }\n    }\n    \n    private void ShowHatchEffect()\n    {\n        if (_hatchParticles != null && !_isTransforming)\n        {\n            _hatchParticles.Play();\n        }\n        \n        // Optional: fade out material\n        if (_renderer != null)\n        {\n            Material mat = _renderer.material;\n            if (mat.HasProperty(\"_Alpha\"))\n                mat.SetColor(\"_Alpha\", Color.white * 0.3f);\n        }\n    }\n    \n    private void SpawnButterfly()\n    {\n        // Create butterfly object or trigger transformation to next phase\n        GameObject butterfly = new GameObject(\"Butterfly\");\n        butterfly.transform.SetParent(_butterflySpawnPoint.parent, false);\n        \n        // Add simple butterfly model (use placeholder or create basic mesh)\n        MeshRenderer renderer = butterfly.AddComponent<MeshRenderer>();\n        renderer.material = Resources.Load<Material>(\"DefaultMaterial\") ?? default(Material);\n        \n        // Add particles\n        ParticleSystem particleSystem = butterfly.AddComponent<ParticleSystem>();\n        particleSystem.Play();\n        \n        // Play sound\n        AudioSource audioSource = butterfly.GetComponent<AudioSource>();\n        if (audioSource != null && _hatchingSound != null)\n            audioSource.PlayOneShot(_hatchingSound);\n            \n        // Destroy after brief delay\n        Invoke(nameof(DestroyButterfly), 2f);\n    }\n    \n    private void DestroyButterfly()\n    {\n        if (_butterflySpawnPoint != null)\n        {\n            GameObject butterfly = _butterflySpawnPoint.gameObject;\n            if (butterfly && butterfly.GetComponent<MeshRenderer>() != null)\n                butterfly.SendMessage(\"Destroy\", true);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "TransformationCocoon",
      "components": [
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "startColor",
          "type": "Color",
          "default": "Color white"
        },
        {
          "name": "endColor",
          "type": "Color",
          "default": "Color iridescent blue with gold gradients"
        },
        {
          "name": "transformationTime",
          "type": "float",
          "default": 45.0
        },
        {
          "name": "pulseSpeed",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "glowIntensity",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "hatchDuration",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "cocoonMass",
          "type": "float",
          "default": 10.0
        },
        {
          "name": "isHatched",
          "type": "bool",
          "default": false
        }
      ],
      "behaviors": [
        {
          "name": "gradual_color_change",
          "trigger": "start transformation process",
          "actions": [
            {
              "action": "set color to startColor"
            },
            {
              "action": "smoothly transition color toward endColor over transformationTime seconds"
            }
          ]
        },
        {
          "name": "organic_movement",
          "trigger": "every few seconds during transformation",
          "actions": [
            {
              "action": "tilt cocoon slightly left and right randomly"
            },
            {
              "action": "rotate cocoon gently around vertical axis slowly"
            },
            {
              "action": "pulse shape to give subtle breathing effect"
            }
          ]
        },
        {
          "name": "internal_glowing",
          "trigger": "continuously while transformation is active",
          "actions": [
            {
              "action": "create soft light inside cocoon with glowIntensity magnitude"
            },
            {
              "action": "pulse glowing intensity up and down slowly over time"
            }
          ]
        },
        {
          "name": "ambient_soundscape",
          "trigger": "while cocoon is present",
          "actions": [
            {
              "action": "play low frequency humming soundscape"
            },
            {
              "action": "add subtle crackling organic noise under audio source"
            }
          ]
        },
        {
          "name": "cocoon_hatching",
          "trigger": "when transformation time has elapsed and color change complete",
          "actions": [
            {
              "action": "set isHatched to true"
            },
            {
              "action": "play dramatic hatching sound effect"
            },
            {
              "action": "start hatch animation with slow inward spiral"
            },
            {
              "action": "spawn butterfly particles from cocoon center"
            },
            {
              "action": "destroy this object after hatchDuration seconds"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TransformationCocoon : MonoBehaviour\n{\n    [Header(\"Cocoon Settings\")]\n    [SerializeField] private float _transformationDuration = 45f;\n    [SerializeField] private AnimationCurve _colorTransitionCurve = AnimationCurve.EaseInOut(0f, 1f);\n    [SerializeField] private Color _startColor = Color.white;\n    [SerializeField] private Color _endColor = Color.blue;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _tiltAmount = 15f;\n    [SerializeField] private float _rotationSpeed = 30f;\n    [SerializeField] private bool _pulseAnimation = true;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0.5f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _hummingSound;\n    [SerializeField] private AudioClip _hatchingSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _cocoonParticles;\n    [SerializeField] private GameObject _glowEffect;\n    [SerializeField] private Light _cocoonLight;\n    \n    [Header(\"Events\")]\n    public AnimationCurve _colorTransition = _colorTransitionCurve;\n    public float[] _targetColors = new float[16];\n    \n    private Transform _mainTransform;\n    private Renderer _mainRenderer;\n    private Material _mainMaterial;\n    private Color _currentColor;\n    private bool _isTransformationActive = false;\n    private Coroutine _transformationCoroutine;\n    private float _startTime;\n    \n    private void Awake()\n    {\n        _mainTransform = transform;\n        _mainRenderer = GetComponent<Renderer>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_cocoonLight == null)\n            _cocoonLight = GetComponent<Light>();\n            \n        SetupGlowEffect();\n    }\n    \n    private void Start()\n    {\n        InitializeParticles();\n        SetupAudio();\n        \n        // Trigger transformation when game starts\n        StartCoroutine(StartTransformation());\n    }\n    \n    private void Update()\n    {\n        if (!_isTransformationActive) return;\n        \n        HandleMovement();\n        HandlePulseAnimation();\n        UpdateGlowEffect();\n        UpdateParticles();\n        \n        CheckForHatching();\n    }\n    \n    private void InitializeParticles()\n    {\n        if (_cocoonParticles != null)\n            _cocoonParticles.Stop();\n            \n        GameObject[] particles = new GameObject[10];\n        for (int i = 0; i < 10; i++)\n        {\n            GameObject particle = new GameObject($\"CocoonParticle_{i}\");\n            particles[i] = particle;\n        }\n        \n        foreach (GameObject particle in particles)\n        {\n            ParticleSystem ps = Instantiate(particle.GetComponent<ParticleSystem>() ?? new ParticleSystem());\n            if (ps != null)\n                ps.Play();\n        }\n    }\n    \n    private void SetupGlowEffect()\n    {\n        if (_glowEffect != null && _cocoonLight == null)\n        {\n            GameObject glowObject = new GameObject(\"CocoonGlow\");\n            glowObject.transform.SetParent(transform);\n            _cocoonLight = glowObject.AddComponent<Light>();\n            _cocoonLight.type = LightType.Point;\n            _cocoonLight.color = Color.yellow;\n            _cocoonLight.intensity = 2f;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null) return;\n        \n        _hummingSound = FindSound(\"HummingSound\");\n        _hatchingSound = FindSound(\"HatchingSound\");\n        \n        if (_hummingSound != null)\n            _audioSource.clip = _hummingSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n            \n        // Add hatching sound trigger\n        StartCoroutine(TriggerHatchingSound());\n    }\n    \n    private float FindSound(string soundName)\n    {\n        AudioClip[] allSounds = Resources.LoadAll<AudioClip>(\"Audio/\");\n\n        foreach (AudioClip sound in allSounds)\n        {\n            if (sound.name.Contains(soundName))\n                return sound;\n        }\n        \n        return null;\n    }\n    \n    private IEnumerator TriggerHatchingSound()\n    {\n        while (_isTransformationActive)\n        {\n            yield return new WaitForSeconds(3f);\n            if (_hatchingSound != null && !_audioSource.isPlaying)\n            {\n                _audioSource.clip = _hatchingSound;\n                _audioSource.Play();\n            }\n        }\n    }\n    \n    private void StartTransformation()\n    {\n        _isTransformationActive = true;\n        _startTime = Time.time;\n        \n        // Create transformation coroutine\n        _transformationCoroutine = StartCoroutine(PerformTransformation());\n    }\n    \n    private IEnumerator PerformTransformation()\n    {\n        while (_isTransformationActive)\n        {\n            float elapsedTime = Time.time - _startTime;\n            \n            if (elapsedTime >= _transformationDuration)\n            {\n                CompleteTransformation();\n                break;\n            }\n            \n            UpdateCocoonColor(elapsedTime);\n            yield return null;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_mainTransform == null) return;\n        \n        float tiltX = Mathf.Sin(Time.time * 2f * _rotationSpeed) * _tiltAmount;\n        float tiltY = -Mathf.Cos(Time.time * 2f * _rotationSpeed) * _tiltAmount;\n        \n        _mainTransform.localEulerAngles = new Vector3(0, 0, 0);\n        \n        // Apply movement\n        _mainTransform.localRotation = Quaternion.Euler(tiltX, 0, tiltY);\n    }\n    \n    private void UpdateCocoonColor(float time)\n    {\n        float progress = (time / _transformationDuration) * _colorTransitionCurve.Evaluate(1f - (1f - progress));\n        \n        Color targetColor;\n        if (_colorTransitionCurve.Length == 4)\n        {\n            float t0 = progress * 2f;\n            float t1 = progress * 6f;\n            targetColor = _colorTransitionCurve.Evaluate(t0).lerp(_startColor, _endColor);\n        }\n        else\n        {\n            targetColor = _colorTransitionCurve.Evaluate(progress);\n        }\n        \n        SetCocoonColor(targetColor);\n    }\n    \n    private void SetCocoonColor(Color color)\n    {\n        _currentColor = color;\n        _targetColors[0] = color.r;\n        _targetColors[1] = color.g;\n        _targetColors[2] = color.b;\n        _targetColors[3] = color.a;\n        \n        if (_mainMaterial != null && _mainRenderer != null)\n        {\n            Color[] colors = new Color[_mainRenderer.material.GetPixelCount()];\n            for (int i = 0; i < colors.Length; i++)\n                colors[i] = _mainRenderer.material.GetPixel(i);\n                \n            _mainRenderer.material.SetColor(0, colors[0]);\n            _mainRenderer.material.SetColor(1, colors[1]);\n            _mainRenderer.material.SetColor(2, colors[2]);\n            _mainRenderer.material.SetColor(3, colors[3]);\n        }\n    }\n    \n    private void HandlePulseAnimation()\n    {\n        if (!_pulseAnimation || _mainTransform == null) return;\n        \n        float pulseProgress = (Time.time - _startTime) * 2f / _transformationDuration;\n        float pulseValue = _pulseCurve.Evaluate(pulseProgress);\n        \n        Vector3 originalScale = _cocoonLight.transform.localScale;\n        _cocoonLight.transform.localScale = new Vector3(\n            Mathf.Lerp(originalScale.x, originalScale.x * pulseValue, pulseProgress),\n            Mathf.Lerp(originalScale.y, originalScale.y * pulseValue, pulseProgress),\n            Mathf.Lerp(originalScale.z, originalScale.z * pulseValue, pulseProgress)\n        );\n    }\n    \n    private void UpdateGlowEffect()\n    {\n        if (_glowEffect == null || _cocoonLight == null) return;\n        \n        float glowIntensity = 1f + Mathf.Sin(Time.time * 2f) * 0.5f; // Add subtle pulsing\n        Color glowColor = new Color(1f, glowIntensity, 0.8f, 0.7f);\n        _cocoonLight.color = glowColor;\n    }\n    \n    private void UpdateParticles()\n    {\n        if (_cocoonParticles != null)\n        {\n            foreach (GameObject particle in _cocoonParticles.gameObject.GetComponentsInChildren<ParticleSystem>())\n                particle.Stop();\n        }\n        \n        // Add new particles every few seconds\n        if (Time.time % 3f < 1f)\n        {\n            GameObject particleObj = new GameObject(\"CocoonParticle\");\n            ParticleSystem ps = Instantiate(particleObj.GetComponent<ParticleSystem>() ?? new ParticleSystem());\n            if (ps != null)\n                ps.Play();\n        }\n    }\n    \n    private void CheckForHatching()\n    {\n        if (_isTransformationActive && Time.time >= _transformationDuration + 3f)\n        {\n            CompleteTransformation();\n        }\n    }\n    \n    private void CompleteTransformation()\n    {\n        _isTransformationActive = false;\n        \n        // Play hatching sound\n        if (_hatchingSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.clip = _hatchingSound;\n            _audioSource.Play();\n        }\n        \n        // Spawn butterfly particles\n        if (_cocoonParticles != null)\n        {\n            foreach (ParticleSystem ps in _cocoonParticles.gameObject.GetComponentsInChildren<ParticleSystem>())\n            {\n                if (ps != null && !ps.isPlaying)\n                    ps.Play();\n            }\n        }\n        \n        // Destroy cocoon after hatch duration\n        if (_glowEffect != null)\n        {\n            DestroyImmediate(_glowEffect);\n        }\n        \n        if (_cocoonLight != null)\n        {\n            DestroyImmediate(_cocoonLight.gameObject);\n        }\n        \n        // Hide or destroy the cocoon object\n        GameObject cocoonObj = GetComponentInChildren<GameObject>() ?? this;\n        if (cocoonObj != null)\n        {\n            Destroy(cocoonObj);\n        }\n    }\n    \n    public void ForceHatch()\n    {\n        if (_isTransformationActive)\n        {\n            CompleteTransformation();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        // Draw color transition curve\n        float t0 = 0f;\n        float t1 = _transformationDuration / 2f;\n        Color[] colors = new Color[16];\n        \n        for (int i = 0; i < 4; i++)\n        {\n            colors[i] = _colorTransition.Evaluate(t0).lerp(_startColor, _endColor);\n            t0 += _transformationDuration * 0.5f;\n            \n            if (i == 1)\n                t1 = _transformationDuration / 2f + Time.time * 0.3f; // Animate curve dynamically\n        }\n        \n        Vector3 center = transform.position + new Vector3(0, 0, 1);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(center, new Vector3(0.5f, 0.5f, 0.5f));\n    }\n    \n    private void OnDestroy()\n    {\n        if (_transformationCoroutine != null)\n            StopCoroutine(_transformationCoroutine);\n        \n        if (_audioSource != null && _hummingSound != null)\n            _audioSource.Stop();\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.CrossFadeQueued (0.64)",
      "Animation.AddClip (0.63)",
      "Animation.GetClipCount (0.63)",
      "Transform.SetAsLastSibling (0.61)",
      "AnimationClip.ClearCurves (0.42)",
      "AnimationClip.AddEvent (0.42)",
      "AnimationMode.BeginSampling (0.42)",
      "AnimationClip.SetCurve (0.42)",
      "AnimationMode.SamplePlayableGraph (0.41)",
      "AnimationMode.SampleAnimationClip (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MetamorphosisCocoon : MonoBehaviour\n{\n    [Header(\"Cocoon Settings\")]\n    public float _hatchTime = 45f;\n    public float _colorTransitionSpeed = 2f;\n    public float _pulseSpeed = 1.5f;\n    public float _movementRadius = 3f;\n    public float _rotationSpeed = 30f;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem hatchParticles;\n    public Light[] lights;\n    private Color _startColor;\n    private Color _finalColor;\n    private float _colorProgress;\n    private Renderer _renderer;\n    private Material _cocoonMaterial;\n    \n    [Header(\"Audio\")]\n    public AudioSource _audioSource;\n    public AudioClip _hummingSound;\n    public AudioClip _cracklingSound;\n    private float _soundTimer = 0f;\n    private float _lastHumTime = -1f;\n    private float _lastCrackleTime = -1f;\n    \n    [Header(\"Physics\")]\n    public Rigidbody2D _rigidbody;\n    public Transform _centerPoint;\n    private bool _isHatched = false;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupCocoonMaterial();\n        _startColor = _renderer.material.color;\n        _finalColor = _startColor;\n        _colorProgress = 0f;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody2D>();\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _centerPoint = transform;\n        \n        if (_centerPoint != null)\n        {\n            _centerPoint.localPosition = Vector3.zero;\n            _centerPoint.localRotation = Quaternion.identity;\n        }\n        \n        if (_audioSource == null)\n       userCode\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (lights == null)\n        {\n            lights = new Light[transform.childCount];\n            for (int i = 0; i < transform.childCount; i++)\n                lights[i] = transform.GetChild(i).GetComponent<Light>();\n        }\n    }\n    \n    private void SetupCocoonMaterial()\n    {\n        if (_renderer == null || _cocoonMaterial == null)\n        {\n            _cocoonMaterial = CreateDefaultMaterial();\n            _renderer.material = _cocoonMaterial;\n        }\n        \n        _startColor = _renderer.material.color;\n        _finalColor = _startColor;\n    }\n    \n    private Material CreateDefaultMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.SetColor(\"_BaseColor\", _startColor);\n        mat.SetInt(\"_Mode\", -1);\n        mat.SetInt(\"_SrcBlend\", 1);\n        mat.SetInt(\"_DstBlend\", 1);\n        mat.SetInt(\"_ZWrite\", 0);\n        \n        return mat;\n    }\n    \n    private void Update()\n    {\n        if (_isHatched) return;\n        \n        float elapsedTime = Time.time - _startTime;\n        \n        // Color Transition\n        _colorProgress += Time.deltaTime * _colorTransitionSpeed / _hatchTime;\n        if (_colorProgress >= 1f)\n        {\n            _colorProgress = 0f;\n            _finalColor = _renderer.material.color;\n            ChangeMaterialColor(_cocoonMaterial, _startColor, _finalColor);\n        }\n        else\n        {\n            ChangeMaterialColor(_cocoonMaterial, _startColor, new Color(\n                Mathf.LerpAngle(_startColor.r, _finalColor.r, _colorProgress),\n                Mathf.LerpAngle(_startColor.g, _finalColor.g, _colorProgress),\n                Mathf.LerpAngle(_startColor.b, _finalColor.b, _colorProgress),\n                Mathf.LerpAngle(_startColor.a, _finalColor.a, _colorProgress)\n            ));\n        }\n        \n        // Pulse Glow\n        float pulse = 1f + Mathf.Sin(Time.time * _pulseSpeed) * 0.5f;\n        if (_renderer.material.HasProperty(\"_EmissionColor\") && _renderer.material.GetColor(\"_EmissionColor\") != Color.white)\n        {\n            _renderer.material.SetColor(\"_EmissionColor\", new Color(\n                _renderer.material.GetColor(\"_EmissionColor\").r * pulse,\n                _renderer.material.GetColor(\"_EmissionColor\").g * pulse,\n                _renderer.material.GetColor(\"_EmissionColor\").b * pulse\n            ));\n        }\n        \n        // Movement\n        if (elapsedTime < _hatchTime)\n        {\n            float angle = Time.time * _rotationSpeed;\n            Vector3 movement = new Vector3(\n                Mathf.Cos(angle) * Mathf.Sin(elapsedTime / _movementRadius),\n                Mathf.Sin(angle) * Mathf.Sin(elapsedTime / _movementRadius),\n                0f\n            );\n            transform.position += movement;\n        }\n        \n        // Centering\n        if (_centerPoint != null)\n        {\n            Vector3 targetPosition = new Vector3(\n                _centerPoint.localPosition.x,\n                _centerPoint.localPosition.y + Mathf.Sin(Time.time * 2f) * 0.5f,\n                _centerPoint.localPosition.z\n            );\n            _centerPoint.localPosition = Vector3.Lerp(_centerPoint.localPosition, targetPosition, Time.deltaTime * 2f);\n        }\n        \n        // Audio\n        PlayTransformationSounds(elapsedTime);\n    }\n    \n    private void PlayTransformationSounds(float elapsedTime)\n    {\n        if (_audioSource == null) return;\n        \n        float humProgress = (elapsedTime / _hatchTime) % 1f;\n        float crackleProgress = (elapsedTime * 0.7f / _hatchTime) % 1f;\n        \n        PlayHummingSound(humProgress);\n        PlayCracklingSound(crackleProgress);\n    }\n    \n    private void PlayHummingSound(float humProgress)\n    {\n        if (_hummingSound == null || _audioSource == null) return;\n        \n        float normalizedProgress = Mathf.Periodic(humProgress, 1f);\n        float pitch = 0.5f + 0.3f * normalizedProgress; // 0.5 to 0.8\n        \n        if (_lastHumTime < 0f || Time.time - _lastHumTime > 2f)\n        {\n            _audioSource.pitch = pitch;\n            _audioSource.PlayOneShot(_hummingSound);\n            _lastHumTime = Time.time;\n        }\n    }\n    \n    private void PlayCracklingSound(float crackleProgress)\n    {\n        if (_cracklingSound == null || _audioSource == null) return;\n        \n        float normalizedProgress = Mathf.Periodic(crackleProgress, 1f);\n        float noise = (normalizedProgress * 2f - 1f) * 0.5f; // -0.5 to 0.5\n        \n        if (_lastCrackleTime < 0f || Time.time - _lastCrackleTime > 1.5f)\n        {\n            float crackleValue = Mathf.Periodic(noise, 1f);\n            _audioSource.pitch = 1f + crackleValue * 0.3f;\n            _audioSource.PlayOneShot(_cracklingSound);\n            _lastCrackleTime = Time.time;\n        }\n    }\n    \n    private void ChangeMaterialColor(Material mat, Color from, Color to)\n    {\n        if (mat.HasProperty(\"_Color\"))\n        {\n            mat.SetColor(\"_Color\", to);\n        }\n        else\n        {\n            Color[] colors = new Color[4];\n            colors[0] = from;\n            colors[1] = Color.white;\n            colors[2] = Color.white;\n            colors[3] = to;\n            \n            mat.SetColor(\"_Color\", colors);\n        }\n    }\n    \n    public void Hatch()\n    {\n        if (_isHatched) return;\n        \n        _isHatched = true;\n        _startTime = Time.time - _hatchTime + 0.1f;\n        \n        // Play hatch sound\n        if (_audioSource != null && _hummingSound != null)\n        {\n            _audioSource.pitch = 2f;\n            _audioSource.PlayOneShot(_hummingSound);\n        }\n        \n        // Spawn particles\n        if (hatchParticles != null)\n        {\n            hatchParticles.Play();\n        }\n        \n        // Apply force to pieces\n        for (int i = 0; i < transform.childCount; i++)\n        {\n            if (_centerPoint == null) continue;\n            \n            Vector3 offset = new Vector3(\n                Random.Range(-_movementRadius * 0.5f, _movementRadius * 0.5f),\n                Random.Range(-_movementRadius * 0.5f, _movementRadius * 0.5f),\n                0f\n            );\n            \n            if (_centerPoint.childIndex == i)\n                continue; // Keep center piece\n            \n            Rigidbody2D rb = transform.GetChild(i).GetComponent<Rigidbody2D>();\n            if (rb != null)\n            {\n                Vector3 force = new Vector3(\n                    Random.Range(-5f, 5f),\n                    -10f,\n                    0f\n                );\n                rb.AddForce(force, ForceMode.Acceleration);\n            }\n        }\n        \n        // Apply upward force to center piece\n        Rigidbody2D rb = _centerPoint.GetComponent<Rigidbody2D>();\n        if (rb != null)\n        {\n            rb.AddForce(Vector3.up * 5f, ForceMode.Acceleration);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _movementRadius);\n        \n        Gizmos.color = Color.red;\n        Vector3 center = transform.position + new Vector3(0f, 1.5f, 0f);\n        Gizmos.DrawRay(center, Vector3.up * 2f);\n    }\n}",
    "per_behavior_docs": 15,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "gradual_color_change": [
        "Rigidbody2D.GetRelativePointVelocity (0.65)",
        "Rigidbody.GetRelativePointVelocity (0.64)",
        "Rigidbody2D.GetPointVelocity (0.64)"
      ],
      "subtle_movement": [
        "Quaternion.RotateTowards (0.76)",
        "Quaternion.LookRotation (0.74)",
        "Transform.GetPositionAndRotation (0.74)"
      ],
      "internal_pulsing_glow": [
        "Light.AddCommandBufferAsync (0.67)",
        "Light.SetLightDirty (0.67)",
        "RigidbodyInterpolation (0.65)"
      ],
      "organic_sound_generation": [
        "AudioVelocityUpdateMode (0.56)",
        "AudioConfiguration (0.55)",
        "ConvertToPrefabInstanceSettings (0.54)"
      ],
      "hatching_sequence": [
        "GameObject.InstantiateGameObjects (0.71)",
        "ParticleSystem.Play (0.69)",
        "ParticleSystem.InheritVelocityModule (0.69)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 54,
        "justification": "Direct translation lacks clear separation of concerns. Methods are somewhat monolithic and intertwined. Good Unity-specific patterns but lacks clean architectural abstraction."
      },
      "ir_monolithic": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 62,
        "justification": "More structured approach with modular methods and clear intent. Strong use of Unity serialization and component design. Some overengineering but good extensibility."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 74,
        "justification": "Highly modular design with clear separation of initialization, behavior, and transformation logic. Excellent use of Unity patterns, defensive programming, and clean method extraction."
      },
      "winner": "ir_per_behavior",
      "key_differences": "Increasing architectural modularity and behavior separation, with IR approaches showing significant improvements over direct translation",
      "advantages": "Breaks complex transformation into discrete, manageable methods; provides clear extension points; uses defensive programming; follows Unity best practices for component design"
    },
    "error": null
  },
  {
    "prompt_num": 11,
    "prompt": "Create a synthesizer pad that generates different tones when walked upon, with pitch based on horizontal position, volume based on pressure/velocity, sustain while standing still, and visual ripples emanating from contact points that fade over time and interact with overlapping ripples.",
    "timestamp": "2026-01-08T22:27:19.473330",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SynthPad : MonoBehaviour\n{\n    [Header(\"Synthesizer Settings\")]\n    [SerializeField] private float _basePitch = 440f;\n    [SerializeField] private float _pitchRange = 20f;\n    [SerializeField] private float _stepSize = 30f;\n    [SerializeField] private int _maxSteps = 16;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _volumeRange = 0.1f;\n    [SerializeField] private float _minVolume = 0.01f;\n    [SerializeField] private float _maxVolume = 0.3f;\n    [SerializeField] private float _attackTime = 0.05f;\n    [SerializeField] private float _releaseTime = 0.5f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private ParticleSystem _rippleEffect;\n    [SerializeField] private Color _baseColor = Color.cyan;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    [SerializeField] private float _minBrightness = 0.3f;\n    [SerializeField] private float _maxBrightness = 1.5f;\n    \n    private int _currentStep = 0;\n    private bool _isPressed = false;\n    private Vector3 _startPosition;\n    private float _originalColor;\n    private Coroutine _rippleCoroutine;\n    \n    void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        _startPosition = transform.position;\n        _originalColor = _baseColor;\n        \n        if (_audioSource != null)\n            _audioSource.playOnAwake = false;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        PlaySound();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        bool wasPressed = _isPressed;\n        _isPressed = Input.GetButtonDown(\"Mouse 0\") && !wasPressed;\n        \n        if (_isPressed)\n        {\n            Vector3 currentPosition = transform.position;\n            int steps = GetSteps(currentPosition);\n            \n            if (steps > 0)\n            {\n                PlayStep(steps, currentPosition - _startPosition);\n            }\n        }\n        else\n        {\n            if (_currentStep > 0)\n            {\n                PlayStep(_currentStep, _startPosition - transform.position);\n                _currentStep--;\n            }\n        }\n    }\n    \n    private int GetSteps(Vector3 currentPosition)\n    {\n        float stepSize = _stepSize;\n        Vector3 range = new Vector3(\n            Mathf.RoundToInt(currentPosition.x / stepSize) * stepSize - currentPosition.x,\n            0f,\n            Mathf.RoundToInt(currentPosition.z / stepSize) * stepSize - currentPosition.z\n        );\n        \n        int steps = 0f;\n        float distance = range.magnitude;\n        while (distance > stepSize)\n        {\n            steps++;\n            distance -= stepSize;\n        }\n        \n        return Math.Max(1, Mathf.Floor(steps));\n    }\n    \n    private void PlayStep(int stepIndex, Vector3 stepOffset)\n    {\n        float x = _startPosition.x + stepIndex * stepOffset.x / _maxSteps;\n        float z = _startPosition.z + stepIndex * stepOffset.z / _maxSteps;\n        \n        int pitchIndex = Mathf.Clamp(stepIndex % _maxSteps, 0, _currentStep);\n        PlayPitch(pitchIndex);\n    }\n    \n    private void PlayPitch(int index)\n    {\n        if (_audioSource == null) return;\n        \n        float targetPitch = _basePitch + (index - _maxSteps / 2f) * (2f * Mathf.PI / _maxSteps);\n        float frequency = Mathf.Round(targetPitch * 1000f) / 1000f;\n        \n        PitchRange range = new PitchRange(frequency, frequency * (1f + (_pitchRange / _maxSteps)));\n        range.SetPitch(frequency);\n        \n        _audioSource.pitch = range.pitch;\n        _audioSource.volume = GetVolume(_currentStep);\n        _audioSource.Play();\n        \n        if (!_isPressed)\n        {\n            StopAllCoroutines();\n            _audioSource.Stop();\n        }\n    }\n    \n    private float GetVolume(int stepIndex)\n    {\n        float normalizedStep = (stepIndex - _maxSteps / 2f) / (_maxSteps / 2f);\n        float volume = Mathf.Clamp01(normalizedStep * _volumeRange);\n        return _minVolume + (volume * (_maxVolume - _minVolume));\n    }\n    \n    private void PlaySound()\n    {\n        if (!_isPressed || _audioSource == null) return;\n        \n        float normalizedStep = (_currentStep - 1f) / 2f; // From -1 to 1\n        float volume = Mathf.Clamp01(normalizedStep * _volumeRange);\n        float pitch = _basePitch + (normalizedStep * _pitchRange);\n        \n        PitchRange range = new PitchRange(pitch, pitch * (1f + (_pitchRange / 2f)));\n        range.SetPitch(pitch);\n        \n        _audioSource.pitch = range.pitch;\n        _audioSource.volume = volume;\n        _audioSource.Play();\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (!_isPressed || _rippleCoroutine != null) return;\n        \n        Color targetColor = GetTargetColor(_currentStep);\n        Color currentColor = _baseColor;\n        \n        float t = Time.deltaTime / 0.5f;\n        currentColor = Color.Lerp(currentColor, targetColor, t);\n        \n        if (Mathf.Abs(currentColor.r - targetColor.r) < 0.01f)\n        {\n            StopAllCoroutines();\n            _rippleCoroutine = null;\n        }\n    }\n    \n    private Color GetTargetColor(int stepIndex)\n    {\n        float normalizedStep = (stepIndex - (_maxSteps + 1f) / 2f) / (_maxSteps / 2f);\n        float red = Mathf.Clamp01(normalizedStep * _colorTransitionSpeed);\n        float green = Mathf.Lerp(0.3f, 1f, red);\n        float blue = Mathf.Lerp(0.6f, 1f, red);\n        \n        return new Color(\n            red,\n            green,\n            blue,\n            Mathf.Lerp(_minBrightness, _maxBrightness, red)\n        );\n    }\n    \n    private void StartRippleEffect()\n    {\n        if (_rippleEffect == null) return;\n        \n        _rippleCoroutine = StartCoroutine(RippleCoroutine());\n    }\n    \n    private System.Collections.IEnumerator RippleCoroutine()\n    {\n        Vector3 originalPos = transform.position;\n        Color originalColor = _baseColor;\n        \n        while (Mathf.Abs(_currentStep - 1f) > 0.05f)\n        {\n            yield return new WaitForSeconds(0.2f);\n            \n            transform.position = originalPos + (transform.position - originalPos) * \n                Mathf.Sin(Time.time * 5f);\n            \n            Color currentColor = _baseColor;\n            float t = Time.deltaTime / 0.5f;\n            for (int i = 0; i < _colorTransitionSpeed; i++)\n            {\n                currentColor = Color.Lerp(currentColor, \n                    GetTargetColor(_currentStep), t * i);\n            }\n            \n            transform.color = currentColor;\n        }\n        \n        StopAllCoroutines();\n    }\n    \n    [System.Serializable]\n    public class PitchRange\n    {\n        private float _minPitch;\n        private float _maxPitch;\n        private float _targetPitch;\n        \n        public PitchRange(float min, float max)\n        {\n            _minPitch = Mathf.Min(min, max);\n            _maxPitch = Mathf.Max(min, max);\n            _targetPitch = min;\n        }\n        \n        public void SetPitch(float pitch)\n        {\n            if (pitch < _minPitch) pitch = _minPitch;\n            else if (pitch > _maxPitch) pitch = _maxPitch;\n            _targetPitch = pitch;\n        }\n        \n        public float Pitch => _targetPitch;\n    }\n}",
    "ir_json": {
      "class_name": "SynthPad",
      "components": [
        "Collider",
        "AudioSource",
        "Renderer",
        "Animator"
      ],
      "fields": [
        {
          "name": "basePitch",
          "type": "float",
          "default": 440
        },
        {
          "name": "pitchRange",
          "type": "float",
          "default": 100
        },
        {
          "name": "maxVolume",
          "type": "float",
          "default": "1f"
        },
        {
          "name": "baseVolume",
          "type": "float",
          "default": "0.5f"
        },
        {
          "name": "sustainTime",
          "type": "float",
          "default": "2f"
        },
        {
          "name": "fadeDuration",
          "type": "float",
          "default": "1f"
        },
        {
          "name": "rippleIntensity",
          "type": "float",
          "default": "0.5f"
        },
        {
          "name": "materialDensity",
          "type": "float",
          "default": "1f"
        },
        {
          "name": "velocitySensitivity",
          "type": "float",
          "default": "0.8f"
        }
      ],
      "behaviors": [
        {
          "name": "generate_tone_on_contact",
          "trigger": "when player collides with this pad area",
          "actions": [
            {
              "action": "calculate pitch based on horizontal distance from center"
            },
            {
              "action": "apply velocity-based volume modulation to tone amplitude"
            },
            {
              "action": "start sustained note at calculated pitch and volume"
            },
            {
              "action": "spawn visual ripple effect centered at contact point"
            }
          ]
        },
        {
          "name": "update_ripple_interactions",
          "trigger": "every frame while pad is active",
          "actions": [
            {
              "action": "gradually reduce all existing ripple amplitudes toward zero"
            },
            {
              "action": "add new ripple particles from contact point outward"
            },
            {
              "action": "make overlapping ripples combine colors and intensities"
            },
            {
              "action": "limit maximum ripple density based on material thickness"
            }
          ]
        },
        {
          "name": "fade_when_not_contacted",
          "trigger": "when no player is touching the pad for fade duration",
          "actions": [
            {
              "action": "gradually reduce sustained note volume to zero"
            },
            {
              "action": "stop visual ripple effects completely"
            },
            {
              "action": "clear any active audio channels if possible"
            }
          ]
        },
        {
          "name": "animate_visual_ripples",
          "trigger": "every frame while pad is active and being touched",
          "actions": [
            {
              "action": "create animated wave patterns that move outward from contact point"
            },
            {
              "action": "change ripple color based on pitch and time"
            },
            {
              "action": "add slight random variation to ripple timing for natural motion"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SynthPad : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _basePitch = 440f;\n    [SerializeField] private float _pitchRange = 100f;\n    [SerializeField] private float _maxVolume = 1f;\n    [SerializeField] private float _minVolume = 0.01f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Ripple Effects\")]\n    [SerializeField] private ParticleSystem[] _rippleParticles;\n    [SerializeField] private float _maxRippleIntensity = 2f;\n    [SerializeField] private AnimationCurve _rippleIntensityCurve = AnimationCurve.Linear(0f, 0.5f, 1f, 0f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _visualEffectPrefab;\n    [SerializeField] private float _fadeDuration = 2f;\n    [SerializeField] private float _rippleDuration = 0.3f;\n    [SerializeField] private Color _baseColor = Color.white;\n    \n    [Header(\"Audio Effects\")]\n    [SerializeField] private bool _usePitchShifting = true;\n    [SerializeField] private float _pitchShiftAmount = 20f;\n    [SerializeField] private AnimationCurve _pitchShiftCurve = AnimationCurve.Linear(0f, -1f, 1f, 1f);\n    \n    private List<Collider> _activeColliders = new List<Collider>();\n    private bool _isPlaying = false;\n    private float _originalVolume;\n    private float _currentRippleIntensity;\n    private Color _currentColor;\n    private Coroutine _fadeCoroutine;\n    \n    [System.Serializable]\n    public class RippleData\n    {\n        public ParticleSystem particleSystem;\n        public float intensity;\n        public float duration;\n        public Color color;\n        public bool usePitchShift = true;\n        public float pitchShiftAmount = 20f;\n        public AnimationCurve pitchShiftCurve = AnimationCurve.Linear(0f, -1f, 1f, 1f);\n    }\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (!_audioSource.isPlaying && _useVisualEffectPrefab != null)\n            CreateVisualEffect();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            PlayNote(other);\n            SetupRippleEffects(other.transform.position, other.GetComponent<Collider>()?.bounds.size);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopNote();\n            ClearRippleEffects();\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isPlaying)\n        {\n            PlayNote(other);\n            SetupRippleEffects(other.transform.position, other.GetComponent<Collider>()?.bounds.size);\n        }\n    }\n    \n    private void PlayNote(Collider player)\n    {\n        if (_audioSource.isPlaying) return;\n        \n        _isPlaying = true;\n        _originalVolume = _audioSource.volume;\n        \n        CalculatePitch(player);\n        ApplyVolume();\n        SetupAudioEffects(player);\n        \n        _audioSource.Play();\n    }\n    \n    private void StopNote()\n    {\n        if (!_audioSource.isPlaying) return;\n        \n        _audioSource.Stop();\n        _isPlaying = false;\n        \n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n            _fadeCoroutine = null;\n        }\n    }\n    \n    private void CalculatePitch(Collider player)\n    {\n        float horizontalDistance = Vector3.Distance(player.transform.position, transform.position);\n        float normalizedX = (horizontalDistance / 2f) - 1f; // Centered between -1 and 1\n        \n        if (_usePitchShifting)\n        {\n            float pitchMultiplier = _pitchShiftCurve.Evaluate(normalizedX * _pitchShiftAmount);\n            pitchMultiplier = Mathf.Clamp01(pitchMultiplier); // Limit to audio frequency range\n            \n            float finalPitch = _basePitch * pitchMultiplier;\n            finalPitch += (random.value * 50f) - 25f; // Add slight random variation\n            \n            if (finalPitch < 20f)\n                finalPitch = 20f;\n            else if (finalPitch > 10000f)\n                finalPitch = 10000f;\n        }\n        else\n        {\n            float finalPitch = _basePitch * (1f + normalizedX * 0.5f);\n            finalPitch = Mathf.Clamp01(finalPitch); // Limit to audio frequency range\n            \n            if (finalPitch < 20f)\n                finalPitch = 20f;\n            else if (finalPitch > 10000f)\n                finalPitch = 10000f;\n        }\n        \n        _audioSource.pitch = finalPitch;\n    }\n    \n    private void ApplyVolume()\n    {\n        float targetVolume = Mathf.Lerp(_minVolume, _maxVolume, _volumeCurve.Evaluate(_audioSource.volume / _originalVolume));\n        _audioSource.volume = Mathf.Clamp(targetVolume, _minVolume, _maxVolume);\n        \n        if (_audioSource.isPlaying)\n            _currentRippleIntensity = Mathf.Lerp(0f, _maxRippleIntensity, \n                _rippleIntensityCurve.Evaluate(_audioSource.volume / _originalVolume));\n    }\n    \n    private void SetupAudioEffects(Collider player)\n    {\n        // Add reverb for a more realistic synth sound\n        if (_audioSource != null && player.GetComponent<ReverbFX>() == null)\n            player.AddComponent<ReverbFX>();\n        \n        // Pitch shift can be added as a separate component if needed\n        \n        // Create pitch shifting effect (requires additional audio processing)\n        // This would typically use a pitch-shifting filter or external plugin\n    }\n    \n    private void SetupRippleEffects(Vector3 contactPoint, Vector3 rippleSize)\n    {\n        ClearRippleEffects();\n        \n        for (int i = 0; i < _rippleParticles.Length; i++)\n        {\n            RippleData data = _rippleParticles[i].GetComponent<ParticleSystem>().data;\n            \n            if (data == null) continue;\n            \n            // Calculate distance from center of pad to contact point\n            float distanceToCenter = Vector3.Distance(transform.position, contactPoint);\n            float normalizedDistance = (distanceToCenter / 2f) - 1f; // Centered between -1 and 1\n            \n            data.intensity = Mathf.Lerp(0f, _maxRippleIntensity, \n                _rippleIntensityCurve.Evaluate(normalizedDistance));\n            \n            // Adjust color based on pitch\n            if (_usePitchShifting)\n            {\n                float pitchMultiplier = _pitchShiftCurve.Evaluate(normalizedDistance * _pitchShiftAmount);\n                pitchMultiplier = Mathf.Clamp01(pitchMultiplier);\n                \n                data.color = Color.Lerp(_baseColor, _baseColor * pitchMultiplier, \n                    _pitchShiftAmount > 0 ? pitchMultiplier : 1f);\n            }\n            \n            // Spawn particles\n            for (int j = 0; j < data.duration; j++)\n            {\n                float timeNormalized = j / data.duration;\n                _rippleParticles[i].AddParticle(new ParticleData()\n                {\n                    position = contactPoint + new Vector3(\n                        random.Range(-rippleSize.x * timeNormalized, rippleSize.x * timeNormalized),\n                        random.Range(0f, rippleSize.y * timeNormalized),\n                        random.Range(-rippleSize.z * timeNormalized, rippleSize.z * timeNormalized)\n                    ),\n                    velocity = new Vector3(random.Range(-5f, 5f), 10f * Mathf.Sin(timeNormalized * Mathf.PI * 2f), \n                        random.Range(-8f, 8f)),\n                    lifetime = 1f\n                });\n            }\n        }\n    }\n    \n    private void ClearRippleEffects()\n    {\n        foreach (var ripple in _rippleParticles)\n        {\n            if (ripple != null && ripple.isPlaying) ripple.Stop();\n        }\n        \n        _currentRippleIntensity = 0f;\n        _currentColor = _baseColor;\n    }\n    \n    private void CreateVisualEffect()\n    {\n        if (_visualEffectPrefab == null) return;\n        \n        GameObject effectObject = Instantiate(_visualEffectPrefab, transform.position, Quaternion.identity);\n        Collider effectCollider = effectObject.GetComponent<Collider>();\n        \n        if (effectCollider != null)\n            effectCollider.enabled = false;\n            \n        ParticleSystem particles = effectObject.AddComponent<ParticleSystem>();\n        \n        // Add basic visual feedback - can be customized further\n        var main = particles.main;\n        main.startLifetime = _rippleDuration;\n        main.startSize = 0.1f;\n        main.startSpeed = 5f;\n        main.maxParticles = 1000f;\n        \n        var emission = particles.emission;\n        emission.rateOverTime = 50f;\n        emission.startLifetime = 0f;\n        emission.startSize = 1f;\n        emission.startSpeed = 2f;\n        emission.color = _baseColor;\n        \n        var shape = particles.shape;\n        shape.type = ParticleSystemShapeType.Sphere;\n        shape.radius = 0.5f;\n        \n        var colorOverLifetime = particles.colorOverLifetime;\n        ColorOverLifetime.SetKey(0, new GradientKey(new Color(_currentColor), new AnimationCurve(0f, 0f, 1f, 1f)));\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _baseColor;\n        \n        Vector3[] corners = new Vector3[]\n        {\n            transform.position + new Vector3(-1.5f, 0f, -1.5f),\n            transform.position + new Vector3(1.5f, 0f, -1.5f),\n            transform.position + new Vector3(-1.5f, 0f, 1.5f),\n            transform.position + new Vector3(1.5f, 0f, 1.5f)\n        };\n        \n        for (int i = 0; i < corners.Length; i++)\n        {\n            if (i % 2 == 0)\n                Gizmos.DrawWireCube(corners[i], 0.5f);\n            else\n                Gizmos.DrawLine(corners[i - 1], corners[i]);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        StopNote();\n        ClearRippleEffects();\n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n            _fadeCoroutine = null;\n        }\n    }\n}\n\npublic class ParticleData\n{\n    public Vector3 position;\n    public Vector3 velocity;\n    public float lifetime;\n}\n\npublic class ParticleSystem : MonoBehaviour\n{\n    [SerializeField] private ParticleSystemShape[] _shapes;\n    [SerializeField] private Renderer[] _renderers;\n    [SerializeField] private Color[] _startColors;\n    [SerializeField] private Gradient[] _colorOverLifetime;\n    \n    private void Start()\n    {\n        CreateParticles();\n    }\n    \n    private void CreateParticles()\n    {\n        if (_shapes == null || _renderers == null) return;\n        \n        for (int i = 0; i < _shapes.Length; i++)\n        {\n            ParticleSystemShape shape = _shapes[i];\n            Renderer renderer = _renderers[i];\n            \n            if (shape != null)\n                shape.Initialize();\n                \n            if (renderer != null && i < _startColors.Length)\n                _startColors[i] = new Color(random.value, random.value, random.value);\n        }\n        \n        var main = GetComponent<ParticleSystemMain>();\n        if (main == null)\n        {\n            main = gameObject.AddComponent<ParticleSystemMain>();\n        }\n        \n        foreach (var shape in _shapes)\n        {\n            ParticleSystemShapeData data = shape.data;\n            data.startLifetime = _rippleDuration;\n            data.startSize = 0.1f;\n            data.startSpeed = 5f;\n            data.maxParticles = 1000f;\n            \n            var emission = main.emission;\n            emission.rateOverTime = 50f;\n            emission.startLifetime = 0f;\n            emission.startSize = 1f;\n            emission.startSpeed = 2f;\n        }\n        \n        var colorOverLifetime = main.colorOverLifetime;\n        if (_colorOverLifetime != null)\n        {\n            for (int i = 0; i < _colorOverLifetime.Length; i++)\n            {\n                ColorOverLifetimeKey key = colorOverLifetime[i].GetKey(0);\n                key.curve = new AnimationCurve();\n                \n                var gradient = _colorOverLifetime[i];\n                if (gradient != null)\n                {\n                    float t1 = 0f;\n                    float t2 = 1f;\n                    GradientKey[] keys = gradient.GetKeys(0, 1);\n                    \n                    key.curve.SetKey(0, new AnimationCurve.EaseInOut(t1, gradient.GetColorAt(0, 0)));\n                    key.curve.SetKey(1, new AnimationCurve.EaseInOut(t2, gradient.GetColorAt(1, 0)));\n                }\n            }\n        }\n    }\n}\n\npublic class ParticleSystemMain : MonoBehaviour\n{\n    public ParticleSystem[] emission;\n    public ParticleSystemShape[] shape;\n    public Renderer[] renderer;\n    public ColorOverLifetime[] colorOverLifetime;\n    \n    private void Start()\n    {\n        InitializeParticles();\n    }\n    \n    private void InitializeParticles()\n    {\n        if (emission == null || shape == null || renderer == null) return;\n        \n        for (int i = 0; i < emission.Length; i++)\n        {\n            var main = emission[i].main;\n            \n            // Emission\n            ParticleSystem.EmissionModule[] emitters = main.emitters;\n            if (emitters != null)\n            {\n                float rateOverTime = emission[i].rateOverTime;\n                float startLifetime = emission[i].startLifetime;\n                float startSize = emission[i].startSize;\n                float startSpeed = emission[i].startSpeed;\n                \n                for (int j = 0; j < emitters.Length; j++)\n                {\n                    ParticleSystem.EmissionModule module = emitters[j];\n                    if (module == null) continue;\n                    \n                    module.rateOverTime = rateOverTime;\n                    module.startLifetime = startLifetime;\n                    module.startSize = startSize;\n                    module.startSpeed = startSpeed;\n                }\n            }\n            \n            // Shape\n            ParticleSystem.ShapeModule[] shapes = main.shapes;\n            if (shapes != null)\n            {\n                for (int j = 0; j < shapes.Length; j++)\n                {\n                    ParticleSystem.ShapeData shapeData = shapes[j].data;\n                    if (shapeData == null) continue;\n                    \n                    shapeData.startLifetime = startLifetime;\n                    shapeData.startSize = startSize;\n                    shapeData.startSpeed = startSpeed;\n                }\n            }\n            \n            // Renderer\n            ParticleSystem.RendererModule[] renderers = main.renderers;\n            if (renderers != null)\n            {\n                for (int j = 0; j < renderers.Length; j++)\n                {\n                    ParticleSystem.RendererData rendererData = renderers[j].data;\n                    if (rendererData == null) continue;\n                    \n                    rendererData.startLifetime = startLifetime;\n                }\n            }\n            \n            // Color Over Lifetime\n            ParticleSystem.ColorOverLifetimeModule[] colorModules = main.colorOverLifetime;\n            if (colorModules != null)\n            {\n                for (int j = 0; j < colorModules.Length; j++)\n                {\n                    ParticleSystem.ColorOverLifetimeData colorData = colorModules[j].data;\n                    if (colorData == null) continue;\n                    \n                    float curveT1 = emission[i].startLifetime / _rippleDuration;\n                    float curveT2 = 1f;\n                    ColorOverLifetimeKey[] keys = colorData.keys;\n                    \n                    for (int k = 0; k < keys.Length; k++)\n                    {\n                        Color keyColor = colorData.GetColorAt(k, 0);\n                        AnimationCurve curve = keys[k].curve;\n                        \n                        if (curve != null)\n                        {\n                            float t1 = curveT1 * (1 - keys[k].weight);\n                            float t2 = curveT2 * (1 - keys[k].weight);\n                            \n                            curve.SetKey(0, new AnimationCurve.EaseInOut(t1, keyColor));\n                            curve.SetKey(1, new AnimationCurve.EaseInOut(t2, keyColor));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class ParticleSystemShapeData\n{\n    public float startLifetime;\n    public float startSize;\n    public float startSpeed;\n    public int maxParticles;\n    \n    [SerializeField] private ParticleSystemShape[] _shapes;\n    [SerializeField] private bool _useDefaultValues = true;\n    \n    public ParticleSystemShapeData()\n    {\n        if (_useDefaultValues)\n        {\n            InitializeDefaultValues();\n        }\n    }\n    \n    private void InitializeDefaultValues()\n    {\n        startLifetime = 0f;\n        startSize = 0.1f;\n        startSpeed = 5f;\n        maxParticles = Mathf.Max(100, (int)_shapes.Length * 50);\n    }\n}\n\npublic class ParticleSystemRenderData\n{\n    [SerializeField] private ParticleSystemRenderer[] _renderers;\n    [SerializeField] private bool _useDefaultValues = true;\n    \n    public ParticleSystemRenderData()\n    {\n        if (_useDefaultValues)\n        {\n            InitializeDefaultValues();\n        }\n    }\n    \n    private void InitializeDefaultValues()\n    {\n        // Default values can vary based on target platform\n    }\n}\n\npublic class ParticleSystemShapeModule\n{\n    [SerializeField] private ParticleSystem[] _emissionParticles;\n    [SerializeField] private ParticleSystemRenderer[] _rendererParticles;\n    [SerializeField] private ColorOverLifetime[] _colorOverLifetimeParticles;\n    \n    public ParticleSystem[] EmissionParticles => _emissionParticles;\n    public ParticleSystemRenderer[] RendererParticles => _rendererParticles;\n    public ColorOverLifetime[] ColorOverLifetimeParticles => _colorOverLifetimeParticles;\n}\n\npublic class ParticleSystemRendererModule\n{\n    [SerializeField] private ParticleSystemRenderer[] _shapeRenderers;\n    \n    public ParticleSystemRenderer[] ShapeRenderers => _shapeRenderers;\n}\n\npublic class ParticleSystemColorOverLifetimeModule\n{\n    [SerializeField] private ParticleSystemColorOverLifetime[] _colorModules;\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.GetIKRotation (0.65)",
      "AudioSource.PlayOnGamepad (0.64)",
      "AudioSource.GamepadSpeakerSupportsOutputType (0.64)",
      "Animator.SetIKRotation (0.64)",
      "Animator.PlayInFixedTime (0.63)",
      "GamepadSpeakerOutputType.Vibration (0.44)",
      "GamepadSpeakerOutputType.SecondaryVibration (0.43)",
      "GamepadSpeakerOutputType.Speaker (0.43)",
      "Terrain.SetKeepUnusedCameraRenderingResources (0.41)",
      "Terrain.GetKeepUnusedCameraRenderingResources (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SynthPad : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    public float baseFrequency = 220f;\n    public float pitchRange = 2f;\n    public float velocitySensitivity = 1.5f;\n    public float sustainDuration = 3f;\n    public float attackSpeed = 0.1f;\n    public float releaseSpeed = 0.05f;\n    \n    [Header(\"Visual Effects\")]\n    public GameObject[] rippleParticles;\n    public ParticleSystem rippleEffect;\n    public AudioSource audioSource;\n    public Renderer renderer;\n    public Material mat;\n    public Color baseColor = Color.white;\n    public Color glowColor = new Color(1f, 1f, 1f, 0.5f);\n    \n    [Header(\"Physics\")]\n    public float padHeight = 0.3f;\n    public LayerMask playerLayer = -1;\n    \n    private bool _isPlayerOnPad = false;\n    private bool _noteIsActive = false;\n    private Vector2 _playerPosition;\n    private float _currentPitch;\n    private float _sustainTimer;\n    private Color _originalColor;\n    private Color _targetGlowColor;\n    private float _originalGlowIntensity;\n    \n    void Start()\n    {\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        if (renderer != null && mat != null)\n        {\n            _originalColor = mat.color;\n            _originalGlowIntensity = mat.GetColor(0, 2).brightness;\n            _targetGlowColor = new Color(_originalGlowIntensity, glowColor.r, glowColor.g, glowColor.b);\n        }\n        \n        if (_rippleParticles != null)\n        {\n            foreach (var particle in _rippleParticles)\n                particle.SetActive(false);\n        }\n    }\n    \n    void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n        UpdateAudio();\n        UpdateVisuals();\n        UpdateRippleEffects();\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] hitColliders = Physics.OverlapBox(transform.position, new Vector3(0f, 0f, padHeight), playerLayer);\n        \n        foreach (var collider in hitColliders)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                _isPlayerOnPad = true;\n                _playerPosition = collider.transform.position;\n                break;\n            }\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_noteIsActive && _isPlayerOnPad)\n        {\n            float horizontal = Input.GetAxis(\"Horizontal\");\n            float vertical = Input.GetAxis(\"Vertical\");\n            \n            // Calculate pitch based on player position\n            Vector3 playerOffset = new Vector3(\n                Mathf.Clamp(horizontal * 0.5f - 1f, -pitchRange, pitchRange),\n                Mathf.Clamp(vertical * 0.5f - 1f, -pitchRange, pitchRange),\n                0f\n            );\n            \n            _currentPitch = baseFrequency + playerOffset.magnitude;\n        }\n        \n        if (!_noteIsActive && _isPlayerOnPad)\n        {\n            // Release note when player moves away from center\n            float distanceToCenter = Vector3.Distance(transform.position, _playerPosition);\n            if (distanceToCenter > 0.5f * padHeight)\n            {\n                _noteIsActive = false;\n                _sustainTimer = 0f;\n            }\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_isPlayerOnPad && _noteIsActive)\n        {\n            // Calculate velocity for volume\n            float velocity = Vector3.Distance(_playerPosition, transform.position);\n            float volume = Mathf.Clamp(velocity * velocitySensitivity / 2f, 0.1f, 1f);\n            \n            // Apply sustain envelope\n            _sustainTimer += Time.deltaTime;\n            if (_sustainTimer >= sustainDuration)\n                _noteIsActive = false;\n            else\n            {\n                float sustainValue = Mathf.Lerp(0f, volume, _sustainTimer / sustainDuration);\n                volume = Mathf.Clamp(sustainValue, 0.1f, 1f);\n            }\n            \n            // Calculate pitch envelope based on player movement\n            float horizontal = Input.GetAxis(\"Horizontal\");\n            float vertical = Input.GetAxis(\"Vertical\");\n            Vector3 offset = new Vector3(\n                Mathf.Clamp(horizontal * 0.5f - 1f, -pitchRange, pitchRange),\n                Mathf.Clamp(vertical * 0.5f - 1f, -pitchRange, pitchRange),\n                0f\n            );\n            \n            // Apply pitch curve (simple linear for now)\n            _currentPitch = baseFrequency + offset.magnitude;\n        }\n        \n        if (_noteIsActive)\n        {\n            PlayNote(_currentPitch, volume);\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (renderer != null && mat != null)\n        {\n            // Animate color based on pitch\n            float pitchMultiplier = _currentPitch / baseFrequency;\n            Color targetColor = new Color(\n                Mathf.Clamp01(pitchMultiplier),\n                0.5f,\n                Mathf.Clamp01(-pitchMultiplier + 1f),\n                0.7f\n            );\n            \n            mat.color = Color.Lerp(mat.color, targetColor, Time.deltaTime * 2f);\n        }\n        \n        // Animate glow based on pitch\n        if (_targetGlowColor != null)\n        {\n            float pitchIntensity = _currentPitch / baseFrequency;\n            Color currentGlow = new Color(\n                Mathf.Clamp01(pitchIntensity),\n                _targetGlowColor.r,\n                _targetGlowColor.g,\n                _targetGlowColor.b\n            );\n            \n            mat.GetColor(0, 2) = Color.Lerp(_originalGlowIntensity, currentGlow, Time.deltaTime * 3f);\n        }\n    }\n    \n    private void UpdateRippleEffects()\n    {\n        if (_rippleParticles != null)\n        {\n            foreach (var particle in _rippleParticles)\n            {\n                if (!_noteIsActive && particle.active)\n                {\n                    // Fade out ripple when note is released\n                    particle.SetActive(false);\n                }\n                else if (!particle.active)\n                {\n                    // Reactivate ripple when note starts\n                    particle.SetActive(true);\n                }\n            }\n        }\n        \n        if (_rippleEffect != null)\n        {\n            _rippleEffect.Play();\n        }\n    }\n    \n    private void PlayNote(float pitch, float volume)\n    {\n        if (audioSource == null) return;\n        \n        // Create simple sine wave audio\n        float[] samples = new float[100];\n        for (int i = 0; i < samples.Length; i++)\n        {\n            float time = i / (samples.Length - 1f);\n            samples[i] = Mathf.Sin(2 * Mathf.PI * pitch * time) * volume;\n        }\n        \n        audioSource.clip = null;\n        audioSource.PlayOneShot(samples, 44100);\n    }\n}",
    "per_behavior_docs": 15,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "generate_tone_on_contact": [
        "Rigidbody.AddForceAtPosition (0.67)",
        "Rigidbody.MoveRotation (0.67)",
        "Rigidbody.MovePosition (0.67)"
      ],
      "update_ripple_interaction": [
        "Physics.OverlapSphereNonAlloc (0.71)",
        "Physics.OverlapSphere (0.70)",
        "Physics.OverlapCapsuleNonAlloc (0.69)"
      ],
      "maintain_sustain": [
        "Animator.PlayInFixedTime (0.65)",
        "WaitTimeoutMode (0.64)",
        "DelayedAttribute (0.64)"
      ],
      "fade_tone_on_move": [
        "Transform.Translate (0.71)",
        "Transform.GetPositionAndRotation (0.69)",
        "Transform.SetPositionAndRotation (0.69)"
      ],
      "update_ripple_visuals": [
        "Animator.SetBoneLocalRotation (0.70)",
        "Animator.GetFloat (0.70)",
        "Animator.GetBoneTransform (0.70)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 3,
        "weighted_total": 46,
        "justification": "Direct translation lacks clear separation of concerns, with methods doing too much. Tries to handle multiple responsibilities in single methods, making code harder to understand and extend. Good use of Unity serialization and lifecycle methods, but overall structure is fragmented."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 68,
        "justification": "Strong modular design with clear separation of audio, visual, and interaction concerns. Extensive use of Unity patterns like serialized fields, trigger methods, and component-based architecture. Highly extensible with well-structured classes and methods that have clear, single responsibilities."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 61,
        "justification": "Good component-based approach with clear method separation. Breaks down behaviors into discrete methods, making code more readable. Slightly less structured than monolithic approach, but still maintains good Unity patterns and modularity."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the most robust, modular, and extensible implementation. It uses advanced Unity patterns, has clear method responsibilities, and provides the most flexible framework for future development.",
      "advantages": "Best balance of modularity, extensibility, and adherence to Unity design principles. Provides clear extension points, uses sophisticated serialization and configuration, and demonstrates a professional-grade approach to component design."
    },
    "error": null
  },
  {
    "prompt_num": 12,
    "prompt": "Build a wind chime cluster where each chime has a different pitch based on length, plays its note when collided with or when wind force is applied, creates subtle swaying animation, and produces harmonic overtones when multiple chimes ring simultaneously.",
    "timestamp": "2026-01-08T22:33:26.377165",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class WindChimeCluster : MonoBehaviour\n{\n    [Header(\"Wind Chime Settings\")]\n    [SerializeField] private float _minPitch = 20f;\n    [SerializeField] private float _maxPitch = 1000f;\n    [SerializeField] private int _chimeCount = 5;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _swaySpeed = 2f;\n    [SerializeField] private float _swayAmplitude = 0.3f;\n    [SerializeField] private LayerMask _windLayerMask = -1;\n    [SerializeField] private float _collisionForce = 5f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _chimeClips;\n    [SerializeField] private float _baseVolume = 0.8f;\n    [SerializeField] private float _pitchScale = 2f;\n    [SerializeField] private float _minPitchDuration = 0.1f;\n    [SerializeField] private float _maxPitchDuration = 0.5f;\n    \n    private AudioSource _audioSource;\n    private Transform[] _chimeTransforms;\n    private Rigidbody[] _rigbodies;\n    private Collider[] _colliders;\n    private Vector3[] _originalPositions;\n    private float[] _swayOffsets;\n    private int _currentChimeIndex = 0;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _chimeTransforms = new Transform[chimeCount];\n        _rigbodies = new Rigidbody[chimeCount];\n        _colliders = new Collider[chimeCount];\n        _originalPositions = new Vector3[chimeCount];\n        _swayOffsets = new float[chimeCount];\n        \n        GenerateChimes();\n        InitializeAudio();\n    }\n    \n    void Update()\n    {\n        AnimateSway();\n        CheckForWindForce();\n    }\n    \n    void FixedUpdate()\n    {\n        ApplyCollisionForce();\n    }\n    \n    void GenerateChimes()\n    {\n        for (int i = 0; i < chimeCount; i++)\n        {\n            Vector3 position = transform.position + new Vector3(\n                Mathf.Cos(i * 2f * Mathf.PI / chimeCount) * \n                (chimeCount - i - 1) * 2f,\n                0f, \n                Mathf.Sin(i * 2f * Mathf.PI / chimeCount) * \n                (chimeCount - i - 1) * 2f\n            );\n            \n            _originalPositions[i] = position;\n            _chimeTransforms[i] = new Transform(\n                GameObject.CreatePrimitive(PrimitiveType.Box),\n                position\n            );\n            \n            Rigidbody rb = _chimeTransforms[i].GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = _chimeTransforms[i].AddComponent<Rigidbody>();\n            }\n            _rigbodies[i] = rb;\n            \n            Collider col = _chimeTransforms[i].GetComponent<Collider>();\n            if (col != null)\n            {\n                col.isTrigger = true;\n                _colliders[i] = col;\n            }\n        }\n    }\n    \n    void InitializeAudio()\n    {\n        for (int i = 0; i < chimeCount; i++)\n        {\n            float pitch = CalculatePitch(i);\n            AudioClip clip = _chimeClips[i % _chimeClips.Length];\n            \n            if (clip == null)\n            {\n                Debug.LogWarning($\"No audio clip found for chime {i}\");\n                continue;\n            }\n            \n            _audioSource.clip = clip;\n            _audioSource.pitch = pitch / 1000f; // Normalize to 0-1 range\n            _audioSource.loop = true;\n            _audioSource.volume = _baseVolume;\n        }\n    }\n    \n    float CalculatePitch(int chimeIndex)\n    {\n        return Mathf.Lerp(_minPitch, _maxPitch, (chimeIndex + 1f) / chimeCount);\n    }\n    \n    void AnimateSway()\n    {\n        for (int i = 0; i < chimeCount; i++)\n        {\n            float targetAngle = -i * (2f * Mathf.PI / chimeCount) * Time.deltaTime;\n            _rigbodies[i].velocity = new Vector3(\n                Mathf.Cos(targetAngle) * _swaySpeed,\n                _swayOffsets[i] + 0.1f * Mathf.Sin(Time.time * 5f),\n                -Mathf.Sin(targetAngle) * _swaySpeed\n            );\n        }\n    }\n    \n    void CheckForWindForce()\n    {\n        if (_audioSource.isPlaying && !_windChimeIsPlaying(_currentChimeIndex))\n        {\n            PlayChime(_currentChimeIndex);\n        }\n    }\n    \n    void ApplyCollisionForce()\n    {\n        for (int i = 0; i < chimeCount; i++)\n        {\n            Collider col = _colliders[i];\n            Rigidbody rb = _rigbodies[i];\n            \n            if (col != null && rb != null)\n            {\n                Vector3 windDirection = Random.insideUnitSphere;\n                windDirection.y = 0f;\n                \n                // Apply random force in any direction\n                rb.AddForce(windDirection * _collisionForce, ForceMode.Impulse);\n                \n                // Check for collision triggers (should be set to trigger in GenerateChimes)\n            }\n        }\n    }\n    \n    bool _isPlaying = false;\n    void PlayChime(int chimeIndex)\n    {\n        if (_isPlaying && chimeIndex == _currentChimeIndex) return; // Avoid double play\n        \n        _audioSource.Play();\n        _isPlaying = true;\n        \n        int nextIndex = (chimeIndex + 1f % chimeCount);\n        StartCoroutine(WindChimeSequenceCoroutine(nextIndex));\n    }\n    \n    System.Collections.IEnumerator WindChimeSequenceCoroutine(int targetIndex)\n    {\n        while (_isPlaying && targetIndex != chimeIndex)\n        {\n            yield return new WaitForSeconds(0.3f);\n            targetIndex = (targetIndex + 1f % chimeCount);\n        }\n    }\n    \n    bool _windChimeIsPlaying = false;\n    void CheckForWindForce()\n    {\n        if (_audioSource.isPlaying && !_windChimeIsPlaying)\n        {\n            PlayChime(_currentChimeIndex);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        for (int i = 0; i < chimeCount; i++)\n        {\n            Vector3 position = transform.position + new Vector3(\n                Mathf.Cos(i * 2f * Mathf.PI / chimeCount) * \n                (chimeCount - i - 1) * 2f,\n                0f, \n                Mathf.Sin(i * 2f * Mathf.PI / chimeCount) * \n                (chimeCount - i - 1) * 2f\n            );\n            \n            Gizmos.DrawWireSphere(position, 0.5f);\n        }\n    }\n    \n    public void PlayChimeRandomly()\n    {\n        int randomIndex = Random.Range(0, chimeCount);\n        PlayChime(randomIndex);\n    }\n    \n    public void SetWindForceDirection(Vector3 direction)\n    {\n        ApplyCollisionForce();\n        \n        // Force only in the specified direction\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 force = direction.normalized * _collisionForce;\n            rb.AddForce(force, ForceMode.Impulse);\n        }\n    }\n    \n    public void SetWindChimeIndex(int index)\n    {\n        _currentChimeIndex = Mathf.Clamp(index, 0, chimeCount - 1);\n    }\n}",
    "ir_json": {
      "class_name": "WindChimeCluster",
      "components": [
        "Collider",
        "Animator"
      ],
      "fields": [
        {
          "name": "chimes",
          "type": "Transform[]",
          "default": null
        },
        {
          "name": "baseTone",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "swaySpeed",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "bobHeight",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "minPitchDiameter",
          "type": "float",
          "default": 0.3
        },
        {
          "name": "maxPitchDiameter",
          "type": "float",
          "default": 0.7
        },
        {
          "name": "pitchOffset",
          "type": "float",
          "default": 0.5
        }
      ],
      "behaviors": [
        {
          "name": "sway_chimes",
          "trigger": "every frame during active gameplay",
          "actions": [
            {
              "action": "rotate each chime slightly around vertical axis"
            },
            {
              "action": "apply random minor wobble movement to each chime"
            }
          ]
        },
        {
          "name": "play_pitch_on_collision",
          "trigger": "when any player or interactive object collides with cluster",
          "actions": [
            {
              "action": "play base tone sound for the shortest chime in collision"
            },
            {
              "action": "create subtle flash animation at impact point"
            }
          ]
        },
        {
          "name": "ring_chime_on_wind_impact",
          "trigger": "when wind force is applied to cluster and cluster is moving",
          "actions": [
            {
              "action": "play base tone for all chimes simultaneously"
            },
            {
              "action": "create gentle rattling animation on affected chimes"
            }
          ]
        },
        {
          "name": "harmonic_overtones",
          "trigger": "when multiple chimes are ringing at once and pitch frequencies match musical ratios",
          "actions": [
            {
              "action": "blend overlapping harmonious tones from all active chimes"
            },
            {
              "action": "add subtle vibrato effect to the combined sound"
            }
          ]
        },
        {
          "name": "pitch_variation_by_length",
          "trigger": "when cluster is being animated to change pitch",
          "actions": [
            {
              "action": "adjust pitch offset of each chime based on its size and animation curve"
            },
            {
              "action": "create rising or falling pitch sweep effect across cluster"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WindChimeCluster : MonoBehaviour\n{\n    [Header(\"Wind Chimes Configuration\")]\n    [SerializeField] private Transform[] _chimes;\n    [SerializeField] private float _swaySpeed = 2f;\n    [SerializeField] private float _bobHeight = 1.5f;\n    [SerializeField] private float _minPitchDiameter = 0.3f;\n    [SerializeField] private float _maxPitchDiameter = 0.7f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _baseToneClips;\n    [SerializeField] private float _pitchOffset = 0.5f;\n    [SerializeField] private float _minPitch = 30f;\n    [SerializeField] private float _maxPitch = 10000f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem[] _sparkleParticles;\n    [SerializeField] private GameObject _flashEffectPrefab;\n    [SerializeField] private float _flashDuration = 0.1f;\n    [SerializeField] private float _flashInterval = 2f;\n    \n    private List<Chime> _chimesList = new List<Chime>();\n    private AudioSource _audioSource;\n    private Collider _collider;\n    \n    [System.Serializable]\n    public class Chime\n    {\n        public Transform chimeTransform;\n        public float pitch;\n        public Vector3 currentPosition;\n        \n        public Chime(Transform transform)\n        {\n            chimeTransform = transform;\n            pitch = CalculatePitch(transform);\n            currentPosition = transform.position;\n        }\n        \n        private float CalculatePitch(Transform transform)\n        {\n            Vector3 directionToCenter = (transform.parent != null ? transform.parent.position : Vector3.zero) - transform.position;\n            float distanceToCenter = directionToCenter.magnitude;\n            \n            if (distanceToCenter <= 0.1f)\n                return _minPitch + Mathf.Abs(transform.eulerAngles.y);\n                \n            float pitchFactor = Mathf.Sqrt(distanceToCenter * _swaySpeed);\n            return _minPitch + pitchFactor;\n        }\n    }\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider>();\n        }\n        \n        SetupChimes();\n    }\n    \n    private void Start()\n    {\n        InvokeRepeating(\"SwayChimes\", 0f, _swaySpeed);\n        InvokeRepeating(\"SparkleParticles\", 1f, 2f);\n    }\n    \n    private void SetupChimes()\n    {\n        if (_chimes == null || _chimes.Length == 0) return;\n        \n        for (int i = 0; i < _chimes.Length; i++)\n        {\n            Chime chime = new Chime(_chimes[i]);\n            _chimesList.Add(chime);\n            \n            // Assign base tone clip\n            if (_baseToneClips != null && _baseToneClips.Length > 0)\n            {\n                int randomIndex = Random.Range(0, _baseToneClips.Length);\n                chime.chimeTransform.PlayAudio(_baseToneClips[randomIndex]);\n            }\n        }\n    }\n    \n    private void SwayChimes()\n    {\n        for (int i = 0; i < _chimesList.Count; i++)\n        {\n            Chime chime = _chimesList[i];\n            \n            // Apply sway movement\n            Vector3 swayDirection = new Vector3(\n                Mathf.Sin(Time.time * _swaySpeed) * 0.5f,\n                Mathf.Cos(Time.time * _swaySpeed) * 0.3f,\n                0f\n            );\n            chime.currentPosition += swayDirection;\n            \n            // Apply bob movement\n            float bobX = Mathf.Sin(Time.time * _bobHeight * 2f) * 0.5f;\n            float bobY = Mathf.Cos(Time.time * _bobHeight * 2f) * 0.3f;\n            chime.currentPosition += new Vector3(bobX, bobY, 0f);\n            \n            // Update transform position\n            chime.chimeTransform.position = chime.currentPosition;\n        }\n    }\n    \n    private void SparkleParticles()\n    {\n        for (int i = 0; i < _sparkleParticles.Length; i++)\n        {\n            if (_sparkleParticles[i] != null)\n            {\n                _sparkleParticles[i].Play();\n            }\n        }\n    }\n    \n    public void TriggerChime(int chimeIndex, bool forceUpdate = false)\n    {\n        Chime chime = _chimesList[chimeIndex];\n        \n        // Calculate new pitch based on position\n        Vector3 directionToCenter = (chime.chimeTransform.parent != null ? \n            chime.chimeTransform.parent.position : Vector3.zero) - chime.chimeTransform.position;\n        float distanceToCenter = directionToCenter.magnitude;\n        if (distanceToCenter <= 0.1f)\n        {\n            chime.pitch = _minPitch + Mathf.Abs(chime.chimeTransform.eulerAngles.y);\n        }\n        else\n        {\n            float pitchFactor = Mathf.Sqrt(distanceToCenter * _swaySpeed);\n            chime.pitch = _minPitch + pitchFactor;\n        }\n        \n        // Apply new pitch to audio clip\n        if (chime.chimeTransform != null)\n        {\n            chime.chimeTransform.PlayAudio(_baseToneClips[Random.Range(0, _baseToneClips.Length)]);\n            \n            // Update pitch offset for audio\n            float targetPitch = chime.pitch + _pitchOffset;\n            chime.chimeTransform.audio.clip.pitch = Mathf.Clamp(targetPitch / 10000f, _minPitch / 10000f, _maxPitch / 10000f);\n        }\n        \n        if (forceUpdate)\n        {\n            UpdateChimes();\n        }\n    }\n    \n    public void PlayWindImpact(int chimeIndex, float force = 1f)\n    {\n        Chime chime = _chimesList[chimeIndex];\n        \n        // Apply wind force to sway\n        Vector3 swayDirection = new Vector3(\n            Mathf.Sin(Time.time * force) * 0.5f,\n            Mathf.Cos(Time.time * force) * 0.3f,\n            0f\n        );\n        chime.currentPosition += swayDirection;\n        \n        // Play sound with pitch variation based on impact location\n        float distanceToCenter = (chime.chimeTransform.parent != null ? \n            chime.chimeTransform.parent.position : Vector3.zero) - chime.chimeTransform.position;\n        float distanceMagnitude = distanceToCenter.magnitude;\n        float pitchVariation = Mathf.Sqrt(distanceMagnitude * force);\n        \n        // Calculate target pitch\n        float basePitch = _minPitch + pitchVariation;\n        chime.pitch = basePitch + Mathf.Abs(chime.chimeTransform.eulerAngles.y);\n        \n        Vector3 impactPoint = chime.chimeTransform.position;\n        impactPoint += new Vector3(0f, 0.5f * force, 0f);\n        \n        // Play sparkle particles at impact point\n        if (_sparkleParticles != null && _flashEffectPrefab != null)\n        {\n            GameObject flashObj = Instantiate(_flashEffectPrefab, impactPoint + transform.up * 0.3f, Quaternion.identity);\n            \n            // Spawn sparkle particles around impact point\n            for (int j = 0; j < 5; j++)\n            {\n                Vector3 particlePos = impactPoint + new Vector3(\n                    Random.Range(-0.2f, 0.2f),\n                    Random.Range(0.1f, 0.4f),\n                    Random.Range(-0.1f, 0.1f)\n                );\n                GameObject spark = Instantiate(_sparkleParticles[i], particlePos, Quaternion.identity);\n            }\n        }\n        \n        // Play audio clip\n        if (_baseToneClips != null && _baseToneClips.Length > 0)\n        {\n            int randomIndex = Random.Range(0, _baseToneClips.Length);\n            chime.chimeTransform.PlayAudio(_baseToneClips[randomIndex]);\n            \n            // Apply pitch offset\n            float targetPitch = chime.pitch + _pitchOffset;\n            chime.chimeTransform.audio.clip.pitch = Mathf.Clamp(targetPitch / 10000f, _minPitch / 10000f, _maxPitch / 10000f);\n        }\n    }\n    \n    public void UpdateChimes()\n    {\n        for (int i = 0; i < _chimesList.Count; i++)\n        {\n            Chime chime = _chimesList[i];\n            \n            // Apply sway\n            Vector3 swayDirection = new Vector3(\n                Mathf.Sin(Time.time * _swaySpeed) * 0.5f,\n                Mathf.Cos(Time.time * _swaySpeed) * 0.3f,\n                0f\n            );\n            chime.currentPosition += swayDirection;\n            \n            // Apply bob\n            float bobX = Mathf.Sin(Time.time * _bobHeight * 2f) * 0.5f;\n            float bobY = Mathf.Cos(Time.time * _bobHeight * 2f) * 0.3f;\n            chime.currentPosition += new Vector3(bobX, bobY, 0f);\n            \n            // Update transform\n            chime.chimeTransform.position = chime.currentPosition;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_chimes == null || _chimes.Length == 0) return;\n        \n        Gizmos.color = Color.yellow;\n        for (int i = 0; i < _chimes.Length; i++)\n        {\n            Vector3 directionToCenter = (transform.parent != null ? transform.parent.position : Vector3.zero) - \n                _chimes[i].position;\n            float distanceToCenter = directionToCenter.magnitude;\n            \n            // Draw line from chime to center\n            if (distanceToCenter > 0.1f)\n            {\n                Gizmos.DrawLine(_chimes[i].position, _chimes[i].position + directionToCenter.normalized * 2f);\n            }\n        }\n        \n        Gizmos.color = Color.cyan;\n        for (int i = 0; i < _sparkleParticles.Length; i++)\n        {\n            if (_sparkleParticles[i] != null)\n            {\n                GameObject spark = _sparkleParticles[i].gameObject;\n                if (spark != null)\n                {\n                    Gizmos.DrawWireSphere(spark.transform.position, 0.05f);\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_audioSource == null) return;\n        \n        // Check for player interaction\n        if (other.CompareTag(\"Player\"))\n        {\n            PlayWindImpact(Random.Range(0, _chimes.Count));\n        }\n        \n        // Check for any object collision\n        else\n        {\n            PlayWindImpact(Random.Range(0, _chimes.Count));\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_flashEffectPrefab != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, 0.1f);\n            \n            // Draw flash effect indicator\n            GameObject flashObj = Instantiate(_flashEffectPrefab, transform.position, Quaternion.identity);\n            Gizmos.DrawLine(flashObj.transform.position, flashObj.transform.position + flashObj.transform.up * 0.3f);\n        }\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.GetIKRotation (0.65)",
      "Animation.AddClip (0.65)",
      "Animation.PlayQueued (0.65)",
      "Animation.GetClipCount (0.64)",
      "Animator.SetIKRotation (0.64)",
      "Animator.GetNextAnimationClipState (0.63)",
      "Animations.AnimatorControllerPlayable (0.43)",
      "Animations.AnimationClipPlayable (0.43)",
      "Animations.AnimationMixerPlayable (0.43)",
      "AnimationClip.AddEvent (0.43)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class WindChimeCluster : MonoBehaviour\n{\n    [Header(\"Chime Settings\")]\n    public int chimeCount = 5;\n    public float[] chimeLengths = {0.3f, 0.4f, 0.45f, 0.5f, 0.55f};\n    public float swaySpeed = 2f;\n    public float rotationSpeed = 30f;\n    \n    [Header(\"Audio Settings\")]\n    public AudioClip[] baseTones;\n    public float[] harmonicOvertones = {0.3f, 0.6f, 1.2f, 1.5f};\n    public float volume = 1f;\n    public float pitchMultiplier = 1f;\n    \n    [Header(\"Wind Detection\")]\n    public float windForceThreshold = 10f;\n    public LayerMask windLayer = -1;\n    private Rigidbody windRigidbody;\n    \n    [Header(\"Animation\")]\n    private Animator chimeAnimator;\n    private Vector3[] initialPositions;\n    private float[] initialRotationAngles;\n    private float[] targetRotationAngles;\n    private float[] swayOffsets;\n    \n    private void Start()\n    {\n        InitializeChimes();\n        SetupAudio();\n        windRigidbody = GetComponent<Rigidbody>();\n        chimeAnimator = GetComponent<Animator>();\n        \n        if (chimeCount > 0)\n        {\n            initialPositions = new Vector3[chimeCount];\n            initialRotationAngles = new float[chimeCount] {0f, 0f};\n            targetRotationAngles = new float[chimeCount] {0f, 0f};\n            swayOffsets = new float[chimeCount] {0f, 0f};\n        }\n    }\n    \n    private void InitializeChimes()\n    {\n        if (chimeCount == 0) return;\n        \n        for (int i = 0; i < chimeCount; i++)\n        {\n            Vector3 position = transform.position + chimeLengths[i] * Random.insideUnitSphere;\n            initialPositions[i] = position;\n            \n            // Create child GameObject with basic chime setup\n            GameObject chimeObj = new GameObject($\"Chime_{i}\");\n            chimeObj.transform.SetParent(transform);\n            chimeObj.transform.localPosition = Vector3.zero;\n            chimeObj.transform.localEulerAngles = new Vector3(0, 0, 0);\n            \n            // Add rigidbody for physics simulation\n            Rigidbody rb = chimeObj.AddComponent<Rigidbody>();\n            rb.velocity = transform.eulerAngles * 0.1f;\n            rb.angularVelocity = new Vector3(Random.Range(-10f, 10f), Random.Range(-5f, 5f), Random.Range(-10f, 10f));\n            \n            // Add audio source\n            AudioSource audioSource = chimeObj.AddComponent<AudioSource>();\n            audioSource.clip = baseTones[i % baseTones.Length];\n            audioSource.loop = true;\n            audioSource.volume = volume * pitchMultiplier;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (baseTones == null || baseTones.Length == 0) return;\n        \n        for (int i = 0; i < chimeCount; i++)\n        {\n            AudioSource audioSource = GetComponent<AudioSource>();\n            if (audioSource != null)\n            {\n                // Apply pitch scaling to the audio clip\n                float originalPitch = audioSource.clip.pitch;\n                audioSource.clip.pitch = Mathf.Lerp(originalPitch, originalPitch * 1.2f, harmonicOvertones[i]);\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        DetectWindAndApplyEffects();\n        AnimateChimes();\n    }\n    \n    private void DetectWindAndApplyEffects()\n    {\n        if (windRigidbody == null) return;\n        \n        float windStrength = 0f;\n        Vector3 windDirection = Vector3.zero;\n        \n        // Calculate wind strength from rigidbody velocity\n        foreach (Rigidbody rb in GetComponentsInChildren<Rigidbody>())\n        {\n            if (rb != windRigidbody)\n            {\n                windStrength += Mathf.Abs(rb.velocity.magnitude);\n                windDirection += rb.velocity.normalized;\n            }\n        }\n        \n        windStrength = Mathf.Max(0f, windStrength / chimeCount);\n        \n        // Apply random sway to each chime\n        for (int i = 0; i < chimeCount; i++)\n        {\n            float swayAmount = Random.Range(-swaySpeed * 0.5f, swaySpeed * 0.5f);\n            transform.position += new Vector3(\n                windDirection.x * windStrength,\n                swayAmount,\n                windDirection.z * windStrength\n            );\n            \n            // Add random rotation for visual variation\n            transform.Rotate(0, Random.Range(-10f, 10f), 0);\n        }\n        \n        // Check if wind force is above threshold\n        if (windStrength > windForceThreshold)\n        {\n            ApplyWindCollisionEffects();\n        }\n    }\n    \n    private void ApplyWindCollisionEffects()\n    {\n        for (int i = 0; i < chimeCount; i++)\n        {\n            Rigidbody rb = GetComponentInChildren<Rigidbody>();\n            if (rb != null)\n            {\n                // Add random force in different directions\n                Vector3 forceDirection = Random.insideUnitSphere.normalized;\n                float forceAmount = windStrength * 5f;\n                rb.AddForce(forceDirection * forceAmount, ForceMode.Impulse);\n                \n                // Apply random pitch modulation\n                rb.angularVelocity += new Vector3(\n                    Mathf.Sin(Time.time * 10f) * 2f,\n                    Mathf.Cos(Time.time * 8f) * 1.5f,\n                    Mathf.Sin(Time.time * 6f) * 1f\n                );\n            }\n        }\n    }\n    \n    private void AnimateChimes()\n    {\n        if (chimeAnimator == null || chimeCount <= 0) return;\n        \n        for (int i = 0; i < chimeCount; i++)\n        {\n            // Calculate target rotation angles based on length and sway\n            float angle = -90f * chimeLengths[i] * Random.Range(0.8f, 1.2f);\n            transform.localEulerAngles = new Vector3(\n                angle,\n                transform.localEulerAngles.y,\n                angle + 30f * Mathf.Sin(Time.time * 0.5f)\n            );\n            \n            // Update sway offsets\n            swayOffsets[i] += -swaySpeed * Random.Range(-0.5f, 0.5f);\n        }\n    }\n    \n    private void ApplyChimeNote(int chimeIndex)\n    {\n        AudioSource audioSource = GetComponent<AudioSource>();\n        if (audioSource == null) return;\n        \n        // Play base tone with pitch scaling\n        float originalPitch = audioSource.clip.pitch;\n        audioSource.clip.pitch = Mathf.Lerp(originalPitch, originalPitch * 1.2f, harmonicOvertones[chimeIndex % harmonicOvertones.Length]);\n        audioSource.Play();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (chimeCount == 0) return;\n        \n        Gizmos.color = Color.yellow;\n        for (int i = 0; i < chimeCount; i++)\n        {\n            Vector3 position = transform.position + chimeLengths[i] * Random.insideUnitSphere;\n            Gizmos.DrawWireSphere(position, 0.1f);\n            \n            // Draw visual indicator for each chime\n            GameObject chimeObj = new GameObject($\"Chime_{i}\");\n            chimeObj.transform.SetParent(transform);\n            chimeObj.transform.localPosition = Vector3.zero;\n            chimeObj.transform.localEulerAngles = new Vector3(0, 30f, 0);\n            \n            Renderer renderer = chimeObj.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Color indicatorColor = Color.cyan;\n                if (i % 2 == 0) indicatorColor = Color.green;\n                else indicatorColor = Color.red;\n                renderer.material.color = indicatorColor;\n            }\n        }\n    }\n}",
    "per_behavior_docs": 16,
    "per_behavior_methods": 6,
    "per_behavior_doc_names": {
      "play_chime_note": [
        "Collider.OnCollisionEnter (0.69)",
        "Collider.OnCollisionExit (0.68)",
        "Collider.OnCollisionStay (0.67)"
      ],
      "generate_harmonic_overtones": [
        "GameObject.InstantiateGameObjects (0.67)",
        "GameObjectUtility (0.65)",
        "GameObject.BroadcastMessage (0.64)"
      ],
      "sway_animation": [
        "Transform.GetPositionAndRotation (0.71)",
        "Quaternion.RotateTowards (0.71)",
        "Rigidbody.OnCollisionEnter (0.70)"
      ],
      "collision_detection": [
        "Animator.GetIKRotationWeight (0.63)",
        "Animation.IsPlaying (0.63)",
        "Animator.SetIKRotationWeight (0.63)"
      ],
      "wind_force_application": [
        "Physics.OverlapSphere (0.68)",
        "Physics.OverlapSphereNonAlloc (0.67)",
        "Physics.OverlapCapsuleNonAlloc (0.67)"
      ],
      "chime_spawn": [
        "GameObject.InstantiateGameObjects (0.70)",
        "GameObject.BroadcastMessage (0.69)",
        "GameObject.GetScene (0.67)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 3,
        "weighted_total": 51,
        "justification": "Direct translation lacks sophisticated architecture, has some Unity patterns but feels rushed. Modular methods exist but lack depth. Partial implementation shows potential but needs significant refinement."
      },
      "ir_monolithic": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 72,
        "justification": "Strong object-oriented design with nested Chime class, excellent use of serialized fields, clear separation of concerns. Complex initialization with robust error handling. Uses modern Unity patterns like InvokeRepeating and component-based design."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 4,
        "weighted_total": 58,
        "justification": "Decent method separation but less cohesive than monolithic approach. Good use of Unity lifecycle methods, but initialization feels more scattered. Attempts comprehensive design but lacks the elegant structure of IR Monolithic."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the most structured, extensible, and Unity-idiomatic implementation. It uses a nested Chime class for encapsulation, has clear serialization, and provides sophisticated pitch and positioning logic.",
      "advantages": "1) Clean, modular design 2) Excellent use of Unity serialization 3) Robust error handling 4) Clear extension points 5) More professional implementation of wind chime physics and audio dynamics"
    },
    "error": null
  },
  {
    "prompt_num": 13,
    "prompt": "Design a security laser grid: stepping on hidden pressure sensors activates red laser beams after 2-second warning alarm, touching any beam triggers lockdown mode with sirens and flashing lights, successfully crossing triggers green success chime and opens reward door, staying motionless for 5 seconds resets the entire system.",
    "timestamp": "2026-01-08T22:36:50.311492",
    "oneshot_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class LaserGridSystem : MonoBehaviour\n{\n    [Header(\"Laser Grid Settings\")]\n    [SerializeField] private int _gridWidth = 5;\n    [SerializeField] private int _gridHeight = 3;\n    [SerializeField] private float _laserDuration = 0.5f;\n    [SerializeField] private float _warningTime = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Laser Beam Settings\")]\n    [SerializeField] private LineRenderer[] _laserLines;\n    [SerializeField] private ParticleSystem[] _laserParticles;\n    [SerializeField] private AudioClip[] _warningSounds;\n    [SerializeField] private AudioClip[] _lockdownSounds;\n    [SerializeField] private AudioClip[] _successSounds;\n    \n    [Header(\"Pressure Sensor Settings\")]\n    [SerializeField] private GameObject[] _sensorObjects;\n    [SerializeField] private string _sensorTag = \"LaserSensor\";\n    [SerializeField] private float _sensorActivationRadius = 0.3f;\n    [SerializeField] private bool _requirePlayerInteraction = true;\n    \n    [Header(\"Lockdown Mode\")]\n    [SerializeField] private float _lockdownDuration = 10f;\n    [SerializeField] private AudioClip[] _sirenSounds;\n    [SerializeField] private GameObject _flashlightObject;\n    [SerializeField] private string _flashlightTag = \"Flashlight\";\n    \n    [Header(\"Success Zone\")]\n    [SerializeField] private GameObject[] _successObjects;\n    [SerializeField] private string _successTag = \"SuccessZone\";\n    [SerializeField] private float _successDuration = 3f;\n    \n    private List<LaserGrid> _laserGrids = new List<LaserGrid>();\n    private Dictionary<GameObject, bool> _sensorStates = new Dictionary<GameObject, bool>();\n    private Dictionary<GameObject, bool> _playerStates = new Dictionary<GameObject, bool>();\n    private Dictionary<GameObject, float> _lastCrossedTimes = new Dictionary<GameObject, float>();\n    \n    public enum LaserMode\n    {\n        Idle,\n        Warning,\n        Lockdown,\n        Success\n    }\n    \n    public LaserMode CurrentLaserMode { get; private set; }\n    \n    [System.Serializable]\n    public class LaserGrid\n    {\n        public Vector2Int gridPosition;\n        public float timeActive = 0f;\n        \n        public List<Vector2Int> activeCells = new List<Vector2Int>();\n        \n        public LaserGrid(Vector2Int pos)\n        {\n            gridPosition = pos;\n            activeCells.Clear();\n        }\n        \n        public void ActivateCell(Vector2Int cellPos)\n        {\n            if (!activeCells.Contains(cellPos))\n                activeCells.Add(cellPos);\n        }\n    }\n    \n    private class PressureSensor\n    {\n        public GameObject sensorObject;\n        public bool isActivated = false;\n        public float lastActivationTime = 0f;\n        \n        public void Activate()\n        {\n            if (sensorObject != null)\n            {\n                StartCoroutine(ActivateAfterDelay(sensorObject));\n            }\n        }\n        \n        private System.Collections.IEnumerator ActivateAfterDelay(GameObject target)\n        {\n            yield return new WaitForSeconds(0.1f);\n            Activate();\n        }\n    }\n    \n    private class FlashlightController\n    {\n        public GameObject flashlightObject;\n        public float currentFlashTime = 0f;\n        \n        public void StartFlash()\n        {\n            if (flashlightObject != null)\n            {\n                StartCoroutine(FlashSequence(flashlightObject));\n            }\n        }\n        \n        private System.Collections.IEnumerator FlashSequence(GameObject target)\n        {\n            while (currentFlashTime < _lockdownDuration)\n            {\n                currentFlashTime += 0.5f;\n                if (currentFlashTime >= 1f)\n                {\n                    target.SetActive(true);\n                    yield return new WaitForSeconds(0.2f);\n                    target.SetActive(false);\n                }\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeLaserGrids();\n        SetupSensors();\n        SetupFlashlight();\n        CurrentLaserMode = LaserMode.Idle;\n    }\n    \n    private void InitializeLaserGrids()\n    {\n        _laserGrids.Clear();\n        \n        for (int x = 0; x < _gridWidth; x++)\n        for (int y = 0; y < _gridHeight; y++)\n        {\n            Vector2Int pos = new Vector2Int(x, y);\n            LaserGrid grid = new LaserGrid(pos);\n            \n            if (_laserLines != null)\n                SetupLaserLineAtPosition(grid.gridPosition, x, y);\n                \n            _laserGrids.Add(grid);\n        }\n    }\n    \n    private void SetupLaserLineAtPosition(Vector2Int gridPos, int x, int y)\n    {\n        Vector3 start = new Vector3(gridPos.x * 10f, -gridHeight + (y + 1) * 10f, 0f);\n        Vector3 end = new Vector3((x + 1) * 10f, -gridHeight + (y + 1) * 10f, 0f);\n        \n        LineRenderer line = _laserLines[x * _gridWidth + y];\n        if (line != null)\n        {\n            line.SetPosition(0, start);\n            line.SetPosition(1, end);\n            \n            // Add visual effect\n            ParticleSystem particles = _laserParticles[x * _gridWidth + y];\n            if (particles != null)\n                particles.Play();\n        }\n    }\n    \n    private void SetupSensors()\n    {\n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null)\n            {\n                pressureSensor = sensor.AddComponent<PressureSensor>();\n                pressureSensor.sensorObject = sensor;\n            }\n            \n            _sensorStates[sensor] = false;\n        }\n    }\n    \n    private void SetupFlashlight()\n    {\n        flashlightObject = _flashlightObject;\n        flashlightController = flashlightObject.GetComponent<FlashlightController>();\n        \n        if (flashlightController == null)\n        {\n            flashlightController = flashlightObject.AddComponent<FlashlightController>();\n            flashlightController.flashlightObject = flashlightObject;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HandlePlayerEnter(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HandlePlayerLeave(other.gameObject);\n        }\n    }\n    \n    private void HandlePlayerEnter(GameObject player)\n    {\n        if (!_requirePlayerInteraction) return;\n        \n        // Check if player is in a laser grid\n        LaserGrid currentGrid = FindLaserGridAtPosition(player.transform.position);\n        if (currentGrid == null) return;\n        \n        // Update sensor states based on proximity\n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null) continue;\n            \n            float distanceToSensor = Vector3.Distance(transform.position, sensor.transform.position);\n            bool shouldActivate = distanceToSensor <= _sensorActivationRadius && !_playerStates[sensor];\n            \n            if (shouldActivate)\n            {\n                pressureSensor.Activate();\n                _playerStates[sensor] = true;\n                break;\n            }\n        }\n    }\n    \n    private void HandlePlayerLeave(GameObject player)\n    {\n        // Reset sensor states for all sensors\n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null) continue;\n            \n            _playerStates[sensor] = false;\n        }\n        \n        // Reset grid state based on player movement\n        LaserGrid currentGrid = FindLaserGridAtPosition(player.transform.position);\n        if (currentGrid != null)\n        {\n            foreach (Vector2Int pos in currentGrid.activeCells)\n            {\n                // Check if player was moving through this cell recently\n                Vector3 p1 = new Vector3(pos.x * 10f, -currentGrid.gridPosition.y + (pos.y + 1) * 10f, 0f);\n                Vector3 p2 = new Vector3((pos.x + 1) * 10f, -currentGrid.gridPosition.y + (pos.y + 1) * 10f, 0f);\n                \n                float distance1 = Vector3.Distance(player.transform.position, p1);\n                float distance2 = Vector3.Distance(player.transform.position, p2);\n                \n                if (distance1 < distance2)\n                {\n                    currentGrid.ActiveCell = pos;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private LaserGrid FindLaserGridAtPosition(Vector3 position)\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        for (int y = 0; y < _gridHeight; y++)\n        {\n            Vector2Int pos = new Vector2Int(x, y);\n            LaserGrid grid = _laserGrids[x * _gridWidth + y];\n            \n            if (grid != null)\n            {\n                float cellCenterX = pos.x * 10f;\n                float cellCenterY = -pos.y * 10f - 10f;\n                \n                Vector3 centerPoint = new Vector3(cellCenterX, cellCenterY, 0f);\n                float distance = Vector3.Distance(position, centerPoint);\n                \n                if (distance <= _sensorActivationRadius)\n                    return grid;\n            }\n        }\n        \n        return null;\n    }\n    \n    private void ActivateWarningLaser()\n    {\n        CurrentLaserMode = LaserMode.Warning;\n        \n        // Play warning sound\n        foreach (AudioClip clip in _warningSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, _flashlightObject.transform);\n            yield return new WaitForSeconds(0.3f);\n            break;\n        }\n        \n        // Start flashing\n        FlashlightController.StartFlash();\n    }\n    \n    private void ActivateLockdownLaser()\n    {\n        CurrentLaserMode = LaserMode.Lockdown;\n        \n        // Play lockdown sound\n        foreach (AudioClip clip in _sirenSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, _flashlightObject.transform);\n            yield return new WaitForSeconds(0.5f);\n            break;\n        }\n        \n        // Start flashing\n        FlashlightController.StartFlash();\n    }\n    \n    private void ActivateSuccessLaser()\n    {\n        CurrentLaserMode = LaserMode.Success;\n        \n        // Play success sound\n        foreach (AudioClip clip in _successSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, _flashlightObject.transform);\n            yield return new WaitForSeconds(0.3f);\n            break;\n        }\n        \n        // Start flashing\n        FlashlightController.StartFlash();\n    }\n    \n    private void ResetSystem()\n    {\n        CurrentLaserMode = LaserMode.Idle;\n        \n        // Reset all lasers\n        foreach (LineRenderer line in _laserLines)\n        {\n            if (line != null)\n                line.enabled = false;\n        }\n        \n        foreach (ParticleSystem particles in _laserParticles)\n        {\n            if (particles != null)\n                particles.Stop();\n        }\n        \n        // Reset sensors\n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null) continue;\n            \n            _playerStates[sensor] = false;\n            pressureSensor.sensorObject.SetActive(false);\n        }\n        \n        // Reset success zones\n        foreach (GameObject successObj in _successObjects)\n        {\n            if (!string.IsNullOrEmpty(successObj.tag))\n                GameObject taggedObj = GameObject.FindGameObjectWithTag(successObj.tag);\n            else\n                taggedObj = successObj;\n            \n            if (taggedObj != null && !taggedObj.active)\n                taggedObj.SetActive(true);\n        }\n        \n        // Reset flashlight\n        if (_flashlightObject != null)\n        {\n            _flashlightObject.SetActive(false);\n            FlashlightController.flashlightObject.SetActive(false);\n        }\n    }\n    \n    public void TriggerSensorActivation(Vector2Int gridPosition, bool activate = true)\n    {\n        LaserGrid currentGrid = FindLaserGridAtPosition(transform.position);\n        if (currentGrid == null) return;\n        \n        Vector2Int cellPos = new Vector2Int(gridPosition.x, gridPosition.y);\n        currentGrid.ActiveCell = cellPos;\n        \n        // Activate sensor at this position\n        GameObject targetSensor = GetNearestActiveSensor(gridPosition);\n        if (targetSensor != null)\n        {\n            pressureSensor = targetSensor.GetComponent<PressureSensor>();\n            if (pressureSensor != null)\n                pressureSensor.Activate();\n        }\n    }\n    \n    private GameObject GetNearestActiveSensor(Vector2Int gridPos)\n    {\n        float closestDistance = float.MaxValue;\n        GameObject nearestSensor = null;\n        \n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null) continue;\n            \n            Vector2Int sensorGridPos = new Vector2Int(sensor.transform.position.x / 10f, -sensor.transform.position.y / 10f);\n            float distance = Vector3.Distance(transform.position, GetCellCenter(gridPos));\n            \n            // Check if this sensor is already activated\n            bool isAlreadyActive = !string.IsNullOrEmpty(sensor.tag) \n                ? _playerStates[sensor] \n                : pressureSensor.isActivated;\n            \n            if (isAlreadyActive) continue;\n            \n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                nearestSensor = sensor;\n            }\n        }\n        \n        return nearestSensor;\n    }\n    \n    private float GetCellCenter(Vector2Int gridPos)\n    {\n        return new Vector3(gridPos.x * 10f, -gridPos.y * 10f - 10f, 0f);\n    }\n    \n    public void PlayerCrossesSuccessZone()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n        \n        // Find success zone\n        GameObject[] successObjects = _successObjects;\n        string successTag = _successTag;\n        GameObject taggedObj = null;\n        \n        foreach (GameObject obj in successObjects)\n        {\n            if (!string.IsNullOrEmpty(obj.tag))\n                taggedObj = GameObject.FindGameObjectWithTag(obj.tag);\n            else\n                taggedObj = obj;\n            \n            if (taggedObj != null && taggedObj.active)\n            {\n                float distance = Vector3.Distance(player.transform.position, taggedObj.transform.position);\n                if (distance <= 2f) // Success zone range\n                {\n                    PlaySuccessSound();\n                    StartSuccessSequence(taggedObj);\n                    return;\n                }\n            }\n        }\n    }\n    \n    private void PlaySuccessSound()\n    {\n        foreach (AudioClip clip in _successSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, _flashlightObject.transform);\n            yield return new WaitForSeconds(0.3f);\n            break;\n        }\n    }\n    \n    private void StartSuccessSequence(GameObject target)\n    {\n        CurrentLaserMode = LaserMode.Success;\n        \n        // Play success sound\n        foreach (AudioClip clip in _successSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, target.transform);\n            yield return new WaitForSeconds(0.3f);\n            break;\n        }\n        \n        // Start flashing\n        FlashlightController.StartFlash();\n    }\n    \n    private void HandleLockdown()\n    {\n        CurrentLaserMode = LaserMode.Lockdown;\n        \n        // Activate sirens\n        foreach (AudioClip clip in _sirenSounds)\n        {\n            AudioSource.PlayClipAtPoint(clip, _flashlightObject.transform);\n            yield return new WaitForSeconds(0.5f);\n            break;\n        }\n        \n        // Flashlight mode\n        if (_flashlightObject != null)\n        {\n            StartCoroutine(FlashSequence(_flashlightObject));\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashSequence(GameObject target)\n    {\n        while (FlashlightController.currentFlashTime < _lockdownDuration)\n        {\n            FlashlightController.currentFlashTime += 0.5f;\n            if (FlashlightController.currentFlashTime >= 1f)\n            {\n                target.SetActive(true);\n                yield return new WaitForSeconds(0.2f);\n                target.SetActive(false);\n            }\n        }\n    }\n    \n    public void ResetLaserMode()\n    {\n        CurrentLaserMode = LaserMode.Idle;\n        \n        // Turn off all lasers\n        foreach (LineRenderer line in _laserLines)\n        {\n            if (line != null)\n                line.enabled = false;\n        }\n        \n        foreach (ParticleSystem particles in _laserParticles)\n        {\n            if (particles != null)\n                particles.Stop();\n        }\n        \n        // Reset sensors\n        foreach (GameObject sensor in _sensorObjects)\n        {\n            pressureSensor = sensor.GetComponent<PressureSensor>();\n            if (pressureSensor == null) continue;\n            \n            _playerStates[sensor] = false;\n            pressureSensor.sensorObject.SetActive(false);\n        }\n    }\n    \n    public void ToggleLaserMode(LaserMode newMode)\n    {\n        if (_requirePlayerInteraction && !GameObject.FindGameObjectWithTag(\"Player\").active)\n            return;\n        \n        switch (newMode)\n        {\n            case LaserMode.Warning:\n                ActivateWarningLaser();\n                break;\n            case LaserMode.Lockdown:\n                ActivateLockdownLaser();\n                break;\n            case LaserMode.Success:\n                PlayerCrossesSuccessZone();\n                break;\n            default:\n                ResetSystem();\n                break;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        for (int x = 0; x < _gridWidth; x++)\n        for (int y = 0; y < _gridHeight; y++)\n        {\n            Vector2Int pos = new Vector2Int(x, y);\n            LaserGrid grid = _laserGrids[x * _gridWidth + y];\n            \n            if (grid != null)\n            {\n                float cellCenterX = pos.x * 10f;\n                float cellCenterY = -pos.y * 10f - 10f;\n                \n                Gizmos.DrawWireCube(cellCenterX, cellCenterY, 0.5f);\n                Gizmos.color = Color.red;\n                Gizmos.DrawRay(cellCenterX, cellCenterY + 1.5f, Vector3.forward * 2f);\n            }\n        }\n    }\n}",
    "ir_json": {
      "class_name": "SecurityLaserGrid",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem",
        "Light"
      ],
      "fields": [
        {
          "name": "gridSize",
          "type": "int",
          "default": 4
        },
        {
          "name": "sensorCount",
          "type": "int",
          "default": 9
        },
        {
          "name": "beamDuration",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "alertSoundClip",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "successSoundClip",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "alarmLoop",
          "type": "ParticleSystem",
          "default": null
        },
        {
          "name": "redLaserLight",
          "type": "Light",
          "default": null
        },
        {
          "name": "greenSuccessChime",
          "type": "AudioClip",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "detect_sensor_touch",
          "trigger": "player steps on pressure sensor with collider",
          "actions": [
            {
              "action": "start red laser beam from sensor location for beam duration"
            },
            {
              "action": "play alert sound clip"
            },
            {
              "action": "activate alarm loop particle system"
            }
          ]
        },
        {
          "name": "beam_alert_player",
          "trigger": "player collides with active red laser beam",
          "actions": [
            {
              "action": "start lockdown mode sequence"
            },
            {
              "action": "play continuous siren sound loop"
            },
            {
              "action": "activate flashing red lights around grid area"
            }
          ]
        },
        {
          "name": "lockdown_success_path",
          "trigger": "player successfully crosses from entry point to exit without triggering beams",
          "actions": [
            {
              "action": "play success sound clip"
            },
            {
              "action": "deactivate all laser beams in grid"
            },
            {
              "action": "stop alarm loop and siren sounds"
            }
          ]
        },
        {
          "name": "reset_grid_system",
          "trigger": "player stays motionless on grid for five seconds after last successful crossing or failure",
          "actions": [
            {
              "action": "deactivate all laser beams in grid"
            },
            {
              "action": "stop alarm loop and siren sounds"
            },
            {
              "action": "clear success chime audio"
            },
            {
              "action": "return red laser lights to standby position"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SecurityLaserGrid : MonoBehaviour\n{\n    [Header(\"Grid Settings\")]\n    [SerializeField] private int _gridWidth = 4;\n    [SerializeField] private int _gridHeight = 4;\n    [SerializeField] private float _beamDuration = 3f;\n    [SerializeField] private LayerMask _sensorLayerMask = -1;\n    \n    [Header(\"Laser Beam Components\")]\n    [SerializeField] private GameObject _laserBeamPrefab;\n    [SerializeField] private Transform _laserSpawnPoint;\n    [SerializeField] private LineRenderer _beamRenderer;\n    [SerializeField] private ParticleSystem _alarmParticles;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _alertSound;\n    [SerializeField] private AudioClip _successSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _laserLight;\n    [SerializeField] private ParticleSystem _flashParticles;\n    \n    private Dictionary<Collider, float> _sensorLastHitTime = new Dictionary<Collider, float>();\n    private bool _gridActive = true;\n    private int _currentBeams = 0;\n    private List<BeamData> _activeBeams = new List<BeamData>();\n    \n    [System.Serializable]\n    public class BeamData\n    {\n        public Transform startPoint;\n        public Vector3 direction;\n        public float duration;\n        public bool isActive;\n        public float timer;\n        \n        public BeamData(Transform sp, Vector3 dir, float dur)\n        {\n            startPoint = sp;\n            direction = dir;\n            duration = dur;\n            timer = 0f;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeGrid();\n        SetupAudio();\n        SetupVisualEffects();\n    }\n    \n    private void Update()\n    {\n        if (!_gridActive) return;\n        \n        CheckSensorStatus();\n        UpdateBeamVisuals();\n        CleanupOldBeams();\n    }\n    \n    private void InitializeGrid()\n    {\n        _activeSensors.Clear();\n        _currentBeams = 0;\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Transform gridPoint = GetGridPoint(x, y);\n                \n                if (!gridPoint.gameObject.activeInHierarchy) continue;\n                \n                Collider sensorCollider = gridPoint.GetComponent<Collider>();\n                if (_isSensorValid(sensorCollider))\n                {\n                    _activeSensors.Add(sensorCollider);\n                    CreateBeamAt(gridPoint.position);\n                }\n            }\n        }\n    }\n    \n    private Transform GetGridPoint(int x, int y)\n    {\n        float offsetX = (x - (_gridWidth / 2f)) * (1f / _gridWidth) * Screen.width;\n        float offsetY = -(y - (_gridHeight / 2f)) * (1f / _gridHeight) * Screen.height;\n        \n        return transform.position + new Vector3(offsetX, offsetY, 0f);\n    }\n    \n    private bool _isSensorValid(Collider sensor)\n    {\n        if (!sensor.CompareTag(\"SecuritySensor\")) return false;\n        \n        Rigidbody rb = sensor.GetComponent<Rigidbody>();\n        if (rb == null) return true;\n        \n        if (rb.bodyType != RigidbodyType2D.Static) return false;\n        \n        Collider[] collidersOnObject = sensor.gameObject.GetComponentsInChildren<Collider>();\n        foreach (Collider c in collidersOnObject)\n        {\n            if (!IsInSensorLayer(c.gameObject)) continue;\n            \n            Vector3 directionToC = (c.transform.position - sensor.transform.position).normalized;\n            float angle = Quaternion.Angle(sensor.transform.forward, directionToC);\n            \n            if (angle <= 45f) return false; // Too close to avoid overlap\n        }\n        \n        return true;\n    }\n    \n    private bool IsInSensorLayer(GameObject obj)\n    {\n        int layer = 1 << obj.layer;\n        return (_sensorLayerMask.value & layer) != 0;\n    }\n    \n    private void CheckSensorStatus()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Transform gridPoint = GetGridPoint(x, y);\n                \n                if (!gridPoint.gameObject.activeInHierarchy) continue;\n                \n                Collider sensorCollider = gridPoint.GetComponent<Collider>();\n                if (_isSensorValid(sensorCollider))\n                {\n                    _activeSensors.Remove(sensorCollider);\n                    CreateBeamAt(gridPoint.position);\n                }\n            }\n        }\n    }\n    \n    private void UpdateBeamVisuals()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Transform gridPoint = GetGridPoint(x, y);\n                \n                if (!gridPoint.gameObject.activeInHierarchy) continue;\n                \n                Collider sensorCollider = gridPoint.GetComponent<Collider>();\n                if (_isSensorValid(sensorCollider))\n                {\n                    CreateBeamAt(gridPoint.position);\n                }\n            }\n        }\n    }\n    \n    private void CleanupOldBeams()\n    {\n        List<BeamData> beamsToRemove = new List<BeamData>();\n        \n        foreach (BeamData beam in _activeBeams)\n        {\n            if (!beam.isActive || beam.timer <= 0f)\n            {\n                RemoveBeam(beam.startPoint);\n                beamsToRemove.Add(beam);\n            }\n        }\n        \n        foreach (BeamData beam in beamsToRemove)\n        {\n            _activeBeams.Remove(beam);\n        }\n    }\n    \n    private void CreateBeamAt(Vector3 startPos)\n    {\n        Vector3 direction = GetDirectionFromGrid(startPos);\n        BeamData newBeam = new BeamData(_laserSpawnPoint, direction, _beamDuration);\n        \n        if (_beamRenderer != null && !_beamRenderer.isPlaying)\n        {\n            _beamRenderer.SetPosition(0, startPos);\n            _currentBeams++;\n            _activeBeams.Add(newBeam);\n        }\n    }\n    \n    private Vector3 GetDirectionFromGrid(Vector3 startPos)\n    {\n        int x = (int)startPos.x / Screen.width;\n        int y = -(int)startPos.y / Screen.height;\n        \n        float angleX = Mathf.Atan2(x - _gridWidth / 2f, _gridHeight / 2f);\n        float angleY = Mathf.Atan2(y - _gridHeight / 2f, _gridWidth / 2f);\n        \n        return new Vector3(\n            Mathf.Cos(angleX) * Screen.width,\n            Mathf.Sin(angleY) * Screen.height\n        );\n    }\n    \n    private void CreateBeamAt(Transform beamStart)\n    {\n        LineRenderer beam = beamStart.GetComponent<LineRenderer>();\n        if (beam == null) return;\n        \n        Vector3 direction = GetDirectionFromGrid(beamStart.position);\n        float steps = Mathf.CeilToInt(direction.magnitude / 0.5f);\n        \n        for (int i = 1; i < steps; i++)\n        {\n            beam.SetPosition(i, beamStart.position + direction * i * 0.5f);\n        }\n        \n        beam.enabled = true;\n    }\n    \n    private void RemoveBeam(Transform beamStart)\n    {\n        LineRenderer beam = beamStart.GetComponent<LineRenderer>();\n        if (beam != null && beam.enabled)\n        {\n            beam.enabled = false;\n            _currentBeams--;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void SetupVisualEffects()\n    {\n        if (_flashParticles != null) _flashParticles.Stop();\n        if (_laserLight != null)\n        {\n            _laserLight.intensity = 2f;\n            _laserLight.color = Color.red;\n            _laserLight.enabled = false;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Transform gridPoint = GetGridPoint(x, y);\n                \n                if (!gridPoint.gameObject.activeInHierarchy) continue;\n                \n                Gizmos.DrawWireCube(gridPoint.position - Vector3.up * 1f, new Vector3(1f, 1f, 1f));\n            }\n        }\n    }\n    \n    public void TriggerSensor(Collider sensor)\n    {\n        _sensorLastHitTime[sensor] = Time.time + _beamDuration;\n        CreateBeamAt(sensor.transform.position);\n        \n        if (_audioSource != null && _alertSound != null)\n        {\n            _audioSource.PlayOneShot(_alertSound);\n        }\n        \n        if (_alarmParticles != null)\n        {\n            _alarmParticles.Play();\n        }\n    }\n    \n    public void TriggerSensorSuccess(Collider sensor, Transform exitPoint)\n    {\n        _sensorLastHitTime[sensor] = -1f;\n        \n        if (_audioSource != null && _successSound != null)\n        {\n            _audioSource.PlayOneShot(_successSound);\n        }\n        \n        if (_flashParticles != null)\n        {\n            _flashParticles.Play();\n        }\n        \n        // Check if player has crossed to exit point\n        if (Physics2D.Raycast(exitPoint.position, Vector3.right, out RaycastHit hit, 0.5f))\n        {\n            // Player successfully crossed grid\n            CleanupGrid();\n        }\n    }\n    \n    public void ResetGrid()\n    {\n        _gridActive = false;\n        CleanupGrid();\n        \n        if (_flashParticles != null) _flashParticles.Stop();\n        if (_laserLight != null) _laserLight.enabled = false;\n    }\n    \n    private void CleanupGrid()\n    {\n        List<BeamData> beamsToRemove = new List<BeamData>();\n        \n        foreach (BeamData beam in _activeBeams)\n        {\n            if (!beam.isActive || beam.timer <= 0f)\n            {\n                RemoveBeam(beam.startPoint);\n                beamsToRemove.Add(beam);\n            }\n        }\n        \n        foreach (BeamData beam in beamsToRemove)\n        {\n            _activeBeams.Remove(beam);\n        }\n        \n        _currentBeams = 0;\n    }\n    \n    private void OnApplicationQuit()\n    {\n        ResetGrid();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_gridActive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            // Player entered a beam area\n            TriggerSensor(other);\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (!_gridActive || !other.CompareTag(\"Player\")) return;\n        \n        // Player is staying in beam area\n        TriggerSensor(other);\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_gridActive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            // Player left beam area, check for successful path\n            Transform exitPoint = other.transform.position + Vector3.up * 2f;\n            TriggerSensorSuccess(other, exitPoint);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (!_gridActive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            // Player entered a beam area\n            TriggerSensor(other.gameObject.GetComponent<Collider>());\n        }\n    }\n    \n    private void OnTriggerStay2D(Collider2D other)\n    {\n        if (!_gridActive || !other.CompareTag(\"Player\")) return;\n        \n        // Player is staying in beam area\n        TriggerSensor(other.gameObject.GetComponent<Collider>());\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other, Vector3 direction)\n    {\n        if (!_gridActive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            // Player entered beam from specific direction\n            TriggerSensorSuccess(other.gameObject.GetComponent<Collider>(), other.transform.position + direction);\n        }\n    }\n    \n    private void OnMouseDown(Collider other)\n    {\n        if (_isSensorValid(other)) \n        {\n            CreateBeamAt(other.transform.position);\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Collider2D.CanContact (0.64)",
      "Collider.OnTriggerStay (0.63)",
      "Collider.OnTriggerEnter (0.63)",
      "Light.GetCommandBuffers (0.63)",
      "Collider2D.CreateMesh (0.63)",
      "Collider.OnTriggerExit (0.63)",
      "Light.RemoveCommandBuffers (0.62)",
      "Collider2D.ClosestPoint (0.62)",
      "Light.AddCommandBufferAsync (0.62)",
      "ParticleSystem.TriggerModule (0.62)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SecurityLaserGrid : MonoBehaviour\n{\n    [Header(\"Laser Grid Settings\")]\n    public int gridSize = 5;\n    public float gridSpacing = 3f;\n    public bool useRaycast = false;\n    \n    [Header(\"Sensor Components\")]\n    public GameObject[] sensors;\n    public AudioSource audioSource;\n    public Renderer[] laserRenderers;\n    public GameObject[] laserBeams;\n    public ParticleSystem alarmParticles;\n    \n    [Header(\"Laser Beam Behavior\")]\n    public float beamDuration = 10f;\n    public float beamCooldown = 5f;\n    public LayerMask beamLayerMask = -1;\n    public bool useGridLines = true;\n    public GameObject[] gridLines;\n    \n    [Header(\"Alarm System\")]\n    public AudioClip alarmSoundClip;\n    public float alarmVolume = 0.8f;\n    public float alarmPitch = 2f;\n    \n    private Vector3[] sensorPositions;\n    private Vector3[] beamStartPoints;\n    private bool[] isSensorActive;\n    private bool[] isBeamActive;\n    private float[] cooldownTimes;\n    private float nextBeamTime;\n    private bool lockdownActive = false;\n    private float lockdownStartTime;\n    private float lockdownEndTime;\n    \n    private void Start()\n    {\n        InitializeGrid();\n        SetupLaserBeams();\n        SetupAlarmSystem();\n    }\n    \n    private void InitializeGrid()\n    {\n        sensorPositions = new Vector3[gridSize * gridSize];\n        isSensorActive = new bool[gridSize * gridSize];\n        \n        // Create grid sensors\n        for (int x = 0; x < gridSize; x++)\n        {\n            for (int y = 0; y < gridSize; y++)\n            {\n                float px = (x - gridSize / 2f) * gridSpacing;\n                float py = (y - gridSize / 2f) * gridSpacing;\n                sensorPositions[x * gridSize + y] = new Vector3(px, py, 0);\n                isSensorActive[x * gridSize + y] = false;\n            }\n        }\n        \n        // Create grid line objects\n        if (gridLines == null)\n        {\n            GameObject[] tempGridLines = new GameObject[gridSize];\n            for (int i = 0; i < gridSize; i++)\n            {\n                GameObject gridLineObj = new GameObject($\"Grid Line {i}\");\n                Transform transform = gridLineObj.transform;\n                \n                // Create line segments\n                for (int j = 0; j < gridSize - 1; j++)\n                {\n                    Vector3 start = sensorPositions[i * gridSize + j];\n                    Vector3 end = sensorPositions[(i + 1) * gridSize + j];\n                    \n                    LineRenderer lineRenderer = gridLineObj.AddComponent<LineRenderer>();\n                    lineRenderer.positionCount = 2;\n                    lineRenderer.SetPosition(0, start);\n                    lineRenderer.SetPosition(1, end);\n                }\n                \n                tempGridLines[i] = gridLineObj;\n            }\n            gridLines = tempGridLines;\n        }\n    }\n    \n    private void SetupLaserBeams()\n    {\n        beamStartPoints = new Vector3[gridSize * gridSize];\n        cooldownTimes = new float[gridSize * gridSize];\n        \n        // Create laser beam objects\n        if (laserBeams == null)\n        {\n            GameObject[] tempBeams = new GameObject[(gridSize - 1) * gridSize];\n            for (int x = 0; x < gridSize - 1; x++)\n            {\n                for (int y = 0; y < gridSize - 1; y++)\n                {\n                    Vector3 beamStart = sensorPositions[x * gridSize + y];\n                    beamStartPoints[x * gridSize + y] = new Vector3(beamStart.x, beamStart.y, 0);\n                    \n                    GameObject beamObj = new GameObject($\"Beam {x}_{y}\");\n                    Transform transform = beamObj.transform;\n                    RayRenderer rayRenderer = beamObj.AddComponent<RayRenderer>();\n                    rayRenderer.positionCount = 2;\n                    rayRenderer.SetPosition(0, beamStartPoints[x * gridSize + y]);\n                    rayRenderer.SetPosition(1, beamStartPoints[(x + 1) * gridSize + y]);\n                }\n            }\n            laserBeams = tempBeams;\n        }\n        \n        // Create cooldown timers\n        for (int i = 0; i < beamStartPoints.Length; i++)\n        {\n            cooldownTimes[i] = beamCooldown;\n        }\n    }\n    \n    private void SetupAlarmSystem()\n    {\n        if (audioSource == null)\n        {\n            audioSource = GetComponent<AudioSource>();\n            if (audioSource == null)\n            {\n                audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (!string.IsNullOrEmpty(alarmSoundClip))\n        {\n            alarmSource.clip = alarmSoundClip;\n            alarmSource.loop = true;\n            alarmSource.volume = alarmVolume;\n            alarmSource.pitch = alarmPitch;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleSensorInputs();\n        UpdateLaserBeams();\n        CheckForLockdown();\n        ResetCooldowns();\n    }\n    \n    private void HandleSensorInputs()\n    {\n        for (int i = 0; i < sensorPositions.Length; i++)\n        {\n            if (!isSensorActive[i] && !lockdownActive)\n            {\n                // Check if player is touching this sensor\n                Collider playerCollider = GetComponent<Collider>();\n                if (playerCollider != null)\n                {\n                    Ray ray = new Ray(sensorPositions[i], playerCollider.transform.position - sensorPositions[i]);\n                    RaycastHit hit;\n                    if (Physics.Raycast(ray, out hit))\n                    {\n                        int hitSensorIndex = GetGridIndexFromPosition(hit.point);\n                        if (hitSensorIndex == i)\n                        {\n                            ActivateSensor(i);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    private void ActivateSensor(int sensorIndex)\n    {\n        isSensorActive[sensorIndex] = true;\n        \n        // Play alarm sound\n        if (audioSource != null && !lockdownActive)\n        {\n            audioSource.PlayOneShot(alarmSoundClip, 0.5f);\n        }\n        \n        // Flash grid line at sensor position\n        if (gridLines != null && gridLines.Length > sensorIndex)\n        {\n            GameObject gridLine = gridLines[sensorIndex];\n            if (gridLine != null)\n            {\n                LineRenderer lr = gridLine.GetComponent<LineRenderer>();\n                if (lr != null)\n                {\n                    lr.enabled = !lr.enabled;\n                }\n            }\n        }\n        \n        // Show laser beam at sensor\n        if (laserRenderers != null && sensorIndex < laserRenderers.Length)\n        {\n            LaserBeam laserBeam = laserRenderers[sensorIndex];\n            if (laserBeam != null)\n            {\n                laserBeam.enabled = true;\n            }\n        }\n    }\n    \n    private void UpdateLaserBeams()\n    {\n        for (int i = 0; i < beamStartPoints.Length; i++)\n        {\n            if (!isBeamActive[i] && !lockdownActive)\n            {\n                // Check cooldown\n                float cooldownTime = cooldownTimes[i];\n                if (cooldownTime <= 0f)\n                {\n                    ActivateBeam(i);\n                }\n            }\n        }\n    }\n    \n    private void ActivateBeam(int beamIndex)\n    {\n        isBeamActive[beamIndex] = true;\n        \n        // Update laser beam position\n        LaserBeam laserBeam = laserRenderers[beamIndex];\n        if (laserBeam != null)\n        {\n            Vector3 start = beamStartPoints[beamIndex];\n            Vector3 end = beamStartPoints[(beamIndex + 1) % beamStartPoints.Length];\n            laserBeam.enabled = true;\n            laserBeam.positionCount = 2;\n            laserBeam.SetPosition(0, start);\n            laserBeam.SetPosition(1, end);\n        }\n        \n        // Flash grid line at beam position\n        int beamGridX = beamIndex / gridSize;\n        int beamGridY = beamIndex % gridSize;\n        if (beamGridX >= 0 && beamGridX < gridLines.Length)\n        {\n            GameObject gridLineObj = gridLines[beamGridX];\n            if (gridLineObj != null)\n            {\n                LineRenderer lr = gridLineObj.GetComponent<LineRenderer>();\n                if (lr != null)\n                {\n                    lr.enabled = !lr.enabled;\n                }\n            }\n        }\n    }\n    \n    private int GetGridIndexFromPosition(Vector3 position)\n    {\n        float px = Mathf.RoundToInt(position.x / gridSpacing);\n        float py = Mathf.RoundToInt(position.y / gridSpacing);\n        \n        if (px < 0 || px >= gridSize || py < 0 || py >= gridSize)\n        {\n            return -1;\n        }\n        \n        int xIndex = px + (gridSize - 1) * gridSize;\n        int yIndex = py * gridSize;\n        return xIndex + yIndex;\n    }\n    \n    private void CheckForLockdown()\n    {\n        for (int i = 0; i < beamStartPoints.Length; i++)\n        {\n            if (!isBeamActive[i] && !lockdownActive)\n            {\n                // Check if player is touching the laser beam\n                Collider playerCollider = GetComponent<Collider>();\n                if (playerCollider != null)\n                {\n                    Ray ray = new Ray(beamStartPoints[i], playerCollider.transform.position - beamStartPoints[i]);\n                    RaycastHit hit;\n                    if (Physics.Raycast(ray, out hit))\n                    {\n                        int hitBeamIndex = GetBeamIndexFromPosition(hit.point);\n                        if (hitBeamIndex >= 0 && !isBeamActive[hitBeamIndex])\n                        {\n                            TriggerLockdown();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    private void TriggerLockdown()\n    {\n        lockdownActive = true;\n        lockdownStartTime = Time.time;\n        \n        // Start flashing lights\n        if (audioSource != null)\n        {\n            alarmSoundClip = alarmSoundClip?.clip;\n            if (alarmSoundClip != null && !lockdownActive)\n            {\n                audioSource.pitch = alarmPitch;\n                audioSource.loop = true;\n                audioSource.volume = alarmVolume;\n                audioSource.Play();\n            }\n        }\n        \n        // Start continuous siren\n        AudioSource sirenSource = gameObject.AddComponent<AudioSource>();\n        sirenSource.clip = CreateSirenSound();\n        sirenSource.loop = true;\n        sirenSource.pitch = 0.5f;\n        sirenSource.volume = 1f;\n        \n        // Disable player movement\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.freezeRotation = true;\n        }\n    }\n    \n    private AudioSource CreateSirenSound()\n    {\n        AudioClip[] possibleSounds = new AudioClip[]\n        {\n            AudioClip-assets[\"Alarm_Siren_1\"],\n            AudioClip-assets[\"Alarm_Siren_2\"],\n            AudioClip-assets[\"Alarm_Siren_3\"]\n        };\n        \n        for (int i = 0; i < possibleSounds.Length; i++)\n        {\n            if (!string.IsNullOrEmpty(possibleSounds[i].name))\n            {\n                return possibleSounds[i];\n            }\n        }\n        \n        // Fallback to built-in alarm sound\n        AudioSource audioSource = gameObject.AddComponent<AudioSource>();\n        audioSource.clip = AudioClip-assets[\"Alarm\"];\n        audioSource.loop = true;\n        audioSource.volume = 1f;\n        audioSource.pitch = 0.5f;\n        return audioSource;\n    }\n    \n    private void ResetCooldowns()\n    {\n        for (int i = 0; i < beamStartPoints.Length; i++)\n        {\n            cooldownTimes[i] -= Time.deltaTime;\n        }\n        \n        // Check if any beams should be ready to fire\n        for (int i = 0; i < beamStartPoints.Length; i++)\n        {\n            if (!isBeamActive[i])\n            {\n                float cooldownTime = cooldownTimes[i];\n                if (cooldownTime <= 0f)\n                {\n                    ActivateBeam(i);\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw grid lines for visualization\n        if (gridLines != null)\n        {\n            Gizmos.color = Color.yellow;\n            foreach (GameObject gridLineObj in gridLines)\n            {\n                LineRenderer lr = gridLineObj.GetComponent<LineRenderer>();\n                if (lr != null)\n                {\n                    lr.enabled = true;\n                }\n            }\n        }\n    }\n    \n    private void OnApplicationQuit()\n    {\n        // Clean up audio sources\n        if (audioSource != null && !lockdownActive)\n        {\n            StopAllSounds();\n        }\n    }\n}",
    "per_behavior_docs": 12,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "detect_sensor_touch": [
        "ResolutionDialogSetting (0.60)",
        "CollisionDetectionMode (0.58)",
        "PlayerPrefsException (0.57)"
      ],
      "trigger_lockdown": [
        "LightShadowCasterMode (0.65)",
        "Transform.SetPositionAndRotation (0.64)",
        "Transform.GetPositionAndRotation (0.63)"
      ],
      "maintain_laser_state": [
        "Transform.GetLocalPositionAndRotation (0.64)",
        "Transform.GetPositionAndRotation (0.63)",
        "Transform.SetLocalPositionAndRotation (0.63)"
      ],
      "unlock_after_success": [
        "MixedLightingMode (0.66)",
        "Light.Reset (0.65)",
        "Light.SetLightDirty (0.65)"
      ],
      "reset_laser_system": [
        "Light.Reset (0.70)",
        "Light.SetLightDirty (0.66)",
        "Light.AddCommandBufferAsync (0.63)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 51,
        "justification": "Good initial structure with enum and multiple helper classes, but lacks clear implementation of core behaviors. Over-complicated with multiple dictionaries and nested classes that reduce readability."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 67,
        "justification": "Strong Unity-specific patterns, well-organized serialized fields, clear method separation. Demonstrates good grid initialization and modular design with extension points."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 69,
        "justification": "Excellent modular design with clear initialization methods, robust grid setup, and flexible component configuration. Slightly more complex but provides clean separation of concerns."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The IR Per-Behavior approach provides the most flexible, readable, and extensible implementation, with clear method responsibilities and comprehensive grid management.",
      "advantages": "Clean separation of grid initialization, beam setup, and alarm systems; easy to understand and modify; follows Unity best practices with serialized fields and modular design"
    },
    "error": null
  },
  {
    "prompt_num": 14,
    "prompt": "Create a rhythm game target that spawns arrows pointing in random directions, plays a beat sound when spawned, awards points only if hit from the matching direction within the beat window, chains consecutive successes with increasing score multipliers and intensifying visual feedback, and resets multiplier on miss with disappointed sound.",
    "timestamp": "2026-01-08T22:42:26.158203",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class RhythmGameTarget : MonoBehaviour\n{\n    [Header(\"Target Settings\")]\n    [SerializeField] private int _spawnInterval = 1f;\n    [SerializeField] private float _beatWindow = 0.3f;\n    [SerializeField] private bool _resetOnHit = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _targetPrefab;\n    [SerializeField] private Transform _hitPoint;\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private float _rotationSpeed = 360f;\n    \n    [Header(\"Score System\")]\n    [SerializeField] private int _basePoints = 50;\n    [SerializeField] private int _maxMultiplier = 10;\n    [SerializeField] private float _multiplierIncreasePerSuccess = 0.1f;\n    [SerializeField] private float _multiplierDecayRate = 0.9f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _spawnSound;\n    [SerializeField] private AudioClip _missSound;\n    [SerializeField] private AudioClip _successSound;\n    [SerializeField] private float _volume = 1f;\n    \n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private bool _isPlaying = false;\n    private int _currentMultiplier = 1;\n    private int _lastSpawnTime;\n    private Queue<Collider> _targetQueue = new Queue<Collider>();\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _volume;\n        _audioSource.playOnAwake = false;\n        \n        StartCoroutine(SpawnTargetCoroutine());\n    }\n    \n    private IEnumerator SpawnTargetCoroutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_spawnInterval);\n            \n            if (_isPlaying) continue;\n            \n            SpawnTarget();\n            _lastSpawnTime = Time.time;\n            _isPlaying = true;\n        }\n    }\n    \n    private void SpawnTarget()\n    {\n        GameObject target = Instantiate(_targetPrefab, transform.position, Quaternion.identity);\n        \n        Collider collider = target.GetComponent<Collider>();\n        if (collider == null)\n        {\n            collider = target.AddComponent<SphereCollider>();\n            collider.isTrigger = true;\n        }\n        \n        // Position target at hit point\n        if (_hitPoint != null)\n        {\n            target.transform.SetParent(_hitPoint);\n            target.transform.localPosition = Vector3.zero;\n        }\n        \n        // Add rotation for visual feedback\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        // Play spawn sound\n        PlaySound(_spawnSound, _volume);\n        \n        // Start target queue\n        _targetQueue.Enqueue(collider);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isPlaying || _lastSpawnTime + _beatWindow <= Time.time)\n            return;\n            \n        CheckRhythmHit(other);\n    }\n    \n    private void CheckRhythmHit(Collider hitCollider)\n    {\n        // Determine target direction\n        Vector3 targetDirection = transform.forward;\n        \n        // Calculate angle between hit direction and target direction\n        float angle = Vector3.Angle(hitCollider.transform.forward, targetDirection);\n        \n        if (angle <= 30f) // Considered a match within rhythm window\n        {\n            GrantPoints(hitCollider);\n            \n            PlaySuccessSound();\n            OnTargetHit(hitCollider);\n            \n            _currentMultiplier *= MultiplierIncreasePerSuccess;\n            ClampMultiplier(_currentMultiplier);\n            \n            ResetMultiplierOnMiss(false);\n        }\n        else\n        {\n            MissTarget(hitCollider);\n            ResetMultiplierOnMiss(true);\n        }\n    }\n    \n    private void GrantPoints(Collider hitCollider)\n    {\n        int points = _basePoints * _currentMultiplier;\n        Debug.Log($\"Scored {points} points!\");\n        \n        // Add score to some global or player score\n        // Example: FindObjectOfType<ScoreManager>().AddScore(points);\n    }\n    \n    private void OnTargetHit(Collider hitCollider)\n    {\n        if (_hitEffect != null)\n            _hitEffect.Play();\n            \n        PlaySound(_hitSound, _volume * 1.5f);\n        \n        // Add additional visual feedback\n        // Example: Create glow effect at hit point\n        // GameObject light = new GameObject(\"Glow\");\n        // Light.transform.SetParent(_hitPoint);\n        // Light.AddComponent<Light>();\n        // light.intensity = 2f;\n    }\n    \n    private void MissTarget(Collider hitCollider)\n    {\n        PlayMissSound();\n        \n        // Add visual miss effect\n        // Example: Create explosion at hit point\n        // GameObject explosion = new GameObject(\"Explosion\");\n        // explosion.transform.SetParent(_hitPoint);\n        // Instantiate-explosionEffect here...\n    }\n    \n    private void ResetMultiplierOnMiss(bool wasSuccessful)\n    {\n        if (!wasSuccessful)\n        {\n            _currentMultiplier *= MultiplierDecayRate;\n            _currentMultiplier = Mathf.Max(1, _currentMultiplier);\n            \n            PlayMissSound();\n        }\n    }\n    \n    private void ResetTarget()\n    {\n        if (_hitEffect != null)\n            _hitEffect.Stop();\n        \n        transform.Rotate(0, 0, 360f);\n        \n        // Clean up visual effects\n        // Example: Destroy hit point object\n        // if (_hitPoint != null && _hitPoint.gameObject != gameObject)\n        //     _hitPoint.gameObject.SetActive(false);\n    }\n    \n    private void PlaySound(AudioClip clip, float volume = 1f)\n    {\n        if (_audioSource == null) return;\n        \n        _audioSource.clip = clip;\n        _audioSource.volume = Mathf.Clamp01(volume);\n        _audioSource.Play();\n    }\n    \n    private int ClampMultiplier(float multiplier)\n    {\n        multiplier = Mathf.Min(_maxMultiplier, multiplier);\n        multiplier = Mathf.Max(1f, multiplier);\n        return (int)Mathf.Round(multiplier * 1000f) / 1000f;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_isPlaying && _audioSource != null)\n            _audioSource.Stop();\n        \n        if (_hitEffect != null)\n            _hitEffect.Stop();\n    }\n}",
    "ir_json": {
      "class_name": "RhythmArrowTarget",
      "components": [
        "Collider",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "arrowPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "beatDuration",
          "type": "float",
          "default": 0.8
        },
        {
          "name": "baseScore",
          "type": "int",
          "default": 10
        },
        {
          "name": "chainCount",
          "type": "int",
          "default": 1
        },
        {
          "name": "currentMultiplier",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "targetDirection",
          "type": "Vector3",
          "default": null
        },
        {
          "name": "beatLoopTimer",
          "type": "float",
          "default": 0
        }
      ],
      "behaviors": [
        {
          "name": "spawn_rhythm_arrow",
          "trigger": "when rhythm note is played and arrow is requested",
          "actions": [
            {
              "action": "create arrow object",
              "value": "arrowPrefab"
            },
            {
              "action": "set arrow direction to target direction"
            },
            {
              "action": "play beat sound effect on arrow spawn"
            }
          ]
        },
        {
          "name": "assign_score_based_on_hit",
          "trigger": "when player shoots arrow at this target",
          "actions": [
            {
              "action": "check if arrow is within valid hit zone"
            },
            {
              "action": "verify arrow direction matches target direction within beat window"
            },
            {
              "action": "calculate score based on current multiplier and base score"
            },
            {
              "action": "play success sound effect"
            }
          ]
        },
        {
          "name": "update_chain_multiplier",
          "trigger": "when consecutive hits match correct directions",
          "actions": [
            {
              "action": "increment chain count if hit condition met"
            },
            {
              "action": "increase multiplier by small percentage (e.g., 5%) for each successful chain"
            },
            {
              "action": "apply increased score multiplier to next calculation"
            }
          ]
        },
        {
          "name": "handle_missed_hit",
          "trigger": "when arrow misses valid hit zone or direction is incorrect",
          "actions": [
            {
              "action": "play disappointed sound effect"
            },
            {
              "action": "reset current multiplier to base value"
            },
            {
              "action": "reset chain count to initial value"
            }
          ]
        },
        {
          "name": "update_visual_feedback",
          "trigger": "when arrow hits or misses the target",
          "actions": [
            {
              "action": "change arrow glow color based on hit status (green for hit, red for miss)"
            },
            {
              "action": "pulse arrow with rhythmic animation pattern"
            },
            {
              "action": "emit particle effects matching beat note energy"
            }
          ]
        },
        {
          "name": "reset_game_state",
          "trigger": "when game session restarts or new rhythm sequence begins",
          "actions": [
            {
              "action": "clear all arrows from target area"
            },
            {
              "action": "reset multiplier and chain count to base values"
            },
            {
              "action": "clear beat loop timer"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RhythmArrowTarget : MonoBehaviour\n{\n    [Header(\"Rhythm Arrow Settings\")]\n    [SerializeField] private GameObject _rhythmArrowPrefab;\n    [SerializeField] private float _beatDuration = 0.8f;\n    [SerializeField] private int _maxChainCount = 3;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _hitColor = Color.green;\n    [SerializeField] private Color _missColor = Color.red;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _missSound;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _arrowSpeed = 15f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    private Vector3[] _targetDirections = new Vector3[]\n    {\n        transform.forward,\n        -transform.forward,\n        transform.right,\n        -transform.right,\n        -transform.up,\n        transform.up,\n        transform.left,\n        -transform.left\n    };\n    \n    private int _currentChainCount = 0;\n    private float _currentTimer = 0f;\n    private bool _isPlayingArrow = false;\n    private Renderer _renderer;\n    private Material _material;\n    private Coroutine _beatCoroutine;\n    \n    private void Start()\n    {\n        InitializeVisuals();\n        SetupTargetDirections();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource != null && _hitSound != null)\n            _audioSource.clip = _hitSound;\n    }\n    \n    private void Update()\n    {\n        UpdateRhythmTimer();\n        CheckForArrowCollisions();\n        UpdateVisualFeedback();\n    }\n    \n    private void InitializeVisuals()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            Color originalColor = _material.color;\n            _material.color = originalColor;\n        }\n        \n        SetupBeatAnimation();\n    }\n    \n    private void SetupTargetDirections()\n    {\n        Vector3[] directions = new Vector3[8];\n        \n        // Define the eight possible arrow directions (front, back, left, right, up, down, and diagonals)\n        directions[0] = transform.forward;\n        directions[1] = -transform.forward;\n        directions[2] = transform.right;\n        directions[3] = -transform.right;\n        directions[4] = -transform.up;\n        directions[5] = transform.up;\n        directions[6] = transform.left;\n        directions[7] = -transform.left;\n        \n        _targetDirections = new Vector3[directions.Length];\n        for (int i = 0; i < directions.Length; i++)\n            _targetDirections[i] = directions[i].normalized;\n    }\n    \n    private void SetupBeatAnimation()\n    {\n        if (_renderer != null)\n        {\n            Color targetColor = _hitColor;\n            float animationValue = 0f;\n            \n            _material.intensity = _animationCurve.Evaluate(0f);\n            _material.color = _hitColor;\n            \n            StartCoroutine(BeatColorAnimation());\n        }\n    }\n    \n    private void UpdateRhythmTimer()\n    {\n        if (_isPlayingArrow)\n        {\n            _currentTimer -= Time.deltaTime * _arrowSpeed;\n            \n            if (_currentTimer <= 0f)\n            {\n                DestroyRhythmArrow();\n                _isPlayingArrow = false;\n            }\n        }\n    }\n    \n    private void CheckForArrowCollisions()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 0.5f, _playerLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                Vector3 arrowDirection = col.transform.forward;\n                \n                bool hit = IsArrowTargeted(arrowDirection);\n                \n                if (hit)\n                {\n                    PlayHitSound();\n                    UpdateScore(hit);\n                    ResetVisuals();\n                }\n                else\n                {\n                    PlayMissSound();\n                    ResetVisuals();\n                }\n            }\n        }\n    }\n    \n    private bool IsArrowTargeted(Vector3 playerDirection)\n    {\n        for (int i = 0; i < _targetDirections.Length; i++)\n        {\n            if (_targetDirections[i].dot(playerDirection) > 0.5f)\n                return true;\n        }\n        return false;\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void PlayMissSound()\n    {\n        if (_audioSource != null && _missSound != null)\n        {\n            _audioSource.PlayOneShot(_missSound);\n        }\n    }\n    \n    private void UpdateScore(bool hit)\n    {\n        int baseScore = 10;\n        \n        // Calculate score multiplier based on chain count\n        float multiplier = (float)Math.Pow(1 + (hit ? 0.5f : -0.3f), _currentChainCount);\n        multiplier = Mathf.Clamp(multiplier, 1f, 10f); // Cap at maximum multiplier\n        \n        int finalScore = Mathf.RoundToInt(baseScore * multiplier);\n        \n        Debug.Log($\"Hit: {finalScore} | Chain Count: {_currentChainCount}\");\n    }\n    \n    private void InitializeRhythmArrow()\n    {\n        GameObject arrow = Instantiate(_rhythmArrowPrefab, transform.position, Quaternion.identity);\n        \n        // Add simple arrow collider for demonstration\n        Rigidbody rb = arrow.AddComponent<Rigidbody>();\n        rb.velocity = _targetDirections[Random.Range(0, _targetDirections.Length)].normalized * _arrowSpeed;\n        \n        // Play beat sound effect on spawn\n        if (_audioSource != null && _hitSound != null)\n            _audioSource.PlayOneShot(_hitSound);\n    }\n    \n    private void DestroyRhythmArrow()\n    {\n        if (_renderer != null) _renderer.Stop();\n        StartCoroutine(DestroyArrowAfterDelay());\n    }\n    \n    private IEnumerator DestroyArrowAfterDelay()\n    {\n        yield return new WaitForSeconds(0.3f);\n        Destroy(gameObject);\n    }\n    \n    private IEnumerator BeatColorAnimation()\n    {\n        while (true)\n        {\n            float elapsedTime = Time.time % _beatDuration;\n            \n            if (_renderer != null)\n            {\n                Color targetColor = _hitColor;\n                float animationValue = 1f - Mathf.Abs(elapsedTime / _beatDuration);\n                \n                _material.color = targetColor;\n                _material.intensity = _animationCurve.Evaluate(animationValue);\n                \n                yield return new WaitForSeconds(_beatDuration);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            InitializeRhythmArrow();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            DestroyRhythmArrow();\n            _isPlayingArrow = false;\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 3,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.62)",
      "Animation.GetClipCount (0.61)",
      "Animation.IsPlaying (0.60)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RhythmArrowTarget : MonoBehaviour\n{\n    [Header(\"Rhythm Arrow Settings\")]\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private float _beatWindowDuration = 0.5f;\n    [SerializeField] private int _maxChainLevel = 3;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _missSound;\n    [SerializeField] private float _basePitchMultiplier = 1.2f;\n    [SerializeField] private float _maxPitchMultiplier = 3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hitParticles;\n    [SerializeField] private GameObject _hitEffectPrefab;\n    [SerializeField] private AudioClip[] _beatNotesArray;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _targetTransform;\n    [SerializeField] private GameObject _hit indicator;\n    [SerializeField] private GameObject _miss indicator;\n    \n    private Rigidbody _rigidbody;\n    private int _currentMultiplier = 1;\n    private float _lastHitTime = -1f;\n    private bool _isChainActive = false;\n    private float _nextArrowSpawnTime = 0f;\n    private float _baseBeatDuration = 0.3f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_targetTransform == null)\n            _targetTransform = transform;\n            \n        if (_hit indicator != null)\n            _hit indicator.SetActive(false);\n            \n        if (_miss indicator != null)\n            _miss indicator.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        SpawnNextArrow();\n        UpdateUI();\n        \n        if (Time.time >= _nextArrowSpawnTime && !_isChainActive)\n        {\n            _nextArrowSpawnTime = Time.time + Random.Range(0.1f, 0.3f);\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_targetTransform == null) return;\n        \n        // Check for arrow input\n        Collider[] colliders = Physics.OverlapSphere(_targetTransform.position, 0.5f, MaterialMask.GetMaterialMask(\"Collider\"));\n        foreach (var hitCollider in colliders)\n        {\n            if (hitCollider.CompareTag(\"RhythmArrow\"))\n            {\n                PlayArrowEffect(hitCollider);\n                break;\n            }\n        }\n    }\n    \n    private void SpawnNextArrow()\n    {\n        if (_arrowPrefab == null) return;\n        \n        Vector3 spawnPosition = _targetTransform.position + Random.insideUnitSphere * 0.5f;\n        Quaternion spawnRotation = Quaternion.Euler(0, -90, 0);\n        \n        GameObject arrow = Instantiate(_arrowPrefab, spawnPosition, spawnRotation);\n        \n        // Add arrow collider\n        Collider arrowCollider = arrow.GetComponent<Collider>();\n        if (arrowCollider == null)\n            arrowCollider = arrow.AddComponent<BoxCollider>();\n            \n        arrowCollider.isTrigger = true;\n        arrowCollider.bounds.size = new Vector3(0.5f, 0.1f, 0.5f);\n        \n        // Add audio source to arrow\n        AudioSource arrowAudioSource = arrow.GetComponent<AudioSource>();\n        if (arrowAudioSource == null)\n            arrowAudioSource = arrow.AddComponent<AudioSource>();\n            \n        // Play beat sound\n        float pitchMultiplier = _currentMultiplier * Random.Range(1f, 2f);\n        pitchMultiplier = Mathf.Clamp(pitchMultiplier, _basePitchMultiplier, _maxPitchMultiplier);\n        \n        arrowAudioSource.clip = _hitSound;\n        arrowAudioSource.pitch = pitchMultiplier;\n        arrowAudioSource.loop = true;\n        arrowAudioSource.volume = 0.8f * pitchMultiplier;\n        arrowAudioSource.Play();\n        \n        // Add hit indicator\n        GameObject hitIndicatorInstance = Instantiate(_hit indicator, spawnPosition + Vector3.up * 0.2f, Quaternion.identity);\n        if (hitIndicatorInstance != null)\n            hitIndicatorInstance.SetActive(true);\n    }\n    \n    private void PlayArrowEffect(RhythmArrow _arrow)\n    {\n        // Check for valid hit\n        bool isHit = IsValidHit(_arrow);\n        \n        // Apply hit or miss logic\n        if (isHit)\n        {\n            AwardHitPoints();\n            PlayHitAudio();\n            ShowHitEffects();\n            UpdateUI();\n        }\n        else\n        {\n            PlayMissAudio();\n            ShowMissEffects();\n        }\n    }\n    \n    private bool IsValidHit(RhythmArrow _arrow)\n    {\n        // Check if arrow is within beat window and direction matches player facing\n        float currentTime = Time.time;\n        return (currentTime - _lastHitTime) <= _beatWindowDuration &&\n               Vector3.Dot(_arrow.transform.forward, _targetTransform.forward) > 0.5f;\n    }\n    \n    private void AwardHitPoints()\n    {\n        // Increase multiplier and score\n        if (_currentMultiplier < _maxChainLevel)\n        {\n            _currentMultiplier++;\n            _isChainActive = true;\n            \n            // Add hit points based on chain level\n            int hitPoints = 10 * _currentMultiplier;\n            PlayBeatNote(hitPoints);\n        }\n    }\n    \n    private void PlayHitAudio()\n    {\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound, 0.8f);\n        }\n    }\n    \n    private void ShowHitEffects()\n    {\n        // Play hit particle effects\n        if (_hitParticles != null)\n            _hitParticles.Play();\n            \n        // Spawn hit effect\n        if (_hitEffectPrefab != null && _audioSource != null)\n        {\n            GameObject hitEffect = Instantiate(_hitEffectPrefab, transform.position + Vector3.up * 0.5f, Quaternion.identity);\n            Destroy(hitEffect, Random.Range(1f, 2f));\n        }\n    }\n    \n    private void PlayMissAudio()\n    {\n        if (_missSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_missSound, 0.5f);\n        }\n    }\n    \n    private void ShowMissEffects()\n    {\n        // Play miss particle effects\n        if (_hitParticles != null)\n            _hitParticles.Play();\n            \n        // Spawn miss effect\n        if (_hitEffectPrefab != null && _audioSource != null)\n        {\n            GameObject missEffect = Instantiate(_hitEffectPrefab, transform.position + Vector3.up * 1f, Quaternion.identity);\n            Destroy(missEffect, Random.Range(0.5f, 1.5f));\n        }\n    }\n    \n    private void PlayBeatNote(int hitPoints)\n    {\n        if (_beatNotesArray != null && _audioSource != null)\n        {\n            // Pick random note from beat notes array\n            int index = Random.Range(0, _beatNotesArray.Length);\n            if (index < _beatNotesArray.Length)\n            {\n                _audioSource.PlayOneShot(_beatNotesArray[index], 1f);\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        // Update hit indicator\n        if (_hit indicator != null)\n        {\n            bool shouldShow = !_isChainActive || Time.time >= _nextArrowSpawnTime;\n            _hit indicator.SetActive(shouldShow);\n        }\n        \n        // Update miss indicator (reset when chain is broken)\n        if (_miss indicator != null && !_isChainActive)\n            _miss indicator.SetActive(false);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        // Draw arrow hit zone\n        Vector3 forward = transform.forward;\n        float radius = 0.2f;\n        Gizmos.DrawWireCube(transform.position + forward * 0.5f, new Vector3(1f, 0.1f, 1f));\n        \n        // Draw beat window indicator\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position + Vector3.up * 0.2f, radius);\n    }\n}",
    "per_behavior_docs": 16,
    "per_behavior_methods": 6,
    "per_behavior_doc_names": {
      "spawn_rhythm_arrow": [
        "Random.Range (0.66)",
        "Random.InitState (0.66)",
        "Camera.CalculateProjectionMatrixFromPhysicalProperties (0.64)"
      ],
      "detect_hit": [
        "CollisionDetectionMode (0.61)",
        "CollisionDetectionMode2D (0.58)",
        "PlayerConnectionInitiateMode (0.58)"
      ],
      "award_hit_points": [
        "ParticleSystem.Play (0.74)",
        "ParticleSystem.GetPlaybackState (0.73)",
        "ParticleSystem.LightsModule (0.72)"
      ],
      "check_chain_success": [
        "Transform.GetLocalPositionAndRotation (0.66)",
        "Transform.SetLocalPositionAndRotation (0.66)",
        "Transform.GetPositionAndRotation (0.64)"
      ],
      "handle_miss": [
        "ParticleSystem.Play (0.70)",
        "ParticleSystem.ColorOverLifetimeModule (0.70)",
        "ParticleSystem.GetPlaybackState (0.69)"
      ],
      "reset_chain": [
        "MonoBehaviour.OnParticleUpdateJobScheduled (0.59)",
        "MonoBehaviour.FixedUpdate (0.59)",
        "Animator.PlayInFixedTime (0.59)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 5,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 3,
        "weighted_total": 48,
        "justification": "Direct translation lacks clear separation of concerns, with methods growing complex. Some good Unity patterns like serialized fields, but overall structure is monolithic and tightly coupled."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 69,
        "justification": "Strong use of Unity patterns, clean separation of visual/audio/gameplay concerns, good serialization, modular method design with clear responsibilities. Intermediate representation helps create more structured code."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 61,
        "justification": "More granular behavior decomposition than oneshot, but slightly less cohesive than monolithic approach. Good use of Unity patterns and modular design, but feels more fragmented."
      },
      "winner": "ir_monolithic",
      "key_differences": "Intermediate representation allows more structured code generation, with clear separation of concerns and better adherence to Unity component design patterns",
      "advantages": "The IR monolithic approach provides the best balance of modularity, Unity-specific patterns, and code readability while maintaining flexibility for future extensions"
    },
    "error": null
  },
  {
    "prompt_num": 15,
    "prompt": "Make a size-changing potion bottle that when collected shrinks the player to 25% scale over 2 seconds with cartoony squish animation and descending pitch sound, affects physics mass and jump height proportionally, shows timer UI counting down 20 seconds, then reverses with ascending pitch and stretch animation.",
    "timestamp": "2026-01-08T22:45:58.069335",
    "oneshot_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\n\npublic class PotionShrinkEffect : MonoBehaviour\n{\n    [Header(\"Potion Settings\")]\n    [SerializeField] private float _shrinkDuration = 2f;\n    [SerializeField] private float _restoreDuration = 3f;\n    [SerializeField] private AnimationCurve _shrinkCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private AnimationCurve _restoreCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 2f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _potionPrefab;\n    [SerializeField] private ParticleSystem _shrinkParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shrinkSound;\n    [SerializeField] private AudioClip _restoreSound;\n    [SerializeField] private float _particleScale = 0.1f;\n    [SerializeField] private Color _originalColor = Color.white;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _timerUI;\n    [SerializeField] private Text _timerText;\n    [SerializeField] private Image _progressImage;\n    \n    private Camera _playerCamera;\n    private Renderer _potionRenderer;\n    private Vector3 _originalPotionScale;\n    private float _shrinkProgress = 0f;\n    private bool _isShrinking = false;\n    private bool _hasRestored = false;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = GameObject.activeInHierarchy?.GetComponent<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        UpdateUI();\n        \n        if (_potionPrefab != null)\n        {\n            _originalPotionScale = _potionPrefab.transform.localScale;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleShrinkEffect();\n        HandleUIUpdate();\n        \n        if (!_isShrinking && !_hasRestored)\n        {\n            RestoreOriginalSize();\n        }\n    }\n    \n    private void HandleShrinkEffect()\n    {\n        if (_isShrinking)\n        {\n            _shrinkProgress += Time.deltaTime * 2f;\n            float currentScale = ShrinkCurve.Evaluate(_shrinkProgress);\n            \n            ApplyScale(currentScale);\n            \n            // Particle system\n            if (_shrinkParticles != null && !_hasRestored)\n                _shrinkParticles.transform.localScale = Vector3.one * (1f - currentScale) * _particleScale;\n            \n            // Audio\n            if (_audioSource != null && _shrinkSound != null)\n            {\n                float pitchMultiplier = 1f / currentScale;\n                pitchMultiplier = Mathf.Clamp01(pitchMultiplier);\n                _audioSource.pitch = pitchMultiplier;\n                _audioSource.PlayOneShot(_shrinkSound, 0.5f);\n            }\n            \n            // Color change\n            if (_potionRenderer != null)\n            {\n                Color originalColor = _originalPotionScale.x >= 0.01f ? _originalColor : _potionRenderer.material.color;\n                Color targetColor = new Color(originalColor.r, originalColor.g, originalColor.b * currentScale);\n                _potionRenderer.material.color = targetColor;\n            }\n        }\n    }\n    \n    private void ApplyScale(float scale)\n    {\n        if (_playerCamera == null) return;\n        \n        Vector3 scaleOffset = transform.position - _playerCamera.transform.position;\n        Vector3 scaledPosition = _playerCamera.transform.TransformPoint(scaleOffset + _originalPotionScale * 0.5f);\n        transform.position = scaledPosition;\n        \n        // Adjust mass and gravity scale for physics components\n        foreach (Component component in transform.GetComponentsInChildren<Rigidbody, IncludingSelf = false))\n        {\n            if (component != null)\n            {\n                component.mass = component.mass * scale;\n                component.gravityScale = component.gravityScale * scale;\n            }\n        }\n    }\n    \n    private void HandleUIUpdate()\n    {\n        if (_timerUI == null) return;\n        \n        UpdateTimerUI();\n    }\n    \n    private void UpdateTimerUI()\n    {\n        float currentTime = Time.time;\n        float progress = 1f - (currentTime / _shrinkDuration);\n        \n        int remainingTime = Mathf.CeilToInt(progress * _shrinkDuration);\n        \n        if (_timerText != null)\n            _timerText.text = remainingTime + \"s\";\n        \n        if (_progressImage != null && progress >= 0.01f)\n        {\n            Color progressColor = new Color(1f - progress, 0.3f, 0.7f);\n            _progressImage.color = progressColor;\n        }\n    }\n    \n    private void RestoreOriginalSize()\n    {\n        if (_hasRestored) return;\n        \n        _isShrinking = false;\n        _shrinkProgress = 0f;\n        _hasRestored = true;\n        \n        // Return to original position\n        Vector3 originalPosition = transform.position;\n        transform.position = originalPosition + (originalPosition - _playerCamera.transform.position);\n        \n        // Restore mass and gravity scale\n        foreach (Component component in transform.GetComponentsInChildren<Rigidbody, IncludingSelf = false))\n        {\n            if (component != null)\n            {\n                component.mass = _originalPotionScale.x >= 0.01f ? _originalPotionScale.x * component.mass : component.mass;\n                component.gravityScale = _originalPotionScale.x >= 0.01f ? component.gravityScale * _originalPotionScale.x : component.gravityScale;\n            }\n        }\n        \n        // Restore particle scale\n        if (_shrinkParticles != null)\n            _shrinkParticles.transform.localScale = Vector3.one;\n    }\n    \n    public void ActivateShrinkEffect()\n    {\n        if (!_isShrinking) \n        {\n            _isShrinking = true;\n            StartCoroutine(ShrinkCoroutine());\n        }\n    }\n    \n    private System.Collections.IEnumerator ShrinkCoroutine()\n    {\n        yield return new WaitForSeconds(_restoreDuration);\n        RestoreOriginalSize();\n    }\n    \n    public void DeactivateEffect()\n    {\n        if (_hasRestored) \n        {\n            _hasRestored = false;\n            StartCoroutine(RestoreCoroutine());\n        }\n    }\n    \n    private System.Collections.IEnumerator RestoreCoroutine()\n    {\n        yield return new WaitForSeconds(_restoreDuration);\n        RestoreOriginalSize();\n    }\n}",
    "ir_json": {
      "class_name": "SizeChangePotion",
      "components": [
        "Collider",
        "AudioSource",
        "Renderer"
      ],
      "fields": [
        {
          "name": "effectDuration",
          "type": "float",
          "default": 2
        },
        {
          "name": "scaleFactor",
          "type": "float",
          "default": 0.25
        },
        {
          "name": "massReductionMultiplier",
          "type": "float",
          "default": 0.625
        },
        {
          "name": "jumpHeightMultiplier",
          "type": "float",
          "default": 0.375
        },
        {
          "name": "pitchMultiplier",
          "type": "AudioVolume",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "collect_potion",
          "trigger": "when player touches this potion bottle",
          "actions": [
            {
              "action": "play squishy collect sound effect"
            },
            {
              "action": "start size change timer"
            },
            {
              "action": "enable scale change animation"
            },
            {
              "action": "set mass reduction multiplier to match new size"
            },
            {
              "action": "apply physics mass change"
            }
          ]
        },
        {
          "name": "trigger_size_change",
          "trigger": "when size change timer expires",
          "actions": [
            {
              "action": "scale player object to smaller size"
            },
            {
              "action": "reduce player jump force by jump height multiplier"
            },
            {
              "action": "set mass scale based on new size"
            },
            {
              "action": "play descending pitch sound effect"
            }
          ]
        },
        {
          "name": "show_timer_display",
          "trigger": "when potion is collected and timer starts",
          "actions": [
            {
              "action": "display countdown timer UI for 20 seconds"
            }
          ]
        },
        {
          "name": "reverse_size_change",
          "trigger": "when size change timer completes second half",
          "actions": [
            {
              "action": "scale player object back to normal size"
            },
            {
              "action": "restore original jump force"
            },
            {
              "action": "reset physics mass"
            }
          ]
        },
        {
          "name": "finish_potion_effect",
          "trigger": "when full size restoration is complete",
          "actions": [
            {
              "action": "play ascending pitch sound effect"
            },
            {
              "action": "play stretchy return animation"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Potion : MonoBehaviour\n{\n    [Header(\"Potion Settings\")]\n    [SerializeField] private float _effectDuration = 2f;\n    [SerializeField] private AnimationCurve _sizeShrinkCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private AnimationCurve _bobCurve = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 0.25f);\n    \n    [Header(\"Size Change\")]\n    [SerializeField] private float _originalScale;\n    [SerializeField] private bool _useOriginalMass = true;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _collectSounds;\n    [SerializeField] private float _volumeSweepAmount = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _popEffect;\n    [SerializeField] private GameObject _bubbleEffectPrefab;\n    [SerializeField] private float _bubbleDuration = 1f;\n    [SerializeField] private float _bubbleSpeed = 2f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private CanvasGroup _uiCanvasGroup;\n    [SerializeField] private GameObject _timerUI;\n    [SerializeField] private string _timerText = \"Collecting Potion...\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPotionCollected;\n    public UnityEvent<float> OnSizeChanged;\n    public UnityEvent OnBubbleStarted;\n    public UnityEvent OnBubbleEnded;\n    \n    private Renderer _renderer;\n    private Collider _collider;\n    private float _startScale;\n    private bool _isShrinking = false;\n    private int _originalMass = 0;\n    private Coroutine _effectCoroutine;\n    private float _bobTimer = 0f;\n    private float _bubbleTimer = 0f;\n    private GameObject _currentBubble;\n    \n    void Start()\n    {\n        InitializeComponents();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_uiCanvasGroup == null)\n            _uiCanvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_timerUI != null)\n            _timerUI.SetActive(false);\n    }\n    \n    void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource.clip = _collectSounds[Random.Range(0, _collectSounds.Length)];\n            _audioSource.volume = 1f;\n            _audioSource.Play();\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isShrinking)\n        {\n            StartPotionEffect(other);\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (_useOriginalMass && other.CompareTag(\"Player\"))\n        {\n            RestoreOriginalScale(other);\n        }\n    }\n    \n    void StartPotionEffect(Collider player)\n    {\n        _startScale = transform.localScale.x;\n        _originalScale = transform.localScale.x;\n        \n        // Save original mass\n        if (_useOriginalMass)\n        {\n            _originalMass = player.GetComponent<Rigidbody>().mass;\n        }\n        \n        // Set up affected layers\n        int layerMask = -1;\n        for (int i = 0; i < 32; i++)\n        {\n            if (!_affectedLayers.value.HasFlag(i))\n                layerMask |= 1 << i;\n        }\n        \n        _collider.isTrigger = true;\n        \n        // Start size shrink animation\n        StartCoroutine(ShrinkPotionEffect(player, layerMask));\n    }\n    \n    IEnumerator ShrinkPotionEffect(Collider player, int affectedLayerMask)\n    {\n        _isShrinking = true;\n        \n        float progress = 0f;\n        while (progress < 1f)\n        {\n            // Update scale based on animation curve\n            transform.localScale = Vector3.Lerp(transform.localScale, new Vector3(_startScale * _sizeShrinkCurve.Evaluate(progress)), \n                Time.deltaTime);\n            \n            // Animate bobbing effect\n            progress += _bobCurve.Evaluate(Time.time * 0.5f - 0.1f); // Offset for timing\n            if (progress >= 1f)\n            {\n                OnSizeChanged?.Invoke(_originalScale);\n                break;\n            }\n            \n            _bobTimer += Time.deltaTime * 2f;\n            float bobY = Mathf.Sin(_bobTimer) * 0.3f;\n            transform.position += Vector3.up * bobY * Time.deltaTime;\n            \n            // Bubble effect\n            if (_bubbleEffectPrefab != null)\n            {\n                CreateBubbleEffect();\n            }\n            \n            yield return new WaitForSeconds(Time.deltaTime);\n        }\n        \n        // Final bubble effects\n        if (_currentBubble != null)\n        {\n            Destroy(gameObject);\n        }\n        \n        OnSizeChanged?.Invoke(_originalScale);\n        OnBubbleEnded?.Invoke();\n    }\n    \n    void CreateBubbleEffect()\n    {\n        GameObject bubble = Instantiate(_bubbleEffectPrefab, transform.position, Quaternion.identity);\n        _currentBubble = bubble;\n        \n        // Add random movement\n        float randomX = Random.Range(-0.5f, 0.5f);\n        float randomY = Random.Range(-0.3f, 0.3f);\n        Vector3 randomDirection = new Vector3(randomX, randomY, 0.7f);\n        bubble.transform.position += randomDirection * Time.deltaTime;\n        bubble.transform.Rotate(0, 2f * Random.Range(0, 360), 0);\n        \n        // Spawn particles\n        ParticleSystem particleSystem = bubble.GetComponent<ParticleSystem>();\n        if (particleSystem != null)\n        {\n            particleSystem.Play();\n        }\n    }\n    \n    void RestoreOriginalScale(Collider player)\n    {\n        transform.localScale = Vector3.one;\n        \n        // Restore mass\n        Rigidbody rb = player.GetComponent<Rigidbody>();\n        if (rb != null && _useOriginalMass)\n        {\n            rb.mass = _originalMass;\n        }\n        \n        // Re-enable collider\n        _collider.isTrigger = false;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n        \n        if (_uiCanvasGroup != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, _uiCanvasGroup.bounds.extents);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _effectDuration = Mathf.Max(0.1f, _effectDuration);\n        _sizeShrinkCurve = AnimationCurve.EaseInOut;\n        _bobCurve = AnimationCurve.EaseInOut;\n        \n        if (_originalScale < 0.1f)\n            _originalScale = 0.1f;\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.64)",
      "Animation.GetClipCount (0.63)",
      "Animation.RemoveClip (0.63)",
      "Renderer.ResetBounds (0.62)",
      "Renderer.ResetLocalBounds (0.61)",
      "AnimationUpdateMode.Fixed (0.44)",
      "AnimationClip.EnsureQuaternionContinuity (0.44)",
      "AnimationUpdateMode.Normal (0.43)",
      "VideoClipImporter.GetResizeWidth (0.42)",
      "VideoClipImporter.GetResizeHeight (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class SizeChangingPotion : MonoBehaviour\n{\n    [Header(\"Potion Settings\")]\n    public float baseScale = 1f;\n    public float targetScale = 0.25f;\n    public float scaleDuration = 2f;\n    public AnimationCurve sizeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);\n    \n    [Header(\"Physics Settings\")]\n    public float originalMass = 1f;\n    public float currentMass = originalMass;\n    public float originalJumpForce = 5f;\n    private Rigidbody rb;\n    private AudioSource audioSource;\n    \n    [Header(\"Audio\")]\n    public AudioClip collectSound;\n    public AudioClip scaleDownSound;\n    public AudioClip restoreSound;\n    public AudioClip popSound;\n    \n    [Header(\"UI\")]\n    public GameObject sizeIndicator;\n    public Text timerText;\n    public Canvas canvas;\n    public CanvasGroup canvasGroup;\n    \n    private bool _isPotionActive = false;\n    private float _scaleTime = 0f;\n    private float _audioTimer = 0f;\n    private Coroutine _scaleCoroutine;\n    private Coroutine _restoreCoroutine;\n    \n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        audioSource = GetComponent<AudioSource>();\n        \n        if (sizeIndicator != null)\n            sizeIndicator.SetActive(false);\n            \n        if (timerText != null)\n            timerText.gameObject.SetActive(false);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!string.IsNullOrEmpty(collectSound.name) && other.CompareTag(\"Player\"))\n        {\n            PlayCollectSound();\n            ActivatePotion();\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (audioSource != null && collectSound != null)\n        {\n            audioSource.PlayOneShot(collectSound);\n        }\n    }\n    \n    public void ActivatePotion()\n    {\n        _isPotionActive = true;\n        \n        if (_scaleCoroutine != null)\n            StopCoroutine(_scaleCoroutine);\n            \n        if (sizeIndicator != null)\n            sizeIndicator.SetActive(true);\n            \n        if (timerText != null)\n            timerText.gameObject.SetActive(true);\n            \n        StartScaleAnimation();\n        StartAudioEffects();\n    }\n    \n    private void StartScaleAnimation()\n    {\n        _scaleTime = 0f;\n        _audioTimer = 0f;\n        \n        if (_scaleCoroutine == null)\n            _scaleCoroutine = StartCoroutine(ScaleToTargetSize());\n    }\n    \n    private void StartAudioEffects()\n    {\n        if (audioSource != null && scaleDownSound != null)\n            audioSource.PlayOneShot(scaleDownSound);\n            \n        if (canvasGroup != null && canvasGroup.gameObject.activeInHierarchy)\n            canvasGroup.volume = 0.5f;\n    }\n    \n    private IEnumerator ScaleToTargetSize()\n    {\n        float elapsedTime = 0f;\n        \n        while (_scaleTime < scaleDuration)\n        {\n            _scaleTime += Time.deltaTime * Time.timeScale;\n            \n            float curveValue = sizeCurve.Evaluate(_scaleTime / scaleDuration);\n            float currentScale = baseScale * curveValue;\n            \n            if (sizeIndicator != null)\n                sizeIndicator.localScale = new Vector3(currentScale, 1f, currentScale);\n            \n            UpdateUI();\n            \n            yield return new WaitForEndOfFrame();\n        }\n        \n        RestoreOriginalSize();\n    }\n    \n    private void UpdateUI()\n    {\n        if (timerText != null && _audioTimer < 1f)\n        {\n            float progress = _audioTimer / 1f;\n            timerText.text = $\"Potion: {_scaleTime:F0} sec\";\n            _audioTimer += Time.deltaTime * Time.timeScale;\n        }\n        else\n        {\n            timerText.gameObject.SetActive(false);\n        }\n    }\n    \n    private void RestoreOriginalSize()\n    {\n        if (_restoreCoroutine != null)\n            StopCoroutine(_restoreCoroutine);\n            \n        _isPotionActive = false;\n        \n        if (sizeIndicator != null)\n            sizeIndicator.SetActive(false);\n            \n        if (timerText != null)\n            timerText.gameObject.SetActive(false);\n            \n        StartRestoreAnimation();\n        PlayRestoreSound();\n    }\n    \n    private void StartRestoreAnimation()\n    {\n        _restoreCoroutine = StartCoroutine(RestoreOriginalSize());\n    }\n    \n    private void PlayRestoreSound()\n    {\n        if (audioSource != null && restoreSound != null)\n            audioSource.PlayOneShot(restoreSound);\n            \n        if (_scaleCoroutine != null)\n            _scaleCoroutine = null;\n    }\n    \n    private IEnumerator RestoreOriginalSize()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < scaleDuration * 2f)\n        {\n            elapsedTime += Time.deltaTime * Time.timeScale;\n            \n            float curveValue = sizeCurve.Evaluate((elapsedTime - scaleDuration) / (scaleDuration * 2f));\n            float currentScale = baseScale * curveValue;\n            \n            if (sizeIndicator != null)\n                sizeIndicator.localScale = new Vector3(currentScale, 1f, currentScale);\n            \n            UpdateUI();\n            \n            yield return new WaitForEndOfFrame();\n        }\n        \n        RestorePhysicsProperties();\n    }\n    \n    private void RestorePhysicsProperties()\n    {\n        if (rb != null)\n        {\n            rb.mass = originalMass;\n            rb.velocity = rb.velocity.normalized * originalJumpForce;\n        }\n        \n        if (_audioTimer >= 1f)\n        {\n            _audioTimer = 0f;\n            timerText.text = $\"Potion: {scaleDuration:F0} sec\";\n        }\n    }\n    \n    public void DeactivatePotion()\n    {\n        if (_isPotionActive && _scaleCoroutine != null)\n            StopCoroutine(_scaleCoroutine);\n            \n        if (_restoreCoroutine != null)\n            StopCoroutine(_restoreCoroutine);\n            \n        _isPotionActive = false;\n        \n        if (sizeIndicator != null)\n            sizeIndicator.SetActive(false);\n            \n        if (timerText != null)\n            timerText.gameObject.SetActive(false);\n    }\n    \n    public void ForceApplySize(float scale)\n    {\n        if (sizeIndicator != null)\n            sizeIndicator.localScale = new Vector3(scale, 1f, scale);\n        \n        UpdateUI();\n    }\n    \n    private void OnValidate()\n    {\n        baseScale = Mathf.Max(0.1f, baseScale);\n        targetScale = Mathf.Max(0.05f, targetScale);\n        scaleDuration = Mathf.Max(0.5f, scaleDuration);\n        originalMass = Mathf.Max(0.01f, originalMass);\n        originalJumpForce = Mathf.Max(0.1f, originalJumpForce);\n    }\n}",
    "per_behavior_docs": 11,
    "per_behavior_methods": 4,
    "per_behavior_doc_names": {
      "collect_potion": [
        "Transform.SetLocalPositionAndRotation (0.64)",
        "Animator.GetIKHintPositionWeight (0.64)",
        "Animation.PlayQueued (0.64)"
      ],
      "scale_downward": [
        "Animator.SetIKRotationWeight (0.74)",
        "Animator.SetFloat (0.73)",
        "Animator.SetIKPositionWeight (0.72)"
      ],
      "scale_upward": [
        "Animator.PlayInFixedTime (0.63)",
        "WaitTimeoutMode (0.63)",
        "Animator.CrossFadeInFixedTime (0.62)"
      ],
      "restore_original_size": [
        "Transform.GetLocalPositionAndRotation (0.65)",
        "FullScreenMovieScalingMode (0.65)",
        "Transform.SetLocalPositionAndRotation (0.65)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 3,
        "weighted_total": 53,
        "justification": "Direct translation lacks clear method separation, has some unnecessary complexity, but shows basic Unity understanding"
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 6,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 68,
        "justification": "Strong use of Unity events, modular design, good separation of concerns, multiple extension points"
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 75,
        "justification": "Most granular approach, clean method decomposition, excellent Unity pattern adherence, very maintainable"
      },
      "winner": "ir_per_behavior",
      "key_differences": "Per-behavior IR approach provides most modular, extensible implementation with clear method responsibilities and clean separation of concerns",
      "advantages": "Small, focused methods that are easy to understand, modify, and test; excellent use of coroutines and Unity lifecycle methods; clear serialized configuration points"
    },
    "error": null
  },
  {
    "prompt_num": 16,
    "prompt": "Create a shapeshifter enemy that morphs between sphere, cube, and pyramid forms every 4 seconds, with each form having different movement patterns (rolling, sliding, hopping), color schemes, and vulnerability windows indicated by brief glowing outlines.",
    "timestamp": "2026-01-08T22:48:33.530246",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class ShapeshifterEnemy : MonoBehaviour\n{\n    [Header(\"Shapeshifter Settings\")]\n    [SerializeField] private float _morphInterval = 4f;\n    [SerializeField] private int _totalMorphStates = 3;\n    [SerializeField] private string[] _morphNames = { \"Sphere\", \"Cube\", \"Pyramid\" };\n    \n    [Header(\"Movement Patterns\")]\n    [SerializeField] private float[] _movementSpeeds = { 2f, 1.5f, 3f };\n    [SerializeField] private float[] _rotationSpeeds = { 360f, 180f, 240f };\n    [SerializeField] private bool[] _moveInAllDirections = { true, false, true };\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Color Schemes\")]\n    [SerializeField] private Color[] _baseColors = { Color.white, Color.yellow, Color.red };\n    [SerializeField] private float[] _colorTransitionSpeeds = { 2f, 4f, 3f };\n    [SerializeField] private bool[] _pulseColors = { true, false, true };\n    \n    [Header(\"Vulnerability Windows\")]\n    [SerializeField] private float[] _vulnerabilityTimes = { 1.5f, 2f, 1f };\n    [SerializeField] private float _vulnerabilityDuration = 0.3f;\n    [SerializeField] private bool[] _showOutlineDuringVulnerability = { true, false, true };\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _morphSounds;\n    [SerializeField] private AudioClip[] _movementSounds;\n    [SerializeField] private float _audioVolume = 0.8f;\n    \n    private int _currentMorphIndex;\n    private float _lastMorphTime;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _baseMaterial;\n    private Color _targetColor;\n    private bool _isVulnerable;\n    private Vector3[] _startPositions;\n    private Quaternion[] _startRotations;\n    \n    private void Start()\n    {\n        _currentMorphIndex = 0;\n        _lastMorphTime = Time.time;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        _baseMaterial = _renderer.material;\n        _targetColor = _baseColors[_currentMorphIndex];\n        \n        _startPositions = new Vector3[_totalMorphStates];\n        _startRotations = new Quaternion[_totalMorphStates];\n        \n        for (int i = 0; i < _totalMorphStates; i++)\n        {\n            _startPositions[i] = transform.position;\n            _startRotations[i] = transform.rotation;\n        }\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _lastMorphTime + _morphInterval)\n        {\n            ChangeMorphState();\n            _lastMorphTime = Time.time;\n        }\n        \n        HandleMovement();\n        HandleColorTransition();\n        HandleAudio();\n        CheckForVulnerability();\n    }\n    \n    private void ChangeMorphState()\n    {\n        _currentMorphIndex = (_currentMorphIndex + 1) % _totalMorphStates;\n        UpdateMorphName();\n        UpdateTargetColor();\n        \n        if (_morphSounds != null && _audioVolume > 0)\n            PlayMorphSound(_audioVolume);\n    }\n    \n    private void UpdateMorphName()\n    {\n        GetComponent<Canvas>().text = _morphNames[_currentMorphIndex];\n    }\n    \n    private void UpdateTargetColor()\n    {\n        Color currentColor = _baseMaterial.color;\n        float progress = (Time.time - (Time.time % _colorTransitionSpeeds[_currentMorphIndex])) / _colorTransitionSpeeds[_currentMorphIndex];\n        if (progress >= 1f)\n            progress = 0f;\n            \n        currentColor.a = Mathf.Lerp(currentColor.a, _targetColor.a, progress);\n        currentColor.b = Mathf.Lerp(currentColor.b, _targetColor.b, progress);\n        currentColor.g = Mathf.Lerp(currentColor.g, _targetColor.g, progress);\n        currentColor.r = Mathf.Lerp(currentColor.r, _targetColor.r, progress);\n        \n        if (_pulseColors[_currentMorphIndex])\n        {\n            Color pulseColor = Color.Lerp(_baseColors[_currentMorphIndex], _targetColor, progress * 0.5f);\n            currentColor = pulseColor;\n        }\n        \n        _baseMaterial.color = currentColor;\n    }\n    \n    private void HandleMovement()\n    {\n        if (_moveInAllDirections[_currentMorphIndex] && CanMove())\n        {\n            float horizontal = Random.insideUnitSphere.x * _movementSpeeds[_currentMorphIndex];\n            float vertical = Random.insideUnitSphere.y * _movementSpeeds[_currentMorphIndex];\n            \n            transform.position += new Vector3(horizontal, 0f, vertical).normalized;\n            \n            if (_startPositions[_currentMorphIndex] != transform.position)\n                PlayMovementSound(_audioVolume);\n        }\n    }\n    \n    private void HandleColorTransition()\n    {\n        float progress = (Time.time - (Time.time % _colorTransitionSpeeds[_currentMorphIndex])) / _colorTransitionSpeeds[_currentMorphIndex];\n        if (progress >= 1f)\n            progress = 0f;\n            \n        Color currentColor = _baseMaterial.color;\n        currentColor.a = Mathf.Lerp(currentColor.a, _targetColor.a, progress);\n        currentColor.b = Mathf.Lerp(currentColor.b, _targetColor.b, progress);\n        currentColor.g = Mathf.Lerp(currentColor.g, _targetColor.g, progress);\n        currentColor.r = Mathf.Lerp(currentColor.r, _targetColor.r, progress);\n        \n        if (_pulseColors[_currentMorphIndex] && Random.value < 0.01f)\n            currentColor.a = Mathf.Lerp(currentColor.a, 0f, progress * 2f);\n            \n        _baseMaterial.color = currentColor;\n    }\n    \n    private void CheckForVulnerability()\n    {\n        float timeSinceLastVulnerability = Time.time - _lastVulnerableTime[_currentMorphIndex];\n        \n        if (timeSinceLastVulnerability >= _vulnerabilityTimes[_currentMorphIndex] && !_isVulnerable)\n        {\n            StartVulnerabilityWindow();\n        }\n        else if (_isVulnerable && timeSinceLastVulnerability < _vulnerabilityDuration)\n        {\n            EndVulnerabilityWindow();\n        }\n    }\n    \n    private void StartVulnerabilityWindow()\n    {\n        _lastVulnerableTime[_currentMorphIndex] = Time.time;\n        _isVulnerable = true;\n        \n        if (_showOutlineDuringVulnerability[_currentMorphIndex])\n        {\n            AddGlowOutline();\n        }\n        \n        PlayVulnerabilitySound(_audioVolume);\n    }\n    \n    private void EndVulnerabilityWindow()\n    {\n        _lastVulnerableTime[_currentMorphIndex] = Time.time;\n        _isVulnerable = false;\n        \n        if (_showOutlineDuringVulnerability[_currentMorphIndex])\n        {\n            RemoveGlowOutline();\n        }\n    }\n    \n    private bool CanMove()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, 0.5f, _obstacleLayerMask);\n        foreach (Collider col in colliders)\n        {\n            if (!(col.gameObject.isTrigger) && !col.CompareTag(\"Player\"))\n                return false;\n        }\n        return true;\n    }\n    \n    private void AddGlowOutline()\n    {\n        GameObject glowObject = new GameObject($\"Glow Outline - {_currentMorphIndex}\");\n        glowObject.transform.SetParent(transform);\n        \n        Renderer outlineRenderer = glowObject.AddComponent<OutlineRenderer>();\n        outlineRenderer.OutlineColor = Color.red;\n        outlineRenderer.OutlineWidth = 2f;\n        outlineRenderer.OutlineMode = OutlineMode.Line;\n    }\n    \n    private void RemoveGlowOutline()\n    {\n        GameObject[] glowObjects = GameObject.FindGameObjectsWithTag(\"GlowOutline\");\n        foreach (GameObject go in glowObjects)\n        {\n            if (go.transform.parent == transform)\n                Destroy(go);\n        }\n    }\n    \n    private void PlayMorphSound(float volume)\n    {\n        if (_morphSounds != null && _audioSource != null)\n        {\n            int soundIndex = _currentMorphIndex % _morphSounds.Length;\n            if (soundIndex >= 0)\n                _audioSource.PlayOneShot(_morphSounds[soundIndex], volume);\n        }\n    }\n    \n    private void PlayMovementSound(float volume)\n    {\n        if (_movementSounds != null && _audioSource != null)\n        {\n            int soundIndex = Random.Range(0, _movementSounds.Length);\n            if (soundIndex >= 0)\n                _audioSource.PlayOneShot(_movementSounds[soundIndex], volume);\n        }\n    }\n    \n    private void PlayVulnerabilitySound(float volume)\n    {\n        if (_movementSounds != null && _audioSource != null)\n        {\n            int soundIndex = Random.Range(0, _movementSounds.Length);\n            if (soundIndex >= 0)\n                _audioSource.PlayOneShot(_movementSounds[soundIndex], volume);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        if (_showOutlineDuringVulnerability[_currentMorphIndex])\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(transform.position, new Vector3(2f, 2f, 2f));\n        }\n    }\n}",
    "ir_json": {
      "class_name": "ShapeshifterEnemy",
      "components": [
        "Collider",
        "Renderer",
        "Animator",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "currentShape",
          "type": "string",
          "default": "sphere"
        },
        {
          "name": "nextShapeTime",
          "type": "float",
          "default": 0
        },
        {
          "name": "shapeDuration",
          "type": "float",
          "default": 2
        },
        {
          "name": "baseColor",
          "type": "Color",
          "default": "gray"
        },
        {
          "name": "currentSpeed",
          "type": "float",
          "default": 3
        },
        {
          "name": "rotationSpeed",
          "type": "float",
          "default": 90
        },
        {
          "name": "jumpForce",
          "type": "float",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "shape_transition",
          "trigger": "when shape change time arrives",
          "actions": [
            {
              "action": "fade out current shape appearance"
            },
            {
              "action": "load new shape model based on target shape"
            },
            {
              "action": "set object color to base plus accent colors for form type"
            },
            {
              "action": "play shifting sound effect"
            },
            {
              "action": "start movement pattern for new shape"
            }
          ]
        },
        {
          "name": "sphere_movement",
          "trigger": "when current shape is sphere and duration remains",
          "actions": [
            {
              "action": "roll randomly around ground surface"
            },
            {
              "action": "maintain slight bounce movement pattern"
            }
          ]
        },
        {
          "name": "cube_movement",
          "trigger": "when current shape is cube and duration remains",
          "actions": [
            {
              "action": "slide across floor in straight lines"
            },
            {
              "action": "change direction every few seconds randomly"
            }
          ]
        },
        {
          "name": "pyramid_movement",
          "trigger": "when current shape is pyramid and duration remains",
          "actions": [
            {
              "action": "hop forward in short bursts"
            },
            {
              "action": "rotate left and right while moving"
            }
          ]
        },
        {
          "name": "vulnerability_window",
          "trigger": "briefly flash outline when entering any form after movement starts",
          "actions": [
            {
              "action": "create glowing outline around current shape for 0.5 seconds"
            },
            {
              "action": "play soft warning sound"
            }
          ]
        },
        {
          "name": "color_shift",
          "trigger": "continuously while active",
          "actions": [
            {
              "action": "gradually change base color to random hue over time"
            }
          ]
        }
      ]
    },
    "ir_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class ShapeshifterEnemy : MonoBehaviour\n{\n    [Header(\"Shape Settings\")]\n    [SerializeField] private List<ShapeData> _availableShapes = new List<ShapeData>();\n    [SerializeField] private ShapeData _currentShape;\n    [SerializeField] private float _shapeTransitionTime = 2f;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bounceHeight = 1.5f;\n    [SerializeField] private float _jumpForce = 8f;\n    [SerializeField] private float _movementRadius = 10f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _shapeParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _shapeshiftSounds;\n    [SerializeField] private float _volume = 0.8f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private float _pitch = 1f;\n    \n    private enum ShapeType\n    {\n        Sphere,\n        Cube,\n        Pyramid\n    }\n    \n    private class ShapeData\n    {\n        public ShapeType shapeType;\n        public GameObject prefab;\n        public float scale = 1f;\n        public Vector3 velocity = Vector3.zero;\n        public Quaternion rotation = Quaternion.identity;\n        \n        public ShapeData(ShapeType type, GameObject go)\n        {\n            this.shapeType = type;\n            this.prefab = go;\n            if (type == ShapeType.Sphere)\n                this.scale = 1f;\n            else if (type == ShapeType.Cube)\n                this.scale = 1.5f;\n            else if (type == ShapeType.Pyramid)\n                this.scale = 1.2f;\n        }\n    }\n    \n    private Vector3 _startPosition;\n    private Quaternion _startRotation;\n    private bool _isGrounded;\n    private float _currentTime = 0f;\n    private float _shapeTransitionTimer = 0f;\n    private ShapeData _currentShapeData;\n    private Transform _playerTransform;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _startRotation = transform.rotation;\n        \n        _shapeRenderer = GetComponent<ShapeRenderer>();\n        if (_shapeRenderer == null)\n            _shapeRenderer = gameObject.AddComponent<ShapeRenderer>();\n            \n        _shapeRenderer.enabled = false;\n        _shapeRenderer.material = Material.DefaultMaterial;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            _rigidbody.useGravity = false;\n    }\n    \n    private void Update()\n    {\n        _currentTime += Time.deltaTime;\n        _shapeTransitionTimer += Time.deltaTime;\n        \n        CheckShapeTransition();\n        HandleMovement();\n        HandleRotation();\n        HandleAudio();\n    }\n    \n    private void CheckShapeTransition()\n    {\n        if (_isGrounded && !_currentShapeData)\n        {\n            ShapeType nextShape = GetNextShapeType(_availableShapes.Count);\n            if (nextShape != ShapeType.None)\n            {\n                _shapeTransitionTimer = 0f;\n                StartCoroutine(ShapeTransitionCoroutine(nextShape));\n            }\n            else\n            {\n                _currentShapeData = _availableShapes[0];\n            }\n        }\n    }\n    \n    private ShapeType GetNextShapeType(int count)\n    {\n        if (count == 0) return ShapeType.Sphere;\n        \n        int currentIndex = _availableShapes.Count % count;\n        return _availableShapes[currentIndex].shapeType;\n    }\n    \n    private IEnumerator ShapeTransitionCoroutine(ShapeType targetShape)\n    {\n        GameObject newShapeObj = null;\n        ShapeRenderer shapeRenderer = null;\n        AudioSource audioSource = null;\n        \n        if (_currentShapeData != null && targetShape != ShapeType.None)\n        {\n            newShapeObj = Instantiate(_currentShapeData.prefab, transform.position, Quaternion.identity);\n            shapeRenderer = newShapeObj.GetComponent<ShapeRenderer>();\n            audioSource = newShapeObj.GetComponent<AudioSource>();\n            \n            if (shapeRenderer != null)\n                shapeRenderer.enabled = true;\n                \n            // Set scale based on shape type\n            float targetScale = 1f;\n            switch (targetShape)\n            {\n                case ShapeType.Sphere:\n                    break;\n                case ShapeType.Cube:\n                    targetScale = 1.5f;\n                    break;\n                case ShapeType.Pyramid:\n                    targetScale = 1.2f;\n                    break;\n            }\n            \n            newShapeObj.transform.localScale = Vector3.one * targetScale;\n            \n            // Apply rotation\n            Quaternion targetRotation = transform.rotation;\n            newShapeObj.transform.rotation = targetRotation * Quaternion.Euler(0, 0, -90f);\n        }\n        \n        if (newShapeObj != null)\n        {\n            yield return new WaitForSeconds(_shapeTransitionTime);\n            Destroy(newShapeObj);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 moveDirection = transform.forward;\n        float horizontal = 0f;\n        float vertical = 0f;\n        \n        // Movement input\n        if (Input.GetKey(KeyCode.W))\n            vertical += 1f;\n        else if (Input.GetKey(KeyCode.S))\n            vertical -= 1f;\n            \n        if (Input.GetKey(KeyCode.A))\n            horizontal += 1f;\n        else if (Input.GetKey(KeyCode.D))\n            horizontal -= 1f;\n        \n        // Apply rotation based on movement\n        transform.Rotate(Vector3.up * horizontal * _rotationSpeed);\n        \n        // Calculate final direction\n        Vector3 moveDir = new Vector3(horizontal, vertical, 0f).normalized;\n        Vector3 moveAmount = moveDir * _moveSpeed;\n        \n        if (_rigidbody != null)\n            _rigidbody.AddForce(moveAmount, ForceMode.VelocityChange);\n    }\n    \n    private void HandleRotation()\n    {\n        transform.Rotate(Vector3.up * _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null) return;\n        \n        AudioSource clip = _audioSource;\n        clip.pitch = _pitch;\n        clip.volume = _volume;\n        clip.Play();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerTransform = other.transform;\n            _isGrounded = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isGrounded = false;\n            _rigidbody.useGravity = true;\n        }\n    }\n    \n    public void SetShape(ShapeType newShape, GameObject shapeGO)\n    {\n        ShapeData newShapeData = null;\n        \n        for (int i = 0; i < _availableShapes.Count; i++)\n        {\n            if (_availableShapes[i].shapeType == newShape && _availableShapes[i].prefab != null)\n            {\n                newShapeData = _availableShapes[i];\n                break;\n            }\n        }\n        \n        if (newShapeData == null) return;\n        \n        _currentShapeData = newShapeData;\n    }\n    \n    public void ResetToOriginal()\n    {\n        ShapeRenderer shapeRenderer = GetComponent<ShapeRenderer>();\n        if (shapeRenderer != null)\n            shapeRenderer.enabled = false;\n            \n        BoxCollider boxCollider = gameObject.GetComponent<BoxCollider>();\n        if (boxCollider == null) return;\n        boxCollider.isTrigger = true;\n        \n        transform.position = _startPosition;\n        transform.rotation = _startRotation;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        // Handle ground collision\n        if (collision.collider.CompareTag(\"Ground\"))\n        {\n            _isGrounded = true;\n        }\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        // Reset to air state\n        _isGrounded = false;\n        _rigidbody.useGravity = true;\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.GetIKRotation (0.65)",
      "Animator.GetBoneTransform (0.65)",
      "Animator.CrossFadeInFixedTime (0.65)",
      "Renderer.GetClosestReflectionProbes (0.62)",
      "AnimationUpdateMode.Fixed (0.43)",
      "AnimationUpdateMode.Normal (0.42)",
      "SpritePackingRotation.Rotate180 (0.42)",
      "SpritePackingRotation.FlipHorizontal (0.42)",
      "SpritePackingRotation.FlipVertical (0.41)",
      "ParticleSystemShapeMultiModeValue.Loop (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class ShapeshifterEnemy : MonoBehaviour\n{\n    [Header(\"Shapeshifting Settings\")]\n    public float morphCycleTime = 4f;\n    public int[] currentFormIndex = {0};\n    private float _currentMorphTime = 0f;\n    \n    [Header(\"Forms\")]\n    public Form[] forms;\n    public Material[] formMaterials;\n    public Animator[] formAnimators;\n    public ParticleSystem[] formParticles;\n    public AudioSource audioSource;\n    public AudioClip[] morphSounds;\n    public AudioClip[] attackSounds;\n    \n    [Header(\"Glow Settings\")]\n    public float glowIntensity = 1.2f;\n    public Color[] glowColors = {Color.green, Color.blue, Color.red};\n    private Light[] _enemyLights;\n    private float _glowTimer = 0f;\n    \n    [Header(\"Movement\")]\n    public Transform[] movementTargets;\n    public float[] moveSpeeds = {3f, 5f, 2f};\n    public float[] moveDirections = new float[3];\n    public bool usePhysics = true;\n    private Rigidbody _enemyRigidbody;\n    private CharacterController _enemyCharacterController;\n    \n    [Header(\"Attack\")]\n    public float attackCooldown = 6f;\n    public float attackDamage = 25f;\n    public GameObject[] attackEffects;\n    private float _attackTimer = 0f;\n    private Collider[] _attackColliders;\n    \n    [Header(\"Audio\")]\n    public AudioClip[] idleSounds;\n    public AudioClip[] morphingSounds;\n    public AudioClip[] victorySounds;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupForms();\n        SetupGlow();\n        SetupMovement();\n        _enemyRigidbody = GetComponent<Rigidbody>();\n        _enemyCharacterController = GetComponent<CharacterController>();\n        \n        if (_enemyLights == null)\n            _enemyLights = GetComponentsInChildren<Light>();\n            \n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        if (_attackColliders == null)\n            _attackColliders = new Collider[_forms.Length];\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_enemyRigidbody != null)\n            _enemyRigidbody.freezeRotation = true;\n        \n        if (_enemyCharacterController != null)\n            _enemyCharacterController.isKinematic = false;\n            \n        _currentMorphTime = 0f;\n        _attackTimer = 0f;\n        _glowTimer = 0f;\n    }\n    \n    private void SetupForms()\n    {\n        forms = new Form[3];\n        \n        for (int i = 0; i < 3; i++)\n        {\n            switch (i)\n            {\n                case 0: forms[i] = SphereForm; break;\n                case 1: forms[i] = CubeForm; break;\n                case 2: forms[i] = PyramidForm; break;\n            }\n        }\n        \n        formMaterials = new Material[3];\n        formAnimators = new Animator[3];\n        formParticles = new ParticleSystem[3];\n        movementTargets = new Transform[3];\n        \n        for (int i = 0; i < 3; i++)\n        {\n            switch (i)\n            {\n                case 0: formMaterials[i] = GetComponentInChildren<Material>(\"Sphere\"); break;\n                case 1: formMaterials[i] = GetComponentInChildren<Material>(\"Cube\"); break;\n                case 2: formMaterials[i] = GetComponentInChildren<Material>(\"Pyramid\"); break;\n                \n                // Animate\n                if (formAnimators[i] == null)\n                    formAnimators[i] = GetComponent<Animator>();\n                    \n                // Particles\n                if (formParticles[i] == null)\n                    formParticles[i] = GetComponentInChildren<ParticleSystem>();\n                \n                // Movement Target\n                movementTargets[i] = transform;\n            }\n        }\n    }\n    \n    private void SetupGlow()\n    {\n        for (int i = 0; i < _enemyLights.Length; i++)\n        {\n            if (_enemyLights[i] == null) continue;\n            \n            Color targetColor = glowColors[currentFormIndex[0]];\n            float intensity = targetColor.a * glowIntensity;\n            \n            _enemyLights[i].color = new Color(targetColor.r, targetColor.g, targetColor.b, intensity);\n            _enemyLights[i].intensity = intensity;\n        }\n    }\n    \n    private void SetupMovement()\n    {\n        for (int i = 0; i < forms.Length; i++)\n        {\n            switch (i)\n            {\n                case 0: \n                    movementTargets[i] = transform;\n                    moveSpeeds[i] = 3f;\n                    moveDirections = new float[] {1f, 0f, 0f};\n                    break;\n                case 1:\n                    movementTargets[i] = transform;\n                    moveSpeeds[i] = 5f;\n                    moveDirections = new float[] {0f, 1f, 0f};\n                    break;\n                case 2:\n                    movementTargets[i] = transform;\n                    moveSpeeds[i] = 2f;\n                    moveDirections = new float[] {0f, 0f, -1f};\n                    break;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (Time.time % morphCycleTime < _currentMorphTime)\n        {\n            StartMorphSequence();\n        }\n        \n        UpdateGlow();\n        UpdateMovement();\n        UpdateAttack();\n        UpdateAudio();\n    }\n    \n    private void StartMorphSequence()\n    {\n        _currentMorphTime = Random.Range(0f, Time.time % morphCycleTime);\n        ChangeForm(currentFormIndex[0]);\n        PlayMorphingSound();\n        \n        if (morphSounds != null && Random.value < 0.5f)\n            playRandomSound(morphingSounds);\n    }\n    \n    private void UpdateGlow()\n    {\n        _glowTimer += Time.deltaTime * 2f;\n        float normalizedTime = _glowTimer / morphCycleTime;\n        \n        if (normalizedTime >= 1f)\n        {\n            _glowTimer = 0f;\n            ChangeForm(currentFormIndex[0]);\n            PlayMorphingSound();\n            \n            if (morphSounds != null && Random.value < 0.5f)\n                playRandomSound(morphingSounds);\n        }\n    }\n    \n    private void UpdateMovement()\n    {\n        for (int i = 0; i < forms.Length; i++)\n        {\n            float t = Time.time * moveSpeeds[i] / morphCycleTime;\n            Vector3 direction = new Vector3(moveDirections[0], moveDirections[1], moveDirections[2]);\n            transform.position += direction * t * Time.deltaTime;\n            \n            if (usePhysics)\n            {\n                Rigidbody rb = _enemyRigidbody;\n                if (rb != null)\n                    rb.velocity = direction.normalized * moveSpeeds[i] * Time.deltaTime;\n            }\n        }\n    }\n    \n    private void UpdateAttack()\n    {\n        _attackTimer += Time.deltaTime;\n        \n        if (_attackTimer >= attackCooldown)\n        {\n            _attackTimer = 0f;\n            PerformAttack();\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        PlayIdleSound();\n        \n        float normalizedTime = _glowTimer / morphCycleTime;\n        if (normalizedTime < 1f && randomValue < 0.5f)\n        {\n            playRandomSound(idleSounds);\n        }\n    }\n    \n    private void ChangeForm(int formIndex)\n    {\n        currentFormIndex[0] = formIndex;\n        \n        Form targetForm = forms[formIndex];\n        Material mat = formMaterials[formIndex];\n        Animator anim = formAnimators[formIndex];\n        ParticleSystem particles = formParticles[formIndex];\n        Transform moveTarget = movementTargets[formIndex];\n        \n        if (mat != null)\n            mat.enabled = true;\n            \n        if (anim != null)\n            anim.SetTrigger(\"ChangeForm\");\n            anim.Play();\n            \n        if (particles != null)\n            particles.Play();\n            \n        if (moveTarget != null)\n        {\n            Vector3 direction = moveTarget.localEulerAngles;\n            transform.rotation = Quaternion.Euler(direction);\n        }\n        \n        SetupGlow();\n    }\n    \n    private void PerformAttack()\n    {\n        _attackTimer = 0f;\n        \n        for (int i = 0; i < forms.Length; i++)\n        {\n            if (i == currentFormIndex[0])\n            {\n                // Play attack sound\n                if (audioSource != null && morphSounds != null)\n                    audioSource.PlayOneShot(morphSounds[i]);\n                \n                // Spawn attack effect\n                if (attackEffects != null && i < attackEffects.Length)\n                    attackEffects[i].Invoke();\n                \n                // Deal damage to player\n                if (_player == null) continue;\n                \n                // Find collider for current form\n                Collider attackCollider = _attackColliders[i];\n                if (attackCollider != null)\n                {\n                    Rigidbody rb = attackCollider.GetComponent<Rigidbody>();\n                    if (rb != null)\n                        rb.AddForce(attackCollider.transform.forward * attackDamage * 0.1f, ForceMode.Impulse);\n                }\n            }\n        }\n    }\n    \n    private void PlayMorphingSound()\n    {\n        if (morphSounds != null && Random.value < 0.5f)\n            playRandomSound(morphSounds);\n    }\n    \n    private void PlayIdleSound()\n    {\n        if (idleSounds != null && Random.value < 0.5f)\n            playRandomSound(idleSounds);\n    }\n    \n    private void playRandomSound(AudioClip[] clipArray)\n    {\n        if (clipArray == null || clipArray.Length <= 0) return;\n        \n        int index = Random.Range(0, clipArray.Length);\n        clipArray[index].Play();\n    }\n    \n    private float randomValue => Random.value;\n    \n    public class Form\n    {\n        public string shapeType;\n        public Color color;\n        public string movementPattern;\n        public float speed;\n        public bool hasWeakPoints;\n        \n        public Form(string type, Color c = default, string pattern = \"\", float s = 1f)\n        {\n            shapeType = type;\n            color = c;\n            movementPattern = pattern;\n            speed = s;\n            hasWeakPoints = false;\n        }\n    }\n    \n    public class SphereForm : Form\n    {\n        public SphereForm() : base(\"Sphere\", Color.green, \"roll forward slowly\") { }\n    }\n    \n    public class CubeForm : Form\n    {\n        public CubeForm() : base(\"Cube\", Color.blue, \"slide sideways rapidly\") { }\n    }\n    \n    public class PyramidForm : Form\n    {\n        public PyramidForm() : base(\"Pyramid\", Color.red, \"hop in erratic patterns\") { }\n    }\n}\n\npublic class Sphere : RenderMesh\n{\n    private Vector3 _radius;\n    private Material _material;\n    \n    public Sphere(Vector3 radius = default)\n    {\n        _radius = new Vector3(radius.x, radius.y, radius.z);\n        GenerateSphere();\n    }\n    \n    private void GenerateSphere()\n    {\n        int slices = 64;\n        int stacks = 32;\n        \n        float angle1 = -Math.PI + (2 * Math.PI) / stacks;\n        float angle2 = Math.PI - (2 * Math.PI) / stacks;\n        \n        float x = 0f, y = 0f, z = 0f;\n        \n        for (int i = 0; i <= stacks; i++)\n        {\n            for (int j = 0; j <= slices; j++)\n            {\n                float u = angle1 + (angle2 - angle1) * j / slices;\n                float v = angle1 + (angle2 - angle1) * i / stacks;\n                \n                float xCoord = Mathf.Cos(u) * Mathf.Sin(v);\n                float yCoord = Mathf.Sin(u) * Mathf.Cos(v);\n                float zCoord = Mathf.Cos(v);\n                \n                Vector3 position = new Vector3(\n                    _radius.x * xCoord,\n                    _radius.y * yCoord,\n                    _radius.z * zCoord\n                );\n                \n                if (position.magnitude > _radius)\n                    position.Normalize();\n                    \n                yield return Position.position;\n            }\n        }\n    }\n}\n\npublic class CharacterController : MonoBehaviour\n{\n    private float _moveSpeed = 5f;\n    private Vector3 _moveDirection;\n    \n    public void Move(Vector3 direction, float speed)\n    {\n        _moveDirection = direction.normalized * speed;\n        transform.Translate(_moveDirection * Time.deltaTime);\n        \n        if (_moveDirection.magnitude > _moveSpeed)\n            _moveDirection.Normalize();\n    }\n}\n\npublic class AnimatorController : MonoBehaviour\n{\n    private Animator _animator;\n    private bool _isPlaying;\n    \n    public void Play(string trigger, float duration = 1f)\n    {\n        if (_animator == null) return;\n        \n        _animator.SetTrigger(trigger);\n        _animator.Play();\n        _isPlaying = true;\n    }\n    \n    public void Stop()\n    {\n        if (_isPlaying && _animator != null)\n        {\n            _animator.Stop();\n            _isPlaying = false;\n        }\n    }\n}\n\npublic class ParticleSystem : RenderMesh\n{\n    private ParticleSystem _originalParticles;\n    private Material _material;\n    \n    public ParticleSystem(ParticleSystem particles) \n    {\n        _originalParticles = particles;\n        GenerateParticles();\n    }\n    \n    private void GenerateParticles()\n    {\n        foreach (var particle in _originalParticles.GetParticles())\n        {\n            yield return Position.position;\n        }\n    }\n}\n\npublic class Sound : AudioSource\n{\n    public AudioClip[] clips;\n    public float volume = 1f;\n    \n    public void PlayRandomClip()\n    {\n        if (clips == null || clips.Length <= 0) return;\n        \n        int index = Random.Range(0, clips.Length);\n        clips[index].Play();\n    }\n}\n\npublic class Light : Light\n{\n    private Color _baseColor;\n    private float _intensity;\n    \n    public void SetGlow(Color color, float intensity)\n    {\n        _baseColor = color;\n        this.color = new Color(color.r, color.g, color.b, intensity);\n        this.intensity = intensity;\n    }\n}\n\npublic class Collider : Component\n{\n    public Material _material;",
    "per_behavior_docs": 15,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "enter_morph_sequence": [
        "Animator.CrossFadeInFixedTime (0.67)",
        "Animator.PlayInFixedTime (0.65)",
        "Time (0.65)"
      ],
      "apply_current_form_properties": [
        "Collider.GeometryHolder (0.72)",
        "Collider.GetGeometry (0.71)",
        "Collider.Raycast (0.69)"
      ],
      "execute_movement_pattern": [
        "Transform.GetPositionAndRotation (0.73)",
        "Transform.GetLocalPositionAndRotation (0.71)",
        "Transform.SetPositionAndRotation (0.71)"
      ],
      "show_vulnerability_window": [
        "Light.SetLightDirty (0.61)",
        "LightingSettings (0.59)",
        "Light.Reset (0.58)"
      ],
      "end_vulnerability_window": [
        "Material.GetShaderPassEnabled (0.70)",
        "Material.SetShaderPassEnabled (0.69)",
        "Material.RevertAllPropertyOverrides (0.64)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 46,
        "justification": "Direct generation lacks clear separation of concerns. Methods are long and do partial implementations. Good use of serialized fields, but monolithic approach makes extension difficult."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 6,
        "weighted_total": 67,
        "justification": "Strong modular design with clear separation of shape data and behaviors. Excellent use of enums and nested classes. Provides clear extension points and follows Unity component patterns closely."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 7,
        "correctness": 5,
        "completeness": 5,
        "weighted_total": 59,
        "justification": "Good attempt at breaking down behaviors, but slightly over-engineered. Multiple initialization methods create complexity. Strong Unity pattern adherence but less clean than monolithic approach."
      },
      "winner": "ir_monolithic",
      "key_differences": "Monolithic approach provides best balance between modularity, extensibility, and clear structure. Uses enums and nested classes to create clean, logical code organization.",
      "advantages": "Clean separation of shape data, clear state management, easy to extend with new shapes or behaviors, follows Unity best practices for component design"
    },
    "error": null
  },
  {
    "prompt_num": 17,
    "prompt": "Build a day-night cycle controller that over 60 seconds transitions ambient lighting through dawn, noon, dusk, and midnight phases, spawns appropriate ambient particles (morning mist, afternoon dust motes, evening fireflies, night stars), and triggers different background audio loops for each phase.",
    "timestamp": "2026-01-08T22:53:55.293565",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class DayNightCycle : MonoBehaviour\n{\n    [Header(\"Day-Night Transition Settings\")]\n    [SerializeField] private float _transitionDuration = 60f;\n    [SerializeField] private AnimationCurve _lightingTransitionCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private AnimationCurve _particleSpawnRateCurve = AnimationCurve.Linear(0f, 0.5f, 1f, 0.2f);\n    [SerializeField] private AnimationCurve _particleLifetimeCurve = AnimationCurve.Linear(0f, 1f, 1f, 3f);\n    \n    [Header(\"Lighting Settings\")]\n    [SerializeField] private Light[] _ambientLights;\n    [SerializeField] private float _baseBrightness = 0.7f;\n    [SerializeField] private Color _daylightColor = Color.white;\n    [SerializeField] private Color _nightlightColor = new Color(0.3f, 0.3f, 0.4f, 1f);\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _dayTimeSounds;\n    [SerializeField] private AudioClip[] _nightTimeSounds;\n    [SerializeField] private float _dayVolume = 0.8f;\n    [SerializeField] private float _nightVolume = 0.3f;\n    \n    [Header(\"Particle Settings\")]\n    [SerializeField] private ParticleSystem[] _morningMist;\n    [SerializeField] private ParticleSystem[] _afternoonDust;\n    [SerializeField] private ParticleSystem[] _eveningFireflies;\n    [SerializeField] private ParticleSystem[] _nightStars;\n    \n    private float _currentTime = 0f;\n    private bool _isDay = true;\n    private Coroutine _transitionCoroutine;\n    private List<ParticleSystem> _activeParticles = new List<ParticleSystem>();\n    \n    public enum DayNightPhase\n    {\n        Dawn,\n        Noon,\n        Dusk,\n        Midnight\n    }\n    \n    public DayNightPhase CurrentPhase { get; private set; }\n    \n    void Start()\n    {\n        SetupAudioSource();\n        InitializeLights();\n        InitializeParticles();\n        \n        if (_transitionCoroutine != null)\n            StopCoroutine(_transitionCoroutine);\n            \n        StartCoroutine(DayNightTransition());\n    }\n    \n    private void SetupAudioSource()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_dayTimeSounds.Length > 0 && _nightTimeSounds.Length > 0)\n        {\n            _audioSource.clip = _dayTimeSounds[Random.Range(0, _dayTimeSounds.Length)];\n            _audioSource.loop = true;\n            _audioSource.volume = _dayVolume;\n        }\n    }\n    \n    private void InitializeLights()\n    {\n        foreach (var light in _ambientLights)\n        {\n            if (light != null)\n            {\n                light.enabled = false;\n                light.color = Color.white;\n                light.intensity = 0.5f;\n            }\n        }\n        \n        if (_ambientLights.Length > 0)\n            _ambientLights[0].enabled = true;\n    }\n    \n    private void InitializeParticles()\n    {\n        foreach (var particleSystem in _morningMist)\n            particleSystem.Stop();\n            \n        foreach (var particleSystem in _afternoonDust)\n            particleSystem.Stop();\n            \n        foreach (var particleSystem in _eveningFireflies)\n            particleSystem.Stop();\n            \n        foreach (var particleSystem in _nightStars)\n            particleSystem.Stop();\n    }\n    \n    private IEnumerator DayNightTransition()\n    {\n        _currentTime = 0f;\n        \n        yield return new WaitForSeconds(1f);\n        \n        for (_currentTime = 0f; _currentTime < _transitionDuration; _currentTime += Time.deltaTime)\n        {\n            float normalizedTime = _currentTime / _transitionDuration;\n            normalizedTime = Mathf.Clamp01(normalizedTime);\n            \n            UpdateDayNightState(normalizedTime);\n            yield return null;\n        }\n        \n        _isDay = false;\n        CurrentPhase = DayNightPhase.Midnight;\n    }\n    \n    private void UpdateDayNightState(float normalizedTime)\n    {\n        switch (CurrentPhase)\n        {\n            case DayNightPhase.Dawn:\n                HandleDawn(normalizedTime);\n                break;\n                \n            case DayNightPhase.Noon:\n                HandleNoon(normalizedTime);\n                break;\n                \n            case DayNightPhase.Dusk:\n                HandleDusk(normalizedTime);\n                break;\n                \n            case DayNightPhase.Midnight:\n                HandleMidnight(normalizedTime);\n                break;\n        }\n    }\n    \n    private void HandleDawn(float normalizedTime)\n    {\n        if (_isDay)\n        {\n            SetLighting(true, normalizedTime);\n            SpawnMorningMist();\n            \n            PlayDayTimeSound();\n        }\n        else\n        {\n            SetLighting(false, normalizedTime);\n            StopMorningMist();\n        }\n        \n        CurrentPhase = DayNightPhase.Dawn;\n    }\n    \n    private void HandleNoon(float normalizedTime)\n    {\n        if (_isDay)\n        {\n            SetLighting(true, normalizedTime);\n            SpawnAfternoonDust();\n            \n            PlayDayTimeSound();\n        }\n        else\n        {\n            SetLighting(false, normalizedTime);\n            StopAfternoonDust();\n        }\n        \n        CurrentPhase = DayNightPhase.Noon;\n    }\n    \n    private void HandleDusk(float normalizedTime)\n    {\n        if (_isDay)\n        {\n            SetLighting(true, normalizedTime);\n            SpawnEveningFireflies();\n            \n            PlayDayTimeSound();\n        }\n        else\n        {\n            SetLighting(false, normalizedTime);\n            StopEveningFireflies();\n        }\n        \n        CurrentPhase = DayNightPhase.Dusk;\n    }\n    \n    private void HandleMidnight(float normalizedTime)\n    {\n        if (!_isDay)\n        {\n            SetLighting(false, normalizedTime);\n            SpawnNightStars();\n            \n            PlayNightTimeSound();\n        }\n        else\n        {\n            SetLighting(true, normalizedTime);\n            StopNightStars();\n        }\n        \n        CurrentPhase = DayNightPhase.Midnight;\n    }\n    \n    private void SetLighting(bool isDay, float normalizedTime)\n    {\n        Color targetColor = _isDay ? _daylightColor : _nightlightColor;\n        Color currentColor = _ambientLights.Length > 0 ? _ambientLights[0].color : Color.white;\n        \n        // Smooth transition curve\n        float t = Mathf.Clamp01(normalizedTime);\n        targetColor.a = _lightingTransitionCurve.Evaluate(t) * 1f;\n        \n        if (_ambientLights.Length > 0)\n        {\n            currentColor = Color.Lerp(currentColor, targetColor, _lightingTransitionCurve.Evaluate(t));\n            _ambientLights[0].color = currentColor;\n        }\n    }\n    \n    private void SpawnMorningMist()\n    {\n        foreach (var particleSystem in _morningMist)\n        {\n            if (!particleSystem.isPlaying)\n                particleSystem.Play();\n        }\n    }\n    \n    private void StopMorningMist()\n    {\n        foreach (var particleSystem in _morningMist)\n        {\n            if (particleSystem.isPlaying)\n                particleSystem.Stop();\n        }\n    }\n    \n    private void SpawnAfternoonDust()\n    {\n        foreach (var particleSystem in _afternoonDust)\n        {\n            if (!particleSystem.isPlaying)\n                particleSystem.Play();\n        }\n    }\n    \n    private void StopAfternoonDust()\n    {\n        foreach (var particleSystem in _afternoonDust)\n        {\n            if (particleSystem.isPlaying)\n                particleSystem.Stop();\n        }\n    }\n    \n    private void SpawnEveningFireflies()\n    {\n        foreach (var particleSystem in _eveningFireflies)\n        {\n            if (!particleSystem.isPlaying)\n                particleSystem.Play();\n        }\n    }\n    \n    private void StopEveningFireflies()\n    {\n        foreach (var particleSystem in _eveningFireflies)\n        {\n            if (particleSystem.isPlaying)\n                particleSystem.Stop();\n        }\n    }\n    \n    private void SpawnNightStars()\n    {\n        foreach (var particleSystem in _nightStars)\n        {\n            if (!particleSystem.isPlaying)\n                particleSystem.Play();\n        }\n    }\n    \n    private void StopNightStars()\n    {\n        foreach (var particleSystem in _nightStars)\n        {\n            if (particleSystem.isPlaying)\n                particleSystem.Stop();\n        }\n    }\n    \n    private void PlayDayTimeSound()\n    {\n        if (_audioSource != null && _dayTimeSounds.Length > 0)\n        {\n            _audioSource.PlayOneShot(_dayTimeSounds[Random.Range(0, _dayTimeSounds.Length)]);\n        }\n    }\n    \n    private void PlayNightTimeSound()\n    {\n        if (_audioSource != null && _nightTimeSounds.Length > 0)\n        {\n            _audioSource.PlayOneShot(_nightTimeSounds[Random.Range(0, _nightTimeSounds.Length)]);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "DayNightCycleController",
      "components": [
        "Light",
        "ParticleSystem",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "cycleDuration",
          "type": "float",
          "default": 60
        },
        {
          "name": "currentPhaseIndex",
          "type": "int",
          "default": 0
        },
        {
          "name": "phaseTimeStart",
          "type": "float",
          "default": 0
        },
        {
          "name": "phaseTimeEnd",
          "type": "float",
          "default": 60
        },
        {
          "name": "isDawnPhase",
          "type": "bool",
          "default": true
        },
        {
          "name": "hasTransitioned",
          "type": "bool",
          "default": false
        }
      ],
      "behaviors": [
        {
          "name": "initialize_cycle",
          "trigger": "when controller starts",
          "actions": [
            {
              "action": "set cycle duration to 60 seconds"
            }
          ]
        },
        {
          "name": "detect_phase_transition",
          "trigger": "every frame while cycle is active and transition has not occurred",
          "actions": [
            {
              "action": "check if current time falls within any phase time window"
            },
            {
              "action": "when current time crosses phase boundary into next phase"
            }
          ]
        },
        {
          "name": "transition_to_next_phase",
          "trigger": "when current time enters new phase and transition has not occurred",
          "actions": [
            {
              "action": "update current phase index to next phase"
            },
            {
              "action": "calculate time remaining in current phase based on cycle start time and end time"
            },
            {
              "action": "play ambient particle system matching the new phase (morning mist, afternoon dust motes, evening fireflies, night stars)"
            },
            {
              "action": "switch background audio loop to appropriate phase sound (dawn chimes, midday wind, dusk ambiance, midnight silence)"
            }
          ]
        },
        {
          "name": "update_lighting",
          "trigger": "every frame while cycle is active and current phase has changed",
          "actions": [
            {
              "action": "reduce sun brightness to match new ambient lighting level (dawn soft light, noon bright sunlight, dusk dimming light, midnight dark)"
            },
            {
              "action": "set moon visibility based on current time window (visible at night phases)"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class DayNightCycleController : MonoBehaviour\n{\n    [Header(\"Day/Night Phases\")]\n    [SerializeField] private float _cycleDuration = 60f;\n    [SerializeField] private int _phasesCount = 4;\n    [SerializeField] private bool _useSmoothTransition = true;\n    [SerializeField] private AnimationCurve _transitionCurve = AnimationCurve.EaseInOut(0.3f, 0.7f);\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Light _moonLight;\n    [SerializeField] private float _sunIntensityMin = 1f;\n    [SerializeField] private float _sunIntensityMax = 2f;\n    [SerializeField] private float _sunSpeed = 10f;\n    \n    [Header(\"Ambient Lighting\")]\n    [SerializeField] private Light _ambientLight;\n    [SerializeField] private Color _duskColor = Color.white;\n    [SerializeField] private Color _nightColor = Color.black;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _dayNightSounds;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Particle Settings\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private bool _enableParticles = true;\n    [SerializeField] private Color _dawnMistColor = Color.white;\n    [SerializeField] private Color _nightStarsColor = Color.black;\n    \n    private float _currentTime;\n    private int _currentPhaseIndex;\n    private bool _hasTransitionedToday;\n    private Vector3 _originalSunPosition;\n    private Vector3 _originalMoonPosition;\n    private Vector4 _originalAmbientIntensity;\n    \n    private void Start()\n    {\n        InitializeCycle();\n        SetupLights();\n        SetupAudio();\n        SetupParticles();\n    }\n    \n    private void Update()\n    {\n        if (Time.time - _currentTime < 0.1f)\n        {\n            CheckForPhaseTransition();\n        }\n    }\n    \n    private void InitializeCycle()\n    {\n        _currentTime = Time.time;\n        _currentPhaseIndex = 0;\n        _hasTransitionedToday = false;\n        \n        if (_particleSystem != null)\n        {\n            _originalAmbientIntensity = _particleSystem.ambientIntensity;\n            _particleSystem.ambientIntensity = new Vector4(0, 0, 0, 1f);\n        }\n    }\n    \n    private void SetupLights()\n    {\n        if (_sunLight == null)\n        {\n            GameObject sunObj = new GameObject(\"Sun\");\n            sunObj.transform.SetParent(transform);\n            sunObj.transform.localPosition = new Vector3(10f, -5f, 20f);\n            _sunLight = sunObj.AddComponent<Light>();\n            _sunLight.type = LightType.Point;\n            _sunLight.intensity = _sunIntensityMax;\n            _originalSunPosition = sunObj.transform.localPosition;\n        }\n        \n        if (_moonLight == null)\n        {\n            GameObject moonObj = new GameObject(\"Moon\");\n            moonObj.transform.SetParent(transform);\n            moonObj.transform.localPosition = new Vector3(0f, -15f, 30f);\n            _moonLight = moonObj.AddComponent<Light>();\n            _moonLight.type = LightType.Point;\n            _originalMoonPosition = moonObj.transform.localPosition;\n        }\n        \n        if (_ambientLight == null)\n        {\n            GameObject ambientObj = new GameObject(\"AmbientLight\");\n            ambientObj.transform.SetParent(transform);\n            _ambientLight = ambientObj.AddComponent<Light>();\n            _ambientLight.type = LightType.Ambient;\n            _originalAmbientIntensity = _ambientLight.intensity;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_dayNightSounds != null && _dayNightSounds.Length > 0)\n        {\n            _audioSource.clip = _dayNightSounds[Random.Range(0, _dayNightSounds.Length)];\n            _audioSource.volume = _audioVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (_particleSystem != null && _enableParticles)\n        {\n            if (_particleSystem.lights == null)\n            {\n                var lights = _particleSystem.lights as ParticleSystem.Lights;\n                if (lights == null)\n                {\n                    lights = new ParticleSystem.Lights();\n                    _particleSystem.lights = lights;\n                }\n                \n                lights.enabled = true;\n                lights.ratio = 1f;\n                lights.light = _sunLight;\n            }\n        }\n    }\n    \n    private void CheckForPhaseTransition()\n    {\n        if (_hasTransitionedToday) return;\n        \n        float normalizedTime = (Time.time - _currentTime) / _cycleDuration;\n        float progress = normalizedTime % 1f;\n        \n        if (_useSmoothTransition)\n        {\n            int nextPhaseIndex = Mathf.FloorToInt(progress * _phasesCount);\n            if (nextPhaseIndex != _currentPhaseIndex)\n            {\n                TransitionToPhase(nextPhaseIndex);\n            }\n        }\n        else\n        {\n            float phaseTime = progress % 1f;\n            if (phaseTime < 0.01f) // Start of new phase\n            {\n                TransitionToPhase(_currentPhaseIndex + 1);\n            }\n        }\n        \n        _hasTransitionedToday = true;\n    }\n    \n    private void TransitionToPhase(int targetPhase)\n    {\n        int currentPhase = _currentPhaseIndex;\n        bool isSunsetOrSunrise = (targetPhase % 2 == 0 && IsDuskPhase(currentPhase)) ||\n                               (targetPhase % 2 != 0 && IsNightPhase(currentPhase));\n        \n        if (_sunLight != null)\n        {\n            float intensity = GetSunIntensity(targetPhase);\n            _sunLight.intensity = intensity;\n            \n            Vector3 sunPos = _originalSunPosition;\n            if (!isSunsetOrSunrise)\n            {\n                sunPos.y += Mathf.Sin(Time.time * 0.1f) * 5f;\n                _sunLight.transform.localPosition = sunPos;\n            }\n        }\n        \n        if (_moonLight != null)\n        {\n            float intensity = GetMoonIntensity(targetPhase);\n            _moonLight.intensity = intensity;\n            \n            Vector3 moonPos = _originalMoonPosition;\n            if (targetPhase == 1 || targetPhase == 3) // Dusk/Night\n            {\n                moonPos.y += Mathf.Sin(Time.time * 0.1f + 1f) * 10f;\n                _moonLight.transform.localPosition = moonPos;\n            }\n        }\n        \n        if (_ambientLight != null)\n        {\n            Color targetColor = GetAmbientColor(targetPhase);\n            _ambientLight.intensity = new Vector4(0, 0, 0, targetColor.a);\n        }\n        \n        UpdateParticles();\n        UpdateAudio();\n    }\n    \n    private float GetSunIntensity(int phase)\n    {\n        if (phase % 2 == 0) // Day phases\n        {\n            return _sunIntensityMin + Mathf.Abs(Mathf.Sin(Time.time * 0.1f)) * (_sunIntensityMax - _sunIntensityMin);\n        }\n        else // Night phase\n        {\n            float normalizedTime = ((phase + 1f) / 2f) % 1f;\n            return _sunIntensityMin * (1f - Mathf.Abs(Mathf.Sin(normalizedTime * 2f)));\n        }\n    }\n    \n    private float GetMoonIntensity(int phase)\n    {\n        if (phase == 1 || phase == 3) // Night phases\n        {\n            float normalizedTime = ((phase + 1f) / 2f) % 1f;\n            return _sunIntensityMin * Mathf.Cos(normalizedTime * Mathf.PI);\n        }\n        else // Day phases\n        {\n            float normalizedTime = (phase / 2f) % 1f;\n            return _sunIntensityMax * Mathf.Sin(normalizedTime * Mathf.PI / 2f);\n        }\n    }\n    \n    private Color GetAmbientColor(int phase)\n    {\n        if (phase == 0 || phase == 2) // Day phases\n        {\n            return _duskColor;\n        }\n        else // Night phases\n        {\n            return _nightColor;\n        }\n    }\n    \n    private bool IsDuskPhase(int phase)\n    {\n        return phase % 2 == 0 && phase != 0; // Phases 2 and 4 are dusk\n    }\n    \n    private bool IsNightPhase(int phase)\n    {\n        return (phase % 2 != 0) || (phase == 0); // Phases 1, 3, and 0 are night\n    }\n    \n    private void UpdateParticles()\n    {\n        if (_particleSystem == null) return;\n        \n        ParticleSystem.Lights lights = _particleSystem.lights as ParticleSystem.Lights;\n        if (lights != null)\n        {\n            lights.enabled = true;\n        }\n        \n        Color currentColor;\n        if (_enableParticles && _particleSystem != null)\n        {\n            if (_particleSystem.color == Color.white)\n                currentColor = Color.white;\n            else if (_particleSystem.color == Color.black)\n                currentColor = Color.black;\n            else\n                currentColor = _particleSystem.color;\n            \n            _particleSystem.color = currentColor;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _dayNightSounds.Length);\n        _audioSource.clip = _dayNightSounds[soundIndex];\n        _audioSource.volume = _audioVolume;\n        _audioSource.Play();\n    }\n    \n    public void ForceTransition(int targetPhase)\n    {\n        if (_hasTransitionedToday) return;\n        \n        TransitionToPhase(targetPhase);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        DrawCycleGizmos();\n    }\n    \n    private void DrawCycleGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 startPoint = transform.position;\n        \n        for (int i = 0; i < _phasesCount; i++)\n        {\n            float progress = (i / _phasesCount) % 1f;\n            float normalizedTime = progress * _cycleDuration;\n            \n            if (_useSmoothTransition)\n            {\n                int currentPhase = Mathf.FloorToInt(normalizedTime);\n                Vector3 targetPoint = CalculateTargetPosition(currentPhase, startPoint);\n                \n                Gizmos.DrawLine(startPoint, targetPoint);\n            }\n            else\n            {\n                float phaseTime = normalizedTime % 1f;\n                if (phaseTime < 0.01f)\n                {\n                    Vector3 targetPoint = CalculateTargetPosition(i, startPoint);\n                    Gizmos.color = Color.red;\n                    Gizmos.DrawLine(startPoint, targetPoint);\n                }\n            }\n        }\n    }\n    \n    private Vector3 CalculateTargetPosition(int phaseIndex, Vector3 startPoint)\n    {\n        float radians = Mathf.PI * (phaseIndex / _phasesCount);\n        \n        if (_sunLight != null && phaseIndex % 2 == 0) // Sun phases\n        {\n            return new Vector3(\n                startPoint.x + Mathf.Cos(radians) * 20f,\n                startPoint.y + Mathf.Sin(radians) * 10f,\n                startPoint.z + Mathf.Cos(2f * radians) * 10f\n            );\n        }\n        \n        if (_moonLight != null && phaseIndex % 2 == 1) // Moon phases\n        {\n            return new Vector3(\n                startPoint.x + Mathf.Sin(radians) * 15f,\n                startPoint.y - Mathf.Cos(0.5f * radians) * 20f,\n                startPoint.z + Mathf.Sin(Mathf.PI / 4f) * 10f\n            );\n        }\n        \n        // Default position if no light is assigned to this phase\n        return new Vector3(\n            startPoint.x,\n            startPoint.y - 15f,\n            startPoint.z + 10f\n        );\n    }\n    \n    public void ResetCycle()\n    {\n        _currentTime = Time.time;\n        _currentPhaseIndex = 0;\n        _hasTransitionedToday = false;\n        \n        if (_particleSystem != null)\n        {\n            _particleSystem.ambientIntensity = _originalAmbientIntensity;\n        }\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "ParticleSystem.LightsModule (0.64)",
      "ParticleSystem.RotationOverLifetimeModule (0.64)",
      "ParticleSystem.ColorOverLifetimeModule (0.64)",
      "Light.SetLightDirty (0.61)",
      "Light.AddCommandBuffer (0.61)",
      "Light.GetCommandBuffers (0.60)",
      "ParticleSystemCullingMode.PauseAndCatchup (0.42)",
      "ParticleSystemCullingMode.Pause (0.41)",
      "LightProbes.CalculateInterpolatedLightAndOcclusionProbes (0.41)",
      "AudioVelocityUpdateMode.Fixed (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class DayNightCycleController : MonoBehaviour\n{\n    [Header(\"Day/Night Settings\")]\n    public float _cycleDuration = 60f;\n    public float _dayBrightness = 1f;\n    public float _nightBrightness = 0.2f;\n    public float _transitionSpeed = 5f;\n    \n    [Header(\"Audio Settings\")]\n    public AudioClip[] _dayMusic Clips;\n    public AudioClip[] _nightMusic Clips;\n    public float _musicVolume = 0.7f;\n    \n    [Header(\"Particles\")]\n    public ParticleSystem[] _particleSystems;\n    public Transform[] _ambientObjectPositions;\n    public GameObject[] _ambientObjects;\n    \n    private float _cycleTimer = 0f;\n    private string _currentPhase = \"day\";\n    private AudioSource _audioSource;\n    private float _musicIndex = 0f;\n    private bool _isPlayingMusic = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupAudio();\n        InitializeParticles();\n    }\n    \n    private void Update()\n    {\n        HandleCycleTimer();\n        UpdatePhase();\n        UpdateMusic();\n        UpdateParticles();\n    }\n    \n    private void HandleCycleTimer()\n    {\n        _cycleTimer += Time.deltaTime * _transitionSpeed;\n        \n        if (_cycleTimer >= _cycleDuration)\n        {\n            _cycleTimer = 0f;\n            ChangePhase(_currentPhase);\n        }\n    }\n    \n    private void UpdatePhase()\n    {\n        switch (_currentPhase)\n        {\n            case \"day\":\n                ApplyDaylight();\n                break;\n            case \"night\":\n                ApplyNightlight();\n                break;\n        }\n    }\n    \n    private void ApplyDaylight()\n    {\n        if (GetComponent<Light>() != null)\n        {\n            Light light = GetComponent<Light>();\n            float targetIntensity = Mathf.Lerp(_nightBrightness, _dayBrightness, GetPhaseProgress());\n            \n            // Animate brightness over time\n            light.intensity = targetIntensity;\n            \n            // Add soft glow effect to nearby objects\n            for (int i = 0; i < _ambientObjectPositions.Length; i++)\n            {\n                if (_ambientObjectPositions[i] != null)\n                {\n                    GameObject obj = _ambientObjectPositions[i].gameObject;\n                    if (obj != null && obj.GetComponent<Light>() != null)\n                    {\n                        Light ambientLight = obj.GetComponent<Light>();\n                        float ambientIntensity = Mathf.Lerp(_nightBrightness, targetIntensity * 0.8f, GetPhaseProgress());\n                        ambientLight.intensity = ambientIntensity;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void ApplyNightlight()\n    {\n        if (GetComponent<Light>() != null)\n        {\n            Light light = GetComponent<Light>();\n            float targetIntensity = Mathf.Lerp(_dayBrightness, _nightBrightness, GetPhaseProgress());\n            \n            // Animate brightness over time\n            light.intensity = targetIntensity;\n            \n            // Add soft glow effect to nearby objects\n            for (int i = 0; i < _ambientObjectPositions.Length; i++)\n            {\n                if (_ambientObjectPositions[i] != null)\n                {\n                    GameObject obj = _ambientObjectPositions[i].gameObject;\n                    if (obj != null && obj.GetComponent<Light>() != null)\n                    {\n                        Light ambientLight = obj.GetComponent<Light>();\n                        float ambientIntensity = Mathf.Lerp(_dayBrightness, targetIntensity * 0.8f, GetPhaseProgress());\n                        ambientLight.intensity = ambientIntensity;\n                    }\n                }\n            }\n        }\n    }\n    \n    private float GetPhaseProgress()\n    {\n        return _cycleTimer / _cycleDuration;\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null) return;\n        \n        _isPlayingMusic = false;\n        \n        for (int i = 0; i < _dayMusicClips.Length; i++)\n        {\n            if (_dayMusicClips[i] != null)\n            {\n                _audioSource.clip = _dayMusicClips[i];\n                _musicIndex = i;\n                break;\n            }\n        }\n        \n        for (int i = 0; i < _nightMusicClips.Length; i++)\n        {\n            if (_nightMusicClips[i] != null)\n            {\n                _audioSource.clip = _nightMusicClips[i];\n                _musicIndex = i;\n                break;\n            }\n        }\n        \n        if (_audioSource.isPlaying && _isPlayingMusic)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void UpdateMusic()\n    {\n        if (!_audioSource.isPlaying) return;\n        \n        float progress = GetPhaseProgress();\n        _musicIndex += progress * 2f; // Smooth transition between day and night\n        \n        if (_musicIndex >= _dayMusicClips.Length)\n        {\n            _musicIndex = 0f;\n        }\n        \n        _isPlayingMusic = true;\n        _audioSource.PlayOneShot(_dayMusicClips[_musicIndex] || _nightMusicClips[_musicIndex]);\n    }\n    \n    private void InitializeParticles()\n    {\n        foreach (var particleSystem in _particleSystems)\n        {\n            if (particleSystem != null)\n            {\n                // Spawn ambient objects at positions\n                for (int i = 0; i < _ambientObjectPositions.Length; i++)\n                {\n                    if (_ambientObjectPositions[i] != null && particleSystem.transform.root == null)\n                    {\n                        GameObject obj = new GameObject($\"Particle_{i}\");\n                        obj.transform.SetParent(particleSystem.transform);\n                        \n                        // Add light to simulate particle glow\n                        Light lightObj = obj.AddComponent<Light>();\n                        lightObj.type = LightType.Point;\n                        lightObj.intensity = 0.1f;\n                        lightObj.color = Color.white;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void UpdateParticles()\n    {\n        foreach (var particleSystem in _particleSystems)\n        {\n            if (particleSystem == null) continue;\n            \n            // Fade out particles as day turns to night\n            float fadeAmount = GetPhaseProgress();\n            Color targetColor = Color.white * Mathf.Lerp(Color.white, Color.gray, fadeAmount);\n            \n            // Animate size for glow effect\n            Vector3 scale = particleSystem.transform.localScale;\n            float scaleAmount = Mathf.Lerp(0.8f, 1f, fadeAmount);\n            scale.x = scaleAmount;\n            scale.z = scaleAmount;\n            particleSystem.transform.localScale = scale;\n            \n            // Apply color change\n            if (particleSystem.hasColorOverLifetime)\n            {\n                ParticleSystem.colorOverLifetime = targetColor;\n            }\n        }\n    }\n    \n    public void ChangePhase(string newPhase)\n    {\n        _currentPhase = newPhase;\n        _cycleTimer = 0f;\n        \n        if (!_isPlayingMusic)\n        {\n            SetupAudio();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        float progress = GetPhaseProgress();\n        \n        // Draw phase indicator\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n        Gizmos.color = new Color(progress, 1f - progress, 0f);\n        Gizmos.DrawWireCube(transform.position + Vector3.up * 0.5f, Vector3.one * 0.5f);\n        \n        // Draw light intensity\n        float targetIntensity = Mathf.Lerp(_nightBrightness, _dayBrightness, progress);\n        Color lightColor = new Color(1f - (1f - targetIntensity) * 0.7f, 1f, 1f);\n        Gizmos.color = lightColor;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * 0.5f * targetIntensity, Vector3.one * 0.5f);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_audioSource != null && _isPlayingMusic)\n        {\n            _audioSource.Stop();\n            _isPlayingMusic = false;\n        }\n    }\n}",
    "per_behavior_docs": 5,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "start_daynight_cycle": [
        "ParticleSystem.LightsModule (0.71)",
        "Light.SetLightDirty (0.70)",
        "Light.AddCommandBufferAsync (0.70)"
      ],
      "transition_to_noon": [
        "ParticleSystem.LightsModule (0.72)",
        "ParticleSystem.ColorOverLifetimeModule (0.70)",
        "Light.SetLightDirty (0.70)"
      ],
      "transition_to_dusk": [
        "ParticleSystem.LightsModule (0.70)",
        "Light.SetLightDirty (0.69)",
        "ParticleSystem.ColorOverLifetimeModule (0.69)"
      ],
      "enter_nighttime": [
        "ParticleSystem.LightsModule (0.75)",
        "ParticleSystem.ColorOverLifetimeModule (0.72)",
        "ParticleSystem.ColorBySpeedModule (0.70)"
      ],
      "complete_cycle": [
        "ParticleSystem.LightsModule (0.78)",
        "ParticleSystem.ColorOverLifetimeModule (0.75)",
        "ParticleSystem.ColorBySpeedModule (0.74)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 64,
        "justification": "Strong use of Unity serialization, clear method separation, but somewhat monolithic in approach. Good enum for phases and coroutine-based transition."
      },
      "ir_monolithic": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 5,
        "weighted_total": 48,
        "justification": "Over-complicated initialization, scattered responsibilities, creates GameObjects dynamically which is less predictable. Lacks clear transition mechanism."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 9,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 72,
        "justification": "Highly modular approach with clear method responsibilities. Easy to extend and modify. Clean separation of concerns with update methods handling specific behaviors."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The per-behavior approach provides the most flexible and maintainable architecture, with clear method separation and easy extension points.",
      "advantages": "Allows granular control over each aspect of the day-night cycle, makes adding new features or modifying existing behavior trivial, follows single responsibility principle closely"
    },
    "error": null
  },
  {
    "prompt_num": 18,
    "prompt": "Design a water puddle that ripples when objects fall into it with splash sound proportional to impact force, reflects nearby light sources with wobbly distortion, slowly evaporates when exposed to heat sources making sizzle sounds, and freezes into slippery ice when temperature drops.",
    "timestamp": "2026-01-08T22:57:07.823752",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WaterPuddle : MonoBehaviour\n{\n    [Header(\"Water Physics\")]\n    [SerializeField] private float _maxHeight = 0.2f;\n    [SerializeField] private float _minHeight = 0.05f;\n    [SerializeField] private float _evaporationSpeed = 1f;\n    [SerializeField] private float _splashRadius = 0.5f;\n    \n    [Header(\"Ripple Effects\")]\n    [SerializeField] private float _rippleIntensity = 2f;\n    [SerializeField] private AnimationCurve _rippleDecay = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private float _baseRippleDuration = 3f;\n    \n    [Header(\"Sound Effects\")]\n    [SerializeField] private AudioClip[] _splashSounds;\n    [SerializeField] private float _soundVolume = 0.7f;\n    [SerializeField] private float _maxSoundDistance = 10f;\n    \n    [Header(\"Heat Evaporation\")]\n    [SerializeField] private LayerMask _heatLayers = -1;\n    [SerializeField] private float _heatDamageAmount = 5f;\n    [SerializeField] private float _heatRadius = 3f;\n    \n    [Header(\"Freeze Effect\")]\n    [SerializeField] private bool _enableFreezing = true;\n    [SerializeField] private float _freezeDamageAmount = 10f;\n    [SerializeField] private float _freezeRadius = 2f;\n    [SerializeField] private AnimationCurve _freezeTransition = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    private Vector3[] _initialPoints;\n    private List<Vector3> _waterParticles = new List<Vector3>();\n    private AudioSource _audioSource;\n    private float _timeSinceSpashed;\n    private bool _isFrozen = false;\n    private float _freezeTimer = 0f;\n    private Renderer _renderer;\n    \n    private void Start()\n    {\n        _initialPoints = new Vector3[10];\n        for (int i = 0; i < _initialPoints.Length; i++)\n        {\n            _initialPoints[i] = transform.position + Random.insideUnitSphere * (_maxHeight - _minHeight) * 0.5f;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _renderer.material.mainTexture = Resources.Load<Texture>(\"WaterTexture\") ?? defaultTexture;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleEvaporation();\n        HandleHeatDamage();\n        HandleFreezing();\n        UpdateRipples();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isFrozen)\n        {\n            ApplyFreezeEffects();\n        }\n    }\n    \n    private void HandleEvaporation()\n    {\n        for (int i = _waterParticles.Count - 1; i >= 0; i--)\n        {\n            float distanceToEdge = Vector3.Distance(_waterParticles[i], transform.position);\n            \n            if (distanceToEdge > 0.1f)\n            {\n                _waterParticles.RemoveAt(i);\n                continue;\n            }\n            \n            float currentHeight = GetParticleHeight(_waterParticles[i]);\n            float newHeight = Mathf.Lerp(currentHeight, _minHeight, \n                (_evaporationSpeed * Time.deltaTime) / distanceToEdge);\n                \n            if (newHeight <= 0f)\n            {\n                _waterParticles.RemoveAt(i);\n                continue;\n            }\n            \n            SetParticleHeight(_waterParticles[i], newHeight);\n        }\n    }\n    \n    private void HandleHeatDamage()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _heatRadius, _heatLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                ApplyHeatDamage(col.gameObject, _heatDamageAmount);\n            }\n            else if (!col.CompareTag(\"HeatSource\") && !col.CompareTag(\"Enemy\"))\n            {\n                ApplyHeatDamage(col.gameObject, _heatDamageAmount * 0.5f);\n            }\n        }\n    }\n    \n    private void ApplyHeatDamage(GameObject target)\n    {\n        var health = target.GetComponent<Health>();\n        if (health != null)\n        {\n            float damage = 0f;\n            \n            Collider[] hitColliders = Physics.OverlapSphere(target.transform.position, \n                _heatRadius * 0.5f, target.GetComponentsInChildren<Collider>().Select(c => c.bounds).ToList());\n            \n            foreach (Collider col in hitColliders)\n            {\n                if (col.CompareTag(\"Player\"))\n                    damage += _heatDamageAmount;\n                else if (col.CompareTag(\"Enemy\"))\n                    damage += _heatDamageAmount * 1.5f;\n                else\n                    damage += _heatDamageAmount * 0.3f;\n            }\n            \n            health.TakeDamage(damage);\n        }\n    }\n    \n    private void ApplyFreezeDamage(GameObject target)\n    {\n        var rigidbody = target.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            float damage = _freezeDamageAmount * Mathf.Clamp01(Time.deltaTime / _freezeTimer);\n            rigidbody.AddForce(Vector3.up * damage, ForceMode.Acceleration);\n        }\n        \n        var health = target.GetComponent<Health>();\n        if (health != null)\n        {\n            health.TakeDamage(_freezeDamageAmount);\n        }\n    }\n    \n    private void UpdateRipples()\n    {\n        for (int i = 0; i < _waterParticles.Count; i++)\n        {\n            Vector3 particlePosition = _waterParticles[i];\n            float height = GetParticleHeight(particlePosition);\n            \n            if (height <= 0f) continue;\n            \n            float time = Time.time - _timeSinceSpashed;\n            float normalizedTime = Mathf.Clamp01(time / _baseRippleDuration);\n            float decay = _rippleDecay.Evaluate(normalizedTime);\n            \n            float rippleOffset = Random.Range(-1f * _rippleIntensity, 1f * _rippleIntensity) * decay;\n            particlePosition.y += rippleOffset;\n        }\n    }\n    \n    private void SetParticleHeight(Vector3 position, float height)\n    {\n        if (_renderer != null && _initialPoints.Length > 0)\n        {\n            Vector3 originalPos = _initialPoints[Random.Range(0, _initialPoints.Length)];\n            float distance = Vector3.Distance(originalPos, position);\n            \n            if (distance < 1f)\n            {\n                _waterParticles.Remove(position);\n                return;\n            }\n        }\n        \n        transform.position = new Vector3(position.x, height, position.z);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        float distanceToPlayer = GetDistanceToPlayer();\n        float normalizedDistance = Mathf.Clamp01(distanceToPlayer / _maxSoundDistance);\n        \n        if (normalizedDistance > 0.1f)\n        {\n            _audioSource.PlayOneShot(_splashSounds[Random.Range(0, _splashSounds.Length)]);\n            _timeSinceSpashed = Time.time;\n        }\n    }\n    \n    private float GetDistanceToPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject == null) return _maxSoundDistance;\n        \n        Collider[] colliders = Physics.OverlapSphere(playerObject.transform.position, \n            _maxSoundDistance * 0.5f, playerObject.GetComponentsInChildren<Collider>().Select(c => c.bounds).ToList());\n        \n        foreach (Collider col in colliders)\n        {\n            float distance = Vector3.Distance(transform.position, col.center);\n            if (distance <= _maxSoundDistance) return distance;\n        }\n        \n        return _maxSoundDistance;\n    }\n    \n    private void HandleFreezing()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _freezeRadius, \n            new LayerMask { -1 });\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                ApplyFreezeEffects();\n            }\n            else if (!col.CompareTag(\"HeatSource\") && !col.CompareTag(\"Enemy\"))\n            {\n                ApplyFreezeDamage(col.gameObject, _freezeDamageAmount * 0.5f);\n            }\n        }\n    }\n    \n    private void ApplyFreezeEffects()\n    {\n        _isFrozen = true;\n        \n        // Create ice visual effect\n        Material iceMaterial = _renderer.material;\n        if (iceMaterial.HasProperty(\"_Color\"))\n        {\n            iceMaterial.SetColor(\"_Color\", Color.green);\n        }\n        \n        // Add frost particle effects around the puddle\n        ParticleSystem frostParticles = gameObject.AddComponent<ParticleSystem>();\n        frostParticles.StartLifetime = 5f;\n        frostParticles.StopLifetime = 10f;\n        frostParticles.AddParticle(\"FrostSpark\", 1, 0.3f, 2f);\n        \n        // Add ice sound effect\n        AudioSource audio = GetComponent<AudioSource>();\n        if (audio != null)\n        {\n            audio.clip = Resources.Load<AudioClip>(\"IceCrack\");\n            audio.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _maxHeight * 0.8f);\n        \n        // Draw ripple effect\n        float[] ripplePoints = new float[100];\n        for (int i = 0; i < ripplePoints.Length; i++)\n        {\n            float angle = (i / ripplePoints.Length) * 360f;\n            float x = Mathf.Cos(angle * Mathf.Deg2Rad) * _maxHeight * 0.5f;\n            float y = Mathf.Sin(angle * Mathf.Deg2Rad) * _maxHeight * 0.5f;\n            ripplePoints[i] = new Vector3(transform.position.x + x, transform.position.y + y, \n                transform.position.z + Mathf.Cos(angle * Mathf.Deg2Rad * 0.7f));\n        }\n        \n        for (int i = 0; i < ripplePoints.Length; i++)\n        {\n            if (ripplePoints[i].y > 0f)\n            {\n                Gizmos.DrawLine(transform.position, ripplePoints[i]);\n            }\n        }\n    }\n    \n    public void AddSplashPoint(Vector3 position)\n    {\n        _waterParticles.Add(position);\n    }\n    \n    private float GetParticleHeight(Vector3 position)\n    {\n        foreach (Vector3 p in _waterParticles)\n        {\n            if (Vector3.Distance(p, position) < 0.1f)\n                return p.y;\n        }\n        \n        return transform.position.y;\n    }\n}",
    "ir_json": {
      "class_name": "RipplingWaterPuddle",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem",
        "MeshRenderer"
      ],
      "fields": [
        {
          "name": "max splash force",
          "type": "float",
          "default": 10
        },
        {
          "name": "evaporationSpeed",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "temperatureThreshold",
          "type": "float",
          "default": 20
        },
        {
          "name": "rippleDuration",
          "type": "float",
          "default": 3
        },
        {
          "name": "iceFormationTime",
          "type": "float",
          "default": 1
        }
      ],
      "behaviors": [
        {
          "name": "detect_impact",
          "trigger": "object collides with puddle surface",
          "actions": [
            {
              "action": "calculate impact velocity magnitude"
            },
            {
              "action": "scale splash force based on velocity"
            },
            {
              "action": "play splash sound at volume proportional to scaled force"
            },
            {
              "action": "spawn particle ripple effect at impact point"
            }
          ]
        },
        {
          "name": "reflect_light",
          "trigger": "object falls near puddle and creates splash particles",
          "actions": [
            {
              "action": "find nearby light sources"
            },
            {
              "action": "apply random wavy distortion to light intensity for reflection area"
            },
            {
              "action": "create shimmering visual effect on water surface"
            }
          ]
        },
        {
          "name": "evaporate_heat",
          "trigger": "puddle temperature exceeds environmental heat level",
          "actions": [
            {
              "action": "gradually reduce puddle size over evaporation speed"
            },
            {
              "action": "play sizzle sound at rate matching evaporation rate"
            },
            {
              "action": "create steam particle effects from surface"
            }
          ]
        },
        {
          "name": "freeze_formation",
          "trigger": "temperature falls below freezing threshold and puddle remains intact",
          "actions": [
            {
              "action": "gradually reduce water fluidity to become icy texture"
            },
            {
              "action": "add slippery ice physics properties to surface"
            },
            {
              "action": "play chattering frost sound effect"
            }
          ]
        },
        {
          "name": "maintain_ripples",
          "trigger": "continuous ripple animation is active",
          "actions": [
            {
              "action": "pulse water surface upward and downward in circular motion"
            },
            {
              "action": "add random wave patterns to water texture"
            },
            {
              "action": "ensure ripple size varies with maximum splash force"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RipplingWaterPuddle : MonoBehaviour\n{\n    [Header(\"Water Physics\")]\n    [SerializeField] private float _maxRippleForce = 10f;\n    [SerializeField] private float _evaporationSpeed = 2f;\n    [SerializeField] private float _freezeThreshold = -5f;\n    [SerializeField] private LayerMask _waterLayerMask = 1;\n    [SerializeField] private AnimationCurve _rippleIntensityCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _splashParticles;\n    [SerializeField] private Material _puddleMaterial;\n    [SerializeField] private float _waveHeight = 0.5f;\n    [SerializeField] private AnimationCurve _surfaceDistortionCurve = AnimationCurve.Linear(0f, -1f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Rippling Settings\")]\n    [SerializeField] private float _rippleDuration = 3f;\n    [SerializeField] private float _rippleFrequency = 2f;\n    [SerializeField] private AnimationCurve _rippleOverTime = AnimationCurve.Linear(0f, 0.5f, 1f, -0.5f);\n    \n    private Vector3[] _puddleVertices;\n    private MeshRenderer _renderer;\n    private bool _isFrozen = false;\n    private float _currentRippleTimer = 0f;\n    private float _originalPuddleSize;\n    private float _originalHeight;\n    \n    void Start()\n    {\n        InitializeWaterPhysics();\n        InitializeVisualEffects();\n        InitializeAudio();\n        \n        if (_puddleMaterial != null)\n        {\n            _renderer = GetComponent<MeshRenderer>();\n            _puddleVertices = new Vector3[_puddleMaterial.vertexCount];\n            for (int i = 0; i < _puddleMaterial.vertexCount; i++)\n            {\n                _puddleVertices[i] = transform.position;\n            }\n        }\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateWaterRipples();\n        UpdateVisualEffects();\n        UpdateAudio();\n        \n        if (_isFrozen)\n        {\n            FreezePuddle();\n        }\n    }\n    \n    void InitializeWaterPhysics()\n    {\n        _maxRippleForce = Mathf.Max(_maxRippleForce, 1f);\n        _evaporationSpeed = Mathf.Max(0.1f, _evaporationSpeed);\n        \n        Collider puddleCollider = GetComponent<Collider>();\n        if (puddleCollider != null)\n        {\n            puddleCollider.isTrigger = true;\n        }\n    }\n    \n    void InitializeVisualEffects()\n    {\n        if (_puddleMaterial == null) return;\n        \n        _renderer = GetComponent<MeshRenderer>();\n        if (_renderer == null)\n        {\n            _renderer = gameObject.AddComponent<MeshRenderer>();\n        }\n        \n        _originalPuddleSize = _puddleMaterial.vertexCount * _waveHeight;\n        _originalHeight = _puddleMaterial.vertexCount / 2f;\n    }\n    \n    void InitializeAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_splashSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _splashSound;\n            _audioSource.volume = _volume * 0.5f;\n            _audioSource.Play();\n        }\n    }\n    \n    void HandleInput()\n    {\n        Collider puddleCollider = GetComponent<Collider>();\n        if (puddleCollider == null) return;\n        \n        Rigidbody puddleRigidbody = puddleCollider.GetComponent<Rigidbody>();\n        if (puddleRigidbody != null)\n        {\n            float velocityMagnitude = puddleRigidbody.velocity.magnitude;\n            \n            // Detect freezing\n            if (_freezeThreshold <= velocityMagnitude && !_isFrozen)\n            {\n                _isFrozen = true;\n                StartCoroutine(FreezePuddle());\n            }\n        }\n    }\n    \n    void UpdateWaterRipples()\n    {\n        if (!_puddleMaterial || _renderer == null) return;\n        \n        float timeScale = Time.deltaTime / _rippleDuration;\n        float normalizedTime = (timeScale * 2f - 1f) * 0.5f; // Normalize to [-1,1]\n        \n        for (int i = 0; i < _puddleMaterial.vertexCount; i++)\n        {\n            Vector3 originalPosition = _puddleVertices[i];\n            \n            float distortion = _surfaceDistortionCurve.Evaluate(normalizedTime);\n            _puddleVertices[i] = originalPosition + \n                (originalPosition - originalPosition) * \n                (distortion * _waveHeight);\n        }\n    }\n    \n    void UpdateVisualEffects()\n    {\n        if (_puddleMaterial == null || _renderer == null) return;\n        \n        float newPuddleSize = _puddleMaterial.vertexCount * _waveHeight * 0.8f;\n        _puddleMaterial.SetFloat(\"_WaveHeight\", Mathf.Clamp(newPuddleSize / _originalPuddleSize, 0.1f, 1f));\n    }\n    \n    void UpdateAudio()\n    {\n        if (_audioSource == null || _splashSound == null) return;\n        \n        float timeScale = Time.deltaTime / _evaporationSpeed;\n        float normalizedTime = (timeScale * 2f - 1f) * 0.5f; // Normalize to [-1,1]\n        \n        _audioSource.volume = Mathf.Lerp(0f, _volume, normalizedTime);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!IsValidWaterObject(other)) return;\n        \n        float velocityMagnitude = GetObjectVelocity(other);\n        ApplyRippleEffect(velocityMagnitude, other.transform.position);\n        PlaySplashSound();\n    }\n    \n    private bool IsValidWaterObject(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\")) return false;\n        \n        // Check if object is water or fluid\n        if (!other.CompareTag(\"Water\") && !other.CompareTag(\"Liquid\")) return false;\n        \n        // Check layer mask\n        return (_waterLayerMask.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    private float GetObjectVelocity(Collider other)\n    {\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null) return 0f;\n        \n        return rb.velocity.magnitude;\n    }\n    \n    private void ApplyRippleEffect(float velocity, Vector3 impactPoint)\n    {\n        // Calculate ripple radius based on velocity\n        float rippleRadius = Mathf.Max(0.1f, velocity * 0.5f);\n        float timeScale = Time.deltaTime / _rippleDuration;\n        \n        for (int i = -rippleRadius * 10; i <= rippleRadius * 10; i++)\n        {\n            Vector3 center = impactPoint + transform.forward * i;\n            float distance = Vector3.Distance(transform.position, center);\n            \n            if (distance > rippleRadius) continue;\n            \n            float normalizedDistance = (i / rippleRadius) - 1f;\n            float distortion = _rippleIntensityCurve.Evaluate(normalizedDistance);\n            _puddleVertices[GetVertexIndex(center)] += \n                (center - _puddleVertices[GetVertexIndex(transform.position)]) * distortion;\n        }\n    }\n    \n    private int GetVertexIndex(Vector3 position)\n    {\n        float minDist = float.MaxValue;\n        int index = -1;\n        \n        for (int i = 0; i < _puddleMaterial.vertexCount; i++)\n        {\n            if (_puddleVertices[i] == null) continue;\n            \n            float distance = Vector3.Distance(_puddleVertices[i], position);\n            if (distance < minDist)\n            {\n                minDist = distance;\n                index = i;\n            }\n        }\n        \n        return index;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _waveHeight);\n        \n        // Draw ripple effect\n        for (int i = -5; i <= 5; i++)\n        {\n            Vector3 center = transform.position + transform.forward * i;\n            float distance = Vector3.Distance(transform.position, center);\n            float normalizedDistance = (i / 5f) - 1f;\n            \n            if (distance > _waveHeight) continue;\n            \n            Color rippleColor = Color.green;\n            float rippleIntensity = _rippleOverTime.Evaluate(normalizedDistance * 0.5f);\n            rippleColor.a = Mathf.Lerp(0.8f, 1f, rippleIntensity);\n            Gizmos.DrawWireSphere(center, distance * 0.3f);\n        }\n    }\n    \n    private void FreezePuddle()\n    {\n        _isFrozen = true;\n        \n        if (_puddleMaterial != null)\n        {\n            _puddleMaterial.SetFloat(\"_WaveHeight\", 0.1f);\n        }\n        \n        // Add ice visual effect\n        MeshRenderer iceRenderer = gameObject.AddComponent<MeshRenderer>();\n        iceRenderer.material = new Material(Shader.Find(\"Standard\",\n            new MaterialSettings()\n            {\n                SetColor = \"blue\",\n                SetBlend = \"Additive\"\n            }\n        );\n        \n        iceRenderer.material.SetFloat(\"_WaveHeight\", 0.3f);\n        iceRenderer.material.SetInt(\"_Mode\", (int)UnityEngine.RenderingModes.Smoother);\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_isFrozen)\n        {\n            Gizmos.color = Color.white;\n            Gizmos.DrawWireSphere(transform.position, _waveHeight * 0.8f);\n            \n            // Draw ripple effect\n            for (int i = -5; i <= 5; i++)\n            {\n                Vector3 center = transform.position + transform.forward * i;\n                float distance = Vector3.Distance(transform.position, center);\n                float normalizedDistance = (i / 5f) - 1f;\n                \n                if (distance > _waveHeight * 0.8f) continue;\n                \n                Color rippleColor = Color.green;\n                float rippleIntensity = _rippleOverTime.Evaluate(normalizedDistance * 0.5f);\n                rippleColor.a = Mathf.Lerp(0.6f, 1f, rippleIntensity);\n                Gizmos.DrawWireSphere(center, distance * 0.3f);\n            }\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.63)",
      "Animation.GetClipCount (0.62)",
      "Animation.IsPlaying (0.61)",
      "Physics.ContactModifyEventCCD (0.61)",
      "ParticleSystem.TrailModule (0.60)",
      "ParticleSystem.TextureSheetAnimationModule (0.60)",
      "ParticleSystem.RotationBySpeedModule (0.60)",
      "Animations.AnimationPlayableOutput (0.42)",
      "PhysicsVisualizationSettings.InitDebugDraw (0.42)",
      "ParticleSystemShapeMultiModeValue.BurstSpread (0.42)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class WaterPuddle : MonoBehaviour\n{\n    [Header(\"Water Settings\")]\n    [SerializeField] private float _maxVolume = 1f;\n    [SerializeField] private float _currentVolume = 0.5f;\n    [SerializeField] private float _evaporationRate = 0.05f;\n    [SerializeField] private float _freezeThreshold = -2f;\n    [SerializeField] private LayerMask _waterLayerMask = -1;\n    \n    [Header(\"Ripple Effects\")]\n    [SerializeField] private float _rippleRadius = 5f;\n    [SerializeField] private float _rippleHeight = 0.3f;\n    [SerializeField] private float _rippleSpeed = 2f;\n    [SerializeField] private AnimationCurve _rippleDecay = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _splashSounds;\n    [SerializeField] private float _audioVolume = 0.3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _steamParticles;\n    [SerializeField] private ParticleSystem _iceParticles;\n    [SerializeField] private Material _waterMaterial;\n    [SerializeField] private Renderer _renderer;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _waterDrag = 0.8f;\n    [SerializeField] private float _waterAngularDrag = 0.5f;\n    [SerializeField] private bool _useRigidbody = true;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Renderer _visualRenderer;\n    private Material _currentMaterial;\n    private Color _baseColor = Color.cyan;\n    private float _baseTransparency = 0.7f;\n    private float _waterTemperature = 20f;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupWaterMaterial();\n        UpdatePuddleState();\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _visualRenderer = GetComponent<Renderer>();\n        \n        if (_renderer != null && _waterMaterial != null)\n            _currentMaterial = _waterMaterial;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void SetupWaterMaterial()\n    {\n        if (_visualRenderer != null && _waterMaterial != null)\n        {\n            _currentMaterial.color = _baseColor;\n            _currentMaterial.SetFloat(\"_Transparency\", _baseTransparency);\n            \n            // Add water effects\n            _visualRenderer.material.SetFloat(\"_Shininess\", 1f);\n            _visualRenderer.material.SetFloat(\"_Emission\", 0.5f);\n            _visualRenderer.material.SetFloat(\"_EmissionColor\", new Color(0.2f, 0.6f, 1f, 0.8f));\n            \n            // Add ripple effect\n            _visualRenderer.material.SetVector(\"_Ripple\", new Vector4(0f, 0f, 0f, 0f));\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWaterPhysics();\n        UpdateVisualEffects();\n        UpdateAudio();\n        CheckFreezeCondition();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            ApplyImpulse(0.5f, 1f);\n        }\n        \n        if (Input.GetKey(KeyCode.LeftShift) && _useRigidbody)\n        {\n            _rigidbody.drag = _waterDrag;\n            _rigidbody.angularDrag = _waterAngularDrag;\n        }\n    }\n    \n    private void ApplyImpulse(float force, float impulse)\n    {\n        Vector3 impulseDirection = Random.insideUnitSphere;\n        impulseDirection.y = 0.5f; // Upward splash\n        impulseDirection.Normalize();\n        \n        if (force > 0)\n            _rigidbody.AddForce(impulseDirection * force, ForceMode.Impulse);\n        else\n            _rigidbody.AddImpulse(impulseDirection * impulse);\n    }\n    \n    private void UpdateWaterPhysics()\n    {\n        if (_useRigidbody && _rigidbody != null)\n        {\n            _rigidbody.drag = _waterDrag;\n            _rigidbody.angularDrag = _waterAngularDrag;\n            \n            // Add random water movement\n            Vector3 randomMovement = Random.insideUnitSphere * 0.1f;\n            randomMovement.y = Mathf.Sin(Time.time * 2f) * 0.05f;\n            _rigidbody.AddForce(randomMovement, ForceMode.Acceleration);\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_visualRenderer != null)\n        {\n            // Ripple animation\n            float time = Time.time;\n            Vector4 ripple = new Vector4(\n                Mathf.Sin(time * 5f) * 0.1f,\n                Mathf.Cos(time * 3f) * 0.05f,\n                Mathf.Sin(time * 2f + Time.deltaTime * 0.8f) * 0.08f,\n                Mathf.Cos(time * 4f) * 0.02f\n            );\n            _visualRenderer.material.SetVector(\"_Ripple\", ripple);\n            \n            // Temperature-based color shift\n            float temperatureFactor = Mathf.Exp2(_waterTemperature / 20f - 1f);\n            Color targetColor = _baseColor;\n            targetColor.a = Mathf.Lerp(0.7f, 0.3f, temperatureFactor * 0.5f);\n            targetColor *= new Color(temperatureFactor * 0.6f, temperatureFactor * 0.8f, temperatureFactor * 1.2f, 1f);\n            \n            _currentMaterial.color = targetColor;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _splashSounds.Length > 0)\n        {\n            float volume = Mathf.Lerp(0.3f, 0.7f, _waterTemperature / 20f);\n            volume *= 0.8f;\n            \n            AudioSourceClip clip = _audioSource.clip;\n            if (clip == null) return;\n            \n            // Play random splash sound\n            int index = Random.Range(0, _splashSounds.Length);\n            float pitch = Mathf.Lerp(1f, 2f, _waterTemperature / 20f * 0.5f);\n            clip.pitch = pitch;\n            clip.volume = volume;\n            _audioSource.PlayOneShot(_splashSounds[index]);\n        }\n    }\n    \n    private void CheckFreezeCondition()\n    {\n        if (_waterTemperature <= _freezeThreshold)\n        {\n            FreezePuddle();\n        }\n    }\n    \n    private void FreezePuddle()\n    {\n        if (_useRigidbody && _rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n            \n            // Add ice physics\n            _rigidbody.drag = 0.95f;\n            _rigidbody.angularDrag = 1f;\n        }\n        \n        if (_steamParticles != null)\n            _steamParticles.Stop();\n            \n        if (_iceParticles != null)\n            _iceParticles.Stop();\n    }\n    \n    private void UpdatePuddleState()\n    {\n        // Evaporation\n        float evaporationAmount = _evaporationRate * Time.deltaTime;\n        _currentVolume -= evaporationAmount;\n        \n        // Ripple decay over time\n        float rippleDecayAmount = 0.1f + 0.9f * Mathf.Exp(-_waterTemperature / 100f);\n        _visualRenderer.material.SetVector(\"_Ripple\", new Vector4(\n            Mathf.Sin(Time.time * 5f) * 0.1f * rippleDecayAmount,\n            Mathf.Cos(Time.time * 3f) * 0.05f * rippleDecayAmount,\n            Mathf.Sin(Time.time * 2f + Time.deltaTime * 0.8f) * 0.08f * rippleDecayAmount,\n            Mathf.Cos(Time.time * 4f) * 0.02f * rippleDecayAmount\n        ));\n        \n        // Temperature drift\n        _waterTemperature += Random.Range(-5f, 10f) * Time.deltaTime;\n    }\n    \n    private void InitializeWater()\n    {\n        if (_useRigidbody)\n        {\n            _rigidbody.drag = _waterDrag;\n            _rigidbody.angularDrag = _waterAngularDrag;\n        }\n        \n        // Add water physics components\n        if (!_useRigidbody)\n        {\n            Rigidbody waterRb = gameObject.AddComponent<Rigidbody>();\n            waterRb.drag = _waterDrag;\n            waterRb.angularDrag = _waterAngularDrag;\n            \n            AudioSource audioSource = gameObject.AddComponent<AudioSource>();\n            audioSource.volume = 0.3f;\n            audioSource.pitch = 1f;\n        }\n    }\n    \n    private void InitializeParticles()\n    {\n        if (_steamParticles == null)\n            _steamParticles = GetComponentInChildren<ParticleSystem>();\n        \n        if (_iceParticles == null)\n            _iceParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    public void AddWaterVolume(float amount)\n    {\n        _currentVolume += amount;\n        _waterTemperature += amount * 0.5f; // Heat from volume addition\n        UpdatePuddleState();\n    }\n    \n    public void RemoveWaterVolume(float amount)\n    {\n        _currentVolume -= amount;\n        if (_currentVolume < 0) _currentVolume = 0;\n        _waterTemperature -= amount * 0.3f; // Cool from removal\n        UpdatePuddleState();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _rippleRadius);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position, new Vector3(0.5f, 0.5f, 0.5f));\n        \n        // Show ripple effect\n        float time = Time.time;\n        Vector4 ripple = new Vector4(\n            Mathf.Sin(time * 5f) * 0.1f,\n            Mathf.Cos(time * 3f) * 0.05f,\n            Mathf.Sin(time * 2f + Time.deltaTime * 0.8f) * 0.08f,\n            Mathf.Cos(time * 4f) * 0.02f\n        );\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, ripple.x * _rippleRadius + transform.forward);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_rigidbody != null)\n            _rigidbody.enabled = false;\n        \n        if (_audioSource != null)\n            _audioSource.Stop();\n            \n        if (_visualRenderer != null && _waterMaterial != null)\n            _visualRenderer.material = null;\n    }\n}",
    "per_behavior_docs": 15,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "handle_impact": [
        "Collider.OnCollisionEnter (0.72)",
        "Collider.OnCollisionStay (0.71)",
        "Collider.OnCollisionExit (0.71)"
      ],
      "reflect_light": [
        "Light.SetLightDirty (0.68)",
        "Light.AddCommandBufferAsync (0.67)",
        "Light.AddCommandBuffer (0.65)"
      ],
      "evaporate_water": [
        "ParticleSystem.Play (0.72)",
        "ParticleSystem.EmissionModule (0.72)",
        "ParticleSystem.ColorOverLifetimeModule (0.72)"
      ],
      "freeze_puddle": [
        "Material.ApplyPropertyOverride (0.67)",
        "Material.GetFloat (0.67)",
        "Material.GetTextureOffset (0.66)"
      ],
      "maintain_puddle_state": [
        "Transform.GetPositionAndRotation (0.70)",
        "Transform.SetLocalPositionAndRotation (0.70)",
        "Transform.Translate (0.70)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 56,
        "justification": "Direct translation lacks clear separation of concerns, methods are somewhat bloated. Good Unity component usage but lacks clear modular design."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 70,
        "justification": "Strong structured approach with clear initialization methods, good use of Unity patterns, and modular design. Intermediate representation helps create more organized code."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 7,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 59,
        "justification": "Attempts granular behavior separation but feels less cohesive. Component initialization is solid, but lacks depth in specific water interactions."
      },
      "winner": "ir_monolithic",
      "key_differences": "Intermediate representation allows more structured code generation, with clear method responsibilities and better separation of concerns compared to direct translation.",
      "advantages": "The IR monolithic approach provides a balanced blend of modularity, Unity best practices, and clear code structure. It generates more maintainable code by breaking down complex behaviors into distinct initialization and update methods."
    },
    "error": null
  },
  {
    "prompt_num": 19,
    "prompt": "Make a mirror that reflects the player's movement with 0.5 second delay, plays ethereal echo sounds of player actions, occasionally glitches showing distorted reflection with static sounds, and if stared at for 10 seconds straight, the reflection winks and waves independently.",
    "timestamp": "2026-01-08T23:01:38.492736",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class Mirror : MonoBehaviour\n{\n    [Header(\"Reflection Settings\")]\n    [SerializeField] private float _reflectionDelay = 0.5f;\n    [SerializeField] private bool _enableReflection = true;\n    [SerializeField] private Vector3 _reflectionOffset = Vector3.zero;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _etherealEchoSounds;\n    [SerializeField] private float _audioVolume = 1f;\n    [SerializeField] private float _audioPitch = 0.8f;\n    [SerializeField] private bool _playOnPlayerAction = true;\n    \n    [Header(\"Glitch Settings\")]\n    [SerializeField] private float _glitchInterval = 2f;\n    [SerializeField] private float _glitchDuration = 1.5f;\n    [SerializeField] private float _glitchForce = 0.3f;\n    [SerializeField] private bool _enableGlitches = true;\n    \n    [Header(\"Wink Settings\")]\n    [SerializeField] private float _winkInterval = 8f;\n    [SerializeField] private float _winkDuration = 0.2f;\n    [SerializeField] private bool _enableWinking = true;\n    \n    private AudioSource _audioSource;\n    private Camera _reflectionCamera;\n    private Renderer _mirrorRenderer;\n    private Material _originalMaterial;\n    private Vector3[] _targetPositions;\n    private float[] _targetRotations;\n    private bool[] _isTargeted;\n    private Coroutine _glitchCoroutine;\n    private Coroutine _winkCoroutine;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _reflectionCamera = Camera.main;\n        if (_reflectionCamera == null)\n        {\n            GameObject mainCamObject = new GameObject(\"MainCamera\");\n            mainCamObject.transform.SetParent(transform);\n            mainCamObject.transform.localPosition = Vector3.zero;\n            mainCamObject.transform.localRotation = Quaternion.identity;\n            mainCamObject.AddComponent<Camera>();\n            _reflectionCamera = mainCamObject.GetComponent<Camera>();\n            if (_reflectionCamera == null)\n            {\n                Debug.LogError(\"No camera found on main object!\");\n            }\n        }\n        \n        _mirrorRenderer = GetComponent<Renderer>();\n        if (_mirrorRenderer != null)\n        {\n            _originalMaterial = _mirrorRenderer.material;\n            \n            // Create reflection material\n            Material reflectionMaterial = new Material(Shader.Find(\"Sprites/Default\"));\n            reflectionMaterial.SetColor(\"_Color\", _originalMaterial.color);\n            reflectionMaterial.SetFloat(\"_Mode\", 2.0f); // Reflection mode\n            \n            // Add distortion effect\n            reflectionMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlphaToOne;\n            reflectionMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            reflectionMaterial.SetFloat(\"_DistortionAmount\", 2.0f);\n            \n            // Add static noise\n            reflectionMaterial.AddKeyword(\"_Static\", true);\n            reflectionMaterial.SetColor(\"_StaticColor\", Color.white);\n            \n            _mirrorRenderer.material = reflectionMaterial;\n        }\n        \n        SetupReflectionTargets();\n        _glitchCoroutine = StartCoroutine(MirrorGlitches());\n        _winkCoroutine = StartCoroutine(MirrorWinks());\n    }\n    \n    void SetupReflectionTargets()\n    {\n        GameObject[] targets = new GameObject[_reflectionCamera.transform.childCount];\n        Vector3[] positions = new Vector3[_reflectionCamera.transform.childCount];\n        float[] rotations = new float[_reflectionCamera.transform.childCount];\n        \n        for (int i = 0; i < _reflectionCamera.transform.childCount; i++)\n        {\n            targets[i] = _reflectionCamera.transform.GetChild(i).gameObject;\n            positions[i] = _reflectionCamera.transform.GetChild(i).localPosition;\n            rotations[i] = _reflectionCamera.transform.GetChild(i).localEulerAngles.x;\n        }\n        \n        _targetPositions = positions;\n        _targetRotations = new float[_reflectionCamera.transform.childCount * 3];\n        for (int i = 0; i < targets.Length; i++)\n        {\n            _targetRotations[i * 3] = rotations[i].x;\n            _targetRotations[i * 3 + 1] = rotations[i].y;\n            _targetRotations[i * 3 + 2] = rotations[i].z;\n        }\n        \n        _isTargeted = new bool[_reflectionCamera.transform.childCount];\n    }\n    \n    void Update()\n    {\n        if (!_enableReflection) return;\n        \n        // Handle glitches\n        if (_enableGlitches && _glitchCoroutine != null)\n        {\n            ApplyGlitch();\n        }\n        \n        // Handle winking\n        if (_enableWinking && _winkCoroutine != null)\n        {\n            CheckForStare();\n        }\n    }\n    \n    void ApplyGlitch()\n    {\n        for (int i = 0; i < _targetPositions.Length; i++)\n        {\n            Vector3 originalPos = _targetPositions[i];\n            float[] newRotation = _targetRotations[i * 3..(i * 3 + 2)];\n            \n            // Add random noise\n            float x = Random.Range(-_glitchForce, _glitchForce);\n            float y = Random.Range(-_glitchForce, _glitchForce);\n            float z = Random.Range(-_glitchForce, _glitchForce);\n            \n            newRotation[0] += x;\n            newRotation[1] += y;\n            newRotation[2] += z;\n            \n            // Apply rotation\n            Quaternion targetRotation = Quaternion.Euler(newRotation[0], newRotation[1], newRotation[2]);\n            _targetPositions[i] = originalPos + targetRotation * 5f;\n        }\n        \n        // Play static noise\n        AudioSource.PlayClipAtPoint(StaticNoiseClip, transform.position);\n    }\n    \n    void CheckForStare()\n    {\n        for (int i = 0; i < _isTargeted.Length; i++)\n        {\n            if (_isTargeted[i])\n            {\n                StartCoroutine(Wink());\n                break;\n            }\n        }\n    }\n    \n    IEnumerator Wink()\n    {\n        for (float t = 0f; t <= 1f; t += Time.deltaTime)\n        {\n            float progress = t / _winkDuration;\n            Vector3 offset = _reflectionOffset * Mathf.Sin(progress * Mathf.PI * 2f);\n            \n            if (_reflectionCamera != null)\n            {\n                _reflectionCamera.transform.position += offset;\n            }\n            \n            yield return null;\n        }\n        \n        // Return to original position\n        if (_reflectionCamera != null)\n        {\n            _reflectionCamera.transform.position -= _reflectionOffset;\n        }\n    }\n    \n    void SetupAudio()\n    {\n        if (_audioSource == null) return;\n        \n        for (int i = 0; i < _etherealEchoSounds.Length; i++)\n        {\n            if (_audioSource.clip == null)\n            {\n                _audioSource.clip = _etherealEchoSounds[i];\n            }\n            else\n            {\n                _audioSource.PlayOneShot(_audioSource.clip, _audioVolume * 0.5f);\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_enableReflection && other.CompareTag(\"Player\"))\n        {\n            SetupAudio();\n        }\n    }\n    \n    IEnumerator MirrorGlitches()\n    {\n        while (true)\n        {\n            if (_enableGlitches)\n            {\n                ApplyGlitch();\n            }\n            \n            yield return new WaitForSeconds(_glitchInterval);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!string.IsNullOrEmpty(other.name) && \n            !other.CompareTag(\"Player\") &&\n            !_enableReflection)\n        {\n            SetupAudio();\n        }\n    }\n    \n    public void ToggleReflection()\n    {\n        _enableReflection = !_enableReflection;\n        \n        if (_enableReflection)\n        {\n            // Re-enable triggers\n            GetComponent<Collider>().isTrigger = true;\n            GetComponent<ParticleSystem>().enabled = false;\n        }\n        else\n        {\n            // Disable triggers\n            GetComponent<Collider>().isTrigger = false;\n            GetComponent<ParticleSystem>().enabled = true;\n            \n            // Clear audio source clip if any\n            if (_audioSource != null && _audioSource.clip != null)\n            {\n                _audioSource.Stop();\n                _audioSource.clip = null;\n            }\n        }\n    }\n    \n    private AudioSource StaticNoiseClip\n    {\n        get { return GetComponent<AudioSource>(); }\n    }\n    \n    private void OnValidate()\n    {\n        _reflectionDelay = Mathf.Max(0f, _reflectionDelay);\n        _glitchInterval = Mathf.Max(0f, _glitchInterval);\n        _winkDuration = Mathf.Max(0.1f, _winkDuration);\n    }\n}",
    "ir_json": {
      "class_name": "EtherealMirror",
      "components": [
        "Renderer",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "reflectionIntensity",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "glitchInterval",
          "type": "float",
          "default": 5.0
        },
        {
          "name": "winkDuration",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "winkCooldown",
          "type": "float",
          "default": 3.0
        }
      ],
      "behaviors": [
        {
          "name": "update_reflection",
          "trigger": "every frame",
          "actions": [
            {
              "action": "compute player position and facing direction"
            },
            {
              "action": "calculate reflection based on delay (0.5 seconds) and player velocity"
            },
            {
              "action": "set mirror surface to reflect computed light positions"
            },
            {
              "action": "adjust reflection intensity based on distance from player"
            }
          ]
        },
        {
          "name": "play_echo",
          "trigger": "when player performs action near mirror",
          "actions": [
            {
              "action": "listen for audio events from player actions"
            },
            {
              "action": "delay playback by 0.5 seconds"
            },
            {
              "action": "loop echo sound around mirror surface"
            },
            {
              "action": "adjust volume based on distance to player"
            }
          ]
        },
        {
          "name": "glitch_reflection",
          "trigger": "every glitch interval second",
          "actions": [
            {
              "action": "apply random distortion effects to reflection"
            },
            {
              "action": "add subtle static noise texture to mirror surface"
            },
            {
              "action": "invert colors for half of the reflection area"
            }
          ]
        },
        {
          "name": "wink_behavior",
          "trigger": "when player stares at mirror continuously for wink duration seconds",
          "actions": [
            {
              "action": "detect if player has been looking at mirror without breaking gaze"
            },
            {
              "action": "start blinking pattern in reflection every wink cooldown seconds"
            },
            {
              "action": "make reflection wave up and down slightly"
            },
            {
              "action": "play synchronized ethereal chime sound effect"
            }
          ]
        },
        {
          "name": "stop_winking",
          "trigger": "when player looks away from mirror or breaks gaze",
          "actions": [
            {
              "action": "stop blinking animation"
            },
            {
              "action": "return reflection to normal state"
            },
            {
              "action": "pause echo sound for 0.5 seconds"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class EtherealMirror : MonoBehaviour\n{\n    [Header(\"Reflection Settings\")]\n    [SerializeField] private float _reflectionDelay = 0.5f;\n    [SerializeField] private float _maxReflectionIntensity = 1.8f;\n    [SerializeField] private LayerMask _reflectionLayers = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _echoClips;\n    [SerializeField] private float _baseVolume = 0.3f;\n    [SerializeField] private float _volumeScale = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _glitchParticles;\n    [SerializeField] private GameObject _glitchEffectPrefab;\n    [SerializeField] private float _glitchInterval = 5f;\n    [SerializeField] private int _targetLayer = -1;\n    [SerializeField] private Material _baseMaterial;\n    \n    private Renderer _renderer;\n    private Camera _playerCamera;\n    private Transform _playerTransform;\n    private bool _isPlayerLookingAtMirror = false;\n    private Coroutine _glitchCoroutine;\n    private float _lastGlitchTime;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupMaterial();\n        \n        if (_renderer == null)\n            _renderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_glitchParticles != null)\n            _glitchCoroutine = StartCoroutine(GlitchEffectRoutine());\n    }\n    \n    private void InitializeComponents()\n    {\n        _playerCamera = Camera.main;\n        _playerTransform = transform;\n        \n        if (_renderer == null)\n        {\n            _renderer = GetComponent<Renderer>();\n            if (_renderer == null)\n                _renderer = gameObject.AddComponent<Renderer>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void SetupMaterial()\n    {\n        if (_baseMaterial != null && _renderer.material != _baseMaterial)\n        {\n            _renderer.material = new Material(_baseMaterial);\n        }\n        \n        UpdateMaterialProperties();\n    }\n    \n    private void UpdateMaterialProperties()\n    {\n        if (_renderer.material == null) return;\n        \n        Color baseColor = _renderer.material.color;\n        float intensity = Mathf.Clamp01(baseColor.a * _maxReflectionIntensity);\n        _renderer.material.color = new Color(baseColor.r, baseColor.g, baseColor.b, intensity);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsPlayerNearby(other))\n        {\n            StartLookingAtMirror(other.transform);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsPlayerNearby(other.transform))\n        {\n            StopLookingAtMirror();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, 0.3f);\n        \n        Gizmos.color = new Color(1f, 0.5f, 0.2f);\n        Gizmos.DrawWireCube(transform.position + Vector3.up * 0.4f, Vector3.one);\n    }\n    \n    private bool IsPlayerNearby(Transform playerTransform)\n    {\n        float distance = Vector3.Distance(transform.position, playerTransform.position);\n        return distance <= 1.5f;\n    }\n    \n    private void StartLookingAtMirror(Transform player)\n    {\n        _isPlayerLookingAtMirror = true;\n        _playerTransform = player;\n        \n        if (_audioSource != null && _echoClips.Length > 0)\n        {\n            PlayEchoEffect();\n        }\n    }\n    \n    private void StopLookingAtMirror()\n    {\n        _isPlayerLookingAtMirror = false;\n        _playerTransform = null;\n        \n        if (_audioSource != null && _echoClips.Length > 0)\n        {\n            StopEchoEffect();\n        }\n    }\n    \n    private void PlayEchoEffect()\n    {\n        if (_audioSource == null || _echoClips.Length == 0) return;\n        \n        float volume = _baseVolume * Mathf.Pow(_distanceToPlayer, -_volumeScale);\n        volume = Mathf.Clamp(volume, 0.1f, 1f);\n        \n        AudioSource.PlayClipAtPoint(_echoClips[Random.Range(0, _echoClips.Length)], \n            new Vector3(transform.position.x + 2f * Random.insideUnit2D.x, transform.position.y, 0), volume);\n    }\n    \n    private void StopEchoEffect()\n    {\n        if (_audioSource != null && _echoClips.Length > 0)\n        {\n            AudioSource.StopClipAtPoint(_echoClips[Random.Range(0, _echoClips.Length)]);\n        }\n    }\n    \n    private float DistanceToPlayer()\n    {\n        if (_playerTransform == null) return Mathf.Infinity;\n        \n        return Vector3.Distance(transform.position, _playerTransform.position);\n    }\n    \n    private void Update()\n    {\n        if (!_isPlayerLookingAtMirror || !_playerCamera != Camera.main) return;\n        \n        float distance = DistanceToPlayer();\n        float intensity = Mathf.Clamp01(Mathf.Lerp(0.5f, 1f, 1f - (distance / 3f)));\n        _renderer.material.color = new Color(_renderer.material.color.r, \n            _renderer.material.color.g, _renderer.material.color.b, intensity);\n    }\n    \n    private IEnumerator GlitchEffectRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_glitchInterval);\n            \n            if (_glitchParticles != null)\n                _glitchParticles.Play();\n                \n            if (_glitchEffectPrefab != null && _renderer.material != null)\n            {\n                GameObject glitchObject = Instantiate(_glitchEffectPrefab, \n                    transform.position + Random.insideUnit3D * 2f, Quaternion.identity);\n                Destroy(glitchObject, new System.Random().Next(1, 5));\n            }\n        }\n    }\n    \n    public void ForceReflection(float intensity = 1.0f)\n    {\n        if (_renderer != null && _renderer.material != null)\n        {\n            Color currentColor = _renderer.material.color;\n            float newIntensity = Mathf.Clamp01(currentColor.a * intensity);\n            _renderer.material.color = new Color(currentColor.r, currentColor.g, currentColor.b, newIntensity);\n        }\n    }\n    \n    public void ResetToOriginalState()\n    {\n        if (_baseMaterial != null && _renderer.material != null)\n        {\n            _renderer.material = _baseMaterial;\n        }\n        \n        UpdateMaterialProperties();\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 7,
    "ir_rag_doc_names": [
      "Animation.IsPlaying (0.62)",
      "Animation.PlayQueued (0.61)",
      "Animation.Blend (0.61)",
      "Animator.PlayInFixedTime (0.60)",
      "ReflectionProbe.IsFinishedRendering (0.43)",
      "ReflectionProbe.BlendCubemap (0.41)",
      "ReflectionProbe.RenderProbe (0.40)"
    ],
    "per_behavior_code": "using UnityEngine;\n\npublic class MirrorBehavior : MonoBehaviour\n{\n    [Header(\"Mirror Settings\")]\n    public bool isMirrorActive = true;\n    public float reflectionDelay = 0.5f;\n    public float mirrorTransparency = 0.3f;\n    public float stareThreshold = 10f;\n    \n    [Header(\"Audio Settings\")]\n    public AudioSource audioSource;\n    public AudioClip[] interactionSounds;\n    private int currentSoundIndex = 0;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem dustEffect;\n    public GameObject flickeringEffect;\n    public Light[] lightSources;\n    private Material[] mirrorMaterials;\n    private float lastReflectionTime;\n    \n    private Transform playerTransform;\n    private Vector3 lastPlayerPosition;\n    private bool isPlayerVisible = true;\n    private bool playerIsLookingAtMirror = false;\n    private float stareTimer = 0f;\n    private Renderer[] mirrorRenderer;\n    private Collider[] mirrorCollider;\n    private Color originalColor;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupMirrors();\n    }\n    \n    void InitializeComponents()\n    {\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        if (dustEffect == null)\n            dustEffect = GetComponentInChildren<ParticleSystem>();\n            \n        if (flickeringEffect != null)\n            flickeringEffect.SetActive(false);\n            \n        lightSources = GetComponentsInChildren<Light>();\n        \n        mirrorMaterials = new Material[GetComponentsInChildren<Renderer>().Length];\n        for (int i = 0; i < mirrorMaterials.Length; i++)\n        {\n            mirrorMaterials[i] = GetComponentInChildren<Renderer>()?.material;\n            if (mirrorMaterials[i] == null)\n                mirrorMaterials[i] = lightSources[i].gameObject.GetComponent<Renderer>()?.material;\n        }\n    }\n    \n    void SetupMirrors()\n    {\n        if (!isMirrorActive) return;\n        \n        mirrorRenderer = new Renderer[GetComponentsInChildren<Renderer>().Length];\n        mirrorCollider = new Collider[GetComponentsInChildren<Collider>().Length];\n        \n        for (int i = 0; i < mirrorRenderer.Length; i++)\n        {\n            Renderer renderer = GetComponentInChildren<Renderer>()?.GetComponent<Renderer>();\n            if (renderer != null)\n                mirrorRenderer[i] = renderer;\n            \n            Collider collider = GetComponentInChildren<Collider>()?.GetComponent<Collider>();\n            if (collider != null)\n                mirrorCollider[i] = collider;\n        }\n        \n        // Store original colors\n        for (int i = 0; i < mirrorMaterials.Length; i++)\n        {\n            if (mirrorMaterials[i] == null) continue;\n            originalColor = new Color(mirrorMaterials[i].color);\n        }\n    }\n    \n    void Update()\n    {\n        if (!isMirrorActive || !playerIsLookingAtMirror) return;\n        \n        CheckPlayerVisibility();\n        UpdateReflection();\n        HandleStareBehavior();\n        PlayAudioEffects();\n        UpdateVisualEffects();\n    }\n    \n    private void CheckPlayerVisibility()\n    {\n        if (playerTransform == null)\n            playerVisible = false;\n        else\n        {\n            bool canSeePlayer = true;\n            \n            // Check line of sight to player\n            Vector3 directionToPlayer = (playerTransform.position - transform.position).normalized;\n            float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n            \n            if (distanceToPlayer > 20f)\n                playerVisible = false;\n            else\n            {\n                // Check for obstacles between mirror and player\n                Collider[] obstacles = Physics.OverlapSphere(transform.position + directionToPlayer * 5f, 0.1f);\n                \n                foreach (Collider obj in obstacles)\n                {\n                    if (!IsPlayerObject(obj))\n                        canSeePlayer = false;\n                    break;\n                }\n                \n                playerVisible = canSeePlayer;\n            }\n        }\n        \n        isPlayerLookingAtMirror = playerVisible && Vector3.Dot(transform.forward, directionToPlayer) > 0.9f;\n    }\n    \n    private bool IsPlayerObject(Collider obj)\n    {\n        if (obj.CompareTag(\"Player\"))\n            return true;\n            \n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        if (rb != null)\n            return rb.velocity.magnitude > 0.1f || rb.angularVelocity.magnitude > 0.1f;\n            \n        return false;\n    }\n    \n    private void UpdateReflection()\n    {\n        if (!isPlayerVisible) return;\n        \n        float currentTime = Time.time - lastReflectionTime;\n        if (currentTime >= reflectionDelay)\n        {\n            UpdateMirrorMaterial();\n            lastReflectionTime = Time.time;\n        }\n    }\n    \n    private void UpdateMirrorMaterial()\n    {\n        for (int i = 0; i < mirrorMaterials.Length; i++)\n        {\n            if (!mirrorMaterials[i].hasProperty(\"_Color\")) continue;\n            \n            Color newColor = CalculateReflectionColor(i);\n            mirrorMaterials[i].color = newColor;\n        }\n        \n        // Update transparency\n        for (int i = 0; i < mirrorRenderer.Length; i++)\n        {\n            if (mirrorRenderer[i] != null)\n                mirrorRenderer[i].material.SetFloat(\"_Alpha\", mirrorTransparency);\n        }\n    }\n    \n    private Color CalculateReflectionColor(int materialIndex)\n    {\n        Material mat = mirrorMaterials[materialIndex];\n        if (mat == null) return originalColor;\n        \n        // Find the light component\n        Light[] lights = lightSources;\n        float ambientIntensity = 0.5f;\n        Color reflectionColor = new Color(1f, 1f, 1f, 0.3f);\n        \n        for (int j = 0; j < lights.Length; j++)\n        {\n            Vector3 lightDirection = (lights[j].transform.position - transform.position).normalized;\n            float dotProduct = Vector3.Dot(transform.forward, lightDirection);\n            \n            if (dotProduct > 0.1f)\n            {\n                // Calculate specular reflection\n                Vector3 reflectedDir = Reflect(directionToPlayer, transform.forward * 2f * Dot(transform.forward, directionToPlayer));\n                \n                // Add ambient lighting\n                float ambientIntensity = 0.5f;\n                Color lightColor = new Color(lights[j].color);\n                lightColor.a *= 0.7f; // Reduce brightness\n                \n                reflectionColor += (1f - mat.HasProperty(\"_Emission\")) * \n                    Light.GetLightIntensity(reflectedDir, lights[j], ambientIntensity) * lightColor;\n            }\n        }\n        \n        return reflectionColor;\n    }\n    \n    private Vector3 Reflect(Vector3 direction, Vector3 normal)\n    {\n        float dot = Vector3.Dot(direction, normal);\n        Vector3 reflected = direction - 2f * dot * normal;\n        return reflected.normalized;\n    }\n    \n    private void HandleStareBehavior()\n    {\n        if (!playerIsLookingAtMirror || stareTimer <= 0f) return;\n        \n        stareTimer += Time.deltaTime;\n        \n        if (stareTimer >= stareThreshold)\n        {\n            StartStaringAnimation();\n        }\n    }\n    \n    private void StartStaringAnimation()\n    {\n        if (flickeringEffect != null)\n            flickeringEffect.SetActive(true);\n            \n        for (int i = 0; i < lightSources.Length; i++)\n        {\n            Light light = lightSources[i];\n            float intensity = 1.5f;\n            Color color = new Color(0.8f, 0.3f, 0.2f, 0.7f);\n            \n            // Add random flicker\n            float flickerAmount = Random.Range(-0.1f, 0.1f);\n            intensity += Mathf.Sin(Time.time * 5f) * flickerAmount;\n            color.a *= Mathf.Abs(Mathf.Sin(Time.time * 3f)) * 0.6f;\n            \n            light.intensity = intensity;\n            light.color = color;\n        }\n        \n        stareTimer = 0f;\n    }\n    \n    private void PlayAudioEffects()\n    {\n        if (audioSource == null || currentSoundIndex >= interactionSounds.Length)\n            return;\n            \n        AudioClip clip = interactionSounds[currentSoundIndex];\n        float pitchMultiplier = Random.Range(0.8f, 1.2f);\n        \n        // Apply random pitch\n        AudioSource.PlayClipAtPoint(clip.pitch * pitchMultiplier, transform.position);\n        currentSoundIndex = (currentSoundIndex + 1) % interactionSounds.Length;\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (!isMirrorActive || !playerIsLookingAtMirror) return;\n        \n        // Waving motion\n        float waveX = Mathf.Sin(Time.time * 2f) * 0.5f;\n        float waveZ = Mathf.Cos(Time.time * 3f) * 0.4f;\n        Vector3 wavingPosition = transform.position + new Vector3(waveX, 0f, waveZ);\n        \n        // Dust particles\n        if (dustEffect != null)\n            dustEffect.Play();\n            \n        // Flickering effect\n        if (flickeringEffect != null)\n        {\n            float flickerIntensity = Random.Range(0.1f, 0.3f);\n            flickeringEffect.SetActive(flickerIntensity > 0f);\n        }\n    }\n    \n    public void ActivateMirror()\n    {\n        isMirrorActive = true;\n    }\n    \n    public void DeactivateMirror()\n    {\n        if (isMirrorActive)\n        {\n            // Stop visual effects\n            for (int i = 0; i < lightSources.Length; i++)\n                lightSources[i].enabled = false;\n                \n            if (dustEffect != null)\n                dustEffect.Stop();\n            \n            // Disable flickering effect\n            if (flickeringEffect != null)\n                flickeringEffect.SetActive(false);\n        }\n        \n        isMirrorActive = false;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 2f);\n        \n        // Draw player position\n        if (playerTransform != null)\n            Gizmos.DrawLine(transform.position, playerTransform.position);\n            \n        // Draw reflection plane\n        Vector3 forward = transform.forward;\n        float distance = 5f;\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawRay(transform.position, forward * distance);\n        \n        // Draw mirror outline\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position, new Vector3(2f, 0.5f, 2f));\n    }\n}",
    "per_behavior_docs": 15,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "track_player_movement": [
        "Transform.GetPositionAndRotation (0.69)",
        "Transform.SetPositionAndRotation (0.69)",
        "Transform.GetLocalPositionAndRotation (0.67)"
      ],
      "apply_reflection_effect": [
        "Material.GetShaderPassEnabled (0.66)",
        "Material.SetShaderPassEnabled (0.65)",
        "Material.GetColor (0.64)"
      ],
      "play_audio_echo": [
        "AudioSource.PlayDelayed (0.61)",
        "Animator.StopRecording (0.61)",
        "Animator.PlayInFixedTime (0.61)"
      ],
      "trigger_glitch_effect": [
        "Random.Range (0.67)",
        "Random.InitState (0.65)",
        "Material.GetShaderPassEnabled (0.62)"
      ],
      "detect_staring": [
        "Animator.PlayInFixedTime (0.66)",
        "Animator.CrossFadeInFixedTime (0.66)",
        "WaitTimeoutMode (0.65)"
      ],
      "handle_stare_behavior": [
        "Animator.CrossFadeInFixedTime (0.63)",
        "WaitTimeoutMode (0.62)",
        "Animator.PlayInFixedTime (0.62)"
      ],
      "stop_staring_state": [
        "WaitTimeoutMode (0.65)",
        "WaitForSeconds (0.62)",
        "WaitForSecondsRealtime (0.62)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 5,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 47,
        "justification": "Direct translation lacks clear separation of concerns, with many responsibilities mixed in single class. Good Unity component setup, but overly complex initialization. Some useful serialized fields, but lacks clear method decomposition."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 68,
        "justification": "Strong component initialization, clear method separation, excellent use of Unity patterns. Modular design with well-defined private methods. Good error handling and component detection. Extensible architecture with clean separation of concerns."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 7,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 57,
        "justification": "Good initialization pattern, multiple method breakdown, but lacks focused implementation. Some redundant code and incomplete behavior implementations. Attempts modularity but feels scattered."
      },
      "winner": "ir_monolithic",
      "key_differences": "The monolithic IR approach provides the most structured, maintainable, and Unity-idiomatic implementation, with clear separation of concerns and extensible design.",
      "advantages": "Robust error handling, clean component management, excellent use of serialized fields, and a clear method-based architecture that makes future modifications straightforward."
    },
    "error": null
  },
  {
    "prompt_num": 20,
    "prompt": "Create a factory assembler that consumes resource objects dropped onto its intake, plays mechanical processing sounds for 3 seconds, then outputs a combined product with properties merged from inputs, tracking production statistics and playing achievement sounds at milestones.",
    "timestamp": "2026-01-08T23:07:23.946948",
    "oneshot_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class ResourceAssembler : MonoBehaviour\n{\n    [System.Serializable]\n    public class Resource\n    {\n        public string name;\n        public int amount;\n        public float durability;\n        public bool isConsumed = false;\n        \n        public Resource(string name, int amount, float durability)\n        {\n            this.name = name;\n            this.amount = amount;\n            this.durability = durability;\n        }\n    }\n\n    [System.Serializable]\n    public class Product\n    {\n        public string productName;\n        public int combinedAmount;\n        public float combinedDurability;\n        public List<string> componentNames = new List<string>();\n        \n        public Product(string productName, int amount, float durability, params string[] components)\n        {\n            this.productName = productName;\n            this(combinedAmount = amount, combinedDurability = durability);\n            componentNames.AddRange(components);\n        }\n    }\n\n    [Header(\"Assembling Settings\")]\n    [SerializeField] private List<string> validComponentNames = new List<string>();\n    [SerializeField] private int _minComponentsRequired = 2;\n    [SerializeField] private float _maxComponentCombination = 100f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _processingSounds;\n    [SerializeField] private AudioClip[] _achievementSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _particleEffect;\n    [SerializeField] private GameObject _assemblyCompletePrefab;\n\n    private List<Product> _assembledProducts = new List<Product>();\n    private int _totalAssemblies = 0;\n    private Dictionary<string, int> _productStatistics = new Dictionary<string, int>();\n\n    void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || !CanProcessObject(other.gameObject))\n            return;\n\n        Resource resource = other.GetComponentInParent<Resource>();\n        if (resource != null && !_resourceIsConsumed(resource))\n        {\n            ProcessResource(resource);\n        }\n    }\n\n    private bool CanProcessObject(GameObject obj)\n    {\n        // Add your processing rules here\n        return true;\n    }\n\n    private bool _resourceIsConsumed(Resource resource)\n    {\n        return resource.isConsumed;\n    }\n\n    public void ProcessResource(Resource input)\n    {\n        _totalAssemblies++;\n        \n        if (_processingSounds.Length == 0)\n        {\n            Debug.LogWarning($\"No processing sound assigned to assembler {gameObject.name}\");\n            return;\n        }\n\n        PlayProcessingSound();\n        \n        // Validate components\n        List<string> componentNames = new List<string>();\n        foreach (string validName in validComponentNames)\n        {\n            if (input != null && input.name.Equals(validName, StringComparison.OrdinalIgnoreCase))\n                componentNames.Add(validName);\n        }\n        \n        if (componentNames.Count < _minComponentsRequired || componentNames.Count > 5)\n            return; // Ignore invalid combinations\n        \n        // Combine components\n        Product combinedProduct = new Product(\n            $\"Combined_{input.name}_{DateTime.Now:yyyyMMddHHmmss}\",\n            input.amount,\n            input.durability,\n            componentNames.ToArray()\n        );\n        \n        _assembledProducts.Add(combinedProduct);\n        \n        UpdateStatistics(combinedProduct.productName, input.amount, input.durability);\n        \n        // Play achievement sound if milestone reached\n        CheckMilestone();\n    }\n\n    private void PlayProcessingSound()\n    {\n        int soundIndex = Random.Range(0, _processingSounds.Length);\n        if (_audioSource != null && soundIndex < _processingSounds.Length)\n            _audioSource.PlayOneShot(_processingSounds[soundIndex]);\n    }\n\n    private void CheckMilestone()\n    {\n        if (_totalAssemblies % 10 == 0)\n        {\n            PlayAchievementSound();\n        }\n    }\n\n    private void PlayAchievementSound()\n    {\n        int soundIndex = Random.Range(0, _achievementSounds.Length);\n        if (_audioSource != null && soundIndex < _achievementSounds.Length)\n            _audioSource.PlayOneShot(_achievementSounds[soundIndex]);\n    }\n\n    public List<Product> GetAssembledProducts()\n    {\n        return new List<Product>(new List<Product>(_assembledProducts));\n    }\n\n    private void UpdateStatistics(string productName, int amountAdded, float durabilityAdded)\n    {\n        if (!_productStatistics.ContainsKey(productName))\n            _productStatistics[productName] = 0;\n\n        _productStatistics[productName] += amountAdded;\n        \n        // Apply some basic stats tracking\n        Debug.Log($\"Updated statistics for {productName}: Amount +{amountAdded}, Durability +{durabilityAdded}\");\n    }\n\n    public int GetTotalAssemblies()\n    {\n        return _totalAssemblies;\n    }\n\n    public Dictionary<string, int> GetProductStatistics()\n    {\n        return new Dictionary<string, int>(_productStatistics);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw component names\n        foreach (string validName in validComponentNames)\n        {\n            if (_assembledProducts.Count > 0 && _assembledProducts[0].componentNames.Contains(validName))\n            {\n                Gizmos.DrawWireCube(new Vector3(10, 10, 0), new Vector3(1, 1, 1));\n                Gizmos.color = Color.green;\n                Gizmos.DrawLine(Gizmos.start + new Vector3(10, 10, 0), \n                    Gizmos.start + new Vector3(11, 10, 0), \n                    _assembledProducts.Count == 1 ? 0.5f : 0.3f);\n            }\n        }\n\n        // Draw assembled product\n        if (_assembledProducts.Count > 0)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(new Vector3(20, 10, 0), new Vector3(1, 1, 1));\n            \n            Gizmos.color = Color.white;\n            string productName = _assembledProducts[0].productName;\n            float combinedAmount = _assembledProducts[0].combinedAmount;\n            float combinedDurability = _assembledProducts[0].combinedDurability;\n\n            Gizmos.DrawRay(Gizmos.start + new Vector3(20, 10, 0), \n                new Vector3(0, -1, 0) * combinedAmount);\n            \n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(new Vector3(20, 8, 0), new Vector3(20, 7, 0), combinedAmount * 0.5f);\n\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(new Vector3(25, 10, 0), new Vector3(1, 1, 1));\n        }\n    }\n\n    public void ShowAssemblyComplete()\n    {\n        if (_assemblyCompletePrefab != null)\n        {\n            GameObject assemblyComplete = Instantiate(_assemblyCompletePrefab, transform.position, Quaternion.identity);\n            Destroy(assemblyComplete, 2f);\n        }\n        \n        PlayProcessingSound();\n        _particleEffect.Play();\n        StartCoroutine(DestroyAfterDelay());\n    }\n\n    private IEnumerator DestroyAfterDelay()\n    {\n        yield return new WaitForSeconds(3f);\n        Destroy(gameObject);\n    }\n\n    public void ResetAssembler()\n    {\n        _assembledProducts.Clear();\n        _totalAssemblies = 0;\n        _productStatistics.Clear();\n    }\n}",
    "ir_json": {
      "class_name": "FactoryAssembler",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem"
      ],
      "fields": [
        {
          "name": "inputSlots",
          "type": "GameObject[]",
          "default": null
        },
        {
          "name": "outputSlot",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "assemblyTime",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "productionRate",
          "type": "int",
          "default": 10
        },
        {
          "name": "currentProduction",
          "type": "int",
          "default": 0
        },
        {
          "name": "lastAssemblyTime",
          "type": "float",
          "default": 0.0
        },
        {
          "name": "assemblyCompleteFlag",
          "type": "bool",
          "default": false
        }
      ],
      "behaviors": [
        {
          "name": "detect_input_items",
          "trigger": "when object is dropped into intake area",
          "actions": [
            {
              "action": "add received object to available input slots"
            }
          ]
        },
        {
          "name": "start_assembly_sequence",
          "trigger": "when enough valid input items are detected and assembly time has elapsed since last complete item",
          "actions": [
            {
              "action": "play continuous mechanical processing sound for assembly duration"
            },
            {
              "action": "start particle system effects at work"
            }
          ]
        },
        {
          "name": "merge_input_properties",
          "trigger": "during assembly sequence execution",
          "actions": [
            {
              "action": "combine all valid properties from input items into combined product object"
            },
            {
              "action": "remove consumed input items from available inventory"
            },
            {
              "action": "update production statistics with merged item data"
            }
          ]
        },
        {
          "name": "complete_production",
          "trigger": "when assembly sequence finishes successfully",
          "actions": [
            {
              "action": "set assembly complete flag to true"
            },
            {
              "action": "spawn combined product in output slot"
            },
            {
              "action": "stop particle system effects"
            },
            {
              "action": "play assembly completion sound"
            }
          ]
        },
        {
          "name": "check_production_milestone",
          "trigger": "when current production reaches production rate threshold",
          "actions": [
            {
              "action": "check for achievement triggers related to milestone reached"
            }
          ]
        },
        {
          "name": "update_production_stats",
          "trigger": "continuously while in assembly state and items are available",
          "actions": [
            {
              "action": "increase current production count by one"
            },
            {
              "action": "record start time of current assembly sequence"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FactoryAssembler : MonoBehaviour\n{\n    [Header(\"Input Slots\")]\n    [SerializeField] private GameObject[] _inputSlots = new GameObject[8];\n    [SerializeField] private int _maxInputItemsPerSlot = 10;\n    \n    [Header(\"Output Configuration\")]\n    [SerializeField] private GameObject _outputSlot;\n    [SerializeField] private ParticleSystem _particleEffects;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _assemblyStartSound;\n    [SerializeField] private AudioClip _assemblyCompleteSound;\n    [SerializeField] private float _assemblyTime = 3f;\n    \n    [Header(\"Production Settings\")]\n    [SerializeField] private int _productionRate = 5;\n    [SerializeField] private float _cooldownBetweenAssemblies = 2f;\n    [SerializeField] private bool _enableCooldown = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _machineModel;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _speedMultiplier = 1.5f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    private List<GameObject> _availableInputItems = new List<GameObject>();\n    private int _currentProductionCount = 0;\n    private float _lastAssemblyTime;\n    private bool _isOnCooldown = false;\n    private Coroutine _assemblyCoroutine;\n    \n    private enum AssemblyState\n    {\n        Idle,\n        Assembling,\n        Cooldown,\n        Complete\n    }\n    \n    private AssemblyState _currentState = AssemblyState.Idle;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupVisualEffects();\n    }\n    \n    private void Update()\n    {\n        if (_currentState == AssemblyState.Cooldown)\n        {\n            CheckCooldownExpiration();\n        }\n        \n        switch (_currentState)\n        {\n            case AssemblyState.Assembling:\n                HandleAssemblySequence();\n                break;\n            case AssemblyState.Idle:\n                CheckForInputItems();\n                break;\n            case AssemblyState.Complete:\n                HandleCompleteProduction();\n                break;\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_particleEffects != null)\n        {\n            _particleEffects.Stop();\n        }\n        \n        if (_audioSource != null && !_assemblyCoroutine)\n        {\n            _audioSource.clip = _assemblyStartSound;\n            _audioSource.loop = true;\n        }\n    }\n    \n    private void SetupVisualEffects()\n    {\n        if (_machineModel == null) return;\n        \n        GameObject machineGO = Instantiate(_machineModel, transform.position, Quaternion.identity);\n        machineGO.SetActive(true);\n        \n        var rotation = machineGO.transform.localEulerAngles;\n        rotation.y = -rotation.y * _speedMultiplier;\n        machineGO.transform.Rotate(0, 0, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckCooldownExpiration()\n    {\n        if (_isOnCooldown && Time.time >= _lastAssemblyTime + _cooldownBetweenAssemblies)\n        {\n            _currentState = AssemblyState.Idle;\n            _isOnCooldown = false;\n            \n            if (_assemblyCoroutine != null)\n            {\n                StopCoroutine(_assemblyCoroutine);\n                _assemblyCoroutine = null;\n            }\n        }\n    }\n    \n    private void CheckForInputItems()\n    {\n        List<GameObject> newInputItems = new List<GameObject>();\n        \n        for (int i = 0; i < _inputSlots.Length; i++)\n        {\n            if (_inputSlots[i] == null) continue;\n            \n            GameObject slot = _inputSlots[i];\n            if (!slot.activeInHierarchy)\n            {\n                Collider[] colliders = Physics.OverlapBox(slot.transform.position, Vector3.up * 0.5f, _obstacleLayerMask);\n                foreach (Collider col in colliders)\n                {\n                    GameObject itemGO = col.gameObject;\n                    if (!newInputItems.Contains(itemGO) && !itemGO.activeInHierarchy)\n                    {\n                        newInputItems.Add(itemGO);\n                        Destroy(itemGO);\n                    }\n                }\n            }\n        }\n        \n        _availableInputItems.Clear();\n        foreach (GameObject item in newInputItems)\n        {\n            _availableInputItems.Add(item);\n        }\n        \n        if (_availableInputItems.Count >= _maxInputItemsPerSlot * 2 && !_isOnCooldown)\n        {\n            StartAssemblySequence();\n        }\n    }\n    \n    private void HandleAssemblySequence()\n    {\n        if (!_availableInputItems.Any() || _assemblyCoroutine != null) return;\n        \n        _currentState = AssemblyState.Assembling;\n        _lastAssemblyTime = Time.time;\n        \n        if (_particleEffects == null)\n        {\n            _particleEffects = GetComponentInChildren<ParticleSystem>();\n            if (_particleEffects == null)\n            {\n                GameObject particleGO = CreateParticleEffect();\n                _particleEffects = particleGO.AddComponent<ParticleSystem>();\n            }\n        }\n        \n        StartAssemblyCoroutine();\n    }\n    \n    private IEnumerator StartAssemblyCoroutine()\n    {\n        _assemblyCoroutine = StartCoroutine(AssemblySequence());\n    }\n    \n    private IEnumerator AssemblySequence()\n    {\n        yield return new WaitForSeconds(_assemblyTime);\n        \n        if (_availableInputItems.Count < 2) yield break;\n        \n        // Merge input items\n        GameObject[] mergedItems = new GameObject[_availableInputItems.Count];\n        for (int i = 0; i < _availableInputItems.Count; i++)\n        {\n            mergedItems[i] = _availableInputItems[i];\n        }\n        \n        // Create combined product\n        GameObject productGO = CreateCombinedProduct(mergedItems);\n        if (_outputSlot == null)\n        {\n            _outputSlot = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            _outputSlot.transform.localScale = Vector3.one * 2f;\n        }\n        \n        productGO.SetActive(true);\n        _outputSlot.SetActive(true);\n        \n        // Spawn particle effects\n        if (_particleEffects != null)\n        {\n            _particleEffects.Play();\n        }\n        \n        // Play audio\n        if (_audioSource != null && _assemblyStartSound != null)\n        {\n            _audioSource.PlayOneShot(_assemblyStartSound);\n        }\n        \n        yield return new WaitForSeconds(0.5f);\n        \n        // Check for achievements or notifications here\n        \n        _currentState = AssemblyState.Complete;\n        \n        PlayAssemblyCompleteSound();\n        productGO.SetActive(false);\n    }\n    \n    private GameObject CreateCombinedProduct(GameObject[] inputItems)\n    {\n        GameObject productGO = new GameObject(\"CombinedProduct\");\n        productGO.transform.SetParent(transform);\n        \n        // Add components from inputs\n        foreach (GameObject item in inputItems)\n        {\n            if (item != null && !productGO.GetComponent<MonoBehaviour>() == null)\n            {\n                var copy = item.GetComponent<MonoBehaviour>();\n                productGO.AddComponent<CopyMonoBehaviour>();\n                productGO.GetComponent<CopyMonoBehaviour>().targetComponent = copy;\n            }\n            \n            // Add rigidbody\n            Rigidbody rb = item.GetComponent<Rigidbody>();\n            if (rb != null && !productGO.GetComponent<Rigidbody>() == rb)\n            {\n                productGO.AddComponent<Rigidbody>();\n                // Use correct method for copying transform properties\n                rb.publishTransform = true; // This is the closest valid API\n            }\n        }\n        \n        return productGO;\n    }\n    \n    private GameObject CreateParticleEffect()\n    {\n        GameObject particleGO = new GameObject(\"ParticleEffect\");\n        ParticleSystem particleSystem = particleGO.AddComponent<ParticleSystem>();\n        \n        var main = particleSystem.main;\n        main.startColor = Color.red;\n        main.startSize = 0.3f;\n        main.startLifetime = 2f;\n        main.startSpeed = 5f;\n        \n        var emission = particleSystem.emission;\n        emission.rateOverTime = new float[] { 10 };\n        emission.bursts = new ParticleSystem.Burst[] { \n            new ParticleSystem.Burst(0.1f, 3) \n        };\n        \n        return particleGO;\n    }\n    \n    private void PlayAssemblyCompleteSound()\n    {\n        if (_audioSource != null && _assemblyCompleteSound != null)\n        {\n            _audioSource.PlayOneShot(_assemblyCompleteSound);\n        }\n    }\n    \n    private void HandleCompleteProduction()\n    {\n        _currentProductionCount++;\n        \n        // Check for production milestones\n        if (_currentProductionCount % 10 == 0)\n        {\n            Debug.Log($\"Assembly complete! Total produced: {_currentProductionCount}\");\n            // Trigger any completion events or notifications here\n        }\n        \n        _lastAssemblyTime = Time.time;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        for (int i = 0; i < _inputSlots.Length; i++)\n        {\n            if (_inputSlots[i] != null)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawWireCube(_inputSlots[i].transform.position, Vector3.up * 0.5f);\n                \n                // Draw input item count\n                int slotCount = _maxInputItemsPerSlot;\n                for (int j = 0; j < slotCount; j++)\n                {\n                    GameObject itemGO = _inputSlots[i];\n                    if (!itemGO.activeInHierarchy)\n                    {\n                        Gizmos.color = Color.cyan;\n                        Gizmos.DrawWireCube(itemGO.transform.position, Vector3.up * 0.3f);\n                    }\n                }\n            }\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 5,
    "ir_rag_doc_names": [
      "ParticleSystem.ForceOverLifetimeModule (0.62)",
      "ParticleSystem.TriggerSubEmitter (0.60)",
      "ParticleSystem.CollisionModule (0.60)",
      "ParticleSystemAnimationTimeMode.FPS (0.40)",
      "Scripting.GarbageCollector.incrementalTimeSliceNanoseconds (0.30)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FactoryAssembler : MonoBehaviour\n{\n    [Header(\"Intake Settings\")]\n    public GameObject[] intakePoints = new GameObject[10];\n    public int currentIntakeIndex = 0;\n    \n    [Header(\"Production Settings\")]\n    public float productionTime = 2f;\n    public float cooldownTime = 1f;\n    private bool isProducing = false;\n    private float lastProductionTime = 0f;\n    private List<FactoryProduct> producedProducts = new List<FactoryProduct>();\n    \n    [Header(\"Material Handling\")]\n    public string[] materialNames = {\"Wood\", \"Metal\", \"Plastic\"};\n    public GameObject[] materialPrefabs = {null, null, null};\n    public int currentMaterialIndex = 0;\n    \n    [Header(\"Audio Settings\")]\n    public AudioSource audioSource;\n    public AudioClip[] productionSounds;\n    public AudioClip[] milestoneSounds;\n    private float nextSoundTime = 0f;\n    \n    [Header(\"Visual Effects\")]\n    public GameObject[] particleEffects = new GameObject[10];\n    public ParticleSystem[] effectSystems = new ParticleSystem[10];\n    private float nextEffectTime = 0f;\n    \n    [Header(\"Milestone Achievements\")]\n    public List<MilestoneAchievement> milestoneAchievements = new List<MilestoneAchievement>();\n    \n    class FactoryProduct\n    {\n        public string materialType;\n        public int productionCount;\n        public float creationTime;\n        \n        public FactoryProduct(string material, int count)\n        {\n            materialType = material;\n            productionCount = count;\n            creationTime = Time.time;\n        }\n    }\n    \n    class MilestoneAchievement\n    {\n        public string achievementName;\n        public int targetCount;\n        public bool isAchieved;\n        \n        public MilestoneAchievement(string name, int count)\n        {\n            achievementName = name;\n            targetCount = count;\n            isAchieved = false;\n        }\n    }\n    \n    private void Start()\n    {\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        for (int i = 0; i < intakePoints.Length; i++)\n        {\n            intakePoints[i] = GameObject.FindGameObjectWithTag(\"Intake\" + i);\n            if (intakePoints[i] != null)\n                intakePoints[i].AddComponent<Collider>(i == 0 ? BoxCollider : SphereCollider) ?? null;\n        }\n        \n        for (int i = 0; i < particleEffects.Length; i++)\n            particleEffects[i] = GameObject.FindGameObjectWithTag(\"Particle\" + i);\n            \n        for (int i = 0; i < effectSystems.Length; i++)\n            effectSystems[i] = GetComponent<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (!isProducing)\n        {\n            CheckIntakeInput();\n            CheckCooldown();\n            CheckMilestoneAchievements();\n        }\n        else\n        {\n            ProcessProduction();\n            UpdateVisualEffects();\n            CheckSoundEffects();\n        }\n    }\n    \n    private void CheckIntakeInput()\n    {\n        if (currentIntakeIndex >= intakePoints.Length)\n            return;\n            \n        GameObject intakePoint = intakePoints[currentIntakeIndex];\n        if (intakePoint != null && intakePoint.activeSelf)\n        {\n            // Try to grab the dropped resource\n            GrabResource(intakePoint);\n        }\n    }\n    \n    private void CheckCooldown()\n    {\n        if (Time.time - lastProductionTime >= cooldownTime)\n        {\n            isProducing = false;\n            lastProductionTime = Time.time;\n        }\n    }\n    \n    private void CheckMilestoneAchievements()\n    {\n        for (int i = 0; i < milestoneAchievements.Count; i++)\n        {\n            if (!milestoneAchievements[i].isAchieved && \n                producedProducts.Count >= milestoneAchievements[i].targetCount)\n            {\n                milestoneAchievements[i].isAchieved = true;\n                PlayMilestoneSound(milestoneAchievements[i].achievementName);\n                Debug.Log($\"Achievement '{milestoneAchievements[i].achievementName}' unlocked!\");\n            }\n        }\n    }\n    \n    private void ProcessProduction()\n    {\n        if (currentMaterialIndex >= materialPrefabs.Length)\n            return;\n            \n        Material currentMaterial = materialPrefabs[currentMaterialIndex]?.GetComponent<Material>();\n        if (currentMaterial == null) return;\n        \n        // Simulate production time\n        float elapsedTime = Time.time - lastProductionTime;\n        float progress = elapsedTime / productionTime;\n        \n        if (progress >= 1f)\n        {\n            lastProductionTime = Time.time;\n            producedProducts.Add(new FactoryProduct(currentMaterialNames[currentMaterialIndex], \n                Mathf.RoundToInt(progress * materialPrefabs[currentMaterialIndex].GetComponent<Collider>().boundaries.length)));\n            \n            // Create product object\n            GameObject product = new GameObject($\"FactoryProduct_{currentMaterialNames[currentMaterialIndex]}\");\n            product.AddComponent<Rigidbody>();\n            product.AddComponent<Collider>();\n            \n            // Apply material properties (simplified)\n            if (currentMaterialNames[currentMaterialIndex] == \"Wood\")\n                product.GetComponent<Renderer>().material = currentMaterial;\n            else if (currentMaterialNames[currentMaterialIndex] == \"Metal\")\n                product.GetComponent<Renderer>().material = currentMaterial;\n            else if (currentMaterialNames[currentMaterialIndex] == \"Plastic\")\n                product.GetComponent<Renderer>().material = currentMaterial;\n            \n            // Add production count to stats\n            UpdateProductionStats();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        for (int i = 0; i < particleEffects.Length; i++)\n        {\n            if (particleEffects[i] != null)\n            {\n                float elapsedTime = Time.time - nextEffectTime;\n                if (elapsedTime >= 1f)\n                {\n                    nextEffectTime += 1f;\n                    PlayParticleEffect(particleEffects[i]);\n                }\n            }\n        }\n    }\n    \n    private void CheckSoundEffects()\n    {\n        for (int i = 0; i < productionSounds.Length; i++)\n        {\n            if (Time.time >= nextSoundTime + productionSounds[i].length)\n            {\n                audioSource.PlayOneShot(productionSounds[i]);\n                nextSoundTime += productionSounds[i].length;\n            }\n        }\n    }\n    \n    private void PlayMilestoneSound(string soundName)\n    {\n        if (audioSource != null && milestoneSounds.Length > 0)\n        {\n            float elapsedTime = Time.time - nextSoundTime;\n            foreach (var sound in milestoneSounds)\n            {\n                if (soundName == \"ProductionSpeedUp\")\n                {\n                    if (elapsedTime >= sound.length)\n                    {\n                        audioSource.PlayOneShot(sound);\n                        nextSoundTime += sound.length;\n                        return;\n                    }\n                }\n                else if (soundName.Contains(\"Material\"))\n                {\n                    if (elapsedTime >= sound.length)\n                    {\n                        audioSource.PlayOneShot(sound);\n                        nextSoundTime += sound.length;\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void PlayParticleEffect(GameObject particleObject)\n    {\n        if (particleObject != null && effectSystems.Length > 0)\n        {\n            foreach (var system in effectSystems)\n            {\n                if (system == particleObject.GetComponent<ParticleSystem>())\n                {\n                    float elapsedTime = Time.time - nextEffectTime;\n                    if (elapsedTime >= 1f)\n                    {\n                        nextEffectTime += 1f;\n                        PlayParticleSystem(system);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void PlayParticleSystem(ParticleSystem system)\n    {\n        if (system != null && system.isPlaying)\n        {\n            var main = system.main;\n            var emission = main.emission;\n            \n            // Set emission rate\n            emission.rateOverTime = 100f / 2f; // 50 particles per second\n            \n            // Play emission once\n            system.Play();\n            nextEffectTime += 1f;\n        }\n    }\n    \n    private void GrabResource(GameObject intakePoint)\n    {\n        if (intakePoint == null) return;\n        \n        Collider[] colliders = intakePoint.GetComponentsInChildren<Collider>();\n        foreach (var collider in colliders)\n        {\n            // Try to grab any resource object that touches this collider\n            Collider[] objectsToCheck = Physics.OverlapSphere(collider.transform.position, 0.5f);\n            \n            foreach (var obj in objectsToCheck)\n            {\n                if (obj.CompareTag(\"Resource\"))\n                {\n                    // Move resource to intake area\n                    Vector3 intakePosition = intakePoint.transform.position;\n                    obj.transform.position = intakePosition;\n                    \n                    // Destroy original resource\n                    Destroy(obj.gameObject);\n                    \n                    // Play processing sound\n                    if (productionSounds.Length > 0)\n                        audioSource.PlayOneShot(productionSounds[0]);\n                    \n                    Debug.Log($\"Resource {obj.name} grabbed and processed!\");\n                    return; // Grabbed successfully, exit loop\n                }\n            }\n        }\n    }\n    \n    private void UpdateProductionStats()\n    {\n        int totalProduced = producedProducts.Count;\n        \n        if (totalProduced > 0)\n        {\n            float averageTime = totalProduced <= 1 ? 0f : \n                (producedProducts[0].creationTime + producedProducts[1].creationTime) / 2f;\n            \n            Debug.Log($\"Produced {totalProduced} items in an average time of {averageTime:F2}s\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw intake points\n        for (int i = 0; i < intakePoints.Length; i++)\n        {\n            if (intakePoints[i] != null && intakePoints[i].activeSelf)\n                Gizmos.DrawWireSphere(intakePoints[i].transform.position, 0.5f);\n        }\n        \n        // Draw material icons\n        for (int i = 0; i < materialNames.Length; i++)\n        {\n            if (materialPrefabs[i] != null && materialPrefabs[i].GetComponent<Renderer>() != null)\n                Gizmos.DrawWireSphere(materialPrefabs[i].transform.position, 0.3f);\n        }\n    }\n}",
    "per_behavior_docs": 12,
    "per_behavior_methods": 4,
    "per_behavior_doc_names": {
      "process_dropped_resource": [
        "Collider.GetGeometry (0.72)",
        "Collider.GeometryHolder (0.71)",
        "Collider.OnCollisionStay (0.70)"
      ],
      "update_production_stats": [
        "Animator.CrossFadeInFixedTime (0.60)",
        "Animation.GetClipCount (0.60)",
        "Animator.GetCurrentAnimatorClipInfoCount (0.60)"
      ],
      "trigger_milestone_achievement": [
        "GameObject.InstantiateGameObjects (0.70)",
        "GameObject.GetComponentInChildren (0.66)",
        "GameObject.GetScene (0.66)"
      ],
      "display_production_report": [
        "Material.CopyPropertiesFromMaterial (0.66)",
        "Material.IsPropertyOverriden (0.66)",
        "Material.IsPropertyLocked (0.65)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 5,
        "correctness": 6,
        "completeness": 4,
        "weighted_total": 43,
        "justification": "Direct translation lacks clear separation of concerns, with methods and classes feeling hastily constructed. Good Unity-specific components like serialized fields, but incomplete implementation with truncated code. Attempts to cover requirements but lacks robust error handling and extension points."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 7,
        "weighted_total": 67,
        "justification": "Extremely strong Unity pattern implementation with clear state management, extensive serialization, and modular design. Includes sophisticated state machine approach, defensive programming techniques, and comprehensive initialization. Multiple extension points and clear separation between configuration and logic."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 6,
        "unity_patterns": 7,
        "correctness": 5,
        "completeness": 6,
        "weighted_total": 55,
        "justification": "Solid component-based approach with good separation of concerns. Multiple collections and configuration points demonstrate flexibility. Slightly over-engineered with redundant arrays and initialization, reducing immediate readability. Good intent but less focused implementation compared to monolithic approach."
      },
      "winner": "ir_monolithic",
      "key_differences": "The monolithic approach provides the most structured, extensible, and Unity-idiomatic implementation, with clear state management and robust error handling.",
      "advantages": "Comprehensive state machine, defensive programming, clear serialization strategy, and modular design make it most adaptable to future requirements and easiest for developers to understand and extend."
    },
    "error": null
  },
  {
    "prompt_num": 21,
    "prompt": "Build a probability field generator that when active causes random events within its radius: objects occasionally teleport short distances, gravity might briefly invert, colors temporarily shift hue, sounds play at random pitches - with intensity and frequency configurable via sliders visible in a holographic UI.",
    "timestamp": "2026-01-08T23:11:29.253551",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ProbabilityFieldGenerator : MonoBehaviour\n{\n    [Header(\"Field Settings\")]\n    [SerializeField] private float _fieldRadius = 10f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private bool _affectPlayer = true;\n    \n    [Header(\"Teleport Settings\")]\n    [SerializeField] private float _teleportRange = 3f;\n    [SerializeField] private float _teleportCooldown = 2f;\n    [SerializeField] private int _maxTeleportsPerSecond = 5;\n    [SerializeField] private float _teleportIntensity = 1.5f;\n    \n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _normalGravityScale = 1f;\n    [SerializeField] private float _invertedGravityScale = 0.25f;\n    [SerializeField] private bool _enableGravitySwitching = true;\n    [SerializeField] private float _gravitySwitchInterval = 5f;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _originalColor = Color.white;\n    [SerializeField] private float _colorShiftAmount = 0.3f;\n    [SerializeField] private AnimationCurve _colorTransitionCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private int _minPitch = 20;\n    [SerializeField] private int _maxPitch = 20000;\n    [SerializeField] private float _volumeVariation = 0.5f;\n    [SerializeField] private AnimationCurve _pitchTransitionCurve = AnimationCurve.Linear(0, 1, 1, 1);\n    \n    [Header(\"Holographic UI\")]\n    [SerializeField] private GameObject _hologramPrefab;\n    [SerializeField] private float _updateInterval = 0.5f;\n    \n    private List<GameObject> _affectedObjects = new List<GameObject>();\n    private Collider _fieldCollider;\n    private Rigidbody _fieldRigidbody;\n    private float _lastTeleportTime;\n    private float _lastGravitySwitchTime;\n    private Color _originalColorForEachObject = new Dictionary<GameObject, Color>();\n    private int _teleportCounter = 0;\n    private int _audioCounter = 0;\n    \n    void Start()\n    {\n        SetupHolographicUI();\n        InitializeFieldCollider();\n        InitializeAudioSource();\n        \n        if (_affectPlayer)\n            AddPlayerToAffectedList();\n    }\n    \n    void Update()\n    {\n        if (Time.time - _lastTeleportTime >= _teleportCooldown)\n        {\n            TeleportRandomObjects();\n            _teleportCounter = 0;\n            _lastTeleportTime = Time.time;\n        }\n        \n        if (_enableGravitySwitching && Time.time - _lastGravitySwitchTime >= _gravitySwitchInterval)\n        {\n            SwitchGravity();\n            _lastGravitySwitchTime = Time.time;\n        }\n        \n        UpdateHolographicUI();\n    }\n    \n    void SetupHolographicUI()\n    {\n        if (_hologramPrefab != null)\n        {\n            GameObject hologram = Instantiate(_hologramPrefab, transform);\n            Destroy(hologram.gameObject, _updateInterval);\n        }\n    }\n    \n    void InitializeFieldCollider()\n    {\n        _fieldCollider = GetComponent<Collider>();\n        if (_fieldCollider == null)\n        {\n            _fieldCollider = gameObject.AddComponent<SphereCollider>();\n            _fieldCollider.radius = _fieldRadius;\n        }\n        \n        _fieldRigidbody = GetComponent<Rigidbody>();\n        if (_fieldRigidbody == null)\n        {\n            _fieldRigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n    }\n    \n    void InitializeAudioSource()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.spatialBlend = 1f;\n        _audioSource.volume = 0.5f;\n    }\n    \n    void AddPlayerToAffectedList()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _affectedObjects.Add(player);\n            \n            // Store original color for the player\n            Color originalColor = player.GetComponent<Renderer>().material.color;\n            _originalColorForEachObject[player] = originalColor;\n        }\n    }\n    \n    void RemovePlayerFromAffectedList()\n    {\n        foreach (GameObject obj in _affectedObjects)\n        {\n            if (obj == null) continue;\n            \n            Color originalColor = _originalColorForEachObject[obj];\n            if (originalColor != Color.white)\n                _originalColorForEachObject[obj] = Color.Lerp(originalColor, Color.white, 0.5f);\n        }\n        \n        _affectedObjects.Clear();\n    }\n    \n    void TeleportRandomObjects()\n    {\n        _teleportCounter++;\n        \n        for (int i = _affectedObjects.Count - 1; i >= 0; i--)\n        {\n            GameObject obj = _affectedObjects[i];\n            \n            if (obj == null) continue;\n            \n            // Calculate displacement vector\n            Vector3 randomDirection = Random.insideUnitSphere * _teleportRange;\n            Vector3 teleportTargetPosition = transform.position + randomDirection;\n            \n            // Apply teleport\n            obj.transform.position = teleportTargetPosition;\n            \n            // Restore original color if it was modified\n            Color currentColor = obj.GetComponent<Renderer>().material.color;\n            if (_originalColorForEachObject[obj] != Color.white)\n                currentColor = Color.Lerp(_originalColorForEachObject[obj], Color.white, 0.5f);\n            obj.GetComponent<Renderer>().material.color = currentColor;\n        }\n        \n        // Limit teleports to prevent performance issues\n        int maxTeleports = Mathf.Ceil(_maxTeleportsPerSecond * Time.deltaTime) - _teleportCounter % 2;\n        if (_teleportCounter > maxTeleports)\n        {\n            RemovePlayerFromAffectedList();\n            break;\n        }\n    }\n    \n    void SwitchGravity()\n    {\n        bool wasInverted = _fieldRigidbody.isKinematic || _fieldRigidbody.gravityScale == _invertedGravityScale;\n        \n        if (!wasInverted)\n        {\n            _fieldRigidbody.gravityScale = _invertedGravityScale;\n        }\n        else\n        {\n            _fieldRigidbody.gravityScale = _normalGravityScale;\n        }\n    }\n    \n    void UpdateHolographicUI()\n    {\n        if (_hologramPrefab != null && GetComponentInChildren<Canvas>() != null)\n        {\n            // Example: Update display based on current field settings\n            float updateTime = Time.time - _fieldCollider.transform.time;\n            \n            // Update teleport intensity visualization (could use particle effects or glow)\n            // Add more UI logic here for different hologram elements\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!_affectPlayer && !other.CompareTag(\"Player\"))\n        {\n            GameObject obj = other.gameObject;\n            Color currentColor = obj.GetComponent<Renderer>().material.color;\n            \n            if (currentColor != _originalColorForEachObject[obj] && \n                !_originalColorForEachObject[obj].equals(Color.white))\n            {\n                // Shift color toward white\n                currentColor = Color.Lerp(currentColor, _originalColorForEachObject[obj], 0.5f);\n                obj.GetComponent<Renderer>().material.color = currentColor;\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (!_affectPlayer && !other.CompareTag(\"Player\"))\n        {\n            GameObject obj = other.gameObject;\n            \n            if (_originalColorForEachObject[obj] != Color.white)\n            {\n                // Shift color back to original\n                Color currentColor = obj.GetComponent<Renderer>().material.color;\n                currentColor = Color.Lerp(currentColor, _originalColorForEachObject[obj], 0.5f);\n                obj.GetComponent<Renderer>().material.color = currentColor;\n            }\n        }\n    }\n    \n    public void SetTeleportRange(float range)\n    {\n        _teleportRange = Mathf.Max(0f, range);\n    }\n    \n    public void SetGravitySwitchInterval(float interval)\n    {\n        _gravitySwitchInterval = interval > 0 ? interval : 1f;\n    }\n    \n    public void SetColorShiftAmount(float amount)\n    {\n        _colorShiftAmount = Mathf.Clamp(amount, 0f, 1f);\n    }\n    \n    public void SetAudioSourceVolume(float volume)\n    {\n        if (_audioSource != null)\n            _audioSource.volume = Mathf.Clamp(volume, 0f, 1f);\n    }\n    \n    public void SetAudioPitchRange(int min, int max)\n    {\n        _minPitch = Mathf.Max(0, min);\n        _maxPitch = Mathf.Min(max, 100000);\n    }\n}",
    "ir_json": {
      "class_name": "ProbabilityFieldGenerator",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem"
      ],
      "fields": [
        {
          "name": "radius",
          "type": "float",
          "default": 15
        },
        {
          "name": "intensitySlider",
          "type": "float",
          "default": 0.7
        },
        {
          "name": "eventFrequencySlider",
          "type": "float",
          "default": 3.5
        },
        {
          "name": "maxTeleportDistance",
          "type": "float",
          "default": 8
        },
        {
          "name": "gravityInversionChance",
          "type": "float",
          "default": 0.4
        },
        {
          "name": "colorShiftStrength",
          "type": "float",
          "default": 1.2
        },
        {
          "name": "audioPitchRange",
          "type": "float",
          "default": 30
        },
        {
          "name": "audioVolume",
          "type": "float",
          "default": 0.8
        }
      ],
      "behaviors": [
        {
          "name": "activate_probability_field",
          "trigger": "when probability field generator becomes active",
          "actions": [
            {
              "action": "initialize random seed using system time"
            },
            {
              "action": "display UI sliders for intensity and frequency if not already shown"
            }
          ]
        },
        {
          "name": "random_event_loop",
          "trigger": "every frame while field is active",
          "actions": [
            {
              "action": "calculate event trigger based on slider values and random number"
            },
            {
              "action": "execute chosen random effect within radius with configured probability"
            }
          ]
        },
        {
          "name": "teleport_objects",
          "trigger": "when teleportation event occurs",
          "actions": [
            {
              "action": "select random objects within effective range of field"
            },
            {
              "action": "calculate random teleport offset vector within max distance"
            },
            {
              "action": "apply teleportation to selected objects using offset"
            }
          ]
        },
        {
          "name": "invert_gravity",
          "trigger": "when gravity inversion event occurs",
          "actions": [
            {
              "action": "temporarily reverse gravity direction for affected objects"
            }
          ]
        },
        {
          "name": "shift_color",
          "trigger": "when color shift event occurs",
          "actions": [
            {
              "action": "select random object within effective range"
            },
            {
              "action": "apply random hue shift to material color using strength value"
            }
          ]
        },
        {
          "name": "play_audio_effect",
          "trigger": "when sound effect event occurs",
          "actions": [
            {
              "action": "generate random pitch offset from audio pitch range"
            },
            {
              "action": "set audio source volume based on sliders"
            },
            {
              "action": "play selected sound clip at altered pitch and volume"
            }
          ]
        },
        {
          "name": "deactivate_probability_field",
          "trigger": "when probability field generator becomes inactive",
          "actions": [
            {
              "action": "hide UI sliders if they were visible"
            },
            {
              "action": "stop all random event loops"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\n\npublic class ProbabilityFieldGenerator : MonoBehaviour\n{\n    [Header(\"Teleportation Settings\")]\n    [SerializeField] private bool _enableTeleportation = true;\n    [SerializeField] private float _teleportCooldown = 1f;\n    [SerializeField] private float _maxTeleportDistance = 8f;\n    [SerializeField] private float _teleportForce = 5f;\n    \n    [Header(\"Gravity Inversion\")]\n    [SerializeField] private bool _enableInvertedGravity = false;\n    [SerializeField] private float _gravityInversionRadius = 10f;\n    [SerializeField] private float _invertGravityWhenClose = true;\n    \n    [Header(\"Color Shift\")]\n    [SerializeField] private bool _enableColorShift = false;\n    [SerializeField] private float _colorShiftIntensity = 1.2f;\n    [SerializeField] private AnimationCurve _shiftCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _teleportSounds;\n    [SerializeField] private float _audioPitchRange = 30f;\n    [SerializeField] private float _audioVolume = 0.8f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.Linear(0, 0, 1, 1);\n    \n    [Header(\"Event Triggers\")]\n    [SerializeField] private string[] _triggerTags = { \"Player\", \"Enemy\" };\n    [SerializeField] private float _triggerCooldown = 2f;\n    \n    private List<GameObject> _teleportedObjects = new List<GameObject>();\n    private Dictionary<string, float> _lastTeleportTime = new Dictionary<string, float>();\n    private float _cooldownTimer = 0f;\n    private bool _isActive = false;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (!_isActive && _audioSource != null)\n            ShowComponentReference(_audioSource);\n    }\n    \n    private void Update()\n    {\n        if (!_isActive) return;\n        \n        UpdateCooldown();\n        HandleEvents();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            if (_enableTeleportation && CanTriggerEvent(other.tag))\n            {\n                TriggerTeleport(other.gameObject);\n            }\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            CheckForGravityInversion(other.transform.position);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_enableTeleportation && CanTriggerEvent(other.tag))\n        {\n            TriggerTeleport(other.gameObject);\n        }\n    }\n    \n    private bool CanTriggerEvent(string tag)\n    {\n        return !_cooldownTimer > 0f || tag == \"Player\" || tag == \"Enemy\";\n    }\n    \n    private void UpdateCooldown()\n    {\n        _cooldownTimer -= Time.deltaTime;\n        \n        if (_audioSource != null && _teleportSounds.Length > 0)\n        {\n            float volume = Mathf.Lerp(0f, _audioVolume, _cooldownTimer / _triggerCooldown);\n            _audioSource.volume = volume;\n        }\n        \n        if (_cooldownTimer <= 0f)\n        {\n            _isActive = false;\n            \n            foreach (var obj in _teleportedObjects)\n            {\n                Destroy(obj);\n            }\n            \n            _teleportedObjects.Clear();\n            _lastTeleportTime.Clear();\n            \n            ShowComponentReference(_audioSource);\n        }\n    }\n    \n    private void HandleEvents()\n    {\n        if (!_isActive || _teleportedObjects.Count == 0) return;\n        \n        for (int layer = 0; layer < Physics.DetectionLayers.Length; layer++)\n        {\n            if (_affectedLayers.value & (1 << layer))\n            {\n                GameObject targetObject = _teleportedObjects[layer];\n                \n                float distance = Vector3.Distance(transform.position, targetObject.transform.position);\n                bool shouldTrigger = false;\n                \n                foreach (string triggerTag in _triggerTags)\n                {\n                    if (targetObject.CompareTag(triggerTag) && CanTriggerEvent(triggerTag))\n                    {\n                        shouldTrigger = true;\n                        break;\n                    }\n                }\n                \n                if (shouldTrigger && !_cooldownTimer > 0f)\n                {\n                    TriggerTeleport(targetObject);\n                }\n            }\n        }\n    }\n    \n    private void CheckForGravityInversion(Vector3 position)\n    {\n        float distance = Vector3.Distance(transform.position, position);\n        \n        if (_enableInvertedGravity && distance <= _gravityInversionRadius)\n        {\n            ApplyInvertedGravity(position);\n        }\n    }\n    \n    private void ApplyInvertedGravity(Vector3 targetPosition)\n    {\n        Rigidbody rb = targetPosition.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 force = rb.velocity;\n            float scale = -1f * _invertGravityWhenClose;\n            \n            if (_enableInvertedGravity)\n            {\n                force.y *= scale;\n                rb.AddForceAtPosition(force, targetPosition);\n            }\n        }\n    }\n    \n    private void TriggerTeleport(GameObject obj)\n    {\n        if (!_enableTeleportation || !_teleportedObjects.Contains(obj)) return;\n        \n        float distance = Vector3.Distance(transform.position, obj.transform.position);\n        \n        if (distance > _maxTeleportDistance) return;\n        \n        Vector3 teleportOffset = GetRandomTeleportOffset(distance);\n        TeleportObject(obj, teleportOffset);\n    }\n    \n    private Vector3 GetRandomTeleportOffset(float distance)\n    {\n        float angle1 = Random.Range(0f, 360f);\n        float angle2 = Random.Range(0f, 360f);\n        \n        float x = Mathf.Cos(angle1 * Mathf.Deg2Rad) * distance;\n        float z = Mathf.Sin(angle1 * Mathf.Deg2Rad) * distance;\n        \n        return new Vector3(x, 0f, z);\n    }\n    \n    private void TeleportObject(GameObject obj, Vector3 offset)\n    {\n        _teleportedObjects.Remove(obj);\n        \n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 originalVelocity = rb.velocity;\n            rb.velocity = new Vector3(\n                originalVelocity.x + offset.x * _teleportForce,\n                originalVelocity.y,\n                originalVelocity.z + offset.z * _teleportForce\n            );\n        }\n        \n        Quaternion rotation = obj.transform.rotation;\n        Quaternion newRotation = Quaternion.Euler(0f, 0f, Random.Range(-90f, 90f));\n        obj.transform.rotation = newRotation * rotation;\n        \n        RigidbodyDynamic rbDynamic = obj.GetComponent<RigidbodyDynamic>();\n        if (rbDynamic != null)\n        {\n            Vector3 force = GetRandomForce();\n            rbDynamic.AddForce(force);\n        }\n        \n        // Store for visual effects\n        _teleportedObjects.Add(obj);\n        \n        string tag = obj.CompareTag(\"Player\") ? \"Player\" : \"Enemy\";\n        _lastTeleportTime[tag] = Time.time;\n    }\n    \n    private Vector3 GetRandomForce()\n    {\n        float x = Random.Range(-10f, 10f);\n        float z = Random.Range(-10f, 10f);\n        \n        return new Vector3(x, 0f, z);\n    }\n    \n    private void PlayTeleportSound()\n    {\n        if (_audioSource == null || _teleportSounds.Length == 0) return;\n        \n        int soundIndex = Random.Range(0, _teleportSounds.Length);\n        _audioSource.PlayOneShot(_teleportSounds[soundIndex]);\n        \n        float pitchMultiplier = Random.Range(1f - _audioPitchRange / 2f, 1f + _audioPitchRange / 2f);\n        _audioSource.pitch = pitchMultiplier;\n        _audioSource.volume = Mathf.Lerp(0f, _audioVolume, Time.deltaTime * 5f);\n    }\n    \n    private void ShowComponentReference(AudioSource audio)\n    {\n        if (audio != null)\n        {\n            Debug.Log(\"Audio Source: \" + audio.name);\n            Debug.Log(\"Volume: \" + audio.volume);\n            Debug.Log(\"Pitch: \" + audio.pitch);\n        }\n    }\n    \n    public bool IsActive => _isActive;\n    public float FieldRadius => _fieldRadius;\n    public float MaxTeleportDistance => _maxTeleportDistance;\n    public float TeleportCooldown => _teleportCooldown;\n    public float GravityInversionRadius => _gravityInversionRadius;\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "ParticleSystem.SetMaximumPreMappedBufferCounts (0.63)",
      "ParticleSystem.ForceOverLifetimeModule (0.62)",
      "ParticleSystem.RotationOverLifetimeModule (0.62)",
      "AudioSource.GamepadSpeakerSupportsOutputType (0.60)",
      "Collider.OnTriggerExit (0.60)",
      "Random.Range (0.60)",
      "Random.InitState (0.60)",
      "ParticleSystemShapeMultiModeValue.Random (0.45)",
      "ParticleSystemShapeMultiModeValue.BurstSpread (0.42)",
      "Animations.GameObjectRecorder (0.41)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ProbabilityFieldGenerator : MonoBehaviour\n{\n    [Header(\"Probability Field Settings\")]\n    [SerializeField] private float _fieldRadius = 10f;\n    [SerializeField] private int _teleportEventsPerSecond = 5;\n    [SerializeField] private float _teleportRange = 2f;\n    [SerializeField] private bool _enableTeleportation = true;\n    [SerializeField] private LayerMask _teleportTargetLayers = -1;\n    \n    [Header(\"Gravity Inversion\")]\n    [SerializeField] private bool _invertedGravity = false;\n    [SerializeField] private float _gravityInversionStrength = 0.5f;\n    [SerializeField] private float _normalGravityStrength = 9.81f;\n    \n    [Header(\"Color Shift\")]\n    [SerializeField] private Color _baseColor = Color.white;\n    [SerializeField] private float _colorShiftIntensity = 0.3f;\n    [SerializeField] private AnimationCurve _shiftCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio Effects\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _audioClips;\n    [SerializeField] private float _minPitch = 0.5f;\n    [SerializeField] private float _maxPitch = 2f;\n    [SerializeField] private float _baseVolume = 1f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _uiPrefab;\n    [SerializeField] private bool _showUI = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTeleportTriggered;\n    public UnityEvent OnGravityInverted;\n    public UnityEvent OnColorShifted;\n    public UnityEvent OnAudioPitchChanged;\n    \n    private Camera _mainCamera;\n    private Renderer _renderer;\n    private Collider _collider;\n    private Material _material;\n    private Color[] _originalColors;\n    private float _lastTime;\n    private bool _isPlayingAudio = false;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupUI();\n        _lastTime = Time.time;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    void InitializeComponents()\n    {\n        _mainCamera = Camera.main;\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.spatialBlend = 1f;\n        }\n        \n        if (_uiPrefab != null && _showUI)\n        {\n            GameObject uiObject = new GameObject(\"ProbabilityFieldUI\");\n            uiObject.transform.SetParent(transform);\n            uiObject.transform.localPosition = Vector3.zero;\n            \n            _uiPrefab.AddComponent<Canvas>();\n            _uiPrefab.GetComponent<Canvas>().renderMode = RenderMode.WorldSpace;\n            _uiPrefab.SetActive(true);\n        }\n    }\n    \n    void SetupUI()\n    {\n        if (_showUI && _uiPrefab != null)\n        {\n            GameObject ui = Instantiate(_uiPrefab, transform);\n            Canvas canvas = ui.GetComponent<Canvas>();\n            \n            Slider sliderRadius = canvas.FindChild(\"RadiusSlider\");\n            sliderRadius.value = _fieldRadius;\n            \n            Slider sliderEventsPerSecond = canvas.FindChild(\"EventsPerSecondSlider\");\n            sliderEventsPerSecond.value = _teleportEventsPerSecond;\n            \n            Slider sliderRange = canvas.FindChild(\"TeleportRangeSlider\");\n            sliderRange.value = _teleportRange;\n            \n            Slider sliderInvertedGravity = canvas.FindChild(\"InvertedGravitySlider\");\n            sliderInvertedGravity.value = _invertedGravity ? 1f : 0f;\n            \n            Slider sliderColorShiftIntensity = canvas.FindChild(\"ColorShiftIntensitySlider\");\n            sliderColorShiftIntensity.value = _colorShiftIntensity;\n        }\n    }\n    \n    void Update()\n    {\n        HandleUIUpdates();\n        \n        if (_enableTeleportation)\n        {\n            TriggerRandomEvents();\n        }\n        \n        CheckForPlayerInField();\n    }\n    \n    void HandleUIUpdates()\n    {\n        if (_showUI && _uiPrefab != null)\n        {\n            GameObject ui = GetComponentInChildren<Canvas>();\n            if (ui != null)\n            {\n                Slider sliderRadius = ui.GetComponent<Slider>();\n                if (sliderRadius != null) sliderRadius.value = _fieldRadius;\n                \n                Slider sliderEventsPerSecond = ui.GetComponent<Slider>();\n                if (sliderEventsPerSecond != null) sliderEventsPerSecond.value = _teleportEventsPerSecond;\n                \n                Slider sliderRange = ui.GetComponent<Slider>();\n                if (sliderRange != null) sliderRange.value = _teleportRange;\n                \n                Slider sliderInvertedGravity = ui.GetComponent<Slider>();\n                if (sliderInvertedGravity != null)\n                {\n                    bool inverted = sliderInvertedGravity.value > 0.5f;\n                    _invertedGravity = inverted;\n                    OnGravityInverted?.Invoke();\n                }\n            }\n        }\n    }\n    \n    void TriggerRandomEvents()\n    {\n        float currentTime = Time.time - _lastTime;\n        _lastTime = currentTime;\n        \n        if (currentTime < 1f / _teleportEventsPerSecond)\n            return;\n        \n        float randomValue = Random.Range(0f, 1f);\n        \n        if (_enableTeleportation && randomValue <= 1f / _teleportEventsPerSecond)\n        {\n            TriggerTeleportEvent();\n        }\n        \n        // Gravity inversion\n        if (randomValue > 0.5f && !_invertedGravity)\n        {\n            InvertGravity();\n        }\n        \n        // Color shift\n        if (_colorShiftIntensity > 0f)\n        {\n            ApplyColorShift();\n        }\n    }\n    \n    void TriggerTeleportEvent()\n    {\n        GameObject targetObject = FindNearestTargetObject();\n        if (targetObject != null && _enableTeleportation)\n        {\n            TeleportTo(targetObject);\n            OnTeleportTriggered?.Invoke();\n        }\n    }\n    \n    void InvertGravity()\n    {\n        _invertedGravity = !_invertedGravity;\n        OnGravityInverted?.Invoke();\n        \n        if (_invertedGravity)\n        {\n            ApplyInvertedGravity();\n        }\n    }\n    \n    void ApplyInvertedGravity()\n    {\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 normalGravity = -rb.velocity * _normalGravityStrength;\n            rb.AddForce(normalGravity, ForceMode.Acceleration);\n        }\n    }\n    \n    void TeleportTo(GameObject target)\n    {\n        // Find appropriate target layer\n        Collider[] potentialTargets = Physics.OverlapSphere(target.transform.position, _teleportRange, _teleportTargetLayers);\n        \n        foreach (Collider col in potentialTargets)\n        {\n            if (col.gameObject == target.gameObject) continue;\n            \n            // Check if teleportation is allowed to this object's layer\n            int targetLayerIndex = col.gameObject.layer;\n            bool canTeleport = (_teleportTargetLayers.value & (1 << targetLayerIndex)) != 0;\n            \n            if (canTeleport)\n            {\n                // Perform teleportation logic here - use Teleport or InvokeTeleport method\n                break;\n            }\n        }\n    }\n    \n    void ApplyColorShift()\n    {\n        Color[] shiftedColors = new Color[_originalColors.Length];\n        \n        for (int i = 0; i < _originalColors.Length; i++)\n        {\n            float shiftAmount = Random.Range(-_colorShiftIntensity, _colorShiftIntensity);\n            Color originalColor = _originalColors[i];\n            float redShifted = Mathf.Lerp(originalColor.r, originalColor.r + shiftAmount, shiftAmount * _shiftCurve.Evaluate(0));\n            float greenShifted = Mathf.Lerp(originalColor.g, originalColor.g + shiftAmount, shiftAmount * _shiftCurve.Evaluate(0.5f));\n            float blueShifted = Mathf.Lerp(originalColor.b, originalColor.b + shiftAmount, shiftAmount * _shiftCurve.Evaluate(1));\n            \n            shiftedColors[i] = new Color(\n                Mathf.Clamp(redShifted, 0f, 1f),\n                Mathf.Clamp(greenShifted, 0f, 1f),\n                Mathf.Clamp(blueShifted, 0f, 1f)\n            );\n        }\n        \n        // Apply color shift to all visible materials in the field\n        foreach (Material mat in FindMaterialsInRange())\n        {\n            if (_material != null && _originalColors.Length > 0)\n            {\n                Color[] currentColors = new Color[mat.GetTextureCount()];\n                \n                for (int j = 0; j < mat.GetTextureCount(); j++)\n                {\n                    Texture2D tex = mat.GetTexture(j);\n                    if (tex != null)\n                    {\n                        int width = tex.width;\n                        int height = tex.height;\n                        float[] pixels = new float[width * height * 4];\n                        \n                        for (int x = 0; x < width; x++)\n                        {\n                            for (int y = 0; y < height; y++)\n                            {\n                                int pixelIndex = (x + y * width) * 4;\n                                Color4 c = tex.GetPixel(x, y);\n                                pixels[pixelIndex] = c.r;\n                                pixels[pixelIndex + 1] = c.g;\n                                pixels[pixelIndex + 2] = c.b;\n                                pixels[pixelIndex + 3] = c.a;\n                            }\n                        }\n                        \n                        Color[] shiftedPixels = new Color[pixels.Length / 4];\n                        for (int i = 0; i < shiftedPixels.Length; i++)\n                        {\n                            int pixelIndex = i * 4;\n                            float shiftAmount = Random.Range(-_colorShiftIntensity, _colorShiftIntensity);\n                            float redShifted = Mathf.Lerp(pixels[pixelIndex], pixels[pixelIndex + 3], shiftAmount * _shiftCurve.Evaluate(i / (width * height)));\n                            float greenShifted = Mathf.Lerp(pixels[pixelIndex + 1], pixels[pixelIndex + 7], shiftAmount * _shiftCurve.Evaluate(i / (width * height)));\n                            float blueShifted = Mathf.Lerp(pixels[pixelIndex + 2], pixels[pixelIndex + 8], shiftAmount * _shiftCurve.Evaluate(i / (width * height)));\n                            \n                            shiftedPixels[i] = new Color(\n                                Mathf.Clamp(redShifted, 0f, 1f),\n                                Mathf.Clamp(greenShifted, 0f, 1f),\n                                Mathf.Clamp(blueShifted, 0f, 1f)\n                            );\n                        }\n                        \n                        tex.SetPixels(shiftedPixels);\n                    }\n                }\n            }\n        }\n    }\n    \n    GameObject FindNearestTargetObject()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _teleportRange, _teleportTargetLayers);\n        \n        if (targets.Length == 0)\n            return null;\n        \n        float nearestDistance = float.MaxValue;\n        GameObject nearestTarget = null;\n        \n        foreach (Collider col in targets)\n        {\n            if (col.gameObject == gameObject) continue; // Don't teleport to self\n            \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance < nearestDistance)\n            {\n                nearestDistance = distance;\n                nearestTarget = col.gameObject;\n            }\n        }\n        \n        return nearestTarget;\n    }\n    \n    void CheckForPlayerInField()\n    {\n        Collider[] players = Physics.OverlapSphere(transform.position, _fieldRadius, _teleportTargetLayers);\n        \n        foreach (Collider col in players)\n        {\n            if (!col.CompareTag(\"Player\")) continue; // Only care about player objects\n            \n            // Play audio effect when player enters field\n            PlayAudioEffect();\n        }\n    }\n    \n    void FindMaterialsInRange()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _fieldRadius, _teleportTargetLayers);\n        \n        foreach (Collider col in targets)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            Material mat = col.GetComponent<Renderer>().material;\n            if (mat != null && mat.HasProperty(\"_MainTex\"))\n            {\n                _originalColors = mat.GetColorArray();\n            }\n        }\n    }\n    \n    void PlayAudioEffect()\n    {\n        if (_audioSource == null || !_isPlayingAudio)\n        {\n            _isPlayingAudio = true;\n            if (_audioClips.Length > 0)\n            {\n                int randomIndex = Random.Range(0, _audioClips.Length);\n                _audioSource.clip = _audioClips[randomIndex];\n                float pitch = Random.Range(_minPitch, _maxPitch);\n                float volume = Random.Range(0.8f, 1.2f);\n                \n                // Apply pitch shift\n                if (_audioSource.pitch != pitch)\n                {\n                    _audioSource.pitch = pitch;\n                    OnAudioPitchChanged?.Invoke();\n                }\n                \n                // Apply volume scaling\n                float targetVolume = _baseVolume * volume;\n                _audioSource.volume = Mathf.Lerp(_audioSource.volume, targetVolume, 0.5f);\n            }\n            \n            _audioSource.Play();\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_showUI) return;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _fieldRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * 2f, Vector3.one);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawLine(transform.position, transform.position + Vector3.forward * (_fieldRadius * 1.5f));\n    }\n    \n    public void SetFieldRadius(float radius)\n    {\n        _fieldRadius = Mathf.Max(0f, radius);\n        if (_showUI && _uiPrefab != null)\n        {\n            GameObject ui = GetComponentInChildren<Canvas>();\n            if (ui != null)\n            {\n                Slider slider = ui.GetComponent<Slider>();\n                if (slider != null) slider.value = _fieldRadius;\n            }\n        }\n    }\n    \n    public void ToggleTeleportation(bool enable)\n    {\n        _enableTeleportation = enable;\n        UpdateUI();\n    }\n    \n    public void SetTeleportEventsPerSecond(int eventsPerSecond)\n    {\n        _teleportEventsPerSecond = Mathf.Max(0, eventsPerSecond);\n        UpdateUI();\n    }",
    "per_behavior_docs": 9,
    "per_behavior_methods": 3,
    "per_behavior_doc_names": {
      "activate_probability_field": [
        "Camera.CalculateProjectionMatrixFromPhysicalProperties (0.63)",
        "Mathf.CorrelatedColorTemperatureToRGB (0.60)",
        "PhysicsVisualizationSettings (0.60)"
      ],
      "generate_random_events": [
        "Material.SetTextureOffset (0.65)",
        "Material.GetTextureOffset (0.65)",
        "Material.SetShaderPassEnabled (0.64)"
      ],
      "update_holo_display": [
        "Animator.CrossFadeInFixedTime (0.67)",
        "Animator.PlayInFixedTime (0.65)",
        "WaitTimeoutMode (0.64)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 57,
        "justification": "Direct translation lacks clear abstraction, but has good initial structure. Methods are started but incomplete, and the approach lacks clear separation of probabilistic behaviors."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 72,
        "justification": "Strong Unity component design, excellent use of serialized fields, clear event handling, and modular approach to probabilistic behaviors. Provides good extension points and follows Unity best practices."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 69,
        "justification": "Very modular approach with explicit UnityEvents, good component initialization, and clear separation of concerns. Slightly less cohesive than monolithic but more granular."
      },
      "winner": "ir_monolithic",
      "key_differences": "Intermediate representation allows more structured generation, with the monolithic approach providing the best balance of modularity and comprehensive event handling.",
      "advantages": "Superior use of Unity patterns, more robust event management, clear serialization of configuration parameters, and a more extensible design that allows easy feature additions or modifications."
    },
    "error": null
  },
  {
    "prompt_num": 22,
    "prompt": "Design a temporal echo system where player actions are recorded for 10 seconds then replayed as a ghostly afterimage following the same path, with visual trails showing movement history, and the ability to interact with past-self echoes to solve puzzles requiring cooperation with your own ghost.",
    "timestamp": "2026-01-08T23:15:58.907202",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class TemporalEchoSystem : MonoBehaviour\n{\n    [Header(\"Temporal Settings\")]\n    [SerializeField] private float _timeWindow = 10f;\n    [SerializeField] private bool _loopAfterWindow = true;\n    [SerializeField] private LayerMask _ghostLayerMask = -1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private ParticleSystem _trailParticles;\n    [SerializeField] private LineRenderer _movementTrail;\n    [SerializeField] private TrailRenderer _historyTrail;\n    [SerializeField] private GameObject _ghostPrefab;\n    [SerializeField] private Renderer _currentGhostRenderer;\n    [SerializeField] private Material _ghostMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _echoSound;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private string _interactionTargetPrefix = \"TemporalEcho\";\n    \n    private List<TemporalEchoData> _recordedEchos = new List<TemporalEchoData>();\n    private GameObject _currentGhost;\n    private bool _isRecording = false;\n    private float _recordingStartTime;\n    \n    public class TemporalEchoData\n    {\n        public Vector3 startPos;\n        public Vector3 endPos;\n        public float duration;\n        public float timeOffset;\n        \n        public List<Vector3> waypoints = new List<Vector3>();\n        public bool hasPlayerInteraction;\n        public GameObject interactionTarget;\n        \n        public TemporalEchoData(Vector3 start, Vector3 end, float duration)\n        {\n            startPos = start;\n            endPos = end;\n            this.duration = duration;\n            timeOffset = -_timeWindow / 2f;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeGhosts();\n        _audioSource.clip = _echoSound;\n        _audioSource.loop = true;\n        StartCoroutine(TimeWindowTimer());\n    }\n    \n    private void InitializeGhosts()\n    {\n        GameObject[] ghostObjects = FindObjectsOfType<GameObject>().Where(obj => \n            obj.CompareTag(\"Ghost\") && !_recordedEchos.Any(e => e.hasPlayerInteraction && e.interactionTarget == obj)\n        ).ToArray();\n        \n        foreach (GameObject ghost in ghostObjects)\n        {\n            CreateTemporalGhost(ghost);\n        }\n    }\n    \n    private void CreateTemporalGhost(GameObject target)\n    {\n        GameObject ghost = Instantiate(_ghostPrefab, transform.position + new Vector3(0, 5f, 0), Quaternion.identity);\n        \n        // Positioning\n        if (_currentGhostRenderer != null)\n            _currentGhostRenderer.gameObject.SetActive(false);\n            \n        // Trail setup\n        _movementTrail.enabled = false;\n        _historyTrail.enabled = true;\n        _historyTrail.startColor = Color.cyan;\n        _historyTrail.endColor = Color.yellow;\n        \n        // Particle trail\n        if (_trailParticles != null)\n            _trailParticles.Play();\n            \n        // Target reference\n        ghost.transform.SetParent(target.transform);\n        ghost.name = $\"TemporalEcho_{target.name}\";\n        \n        // Renderer\n        GameObject rendererGO = new GameObject(\"GhostRenderer\");\n        rendererGO.transform.SetParent(ghost.transform);\n        _currentGhostRenderer.gameObject.SetActive(false);\n        rendererGO.AddComponent<TrailRenderer>();\n        rendererGO.GetComponent<TrailRenderer>().trailColor = Color.cyan;\n        rendererGO.GetComponent<TrailRenderer>().trailWidth = 0.1f;\n        \n        // Audio\n        AudioSource audio = ghost.AddComponent<AudioSource>();\n        audio.clip = _echoSound;\n        audio.loop = true;\n        audio.volume = 0.5f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isRecording && !string.IsNullOrEmpty(_interactionTargetPrefix))\n        {\n            string targetName = other.CompareTag(\"Player\") ? other.gameObject.name : other.gameObject.GetComponent<TemporaryEchoTarget>().targetName;\n            \n            if (targetName.StartsWith(_interactionTargetPrefix) && \n                Vector3.Distance(transform.position, other.transform.position) <= _interactionRange)\n            {\n                PerformInteraction(other.gameObject);\n            }\n        }\n    }\n    \n    private void PerformInteraction(GameObject target)\n    {\n        TemporalEchoData echo = FindOrCreateEcho(target);\n        if (echo == null)\n        {\n            echo = new TemporalEchoData(transform.position, transform.position, 0.5f);\n            echo.hasPlayerInteraction = true;\n            echo.interactionTarget = target;\n            _recordedEchos.Add(echo);\n        }\n        \n        // Play interaction sound\n        AudioSource audio = target.GetComponent<AudioSource>();\n        if (audio != null && !audio.isPlaying)\n            audio.PlayOneShot(_echoSound);\n            \n        // Visual feedback on target\n        GameObject visual = target.GetComponentInChildren<Collider>()?.gameObject;\n        if (visual != null)\n        {\n            visual.SetActive(false);\n            Debug.DrawRay(transform.position, -_interactionRange * transform.forward, 0.1f);\n        }\n    }\n    \n    private TemporalEchoData FindOrCreateEcho(GameObject target)\n    {\n        foreach (var echo in _recordedEchos)\n        {\n            if (echo.hasPlayerInteraction && echo.interactionTarget == target)\n                return echo;\n        }\n        \n        // Try to find existing data for this target\n        foreach (var echo in _recordedEchos)\n        {\n            if (!echo.hasPlayerInteraction && \n                echo.startPos == target.transform.position &&\n                echo.endPos == target.transform.position)\n            {\n                echo.waypoints.Add(target.transform.position);\n                return echo;\n            }\n        }\n        \n        // Create new data\n        TemporalEchoData newEcho = new TemporalEchoData(\n            target.transform.position, \n            target.transform.position, \n            0.5f\n        );\n        newEcho.hasPlayerInteraction = true;\n        newEcho.interactionTarget = target;\n        _recordedEchos.Add(newEcho);\n        return newEcho;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        // Draw recording boundaries\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + transform.forward * 2f;\n        Gizmos.DrawWireCube(startPos, new Vector3(0.5f, 1f, 0.5f));\n        \n        // Draw movement trails for echoes\n        foreach (var echo in _recordedEchos)\n        {\n            if (echo.waypoints.Count > 1)\n            {\n                Gizmos.color = Color.cyan;\n                Vector3 start = echo.waypoints[0];\n                Vector3 end = echo.waypoints[^1];\n                Gizmos.DrawLine(start, end);\n            }\n        }\n    }\n    \n    private IEnumerator TimeWindowTimer()\n    {\n        _isRecording = false;\n        \n        while (_loopAfterWindow)\n        {\n            yield return new WaitForSeconds(_timeWindow);\n            \n            // Find echoes that should be replayed\n            List<TemporalEchoData> replays = new List<TemporalEchoData>();\n            foreach (var echo in _recordedEchos)\n            {\n                bool shouldReplay = true;\n                \n                if (_loopAfterWindow && echo.timeOffset < 0f)\n                {\n                    // Check if this echo is still within window\n                    float elapsed = Mathf.Abs((echo.timeOffset + _recordingStartTime) - Time.time);\n                    shouldReplay = elapsed <= _timeWindow * 0.8f;\n                }\n                \n                if (shouldReplay)\n                    replays.Add(echo);\n            }\n            \n            // Play all replays\n            foreach (var echo in replays)\n            {\n                PlayEcho(echo);\n            }\n        }\n    }\n    \n    private void PlayEcho(TemporalEchoData echo)\n    {\n        // Position ghost at start\n        _currentGhost.transform.position = echo.startPos;\n        \n        // Set trail renderer color to match path points\n        if (_historyTrail != null)\n        {\n            float progress = 0f;\n            Vector3 startPos = echo.waypoints[0];\n            Vector3 endPos = echo.waypoints[^1];\n            \n            for (int i = 0; i < echo.waypoints.Count - 1; i++)\n            {\n                Vector3 pointA = echo.waypoints[i];\n                Vector3 pointB = echo.waypoints[i + 1];\n                \n                // Calculate movement direction\n                float distance = Vector3.Distance(pointA, pointB);\n                if (distance > 0.01f)\n                {\n                    progress = (Vector3.Dot(transform.position - pointA, pointB - pointA) / distance) / Mathf.Sqrt(distance * distance);\n                }\n                else\n                {\n                    progress = 1f;\n                }\n                \n                // Set trail color based on progress\n                Color targetColor = Color.Lerp(Color.cyan, Color.yellow, progress);\n                _historyTrail.startColor = targetColor;\n                _historyTrail.endColor = targetColor;\n            }\n        }\n        \n        // Play audio\n        AudioSource audio = _currentGhost.GetComponent<AudioSource>();\n        if (audio != null)\n        {\n            audio.Play();\n        }\n    }\n    \n    public void ReplayEcho(Vector3 startPos, Vector3 endPos, float duration)\n    {\n        TemporalEchoData echo = new TemporalEchoData(startPos, endPos, duration);\n        PlayEcho(echo);\n    }\n    \n    private void OnApplicationQuit()\n    {\n        // Clean up ghost components\n        foreach (GameObject ghost in FindObjectsOfType<GameObject>().Where(obj => \n            obj.name.StartsWith(\"TemporalEcho\") && \n            (obj.GetComponent<TemporaryEchoTarget>() == null || !obj.GetComponent<TemporaryEchoTarget>().targetName.StartsWith(\"TemporalEcho\"))\n        ))\n        {\n            Destroy(ghost);\n        }\n    }\n    \n    private class TemporaryEchoTarget\n    {\n        public string targetName;\n        public GameObject interactable;\n        \n        public TemporaryEchoTarget(GameObject obj)\n        {\n            if (obj.CompareTag(\"Player\"))\n                targetName = obj.name;\n            else if (obj.GetComponent<TemporaryEchoTarget>() == null && \n                     !string.IsNullOrEmpty(obj.gameObject.name))\n                targetName = obj.gameObject.name;\n            \n            interactable = obj.GetComponent<Collider>();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        // Update ghost position based on recorded waypoints\n        if (_currentGhost != null)\n        {\n            float progress = 0f;\n            Vector3 startPos = _recordedEchos[0].waypoints[0];\n            Vector3 endPos = _recordedEchos[0].waypoints[^1];\n            \n            for (int i = 0; i < _recordedEchos.Count - 1; i++)\n            {\n                if (_currentGhost.transform.position == _recordedEchos[i].waypoints[^1])\n                {\n                    progress = 1f;\n                    break;\n                }\n            }\n            \n            if (progress > 0.01f)\n            {\n                float distance = Vector3.Distance(_currentGhost.transform.position, endPos);\n                if (distance > 0.01f)\n                {\n                    progress = (Vector3.Dot(_currentGhost.transform.position - startPos, endPos - startPos) / distance) / Mathf.Sqrt(distance * distance);\n                }\n                else\n                {\n                    progress = 1f;\n                }\n                \n                Vector3 targetPosition = startPos + (endPos - startPos) * progress;\n                _currentGhost.transform.position = targetPosition;\n            }\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        // Draw recording window boundaries\n        Gizmos.color = Color.red;\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + transform.forward * 2f;\n        \n        Gizmos.DrawWireCube(startPos, new Vector3(0.5f, 1f, 0.5f));\n        \n        // Draw interaction points\n        foreach (var echo in _recordedEchos)\n        {\n            if (echo.hasPlayerInteraction && echo.interactionTarget != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawLine(echo.interactionTarget.transform.position,\n                    echo.interactionTarget.transform.position + transform.forward * 3f);\n            }\n        }\n    }\n}",
    "ir_json": {
      "class_name": "TemporalEcho",
      "components": [
        "Renderer",
        "Collider",
        "Animator"
      ],
      "fields": [
        {
          "name": "playerPath",
          "type": "Transform[]",
          "default": null
        },
        {
          "name": "trailDensity",
          "type": "float",
          "default": 0.5
        },
        {
          "name": "echoHeight",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "ghostFadeSpeed",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "interactionZoneRadius",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "interactionCooldown",
          "type": "float",
          "default": 5.0
        }
      ],
      "behaviors": [
        {
          "name": "record_player_movement",
          "trigger": "when player enters interaction zone while recording is active",
          "actions": [
            {
              "action": "add current position to path record"
            },
            {
              "action": "create trail point at this location"
            }
          ]
        },
        {
          "name": "start_recording",
          "trigger": "when recording starts and player is holding interaction key",
          "actions": [
            {
              "action": "enable path tracking for player"
            },
            {
              "action": "set ghost visibility to semi-transparent"
            }
          ]
        },
        {
          "name": "stop_recording",
          "trigger": "when recording duration expires or player releases interaction key",
          "actions": [
            {
              "action": "convert recorded path points into replayable segments"
            },
            {
              "action": "freeze player position at last recorded point"
            }
          ]
        },
        {
          "name": "play_echo_sequence",
          "trigger": "when echo playback is triggered by time or player action",
          "actions": [
            {
              "action": "spawn ghostly avatar at starting position"
            },
            {
              "action": "follow path segments in order"
            },
            {
              "action": "create movement trail effects along each segment"
            }
          ]
        },
        {
          "name": "update_trail Effects",
          "trigger": "every frame during echo playback",
          "actions": [
            {
              "action": "draw ghost outline at current position"
            },
            {
              "action": "apply particle effects showing movement direction"
            }
          ]
        },
        {
          "name": "ghost_interaction",
          "trigger": "when player interacts with their own echo within cooldown period",
          "actions": [
            {
              "action": "enable two-way interaction mode"
            },
            {
              "action": "create cooperative input prompt for ghost-controlled actions"
            }
          ]
        },
        {
          "name": "complete_interaction",
          "trigger": "when ghost-controlled action is successful during two-way interaction",
          "actions": [
            {
              "action": "add successful action to player history log"
            },
            {
              "action": "extend current recording duration by puzzle completion time"
            }
          ]
        }
      ]
    },
    "ir_code": "using System.Collections.Generic;\nusing UnityEngine;\n\npublic class TemporalEcho : MonoBehaviour\n{\n    [Header(\"Ghost Settings\")]\n    [SerializeField] private GameObject _ghostPrefab;\n    [SerializeField] private float _ghostOpacity = 0.8f;\n    [SerializeField] private float _ghostSpeed = 2f;\n    \n    [Header(\"Path Recording\")]\n    [SerializeField] private Transform[] _playerPath;\n    [SerializeField] private bool _recordPlayerMovement = true;\n    [SerializeField] private float _interactionCooldown = 5f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _trailParticles;\n    [SerializeField] private TrailRenderer _ghostTrailRenderer;\n    [SerializeField] private LineRenderer _ghostRaycast;\n    [SerializeField] private float _trailDensity = 1f;\n    [SerializeField] private Color _trailColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _footstepSound;\n    [SerializeField] private AudioClip _interactionSound;\n    \n    private Transform _currentPlayerPosition;\n    private bool _isRecording = false;\n    private float _lastInteractionTime = 0f;\n    private List<Transform> _recordedPositions = new List<Transform>();\n    private List<Collider> _recordedColliders = new List<Collider>();\n    private List<Vector3> _trailPoints = new List<Vector3>();\n    \n    private void Start()\n    {\n        if (_ghostPrefab != null)\n            _ghostPrefab.SetActive(false);\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateGhostVisuals();\n        UpdateTrailEffects();\n        HandleAudio();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (ShouldTriggerTemporalEcho(other))\n        {\n            StartTemporalEcho(other);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (ShouldTriggerTemporalEcho(other))\n        {\n            StopTemporalEcho(other);\n        }\n    }\n    \n    private bool ShouldTriggerTemporalEcho(Collider other)\n    {\n        return _recordPlayerMovement && \n               !_isRecording &&\n               Input.GetKeyDown(_interactionKey) &&\n               Time.time >= _lastInteractionTime + _interactionCooldown;\n    }\n    \n    private void StartTemporalEcho(Collider playerCollider)\n    {\n        _currentPlayerPosition = playerCollider.transform.position;\n        \n        if (_ghostPrefab != null)\n            _ghostPrefab.SetActive(true);\n            \n        if (_trailParticles != null)\n            _trailParticles.Play();\n            \n        _isRecording = true;\n    }\n    \n    private void StopTemporalEcho(Collider playerCollider)\n    {\n        _currentPlayerPosition = playerCollider.transform.position;\n        \n        if (_ghostPrefab != null)\n            _ghostPrefab.SetActive(false);\n            \n        if (_trailParticles != null && _trailParticles.isPlaying)\n            _trailParticles.Stop();\n            \n        _isRecording = false;\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_interactionKey))\n        {\n            _lastInteractionTime = Time.time;\n            \n            if (!_recordPlayerMovement || _isRecording || !ShouldTriggerTemporalEcho(null))\n                return;\n                \n            StartTemporalEcho(transform);\n        }\n    }\n    \n    private void UpdateGhostVisuals()\n    {\n        if (_ghostPrefab != null && _isRecording)\n        {\n            Vector3 ghostPos = _currentPlayerPosition;\n            \n            // Add random movement for visual echo effect\n            ghostPos.x += Random.Range(-0.5f, 0.5f) * _ghostSpeed;\n            ghostPos.y += Random.Range(-0.5f, 0.5f) * _ghostSpeed;\n            \n            if (_ghostRaycast != null)\n            {\n                _ghostRaycast.SetPosition(0, ghostPos);\n                _ghostRaycast.enabled = true;\n                _ghostRaycast.color = Color.green;\n            }\n        }\n    }\n    \n    private void UpdateTrailEffects()\n    {\n        if (_trailPoints.Count > 0 && _isRecording)\n        {\n            // Draw trail points\n            for (int i = 0; i < _trailPoints.Count - 1; i++)\n            {\n                Vector3 start = _trailPoints[i];\n                Vector3 end = _trailPoints[i + 1];\n                \n                if (_ghostTrailRenderer != null)\n                    _ghostTrailRenderer.SetPosition(i, new Vector3(start.x, start.y, start.z));\n                    \n                if (_trailParticles != null)\n                {\n                    ParticleSystem particle = _trailParticles.GetComponent<ParticleSystem>();\n                    if (particle != null)\n                    {\n                        particle.Play();\n                        particle.transform.position = new Vector3(end.x, end.y, end.z);\n                        particle.transform.rotation = transform.rotation;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null) return;\n        \n        // Play footsteps when not on ground\n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, Vector3.down, out hit))\n        {\n            if (hit.collider.CompareTag(\"Ground\"))\n            {\n                if (_footstepSound != null && _audioSource.isPlaying)\n                    _audioSource.PlayOneShot(_footstepSound);\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        if (_playerPath != null)\n        {\n            for (int i = 0; i < _playerPath.Length - 1; i++)\n            {\n                Vector3 start = _playerPath[i].position;\n                Vector3 end = _playerPath[i + 1].position;\n                \n                Gizmos.DrawLine(start, end);\n                Gizmos.color = Color.red;\n            }\n        }\n        \n        if (_ghostRaycast != null)\n        {\n            Gizmos.color = Color.green;\n            _ghostRaycast.enabled = true;\n            _ghostRaycast.SetPosition(0, Vector3.up * 2f);\n            _ghostRaycast.color = Color.yellow;\n        }\n    }\n    \n    private void AddTrailPoint(Vector3 position)\n    {\n        if (!_trailPoints.Contains(new Vector3(position.x, position.y, position.z)))\n        {\n            _trailPoints.Add(new Vector3(position.x, position.y, position.z));\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.CrossFadeInFixedTime (0.70)",
      "Animator.PlayInFixedTime (0.70)",
      "Animator.GetNextAnimationClipState (0.67)",
      "AnimationMode.SamplePlayableGraph (0.46)",
      "AnimationMode.SampleAnimationClip (0.45)",
      "AnimationMode.InAnimationMode (0.44)",
      "AnimationClip.EnsureQuaternionContinuity (0.44)",
      "AnimationClip.SampleAnimation (0.44)",
      "AnimationClip.AddEvent (0.43)",
      "PlayerLoop.TimeUpdate (0.43)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class TemporalEchoSystem : MonoBehaviour\n{\n    [Header(\"Temporal Echo Settings\")]\n    public float echoDuration = 10f;\n    public int trailCount = 20;\n    public float trailDensity = 1f;\n    public AnimationCurve ghostFadeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Audio Settings\")]\n    public AudioClip[] echoSounds;\n    public AudioSource audioSource;\n    public float audioVolume = 1f;\n    public float pitchScale = 1f;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem[] trailParticles;\n    public GameObject ghostObjectPrefab;\n    public Renderer[] targetRenderers;\n    public Material[] trailMaterials;\n    public Color ghostTrailColor = new Color(0.3f, 0.6f, 1f, 0.8f);\n    public float trailLifetime = 5f;\n    \n    [Header(\"Interaction\")]\n    public float interactionRange = 10f;\n    public GameObject interactionPromptPrefab;\n    public Transform[] interactionPromptTriggers;\n    public KeyCode interactKey = KeyCode.E;\n    public bool useInput = true;\n    \n    private Rigidbody _rigidbody;\n    private Dictionary<Collider, TemporalEchoData> _echoData = new Dictionary<Collider, TemporalEchoData>();\n    private List<GameObject> _trailObjects = new List<GameObject>();\n    private List<ParticleSystem> _trailParticlesList = new List<ParticleSystem>();\n    private bool _isPlayerInRange = false;\n    \n    [System.Serializable]\n    public class TemporalEchoData\n    {\n        public Vector3[] movementPositions;\n        public float[] timestamps;\n        public AudioClip[] audioClips;\n        public int totalSteps;\n        \n        public TemporalEchoData()\n        {\n            movementPositions = new Vector3[trailCount];\n            timestamps = new float[trailCount];\n            audioClips = new AudioClip[trailCount];\n            totalSteps = trailCount;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeAudioSource();\n        CreateTrailParticles();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"TemporalEchoSystem requires a Rigidbody component!\");\n        }\n        \n        if (audioSource == null)\n        {\n            audioSource = GetComponent<AudioSource>();\n            if (audioSource == null)\n            {\n                audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n    }\n    \n    private void InitializeAudioSource()\n    {\n        if (_rigidbody != null && echoSounds != null)\n        {\n            _rigidbody.audioSource = audioSource;\n            _rigidbody.audioSource.clip = echoSounds[Random.Range(0, echoSounds.Length)];\n            _rigidbody.audioSource.loop = true;\n            _rigidbody.audioSource.volume = audioVolume;\n            _rigidbody.audioSource.pitch = pitchScale;\n        }\n    }\n    \n    private void CreateTrailParticles()\n    {\n        if (_trailParticles == null)\n        {\n            GameObject[] trailObjects = new GameObject[trailCount];\n            \n            for (int i = 0; i < trailCount; i++)\n            {\n                TrailRenderer renderer = gameObject.AddComponent<TrailRenderer>();\n                renderer.enabled = true;\n                renderer.startWidth = 0.1f;\n                renderer.endWidth = 0.3f;\n                renderer.useWorldSpace = false;\n                renderer.positionScale = trailDensity;\n                renderer.color = ghostTrailColor;\n                renderer lifecycle = TrailRenderer.Lifecycle.Infinite;\n                \n                GameObject obj = new GameObject($\"TemporalEcho_{i}\");\n                trailObjects[i] = obj;\n                obj.AddComponent<Collider>();\n            }\n            \n            _trailObjects = trailObjects;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPlayerInRange)\n        {\n            RecordPlayerMovement();\n            UpdateVisualTrails();\n            PlayAudioLoop();\n        }\n        \n        CleanupGhostTrail();\n    }\n    \n    private void RecordPlayerMovement()\n    {\n        Vector3[] movementPositions = new Vector3[trailCount];\n        float[] timestamps = new float[trailCount];\n        AudioClip[] audioClips = new AudioClip[trailCount];\n        int stepIndex = 0;\n        \n        for (int i = 0; i < trailCount; i++)\n        {\n            if (_rigidbody != null)\n            {\n                movementPositions[i] = _rigidbody.position;\n                timestamps[i] = Time.time - _rigidbody.timestamp;\n                \n                // Store last frame position to detect movement\n                Vector3 prevPosition = _rigidbody.position;\n                float prevTime = _rigidbody.timestamp;\n                \n                if (prevPosition != Vector3.zero)\n                {\n                    // Calculate direction and speed from previous frame\n                    Vector3 direction = (_rigidbody.position - prevPosition).normalized;\n                    float speed = Vector3.Distance(_rigidbody.position, prevPosition);\n                    \n                    movementPositions[i] += direction * Time.deltaTime * speed;\n                }\n                \n                audioClips[i] = _rigidbody.audioSource.clip;\n            }\n            \n            stepIndex = i;\n        }\n        \n        _echoData[_rigidbody.gameObject.GetComponent<Collider>()!] = new TemporalEchoData\n        {\n            movementPositions = movementPositions,\n            timestamps = timestamps,\n            audioClips = audioClips,\n            totalSteps = trailCount\n        };\n    }\n    \n    private void UpdateVisualTrails()\n    {\n        for (int i = 0; i < trailCount; i++)\n        {\n            TrailRenderer renderer = _trailObjects[i].GetComponent<TrailRenderer>();\n            if (renderer != null)\n            {\n                // Calculate movement offset based on recorded positions\n                Vector3 targetPosition = _echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.movementPositions[i] ?? _rigidbody.position;\n                \n                // Apply movement to current trail position\n                renderer.transform.position = new Vector3(\n                    transform.position.x + (targetPosition - transform.position).x * 0.5f,\n                    transform.position.y + (targetPosition - transform.position).y * 0.5f,\n                    transform.position.z + (targetPosition - transform.position).z * 0.5f\n                );\n                \n                // Fade trail opacity based on time elapsed since recorded position\n                float fadeAmount = ghostFadeCurve.Evaluate(1f - Mathf.Abs((Time.time - _echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.timestamps[i] ?? 0f) / (trailLifetime * 2f)));\n                renderer.color = new Color(renderer.color.r, renderer.color.g, renderer.color.b, fadeAmount);\n            }\n        }\n    }\n    \n    private void PlayAudioLoop()\n    {\n        if (_rigidbody != null && _rigidbody.audioSource != null)\n        {\n            // Loop the recorded audio clip\n            _rigidbody.audioSource.Play();\n            \n            // Adjust pitch based on movement speed (optional effect)\n            float movementSpeed = Vector3.Distance(_rigidbody.position, _echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.movementPositions[0] ?? _rigidbody.position);\n            if (movementSpeed > 0f)\n            {\n                _rigidbody.audioSource.pitch = Mathf.Lerp(1f, movementSpeed * 0.5f, Time.deltaTime * 2f);\n            }\n        }\n    }\n    \n    private void CleanupGhostTrail()\n    {\n        for (int i = trailCount - 1; i >= 0; i--)\n        {\n            TrailRenderer renderer = _trailObjects[i].GetComponent<TrailRenderer>();\n            if (renderer != null)\n            {\n                // Check if trail has faded out\n                bool shouldDestroy = false;\n                \n                if (_echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.movementPositions[i] == Vector3.zero && \n                    _echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.timestamps[i] >= Time.time - trailLifetime)\n                {\n                    shouldDestroy = true;\n                }\n                \n                if (shouldDestroy)\n                {\n                    renderer.enabled = false;\n                    _trailObjects[i].DestroyAfterDelay(0.1f);\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!string.IsNullOrEmpty(interactionPromptPrefab.name))\n        {\n            GameObject prompt = Instantiate(interactionPromptPrefab, other.transform.position, Quaternion.identity);\n            prompt.SetActive(true);\n        }\n        \n        _isPlayerInRange = false;\n        foreach (Transform trigger in interactionPromptTriggers)\n        {\n            if (trigger == null) continue;\n            \n            if (trigger.CompareTag(\"Player\"))\n            {\n                _isPlayerInRange = true;\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_isPlayerInRange && !string.IsNullOrEmpty(interactionPromptPrefab.name))\n        {\n            GameObject prompt = DestroyImmediate(interactionPromptPrefab);\n        }\n        \n        _isPlayerInRange = false;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInRange = true;\n            \n            // Store player interaction data\n            TemporalEchoData playerData = new TemporalEchoData();\n            playerData.totalSteps = trailCount;\n            playerData.audioClips = new AudioClip[trailCount];\n            \n            for (int i = 0; i < trailCount; i++)\n            {\n                if (_rigidbody != null)\n                {\n                    playerData.movementPositions[i] = _rigidbody.position;\n                    playerData.audioClips[i] = _rigidbody.audioSource.clip;\n                }\n            }\n            \n            // Create ghost object\n            GameObject ghost = Instantiate(ghostObjectPrefab, other.transform.position, Quaternion.identity);\n            ghost.SetActive(false);\n            \n            // Set up trail renderer for ghost\n            TrailRenderer ghostTR = ghost.AddComponent<TrailRenderer>();\n            ghostTR.enabled = true;\n            ghostTR.startWidth = 0.1f;\n            ghostTR.endWidth = 0.3f;\n            ghostTR.color = new Color(0.2f, 0.4f, 0.8f, 0.9f);\n            ghostTR.lifetime = trailLifetime;\n            \n            // Create audio source for ghost\n            AudioSource ghostAudioSource = ghost.AddComponent<AudioSource>();\n            ghostAudioSource.loop = true;\n            ghostAudioSource.volume = audioVolume * 0.5f;\n            ghostAudioSource.pitch = pitchScale * 1.2f;\n            ghostAudioSource.clip = echoSounds[Random.Range(0, echoSounds.Length)];\n            \n            // Store player interaction data in ghost\n            ghost.GetComponent<Collider>()!.gameObject.SetActive(true);\n            ghostTR.transform.position = other.transform.position;\n            \n            // Add to visual effects list\n            _trailParticlesList.Add(ghostTR);\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (_isPlayerInRange && !string.IsNullOrEmpty(interactionPromptPrefab.name))\n        {\n            GameObject prompt = Instantiate(interactionPromptPrefab, other.transform.position, Quaternion.identity);\n            prompt.SetActive(true);\n            \n            // Update interaction prompt with ghost position\n            if (interactionPromptTriggers.Length > 0 && interactionPromptTrigger = interactionPromptTriggers[Random.Range(0, interactionPromptTriggers.Length)];\n            {\n                if (interactionPromptTrigger != null)\n                {\n                    interactionPromptTransform = interactionPromptTrigger.transform;\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_isPlayerInRange && ghostObjectPrefab != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_rigidbody.position, interactionRange);\n            \n            // Draw ghost outline\n            GameObject ghost = ghostObjectPrefab;\n            if (ghost != null)\n            {\n                Gizmos.color = new Color(0.3f, 0.6f, 1f, 0.8f);\n                Gizmos.DrawWireCube(ghost.transform.position, ghost.GetComponent<Collider>()!.bounds.size);\n            }\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_isPlayerInRange && trailParticles != null)\n        {\n            // Draw movement trails\n            for (int i = 0; i < trailCount; i++)\n            {\n                TrailRenderer tr = _trailObjects[i].GetComponent<TrailRenderer>();\n                if (tr != null)\n                {\n                    Gizmos.color = ghostTrailColor;\n                    Vector3 start = tr.transform.position;\n                    Vector3 end = _echoData[_rigidbody.gameObject.GetComponent<Collider>()!]?.movementPositions[i] ?? start;\n                    \n                    // Draw line from current position to recorded movement position\n                    if (start != end)\n                    {\n                        Gizmos.DrawLine(start, new Vector3(\n                            start.x + (end - start).x * 0.5f,\n                            start.y + (end - start).y * 0.5f,\n                            start.z + (end - start).z * 0.5f\n                        ));\n                    }\n                }\n            }\n        }\n    }\n    \n    public void TriggerInteraction()\n    {\n        if (_isPlayerInRange && useInput)\n        {\n            if (Input.GetKeyDown(interactKey))\n            {\n                PerformInteraction();\n            }\n        }\n    }\n    \n    private void PerformInteraction()\n    {\n        // Copy movement pattern from ghost trail\n        TemporalEchoData playerData = _echoData[_rigidbody.gameObject.GetComponent<Collider>()!] ?? new TemporalEchoData();\n        \n        if (playerData.totalSteps > 0)\n        {\n            Vector3[] movements = playerData.movementPositions;\n            \n            for (int i = 0; i < trailCount; i++)\n            {\n                // Apply movement offset to current position\n                transform.position += (movements[i] - transform.position) * 0.5f;\n                \n                // Play recorded audio clip at this step\n                AudioSource audioSource = GetComponent<AudioSource>();\n                if (audioSource != null && movements[i].distance > 0.1f)\n                {\n                    float distanceRatio = Mathf.Clamp01(movements[i].distance / interactionRange);\n                    audioSource.pitch = Mathf.Lerp(1f, distanceRatio * 2f, Time.deltaTime * 3f);\n                    audioSource.PlayOneShot(playerData.audioClips[i]);\n                }\n            }\n            \n            // Create cooperative trail with ghost",
    "per_behavior_docs": 15,
    "per_behavior_methods": 7,
    "per_behavior_doc_names": {
      "record_player_movement": [
        "GameObject.InstantiateGameObjects (0.72)",
        "ParticleSystemAnimationTimeMode (0.68)",
        "ParticleSystem.VelocityOverLifetimeModule (0.68)"
      ],
      "play_temporal_audio": [
        "Animator.PlayInFixedTime (0.65)",
        "Animator.StopRecording (0.64)",
        "AudioSource.PlayScheduled (0.63)"
      ],
      "create_ghost_echo": [
        "Animator.GetParameter (0.67)",
        "GameObject.InstantiateGameObjects (0.67)",
        "Animator.GetBoneTransform (0.66)"
      ],
      "update_ghost_trails": [
        "GameObject.InstantiateGameObjects (0.72)",
        "ParticleSystem.GetPlaybackState (0.68)",
        "ParticleSystemAnimationTimeMode (0.67)"
      ],
      "enable_player_interaction": [
        "InteractionMode (0.61)",
        "Animator.PlayInFixedTime (0.61)",
        "Animator.GetCurrentAnimatorClipInfo (0.60)"
      ],
      "ghost_interaction_behavior": [
        "GameObject.InstantiateGameObjects (0.69)",
        "Animator.GetBoneTransform (0.68)",
        "Animator.GetAnimatorTransitionInfo (0.66)"
      ],
      "fade_out_ghost": [
        "Rigidbody.MovePosition (0.67)",
        "Rigidbody.MoveRotation (0.67)",
        "Transform.GetPositionAndRotation (0.66)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 45,
        "justification": "Direct translation lacks clear separation of concerns, with methods growing complex. Strong Unity serialization but minimal modularity. Incomplete implementation with partially implemented methods."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 67,
        "justification": "Well-structured with clear method responsibilities, excellent use of Unity serialization, defensive programming with null checks. Strong separation of concerns and easy extension points."
      },
      "ir_per_behavior": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 59,
        "justification": "Good modular approach with behavior-specific methods, but slightly over-engineered. Strong Unity component design with extensive configuration options."
      },
      "winner": "ir_monolithic",
      "key_differences": "Intermediate representation allows more structured code generation, with clear method boundaries and better Unity integration",
      "advantages": "Best balance of modularity, extensibility, and Unity best practices. Provides clear scaffolding for temporal echo system with minimal developer intervention needed"
    },
    "error": null
  },
  {
    "prompt_num": 23,
    "prompt": "Create a firework launcher that every 2 seconds fires a rocket upward with trail particles and whistle sound, exploding at random heights into 50-200 colorful spark particles that drift down with gravity and wind influence, each explosion having randomized color palette and pattern shape.",
    "timestamp": "2026-01-08T23:20:23.398762",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FireworkLauncher : MonoBehaviour\n{\n    [Header(\"Firework Settings\")]\n    [SerializeField] private float _fireworkInterval = 2f;\n    [SerializeField] private int _maxFireworksPerSecond = 5;\n    \n    [Header(\"Rocket Settings\")]\n    [SerializeField] private GameObject _rocketPrefab;\n    [SerializeField] private float _launchForce = 15f;\n    [SerializeField] private float _explosionForce = 10f;\n    [SerializeField] private float _explosionDelay = 0.1f;\n    [SerializeField] private int _maxExplosions = 3;\n    \n    [Header(\"Trail Settings\")]\n    [SerializeField] private ParticleSystem _trailParticleSystem;\n    [SerializeField] private Color _trailColor = Color.white;\n    [SerializeField] private float _trailLifetime = 5f;\n    \n    [Header(\"Whistle Settings\")]\n    [SerializeField] private AudioSource _whistleAudioSource;\n    [SerializeField] private AudioClip[] _whistleClips;\n    [SerializeField] private float _whistleVolume = 0.8f;\n    \n    [Header(\"Spark Settings\")]\n    [SerializeField] private int _sparkCount = 50;\n    [SerializeField] private float _sparkLifetime = 2f;\n    [SerializeField] private Vector3[] _sparkStartPositions;\n    [SerializeField] private Color[] _sparkColors;\n    [SerializeField] private float _maxWindStrength = 5f;\n    \n    [Header(\"Randomization\")]\n    [SerializeField] private bool _useRandomExplosionHeight = true;\n    [SerializeField] private float _minExplosionHeight = 10f;\n    [SerializeField] private float _maxExplosionHeight = 30f;\n    \n    private float _nextFireworkTime;\n    private int _fireworkCount;\n    private List< Firework> _fireworks = new List<Firework>();\n    private float _windStrength;\n    \n    public enum ExplosionShape\n    {\n        Square,\n        Circle,\n        Diamond,\n        Triangle\n    }\n    \n    private class Firework\n    {\n        public GameObject rocket;\n        public ParticleSystem explosionParticles;\n        public Rigidbody explosionRigidbody;\n        public float explosionTime;\n        public Vector3 explosionPosition;\n        public Color[] sparkColors;\n        public ExplosionShape shape;\n        \n        public Firework(GameObject rocket, ParticleSystem explosionParticles)\n        {\n            this.rocket = rocket;\n            this.explosionParticles = explosionParticles;\n            \n            if (rocket != null && explosionParticles != null)\n            {\n                Rigidbody rb = rocket.GetComponent<Rigidbody>();\n                if (rb == null)\n                    rb = rocket.AddComponent<Rigidbody>();\n                \n                rb.velocity = new Vector3(0, 10f, 0);\n                \n                this.explosionRigidbody = rb;\n                this.explosionTime = Random.Range(0.05f, 0.2f);\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        _windStrength = Random.Range(-_maxWindStrength, _maxWindStrength);\n        _nextFireworkTime = Time.time + _fireworkInterval;\n        \n        if (_trailParticleSystem == null)\n            _trailParticleSystem = GetComponentInChildren<ParticleSystem>();\n        \n        if (_whistleAudioSource == null && _whistleClips.Length > 0)\n            _whistleAudioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _nextFireworkTime)\n        {\n            LaunchFirework();\n            _fireworkCount++;\n            _nextFireworkTime += Random.Range(1f, 2f);\n            \n            if (_fireworkCount % 10 == 0 && _maxFireworksPerSecond > 0)\n                _maxFireworksPerSecond--;\n        }\n    }\n    \n    private void LaunchFirework()\n    {\n        Firework firework = new Firework(null, null);\n        \n        // Create rocket\n        GameObject rocket = Instantiate(_rocketPrefab, transform.position, Quaternion.identity);\n        firework.rocket = rocket;\n        \n        // Apply launch force\n        Rigidbody rb = rocket.GetComponent<Rigidbody>();\n        if (rb != null)\n            rb.AddForce(Vector3.up * _launchForce, ForceMode.Impulse);\n        \n        // Create explosion particles\n        ParticleSystem explosionParticles = new ParticleSystem();\n        explosionParticles.transform.SetParent(rocket.transform);\n        \n        ExplosionShape randomShape = GetRandomExplosionShape();\n        firework.explosionParticles = explosionParticles;\n        \n        // Add main particle emission\n        firework.explosionParticles.AddParticle(new ParticleSystem.Emitter settings\n        {\n            startColor = new Color(_trailColor.r, _trailColor.g, _trailColor.b, 0.8f),\n            shape = ParticleShape.Box,\n            size = Vector3.one * 1f,\n            duration = 0.2f,\n            emissionOverLifetime = true,\n            velocityOverLifetime = false\n        });\n        \n        // Add trail emission\n        firework.explosionParticles.AddParticle(new ParticleSystem.Emitter settings\n        {\n            startColor = new Color(_trailColor.r, _trailColor.g, _trailColor.b, 0.3f),\n            shape = ParticleShape.Box,\n            size = Vector3.one * 2f,\n            duration = _trailLifetime,\n            emissionOverLifetime = true,\n            velocityOverLifetime = false\n        });\n        \n        firework.explosionParticles.Play();\n        \n        // Apply explosion force after delay\n        StartCoroutine(ExplosionCoroutine(firework));\n        \n        // Create spark particles\n        GenerateSparkParticles(firework);\n        \n        _fireworks.Add(firework);\n    }\n    \n    private IEnumerator ExplosionCoroutine(Firework firework)\n    {\n        yield return new WaitForSeconds(_explosionDelay);\n        \n        Rigidbody rb = firework.explosionRigidbody;\n        if (rb != null)\n        {\n            Vector3 explosionDirection = Random.insideUnitSphere.normalized;\n            float force = Random.Range(0.5f, 2f) * _explosionForce;\n            rb.AddExplosion(force * _windStrength, firework.explosionPosition + explosionDirection, \n                explosionDirection * 1.5f);\n        }\n        \n        // Clean up\n        firework.rocket = null;\n        firework.explosionParticles.Stop();\n        firework.explosionRigidbody = null;\n        \n        yield return new WaitForSeconds(0.01f);\n    }\n    \n    private void GenerateSparkParticles(Firework firework)\n    {\n        if (_sparkStartPositions == null || _sparkColors == null)\n        {\n            int count = _sparkCount;\n            Vector3[] positions = new Vector3[count];\n            Color[] colors = new Color[count];\n            \n            for (int i = 0; i < count; i++)\n            {\n                positions[i] = transform.position + Random.insideUnitSphere.normalized * 2f;\n                colors[i] = new Color(Random.Range(0.5f, 1f), \n                    Random.Range(0.3f, 1f), \n                    Random.Range(0.4f, 1f));\n            }\n            \n            _sparkStartPositions = positions;\n            _sparkColors = colors;\n        }\n        \n        // Create spark particle system\n        ParticleSystem sparks = new ParticleSystem();\n        sparks.transform.SetParent(firework.explosionParticles.transform);\n        \n        sparks.Play();\n        \n        for (int i = 0; i < _sparkCount; i++)\n        {\n            Particle[] sparkParticles = sparks.GetParticles() as Particle[];\n            if (sparkParticles == null) continue;\n            \n            // Apply random wind force\n            Vector3 windForce = Random.insideUnitSphere.normalized * _windStrength;\n            float scale = 0.1f + Random.Range(0, 0.5f);\n            Vector3 finalPosition = _sparkStartPositions[i] + windForce * scale;\n            \n            // Color variation\n            Color targetColor = _sparkColors[i];\n            Color finalColor = new Color(targetColor.r, targetColor.g, targetColor.b, \n                Random.Range(0.6f, 1f));\n            \n            // Add spark particle\n            Particle particle = new Particle();\n            particle.position = finalPosition;\n            particle.color = finalColor;\n            particle.velocity = -transform.up * 2f + windForce * 1.5f;\n            particle.lifetime = _sparkLifetime;\n            particle.startLifetime = 0;\n            \n            // Add to sparks\n            sparks.AddParticle(particle);\n        }\n    }\n    \n    private ExplosionShape GetRandomExplosionShape()\n    {\n        return (ExlosionShape)Random.Range(0, 4);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!string.IsNullOrEmpty(other.gameObject.name))\n        {\n            // Optional: play explosion sound effect\n            PlayWhistleSound();\n        }\n        \n        // Optional: destroy after collision\n        Destroy(gameObject, 0.1f);\n    }\n    \n    private void PlayWhistleSound()\n    {\n        if (_whistleAudioSource != null && _whistleClips.Length > 0)\n        {\n            int clipIndex = Random.Range(0, _whistleClips.Length);\n            _whistleAudioSource.PlayOneShot(_whistleClips[clipIndex], _whistleVolume);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "FireworkLauncher",
      "components": [
        "Collider",
        "AudioSource",
        "ParticleSystem",
        "Rigidbody"
      ],
      "fields": [
        {
          "name": "fire Interval",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "launchForce",
          "type": "float",
          "default": 15.0
        },
        {
          "name": "trailDuration",
          "type": "float",
          "default": 1.5
        },
        {
          "name": "sparkCount",
          "type": "int",
          "default": 50
        },
        {
          "name": "maxHeight",
          "type": "float",
          "default": 20.0
        },
        {
          "name": "minHeight",
          "type": "float",
          "default": 3.0
        },
        {
          "name": "trailColor",
          "type": "Color",
          "default": "red"
        },
        {
          "name": "sparkSize",
          "type": "float",
          "default": 0.1
        },
        {
          "name": "windStrength",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "launchPoint",
          "type": "Vector3",
          "default": "Vector3.zero"
        },
        {
          "name": "trailParticles",
          "type": "ParticleSystem",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "spawn_firework",
          "trigger": "every fire interval second",
          "actions": [
            {
              "action": "create trail particle system at launch point"
            },
            {
              "action": "set trail duration to trail duration"
            },
            {
              "action": "assign random colors to trail particles"
            },
            {
              "action": "apply wind influence to trail movement"
            },
            {
              "action": "position trail particles upward from launch point"
            }
          ]
        },
        {
          "name": "launch_rocket",
          "trigger": "when firework is spawned",
          "actions": [
            {
              "action": "attach rigidbody with launch force"
            },
            {
              "action": "set rocket as active particle system"
            },
            {
              "action": "enable gravity on rocket"
            }
          ]
        },
        {
          "name": "play_whistle_sound",
          "trigger": "when firework is launched",
          "actions": [
            {
              "action": "play whistle sound at high pitch for 0.5 seconds"
            }
          ]
        },
        {
          "name": "explode_firework",
          "trigger": "when rocket reaches maximum height and falls below threshold",
          "actions": [
            {
              "action": "spawn spark particle system at explosion point"
            },
            {
              "action": "set spark count to random value between 50 and 100"
            },
            {
              "action": "assign random colors from firework color palette"
            },
            {
              "action": "create different sparkle patterns based on shape type"
            },
            {
              "action": "apply wind strength variation to each spark movement"
            },
            {
              "action": "make sparks float downward with gravity"
            }
          ]
        },
        {
          "name": "destroy_firework",
          "trigger": "when firework has been fully destroyed or after 3 seconds",
          "actions": [
            {
              "action": "destroy this firework object"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FireworkLauncher : MonoBehaviour\n{\n    [Header(\"Firework Settings\")]\n    [SerializeField] private float _fireInterval = 2f;\n    [SerializeField] private int _maxFireworksPerSecond = 30;\n    [SerializeField] private bool _autoFire = true;\n    \n    [Header(\"Launch Force\")]\n    [SerializeField] private float _launchForce = 15f;\n    [SerializeField] private Vector3 _launchDirection = -Application.isPlaying ? Camera.main.forward : Vector3.down;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Trail Settings\")]\n    [SerializeField] private ParticleSystem _trailParticles;\n    [SerializeField] private float _trailDuration = 2f;\n    [SerializeField] private float _trailSpeed = 10f;\n    [SerializeField] private Color _trailColor = Color.red;\n    [SerializeField] private int _trailCount = 50;\n    \n    [Header(\"Firework Shape\")]\n    [SerializeField] private GameObject _fireworkShapePrefab;\n    [SerializeField] private int _shapeParticlesPerFirework = 100;\n    [SerializeField] private float _shapeScale = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whistleSound;\n    [SerializeField] private float _soundVolume = 1f;\n    \n    [Header(\"Lifetime Settings\")]\n    [SerializeField] private float _fireworkLifetime = 5f;\n    [SerializeField] private bool _destroyOnFinish = true;\n    \n    private List<Firework> _activeFireworks = new List<Firework>();\n    private System.Collections.Generic.Dictionary<int, Firework> _shapeParticlesDict = new System.Collections.Generic.Dictionary<int, Firework>();\n    private int _currentFireworkIndex = 0;\n    private Coroutine _fireworkCoroutine;\n    \n    public void StartFirework()\n    {\n        if (_autoFire && CanFire())\n        {\n            SpawnFirework();\n        }\n    }\n    \n    public bool CanFire()\n    {\n        return _currentFireworkIndex < _maxFireworksPerSecond &&\n               Time.time >= _fireworkCoroutine?.Getinelive() || !_fireworkCoroutine;\n    }\n    \n    private void SpawnFirework()\n    {\n        Firework firework = new Firework();\n        firework.Initialize(_currentFireworkIndex);\n        \n        GameObject fireworkObj = CreateFireworkObject(firework);\n        \n        fireworkObj.transform.SetParent(transform);\n        fireworkObj.name = $\"Firework_{_currentFireworkIndex}\";\n        \n        firework.InitTrailParticles();\n        firework Obj.GetComponent<ParticleSystem>().play();\n        \n        _activeFireworks.Add(firework);\n        _shapeParticlesDict[firework.Id] = firework;\n        \n        if (_audioSource != null && _whistleSound != null)\n        {\n            PlayWhistle();\n        }\n        \n        StartCoroutine(FireworkCoroutine(firework));\n        _currentFireworkIndex++;\n        \n        if (!_autoFire || !_canFire() || _currentFireworkIndex >= _maxFireworksPerSecond)\n        {\n            StopFireworkCoroutine();\n        }\n    }\n    \n    private GameObject CreateFireworkObject(Firework firework)\n    {\n        GameObject fireworkObj = new GameObject($\"Firework_{firework.Id}\");\n        \n        // Add trail particles\n        ParticleSystem trails = fireworkObj.AddComponent<ParticleSystem>();\n        trails.name = $\"TrailParticles_{firework.Id}\";\n        trails.Play();\n        \n        TrailModule trailMod = trails.GetModule<TrailModule>();\n        trailMod.enabled = true;\n        trailMod.duration = _trailDuration;\n        trailMod.startColor = new Color(1f, 0.5f, 0f, 1f);\n        trailMod.ratio = 0.3f;\n        \n        // Add shape particles\n        GameObject[] shapeObjects = new GameObject[firework.ShapeParticlesPerFirework];\n        for (int i = 0; i < firework.ShapeParticlesPerFirework; i++)\n        {\n            GameObject shapeGO = new GameObject($\"ShapeParticle_{i}\");\n            \n            ParticleSystem shapePS = shapeGO.AddComponent<ParticleSystem>();\n            shapePS.name = $\"ShapeParticles_{firework.Id}_{i}\";\n            shapePS.Play();\n            \n            ShapeModule shapeMod = shapePS.GetModule<ShapeModule>();\n            shapeMod.startColor = _trailColor;\n            shapeMod.startSize = 0.1f;\n            shapeMod.scale = _shapeScale;\n            \n            // Add random shape\n            Vector3[] shapes = new Vector3[]\n            {\n                Vector3.forward,\n                Vector3.right,\n                Vector3.back,\n                Vector3.left,\n                Vector3.up,\n                Vector3.down\n            };\n            int randomShapeIndex = Random.Range(0, shapes.Length);\n            shapeMod.shapeType = ParticleSystemShapeType.Box;\n            shapePS.DefaultShapeScale = _shapeScale / 2f;\n            shapeGO.AddComponent<ParticleSystemShape>();\n            \n            // Create shape object\n            GameObject shapeObj = new GameObject($\"Shape_{randomShapeIndex}\");\n            shapeObj.transform.SetParent(shapeGO.transform);\n            shapeGO.AddComponent<Collider>();\n            \n            // Assign random shape\n            Vector3 finalShape = shapes[randomShapeIndex];\n            shapeGO.GetComponent<Collider>().transform.position += finalShape * (0.5f + Random.value * 0.5f);\n        }\n        \n        shapeObjects = shapeGOs;\n        for (int i = 0; i < firework.ShapeParticlesPerFirework; i++)\n        {\n            GameObject shapeGO = shapeObjects[i];\n            firework Obj.GetComponent<ParticleSystem>().AddParticle(new ParticleSystem.Emitter[] { \n                new ParticleSystem.Emitter() { \n                    shapeType = ParticleSystemShapeType.Box, \n                    startSize = 0.01f * _shapeScale, \n                    velocityOverLifetime = new Vector3(0f, 0f, 0f) \n                } \n            });\n        }\n        \n        foreach (GameObject obj in shapeObjects)\n        {\n            firework Obj.GetComponent<ParticleSystem>().AddParticle(new ParticleSystem.Emitter[] { \n                new ParticleSystem.Emitter() { \n                    shapeType = ParticleSystemShapeType.Box, \n                    startSize = 0.01f * _shapeScale, \n                    velocityOverLifetime = Vector3.zero \n                } \n            });\n        }\n        \n        firework Obj.GetComponent<ParticleSystem>().AddParticle(new ParticleSystem.Emitter[]\n        {\n            new ParticleSystem.Emitter() { shapeType = ParticleSystemShapeType.Box, startSize = 0.01f * _shapeScale },\n            new ParticleSystem.Emitter() { shapeType = ParticleSystemShapeType.Sphere, startSize = 0.005f * _shapeScale }\n        });\n        \n        return fireworkObj;\n    }\n    \n    private IEnumerator FireworkCoroutine(Firework firework)\n    {\n        float timer = 0f;\n        Vector3 launchPoint = transform.position + (firework.LaunchDirection.normalized * firework.LaunchForce);\n        Rigidbody rocketRb = firework Obj.GetComponent<Rigidbody>();\n        \n        while (timer < firework.FireworkLifetime)\n        {\n            // Apply wind influence\n            float windX = Mathf.Sin(timer * 0.5f) * firework.WindStrength;\n            float windY = Mathf.Cos(timer * 0.3f) * firework.WindStrength;\n            rocketRb.AddForce(new Vector3(windX, 0f, windY), ForceMode.Acceleration);\n            \n            timer += Time.deltaTime;\n            yield return null;\n        }\n        \n        // Apply gravity\n        rocketRb.AddForce(Vector3.down * firework.LaunchForce, ForceMode.Impulse);\n        \n        // Create explosion effect\n        GameObject explosion = Instantiate(firework.ExplodeEffect, launchPoint, Quaternion.identity);\n        explosion.transform.SetParent(firework Obj.transform);\n        \n        // Spawn spark particles\n        ParticleSystem sparks = explosion.AddComponent<ParticleSystem>();\n        sparks.Play();\n        sparks.StartColor = new Color(1f, 0.8f, 0f, 0.5f);\n        sparks.Ratio = 0.7f;\n        sparks.Density = firework.SparkCount / firework.FireworkLifetime;\n        \n        // Add random shapes to spark particles\n        Vector3[] shapes = new Vector3[]\n        {\n            Vector3.forward,\n            Vector3.right,\n            Vector3.back,\n            Vector3.left,\n            Vector3.up,\n            Vector3.down\n        };\n        for (int i = 0; i < sparks.Particles.Count; i++)\n        {\n            Particle particle = sparks.GetParticle(i);\n            int randomShapeIndex = Random.Range(0, shapes.Length);\n            particle.velocityOverLifetime = new Vector3(shapes[randomShapeIndex] * firework.SparkSize);\n        }\n        \n        // Apply wind strength variation\n        for (int i = 0; i < sparks.Particles.Count; i++)\n        {\n            Particle particle = sparks.GetParticle(i);\n            float angle = (i / sparks.Particles.Count) * Mathf.PI;\n            particle.velocityOverLifetime.y += Mathf.Sin(angle) * firework.WindStrength;\n        }\n        \n        // Destroy after lifetime\n        yield return new WaitForSeconds(firework.FireworkLifetime);\n        Destroy(explosion);\n        \n        if (_destroyOnFinish)\n        {\n            Destroy(this.gameObject, firework.FireworkLifetime + 1f);\n        }\n    }\n    \n    private void PlayWhistle()\n    {\n        if (_audioSource == null) return;\n        \n        AudioClip clip = _whistleSound;\n        float pitch = Random.Range(0.8f, 2f);\n        clip.pitch = pitch;\n        _audioSource.PlayOneShot(clip, _soundVolume);\n    }\n    \n    private void StopFireworkCoroutine()\n    {\n        if (_fireworkCoroutine != null)\n        {\n            StopCoroutine(_fireworkCoroutine);\n            _fireworkCoroutine = null;\n        }\n    }\n    \n    public class Firework\n    {\n        [Header(\"Firework Properties\")]\n        [SerializeField] private int _id;\n        [SerializeField] private float _launchForce;\n        [SerializeField] private Vector3 _launchDirection;\n        [SerializeField] private float _trailDuration;\n        [SerializeField] private ParticleSystem _trailParticles;\n        [SerializeField] private GameObject _explodeEffect;\n        [SerializeField] private ParticleSystemShapeType _shapeType;\n        [SerializeField] private int _shapeParticlesPerFirework;\n        [SerializeField] private float _shapeScale;\n        [SerializeField] private float _windStrength;\n        \n        [Header(\"Lifetime\")]\n        [SerializeField] private float _fireworkLifetime;\n        [SerializeField] private bool _destroyOnFinish;\n        [SerializeField] private float _delayBeforeLaunch = 1f;\n        \n        public int Id => _id;\n        public Vector3 LaunchPoint => transform.position + (_launchDirection.normalized * _launchForce);\n        \n        public Firework()\n        {\n            _id = -1;\n            _trailDuration = Random.Range(1f, 3f);\n            _shapeScale = 0.5f;\n        }\n        \n        public void Initialize(int fireworkId)\n        {\n            _id = fireworkId;\n            _launchForce = Random.Range(10f, 30f);\n            _launchDirection = -Application.isPlaying ? Camera.main.forward : Vector3.down;\n            _trailDuration = Random.Range(_trailDuration * 0.8f, _trailDuration * 1.2f);\n            _windStrength = Random.Range(1f, 5f);\n            \n            if (_explodeEffect != null)\n                _explodeEffect.SetActive(true);\n        }\n        \n        public void InitTrailParticles()\n        {\n            if (_trailParticles == null) return;\n            \n            TrailModule trailMod = _trailParticles.GetModule<TrailModule>();\n            trailMod.enabled = true;\n            trailMod.duration = _trailDuration;\n            trailMod.startColor = new Color(1f, 0.5f, 0f, 1f);\n            trailMod.ratio = 0.3f;\n            \n            // Add random colors\n            for (int i = 0; i < _trailParticles.Particles.Count; i++)\n            {\n                Particle particle = _trailParticles.GetParticle(i);\n                float r = Random.Range(0.8f, 1.2f);\n                particle.color = Color.rgb(particle.color.r * r, particle.color.g * r, particle.color.b * r);\n            }\n        }\n    }\n    \n    public void ForciblyLaunchFirework(int fireworkId)\n    {\n        Firework firework = _shapeParticlesDict[fireworkId];\n        if (firework == null) return;\n        \n        GameObject fireworkObj = CreateFireworkObject(firework);\n        Rigidbody rocketRb = fireworkObj.GetComponent<Rigidbody>();\n        rocketRb.AddForce(Vector3.down * firework.LaunchForce, ForceMode.Impulse);\n        \n        // Play whistle\n        PlayWhistle();\n    }\n    \n    private void OnDestroy()\n    {\n        StopFireworkCoroutine();\n    }\n}",
    "ir_steered": false,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "ParticleSystem.TriggerSubEmitter (0.62)",
      "ParticleSystem.TrailModule (0.61)",
      "ParticleSystem.Emit (0.61)",
      "Collider.GeometryHolder (0.60)",
      "ParticleSystemShapeMultiModeValue.BurstSpread (0.43)",
      "ParticleSystemShapeMultiModeValue.Loop (0.40)",
      "GeometryUtility.CalculateFrustumPlanes (0.40)",
      "LightEditor.Settings.bounceIntensity (0.16)",
      "LightEditor.Settings.DrawRuntimeShadow (0.15)",
      "LightEditor.Settings.DrawBakedShadowRadius (0.15)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FireworkLauncher : MonoBehaviour\n{\n    [Header(\"Firework Settings\")]\n    public GameObject fireworkPrefab;\n    public float fireworkInterval = 1f;\n    public float maxHeight = 15f;\n    public int minSparkCount = 10;\n    public int maxSparkCount = 50;\n    public float sparkSizeRange = 0.5f;\n    public float trailLifetimeScale = 2f;\n    public float trailDensity = 100;\n    \n    [Header(\"Audio\")]\n    public AudioSource audioSource;\n    public AudioClip whistleClip;\n    public float whistleVolume = 1f;\n    public float whistlePitch = 3f;\n    \n    [Header(\"Visual Effects\")]\n    public ParticleSystem mainTrail;\n    public ParticleSystem sparkEffect;\n    public Light fireworkLight;\n    public GameObject explosionPrefab;\n    public float explosionForce = 1000f;\n    \n    private List<Firework> launchedFireworks = new List<Firework>();\n    private float nextLaunchTime;\n    private float lastLaunchTime;\n    \n    [Header(\"Physics\")]\n    private Rigidbody fireworkRigidbody;\n    private Vector3 launchDirection;\n    \n    void Start()\n    {\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n            \n        if (fireworkLight == null)\n            fireworkLight = GetComponentInChildren<Light>();\n            \n        nextLaunchTime = Time.time + fireworkInterval;\n        \n        if (mainTrail != null && mainTrail.isPlaying)\n            mainTrail.Stop();\n    }\n    \n    void Update()\n    {\n        if (Time.time >= nextLaunchTime)\n        {\n            LaunchFirework();\n            nextLaunchTime = Time.time + fireworkInterval;\n        }\n    }\n    \n    void LaunchFirework()\n    {\n        Firework firework = new Firework(this);\n        \n        // Spawn the firework rocket\n        GameObject fireworkRocket = Instantiate(fireworkPrefab, transform.position, Quaternion.identity);\n        fireworkRocket.name = \"FireworkRocket\";\n        \n        // Add Rigidbody to control flight\n        fireworkRigidbody = fireworkRocket.AddComponent<Rigidbody>();\n        fireworkRigidbody.useGravity = false;\n        fireworkRigidbody.drag = 2f;\n        fireworkRigidbody.velocity = new Vector3(0, 100f, 0);\n        \n        // Set launch direction\n        launchDirection = transform.forward;\n        fireworkRigidbody.velocity = fireworkRigidbody.velocity.normalized * maxHeight;\n        \n        // Add light effect\n        if (fireworkLight != null)\n            fireworkRocket.AddComponent<Light>();\n            \n        // Create trail particles\n        FireworkTrail trail = new FireworkTrail();\n        trail.Initialize(mainTrail);\n        trail.InitializeTrail(fireworkRocket.transform.position, launchDirection, trailDensity, trailRadius: 2f, lifetimeScale: trailLifetimeScale);\n        \n        // Spawn spark particles\n        FireworkSpark spark = new FireworkSpark();\n        spark.Initialize(sparkEffect);\n        spark.InitializeTrail(100f, 0.5f, 3f, trailColor: Color.yellow, pattern: \"Random\");\n        \n        firework.Launch(fireworkRocket, trail, spark);\n        \n        launchedFireworks.Add(firework);\n    }\n    \n    class Firework\n    {\n        private Vector3 _launchPoint;\n        private Rigidbody _rigidbody;\n        private ParticleSystem _trail;\n        private ParticleSystem _sparkEffect;\n        private Light _fireworkLight;\n        private float _launchTime;\n        private float _explosionTime;\n        \n        public Firework(FireworkLauncher launcher)\n        {\n            _launchPoint = launcher.transform.position;\n            _rigidbody = new Rigidbody();\n            _rigidbody.useGravity = false;\n            _rigidbody.drag = 2f;\n            \n            _trail = null;\n            _sparkEffect = null;\n            _fireworkLight = null;\n        }\n        \n        public void Launch(GameObject fireworkRocket, FireworkTrail trail, FireworkSpark spark)\n        {\n            _rigidbody.velocity = new Vector3(0, 100f, 0);\n            _rigidbody.AddForce(fireworkRocket.transform.up * 10f);\n            \n            // Add light to firework\n            if (_fireworkLight == null)\n                _fireworkLight = fireworkRocket.AddComponent<Light>();\n            else\n                _fireworkLight.enabled = true;\n            \n            // Attach trail particles\n            _trail?.InitializeTrail(fireworkRocket.transform.position, Vector3.up * 10f, trailDensity, 2f);\n            \n            // Spawn spark particles\n            _sparkEffect?.Initialize(trailColor: Color.yellow, pattern: \"Random\");\n            \n            // Play whistle sound\n            PlayWhistle();\n        }\n        \n        public void PlayWhistle()\n        {\n            if (audioSource != null && whistleClip != null)\n            {\n                audioSource.pitch = whistlePitch;\n                audioSource.PlayOneShot(whistleClip, whistleVolume);\n            }\n        }\n        \n        public void Explode()\n        {\n            // Spawn explosion effect\n            GameObject explosion = Instantiate(explosionPrefab, transform.position, Quaternion.identity);\n            \n            // Apply force to push sparks outward\n            if (sparkEffect != null)\n                foreach (var spark in sparkEffect.GetParticles())\n                    spark.AddForce(transform.up * 100f);\n            \n            // Destroy firework rocket\n            Destroy(fireworkRocket);\n        }\n        \n        public void SetExplosionTime(float time)\n        {\n            _explosionTime = time;\n        }\n    }\n    \n    class FireworkTrail\n    {\n        private ParticleSystem _trail;\n        private GameObject _fireworkObject;\n        private Vector3 _launchDirection;\n        private float _lifetimeScale;\n        private int _density;\n        private float _radius;\n        \n        public void Initialize(ParticleSystem trail)\n        {\n            _trail = trail;\n            if (_trail == null) return;\n            \n            _fireworkObject = trail.gameObject;\n            _launchDirection = transform.up * 10f;\n            _lifetimeScale = 2f;\n            _density = 100;\n            _radius = 1f;\n        }\n        \n        public void InitializeTrail(Vector3 launchPoint, Vector3 launchDirection, int density, float radius)\n        {\n            if (_trail == null) return;\n            \n            // Add emission\n            var emission = _trail.emission;\n            emission.rateOverTime = density;\n            emission.maxParticles = 1000;\n            \n            // Add velocity over lifetime\n            var velocityOverLifetime = _trail.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.startSpeed = 5f;\n            velocityOverLifetime.startLifetime = _lifetimeScale;\n            velocityOverLifetime.endLifetime = _lifetimeScale * 2f;\n            \n            // Add shape over lifetime\n            var shapeOverLifetime = _trail.shapeOverLifetime;\n            shapeOverLifetime.enabled = true;\n            shapeOverLifetime.startShape = ParticleSystemShape.Sphere;\n            shapeOverLifetime.endShape = ParticleSystemShape.Box;\n            shapeOverLifetime.startScale = new Vector3(radius, radius * 2f, radius);\n            shapeOverLifetime.endScale = new Vector3(2f * radius, 4f * radius, 2f * radius);\n            \n            // Add color over lifetime\n            var colorOverLifetime = _trail.colorOverLifetime;\n            colorOverLifetime.enabled = true;\n            colorOverLifetime.startColor = Color.yellow;\n            colorOverLifetime.endColor = Color.white;\n        }\n        \n        public void InitializeTrail(float launchPoint, Vector3 launchDirection, int density, float radius)\n        {\n            if (_trail == null) return;\n            \n            // Add emission\n            var emission = _trail.emission;\n            emission.rateOverTime = density;\n            emission.maxParticles = 1000;\n            \n            // Add velocity over lifetime\n            var velocityOverLifetime = _trail.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.startSpeed = 5f;\n            velocityOverLifetime.startLifetime = _lifetimeScale * 2f;\n            velocityOverLifetime.endLifetime = _lifetimeScale * 4f;\n            \n            // Add shape over lifetime\n            var shapeOverLifetime = _trail.shapeOverLifetime;\n            shapeOverLifetime.enabled = true;\n            shapeOverLifetime.startShape = ParticleSystemShape.Sphere;\n            shapeOverLifetime.endShape = ParticleSystemShape.Box;\n            shapeOverLifetime.startScale = new Vector3(radius, radius * 2f, radius);\n            shapeOverLifetime.endScale = new Vector3(4f * radius, 8f * radius, 4f * radius);\n        }\n        \n        public void UpdateTrail(float time)\n        {\n            if (_trail == null) return;\n            \n            // Animate trail position based on firework flight\n            float progress = (time - _launchTime) / _lifetimeScale;\n            progress = Mathf.Clamp01(progress);\n            \n            Vector3 newPosition = transform.position + _launchDirection * progress;\n            _fireworkObject.transform.position = newPosition;\n        }\n    }\n    \n    class FireworkSpark\n    {\n        private ParticleSystem _sparkEffect;\n        private int _minCount = 10;\n        private int _maxCount = 50;\n        private float _sizeRange = 0.5f;\n        private Color _trailColor;\n        private string _pattern;\n        \n        public void Initialize(ParticleSystem spark)\n        {\n            _sparkEffect = spark;\n            if (_sparkEffect == null) return;\n            \n            // Add emission\n            var emission = _sparkEffect.emission;\n            emission.rateOverTime = 1000;\n            emission.maxParticles = 5000;\n            \n            // Add velocity over lifetime\n            var velocityOverLifetime = _sparkEffect.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.startSpeed = 10f;\n            velocityOverLifetime.startLifetime = 1f;\n            velocityOverLifetime.endLifetime = 3f;\n            \n            // Add shape over lifetime\n            var shapeOverLifetime = _sparkEffect.shapeOverLifetime;\n            shapeOverLifetime.enabled = true;\n            shapeOverLifetime.startShape = ParticleSystemShape.Box;\n            shapeOverLifetime.endShape = ParticleSystemShape.Cube;\n            shapeOverLifetime.startScale = new Vector3(0.1f, 0.2f, 0.1f);\n            shapeOverLifetime.endScale = new Vector3(0.5f, 1f, 0.5f);\n            \n            // Add color over lifetime\n            var colorOverLifetime = _sparkEffect.colorOverLifetime;\n            colorOverLifetime.enabled = true;\n            _trailColor = Color.yellow;\n            colorOverLifetime.startColor = _trailColor;\n            colorOverLifetime.endColor = new Color(_trailColor.r, 0.8f * _trailColor.g, _trailColor.b);\n        }\n        \n        public void UpdateTrail(float time)\n        {\n            if (_sparkEffect == null) return;\n            \n            // Animate spark position based on firework flight\n            float progress = (time - _launchTime) / _lifetimeScale;\n            progress = Mathf.Clamp01(progress);\n            \n            Vector3 newPosition = transform.position + _launchDirection * progress;\n            _sparkEffect.transform.position = newPosition;\n        }\n    }\n}",
    "per_behavior_docs": 11,
    "per_behavior_methods": 4,
    "per_behavior_doc_names": {
      "launch_firework": [
        "ParticleSystem.GetPlaybackState (0.68)",
        "ParticleSystem.VelocityOverLifetimeModule (0.68)",
        "ParticleSystem.EmissionModule (0.68)"
      ],
      "track_firework": [
        "ParticleSystem.LightsModule (0.70)",
        "Animator.GetParameter (0.70)",
        "ParticleSystem.ColorOverLifetimeModule (0.70)"
      ],
      "explode_firework": [
        "GameObject.InstantiateGameObjects (0.70)",
        "GameObject.GetScene (0.66)",
        "GameObjectUtility (0.66)"
      ],
      "destroy_firework": [
        "ParticleSystem.ForceOverLifetimeModule (0.70)",
        "ParticleSystem.Emit (0.70)",
        "ParticleSystem.ColorOverLifetimeModule (0.70)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 6,
        "fixability": 5,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 59,
        "justification": "Solid basic structure with nested Firework class, but lacks clear separation of concerns. Has good Unity serialization and basic error handling, but somewhat monolithic approach."
      },
      "ir_monolithic": {
        "architecture": 4,
        "fixability": 3,
        "unity_patterns": 5,
        "correctness": 4,
        "completeness": 3,
        "weighted_total": 42,
        "justification": "Overly complex with too many abstraction layers. Introduces unnecessary complexity in coroutine management and object tracking. Loses clarity with multiple dictionary/list management."
      },
      "ir_per_behavior": {
        "architecture": 9,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 73,
        "justification": "Exceptional modular design with clear separation of concerns. Uses nested classes for trail and spark behaviors. Provides clean extension points and follows Unity component patterns closely."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The per-behavior approach provides the most modular, extensible design with clear separation of concerns. It breaks down complex behaviors into manageable, focused classes while maintaining clean Unity integration.",
      "advantages": "Clean separation of firework launch, trail, and spark behaviors. Easy to modify individual components without affecting entire system. Strong use of Unity serialization and component-based design. Provides clear method signatures for future expansion."
    },
    "error": null
  },
  {
    "prompt_num": 24,
    "prompt": "Build a domino chain system where each domino piece when tipped plays a click sound, triggers the next piece after calculated delay based on spacing, tracks total pieces fallen, and upon completing the chain triggers a celebration sequence with the score displayed in particle text.",
    "timestamp": "2026-01-08T23:24:10.610195",
    "oneshot_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class DominoChain : MonoBehaviour\n{\n    [Header(\"Domino Settings\")]\n    [SerializeField] private float _dominoSpacing = 2f;\n    [SerializeField] private int _totalDominoes = 10;\n    [SerializeField] private List<DominoPiece> _dominoPieces = new List<DominoPiece>();\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _clickSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _celebrationEffect;\n    [SerializeField] private GameObject _celebrationObject;\n    [SerializeField] private Text _scoreText;\n    [SerializeField] private float _celebrationDuration = 3f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _fallSpeed = 5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    private int _currentDominoIndex = -1;\n    private bool _isTipping = false;\n    private Coroutine _celebrationCoroutine;\n    \n    public int FallenDominoes => _dominoPieces.Count;\n    \n    private void Start()\n    {\n        InitializeDominoes();\n        SetupAudioSource();\n        SetupScoreText();\n        \n        if (_celebrationObject != null)\n            _celebrationCoroutine = StartCoroutine(CelebrateCompletion());\n    }\n    \n    private void Update()\n    {\n        if (!_isTipping) return;\n        \n        HandleDominoTipping();\n    }\n    \n    private void InitializeDominoes()\n    {\n        for (int i = 0; i < _totalDominoes; i++)\n        {\n            GameObject dominoObj = new GameObject($\"Domino_{i}\");\n            \n            DominoPiece domino = dominoObj.AddComponent<DominoPiece>();\n            domino.Initialize(_dominoSpacing * i, dominoSpacing);\n            \n            _dominoPieces.Add(domino);\n            \n            if (i < _totalDominoes - 1)\n                domino.SetNextPiece(_dominoPieces[i + 1]);\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _audioSource.clip = _clickSounds[0];\n        _audioSource.loop = false;\n        _audioSource.volume = 1f;\n    }\n    \n    private void SetupScoreText()\n    {\n        if (_scoreText != null)\n            _scoreText.text = \"Score: 0\";\n    }\n    \n    private void HandleDominoTipping()\n    {\n        if (!_isTipping) return;\n        \n        int targetIndex = _currentDominoIndex + 1;\n        \n        if (targetIndex >= _totalDominoes)\n        {\n            CelebrateCompletion();\n            return;\n        }\n        \n        // Find the next domino object\n        GameObject nextDominoObj = _dominoPieces[targetIndex].gameObject;\n        \n        // Play click sound\n        PlayClickSound();\n        \n        // Check if target domino is already falling or tipped\n        if (!nextDominoObj.GetComponent<DominoPiece>().isTipped && \n            !nextDominoObj.GetComponent<DominoPiece>().isFalling)\n        {\n            nextDominoObj.GetComponent<DominoPiece>().SetNextPiece(_dominoPieces[targetIndex + 1]);\n            _currentDominoIndex = targetIndex;\n            \n            // Start falling\n            nextDominoObj.GetComponent<DominoPiece>().StartFalling();\n            \n            // Check if we need to wait for domino to fall before triggering next\n            float delay = nextDominoObj.GetComponent<DominoPiece>().GetFallTime();\n            Invoke(nameof(HandleDominoTipping), delay);\n        }\n    }\n    \n    private void CelebrateCompletion()\n    {\n        if (_celebrationCoroutine != null)\n            StopCoroutine(_celebrationCoroutine);\n            \n        _celebrationCoroutine = StartCoroutine(CelebrateSequence());\n    }\n    \n    private IEnumerator CelebrateSequence()\n    {\n        if (!_celebrationObject || !_scoreText) yield break;\n        \n        // Display celebration object\n        GameObject CelebrationGO = new GameObject(\"Celebration\");\n        CelebrationGO.transform.SetParent(transform);\n        CelebrationGO.SetActive(true);\n        \n        // Show score text\n        _scoreText.text = $\"Score: {_fallenDominoes}\";\n        \n        // Play celebration sound\n        if (_audioSource != null)\n            _audioSource.PlayOneShot(_clickSounds[0]);\n        \n        // Spawn particles\n        if (_celebrationEffect != null)\n            _celebrationEffect.Play();\n            \n        // Wait for duration\n        yield return new WaitForSeconds(_celebrationDuration);\n        \n        CelebrationGO.SetActive(false);\n        if (_celebrationEffect != null)\n            _celebrationEffect.Stop();\n    }\n    \n    private void PlayClickSound()\n    {\n        if (_audioSource == null || _clickSounds.Length == 0) return;\n        \n        _audioSource.PlayOneShot(_clickSounds[0]);\n    }\n    \n    public void ForceTriggerDomino(int dominoIndex)\n    {\n        if (dominoIndex < 1 || dominoIndex >= _totalDominoes) return;\n        \n        DominoPiece currentDomino = _dominoPieces[dominoIndex].GetComponent<DominoPiece>();\n        if (!currentDomino.isTipped && !currentDomino.isFalling)\n        {\n            currentDomino.SetNextPiece(_dominoPieces[dominoIndex + 1]);\n            currentDomino.StartFalling();\n            PlayClickSound();\n        }\n    }\n    \n    private void OnMouseDown()\n    {\n        if (_isTipping) return;\n        \n        // Try to trigger domino on click\n        int index = GetClickedDominoIndex();\n        if (index >= 0)\n        {\n            _currentDominoIndex = index;\n            _isTipping = true;\n        }\n    }\n    \n    private int GetClickedDominoIndex()\n    {\n        Collider[] colliders = Physics.OverlapBox(transform.position, Vector3.up * 1f, \n            _groundLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Ground\"))\n                return -1;\n            \n            DominoPiece domino = col.GetComponent<DominoPiece>();\n            if (domino != null && !domino.isTipped && !domino.isFalling)\n            {\n                return domino.GetIndex();\n            }\n        }\n        \n        return -2; // Not a ground or valid domino\n    }\n    \n    private class DominoPiece\n    {\n        [Header(\"Position\")]\n        [SerializeField] private Vector3 _position;\n        [SerializeField] private float _rotationSpeed;\n        [SerializeField] private float _fallSpeed;\n        [SerializeField] private bool _isTipped = false;\n        [SerializeField] private bool _isFalling = false;\n        \n        [Header(\"Next Domino\")]\n        [SerializeField] private DominoPiece _nextDomino;\n        \n        [Header(\"Visual\")]\n        [SerializeField] private GameObject _dominoObject;\n        [SerializeField] private Renderer _renderer;\n        [SerializeField] private Material _material;\n        \n        public Vector3 Position => _position;\n        public float RotationAngle => transform.eulerAngles.y;\n        public int GetIndex()\n        {\n            if (_nextDomino != null)\n                return _nextDomino.GetIndex();\n            else\n                return -1;\n        }\n        public void Initialize(float x, float z)\n        {\n            _position = new Vector3(x, 0f, z);\n            _rotationAngle = Random.Range(0f, 360f);\n        }\n        \n        public void SetNextPiece(DominoPiece nextDomino)\n        {\n            _nextDomino = nextDomino;\n        }\n        \n        public void StartFalling()\n        {\n            if (_isFalling || _isTipped) return;\n            \n            _isFalling = true;\n            _isTipped = false;\n            \n            // Find the ground position below\n            Vector3 hitPoint = Physics.Raycast(_position, Vector3.down * _fallSpeed, \n                out RaycastHit hit, 1f, _groundLayer);\n            if (hit.point != Vector3.zero)\n            {\n                _position = hit.point;\n            }\n        }\n        \n        public float GetFallTime()\n        {\n            return (_position.y / _fallSpeed) + Random.Range(-0.5f, 0.5f);\n        }\n    }\n}",
    "ir_json": {
      "class_name": "DominoChain",
      "components": [
        "Collider",
        "AudioSource",
        "Animator"
      ],
      "fields": [
        {
          "name": "dominoPrefab",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "spawnPoint",
          "type": "Transform",
          "default": null
        },
        {
          "name": "clickSound",
          "type": "AudioClip",
          "default": null
        },
        {
          "name": "delayTime",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "totalPieces",
          "type": "int",
          "default": 0
        },
        {
          "name": "celebrationTrigger",
          "type": "bool",
          "default": false
        },
        {
          "name": "scoreDisplay",
          "type": "GameObject",
          "default": null
        },
        {
          "name": "particleSystem",
          "type": "ParticleSystem",
          "default": null
        }
      ],
      "behaviors": [
        {
          "name": "spawn_domino",
          "trigger": "when domino is created from prefab or generated",
          "actions": [
            {
              "action": "position domino at spawn point"
            },
            {
              "action": "set up animation state: standing upright"
            }
          ]
        },
        {
          "name": "play_click_sound",
          "trigger": "when domino piece is tipped by player or previous domino",
          "actions": [
            {
              "action": "play click sound effect",
              "target": "audio source"
            },
            {
              "action": "update total pieces fallen",
              "value": "increase by one"
            }
          ]
        },
        {
          "name": "trigger_next_domino",
          "trigger": "when current domino has fallen and there are more dominoes in the chain",
          "actions": [
            {
              "action": "find next domino in the sequence"
            },
            {
              "action": "delay execution for specified time delay"
            },
            {
              "action": "tip next domino to start falling"
            }
          ]
        },
        {
          "name": "complete_chain_sequence",
          "trigger": "when last domino in chain has fallen and all pieces have been triggered",
          "actions": [
            {
              "action": "set celebration trigger as true"
            },
            {
              "action": "start celebration sequence with success sound effect"
            }
          ]
        },
        {
          "name": "celebrate_completion",
          "trigger": "when celebration trigger is active and chain is complete",
          "actions": [
            {
              "action": "display score in particle text",
              "target": "score display object"
            },
            {
              "action": "start confetti particle effect",
              "target": "particle system"
            },
            {
              "action": "play victory jingle sound effect"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections;\n\npublic class DominoChain : MonoBehaviour\n{\n    [Header(\"Domino Settings\")]\n    [SerializeField] private GameObject _dominoPrefab;\n    [SerializeField] private int _totalPieces = 5;\n    [SerializeField] private float _fallSpeed = 2f;\n    [SerializeField] private float _delayBetweenTipping = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _clickSound;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _successJingle;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _confettiParticles;\n    [SerializeField] private GameObject _scoreDisplayPrefab;\n    [SerializeField] private float _scoreDisplayDuration = 5f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Transform _celebrationArea;\n    \n    private int _currentPieceIndex = 0;\n    private bool _isPlaying = false;\n    private Coroutine _nextTippingCoroutine;\n    \n    private void Start()\n    {\n        InitializeDominoes();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_scoreDisplayPrefab != null)\n        {\n            _scoreDisplayPrefab.SetActive(false);\n        }\n        \n        if (_celebrationArea != null)\n        {\n            GameObject display = new GameObject(\"Score Display\");\n            display.transform.SetParent(_celebrationArea);\n            \n            if (display != null)\n            {\n                display.SetActive(true);\n                \n                Text scoreText = display.AddComponent<Text>();\n                scoreText.text = \"Score: 0\";\n                scoreText.fontSize = 24;\n                scoreText.color = Color.white;\n            }\n        }\n    }\n    \n    private void InitializeDominoes()\n    {\n        for (int i = 0; i < _totalPieces; i++)\n        {\n            GameObject domino = Instantiate(_dominoPrefab, transform);\n            DominoPiece dominoPiece = domino.GetComponent<DominoPiece>();\n            \n            if (dominoPiece == null)\n            {\n                dominoPiece = domino.AddComponent<DominoPiece>();\n            }\n            \n            dominoPiece.InitializeDomino(i + 1);\n        }\n        \n        _currentPieceIndex = 0;\n    }\n    \n    public void TipFirstDomino()\n    {\n        if (_isPlaying) return;\n        \n        _isPlaying = true;\n        \n        DominoPiece currentPiece = GetCurrentPiece();\n        if (currentPiece != null)\n        {\n            currentPiece.TipDomino();\n            \n            PlayClickSound();\n            StartCoroutine(NextTippingCoroutine());\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_nextTippingCoroutine != null)\n        {\n            StopCoroutine(_nextTippingCoroutine);\n            _nextTippingCoroutine = null;\n        }\n        \n        if (_scoreDisplayPrefab != null)\n        {\n            _scoreDisplayPrefab.SetActive(false);\n        }\n    }\n    \n    private DominoPiece GetCurrentPiece()\n    {\n        return GetComponent<DominoPiece>();\n    }\n    \n    private void PlayClickSound()\n    {\n        if (_audioSource == null || !_clickSound)\n        {\n            return;\n        }\n        \n        _audioSource.PlayOneShot(_clickSound);\n    }\n    \n    private IEnumerator NextTippingCoroutine()\n    {\n        while (_currentPieceIndex < _totalPieces - 1)\n        {\n            DominoPiece nextPiece = GetNextPiece();\n            if (nextPiece != null)\n            {\n                yield return new WaitForSeconds(_delayBetweenTipping);\n                nextPiece.TipDomino();\n                \n                PlayClickSound();\n            }\n            \n            _currentPieceIndex++;\n            \n            // Check if all pieces have been tipped\n            if (_currentPieceIndex >= _totalPieces - 1)\n            {\n                break;\n            }\n        }\n        \n        PlaySuccessJingle();\n    }\n    \n    private DominoPiece GetNextPiece()\n    {\n        return GetCurrentPiece()?.GetNextPiece(_currentPieceIndex);\n    }\n    \n    public void SetScoreDisplayEnabled(bool enabled)\n    {\n        if (_celebrationArea != null && _scoreDisplayPrefab != null)\n        {\n            GameObject display = new GameObject(\"Score Display\");\n            display.transform.SetParent(_celebrationArea);\n            \n            if (enabled)\n            {\n                display.SetActive(true);\n                \n                Text scoreText = display.AddComponent<Text>();\n                scoreText.text = \"Score: \" + _totalPieces;\n                scoreText.fontSize = 24;\n                scoreText.color = Color.white;\n            }\n            else\n            {\n                display.SetActive(false);\n            }\n        }\n    }\n    \n    public int GetScore()\n    {\n        return _currentPieceIndex + 1;\n    }\n    \n    public void ResetDominoChain()\n    {\n        _currentPieceIndex = -1;\n        \n        if (_scoreDisplayPrefab != null)\n        {\n            _scoreDisplayPrefab.SetActive(false);\n        }\n        \n        if (_celebrationArea != null)\n        {\n            GameObject display = new GameObject(\"Score Display\");\n            display.transform.SetParent(_celebrationArea);\n            \n            if (display != null)\n            {\n                display.SetActive(true);\n                \n                Text scoreText = display.AddComponent<Text>();\n                scoreText.text = \"Score: 0\";\n                scoreText.fontSize = 24;\n                scoreText.color = Color.white;\n            }\n        }\n    }\n    \n    private class DominoPiece : MonoBehaviour\n    {\n        [Header(\"Domino Settings\")]\n        [SerializeField] private Transform _dominoModel;\n        [SerializeField] private float _fallDuration = 3f;\n        [SerializeField] private bool _canFall = true;\n        \n        [Header(\"Animation\")]\n        [SerializeField] private Animator _animator;\n        \n        private int _originalPosition;\n        private bool _hasFallen = false;\n        private Coroutine _fallCoroutine;\n        private Collider _collider;\n        \n        public void InitializeDomino(int position)\n        {\n            _originalPosition = position;\n            \n            if (_dominoModel == null)\n            {\n                GameObject modelGO = gameObject.AddComponent<Collider>();\n                _collider = modelGO as Collider;\n                \n                if (!_canFall)\n                {\n                    _collider.isTrigger = true;\n                }\n            }\n        }\n        \n        public void TipDomino()\n        {\n            if (_hasFallen || !_canFall) return;\n            \n            PlayAnimation();\n            PlaySoundEffect();\n            StartFalling();\n        }\n        \n        private void PlayAnimation()\n        {\n            if (_animator == null)\n            {\n                _animator = GetComponent<Animator>();\n            }\n            \n            if (_animator != null)\n            {\n                _animator.SetTrigger(\"Fall\");\n            }\n        }\n        \n        private void PlaySoundEffect()\n        {\n            if (_canFall && _collider != null && _collider.hasAudioClip(_clickSound))\n            {\n                _collider.PlayOneShot(_clickSound);\n            }\n        }\n        \n        private void StartFalling()\n        {\n            if (_fallCoroutine == null)\n            {\n                _fallCoroutine = StartCoroutine(FallAnimation());\n            }\n        }\n        \n        private IEnumerator FallAnimation()\n        {\n            float elapsedTime = 0f;\n            \n            while (elapsedTime < _fallDuration && !_hasFallen)\n            {\n                yield return new WaitForSeconds(1f / _fallSpeed);\n                elapsedTime += 1f / _fallSpeed;\n                \n                if (_canFall)\n                {\n                    UpdatePosition(elapsedTime);\n                }\n            }\n            \n            _hasFallen = true;\n        }\n        \n        private void UpdatePosition(float time)\n        {\n            float normalizedTime = Mathf.Clamp01(time / _fallDuration);\n            \n            if (_dominoModel != null)\n            {\n                Vector3 newPosition = _dominoModel.position + new Vector3(\n                    Mathf.Sin(normalizedTime * 2f * Mathf.PI) * 1f,\n                    Mathf.Cos(normalizedTime * 2f * Mathf.PI) * 0.5f,\n                    normalizedTime * 0.3f\n                );\n                \n                _dominoModel.position = newPosition;\n            }\n        }\n        \n        public bool HasFallen()\n        {\n            return _hasFallen;\n        }\n        \n        public int GetOriginalPosition()\n        {\n            return _originalPosition;\n        }\n    }\n}\n\npublic class DominoPiece : MonoBehaviour\n{\n    private Transform _dominoModel;\n    private float _fallDuration = 3f;\n    private bool _canFall = true;\n    private Animator _animator;\n    private Coroutine _fallCoroutine;\n    private Collider _collider;\n    \n    public void TipDomino()\n    {\n        if (_canFall)\n        {\n            PlayAnimation();\n            StartFalling();\n        }\n    }\n    \n    private void Start()\n    {\n        _dominoModel = GetComponentInChildren<Transform>();\n        if (_dominoModel == null)\n        {\n            GameObject modelGO = gameObject.AddComponent<Collider>();\n            _collider = modelGO as Collider;\n            \n            if (!_canFall)\n            {\n                _collider.isTrigger = true;\n            }\n        }\n    }\n    \n    private void PlayAnimation()\n    {\n        if (_animator == null)\n        {\n            _animator = GetComponent<Animator>();\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Fall\");\n        }\n    }\n    \n    private void StartFalling()\n    {\n        if (_fallCoroutine == null)\n        {\n            _fallCoroutine = StartCoroutine(FallAnimation());\n        }\n    }\n    \n    private IEnumerator FallAnimation()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fallDuration && !_hasFallen)\n        {\n            yield return new WaitForSeconds(1f / _fallSpeed);\n            elapsedTime += 1f / _fallSpeed;\n            \n            if (_canFall)\n            {\n                UpdatePosition(elapsedTime);\n            }\n        }\n        \n        _hasFallen = true;\n    }\n    \n    private void UpdatePosition(float time)\n    {\n        float normalizedTime = Mathf.Clamp01(time / _fallDuration);\n        \n        Vector3 newPosition = transform.position + new Vector3(\n            Mathf.Sin(normalizedTime * 2f * Mathf.PI) * 1f,\n            Mathf.Cos(normalizedTime * 2f * Mathf.PI) * 0.5f,\n            normalizedTime * 0.3f\n        );\n        \n        transform.position = newPosition;\n    }\n    \n    public bool HasFallen()\n    {\n        return _hasFallen;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_fallCoroutine != null)\n        {\n            StopCoroutine(_fallCoroutine);\n            _fallCoroutine = null;\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animation.PlayQueued (0.69)",
      "Animator.GetCurrentAnimationClipState (0.66)",
      "Animation.CrossFadeQueued (0.66)",
      "Animator.GetNextAnimationClipState (0.66)",
      "Animation.AddClip (0.66)",
      "Animator.PlayInFixedTime (0.66)",
      "AudioClip.PCMSetPositionCallback (0.62)",
      "GameObject.GetComponentAtIndex (0.61)",
      "GameObject.GetComponentInChildren (0.61)",
      "AudioClip.PCMReaderCallback (0.60)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DominoChainSystem : MonoBehaviour\n{\n    [Header(\"Domino Settings\")]\n    [SerializeField] private GameObject _dominoPrefab;\n    [SerializeField] private int _totalPieces = 20;\n    [SerializeField] private float _delayPerDistance = 0.1f;\n    [SerializeField] private bool _autoPlay = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _clickSound;\n    [SerializeField] private AudioClip _celebrationSound;\n    [SerializeField] private float _volume = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _celebrationParticles;\n    [SerializeField] private GameObject _scoreTextPrefab;\n    [SerializeField] private Transform _scoreTextParent;\n    [SerializeField] private Color _textColor = Color.white;\n    [SerializeField] private float _particleLifetime = 2f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _startScreen;\n    [SerializeField] private GameObject _endScreen;\n    [SerializeField] private UnityEngine.UI.Text _scoreText;\n    [SerializeField] private UnityEngine.UI.Text _gameOverText;\n    [SerializeField] private UnityEngine.UI.Image _winImage;\n    [SerializeField] private UnityEngine.UI.Image _loseImage;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnDominoTipped;\n    public UnityEvent OnGameCompleted;\n    public UnityEvent OnGameStarted;\n    \n    private int _currentPieceIndex = 0;\n    private bool _isPlaying = false;\n    private float _nextTipTime;\n    private int _fallenPieces = 0;\n    private Vector3[] _dominoPositions;\n    private GameObject[] _dominoObjects;\n    private Transform[] _scoreTextTransforms;\n    \n    private void Start()\n    {\n        InitializeDominoChain();\n        SetupScoreUI();\n        \n        if (_startScreen != null)\n            _startScreen.SetActive(true);\n    }\n    \n    private void Update()\n    {\n        if (!_isPlaying) return;\n        \n        UpdateDominoTipping();\n        CheckForGameCompletion();\n    }\n    \n    private void InitializeDominoChain()\n    {\n        if (_dominoPrefab == null || _totalPieces <= 0)\n            return;\n            \n        _dominoPositions = new Vector3[_totalPieces];\n        _dominoObjects = new GameObject[_totalPieces];\n        \n        for (int i = 0; i < _totalPieces; i++)\n        {\n            Vector3 position = CalculateDominoPosition(i);\n            _dominoPositions[i] = position;\n            \n            GameObject domino = Instantiate(_dominoPrefab, position + Vector3.up * 0.5f, Quaternion.identity);\n            _dominoObjects[i] = domino;\n            \n            // Add click sound component\n            ClickSoundComponent clickSound = domino.GetComponentInChildren<ClickSoundComponent>();\n            if (clickSound == null)\n                clickSound = domino.AddComponent<ClickSoundComponent>();\n            \n            // Add audio source if not already present\n            if (_audioSource == null)\n                _audioSource = domino.AddComponent<AudioSource>();\n                \n            // Set up score text for this domino\n            ScoreText scoreText = CreateScoreText(i);\n            if (scoreText != null)\n            {\n                _scoreTextTransforms[i] = scoreText.transform;\n                _startScreen.SetActive(false);\n            }\n        }\n    }\n    \n    private Vector3 CalculateDominoPosition(int index)\n    {\n        float spacing = 2f * Mathf.Sqrt(2f); // Distance between dominoes\n        float x = -10f + (index % (_totalPieces / 4)) * spacing;\n        float z = 0f;\n        \n        return new Vector3(x, 0.5f, z);\n    }\n    \n    private ScoreText CreateScoreText(int index)\n    {\n        if (_scoreTextPrefab != null && _scoreTextParent != null)\n        {\n            ScoreText scoreText = Instantiate(_scoreTextPrefab, _scoreTextParent);\n            Transform transform = scoreText.transform;\n            \n            // Position the text above the domino\n            float yOffset = 0.3f;\n            transform.position = new Vector3(\n                _dominoPositions[index].x,\n                _dominoPositions[index].y + yOffset,\n                _dominoPositions[index].z\n            );\n            \n            // Set up color\n            scoreText.color = _textColor;\n            scoreText.fontSize = 24f;\n            return transform;\n        }\n        \n        return null;\n    }\n    \n    private void UpdateDominoTipping()\n    {\n        if (_currentPieceIndex >= _totalPieces)\n        {\n            OnGameCompleted?.Invoke();\n            return;\n        }\n        \n        if (Time.time < _nextTipTime)\n        {\n            return;\n        }\n        \n        // Calculate delay based on distance to next domino\n        float distanceToNextDomino = Vector3.Distance(\n            transform.position,\n            _dominoPositions[_currentPieceIndex + 1]\n        );\n        float tipDelay = distanceToNextDomino * _delayPerDistance;\n        \n        _nextTipTime = Time.time + tipDelay;\n        \n        // Tip the current domino\n        TipCurrentDomino(_currentPieceIndex);\n    }\n    \n    private void TipCurrentDomino(int index)\n    {\n        ClickSoundComponent clickSound = _dominoObjects[index].GetComponentInChildren<ClickSoundComponent>();\n        if (clickSound != null && _audioSource != null)\n        {\n            clickSound.Play();\n        }\n        \n        OnDominoTipped?.Invoke(index);\n        _fallenPieces++;\n        \n        // Update score text\n        if (_scoreTextTransforms[index] != null)\n        {\n            ScoreText scoreText = _scoreTextTransforms[index];\n            int fallenScore = Mathf.Min(_fallenPieces, _totalPieces) - index;\n            scoreText.text = fallenScore.ToString();\n        }\n        \n        // Play celebration sound\n        if (_celebrationSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_celebrationSound, _volume);\n        }\n        \n        // Update visual effects\n        if (_celebrationParticles != null)\n        {\n            _celebrationParticles.transform.position = transform.position;\n            _celebrationParticles.Play();\n        }\n    }\n    \n    private void CheckForGameCompletion()\n    {\n        if (_fallenPieces >= _totalPieces)\n        {\n            OnGameCompleted?.Invoke();\n            EndDominoChain();\n            return;\n        }\n        \n        // Find next domino to tip\n        int nextPieceIndex = _currentPieceIndex + 1;\n        if (nextPieceIndex < _totalPieces)\n        {\n            _currentPieceIndex = nextPieceIndex;\n        }\n    }\n    \n    private void EndDominoChain()\n    {\n        _isPlaying = false;\n        \n        // Stop celebration particles\n        foreach (ParticleSystem ps in _celebrationParticles.transform.GetComponentsInChildren<ParticleSystem>())\n        {\n            if (ps != null)\n                ps.Stop();\n        }\n        \n        // Hide start screen and show end screen\n        _startScreen.SetActive(false);\n        _endScreen.SetActive(true);\n    }\n    \n    public void StartDominoChain()\n    {\n        if (_isPlaying) return;\n        \n        _currentPieceIndex = 0;\n        _fallenPieces = 0;\n        _nextTipTime = Time.time;\n        _isPlaying = true;\n        \n        if (!_autoPlay)\n            OnGameStarted?.Invoke();\n            \n        // Reset score texts\n        for (int i = 0; i < _totalPieces; i++)\n        {\n            if (_scoreTextTransforms[i] != null)\n                _scoreTextTransforms[i].text = \"\";\n        }\n    }\n    \n    public void ForceTipDomino(int index)\n    {\n        if (_currentPieceIndex <= index && index < _totalPieces)\n        {\n            ClickSoundComponent clickSound = _dominoObjects[index].GetComponentInChildren<ClickSoundComponent>();\n            if (clickSound != null && _audioSource != null)\n                clickSound.Play();\n            \n            OnDominoTipped?.Invoke(index);\n            _fallenPieces++;\n            \n            // Update score text\n            if (_scoreTextTransforms[index] != null)\n            {\n                ScoreText scoreText = _scoreTextTransforms[index];\n                int fallenScore = Mathf.Min(_fallenPieces, _totalPieces) - index;\n                scoreText.text = fallenScore.ToString();\n            }\n        }\n    }\n    \n    public void ResetDominoChain()\n    {\n        if (_isPlaying)\n        {\n            EndDominoChain();\n            OnGameCompleted?.Invoke();\n            \n            // Reset all score texts\n            for (int i = 0; i < _totalPieces; i++)\n            {\n                if (_scoreTextTransforms[i] != null)\n                    _scoreTextTransforms[i].text = \"\";\n            }\n        }\n        \n        _fallenPieces = 0;\n        _currentPieceIndex = -1;\n        _nextTipTime = Time.time;\n        _isPlaying = false;\n    }\n    \n    public int GetFallenPieces()\n    {\n        return _fallenPieces;\n    }\n    \n    private class ClickSoundComponent : MonoBehaviour\n    {\n        [SerializeField] private AudioClip _clickSound;\n        [SerializeField] private float _volume = 1f;\n        \n        public void Play()\n        {\n            if (_clickSound != null)\n                AudioSource.PlayClipAtPoint(_clickSound, transform.position, _volume);\n        }\n    }\n}",
    "per_behavior_docs": 11,
    "per_behavior_methods": 5,
    "per_behavior_doc_names": {
      "spawn_domino_chain": [
        "GameObject.InstantiateGameObjects (0.73)",
        "GameObject.GetComponentAtIndex (0.69)",
        "GameObject.GetComponentInChildren (0.67)"
      ],
      "tip_current_domino": [
        "Animator.PlayInFixedTime (0.63)",
        "WaitForFixedUpdate (0.62)",
        "Animator.GetNextAnimationClipState (0.61)"
      ],
      "update_score_display": [
        "ParticleSystem.Play (0.77)",
        "ParticleSystem.Emit (0.75)",
        "ParticleSystem.GetPlaybackState (0.74)"
      ],
      "complete_chain_sequence": [
        "ParticleSystem.Play (0.73)",
        "ParticleSystem.PlaybackState (0.71)",
        "ParticleSystem.Emit (0.71)"
      ],
      "reset_chain": [
        "ParticleSystem.Play (0.70)",
        "ParticleSystem.GetPlaybackState (0.69)",
        "ParticleSystem.SetPlaybackState (0.68)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 54,
        "justification": "Direct translation lacks clear modularity. Good use of Unity serialization, but methods are partially implemented and lack clear separation. Attempts comprehensive design but feels rushed and incomplete."
      },
      "ir_monolithic": {
        "architecture": 6,
        "fixability": 7,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 5,
        "weighted_total": 66,
        "justification": "More structured approach with better component management. Clearer initialization, good use of Unity patterns, modular component design. Slightly over-engineered but more maintainable."
      },
      "ir_per_behavior": {
        "architecture": 9,
        "fixability": 8,
        "unity_patterns": 9,
        "correctness": 7,
        "completeness": 6,
        "weighted_total": 77,
        "justification": "Exceptional architectural design with clear separation of concerns. Extensive use of Unity events, serialized fields, and modular component design. Highly extensible with clear extension points and well-thought-out system."
      },
      "winner": "ir_per_behavior",
      "key_differences": "The per-behavior approach provides the most granular, flexible, and extensible implementation. It separates concerns more effectively, uses Unity events for loose coupling, and provides clear hooks for future development.",
      "advantages": "Most robust implementation with comprehensive initialization, clear event-driven architecture, and excellent use of Unity-specific patterns like serialized fields and component-based design. Provides the most natural extension points and follows best practices for game system design."
    },
    "error": null
  },
  {
    "prompt_num": 25,
    "prompt": "Design a sentient furniture set where a chair, table, and lamp communicate through blinking lights and squeaking sounds, rearrange themselves when not observed (position changes between frames where player looks away), and occasionally perform a synchronized dance routine when music plays nearby.",
    "error": "'list' object has no attribute 'get'",
    "timestamp": "2026-01-08T23:28:58.036948"
  },
  {
    "prompt_num": 26,
    "prompt": "Create a emotion-responsive plant that tracks player behavior: grows taller and blooms when player is nearby and calm, wilts and changes to grey when player is aggressive or absent too long, produces happy chime sounds when watered (object dropped on it), and releases spore particles when fully bloomed that affect nearby plants.",
    "timestamp": "2026-01-08T23:28:58.509288",
    "oneshot_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class EmotionPlant : MonoBehaviour\n{\n    [Header(\"Plant Behavior\")]\n    [SerializeField] private float _maxGrowthHeight = 2f;\n    [SerializeField] private float _growthRate = 1f;\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _absenceThreshold = 10f;\n    \n    [Header(\"Emotional States\")]\n    [SerializeField] private float _baseGrowthTime = 2f;\n    [SerializeField] private float _aggressiveDuration = 3f;\n    [SerializeField] private float _calmDuration = 5f;\n    [SerializeField] private bool _startAsCalm = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _sporeParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _happyChime;\n    [SerializeField] private AudioClip _sadSigh;\n    [SerializeField] private AudioClip[] _aggressiveSounds;\n    [SerializeField] private AudioClip[] _calmSounds;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _growthAnimator = \"Growth\";\n    [SerializeField] private string _bloomAnimator = \"Bloom\";\n    [SerializeField] private string _witherAnimator = \"Wither\";\n    [SerializeField] private string _shrinkAnimator = \"Shrink\";\n    \n    private float _currentTime;\n    private bool _isPlayerNearby;\n    private int _lastWateredTime;\n    private int _aggressiveTimer;\n    private int _calmTimer;\n    private List<EmotionPlant> _nearbyPlants;\n    private Transform _playerTransform;\n    \n    private void Start()\n    {\n        _currentTime = 0f;\n        _isPlayerNearby = false;\n        _lastWateredTime = -1f;\n        _aggressiveTimer = 0f;\n        _calmTimer = 0f;\n        \n        SetupAudio();\n        SetupAnimator();\n        FindPlayer();\n        nearbyPlants = new List<EmotionPlant>();\n    }\n    \n    private void Update()\n    {\n        _currentTime += Time.deltaTime;\n        CheckPlayerProximity();\n        UpdateEmotionalState();\n        UpdateVisuals();\n        HandleWatering();\n        UpdateSporeEffects();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_happyChime != null && _audioSource.clip != null)\n            _audioSource.loop = true;\n            _audioSource.Play();\n    }\n    \n    private void SetupAnimator()\n    {\n        if (_animator == null) return;\n        \n        AnimatorController ac = _animator.GetComponent<AnimatorController>();\n        if (ac == null)\n            ac = _animator.AddComponent<AnimatorController>();\n            \n        ac.addTrigger(\"IsPlayerNearby\", IsPlayerNearby);\n        ac.addTrigger(\"ShouldGrow\", GetShouldGrow());\n        ac.addTrigger(\"ShouldShrink\", GetShouldShrink());\n        ac.addTrigger(\"ShouldBloom\", GetShouldBloom());\n        ac.addTrigger(\"ShouldWither\", GetShouldWither());\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n            _playerTransform = player.transform;\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        if (_playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        bool wasNearby = _isPlayerNearby;\n        \n        if (distanceToPlayer <= _detectionRange)\n            _isPlayerNearby = true;\n        else\n            _isPlayerNearby = false;\n            \n        nearbyPlants.Clear();\n        foreach (var plant in GameObject.GetComponentsInChildren<EmotionPlant>())\n        {\n            if (plant != this && !plant.isProhibited)\n                nearbyPlants.Add(plant);\n        }\n        \n        if (_isPlayerNearby && !wasNearby)\n        {\n            _aggressiveTimer = 0f;\n            _calmTimer = 0f;\n        }\n    }\n    \n    private void UpdateEmotionalState()\n    {\n        float timeSpentCalm = 0f;\n        float timeSpentAggressive = 0f;\n        \n        foreach (var plant in nearbyPlants)\n        {\n            if (!plant.isProhibited && plant != this)\n                timeSpentCalm += plant.CalmTime;\n                \n            if (!plant.isProhibited && plant._startAsCalm == false)\n                timeSpentAggressive += plant.AggressiveTime;\n        }\n        \n        float totalNearbyTime = timeSpentCalm + timeSpentAggressive;\n        \n        _calmTimer += Time.deltaTime * 0.5f;\n        if (_isPlayerNearby && totalNearbyTime > _absenceThreshold)\n        {\n            _calmTimer = Mathf.Clamp(_calmTimer, 0f, _baseGrowthTime);\n        }\n        else\n        {\n            _calmTimer = 0f;\n        }\n        \n        float calmPercentage = (_isPlayerNearby ? _calmTimer / _baseGrowthTime : 0f);\n        float aggressivePercentage = (1f - calmPercentage) * (_startAsCalm ? 0.5f : 1f);\n        \n        if (!_isPlayerNearby && totalNearbyTime > _absenceThreshold)\n            aggressivePercentage = Mathf.Clamp(aggressivePercentage, 0f, 1f);\n        \n        float shouldGrow = (calmPercentage >= 0.7f) ? 1f : 0f;\n        float shouldShrink = (aggressivePercentage >= 0.8f || totalNearbyTime < 0.5f) ? 1f : 0f;\n    }\n    \n    private bool GetShouldGrow()\n    {\n        return ShouldGrow && !ShouldShrink;\n    }\n    \n    private bool GetShouldShrink()\n    {\n        return ShouldShrink && !ShouldGrow;\n    }\n    \n    private bool GetShouldBloom()\n    {\n        float growthValue = 0f;\n        \n        foreach (var plant in nearbyPlants)\n        {\n            if (!plant.isProhibited && plant != this)\n                growthValue += plant.CalmTime * 0.5f;\n        }\n        \n        return growthValue >= _baseGrowthTime * 0.8f;\n    }\n    \n    private bool GetShouldWither()\n    {\n        float aggressiveValue = 0f;\n        \n        foreach (var plant in nearbyPlants)\n        {\n            if (!plant.isProhibited && plant._startAsCalm == false)\n                aggressiveValue += plant.AggressiveTime * 1.5f;\n        }\n        \n        return aggressiveValue >= _baseGrowthTime * 2f || aggressiveValue > 0.5f;\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_animator != null)\n        {\n            switch (GetShouldGrow())\n            {\n                case true:\n                    _animator.SetTrigger(_growthAnimator);\n                    break;\n                case false:\n                    switch (GetShouldShrink())\n                    {\n                        case true:\n                            _animator.SetTrigger(_witherAnimator);\n                            break;\n                        case false:\n                            if (_isPlayerNearby && GetShouldBloom())\n                                _animator.SetTrigger(_bloomAnimator);\n                            else\n                                _animator.SetTrigger(_shrinkAnimator);\n                            break;\n                    }\n                case true: // ShouldShrink is always true in this branch\n                    _animator.SetTrigger(_witherAnimator);\n                    break;\n            }\n        }\n    }\n    \n    private void HandleWatering()\n    {\n        if (Time.time - _lastWateredTime >= 1f)\n        {\n            _lastWateredTime = Time.time;\n            WaterPlant();\n        }\n    }\n    \n    private void WaterPlant()\n    {\n        if (_audioSource != null && _happyChime != null && _audioSource.clip != null)\n        {\n            _audioSource.PlayOneShot(_happyChime);\n        }\n        \n        if (_sporeParticles != null)\n            _sporeParticles.Play();\n            \n        nearbyPlants.Clear();\n        foreach (var plant in GameObject.GetComponentsInChildren<EmotionPlant>())\n        {\n            if (plant != this && !plant.isProhibited)\n                nearbyPlants.Add(plant);\n        }\n    }\n    \n    private void UpdateSporeEffects()\n    {\n        if (_sporeParticles == null) return;\n        \n        float sporeCount = Mathf.Max(10f, _currentTime * 5f);\n        for (int i = 0; i < sporeCount; i++)\n            _sporeParticles.Play();\n            \n        if (_currentTime >= _baseGrowthTime)\n            _sporeParticles.Stop();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * _maxGrowthHeight, Vector3.one);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n            _isPlayerNearby = true;\n            \n        nearbyPlants.Clear();\n        foreach (var plant in GameObject.GetComponentsInChildren<EmotionPlant>())\n        {\n            if (plant != this && !plant.isProhibited)\n                nearbyPlants.Add(plant);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n            _isPlayerNearby = false;\n            \n        nearbyPlants.Clear();\n        foreach (var plant in GameObject.GetComponentsInChildren<EmotionPlant>())\n        {\n            if (plant != this && !plant.isProhibited)\n                nearbyPlants.Add(plant);\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, 0.5f);\n    }\n    \n    private enum EmotionState\n    {\n        Calm,\n        Aggressive,\n        Absent\n    }\n    \n    private EmotionState GetCurrentEmotionState()\n    {\n        if (_isPlayerNearby)\n            return _startAsCalm ? EmotionState.Calm : EmotionState.Aggressive;\n        else\n            return EmotionState.Absent;\n    }\n    \n    public void SetProhibited(bool prohibited = true)\n    {\n        _isProhibited = prohibited;\n    }\n    \n    private bool _isProhibited { get; set; }\n    \n    private void FixedUpdate()\n    {\n        if (_currentTime >= _maxGrowthHeight * 2f && !_isProhibited)\n            GrowPlant();\n            \n        UpdateVisuals();\n        UpdateSporeEffects();\n    }\n    \n    private void GrowPlant()\n    {\n        float growthAmount = _growthRate * Time.deltaTime;\n        transform.position += Vector3.up * growthAmount;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_growthAnimator);\n            \n        _currentTime += Time.deltaTime;\n        UpdateSporeEffects();\n    }\n    \n    private void WitherPlant()\n    {\n        transform.localScale = Vector3.one * 0.5f;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_witherAnimator);\n            \n        if (_audioSource != null && _sadSigh != null && _audioSource.clip != null)\n            _audioSource.PlayOneShot(_sadSigh);\n    }\n    \n    private void BloomPlant()\n    {\n        transform.localScale = Vector3.one * 1.5f;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_bloomAnimator);\n            \n        if (_sporeParticles != null)\n            _sporeParticles.Play();\n            \n        if (_audioSource != null && _happyChime != null && _audioSource.clip != null)\n            _audioSource.PlayOneShot(_happyChime);\n    }\n    \n    private void ShrinkPlant()\n    {\n        transform.localScale = Vector3.one * 0.8f;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_shrinkAnimator);\n            \n        if (_audioSource != null && _sadSigh != null && _audioSource.clip != null)\n            _audioSource.PlayOneShot(_sadSigh);\n    }\n    \n    private void SetEmotionState(EmotionState state)\n    {\n        switch (state)\n        {\n            case EmotionState.Calm:\n                _startAsCalm = true;\n                _aggressiveTimer = 0f;\n                _calmTimer = 0f;\n                break;\n            case EmotionState.Aggressive:\n                _startAsCalm = false;\n                _aggressiveTimer = 0f;\n                _calmTimer = 0f;\n                break;\n            case EmotionState.Absent:\n                _startAsCalm = false;\n                _aggressiveTimer = 3f;\n                _calmTimer = 0f;\n                break;\n        }\n    }\n    \n    private void ResetToDefault()\n    {\n        transform.localScale = Vector3.one * 1f;\n        _currentTime = 0f;\n        _lastWateredTime = -1f;\n        _audioSource.loop = false;\n        _isProhibited = false;\n    }\n}",
    "ir_json": {
      "class_name": "EmotionResponsiblePlant",
      "components": [
        "Collider",
        "Animator",
        "AudioSource"
      ],
      "fields": [
        {
          "name": "growthThreshold",
          "type": "float",
          "default": 2.0
        },
        {
          "name": "waterLevel",
          "type": "float",
          "default": 1.0
        },
        {
          "name": "lastPlayerTime",
          "type": "float",
          "default": -1.0
        },
        {
          "name": "isCalm",
          "type": "bool",
          "default": true
        },
        {
          "name": "currentHeight",
          "type": "float",
          "default": 1.0
        }
      ],
      "behaviors": [
        {
          "name": "track_player_proximity",
          "trigger": "when player enters detection range",
          "actions": [
            {
              "action": "store current time as last player interaction"
            },
            {
              "action": "determine if player was calm or aggressive"
            }
          ]
        },
        {
          "name": "update_emotion_state",
          "trigger": "every frame while plant exists",
          "actions": [
            {
              "action": "check how long ago player interacted"
            },
            {
              "action": "if no player interaction for threshold time then set is calm to false"
            },
            {
              "action": "else if player was aggressive then set is calm to false"
            },
            {
              "action": "else update emotional state based on previous player behavior"
            }
          ]
        },
        {
          "name": "change_height_based_on_emotion",
          "trigger": "when emotion state changes",
          "actions": [
            {
              "action": "increase height if now calm and above growth threshold"
            },
            {
              "action": "decrease height if no longer calm"
            },
            {
              "action": "set animation to grow or shrink based on new height"
            }
          ]
        },
        {
          "name": "water_response_behavior",
          "trigger": "when plant is stepped on",
          "actions": [
            {
              "action": "increase water level by 0.5 and play happy chime sound"
            },
            {
              "action": "start watering animation"
            }
          ]
        },
        {
          "name": "flower_bloom_when_calm",
          "trigger": "when calm emotion detected",
          "actions": [
            {
              "action": "play flower blooming animation at current height"
            },
            {
              "action": "enable particle effects for flowers"
            }
          ]
        },
        {
          "name": "release_spores_when_bloomed",
          "trigger": "every frame when in bloom state and watered",
          "actions": [
            {
              "action": "spawn spore particles upward from plant crown"
            },
            {
              "action": "apply gentle upward force to spawned spores"
            }
          ]
        },
        {
          "name": "gray_out_when_not_calm",
          "trigger": "when not calm emotion detected and watered",
          "actions": [
            {
              "action": "change plant color to grey"
            },
            {
              "action": "disable flower particle effects"
            }
          ]
        }
      ]
    },
    "ir_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class EmotionalPlant : MonoBehaviour\n{\n    [Header(\"Growth Settings\")]\n    [SerializeField] private float _growthSpeed = 2f;\n    [SerializeField] private float _maxGrowthAmount = 5f;\n    [SerializeField] private float _minGrowthAmount = 0.1f;\n    \n    [SerializeField] private float _wateringAmount = 10f;\n    [SerializeField] private float _wateringInterval = 3f;\n    [SerializeField] private float _wateringCooldown = 2f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _growTrigger = \"Grow\";\n    [SerializeField] private string _shrinkTrigger = \"Shrink\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _happySounds;\n    [SerializeField] private AudioClip[] _sadSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _flowerParticles;\n    [SerializeField] private ParticleSystem _sporeParticles;\n    [SerializeField] private Light _sunlightLight;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private LayerMask _playerLayerMask = -1;\n    \n    private Transform _player;\n    private float _lastPlayerTime;\n    private float _wateredTime;\n    private bool _canWater;\n    private Coroutine _wateringCoroutine;\n    private Coroutine _spawningCoroutine;\n    \n    private enum EmotionalState\n    {\n        Calm,\n        Happy,\n        Angry,\n        Sad\n    }\n    \n    private EmotionalState _currentState = EmotionalState.Calm;\n    private float _happyTimer = 0f;\n    private float _sadTimer = 0f;\n    private float _angryTimer = 0f;\n    private float _targetHeight;\n    private float _currentHeight;\n    private bool _isDaytime;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupSunlightLight();\n        SetDefaultHeight();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_flowerParticles != null)\n            _flowerParticles.Stop();\n        if (_sporeParticles != null)\n            _sporeParticles.Stop();\n    }\n    \n    void InitializeComponents()\n    {\n        _wateredTime = 0f;\n        _canWater = true;\n        \n        // Try to find player tag\n        GameObject[] players = GameObject.FindGameObjectsWithTag(_playerTag);\n        foreach (GameObject playerObj in players)\n        {\n            if (!string.IsNullOrEmpty(playerObj.name) && \n                playerObj.GetComponent<Collider>() != null && \n                playerObj.GetComponent<Collider>().isTrigger)\n            {\n                _player = playerObj.transform;\n                return;\n            }\n        }\n        \n        // Fallback: find any object with trigger collider\n        GameObject[] allObjects = GameObject.FindGameObjectsOfType<GameObject>();\n        foreach (GameObject obj in allObjects)\n        {\n            if (!string.IsNullOrEmpty(obj.name) && \n                obj.GetComponent<Collider>() != null && \n                obj.GetComponent<Collider>().isTrigger)\n            {\n                _player = obj.transform;\n                return;\n            }\n        }\n        \n        // If still not found, create basic player marker\n        CreatePlayerMarker();\n    }\n    \n    void CreatePlayerMarker()\n    {\n        GameObject playerMarker = new GameObject(\"PlayerMarker\");\n        playerMarker.transform.SetParent(transform);\n        playerMarker.transform.localPosition = Vector3.forward * 5f;\n        \n        Collider markerCollider = playerMarker.AddComponent<Collider>();\n        markerCollider.isTrigger = true;\n        markerCollider.gameObject.SetActive(false);\n        \n        Renderer renderer = playerMarker.AddComponent<Renderer>();\n        renderer.material = Resources.Load<Material>(\"DefaultMaterial\") as Material;\n    }\n    \n    void SetupSunlightLight()\n    {\n        if (_sunlightLight == null)\n        {\n            _sunlightLight = GetComponentInChildren<Light>();\n            if (_sunlightLight == null)\n                _sunlightLight = gameObject.AddComponent<Light>();\n            \n            _sunlightLight.type = LightType.Point;\n            _sunlightLight.color = Color.yellow;\n            _sunlightLight.intensity = 2f;\n        }\n    }\n    \n    void SetDefaultHeight()\n    {\n        GameObject plantObject = GetComponentInChildren<GameObject>();\n        if (plantObject != null)\n        {\n            Vector3 startPos = plantObject.transform.localPosition;\n            startPos.y += 0.5f; // Add height variation\n            plantObject.transform.localPosition = startPos;\n        }\n        \n        _currentHeight = transform.localScale.y;\n    }\n    \n    void Update()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        bool playerInRange = distanceToPlayer <= _detectionRange;\n        \n        // Handle time of day\n        _isDaytime = Time.time % (2f * _dayLength) < _dayLength;\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_playerTag) || other.CompareTag(\"Player\"))\n        {\n            _lastPlayerTime = Time.time;\n            _canWater = true;\n            _isWatering = false;\n            \n            // Reset cooldown\n            if (_wateringCoroutine != null)\n                StopCoroutine(_wateringCoroutine);\n                \n            _wateringCoroutine = StartCoroutine(WaterPlantCooldown());\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_playerTag) || other.CompareTag(\"Player\"))\n        {\n            _canWater = true;\n            _isWatering = false;\n            \n            // Reset cooldown\n            _wateringCoroutine?.Wait();\n            \n            // Check water needs after player leaves\n            StartCoroutine(WaterPlantCooldown());\n        }\n    }\n    \n    void WaterPlant()\n    {\n        if (_isDaytime)\n        {\n            float waterAmount = _wateredTime > 0 ? _wateredTime * 5f : _wateringAmount;\n            PlayHappySound();\n            \n            ApplyWaterEffect(waterAmount);\n        }\n    }\n    \n    void ApplyWaterEffect(float waterAmount)\n    {\n        GameObject waterSplash = new GameObject(\"WaterSplash\");\n        waterSplash.transform.SetParent(transform);\n        \n        ParticleSystem waterParticles = waterSplash.AddComponent<ParticleSystem>();\n        waterParticles.Play();\n        \n        WaterParticle[] particles = new WaterParticle[10];\n        for (int i = 0; i < particles.Length; i++)\n        {\n            particles[i] = new WaterParticle\n            {\n                position = transform.position,\n                velocity = new Vector3(\n                    Random.Range(-5f, 5f),\n                    Random.Range(-2f, 2f),\n                    -8f\n                ),\n                lifetime = Random.Range(0.5f, 1.5f)\n            };\n        }\n        \n        waterParticles.SetParticles(particles);\n    }\n    \n    void WaterPlantCooldown()\n    {\n        if (_wateringCoroutine != null)\n        {\n            StopCoroutine(_wateringCoroutine);\n            _wateringCoroutine = null;\n        }\n    }\n    \n    private void UpdateEmotionalState(float playerInteractionTime)\n    {\n        switch (_currentState)\n        {\n            case EmotionalState.Calm:\n                CheckForHappyPlayer(playerInteractionTime);\n                break;\n                \n            case EmotionalState.Happy:\n                CheckForSadPlayer(playerInteractionTime);\n                break;\n                \n            case EmotionalState.Angry:\n                CheckForSadPlayer(playerInteractionTime);\n                break;\n                \n            case EmotionalState.Sad:\n                // Stay sad until player interacts\n                break;\n        }\n    }\n    \n    void CheckForHappyPlayer(float timeSinceLastInteraction)\n    {\n        if (timeSinceLastInteraction > 0.5f && _currentState == EmotionalState.Calm)\n        {\n            _currentState = EmotionalState.Happy;\n            _happyTimer = 0f;\n        }\n    }\n    \n    void CheckForSadPlayer(float timeSinceLastInteraction)\n    {\n        if (timeSinceLastInteraction > 1f && _currentState != EmotionalState.Sad)\n        {\n            _currentState = EmotionalState.Sad;\n            _sadTimer = 0f;\n        }\n        else\n        {\n            // Update timers based on interaction frequency\n            float interactionMultiplier = _currentState == EmotionalState.Happy ? 2f : 1.5f;\n            _happyTimer += Time.deltaTime * interactionMultiplier;\n            \n            if (_happyTimer > 0.8f && _currentState == EmotionalState.Happy)\n            {\n                _currentState = EmotionalState.Calm;\n                _happyTimer = 0f;\n            }\n        }\n    }\n    \n    void ChangeHeight(float targetHeight)\n    {\n        float heightChange = (_currentHeight - targetHeight) * 0.5f;\n        \n        // Animate height\n        transform.localScale = new Vector3(_currentHeight + heightChange, _currentHeight, _currentHeight);\n        \n        // Update animation triggers\n        if (_animator != null)\n        {\n            float distanceChanged = Mathf.Abs(heightChange);\n            if (distanceChanged > 0.1f)\n                _animator.SetTrigger(_growTrigger);\n                \n            if (targetHeight < _currentHeight * 0.8f)\n                _animator.SetTrigger(_shrinkTrigger);\n        }\n    }\n    \n    void Bloom()\n    {\n        ChangeHeight(Mathf.Clamp(_currentHeight + 2f, 0.1f, 10f));\n        \n        // Start bloom animation\n        if (_animator != null && !_animator.isPlaying)\n            _animator.Play();\n            \n        // Enable flower particles\n        if (_flowerParticles != null)\n            _flowerParticles.gameObject.SetActive(true);\n    }\n    \n    void SpawnSpores()\n    {\n        if (_currentHeight < 2f && _currentState == EmotionalState.Happy && \n            !_sporeParticles.isPlaying)\n        {\n            StartCoroutine(StartSporeCoroutine());\n        }\n    }\n    \n    IEnumerator StartSporeCoroutine()\n    {\n        yield return new WaitForSeconds(1f);\n        \n        if (_currentHeight < 2f && _currentState == EmotionalState.Happy)\n        {\n            // Spawn upward spores\n            GameObject[] sporeObjects = new GameObject[3];\n            for (int i = 0; i < sporeObjects.Length; i++)\n            {\n                sporeObjects[i] = new GameObject($\"Spore_{i}\");\n                sporeObjects[i].AddComponent<ParticleSystem>();\n                \n                ParticleSystem sporeParticles = sporeObjects[i].GetComponent<ParticleSystem>();\n                sporeParticles.transform.localScale = Vector3.one * 1.5f;\n                sporeParticles.transform.position += Vector3.up * 5f;\n            }\n            \n            // Clean up after a few seconds\n            yield return new WaitForSeconds(3f);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        \n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_player != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _player.position);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        if (_wateringCoroutine != null)\n            StopCoroutine(_wateringCoroutine);\n            \n        if (_sporeParticles != null)\n            _sporeParticles.Stop();\n    }\n}\n\npublic class WaterParticle\n{\n    public Vector3 position;\n    public Vector3 velocity;\n    public float lifetime;\n}\n\npublic class EmotionalPlantController : MonoBehaviour\n{\n    [SerializeField] private GameObject _plantObject;\n    [SerializeField] private Transform _playerTransform;\n    [SerializeField] private float _interactionRange = 10f;\n    \n    private List<GameObject> _playersInRange = new List<GameObject>();\n    private Coroutine _interactionCoroutine;\n    \n    public void StartInteraction()\n    {\n        if (_interactionCoroutine != null)\n            StopCoroutine(_interactionCoroutine);\n            \n        _interactionCoroutine = StartCoroutine(InteractWithPlayers());\n    }\n    \n    IEnumerator InteractWithPlayers()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(0.5f);\n            \n            UpdatePlayersInRange();\n            \n            foreach (GameObject player in _playersInRange)\n            {\n                if (player != null && player.transform != _plantObject.transform)\n                {\n                    // Add interaction trigger\n                    OnPlayerInteracted(player);\n                }\n            }\n        }\n    }\n    \n    private void UpdatePlayersInRange()\n    {\n        _playersInRange.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(_plantObject.transform.position, _interactionRange);\n        foreach (Collider col in colliders)\n        {\n            if (col.transform == _plantObject.transform) continue;\n            \n            GameObject playerObj = col.gameObject;\n            if (!string.IsNullOrEmpty(playerObj.name) && \n                playerObj.GetComponent<Collider>() != null && \n                playerObj.GetComponent<Collider>().isTrigger)\n            {\n                _playersInRange.Add(playerObj);\n            }\n        }\n    }\n    \n    public void OnPlayerInteracted(GameObject player)\n    {\n        // Add interaction logic here\n        PlayHappySound();\n        UpdatePlantHeight(0.8f);\n        \n        // Spawn spores\n        GameObject[] sporeObjects = new GameObject[3];\n        for (int i = 0; i < sporeObjects.Length; i++)\n        {\n            sporeObjects[i] = new GameObject($\"Spore_{i}\");\n            sporeObjects[i].AddComponent<ParticleSystem>();\n            \n            ParticleSystem sporeParticles = sporeObjects[i].GetComponent<ParticleSystem>();\n            sporeParticles.transform.localScale = Vector3.one * 1.5f;\n            sporeParticles.transform.position += Vector3.up * 5f;\n        }\n        \n        // Clean up after a few seconds\n        StartCoroutine(CleanupSpores(sporeObjects));\n    }\n    \n    private IEnumerator CleanupSpores(GameObject[] sporeObjects)\n    {\n        yield return new WaitForSeconds(2f);\n        \n        foreach (GameObject spore in sporeObjects)\n        {\n            if (spore != null)\n            {\n                Destroy(spore);\n            }\n        }\n    }\n    \n    public void PlayHappySound()\n    {\n        AudioSource audioSource = _plantObject.GetComponent<AudioSource>();\n        if (audioSource != null && _playersInRange.Count > 0)\n        {\n            AudioClip[] sounds = new AudioClip[]\n            {\n                _happySounds[0] ?? _sadSounds[0],\n                _happySounds[1] ?? _sadSounds[1]\n            };\n            \n            if (sounds.Length > 0)\n            {\n                audioSource.PlayOneShot(sounds[Random.Range(0, sounds.Length)]);\n            }\n        }\n    }\n    \n    public void UpdatePlantHeight(float height)\n    {\n        GameObject plantObj = _plantObject.GetComponent<GameObject>();\n        if (plantObj != null)\n        {\n            plantObj.transform.localScale.y = height;\n        }\n    }\n}",
    "ir_steered": true,
    "ir_rag_docs": 10,
    "ir_rag_doc_names": [
      "Animator.ResetControllerState (0.65)",
      "Animator.IsParameterControlledByCurve (0.64)",
      "Animation.PlayQueued (0.64)",
      "Animator.GetBehaviour (0.63)",
      "Animation.IsPlaying (0.63)",
      "Animation.AddClip (0.63)",
      "AnimationUpdateMode.Normal (0.41)",
      "Terrain.SetKeepUnusedCameraRenderingResources (0.41)",
      "AnimationUpdateMode.Fixed (0.41)",
      "Terrain.GetKeepUnusedCameraRenderingResources (0.40)"
    ],
    "per_behavior_code": "using UnityEngine;\nusing System.Collections;\n\npublic class EmotionResponsivePlant : MonoBehaviour\n{\n    [Header(\"Plant Settings\")]\n    [SerializeField] private float _maxGrowthHeight = 2f;\n    [SerializeField] private float _growthRate = 0.1f;\n    [SerializeField] private float _bloomDuration = 5f;\n    [SerializeField] private float _sporeSpawnInterval = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _waterSounds;\n    [SerializeField] private AudioClip[] _growthSounds;\n    [SerializeField] private AudioClip[] _sporeSounds;\n    [SerializeField] private AudioClip[] _aggressiveSounds;\n    [SerializeField] private AudioClip[] _calmSounds;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _waterSprayEffect;\n    [SerializeField] private ParticleSystem _sporeEmissionEffect;\n    [SerializeField] private Renderer _plantRenderer;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private float _updateFrequency = 0.5f;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Renderer _currentRenderer;\n    private bool _isPlayerNearby;\n    private bool _isBloomed;\n    private bool _isWatering;\n    private float _lastSporeSpawnTime;\n    private float _waterTimer = 0f;\n    private float _growthTimer = 0f;\n    private float _bloomTimer = 0f;\n    private Vector3 _playerPosition;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _currentRenderer = GetComponent<Renderer>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rigidbody == null)\n            _rigidbody = GetComponent<Rigidbody>();\n            \n        if (_plantRenderer != null)\n            _plantRenderer.enabled = false;\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_waterSprayEffect == null)\n            _waterSprayEffect = gameObject.AddComponent<ParticleSystem>();\n        \n        if (_sporeEmissionEffect == null)\n            _sporeEmissionEffect = gameObject.AddComponent<ParticleSystem>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        UpdatePlantState();\n        UpdateVisualEffects();\n        UpdateAudio();\n        \n        if (Time.time >= _updateFrequency)\n        {\n            CheckForSporeSpawn();\n            CheckForWateringUpdate();\n        }\n    }\n    \n    private void DetectPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, playerObject.transform.position);\n        _isPlayerNearby = distanceToPlayer <= _detectionRadius;\n        _playerPosition = playerObject.transform.position;\n    }\n    \n    private void UpdatePlantState()\n    {\n        if (!_isPlayerNearby) return;\n        \n        float playerMovementSpeed = GetPlayerMovementSpeed();\n        \n        // Determine player behavior\n        bool playerIsCalm = IsPlayerCalm(playerMovementSpeed);\n        bool playerIsAggressive = !playerIsCalm && playerMovementSpeed > 3f;\n        \n        // Update growth based on behavior\n        _growthTimer += Time.deltaTime * _growthRate;\n        float currentGrowth = Mathf.Lerp(0f, _maxGrowthHeight, _growthTimer);\n        \n        if (currentGrowth < 0f)\n            currentGrowth = 0f;\n            \n        ApplyGrowth(currentGrowth, playerIsCalm, playerIsAggressive);\n    }\n    \n    private float GetPlayerMovementSpeed()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject == null) return 0f;\n        \n        Rigidbody playerRb = playerObject.GetComponent<Rigidbody>();\n        if (playerRb != null)\n            return Mathf.Abs(playerRb.velocity.magnitude);\n        else\n            return 0f;\n    }\n    \n    private bool IsPlayerCalm(float movementSpeed)\n    {\n        float calmThreshold = 2f;\n        return movementSpeed <= calmThreshold;\n    }\n    \n    private void ApplyGrowth(float growthAmount, bool isCalm, bool isAggressive)\n    {\n        if (_rigidbody == null) return;\n        \n        Vector3 growthDirection = _rigidbody.velocity.normalized * growthAmount;\n        growthDirection.y = 0f; // Prevent vertical growth\n        \n        _rigidbody.AddForce(growthDirection, ForceMode.VelocityChange);\n        \n        // Update renderer material based on growth\n        if (_plantRenderer != null)\n        {\n            Color targetColor = GetPlantColor(isCalm, isAggressive);\n            _plantRenderer.material.color = targetColor;\n        }\n    }\n    \n    private Color GetPlantColor(bool isCalm, bool isAggressive)\n    {\n        float brightness = Mathf.Lerp(0.3f, 1f, isCalm ? 1f : 0.5f);\n        return new Color(brightness, 0.4f * brightness, 0.2f * brightness);\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_waterSprayEffect == null) return;\n        \n        _waterTimer += Time.deltaTime;\n        float waterAmount = Mathf.Lerp(0f, 1f, _waterTimer / 5f);\n        \n        var main = _waterSprayEffect.main;\n        main.startLifetime = waterAmount;\n        main.startColor = new Color(0.8f, 0.6f, 0.3f, 0.7f);\n        main.startSpeed = 10f;\n        main.startSize = 1f;\n        \n        _waterSprayEffect.Play();\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource == null) return;\n        \n        // Water sound\n        if (_isWatering)\n        {\n            PlayRandomWaterSound();\n        }\n        else\n        {\n            PlayRandomGrowthSound();\n        }\n    }\n    \n    private void CheckForSporeSpawn()\n    {\n        if (!_sporeEmissionEffect != null && Time.time >= _lastSporeSpawnTime + _sporeSpawnInterval)\n        {\n            _lastSporeSpawnTime = Time.time;\n            spawnSpores();\n        }\n    }\n    \n    private void CheckForWateringUpdate()\n    {\n        if (_isPlayerNearby && !_isWatering)\n        {\n            StartWatering();\n        }\n        else if (_isPlayerNearby && _isWatering)\n        {\n            StopWatering();\n        }\n    }\n    \n    private void spawnSpores()\n    {\n        if (_sporeEmissionEffect == null) return;\n        \n        var main = _sporeEmissionEffect.main;\n        main.startLifetime = 2f;\n        main.startSize = 0.1f;\n        main.startSpeed = 5f;\n        main.startColor = new Color(0.7f, 0.9f, 1f, 0.3f);\n        \n        _sporeEmissionEffect.Play();\n    }\n    \n    private void StartWatering()\n    {\n        if (_waterSprayEffect == null) return;\n        \n        _isWatering = true;\n        _waterTimer = 0f;\n        \n        // Play water sound\n        if (_waterSounds != null && _waterSounds.Length > 0)\n        {\n            PlayRandomWaterSound();\n        }\n    }\n    \n    private void StopWatering()\n    {\n        _isWatering = false;\n        \n        // Water spray effect\n        var main = _waterSprayEffect.main;\n        main.startLifetime = 0f;\n        main.startSize = 1f;\n        main.startColor = Color.white;\n        \n        _waterSprayEffect.Stop();\n    }\n    \n    private void PlayRandomWaterSound()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _waterSounds.Length);\n        if (soundIndex >= 0 && _waterSounds[soundIndex] != null)\n            _audioSource.PlayOneShot(_waterSounds[soundIndex]);\n    }\n    \n    private void PlayRandomGrowthSound()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _growthSounds.Length);\n        if (soundIndex >= 0 && _growthSounds[soundIndex] != null)\n            _audioSource.PlayOneShot(_growthSounds[soundIndex]);\n    }\n    \n    private void PlaySporeSound()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _sporeSounds.Length);\n        if (soundIndex >= 0 && _sporeSounds[soundIndex] != null)\n            _audioSource.PlayOneShot(_sporeSounds[soundIndex]);\n    }\n    \n    private void PlayAggressiveSound()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _aggressiveSounds.Length);\n        if (soundIndex >= 0 && _aggressiveSounds[soundIndex] != null)\n            _audioSource.PlayOneShot(_aggressiveSounds[soundIndex]);\n    }\n    \n    private void PlayCalmSound()\n    {\n        if (_audioSource == null) return;\n        \n        int soundIndex = Random.Range(0, _calmSounds.Length);\n        if (soundIndex >= 0 && _calmSounds[soundIndex] != null)\n            _audioSource.PlayOneShot(_calmSounds[soundIndex]);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_playerPosition != Vector3.zero)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _playerPosition);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartWatering();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopWatering();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            StartWatering();\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartWatering();\n        }\n    }\n    \n    private void OnTriggerExit2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopWatering();\n        }\n    }\n}",
    "per_behavior_docs": 16,
    "per_behavior_methods": 8,
    "per_behavior_doc_names": {
      "track_player_proximity": [
        "Physics.OverlapSphere (0.68)",
        "Physics.OverlapSphereNonAlloc (0.68)",
        "Physics.Raycast (0.67)"
      ],
      "detect_player_behavior": [
        "Rigidbody.MoveRotation (0.71)",
        "Rigidbody.MovePosition (0.69)",
        "Rigidbody.Move (0.69)"
      ],
      "respond_to_player_calm": [
        "Animator.PlayInFixedTime (0.65)",
        "WaitTimeoutMode (0.62)",
        "Time (0.62)"
      ],
      "respond_to_player_aggression": [
        "Animator.PlayInFixedTime (0.64)",
        "Time (0.62)",
        "WaitTimeoutMode (0.62)"
      ],
      "respond_to_player_absence": [
        "Physics.OverlapSphereNonAlloc (0.68)",
        "Physics.OverlapSphere (0.68)",
        "Physics.Raycast (0.66)"
      ],
      "water_plant": [
        "Animator.PlayInFixedTime (0.65)",
        "Time (0.63)",
        "Animator.CrossFadeInFixedTime (0.63)"
      ],
      "release_spores": [
        "ParticleSystem.ColorBySpeedModule (0.73)",
        "ParticleSystem.Play (0.73)",
        "ParticleSystem.GetPlaybackState (0.71)"
      ],
      "maintain_health": [
        "WaitForFixedUpdate (0.54)",
        "Animation.IsPlaying (0.54)",
        "Animator.ResetControllerState (0.53)"
      ]
    },
    "grade": {
      "oneshot": {
        "architecture": 5,
        "fixability": 4,
        "unity_patterns": 6,
        "correctness": 5,
        "completeness": 4,
        "weighted_total": 52,
        "justification": "Direct translation lacks clear separation of concerns. Methods are somewhat tangled, with multiple responsibilities in single methods. Good use of serialized fields, but complexity makes extension difficult."
      },
      "ir_monolithic": {
        "architecture": 7,
        "fixability": 8,
        "unity_patterns": 8,
        "correctness": 6,
        "completeness": 7,
        "weighted_total": 67,
        "justification": "Strong modular design with clear enum for emotional states. Comprehensive error handling and multiple initialization strategies. Good use of Unity patterns like component retrieval and serialized fields."
      },
      "ir_per_behavior": {
        "architecture": 8,
        "fixability": 7,
        "unity_patterns": 7,
        "correctness": 6,
        "completeness": 6,
        "weighted_total": 64,
        "justification": "Highly decomposed approach with clear method-level separation. Excellent potential for extension. Slightly over-engineered with multiple redundant initialization checks."
      },
      "winner": "ir_monolithic",
      "key_differences": "The IR Monolithic approach provides the best balance of modularity, extensibility, and Unity-specific design patterns. It uses a clear emotional state enum, provides multiple fallback mechanisms, and has robust component initialization.",
      "advantages": "Best approach for maintaining and extending plant behavior, with clear state management and comprehensive initialization strategies. Provides a solid framework that a junior developer could easily understand and modify."
    },
    "error": null
  }
]