[
  {
    "prompt_num": 1,
    "prompt": "Create a script that makes an object spin faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase.",
    "timestamp": "2026-01-08T10:49:30.548585",
    "oneshot_code": "using UnityEngine;\n\npublic class SpinAndExplode : MonoBehaviour\n{\n    [SerializeField] private float maxSpinSpeed = 50f;\n    [SerializeField] private AudioClip explosionSound;\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private Material colorShiftMaterial;\n    [SerializeField] private GameObject[] explosionPiecesPrefab;\n    [SerializeField] private AudioClip[] pieceExplosionSounds;\n\n    private float currentSpinSpeed = 0f;\n    private bool isSpinningUp = false;\n    private bool isExploding = false;\n\n    public void StartSpin()\n    {\n        isSpinningUp = true;\n        StartCoroutine(SpinAndColorShift());\n    }\n\n    public void StopSpin()\n    {\n        isSpinningUp = false;\n        isExploding = true;\n        PlayExplosionSound();\n        SpawnExplosionPieces();\n    }\n\n    private IEnumerator SpinAndColorShift()\n    {\n        while (currentSpinSpeed < maxSpinSpeed)\n        {\n            currentSpinSpeed += Time.deltaTime * 10f;\n\n            // Apply color shift\n            colorShiftMaterial.SetFloat(\"_Time\", currentSpinSpeed / maxSpinSpeed);\n            transform.Rotate(Vector3.up, currentSpinSpeed);\n\n            yield return null;\n        }\n\n        StopCoroutine(SpinAndColorShift());\n    }\n\n    private void PlayExplosionSound()\n    {\n        audioSource.PlayOneShot(explosionSound);\n    }\n\n    private void SpawnExplosionPieces()\n    {\n        for (int i = 0; i < explosionPiecesPrefab.Length; i++)\n        {\n            Instantiate(explosionPiecesPrefab[i], transform.position, Quaternion.identity);\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Play unique piece explosion sound\n        audioSource.PlayOneShot(pieceExplosionSounds[Random.Range(0, pieceExplosionSounds.Length)]);\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": "using UnityEngine;\n\npublic class GeneratedBehavior : MonoBehaviour\n{\n    // TODO: [Declare any required fields]\n\n    void Start() {\n        // TODO: [Any initialization logic]\n    }\n\n    void Update() {\n        // TODO: [Implement behavior 1]\n        \n        // TODO: [Implement behavior 2]\n    }\n}",
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": {},
    "grade": null,
    "error": null
  },
  {
    "prompt_num": 2,
    "prompt": "Make a gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center, all while rotating the entire gravity well slowly.",
    "timestamp": "2026-01-08T10:50:00.662193",
    "oneshot_code": "using UnityEngine;\nusing System.Collections;\n\npublic class GravityWell : MonoBehaviour {\n\n    [SerializeField] private float pullForce = 10f;\n    [SerializeField] private float rumbleIntensity = 5f;\n    [SerializeField] private Color lightColor = new Color(1f, 1f, 1f);\n    [SerializeField] private ParticleSystem collisionParticlePrefab;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource rumbleSource;\n    [SerializeField] private AudioClip rumbleClip;\n\n    [Header(\"Lighting\")]\n    [SerializeField] private Light mainLight;\n\n    [Range(0f, 1f)]\n    [SerializeField] private float lightIntensityMultiplier = 0.5f;\n\n    [SerializeField] private Color lightColorChangeSpeed = new Color(0f, 0f, 0f);\n\n    private Rigidbody gravityWellRb;\n    private Vector3 worldCenterOffset;\n    private bool isPulling = false;\n\n    private void Start()\n    {\n        // Get rigidbody component\n        gravityWellRb = GetComponent<Rigidbody>();\n\n        // Calculate offset for center of gravity well\n        worldCenterOffset = transform.TransformPoint(Vector3.forward * 0.5f);\n    }\n\n    private void FixedUpdate()\n    {\n        // Check if any rigidbodies are nearby\n        Collider[] colliders = Physics.OverlapSphere(worldCenterOffset, pullForce);\n\n        foreach (Collider col in colliders)\n        {\n            Rigidbody rb = col.GetComponent<Rigidbody>();\n\n            // Calculate distance from center of gravity well\n            Vector3 directionToCenter = worldCenterOffset - col.transform.position;\n            float distance = directionToCenter.magnitude;\n\n            // Apply pull force based on distance\n            if (!isPulling && rb != null)\n            {\n                isPulling = true;\n                StartCoroutine(ApplyPullForce(rb, distance));\n            }\n\n            // Update light intensity and color\n            UpdateLightIntensityAndColor(distance);\n        }\n    }\n\n    private IEnumerator ApplyPullForce(Rigidbody targetRB, float distance)\n    {\n        while (targetRB != null && !isPulling)\n        {\n            Vector3 forceDirection = worldCenterOffset - targetRB.position;\n            float pullMagnitude = pullForce * (1f / (distance + 0.5f)); // Increase force with distance\n\n            // Apply gravity-like force\n            targetRB.AddForce(forceDirection.normalized * pullMagnitude, ForceMode.Force);\n\n            yield return null;\n        }\n\n        isPulling = false; // Stop pulling when object leaves range or collides\n    }\n\n    private void UpdateLightIntensityAndColor(float distance)\n    {\n        if (mainLight != null)\n        {\n            float lightIntensity = 1f - Mathf.Clamp01(distance / pullForce);\n            mainLight.intensity *= lightIntensity * lightIntensityMultiplier;\n\n            // Change color over time based on distance\n            Color newColor = lightColor;\n            newColor.r += lightColorChangeSpeed.r * (distance / pullForce) * Time.deltaTime;\n            newColor.g += lightColorChangeSpeed.g * (distance / pullForce) * Time.deltaTime;\n            newColor.b += lightColorChangeSpeed.b * (distance / pullForce) * Time.deltaTime;\n\n            mainLight.color = newColor;\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Play rumble audio\n        if (rumbleSource != null && rumbleClip != null)\n        {\n            rumbleSource.PlayOneShot(rumbleClip);\n        }\n\n        // Spawn particle effect at collision point\n        Instantiate(collisionParticlePrefab, transform.position, Quaternion.identity);\n\n        // Reset pull state\n        isPulling = false;\n    }\n}",
    "ir_json": null,
    "ir_code": null,
    "ir_steered": false,
    "ir_rag_docs": 0,
    "ir_rag_doc_names": null,
    "per_behavior_code": "using UnityEngine;\n\npublic class GeneratedBehavior : MonoBehaviour\n{\n    // No fields required\n    \n    void Start() \n    {\n        // Behavior implementation goes here\n    }\n\n    void Update()\n    {\n        // Behavior implementation goes here\n    }\n}",
    "per_behavior_docs": 0,
    "per_behavior_methods": 0,
    "per_behavior_doc_names": {},
    "grade": null,
    "error": null
  }
]