{
  "generated_at": "2026-01-08T14:46:47.627827",
  "model": "claude-sonnet-4-20250514",
  "total_examples": 346,
  "complete_examples": 346,
  "by_type": {
    "pickup": 15,
    "general": 237,
    "environment": 13,
    "combat": 54,
    "movement": 27
  },
  "pairs": [
    {
      "prompt": "rotating coin that adds score when collected",
      "ideal_ir": {
        "class_name": "CollectibleCoin",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "scoreValue",
            "type": "int",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "rotate_continuously",
            "trigger": "every frame",
            "actions": [
              {
                "action": "rotate around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "collect_coin",
            "trigger": "when player touches this coin",
            "actions": [
              {
                "action": "add score value to player score"
              },
              {
                "action": "destroy this coin object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class CollectibleCoin : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 180, 0);\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private int _scoreValue = 10;\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _collectDelay = 0f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _effectDuration = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnCoinCollected;\n    public UnityEvent OnCollectionComplete;\n    \n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private bool _isCollected = false;\n    \n    public static int TotalScore { get; private set; } = 0;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isCollected)\n        {\n            transform.Rotate(_rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        TotalScore += _scoreValue;\n        \n        OnCoinCollected?.Invoke(_scoreValue);\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collectDelay > 0)\n        {\n            Invoke(nameof(CompleteCollection), _collectDelay);\n        }\n        else\n        {\n            CompleteCollection();\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.volume = _volume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n    }\n    \n    private void CompleteCollection()\n    {\n        OnCollectionComplete?.Invoke();\n        \n        if (_destroyOnCollect)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public static void ResetScore()\n    {\n        TotalScore = 0;\n    }\n    \n    public void SetScoreValue(int value)\n    {\n        _scoreValue = Mathf.Max(0, value);\n    }\n    \n    public int GetScoreValue()\n    {\n        return _scoreValue;\n    }\n    \n    public bool IsCollected()\n    {\n        return _isCollected;\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "health pickup that heals player on touch",
      "ideal_ir": {
        "class_name": "HealthPickup",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "healAmount",
            "type": "int",
            "default": 25
          },
          {
            "name": "isUsed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "heal_player_on_touch",
            "trigger": "when player touches this pickup and pickup has not been used",
            "actions": [
              {
                "action": "increase player health by heal amount"
              },
              {
                "action": "mark pickup as used"
              },
              {
                "action": "destroy this pickup object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthPickup : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _healAmount = 25;\n    [SerializeField] private int _maxHealth = 100;\n    \n    [Header(\"Pickup Settings\")]\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private float _effectDuration = 2f;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent<int> _onHealthPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        AnimatePickup();\n    }\n    \n    private void AnimatePickup()\n    {\n        if (_rotationSpeed > 0)\n        {\n            transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        }\n        \n        if (_bobHeight > 0 && _bobSpeed > 0)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HealPlayer(other.gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            HealPlayer(collision.gameObject);\n        }\n    }\n    \n    private void HealPlayer(GameObject player)\n    {\n        PlayerHealthComponent playerHealth = player.GetComponent<PlayerHealthComponent>();\n        \n        if (playerHealth == null)\n        {\n            playerHealth = player.GetComponentInChildren<PlayerHealthComponent>();\n        }\n        \n        if (playerHealth == null)\n        {\n            playerHealth = player.AddComponent<PlayerHealthComponent>();\n            playerHealth.Initialize(_maxHealth);\n        }\n        \n        int actualHealAmount = playerHealth.Heal(_healAmount);\n        \n        if (actualHealAmount > 0)\n        {\n            PlayPickupEffects();\n            _onHealthPickedUp?.Invoke(actualHealAmount);\n            \n            if (_destroyOnPickup)\n            {\n                if (_audioSource != null && _pickupSound != null)\n                {\n                    _audioSource.PlayOneShot(_pickupSound);\n                    StartCoroutine(DestroyAfterSound());\n                }\n                else\n                {\n                    Destroy(gameObject);\n                }\n            }\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            GameObject effect = Instantiate(_pickupEffect, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator DestroyAfterSound()\n    {\n        GetComponent<Collider>().enabled = false;\n        GetComponent<Renderer>().enabled = false;\n        \n        yield return new WaitForSeconds(_pickupSound.length);\n        Destroy(gameObject);\n    }\n    \n    [System.Serializable]\n    public class PlayerHealthComponent : MonoBehaviour\n    {\n        [SerializeField] private int _currentHealth;\n        [SerializeField] private int _maxHealth = 100;\n        \n        public int CurrentHealth => _currentHealth;\n        public int MaxHealth => _maxHealth;\n        public bool IsFullHealth => _currentHealth >= _maxHealth;\n        \n        private void Start()\n        {\n            if (_currentHealth <= 0)\n            {\n                _currentHealth = _maxHealth;\n            }\n        }\n        \n        public void Initialize(int maxHealth)\n        {\n            _maxHealth = maxHealth;\n            _currentHealth = maxHealth;\n        }\n        \n        public int Heal(int amount)\n        {\n            if (amount <= 0 || IsFullHealth) return 0;\n            \n            int previousHealth = _currentHealth;\n            _currentHealth = Mathf.Min(_currentHealth + amount, _maxHealth);\n            \n            return _currentHealth - previousHealth;\n        }\n        \n        public void TakeDamage(int amount)\n        {\n            if (amount <= 0) return;\n            \n            _currentHealth = Mathf.Max(_currentHealth - amount, 0);\n        }\n        \n        public void SetHealth(int health)\n        {\n            _currentHealth = Mathf.Clamp(health, 0, _maxHealth);\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "ammo box that refills weapon ammunition",
      "ideal_ir": {
        "class_name": "AmmoBox",
        "components": [
          "BoxCollider",
          "MeshRenderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "ammoAmount",
            "type": "int",
            "default": 30
          },
          {
            "name": "refillSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "isUsed",
            "type": "bool",
            "default": false
          },
          {
            "name": "respawnTime",
            "type": "float",
            "default": 10.0
          }
        ],
        "behaviors": [
          {
            "name": "refill_ammo",
            "trigger": "when player touches the ammo box and box is not used",
            "actions": [
              {
                "action": "add ammo amount to player weapon"
              },
              {
                "action": "play refill sound effect"
              },
              {
                "action": "mark box as used"
              },
              {
                "action": "hide the ammo box visually"
              },
              {
                "action": "disable collision detection"
              }
            ]
          },
          {
            "name": "respawn_ammo_box",
            "trigger": "when respawn time has elapsed after being used",
            "actions": [
              {
                "action": "mark box as not used"
              },
              {
                "action": "show the ammo box visually"
              },
              {
                "action": "enable collision detection"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AmmoBox : MonoBehaviour\n{\n    [System.Serializable]\n    public class AmmoRefillEvent : UnityEvent<int> { }\n    \n    [System.Serializable]\n    public class AmmoType\n    {\n        public string ammoName = \"Bullets\";\n        public int refillAmount = 30;\n        public bool unlimitedRefills = false;\n        public int maxRefills = 1;\n        [HideInInspector] public int currentRefills = 0;\n    }\n    \n    [Header(\"Ammo Configuration\")]\n    [SerializeField] private AmmoType[] _ammoTypes = new AmmoType[] { new AmmoType() };\n    [SerializeField] private bool _refillAllAmmoTypes = true;\n    [SerializeField] private float _refillCooldown = 1f;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool _requireKeyPress = false;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _visualEffect;\n    [SerializeField] private AudioClip _refillSound;\n    [SerializeField] private ParticleSystem _refillParticles;\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _refillAnimationTrigger = \"Refill\";\n    \n    [Header(\"Auto Destruction\")]\n    [SerializeField] private bool _destroyWhenEmpty = true;\n    [SerializeField] private float _destroyDelay = 0.5f;\n    \n    [Header(\"Events\")]\n    public AmmoRefillEvent OnAmmoRefilled;\n    public UnityEvent OnAmmoBoxEmpty;\n    public UnityEvent OnPlayerInRange;\n    public UnityEvent OnPlayerOutOfRange;\n    \n    private AudioSource _audioSource;\n    private bool _playerInRange = false;\n    private GameObject _currentPlayer;\n    private float _lastRefillTime = -1f;\n    private bool _isEmpty = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _refillSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        // Initialize refill counters\n        foreach (var ammoType in _ammoTypes)\n        {\n            ammoType.currentRefills = 0;\n        }\n        \n        // Ensure we have a collider for trigger detection\n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            col = gameObject.AddComponent<BoxCollider>();\n        }\n        col.isTrigger = true;\n    }\n    \n    private void Update()\n    {\n        if (_isEmpty) return;\n        \n        if (_requireKeyPress && _playerInRange && _currentPlayer != null)\n        {\n            if (Input.GetKeyDown(_interactionKey))\n            {\n                TryRefillAmmo(_currentPlayer);\n            }\n        }\n        \n        // Check if player is still in range when using key interaction\n        if (_requireKeyPress && _currentPlayer != null)\n        {\n            float distance = Vector3.Distance(transform.position, _currentPlayer.transform.position);\n            if (distance > _interactionRange)\n            {\n                OnPlayerExitRange();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isEmpty) return;\n        \n        if (IsPlayer(other.gameObject))\n        {\n            if (_requireKeyPress)\n            {\n                OnPlayerEnterRange(other.gameObject);\n            }\n            else\n            {\n                TryRefillAmmo(other.gameObject);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsPlayer(other.gameObject) && _requireKeyPress)\n        {\n            OnPlayerExitRange();\n        }\n    }\n    \n    private bool IsPlayer(GameObject obj)\n    {\n        return obj.CompareTag(\"Player\") && ((_playerLayer.value & (1 << obj.layer)) != 0);\n    }\n    \n    private void OnPlayerEnterRange(GameObject player)\n    {\n        _playerInRange = true;\n        _currentPlayer = player;\n        OnPlayerInRange?.Invoke();\n    }\n    \n    private void OnPlayerExitRange()\n    {\n        _playerInRange = false;\n        _currentPlayer = null;\n        OnPlayerOutOfRange?.Invoke();\n    }\n    \n    private void TryRefillAmmo(GameObject player)\n    {\n        if (_isEmpty || Time.time - _lastRefillTime < _refillCooldown)\n            return;\n        \n        // Find weapon components on player\n        WeaponAmmo[] weapons = player.GetComponentsInChildren<WeaponAmmo>();\n        if (weapons.Length == 0)\n        {\n            // Try to find weapon on player directly\n            WeaponAmmo weapon = player.GetComponent<WeaponAmmo>();\n            if (weapon != null)\n            {\n                weapons = new WeaponAmmo[] { weapon };\n            }\n        }\n        \n        if (weapons.Length == 0) return;\n        \n        bool refillSuccessful = false;\n        \n        foreach (var ammoType in _ammoTypes)\n        {\n            if (!ammoType.unlimitedRefills && ammoType.currentRefills >= ammoType.maxRefills)\n                continue;\n            \n            foreach (var weapon in weapons)\n            {\n                if (_refillAllAmmoTypes || weapon.AmmoTypeName == ammoType.ammoName)\n                {\n                    if (weapon.RefillAmmo(ammoType.refillAmount))\n                    {\n                        refillSuccessful = true;\n                        ammoType.currentRefills++;\n                        OnAmmoRefilled?.Invoke(ammoType.refillAmount);\n                        \n                        if (!_refillAllAmmoTypes) break;\n                    }\n                }\n            }\n        }\n        \n        if (refillSuccessful)\n        {\n            _lastRefillTime = Time.time;\n            PlayRefillEffects();\n            \n            if (IsEmpty())\n            {\n                HandleEmptyAmmoBox();\n            }\n        }\n    }\n    \n    private void PlayRefillEffects()\n    {\n        if (_refillSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_refillSound);\n        }\n        \n        if (_refillParticles != null)\n        {\n            _refillParticles.Play();\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_refillAnimationTrigger))\n        {\n            _animator.SetTrigger(_refillAnimationTrigger);\n        }\n        \n        if (_visualEffect != null)\n        {\n            _visualEffect.SetActive(true);\n            Invoke(nameof(DisableVisualEffect), 1f);\n        }\n    }\n    \n    private void DisableVisualEffect()\n    {\n        if (_visualEffect != null)\n        {\n            _visualEffect.SetActive(false);\n        }\n    }\n    \n    private bool IsEmpty()\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            if (ammoType.unlimitedRefills || ammoType.currentRefills < ammoType.maxRefills)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private void HandleEmptyAmmoBox()\n    {\n        _isEmpty = true;\n        OnAmmoBoxEmpty?.Invoke();\n        \n        if (_destroyWhenEmpty)\n        {\n            Destroy(gameObject, _destroyDelay);\n        }\n    }\n    \n    public void RefillAmmoBox()\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            ammoType.currentRefills = 0;\n        }\n        _isEmpty = false;\n    }\n    \n    public int GetRemainingRefills(string ammoTypeName)\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            if (ammoType.ammoName == ammoTypeName)\n            {\n                if (ammoType.unlimitedRefills) return -1;\n                return ammoType.maxRefills - ammoType.currentRefills;\n            }\n        }\n        return 0;\n    }\n}\n\n[System.Serializable]\npublic class WeaponAmmo : MonoBehaviour\n{\n    [Header(\"Ammo Settings\")]\n    [SerializeField] private string _ammoTypeName = \"Bullets\";\n    [SerializeField] private int _currentAmmo = 30;\n    [SerializeField] private int _maxAmmo = 120;\n    [SerializeField] private int _clipSize = 30;\n    [SerializeField] private int _currentClip = 30;\n    \n    public string AmmoTypeName => _ammoTypeName;\n    public int CurrentAmmo => _currentAmmo;\n    public int MaxAmmo => _maxAmmo;\n    public int CurrentClip => _currentClip;\n    \n    public bool RefillAmmo(int amount)\n    {\n        if (_currentAmmo >= _maxAmmo) return false;\n        \n        int ammoToAdd = Mathf.Min(amount, _maxAmmo - _currentAmmo);\n        _currentAmmo += ammoToAdd;\n        \n        return ammoToAdd > 0;\n    }\n    \n    public bool UseAmmo(int amount = 1)\n    {\n        if (_currentClip < amount) return false;\n        \n        _currentClip -= amount;\n        return true;\n    }\n    \n    public bool Reload()\n    {\n        if (_currentAmmo <= 0 || _currentClip >= _clipSize) return false;\n        \n        int ammoNeeded = _clipSize - _currentClip;\n        int ammoToReload = Mathf.Min(ammoNeeded, _currentAmmo);\n        \n        _currentClip += ammoToReload;\n        _currentAmmo -= ammoToReload;\n        \n        return ammoToReload > 0;\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "power-up that grants temporary invincibility",
      "ideal_ir": {
        "class_name": "InvincibilityPowerUp",
        "components": [
          "Collider",
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "invincibilityDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isCollected",
            "type": "bool",
            "default": false
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90.0
          }
        ],
        "behaviors": [
          {
            "name": "rotate_continuously",
            "trigger": "every frame while power-up exists",
            "actions": [
              {
                "action": "rotate around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "collect_power_up",
            "trigger": "when player touches this power-up",
            "actions": [
              {
                "action": "mark power-up as collected"
              },
              {
                "action": "grant player invincibility for specified duration"
              },
              {
                "action": "play collection sound effect"
              },
              {
                "action": "destroy this power-up object"
              }
            ]
          },
          {
            "name": "bob_up_and_down",
            "trigger": "every frame while power-up exists",
            "actions": [
              {
                "action": "move up and down in a smooth floating motion"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class InvincibilityPowerUp : MonoBehaviour\n{\n    [Header(\"Power-Up Settings\")]\n    [SerializeField] private float _invincibilityDuration = 5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private bool _destroyOnPickup = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private Color _invincibilityColor = Color.yellow;\n    [SerializeField] private float _flashSpeed = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPowerUpCollected;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        AnimatePowerUp();\n    }\n    \n    private void AnimatePowerUp()\n    {\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyInvincibility(other.gameObject);\n            HandlePickupEffects();\n            OnPowerUpCollected?.Invoke();\n            \n            if (_destroyOnPickup)\n            {\n                Destroy(gameObject);\n            }\n            else\n            {\n                gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    private void ApplyInvincibility(GameObject player)\n    {\n        InvincibilityEffect invincibilityEffect = player.GetComponent<InvincibilityEffect>();\n        \n        if (invincibilityEffect == null)\n        {\n            invincibilityEffect = player.AddComponent<InvincibilityEffect>();\n        }\n        \n        invincibilityEffect.ActivateInvincibility(_invincibilityDuration, _invincibilityColor, _flashSpeed);\n    }\n    \n    private void HandlePickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n}\n\npublic class InvincibilityEffect : MonoBehaviour\n{\n    private bool _isInvincible = false;\n    private Renderer[] _renderers;\n    private Color[] _originalColors;\n    private Collider _playerCollider;\n    private Coroutine _invincibilityCoroutine;\n    \n    public bool IsInvincible => _isInvincible;\n    \n    private void Awake()\n    {\n        _renderers = GetComponentsInChildren<Renderer>();\n        _originalColors = new Color[_renderers.Length];\n        _playerCollider = GetComponent<Collider>();\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i].material != null)\n            {\n                _originalColors[i] = _renderers[i].material.color;\n            }\n        }\n    }\n    \n    public void ActivateInvincibility(float duration, Color invincibilityColor, float flashSpeed)\n    {\n        if (_invincibilityCoroutine != null)\n        {\n            StopCoroutine(_invincibilityCoroutine);\n        }\n        \n        _invincibilityCoroutine = StartCoroutine(InvincibilityCoroutine(duration, invincibilityColor, flashSpeed));\n    }\n    \n    private IEnumerator InvincibilityCoroutine(float duration, Color invincibilityColor, float flashSpeed)\n    {\n        _isInvincible = true;\n        float elapsed = 0f;\n        \n        if (_playerCollider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), true);\n        }\n        \n        while (elapsed < duration)\n        {\n            float flashValue = Mathf.Sin(Time.time * flashSpeed) * 0.5f + 0.5f;\n            \n            for (int i = 0; i < _renderers.Length; i++)\n            {\n                if (_renderers[i] != null && _renderers[i].material != null)\n                {\n                    _renderers[i].material.color = Color.Lerp(_originalColors[i], invincibilityColor, flashValue);\n                }\n            }\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _isInvincible = false;\n        \n        if (_playerCollider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), false);\n        }\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _renderers[i].material != null)\n            {\n                _renderers[i].material.color = _originalColors[i];\n            }\n        }\n        \n        _invincibilityCoroutine = null;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInvincible && (other.CompareTag(\"Enemy\") || other.CompareTag(\"Projectile\")))\n        {\n            // Ignore damage while invincible\n            return;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isInvincible && (collision.gameObject.CompareTag(\"Enemy\") || collision.gameObject.CompareTag(\"Projectile\")))\n        {\n            // Ignore damage while invincible\n            return;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "key that unlocks corresponding door",
      "ideal_ir": {
        "class_name": "Key",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "doorId",
            "type": "string",
            "default": "door1"
          },
          {
            "name": "isCollected",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "collect_key",
            "trigger": "when player touches this key",
            "actions": [
              {
                "action": "mark key as collected"
              },
              {
                "action": "add this key to player inventory"
              },
              {
                "action": "make key invisible"
              },
              {
                "action": "disable key collision"
              },
              {
                "action": "play key collection sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Key : MonoBehaviour\n{\n    [Header(\"Key Settings\")]\n    [SerializeField] private string _keyID = \"DefaultKey\";\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private GameObject _pickupEffect;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnKeyPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    void Update()\n    {\n        if (_isPickedUp) return;\n        \n        // Bobbing animation\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n        \n        // Rotation animation\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PickupKey(other.gameObject);\n        }\n    }\n    \n    private void PickupKey(GameObject player)\n    {\n        _isPickedUp = true;\n        \n        // Add key to player's inventory\n        PlayerKeyInventory inventory = player.GetComponent<PlayerKeyInventory>();\n        if (inventory == null)\n        {\n            inventory = player.AddComponent<PlayerKeyInventory>();\n        }\n        \n        inventory.AddKey(_keyID);\n        \n        // Play pickup sound\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn pickup effect\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        // Invoke event\n        OnKeyPickedUp?.Invoke(_keyID);\n        \n        // Destroy or hide the key\n        if (_destroyOnPickup)\n        {\n            if (_audioSource != null && _pickupSound != null)\n            {\n                Destroy(gameObject, _pickupSound.length);\n                GetComponent<Renderer>().enabled = false;\n                GetComponent<Collider>().enabled = false;\n            }\n            else\n            {\n                Destroy(gameObject);\n            }\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n\npublic class PlayerKeyInventory : MonoBehaviour\n{\n    private System.Collections.Generic.List<string> _keys = new System.Collections.Generic.List<string>();\n    \n    public void AddKey(string keyID)\n    {\n        if (!_keys.Contains(keyID))\n        {\n            _keys.Add(keyID);\n        }\n    }\n    \n    public bool HasKey(string keyID)\n    {\n        return _keys.Contains(keyID);\n    }\n    \n    public void RemoveKey(string keyID)\n    {\n        _keys.Remove(keyID);\n    }\n    \n    public System.Collections.Generic.List<string> GetAllKeys()\n    {\n        return new System.Collections.Generic.List<string>(_keys);\n    }\n}\n\npublic class Door : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private string _requiredKeyID = \"DefaultKey\";\n    [SerializeField] private bool _consumeKeyOnUse = true;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private Vector3 _openOffset = new Vector3(0, 3f, 0);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _unlockSound;\n    [SerializeField] private AudioClip _lockedSound;\n    [SerializeField] private AudioClip _openSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _lockedIndicator;\n    [SerializeField] private GameObject _unlockedIndicator;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDoorUnlocked;\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorLocked;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private AudioSource _audioSource;\n    \n    void Start()\n    {\n        _closedPosition = transform.position;\n        _openPosition = _closedPosition + _openOffset;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        UpdateVisualIndicators();\n    }\n    \n    void Update()\n    {\n        if (_isMoving)\n        {\n            Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n            transform.position = Vector3.MoveTowards(transform.position, targetPosition, _openSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(transform.position, targetPosition) < 0.01f)\n            {\n                transform.position = targetPosition;\n                _isMoving = false;\n                \n                if (_isOpen)\n                {\n                    OnDoorOpened?.Invoke();\n                }\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isMoving)\n        {\n            TryOpenDoor(other.gameObject);\n        }\n    }\n    \n    private void TryOpenDoor(GameObject player)\n    {\n        PlayerKeyInventory inventory = player.GetComponent<PlayerKeyInventory>();\n        \n        if (inventory != null && inventory.HasKey(_requiredKeyID))\n        {\n            UnlockAndOpenDoor(inventory);\n        }\n        else\n        {\n            PlayLockedFeedback();\n        }\n    }\n    \n    private void UnlockAndOpenDoor(PlayerKeyInventory inventory)\n    {\n        if (_consumeKeyOnUse)\n        {\n            inventory.RemoveKey(_requiredKeyID);\n        }\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        // Play unlock sound\n        if (_unlockSound != null)\n        {\n            _audioSource.PlayOneShot(_unlockSound);\n        }\n        \n        // Play open sound after a delay\n        if (_openSound != null)\n        {\n            Invoke(nameof(PlayOpenSound), 0.5f);\n        }\n        \n        UpdateVisualIndicators();\n        OnDoorUnlocked?.Invoke();\n    }\n    \n    private void PlayOpenSound()\n    {\n        if (_openSound != null)\n        {\n            _audioSource.PlayOneShot(_openSound);\n        }\n    }\n    \n    private void PlayLockedFeedback()\n    {\n        if (_lockedSound != null)\n        {\n            _audioSource.PlayOneShot(_lockedSound);\n        }\n        \n        OnDoorLocked?.Invoke();\n    }\n    \n    private void UpdateVisualIndicators()\n    {\n        if (_lockedIndicator != null)\n        {\n            _lockedIndicator.SetActive(!_isOpen);\n        }\n        \n        if (_unlockedIndicator != null)\n        {\n            _unlockedIndicator.SetActive(_isOpen);\n        }\n    }\n    \n    public void CloseDoor()\n    {\n        if (_isOpen && !_isMoving)\n        {\n            _isOpen = false;\n            _isMoving = true;\n        }\n    }\n    \n    public bool IsOpen()\n    {\n        return _isOpen;\n    }\n    \n    public string GetRequiredKeyID()\n    {\n        return _requiredKeyID;\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "gem that floats and sparkles",
      "ideal_ir": {
        "class_name": "FloatingGem",
        "components": [
          "Rigidbody",
          "Collider",
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "floatHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 30.0
          },
          {
            "name": "sparkleInterval",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "float_up_and_down",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "move up and down in a smooth sine wave pattern at float height and float speed"
              }
            ]
          },
          {
            "name": "rotate_continuously",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "rotate around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "emit_sparkles",
            "trigger": "every sparkle interval seconds",
            "actions": [
              {
                "action": "emit sparkle particles around the gem"
              },
              {
                "action": "play sparkle sound effect"
              }
            ]
          },
          {
            "name": "collect_gem",
            "trigger": "when player touches this gem",
            "actions": [
              {
                "action": "play collection sound effect"
              },
              {
                "action": "emit burst of sparkle particles"
              },
              {
                "action": "destroy this gem object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class FloatingGem : MonoBehaviour\n{\n    [Header(\"Floating Animation\")]\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private bool _randomizeStartPosition = true;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 90, 0);\n    \n    [Header(\"Sparkle Effects\")]\n    [SerializeField] private ParticleSystem _sparkleParticles;\n    [SerializeField] private Light _gemLight;\n    [SerializeField] private float _lightIntensityMin = 0.5f;\n    [SerializeField] private float _lightIntensityMax = 1.5f;\n    [SerializeField] private float _lightPulseSpeed = 3f;\n    \n    [Header(\"Collection\")]\n    [SerializeField] private bool _canBeCollected = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private GameObject _collectEffect;\n    \n    private Vector3 _startPosition;\n    private float _timeOffset;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private bool _isCollected = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_randomizeStartPosition)\n        {\n            _timeOffset = Random.Range(0f, Mathf.PI * 2f);\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_sparkleParticles == null)\n        {\n            _sparkleParticles = GetComponentInChildren<ParticleSystem>();\n        }\n        \n        if (_gemLight == null)\n        {\n            _gemLight = GetComponentInChildren<Light>();\n        }\n        \n        if (_sparkleParticles != null)\n        {\n            _sparkleParticles.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        AnimateFloating();\n        AnimateRotation();\n        AnimateLight();\n    }\n    \n    private void AnimateFloating()\n    {\n        float newY = _startPosition.y + Mathf.Sin((Time.time * _floatSpeed) + _timeOffset) * _floatAmplitude;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n    }\n    \n    private void AnimateRotation()\n    {\n        transform.Rotate(_rotationSpeed * Time.deltaTime);\n    }\n    \n    private void AnimateLight()\n    {\n        if (_gemLight != null)\n        {\n            float intensity = Mathf.Lerp(_lightIntensityMin, _lightIntensityMax, \n                (Mathf.Sin(Time.time * _lightPulseSpeed) + 1f) * 0.5f);\n            _gemLight.intensity = intensity;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canBeCollected || _isCollected) return;\n        \n        if (other.CompareTag(_playerTag))\n        {\n            CollectGem();\n        }\n    }\n    \n    private void CollectGem()\n    {\n        _isCollected = true;\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, transform.rotation);\n        }\n        \n        if (_sparkleParticles != null)\n        {\n            _sparkleParticles.Stop();\n        }\n        \n        StartCoroutine(DestroyAfterSound());\n    }\n    \n    private IEnumerator DestroyAfterSound()\n    {\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        GetComponent<Collider>().enabled = false;\n        \n        float waitTime = 0f;\n        if (_collectSound != null)\n        {\n            waitTime = _collectSound.length;\n        }\n        \n        yield return new WaitForSeconds(waitTime);\n        \n        Destroy(gameObject);\n    }\n    \n    public void SetFloatParameters(float amplitude, float speed)\n    {\n        _floatAmplitude = amplitude;\n        _floatSpeed = speed;\n    }\n    \n    public void SetRotationSpeed(Vector3 rotationSpeed)\n    {\n        _rotationSpeed = rotationSpeed;\n    }\n    \n    public void EnableCollection(bool enable)\n    {\n        _canBeCollected = enable;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fuel canister for vehicle refueling",
      "ideal_ir": {
        "class_name": "FuelCanister",
        "components": [
          "Collider",
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "fuelAmount",
            "type": "float",
            "default": 100
          },
          {
            "name": "refuelRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "isBeingUsed",
            "type": "bool",
            "default": false
          },
          {
            "name": "isEmpty",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_vehicle_proximity",
            "trigger": "when vehicle comes within interaction range",
            "actions": [
              {
                "action": "show refuel prompt to player"
              },
              {
                "action": "highlight canister with glow effect"
              }
            ]
          },
          {
            "name": "start_refueling",
            "trigger": "when player activates refuel action while near vehicle",
            "actions": [
              {
                "action": "set being used state to true"
              },
              {
                "action": "play fuel pouring sound effect"
              },
              {
                "action": "show refueling progress indicator"
              },
              {
                "action": "prevent canister from being moved"
              }
            ]
          },
          {
            "name": "transfer_fuel",
            "trigger": "while refueling is active and canister has fuel",
            "actions": [
              {
                "action": "decrease canister fuel amount over time"
              },
              {
                "action": "increase vehicle fuel amount at refuel rate"
              },
              {
                "action": "update progress bar display"
              }
            ]
          },
          {
            "name": "complete_refueling",
            "trigger": "when vehicle tank is full or canister becomes empty",
            "actions": [
              {
                "action": "stop fuel pouring sound"
              },
              {
                "action": "hide progress indicator"
              },
              {
                "action": "set being used state to false"
              },
              {
                "action": "show refuel complete message"
              }
            ]
          },
          {
            "name": "become_empty",
            "trigger": "when fuel amount reaches zero",
            "actions": [
              {
                "action": "set empty state to true"
              },
              {
                "action": "change canister appearance to empty version"
              },
              {
                "action": "disable refueling capability"
              },
              {
                "action": "play empty container sound"
              }
            ]
          },
          {
            "name": "cancel_refueling",
            "trigger": "when player moves away during refueling or presses cancel",
            "actions": [
              {
                "action": "stop fuel transfer immediately"
              },
              {
                "action": "hide progress indicator"
              },
              {
                "action": "set being used state to false"
              },
              {
                "action": "stop all refueling sounds"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FuelCanister : MonoBehaviour\n{\n    [Header(\"Fuel Settings\")]\n    [SerializeField] private float _fuelAmount = 50f;\n    [SerializeField] private float _refuelRate = 10f;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private bool _isConsumableOnUse = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _refuelSound;\n    [SerializeField] private AudioClip _emptySound;\n    [SerializeField] private AudioClip _pickupSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _fuelParticles;\n    [SerializeField] private Material _emptyMaterial;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _bobSpeed = 2f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Canvas _fuelAmountUI;\n    [SerializeField] private UnityEngine.UI.Text _fuelAmountText;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnFuelUsed;\n    public UnityEvent OnCanisterEmpty;\n    public UnityEvent OnCanisterPickedUp;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Vector3 _originalPosition;\n    private bool _isEmpty = false;\n    private bool _isRefueling = false;\n    private GameObject _currentVehicle;\n    private Collider _collider;\n    \n    [System.Serializable]\n    public class VehicleFuelSystem\n    {\n        public float currentFuel;\n        public float maxFuel;\n        public bool needsFuel;\n        \n        public VehicleFuelSystem(float maxFuelCapacity)\n        {\n            maxFuel = maxFuelCapacity;\n            currentFuel = 0f;\n            needsFuel = true;\n        }\n        \n        public float AddFuel(float amount)\n        {\n            float previousFuel = currentFuel;\n            currentFuel = Mathf.Clamp(currentFuel + amount, 0f, maxFuel);\n            needsFuel = currentFuel < maxFuel;\n            return currentFuel - previousFuel;\n        }\n        \n        public bool IsFull()\n        {\n            return currentFuel >= maxFuel;\n        }\n        \n        public float GetFuelPercentage()\n        {\n            return currentFuel / maxFuel;\n        }\n    }\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n            _originalMaterial = _renderer.material;\n            \n        _collider = GetComponent<Collider>();\n        _originalPosition = transform.position;\n        \n        UpdateUI();\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleBobAnimation();\n        HandlePlayerInteraction();\n        UpdateUI();\n    }\n    \n    private void HandleBobAnimation()\n    {\n        if (!_isEmpty)\n        {\n            float newY = _originalPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n            transform.position = new Vector3(_originalPosition.x, newY, _originalPosition.z);\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n        bool playerInRange = distanceToPlayer <= _interactionRange;\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(playerInRange && !_isEmpty);\n        \n        if (playerInRange && Input.GetKeyDown(KeyCode.E) && !_isEmpty)\n        {\n            PickupCanister();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            VehicleController vehicle = other.GetComponentInParent<VehicleController>();\n            if (vehicle == null)\n                vehicle = other.GetComponent<VehicleController>();\n                \n            if (vehicle != null)\n            {\n                _currentVehicle = vehicle.gameObject;\n            }\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (_isRefueling || _isEmpty) return;\n        \n        if (other.CompareTag(\"Player\") && Input.GetKey(KeyCode.F))\n        {\n            VehicleController vehicle = other.GetComponentInParent<VehicleController>();\n            if (vehicle == null)\n                vehicle = other.GetComponent<VehicleController>();\n                \n            if (vehicle != null)\n            {\n                RefuelVehicle(vehicle);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _currentVehicle = null;\n            _isRefueling = false;\n        }\n    }\n    \n    public void RefuelVehicle(VehicleController vehicle)\n    {\n        if (_isEmpty || _fuelAmount <= 0f) return;\n        \n        VehicleFuelSystem fuelSystem = vehicle.GetComponent<VehicleFuelSystem>();\n        if (fuelSystem == null)\n        {\n            fuelSystem = vehicle.gameObject.AddComponent<VehicleFuelSystem>();\n        }\n        \n        _isRefueling = true;\n        \n        float fuelToTransfer = Mathf.Min(_refuelRate * Time.deltaTime, _fuelAmount);\n        float actualFuelTransferred = fuelSystem.AddFuel(fuelToTransfer);\n        \n        _fuelAmount -= actualFuelTransferred;\n        OnFuelUsed?.Invoke(actualFuelTransferred);\n        \n        if (_fuelParticles != null && !_fuelParticles.activeInHierarchy)\n            _fuelParticles.SetActive(true);\n        \n        PlayRefuelSound();\n        \n        if (_fuelAmount <= 0f)\n        {\n            SetEmpty();\n        }\n        \n        if (fuelSystem.IsFull())\n        {\n            _isRefueling = false;\n            if (_fuelParticles != null)\n                _fuelParticles.SetActive(false);\n        }\n    }\n    \n    private void PlayRefuelSound()\n    {\n        if (_audioSource != null && _refuelSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.clip = _refuelSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetEmpty()\n    {\n        _isEmpty = true;\n        _isRefueling = false;\n        \n        if (_renderer != null && _emptyMaterial != null)\n            _renderer.material = _emptyMaterial;\n        \n        if (_fuelParticles != null)\n            _fuelParticles.SetActive(false);\n        \n        if (_audioSource != null && _emptySound != null)\n        {\n            _audioSource.clip = _emptySound;\n            _audioSource.Play();\n        }\n        \n        OnCanisterEmpty?.Invoke();\n        \n        if (_isConsumableOnUse)\n        {\n            Invoke(nameof(DestroyCanister), 2f);\n        }\n    }\n    \n    private void PickupCanister()\n    {\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.clip = _pickupSound;\n            _audioSource.Play();\n        }\n        \n        OnCanisterPickedUp?.Invoke();\n        \n        if (_collider != null)\n            _collider.enabled = false;\n        \n        gameObject.SetActive(false);\n    }\n    \n    private void UpdateUI()\n    {\n        if (_fuelAmountText != null)\n        {\n            _fuelAmountText.text = $\"Fuel: {_fuelAmount:F1}L\";\n        }\n        \n        if (_fuelAmountUI != null)\n        {\n            _fuelAmountUI.gameObject.SetActive(!_isEmpty);\n        }\n    }\n    \n    private void DestroyCanister()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetFuelAmount()\n    {\n        return _fuelAmount;\n    }\n    \n    public bool IsEmpty()\n    {\n        return _isEmpty;\n    }\n    \n    public void SetFuelAmount(float amount)\n    {\n        _fuelAmount = Mathf.Max(0f, amount);\n        _isEmpty = _fuelAmount <= 0f;\n        \n        if (_isEmpty)\n            SetEmpty();\n    }\n    \n    public void RefillCanister(float amount)\n    {\n        _fuelAmount += amount;\n        _isEmpty = false;\n        \n        if (_renderer != null && _originalMaterial != null)\n            _renderer.material = _originalMaterial;\n    }\n}\n\npublic class VehicleController : MonoBehaviour\n{\n    [Header(\"Vehicle Fuel\")]\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _currentFuel = 50f;\n    [SerializeField] private float _fuelConsumptionRate = 5f;\n    [SerializeField] private UnityEngine.UI.Slider _fuelGauge;\n    \n    private FuelCanister.VehicleFuelSystem _fuelSystem;\n    \n    private void Start()\n    {\n        _fuelSystem = new FuelCanister.VehicleFuelSystem(_maxFuel);\n        _fuelSystem.currentFuel = _currentFuel;\n    }\n    \n    private void Update()\n    {\n        ConsumeFuel();\n        UpdateFuelGauge();\n    }\n    \n    private void ConsumeFuel()\n    {\n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.S))\n        {\n            _fuelSystem.AddFuel(-_fuelConsumptionRate * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateFuelGauge()\n    {\n        if (_fuelGauge != null)\n        {\n            _fuelGauge.value = _fuelSystem.GetFuelPercentage();\n        }\n    }\n    \n    public FuelCanister.VehicleFuelSystem GetFuelSystem()\n    {\n        return _fuelSystem;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "experience orb that grants XP",
      "ideal_ir": {
        "class_name": "ExperienceOrb",
        "components": [
          "Rigidbody",
          "SphereCollider",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "experienceValue",
            "type": "int",
            "default": 10
          },
          {
            "name": "attractionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "bobSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "bobHeight",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "lifeTime",
            "type": "float",
            "default": 30.0
          }
        ],
        "behaviors": [
          {
            "name": "float_and_glow",
            "trigger": "when orb exists in the world",
            "actions": [
              {
                "action": "gently bob up and down at bob speed and height"
              },
              {
                "action": "emit soft glowing light with glow intensity"
              },
              {
                "action": "slowly rotate around vertical axis"
              }
            ]
          },
          {
            "name": "attract_to_player",
            "trigger": "when player enters attraction range",
            "actions": [
              {
                "action": "move toward player at move speed"
              },
              {
                "action": "increase glow intensity as getting closer to player"
              }
            ]
          },
          {
            "name": "grant_experience",
            "trigger": "when touching player",
            "actions": [
              {
                "action": "add experience value to player experience points"
              },
              {
                "action": "play collection sound effect"
              },
              {
                "action": "spawn particle effect at orb position"
              },
              {
                "action": "destroy this orb"
              }
            ]
          },
          {
            "name": "expire_over_time",
            "trigger": "when orb has existed for life time duration",
            "actions": [
              {
                "action": "fade out gradually over short duration"
              },
              {
                "action": "destroy this orb"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExperienceOrb : MonoBehaviour\n{\n    [Header(\"Experience Settings\")]\n    [SerializeField] private int _experienceValue = 10;\n    [SerializeField] private float _attractionRange = 5f;\n    [SerializeField] private float _attractionSpeed = 8f;\n    [SerializeField] private float _collectDistance = 0.5f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private AnimationCurve _attractionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectVolume = 0.7f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _lifeTime = 30f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnExperienceCollected;\n    \n    private Transform _player;\n    private Vector3 _startPosition;\n    private bool _isBeingAttracted = false;\n    private bool _isCollected = false;\n    private float _bobTimer = 0f;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _bobTimer = Random.Range(0f, Mathf.PI * 2f);\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        _rigidbody.useGravity = false;\n        _rigidbody.isKinematic = true;\n        \n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            SphereCollider sphereCollider = gameObject.AddComponent<SphereCollider>();\n            sphereCollider.isTrigger = true;\n            sphereCollider.radius = 0.5f;\n            _collider = sphereCollider;\n        }\n        _collider.isTrigger = true;\n        \n        if (_lifeTime > 0f)\n        {\n            Destroy(gameObject, _lifeTime);\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        if (_player == null)\n        {\n            FindPlayer();\n        }\n        \n        HandleMovement();\n        HandleVisualEffects();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attractionRange && !_isBeingAttracted)\n        {\n            _isBeingAttracted = true;\n        }\n        \n        if (_isBeingAttracted)\n        {\n            Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n            float attractionForce = _attractionCurve.Evaluate(1f - (distanceToPlayer / _attractionRange));\n            \n            transform.position = Vector3.MoveTowards(\n                transform.position,\n                _player.position,\n                _attractionSpeed * attractionForce * Time.deltaTime\n            );\n            \n            if (distanceToPlayer <= _collectDistance)\n            {\n                CollectOrb();\n            }\n        }\n        else\n        {\n            _bobTimer += Time.deltaTime * _bobSpeed;\n            Vector3 bobOffset = Vector3.up * Mathf.Sin(_bobTimer) * _bobHeight;\n            transform.position = _startPosition + bobOffset;\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectOrb();\n        }\n    }\n    \n    private void CollectOrb()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        \n        OnExperienceCollected?.Invoke(_experienceValue);\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.volume = _collectVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, Quaternion.identity);\n            \n            ParticleSystem particles = effect.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                Destroy(effect, particles.main.duration + particles.main.startLifetime.constantMax);\n            }\n            else\n            {\n                Destroy(effect, 2f);\n            }\n        }\n    }\n    \n    public void SetExperienceValue(int value)\n    {\n        _experienceValue = Mathf.Max(0, value);\n    }\n    \n    public int GetExperienceValue()\n    {\n        return _experienceValue;\n    }\n    \n    public void SetAttractionRange(float range)\n    {\n        _attractionRange = Mathf.Max(0f, range);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attractionRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _collectDistance);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "shield pickup that adds armor",
      "ideal_ir": {
        "class_name": "ShieldPickup",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "armorAmount",
            "type": "int",
            "default": 25
          },
          {
            "name": "pickupSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "pickupEffect",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "pickup_shield",
            "trigger": "when player touches this shield pickup",
            "actions": [
              {
                "action": "add armor amount to player's current armor"
              },
              {
                "action": "play pickup sound effect"
              },
              {
                "action": "spawn pickup visual effect at current position"
              },
              {
                "action": "destroy this shield pickup object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ShieldPickup : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private int _armorAmount = 25;\n    [SerializeField] private int _maxArmor = 100;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent<int> _onArmorAdded;\n    \n    private AudioSource _audioSource;\n    private Vector3 _startPosition;\n    private bool _isPickedUp = false;\n    \n    [System.Serializable]\n    public class PlayerArmor\n    {\n        public int currentArmor;\n        public int maxArmor;\n        \n        public PlayerArmor(int maxArmor)\n        {\n            this.maxArmor = maxArmor;\n            this.currentArmor = 0;\n        }\n        \n        public int AddArmor(int amount)\n        {\n            int oldArmor = currentArmor;\n            currentArmor = Mathf.Clamp(currentArmor + amount, 0, maxArmor);\n            return currentArmor - oldArmor;\n        }\n    }\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    void Update()\n    {\n        if (_isPickedUp) return;\n        \n        AnimatePickup();\n    }\n    \n    void AnimatePickup()\n    {\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PlayerArmor playerArmor = other.GetComponent<PlayerArmor>();\n            if (playerArmor == null)\n            {\n                playerArmor = other.gameObject.AddComponent<PlayerArmorComponent>().armor;\n            }\n            \n            int armorAdded = playerArmor.AddArmor(_armorAmount);\n            \n            if (armorAdded > 0)\n            {\n                PickupShield(armorAdded);\n            }\n        }\n    }\n    \n    void PickupShield(int armorAdded)\n    {\n        _isPickedUp = true;\n        \n        if (_pickupEffect != null)\n        {\n            _pickupEffect.Play();\n        }\n        \n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        _onArmorAdded?.Invoke(armorAdded);\n        \n        GetComponent<Collider>().enabled = false;\n        GetComponent<Renderer>().enabled = false;\n        \n        Destroy(gameObject, _pickupSound != null ? _pickupSound.length : 0.1f);\n    }\n    \n    public class PlayerArmorComponent : MonoBehaviour\n    {\n        public PlayerArmor armor;\n        \n        void Awake()\n        {\n            armor = new PlayerArmor(100);\n        }\n        \n        public int GetCurrentArmor()\n        {\n            return armor.currentArmor;\n        }\n        \n        public int GetMaxArmor()\n        {\n            return armor.maxArmor;\n        }\n        \n        public void TakeDamage(int damage)\n        {\n            armor.currentArmor = Mathf.Max(0, armor.currentArmor - damage);\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "speed boost pickup that increases movement",
      "ideal_ir": {
        "class_name": "SpeedBoostPickup",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "speedMultiplier",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "boostDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isCollected",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "collect_pickup",
            "trigger": "when player touches this pickup",
            "actions": [
              {
                "action": "mark pickup as collected"
              },
              {
                "action": "increase player movement speed by speed multiplier"
              },
              {
                "action": "start boost duration timer"
              },
              {
                "action": "hide pickup visual"
              },
              {
                "action": "play pickup sound effect"
              }
            ]
          },
          {
            "name": "end_speed_boost",
            "trigger": "when boost duration timer expires",
            "actions": [
              {
                "action": "restore player movement speed to normal"
              },
              {
                "action": "destroy pickup object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpeedBoostPickup : MonoBehaviour\n{\n    [Header(\"Speed Boost Settings\")]\n    [SerializeField] private float _speedMultiplier = 2f;\n    [SerializeField] private float _boostDuration = 5f;\n    [SerializeField] private bool _stackable = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPickedUp) return;\n        \n        // Rotate the pickup\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        // Bob up and down\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpeedBoost(other.gameObject);\n            PickupItem();\n        }\n    }\n    \n    private void ApplySpeedBoost(GameObject player)\n    {\n        SpeedBoostEffect boostEffect = player.GetComponent<SpeedBoostEffect>();\n        \n        if (boostEffect == null)\n        {\n            boostEffect = player.AddComponent<SpeedBoostEffect>();\n        }\n        \n        boostEffect.ApplySpeedBoost(_speedMultiplier, _boostDuration, _stackable);\n    }\n    \n    private void PickupItem()\n    {\n        _isPickedUp = true;\n        \n        // Play pickup sound\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn pickup effect\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        // Invoke event\n        OnPickedUp?.Invoke();\n        \n        // Hide visual components\n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null) renderer.enabled = false;\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null) collider.enabled = false;\n        \n        // Destroy after sound finishes\n        float destroyDelay = _pickupSound != null ? _pickupSound.length : 0.1f;\n        Destroy(gameObject, destroyDelay);\n    }\n}\n\npublic class SpeedBoostEffect : MonoBehaviour\n{\n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _originalSpeed;\n    private float _currentMultiplier = 1f;\n    private float _boostEndTime;\n    private bool _hasActiveBoost = false;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        // Store original speed from a basic movement script if it exists\n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            _originalSpeed = movement.moveSpeed;\n        }\n        else\n        {\n            _originalSpeed = 5f; // Default fallback speed\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasActiveBoost && Time.time >= _boostEndTime)\n        {\n            RemoveSpeedBoost();\n        }\n    }\n    \n    public void ApplySpeedBoost(float multiplier, float duration, bool stackable)\n    {\n        if (stackable)\n        {\n            _currentMultiplier *= multiplier;\n        }\n        else\n        {\n            _currentMultiplier = Mathf.Max(_currentMultiplier, multiplier);\n        }\n        \n        _boostEndTime = Time.time + duration;\n        _hasActiveBoost = true;\n        \n        UpdateMovementSpeed();\n    }\n    \n    private void UpdateMovementSpeed()\n    {\n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            movement.moveSpeed = _originalSpeed * _currentMultiplier;\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        _currentMultiplier = 1f;\n        _hasActiveBoost = false;\n        \n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            movement.moveSpeed = _originalSpeed;\n        }\n    }\n}\n\npublic class BasicMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    public float moveSpeed = 5f;\n    public float jumpForce = 8f;\n    \n    private CharacterController _controller;\n    private Rigidbody _rigidbody;\n    private Vector3 _velocity;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _controller = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n    }\n    \n    private void Update()\n    {\n        if (_controller != null)\n        {\n            HandleCharacterControllerMovement();\n        }\n        else if (_rigidbody != null)\n        {\n            HandleRigidbodyMovement();\n        }\n    }\n    \n    private void HandleCharacterControllerMovement()\n    {\n        _isGrounded = _controller.isGrounded;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _controller.Move(moveDirection * moveSpeed * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _velocity.y = Mathf.Sqrt(jumpForce * -2f * Physics.gravity.y);\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        _controller.Move(_velocity * Time.deltaTime);\n    }\n    \n    private void HandleRigidbodyMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _rigidbody.MovePosition(transform.position + moveDirection * moveSpeed * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            _rigidbody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "enemy that patrols between waypoints",
      "ideal_ir": {
        "class_name": "PatrollingEnemy",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "waypoints",
            "type": "Transform[]",
            "default": null
          },
          {
            "name": "patrolSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "waitTime",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "currentWaypointIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "isWaiting",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_patrol",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "set current waypoint to first waypoint in array"
              },
              {
                "action": "begin moving toward current waypoint"
              }
            ]
          },
          {
            "name": "move_to_waypoint",
            "trigger": "when not waiting and waypoints exist",
            "actions": [
              {
                "action": "move toward current waypoint at patrol speed"
              },
              {
                "action": "face direction of movement"
              }
            ]
          },
          {
            "name": "reach_waypoint",
            "trigger": "when arriving at current waypoint",
            "actions": [
              {
                "action": "stop moving"
              },
              {
                "action": "start waiting for specified wait time"
              },
              {
                "action": "increment waypoint index to next waypoint"
              },
              {
                "action": "wrap waypoint index to beginning if at end of array"
              }
            ]
          },
          {
            "name": "resume_patrol",
            "trigger": "when wait time has elapsed",
            "actions": [
              {
                "action": "stop waiting"
              },
              {
                "action": "resume moving toward new current waypoint"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class EnemyPatrol : MonoBehaviour\n{\n    [Header(\"Patrol Settings\")]\n    [SerializeField] private Transform[] _waypoints;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _waitTime = 2f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _loopPatrol = true;\n    [SerializeField] private bool _reverseOnEnd = true;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnPlayerLost;\n    public UnityEvent OnWaypointReached;\n    \n    private int _currentWaypointIndex = 0;\n    private bool _isWaiting = false;\n    private bool _isReversing = false;\n    private float _waitTimer = 0f;\n    private Vector3 _startPosition;\n    private bool _playerDetected = false;\n    private Transform _detectedPlayer;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_waypoints == null || _waypoints.Length == 0)\n        {\n            Debug.LogWarning($\"EnemyPatrol on {gameObject.name} has no waypoints assigned!\");\n            enabled = false;\n            return;\n        }\n        \n        ValidateWaypoints();\n        \n        if (_waypoints.Length > 0)\n        {\n            transform.position = _waypoints[0].position;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_waypoints == null || _waypoints.Length == 0) return;\n        \n        CheckForPlayer();\n        \n        if (!_playerDetected)\n        {\n            HandlePatrol();\n        }\n    }\n    \n    private void HandlePatrol()\n    {\n        if (_isWaiting)\n        {\n            _waitTimer += Time.deltaTime;\n            if (_waitTimer >= _waitTime)\n            {\n                _isWaiting = false;\n                _waitTimer = 0f;\n                MoveToNextWaypoint();\n            }\n            return;\n        }\n        \n        Transform targetWaypoint = _waypoints[_currentWaypointIndex];\n        if (targetWaypoint == null) return;\n        \n        Vector3 targetPosition = targetWaypoint.position;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n        \n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _moveSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.1f)\n        {\n            OnWaypointReached?.Invoke();\n            \n            if (_waitTime > 0f)\n            {\n                _isWaiting = true;\n            }\n            else\n            {\n                MoveToNextWaypoint();\n            }\n        }\n    }\n    \n    private void MoveToNextWaypoint()\n    {\n        if (_waypoints.Length <= 1) return;\n        \n        if (_loopPatrol)\n        {\n            _currentWaypointIndex = (_currentWaypointIndex + 1) % _waypoints.Length;\n        }\n        else if (_reverseOnEnd)\n        {\n            if (!_isReversing)\n            {\n                _currentWaypointIndex++;\n                if (_currentWaypointIndex >= _waypoints.Length)\n                {\n                    _currentWaypointIndex = _waypoints.Length - 2;\n                    _isReversing = true;\n                }\n            }\n            else\n            {\n                _currentWaypointIndex--;\n                if (_currentWaypointIndex < 0)\n                {\n                    _currentWaypointIndex = 1;\n                    _isReversing = false;\n                }\n            }\n        }\n        else\n        {\n            _currentWaypointIndex++;\n            if (_currentWaypointIndex >= _waypoints.Length)\n            {\n                _currentWaypointIndex = _waypoints.Length - 1;\n            }\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        bool playerFound = false;\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(_playerTag))\n            {\n                if (!_playerDetected)\n                {\n                    _playerDetected = true;\n                    _detectedPlayer = col.transform;\n                    OnPlayerDetected?.Invoke();\n                }\n                playerFound = true;\n                break;\n            }\n        }\n        \n        if (!playerFound && _playerDetected)\n        {\n            _playerDetected = false;\n            _detectedPlayer = null;\n            OnPlayerLost?.Invoke();\n        }\n    }\n    \n    private void ValidateWaypoints()\n    {\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            if (_waypoints[i] == null)\n            {\n                Debug.LogWarning($\"EnemyPatrol on {gameObject.name} has null waypoint at index {i}\");\n            }\n        }\n    }\n    \n    public void SetWaypoints(Transform[] newWaypoints)\n    {\n        _waypoints = newWaypoints;\n        _currentWaypointIndex = 0;\n        _isReversing = false;\n        ValidateWaypoints();\n    }\n    \n    public void AddWaypoint(Transform waypoint)\n    {\n        if (waypoint == null) return;\n        \n        Transform[] newWaypoints = new Transform[_waypoints.Length + 1];\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            newWaypoints[i] = _waypoints[i];\n        }\n        newWaypoints[_waypoints.Length] = waypoint;\n        _waypoints = newWaypoints;\n    }\n    \n    public void PausePatrol()\n    {\n        enabled = false;\n    }\n    \n    public void ResumePatrol()\n    {\n        enabled = true;\n    }\n    \n    public void ResetToStart()\n    {\n        _currentWaypointIndex = 0;\n        _isReversing = false;\n        _isWaiting = false;\n        _waitTimer = 0f;\n        _playerDetected = false;\n        _detectedPlayer = null;\n        \n        if (_waypoints != null && _waypoints.Length > 0 && _waypoints[0] != null)\n        {\n            transform.position = _waypoints[0].position;\n        }\n        else\n        {\n            transform.position = _startPosition;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_waypoints == null || _waypoints.Length == 0) return;\n        \n        Gizmos.color = Color.blue;\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            if (_waypoints[i] == null) continue;\n            \n            Gizmos.DrawWireSphere(_waypoints[i].position, 0.5f);\n            \n            if (i < _waypoints.Length - 1 && _waypoints[i + 1] != null)\n            {\n                Gizmos.DrawLine(_waypoints[i].position, _waypoints[i + 1].position);\n            }\n            else if (_loopPatrol && i == _waypoints.Length - 1 && _waypoints[0] != null)\n            {\n                Gizmos.DrawLine(_waypoints[i].position, _waypoints[0].position);\n            }\n        }\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_waypoints.Length > 0 && _waypoints[_currentWaypointIndex] != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_waypoints[_currentWaypointIndex].position, 0.7f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "turret that tracks and shoots at player",
      "ideal_ir": {
        "class_name": "PlayerTrackingTurret",
        "components": [
          "Transform",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "shootCooldown",
            "type": "float",
            "default": 1
          },
          {
            "name": "bulletPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "firePoint",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "track_player",
            "trigger": "when player is within detection range",
            "actions": [
              {
                "action": "rotate turret to face player position smoothly"
              }
            ]
          },
          {
            "name": "shoot_at_player",
            "trigger": "when player is within detection range and turret is facing player and shoot cooldown has elapsed",
            "actions": [
              {
                "action": "instantiate bullet at fire point"
              },
              {
                "action": "launch bullet toward player position"
              },
              {
                "action": "reset shoot cooldown timer"
              }
            ]
          },
          {
            "name": "stop_tracking",
            "trigger": "when player moves outside detection range",
            "actions": [
              {
                "action": "stop rotating turret"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class PlayerTrackingTurret : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _fieldOfView = 90f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private Transform _turretHead;\n    [SerializeField] private float _rotationSpeed = 2f;\n    [SerializeField] private bool _smoothRotation = true;\n    \n    [Header(\"Shooting\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 20f;\n    [SerializeField] private float _projectileLifetime = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    \n    private Transform _player;\n    private float _nextFireTime;\n    private bool _playerInRange;\n    private bool _hasLineOfSight;\n    \n    private void Start()\n    {\n        if (_turretHead == null)\n            _turretHead = transform;\n            \n        if (_firePoint == null)\n            _firePoint = _turretHead;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        FindPlayer();\n        \n        if (_player != null)\n        {\n            CheckPlayerInRange();\n            CheckLineOfSight();\n            \n            if (_playerInRange && _hasLineOfSight)\n            {\n                RotateTowardsPlayer();\n                TryShoot();\n            }\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_player == null)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n                _player = playerObject.transform;\n        }\n    }\n    \n    private void CheckPlayerInRange()\n    {\n        if (_player == null)\n        {\n            _playerInRange = false;\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _playerInRange = distanceToPlayer <= _detectionRange;\n        \n        if (_playerInRange)\n        {\n            Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n            float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer);\n            _playerInRange = angleToPlayer <= _fieldOfView * 0.5f;\n        }\n    }\n    \n    private void CheckLineOfSight()\n    {\n        if (!_playerInRange || _player == null)\n        {\n            _hasLineOfSight = false;\n            return;\n        }\n        \n        Vector3 directionToPlayer = (_player.position - _firePoint.position).normalized;\n        float distanceToPlayer = Vector3.Distance(_firePoint.position, _player.position);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(_firePoint.position, directionToPlayer, out hit, distanceToPlayer, _obstacleLayerMask))\n        {\n            _hasLineOfSight = hit.collider.CompareTag(\"Player\");\n        }\n        else\n        {\n            _hasLineOfSight = true;\n        }\n    }\n    \n    private void RotateTowardsPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 targetDirection = (_player.position - _turretHead.position).normalized;\n        targetDirection.y = 0f;\n        \n        Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n        \n        if (_smoothRotation)\n        {\n            _turretHead.rotation = Quaternion.Slerp(_turretHead.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n        else\n        {\n            _turretHead.rotation = targetRotation;\n        }\n    }\n    \n    private void TryShoot()\n    {\n        if (Time.time >= _nextFireTime && _projectilePrefab != null)\n        {\n            Shoot();\n            _nextFireTime = Time.time + (1f / _fireRate);\n        }\n    }\n    \n    private void Shoot()\n    {\n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb != null)\n        {\n            Vector3 shootDirection = _firePoint.forward;\n            if (_player != null)\n            {\n                shootDirection = (_player.position - _firePoint.position).normalized;\n            }\n            \n            projectileRb.velocity = shootDirection * _projectileSpeed;\n        }\n        \n        TurretProjectile projectileScript = projectile.GetComponent<TurretProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<TurretProjectile>();\n        }\n        projectileScript.Initialize(_projectileLifetime);\n        \n        if (_audioSource != null && _shootSound != null)\n        {\n            _audioSource.PlayOneShot(_shootSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Vector3 leftBoundary = Quaternion.Euler(0, -_fieldOfView * 0.5f, 0) * transform.forward * _detectionRange;\n        Vector3 rightBoundary = Quaternion.Euler(0, _fieldOfView * 0.5f, 0) * transform.forward * _detectionRange;\n        \n        Gizmos.DrawLine(transform.position, transform.position + leftBoundary);\n        Gizmos.DrawLine(transform.position, transform.position + rightBoundary);\n        \n        if (_hasLineOfSight && _player != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(_firePoint.position, _player.position);\n        }\n    }\n}\n\npublic class TurretProjectile : MonoBehaviour\n{\n    private float _lifetime;\n    private float _spawnTime;\n    \n    public void Initialize(float lifetime)\n    {\n        _lifetime = lifetime;\n        _spawnTime = Time.time;\n    }\n    \n    private void Update()\n    {\n        if (Time.time - _spawnTime >= _lifetime)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Destroy(gameObject);\n        }\n        else if (!other.isTrigger)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        Destroy(gameObject);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "enemy that chases player when spotted",
      "ideal_ir": {
        "class_name": "ChasingEnemy",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "chaseSpeed",
            "type": "float",
            "default": 5
          },
          {
            "name": "isChasing",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "set chasing state to true"
              },
              {
                "action": "face toward player direction"
              }
            ]
          },
          {
            "name": "chase_player",
            "trigger": "while chasing state is active and player is visible",
            "actions": [
              {
                "action": "move toward player at chase speed"
              },
              {
                "action": "maintain facing direction toward player"
              }
            ]
          },
          {
            "name": "stop_chasing",
            "trigger": "when player exits detection range or becomes hidden",
            "actions": [
              {
                "action": "set chasing state to false"
              },
              {
                "action": "stop movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class EnemyChaser : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _fieldOfViewAngle = 60f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    [SerializeField] private LayerMask _playerLayerMask = 1 << 6;\n    \n    [Header(\"Chase Settings\")]\n    [SerializeField] private float _chaseSpeed = 5f;\n    [SerializeField] private float _patrolSpeed = 2f;\n    [SerializeField] private float _loseTargetTime = 5f;\n    [SerializeField] private float _attackRange = 2f;\n    \n    [Header(\"Patrol Settings\")]\n    [SerializeField] private Transform[] _patrolPoints;\n    [SerializeField] private float _waitTimeAtPatrol = 2f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _detectionColor = Color.red;\n    [SerializeField] private Color _patrolColor = Color.green;\n    [SerializeField] private bool _showDebugGizmos = true;\n    \n    private NavMeshAgent _navAgent;\n    private Transform _player;\n    private EnemyState _currentState;\n    private float _lastSeenTime;\n    private Vector3 _lastKnownPlayerPosition;\n    private int _currentPatrolIndex;\n    private float _patrolWaitTimer;\n    private bool _isWaitingAtPatrol;\n    \n    private enum EnemyState\n    {\n        Patrolling,\n        Chasing,\n        Searching,\n        Attacking\n    }\n    \n    void Start()\n    {\n        _navAgent = GetComponent<NavMeshAgent>();\n        if (_navAgent == null)\n        {\n            Debug.LogError(\"NavMeshAgent component required on \" + gameObject.name);\n            enabled = false;\n            return;\n        }\n        \n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n        \n        _currentState = EnemyState.Patrolling;\n        _navAgent.speed = _patrolSpeed;\n        \n        if (_patrolPoints.Length > 0)\n        {\n            SetDestinationToPatrolPoint();\n        }\n    }\n    \n    void Update()\n    {\n        if (_player == null) return;\n        \n        switch (_currentState)\n        {\n            case EnemyState.Patrolling:\n                HandlePatrolling();\n                break;\n            case EnemyState.Chasing:\n                HandleChasing();\n                break;\n            case EnemyState.Searching:\n                HandleSearching();\n                break;\n            case EnemyState.Attacking:\n                HandleAttacking();\n                break;\n        }\n        \n        CheckForPlayer();\n    }\n    \n    void HandlePatrolling()\n    {\n        if (_patrolPoints.Length == 0) return;\n        \n        if (!_navAgent.pathPending && _navAgent.remainingDistance < 0.5f)\n        {\n            if (!_isWaitingAtPatrol)\n            {\n                _isWaitingAtPatrol = true;\n                _patrolWaitTimer = _waitTimeAtPatrol;\n            }\n            else\n            {\n                _patrolWaitTimer -= Time.deltaTime;\n                if (_patrolWaitTimer <= 0f)\n                {\n                    _isWaitingAtPatrol = false;\n                    _currentPatrolIndex = (_currentPatrolIndex + 1) % _patrolPoints.Length;\n                    SetDestinationToPatrolPoint();\n                }\n            }\n        }\n    }\n    \n    void HandleChasing()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attackRange)\n        {\n            _currentState = EnemyState.Attacking;\n            _navAgent.isStopped = true;\n            return;\n        }\n        \n        if (CanSeePlayer())\n        {\n            _lastSeenTime = Time.time;\n            _lastKnownPlayerPosition = _player.position;\n            _navAgent.SetDestination(_player.position);\n        }\n        else if (Time.time - _lastSeenTime > _loseTargetTime)\n        {\n            _currentState = EnemyState.Searching;\n            _navAgent.SetDestination(_lastKnownPlayerPosition);\n        }\n    }\n    \n    void HandleSearching()\n    {\n        if (!_navAgent.pathPending && _navAgent.remainingDistance < 0.5f)\n        {\n            _currentState = EnemyState.Patrolling;\n            _navAgent.speed = _patrolSpeed;\n            SetDestinationToPatrolPoint();\n        }\n    }\n    \n    void HandleAttacking()\n    {\n        if (_player == null) return;\n        \n        Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n        transform.rotation = Quaternion.LookRotation(new Vector3(directionToPlayer.x, 0, directionToPlayer.z));\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer > _attackRange)\n        {\n            _currentState = EnemyState.Chasing;\n            _navAgent.isStopped = false;\n            _navAgent.speed = _chaseSpeed;\n        }\n    }\n    \n    void CheckForPlayer()\n    {\n        if (_player == null || _currentState == EnemyState.Attacking) return;\n        \n        if (CanSeePlayer() && _currentState != EnemyState.Chasing)\n        {\n            _currentState = EnemyState.Chasing;\n            _navAgent.speed = _chaseSpeed;\n            _navAgent.isStopped = false;\n            _lastSeenTime = Time.time;\n        }\n    }\n    \n    bool CanSeePlayer()\n    {\n        if (_player == null) return false;\n        \n        Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer > _detectionRange) return false;\n        \n        float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer);\n        if (angleToPlayer > _fieldOfViewAngle / 2f) return false;\n        \n        Vector3 rayOrigin = transform.position + Vector3.up * 1.5f;\n        Vector3 rayTarget = _player.position + Vector3.up * 1f;\n        \n        if (Physics.Raycast(rayOrigin, (rayTarget - rayOrigin).normalized, out RaycastHit hit, distanceToPlayer, _obstacleLayerMask))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    void SetDestinationToPatrolPoint()\n    {\n        if (_patrolPoints.Length == 0) return;\n        \n        _navAgent.SetDestination(_patrolPoints[_currentPatrolIndex].position);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (!_showDebugGizmos) return;\n        \n        Gizmos.color = _currentState == EnemyState.Chasing ? _detectionColor : _patrolColor;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Vector3 leftBoundary = Quaternion.Euler(0, -_fieldOfViewAngle / 2f, 0) * transform.forward * _detectionRange;\n        Vector3 rightBoundary = Quaternion.Euler(0, _fieldOfViewAngle / 2f, 0) * transform.forward * _detectionRange;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, leftBoundary);\n        Gizmos.DrawRay(transform.position, rightBoundary);\n        \n        if (_patrolPoints != null)\n        {\n            Gizmos.color = Color.cyan;\n            for (int i = 0; i < _patrolPoints.Length; i++)\n            {\n                if (_patrolPoints[i] != null)\n                {\n                    Gizmos.DrawWireSphere(_patrolPoints[i].position, 0.5f);\n                    if (i < _patrolPoints.Length - 1 && _patrolPoints[i + 1] != null)\n                    {\n                        Gizmos.DrawLine(_patrolPoints[i].position, _patrolPoints[i + 1].position);\n                    }\n                    else if (i == _patrolPoints.Length - 1 && _patrolPoints[0] != null)\n                    {\n                        Gizmos.DrawLine(_patrolPoints[i].position, _patrolPoints[0].position);\n                    }\n                }\n            }\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "boss with multiple attack phases",
      "ideal_ir": {
        "class_name": "MultiphaseBoss",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 1000
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 1000
          },
          {
            "name": "currentPhase",
            "type": "int",
            "default": 1
          },
          {
            "name": "phaseTransitionThreshold",
            "type": "float",
            "default": 0.33
          },
          {
            "name": "attackDamage",
            "type": "float",
            "default": 50
          },
          {
            "name": "attackRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "chargeSpeed",
            "type": "float",
            "default": 20
          },
          {
            "name": "projectileSpeed",
            "type": "float",
            "default": 10
          },
          {
            "name": "isAttacking",
            "type": "bool",
            "default": false
          },
          {
            "name": "attackCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "lastAttackTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "enrageMultiplier",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "phase_one_combat",
            "trigger": "when in phase one and player is within attack range",
            "actions": [
              {
                "action": "perform basic melee attacks"
              },
              {
                "action": "move slowly toward player"
              },
              {
                "action": "play phase one combat animations"
              }
            ]
          },
          {
            "name": "phase_transition_to_two",
            "trigger": "when health drops below sixty six percent",
            "actions": [
              {
                "action": "change current phase to two"
              },
              {
                "action": "play phase transition animation"
              },
              {
                "action": "become temporarily invulnerable"
              },
              {
                "action": "emit screen shake effect"
              },
              {
                "action": "spawn protective barrier around self"
              }
            ]
          },
          {
            "name": "phase_two_combat",
            "trigger": "when in phase two and player is within attack range",
            "actions": [
              {
                "action": "perform charging attacks at increased speed"
              },
              {
                "action": "launch projectile attacks in multiple directions"
              },
              {
                "action": "create area of effect damage zones"
              },
              {
                "action": "move more aggressively toward player"
              }
            ]
          },
          {
            "name": "phase_transition_to_three",
            "trigger": "when health drops below thirty three percent",
            "actions": [
              {
                "action": "change current phase to three"
              },
              {
                "action": "play enrage animation sequence"
              },
              {
                "action": "increase all attack damage by enrage multiplier"
              },
              {
                "action": "reduce attack cooldown times"
              },
              {
                "action": "change visual appearance to show rage state"
              }
            ]
          },
          {
            "name": "phase_three_combat",
            "trigger": "when in phase three and player is within attack range",
            "actions": [
              {
                "action": "perform devastating combo attacks"
              },
              {
                "action": "launch rapid fire projectile barrages"
              },
              {
                "action": "create multiple simultaneous area attacks"
              },
              {
                "action": "teleport around battlefield unpredictably"
              },
              {
                "action": "summon additional enemy minions"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when hit by player attack",
            "actions": [
              {
                "action": "reduce current health by damage amount"
              },
              {
                "action": "play damage reaction animation"
              },
              {
                "action": "emit damage particle effects"
              },
              {
                "action": "play hurt sound effect"
              }
            ]
          },
          {
            "name": "death_sequence",
            "trigger": "when current health reaches zero",
            "actions": [
              {
                "action": "play dramatic death animation"
              },
              {
                "action": "emit explosion particle effects"
              },
              {
                "action": "drop valuable loot items"
              },
              {
                "action": "trigger victory music"
              },
              {
                "action": "destroy self after animation completes"
              }
            ]
          },
          {
            "name": "attack_cooldown_management",
            "trigger": "when attack finishes executing",
            "actions": [
              {
                "action": "set is attacking to false"
              },
              {
                "action": "record current time as last attack time"
              },
              {
                "action": "wait for cooldown period before next attack"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class BossController : MonoBehaviour\n{\n    [System.Serializable]\n    public class BossPhase\n    {\n        [Header(\"Phase Settings\")]\n        public string phaseName = \"Phase\";\n        public float healthThreshold = 100f;\n        public float moveSpeed = 3f;\n        public float attackCooldown = 2f;\n        public Color phaseColor = Color.white;\n        \n        [Header(\"Attack Pattern\")]\n        public AttackType[] attackPattern;\n        public float attackDamage = 10f;\n        public float attackRange = 5f;\n    }\n    \n    [System.Serializable]\n    public enum AttackType\n    {\n        MeleeSlash,\n        RangedProjectile,\n        AreaSlam,\n        ChargeAttack,\n        SpinAttack\n    }\n    \n    [Header(\"Boss Stats\")]\n    [SerializeField] private float _maxHealth = 300f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private bool _isInvulnerable = false;\n    \n    [Header(\"Boss Phases\")]\n    [SerializeField] private BossPhase[] _phases;\n    [SerializeField] private int _currentPhaseIndex = 0;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private Transform _player;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Attack Settings\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private LayerMask _damageLayer = 1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Renderer _bossRenderer;\n    [SerializeField] private ParticleSystem _phaseTransitionEffect;\n    [SerializeField] private ParticleSystem _attackEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _phaseTransitionSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBossDefeated;\n    public UnityEvent<int> OnPhaseChanged;\n    public UnityEvent<float> OnHealthChanged;\n    \n    private Rigidbody _rigidbody;\n    private bool _isAttacking = false;\n    private bool _isDead = false;\n    private float _lastAttackTime;\n    private int _currentAttackIndex = 0;\n    private Coroutine _currentAttackCoroutine;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_bossRenderer == null)\n            _bossRenderer = GetComponent<Renderer>();\n    }\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        InitializePhases();\n        FindPlayer();\n        \n        if (_phases.Length > 0)\n        {\n            ApplyPhaseSettings(_phases[0]);\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _detectionRange)\n        {\n            if (!_isAttacking)\n            {\n                MoveTowardsPlayer();\n                TryAttack();\n            }\n        }\n    }\n    \n    private void InitializePhases()\n    {\n        if (_phases == null || _phases.Length == 0)\n        {\n            _phases = new BossPhase[3];\n            \n            _phases[0] = new BossPhase\n            {\n                phaseName = \"Phase 1\",\n                healthThreshold = _maxHealth * 0.66f,\n                moveSpeed = 2f,\n                attackCooldown = 3f,\n                phaseColor = Color.green,\n                attackPattern = new AttackType[] { AttackType.MeleeSlash, AttackType.RangedProjectile },\n                attackDamage = 15f,\n                attackRange = 3f\n            };\n            \n            _phases[1] = new BossPhase\n            {\n                phaseName = \"Phase 2\",\n                healthThreshold = _maxHealth * 0.33f,\n                moveSpeed = 3f,\n                attackCooldown = 2f,\n                phaseColor = Color.yellow,\n                attackPattern = new AttackType[] { AttackType.AreaSlam, AttackType.ChargeAttack, AttackType.RangedProjectile },\n                attackDamage = 20f,\n                attackRange = 4f\n            };\n            \n            _phases[2] = new BossPhase\n            {\n                phaseName = \"Phase 3\",\n                healthThreshold = 0f,\n                moveSpeed = 4f,\n                attackCooldown = 1.5f,\n                phaseColor = Color.red,\n                attackPattern = new AttackType[] { AttackType.SpinAttack, AttackType.ChargeAttack, AttackType.AreaSlam, AttackType.RangedProjectile },\n                attackDamage = 25f,\n                attackRange = 5f\n            };\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_player == null || _currentPhaseIndex >= _phases.Length) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        float moveSpeed = _phases[_currentPhaseIndex].moveSpeed;\n        _rigidbody.MovePosition(transform.position + direction * moveSpeed * Time.deltaTime);\n        \n        transform.LookAt(new Vector3(_player.position.x, transform.position.y, _player.position.z));\n    }\n    \n    private void TryAttack()\n    {\n        if (_currentPhaseIndex >= _phases.Length) return;\n        \n        BossPhase currentPhase = _phases[_currentPhaseIndex];\n        \n        if (Time.time - _lastAttackTime >= currentPhase.attackCooldown)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            \n            if (distanceToPlayer <= currentPhase.attackRange)\n            {\n                PerformAttack();\n            }\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (_currentPhaseIndex >= _phases.Length) return;\n        \n        BossPhase currentPhase = _phases[_currentPhaseIndex];\n        \n        if (currentPhase.attackPattern.Length == 0) return;\n        \n        AttackType attackType = currentPhase.attackPattern[_currentAttackIndex];\n        _currentAttackIndex = (_currentAttackIndex + 1) % currentPhase.attackPattern.Length;\n        \n        _lastAttackTime = Time.time;\n        \n        if (_currentAttackCoroutine != null)\n        {\n            StopCoroutine(_currentAttackCoroutine);\n        }\n        \n        _currentAttackCoroutine = StartCoroutine(ExecuteAttack(attackType, currentPhase));\n    }\n    \n    private IEnumerator ExecuteAttack(AttackType attackType, BossPhase phase)\n    {\n        _isAttacking = true;\n        \n        PlayAttackSound();\n        PlayAttackEffect();\n        \n        switch (attackType)\n        {\n            case AttackType.MeleeSlash:\n                yield return StartCoroutine(MeleeSlashAttack(phase));\n                break;\n            case AttackType.RangedProjectile:\n                yield return StartCoroutine(RangedProjectileAttack(phase));\n                break;\n            case AttackType.AreaSlam:\n                yield return StartCoroutine(AreaSlamAttack(phase));\n                break;\n            case AttackType.ChargeAttack:\n                yield return StartCoroutine(ChargeAttack(phase));\n                break;\n            case AttackType.SpinAttack:\n                yield return StartCoroutine(SpinAttack(phase));\n                break;\n        }\n        \n        _isAttacking = false;\n    }\n    \n    private IEnumerator MeleeSlashAttack(BossPhase phase)\n    {\n        yield return new WaitForSeconds(0.5f);\n        \n        Collider[] hitColliders = Physics.OverlapSphere(_attackPoint.position, phase.attackRange, _damageLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DamagePlayer(hit.gameObject, phase.attackDamage);\n            }\n        }\n    }\n    \n    private IEnumerator RangedProjectileAttack(BossPhase phase)\n    {\n        if (_projectilePrefab != null && _player != null)\n        {\n            Vector3 direction = (_player.position - _attackPoint.position).normalized;\n            \n            GameObject projectile = Instantiate(_projectilePrefab, _attackPoint.position, Quaternion.LookRotation(direction));\n            Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n            \n            if (projectileRb == null)\n                projectileRb = projectile.AddComponent<Rigidbody>();\n                \n            projectileRb.velocity = direction * _projectileSpeed;\n            \n            ProjectileDamage projectileDamage = projectile.GetComponent<ProjectileDamage>();\n            if (projectileDamage == null)\n                projectileDamage = projectile.AddComponent<ProjectileDamage>();\n                \n            projectileDamage.damage = phase.attackDamage;\n            \n            Destroy(projectile, 5f);\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n    }\n    \n    private IEnumerator AreaSlamAttack(BossPhase phase)\n    {\n        yield return new WaitForSeconds(1f);\n        \n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, phase.attackRange * 1.5f, _damageLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DamagePlayer(hit.gameObject, phase.attackDamage * 1.2f);\n            }\n        }\n    }\n    \n    private IEnumerator ChargeAttack(BossPhase phase)\n    {\n        if (_player == null) yield break;\n        \n        Vector3 chargeDirection = (_player.position - transform.position).normalized;\n        chargeDirection.y = 0;\n        \n        float chargeDistance = 8f;\n        float chargeSpeed = phase.moveSpeed * 3f;\n        \n        Vector3 startPosition = transform.position;\n        Vector3 targetPosition = startPosition + chargeDirection * chargeDistance;\n        \n        float chargeTime = chargeDistance / chargeSpeed;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < chargeTime)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / chargeTime;\n            \n            Vector3 currentPosition = Vector3.Lerp(startPosition, targetPosition, progress);\n            _rigidbody.MovePosition(currentPosition);\n            \n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, 1.5f, _damageLayer);\n            foreach (Collider hit in hitColliders)\n            {\n                if (hit.CompareTag(\"Player\"))\n                {\n                    DamagePlayer(hit.gameObject, phase.attackDamage * 1.5f);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        yield return new WaitForSeconds(0.5f);\n    }\n    \n    private IEnumerator SpinAttack(BossPhase phase)\n    {\n        float spinDuration = 2f;\n        float spinSpeed = 720f;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < spinDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            transform.Rotate(0, spinSpeed * Time.deltaTime, 0);\n            \n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, phase.attackRange, _damageLayer);\n            foreach (Collider hit in hitColliders)\n            {\n                if (hit.CompareTag(\"Player\"))\n                {\n                    DamagePlayer(hit.gameObject, phase.attackDamage * 0.5f);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void DamagePlayer(GameObject player, float damage)\n    {\n        // Send damage message to player\n        player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead || _isInvulnerable) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        CheckPhaseTransition();\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void CheckPhaseTransition()\n    {\n        if (_currentPhaseIndex >= _phases.Length - 1) return;\n        \n        BossPhase nextPhase = _phases[_currentPhaseIndex + 1];\n        \n        if (_currentHealth <= nextPhase.healthThreshold)\n        {\n            TransitionToNextPhase();\n        }\n    }\n    \n    private void TransitionToNextPhase()\n    {\n        _currentPhaseIndex++;\n        \n        if (_currentPhaseIndex < _phases.Length)\n        {\n            ApplyPhaseSettings(_phases[_currentPhaseIndex]);\n            OnPhaseChanged?.Invoke(_currentPhaseIndex);\n            \n            PlayPhaseTransitionEffect();\n            PlayPhaseTransitionSound();\n            \n            _isInvulnerable = true;\n            StartCoroutine(InvulnerabilityPeriod(2f));\n        }\n    }\n    \n    private void ApplyPhaseSettings(BossPhase phase)\n    {\n        if (_bossRenderer != null)\n        {\n            _bossRenderer.material.color = phase.phaseColor;\n        }\n        \n        _currentAttackIndex = 0;\n    }\n    \n    private IEnumerator InvulnerabilityPeriod(float duration)\n    {\n        yield return new WaitForSeconds(duration);\n        _isInvulnerable = false;\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _isAttacking = false;",
      "behavior_type": "combat"
    },
    {
      "prompt": "flying enemy that circles overhead",
      "ideal_ir": {
        "class_name": "CirclingFlyingEnemy",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "circleRadius",
            "type": "float",
            "default": 10
          },
          {
            "name": "flyingHeight",
            "type": "float",
            "default": 8
          },
          {
            "name": "circlingSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "centerPoint",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "initialize_circle_center",
            "trigger": "when the game starts",
            "actions": [
              {
                "action": "set the center point to current position"
              },
              {
                "action": "move to flying height above center point"
              }
            ]
          },
          {
            "name": "circle_overhead",
            "trigger": "continuously during gameplay",
            "actions": [
              {
                "action": "move in circular pattern around center point"
              },
              {
                "action": "maintain constant flying height"
              },
              {
                "action": "rotate to face movement direction"
              }
            ]
          },
          {
            "name": "adjust_to_terrain",
            "trigger": "when flying over varying terrain heights",
            "actions": [
              {
                "action": "maintain consistent height above ground level"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FlyingEnemy : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _circleRadius = 10f;\n    [SerializeField] private float _circleSpeed = 2f;\n    [SerializeField] private float _hoverHeight = 8f;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Target Settings\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _followPlayer = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Vertical Movement\")]\n    [SerializeField] private float _bobAmount = 0.5f;\n    [SerializeField] private float _bobSpeed = 3f;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private bool _faceMovementDirection = true;\n    [SerializeField] private float _rotationSpeed = 5f;\n    \n    private Vector3 _centerPoint;\n    private float _currentAngle;\n    private float _bobTimer;\n    private Vector3 _lastPosition;\n    private GameObject _player;\n    \n    private void Start()\n    {\n        if (_followPlayer)\n        {\n            _player = GameObject.FindGameObjectWithTag(_playerTag);\n            if (_player != null)\n            {\n                _target = _player.transform;\n            }\n        }\n        \n        if (_target == null)\n        {\n            _centerPoint = transform.position;\n        }\n        else\n        {\n            _centerPoint = new Vector3(_target.position.x, _target.position.y + _hoverHeight, _target.position.z);\n        }\n        \n        _lastPosition = transform.position;\n        _currentAngle = Random.Range(0f, 360f);\n    }\n    \n    private void Update()\n    {\n        UpdateCenterPoint();\n        UpdateCircularMovement();\n        UpdateVerticalBobbing();\n        UpdateRotation();\n    }\n    \n    private void UpdateCenterPoint()\n    {\n        if (_target != null)\n        {\n            Vector3 targetCenter = new Vector3(_target.position.x, _target.position.y + _hoverHeight, _target.position.z);\n            _centerPoint = Vector3.Lerp(_centerPoint, targetCenter, Time.deltaTime * 2f);\n        }\n    }\n    \n    private void UpdateCircularMovement()\n    {\n        float angleIncrement = _circleSpeed * Time.deltaTime;\n        if (!_clockwise)\n        {\n            angleIncrement = -angleIncrement;\n        }\n        \n        _currentAngle += angleIncrement;\n        if (_currentAngle >= 360f)\n        {\n            _currentAngle -= 360f;\n        }\n        else if (_currentAngle < 0f)\n        {\n            _currentAngle += 360f;\n        }\n        \n        float radians = _currentAngle * Mathf.Deg2Rad;\n        Vector3 circlePosition = new Vector3(\n            _centerPoint.x + Mathf.Cos(radians) * _circleRadius,\n            _centerPoint.y,\n            _centerPoint.z + Mathf.Sin(radians) * _circleRadius\n        );\n        \n        transform.position = circlePosition;\n    }\n    \n    private void UpdateVerticalBobbing()\n    {\n        _bobTimer += Time.deltaTime * _bobSpeed;\n        float bobOffset = Mathf.Sin(_bobTimer) * _bobAmount;\n        \n        Vector3 currentPos = transform.position;\n        currentPos.y += bobOffset;\n        transform.position = currentPos;\n    }\n    \n    private void UpdateRotation()\n    {\n        if (_faceMovementDirection)\n        {\n            Vector3 movementDirection = transform.position - _lastPosition;\n            if (movementDirection.magnitude > 0.01f)\n            {\n                Quaternion targetRotation = Quaternion.LookRotation(movementDirection);\n                transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n        }\n        \n        _lastPosition = transform.position;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_playerTag))\n        {\n            // Handle player collision\n            Debug.Log(\"Flying enemy detected player\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = Application.isPlaying ? _centerPoint : transform.position;\n        \n        // Draw circle path\n        for (int i = 0; i < 36; i++)\n        {\n            float angle1 = i * 10f * Mathf.Deg2Rad;\n            float angle2 = (i + 1) * 10f * Mathf.Deg2Rad;\n            \n            Vector3 point1 = new Vector3(\n                center.x + Mathf.Cos(angle1) * _circleRadius,\n                center.y,\n                center.z + Mathf.Sin(angle1) * _circleRadius\n            );\n            \n            Vector3 point2 = new Vector3(\n                center.x + Mathf.Cos(angle2) * _circleRadius,\n                center.y,\n                center.z + Mathf.Sin(angle2) * _circleRadius\n            );\n            \n            Gizmos.DrawLine(point1, point2);\n        }\n        \n        // Draw center point\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, 0.5f);\n        \n        // Draw hover height indicator\n        if (_target != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(_target.position, center);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "enemy that explodes on death",
      "ideal_ir": {
        "class_name": "ExplodingEnemy",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "explosionDamage",
            "type": "float",
            "default": 50
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 1000
          },
          {
            "name": "isDead",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when collision occurs with damage dealing object",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt sound effect"
              }
            ]
          },
          {
            "name": "death_explosion",
            "trigger": "when health reaches zero or below",
            "actions": [
              {
                "action": "set isDead to true"
              },
              {
                "action": "create explosion particle effect at current position"
              },
              {
                "action": "play explosion sound effect"
              },
              {
                "action": "find all objects within explosion radius"
              },
              {
                "action": "apply explosion damage to nearby enemies and player"
              },
              {
                "action": "apply explosive force to nearby rigidbodies"
              },
              {
                "action": "destroy this game object after short delay"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplodingEnemy : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    private float _currentHealth;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _explosionDamage = 50f;\n    [SerializeField] private LayerMask _explosionLayers = -1;\n    [SerializeField] private GameObject _explosionEffectPrefab;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _renderer;\n    [SerializeField] private Color _damageColor = Color.red;\n    [SerializeField] private float _damageFlashDuration = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnTakeDamage;\n    \n    private Color _originalColor;\n    private bool _isDead = false;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        \n        if (_renderer == null)\n            _renderer = GetComponent<Renderer>();\n            \n        if (_renderer != null)\n            _originalColor = _renderer.material.color;\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        OnTakeDamage?.Invoke();\n        \n        if (_renderer != null)\n            StartCoroutine(FlashDamage());\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashDamage()\n    {\n        if (_renderer != null)\n        {\n            _renderer.material.color = _damageColor;\n            yield return new WaitForSeconds(_damageFlashDuration);\n            _renderer.material.color = _originalColor;\n        }\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        OnDeath?.Invoke();\n        \n        Explode();\n        \n        Destroy(gameObject);\n    }\n    \n    private void Explode()\n    {\n        Vector3 explosionPosition = transform.position;\n        \n        // Create explosion effect\n        if (_explosionEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_explosionEffectPrefab, explosionPosition, Quaternion.identity);\n            Destroy(effect, 5f);\n        }\n        \n        // Play explosion sound\n        if (_explosionSound != null && _audioSource != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, explosionPosition);\n        }\n        \n        // Find all colliders in explosion radius\n        Collider[] colliders = Physics.OverlapSphere(explosionPosition, _explosionRadius, _explosionLayers);\n        \n        foreach (Collider hit in colliders)\n        {\n            if (hit.gameObject == gameObject) continue;\n            \n            // Apply explosion force\n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, explosionPosition, _explosionRadius);\n            }\n            \n            // Apply damage to other exploding enemies\n            ExplodingEnemy otherEnemy = hit.GetComponent<ExplodingEnemy>();\n            if (otherEnemy != null)\n            {\n                float distance = Vector3.Distance(explosionPosition, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                otherEnemy.TakeDamage(_explosionDamage * damageMultiplier);\n            }\n            \n            // Damage player\n            if (hit.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(explosionPosition, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                float finalDamage = _explosionDamage * damageMultiplier;\n                \n                // Send damage message if player has a method to receive it\n                hit.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            // Optional: Explode on contact with player\n            // Die();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Projectile\"))\n        {\n            TakeDamage(25f);\n            Destroy(collision.gameObject);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    public bool IsDead()\n    {\n        return _isDead;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "spawner that creates enemies periodically",
      "ideal_ir": {
        "class_name": "EnemySpawner",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "enemyPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "spawnInterval",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "maxEnemies",
            "type": "int",
            "default": 10
          },
          {
            "name": "spawnRadius",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "spawn_enemy_periodically",
            "trigger": "when spawn interval time has elapsed and current enemy count is below maximum",
            "actions": [
              {
                "action": "create new enemy instance from prefab"
              },
              {
                "action": "position enemy at random location within spawn radius around spawner"
              },
              {
                "action": "reset spawn timer"
              },
              {
                "action": "increment current enemy count"
              }
            ]
          },
          {
            "name": "track_enemy_destruction",
            "trigger": "when spawned enemy is destroyed",
            "actions": [
              {
                "action": "decrement current enemy count"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class EnemySpawner : MonoBehaviour\n{\n    [Header(\"Spawn Settings\")]\n    [SerializeField] private GameObject[] _enemyPrefabs;\n    [SerializeField] private Transform[] _spawnPoints;\n    [SerializeField] private float _spawnInterval = 2f;\n    [SerializeField] private int _maxEnemies = 10;\n    [SerializeField] private bool _spawnOnStart = true;\n    \n    [Header(\"Spawn Area (if no spawn points)\")]\n    [SerializeField] private float _spawnRadius = 5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Wave Settings\")]\n    [SerializeField] private bool _useWaves = false;\n    [SerializeField] private int _enemiesPerWave = 5;\n    [SerializeField] private float _timeBetweenWaves = 10f;\n    \n    private List<GameObject> _spawnedEnemies = new List<GameObject>();\n    private Coroutine _spawnCoroutine;\n    private int _currentWaveEnemies = 0;\n    private bool _isSpawning = false;\n    \n    private void Start()\n    {\n        if (_spawnOnStart)\n        {\n            StartSpawning();\n        }\n        \n        ValidateSpawnSettings();\n    }\n    \n    private void ValidateSpawnSettings()\n    {\n        if (_enemyPrefabs == null || _enemyPrefabs.Length == 0)\n        {\n            Debug.LogWarning(\"EnemySpawner: No enemy prefabs assigned!\");\n            return;\n        }\n        \n        if (_spawnPoints == null || _spawnPoints.Length == 0)\n        {\n            Debug.LogWarning(\"EnemySpawner: No spawn points assigned, using random positions around spawner.\");\n        }\n    }\n    \n    public void StartSpawning()\n    {\n        if (_isSpawning) return;\n        \n        _isSpawning = true;\n        \n        if (_useWaves)\n        {\n            _spawnCoroutine = StartCoroutine(SpawnWaves());\n        }\n        else\n        {\n            _spawnCoroutine = StartCoroutine(SpawnContinuous());\n        }\n    }\n    \n    public void StopSpawning()\n    {\n        _isSpawning = false;\n        \n        if (_spawnCoroutine != null)\n        {\n            StopCoroutine(_spawnCoroutine);\n            _spawnCoroutine = null;\n        }\n    }\n    \n    public void ClearAllEnemies()\n    {\n        for (int i = _spawnedEnemies.Count - 1; i >= 0; i--)\n        {\n            if (_spawnedEnemies[i] != null)\n            {\n                Destroy(_spawnedEnemies[i]);\n            }\n        }\n        _spawnedEnemies.Clear();\n    }\n    \n    private IEnumerator SpawnContinuous()\n    {\n        while (_isSpawning)\n        {\n            if (CanSpawn())\n            {\n                SpawnEnemy();\n            }\n            \n            yield return new WaitForSeconds(_spawnInterval);\n        }\n    }\n    \n    private IEnumerator SpawnWaves()\n    {\n        while (_isSpawning)\n        {\n            _currentWaveEnemies = 0;\n            \n            // Spawn wave\n            for (int i = 0; i < _enemiesPerWave; i++)\n            {\n                if (CanSpawn())\n                {\n                    SpawnEnemy();\n                    _currentWaveEnemies++;\n                    yield return new WaitForSeconds(_spawnInterval);\n                }\n            }\n            \n            // Wait for wave to be cleared or timeout\n            float waveTimer = 0f;\n            while (_currentWaveEnemies > 0 && waveTimer < _timeBetweenWaves)\n            {\n                CleanupDestroyedEnemies();\n                waveTimer += Time.deltaTime;\n                yield return null;\n            }\n            \n            yield return new WaitForSeconds(_timeBetweenWaves);\n        }\n    }\n    \n    private bool CanSpawn()\n    {\n        CleanupDestroyedEnemies();\n        return _spawnedEnemies.Count < _maxEnemies && _enemyPrefabs.Length > 0;\n    }\n    \n    private void SpawnEnemy()\n    {\n        GameObject enemyPrefab = _enemyPrefabs[Random.Range(0, _enemyPrefabs.Length)];\n        Vector3 spawnPosition = GetSpawnPosition();\n        \n        if (spawnPosition != Vector3.zero)\n        {\n            GameObject enemy = Instantiate(enemyPrefab, spawnPosition, GetSpawnRotation());\n            _spawnedEnemies.Add(enemy);\n            \n            // Add enemy tracker component\n            EnemyTracker tracker = enemy.GetComponent<EnemyTracker>();\n            if (tracker == null)\n            {\n                tracker = enemy.AddComponent<EnemyTracker>();\n            }\n            tracker.Initialize(this);\n        }\n    }\n    \n    private Vector3 GetSpawnPosition()\n    {\n        if (_spawnPoints != null && _spawnPoints.Length > 0)\n        {\n            Transform spawnPoint = _spawnPoints[Random.Range(0, _spawnPoints.Length)];\n            return spawnPoint != null ? spawnPoint.position : transform.position;\n        }\n        \n        // Random position around spawner\n        Vector2 randomCircle = Random.insideUnitCircle * _spawnRadius;\n        Vector3 randomPosition = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n        \n        // Try to place on ground\n        if (Physics.Raycast(randomPosition + Vector3.up * 10f, Vector3.down, out RaycastHit hit, 20f, _groundLayer))\n        {\n            return hit.point;\n        }\n        \n        return randomPosition;\n    }\n    \n    private Quaternion GetSpawnRotation()\n    {\n        return Quaternion.Euler(0, Random.Range(0, 360), 0);\n    }\n    \n    private void CleanupDestroyedEnemies()\n    {\n        for (int i = _spawnedEnemies.Count - 1; i >= 0; i--)\n        {\n            if (_spawnedEnemies[i] == null)\n            {\n                _spawnedEnemies.RemoveAt(i);\n                if (_useWaves)\n                {\n                    _currentWaveEnemies--;\n                }\n            }\n        }\n    }\n    \n    public void OnEnemyDestroyed(GameObject enemy)\n    {\n        if (_spawnedEnemies.Contains(enemy))\n        {\n            _spawnedEnemies.Remove(enemy);\n            if (_useWaves)\n            {\n                _currentWaveEnemies--;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw spawn radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _spawnRadius);\n        \n        // Draw spawn points\n        if (_spawnPoints != null)\n        {\n            Gizmos.color = Color.red;\n            foreach (Transform spawnPoint in _spawnPoints)\n            {\n                if (spawnPoint != null)\n                {\n                    Gizmos.DrawWireCube(spawnPoint.position, Vector3.one);\n                }\n            }\n        }\n    }\n}\n\npublic class EnemyTracker : MonoBehaviour\n{\n    private EnemySpawner _spawner;\n    \n    public void Initialize(EnemySpawner spawner)\n    {\n        _spawner = spawner;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_spawner != null)\n        {\n            _spawner.OnEnemyDestroyed(gameObject);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "enemy with ranged and melee attacks",
      "ideal_ir": {
        "class_name": "RangedMeleeEnemy",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "meleeRange",
            "type": "float",
            "default": 2
          },
          {
            "name": "rangedRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "meleeDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "rangedDamage",
            "type": "float",
            "default": 15
          },
          {
            "name": "meleeAttackCooldown",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "rangedAttackCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "projectilePrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "projectileSpawnPoint",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "start pursuing player"
              },
              {
                "action": "play alert animation"
              }
            ]
          },
          {
            "name": "pursue_player",
            "trigger": "when player is detected and not in attack range",
            "actions": [
              {
                "action": "move toward player at move speed"
              },
              {
                "action": "face toward player"
              },
              {
                "action": "play walking animation"
              }
            ]
          },
          {
            "name": "melee_attack",
            "trigger": "when player is within melee range and melee attack is ready",
            "actions": [
              {
                "action": "stop movement"
              },
              {
                "action": "play melee attack animation"
              },
              {
                "action": "deal melee damage to player"
              },
              {
                "action": "start melee attack cooldown"
              }
            ]
          },
          {
            "name": "ranged_attack",
            "trigger": "when player is within ranged range but outside melee range and ranged attack is ready",
            "actions": [
              {
                "action": "stop movement"
              },
              {
                "action": "face toward player"
              },
              {
                "action": "play ranged attack animation"
              },
              {
                "action": "spawn projectile at spawn point toward player"
              },
              {
                "action": "start ranged attack cooldown"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when receiving damage",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt animation"
              },
              {
                "action": "interrupt current attack if attacking"
              }
            ]
          },
          {
            "name": "die",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "play death animation"
              },
              {
                "action": "disable collider"
              },
              {
                "action": "destroy game object after animation completes"
              }
            ]
          },
          {
            "name": "lose_player",
            "trigger": "when player leaves detection range",
            "actions": [
              {
                "action": "stop pursuing player"
              },
              {
                "action": "return to idle state"
              },
              {
                "action": "play idle animation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Enemy : MonoBehaviour\n{\n    [Header(\"Health\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 180f;\n    \n    [Header(\"Combat Ranges\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _meleeRange = 2f;\n    [SerializeField] private float _rangedRange = 8f;\n    [SerializeField] private float _attackCooldown = 2f;\n    \n    [Header(\"Melee Attack\")]\n    [SerializeField] private float _meleeDamage = 25f;\n    [SerializeField] private float _meleeAttackDuration = 0.5f;\n    \n    [Header(\"Ranged Attack\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private float _rangedDamage = 15f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnMeleeAttack;\n    public UnityEvent OnRangedAttack;\n    \n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private float _lastAttackTime;\n    private bool _isAttacking;\n    private EnemyState _currentState;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        MeleeAttacking,\n        RangedAttacking,\n        Dead\n    }\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _currentState = EnemyState.Idle;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_firePoint == null)\n        {\n            GameObject firePointObj = new GameObject(\"FirePoint\");\n            firePointObj.transform.SetParent(transform);\n            firePointObj.transform.localPosition = Vector3.forward;\n            _firePoint = firePointObj.transform;\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_currentState == EnemyState.Dead) return;\n        \n        FindPlayer();\n        UpdateState();\n        HandleState();\n    }\n    \n    private void FindPlayer()\n    {\n        if (_player == null)\n        {\n            GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObj != null)\n            {\n                _player = playerObj.transform;\n            }\n        }\n    }\n    \n    private void UpdateState()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (_isAttacking) return;\n        \n        if (distanceToPlayer > _detectionRange)\n        {\n            _currentState = EnemyState.Idle;\n        }\n        else if (distanceToPlayer <= _meleeRange && CanAttack())\n        {\n            _currentState = EnemyState.MeleeAttacking;\n        }\n        else if (distanceToPlayer <= _rangedRange && distanceToPlayer > _meleeRange && CanAttack())\n        {\n            _currentState = EnemyState.RangedAttacking;\n        }\n        else if (distanceToPlayer <= _detectionRange)\n        {\n            _currentState = EnemyState.Chasing;\n        }\n    }\n    \n    private void HandleState()\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                break;\n                \n            case EnemyState.Chasing:\n                ChasePlayer();\n                break;\n                \n            case EnemyState.MeleeAttacking:\n                PerformMeleeAttack();\n                break;\n                \n            case EnemyState.RangedAttacking:\n                PerformRangedAttack();\n                break;\n        }\n    }\n    \n    private void ChasePlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.deltaTime);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void PerformMeleeAttack()\n    {\n        if (_isAttacking) return;\n        \n        StartCoroutine(MeleeAttackCoroutine());\n    }\n    \n    private System.Collections.IEnumerator MeleeAttackCoroutine()\n    {\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnMeleeAttack?.Invoke();\n        \n        yield return new WaitForSeconds(_meleeAttackDuration);\n        \n        if (_player != null && Vector3.Distance(transform.position, _player.position) <= _meleeRange)\n        {\n            DealDamageToPlayer(_meleeDamage);\n        }\n        \n        _isAttacking = false;\n    }\n    \n    private void PerformRangedAttack()\n    {\n        if (_isAttacking) return;\n        \n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnRangedAttack?.Invoke();\n        \n        FireProjectile();\n        \n        Invoke(nameof(ResetAttacking), 0.5f);\n    }\n    \n    private void FireProjectile()\n    {\n        if (_projectilePrefab == null || _player == null) return;\n        \n        Vector3 direction = (_player.position - _firePoint.position).normalized;\n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, Quaternion.LookRotation(direction));\n        \n        EnemyProjectile projectileScript = projectile.GetComponent<EnemyProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<EnemyProjectile>();\n        }\n        \n        projectileScript.Initialize(direction, _projectileSpeed, _rangedDamage);\n    }\n    \n    private void ResetAttacking()\n    {\n        _isAttacking = false;\n    }\n    \n    private bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    private void DealDamageToPlayer(float damage)\n    {\n        if (_player == null) return;\n        \n        _player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_currentState == EnemyState.Dead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _currentState = EnemyState.Dead;\n        OnDeath?.Invoke();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        Collider[] colliders = GetComponents<Collider>();\n        foreach (Collider col in colliders)\n        {\n            col.enabled = false;\n        }\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _rangedRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _meleeRange);\n    }\n}\n\npublic class EnemyProjectile : MonoBehaviour\n{\n    private Vector3 _direction;\n    private float _speed;\n    private float _damage;\n    private float _lifetime = 5f;\n    \n    public void Initialize(Vector3 direction, float speed, float damage)\n    {\n        _direction = direction;\n        _speed = speed;\n        _damage = damage;\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void Update()\n    {\n        transform.Translate(_direction * _speed * Time.deltaTime, Space.World);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            other.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            Destroy(gameObject);\n        }\n        else if (!other.isTrigger && !other.CompareTag(\"Enemy\"))\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            Destroy(gameObject);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "stealth enemy that ambushes player",
      "ideal_ir": {
        "class_name": "StealthEnemy",
        "components": [
          "Rigidbody",
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "ambushRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "ambushSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "hideTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isHidden",
            "type": "bool",
            "default": true
          },
          {
            "name": "isAmbushing",
            "type": "bool",
            "default": false
          },
          {
            "name": "playerTarget",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "start_hidden",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "make enemy invisible"
              },
              {
                "action": "set hidden state to true"
              },
              {
                "action": "find player object in scene"
              }
            ]
          },
          {
            "name": "detect_player",
            "trigger": "when player enters detection range and enemy is hidden",
            "actions": [
              {
                "action": "start tracking player position"
              },
              {
                "action": "begin moving stealthily toward player"
              }
            ]
          },
          {
            "name": "stealth_movement",
            "trigger": "when tracking player and not ambushing",
            "actions": [
              {
                "action": "move toward player at slow stealth speed"
              },
              {
                "action": "maintain invisibility"
              },
              {
                "action": "avoid making noise"
              }
            ]
          },
          {
            "name": "prepare_ambush",
            "trigger": "when player is within ambush range and enemy is hidden",
            "actions": [
              {
                "action": "stop moving"
              },
              {
                "action": "position behind or beside player"
              },
              {
                "action": "wait for optimal ambush moment"
              }
            ]
          },
          {
            "name": "execute_ambush",
            "trigger": "when ready to ambush and player is in range",
            "actions": [
              {
                "action": "become visible instantly"
              },
              {
                "action": "set ambushing state to true"
              },
              {
                "action": "rush toward player at high speed"
              },
              {
                "action": "play ambush sound effect"
              }
            ]
          },
          {
            "name": "attack_player",
            "trigger": "when ambushing and reaches player",
            "actions": [
              {
                "action": "deal damage to player"
              },
              {
                "action": "play attack animation"
              },
              {
                "action": "knock player backward"
              }
            ]
          },
          {
            "name": "retreat_after_ambush",
            "trigger": "when ambush attack is complete",
            "actions": [
              {
                "action": "move away from player quickly"
              },
              {
                "action": "become invisible after short delay"
              },
              {
                "action": "reset to hidden state"
              },
              {
                "action": "wait before next ambush opportunity"
              }
            ]
          },
          {
            "name": "lose_player",
            "trigger": "when player leaves detection range for extended time",
            "actions": [
              {
                "action": "stop tracking player"
              },
              {
                "action": "return to original hiding position"
              },
              {
                "action": "reset to patrol state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class StealthEnemy : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _ambushRadius = 3f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n    \n    [Header(\"Stealth Settings\")]\n    [SerializeField] private float _stealthDuration = 5f;\n    [SerializeField] private float _visibilityTransitionSpeed = 2f;\n    [SerializeField] private float _minAlpha = 0.1f;\n    [SerializeField] private float _maxAlpha = 1f;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _ambushSpeed = 8f;\n    [SerializeField] private float _retreatSpeed = 6f;\n    [SerializeField] private float _circleDistance = 8f;\n    \n    [Header(\"Attack Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _attackRange = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _ambushSound;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _retreatSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnPlayerAttacked;\n    public UnityEvent OnAmbushTriggered;\n    public UnityEvent OnStealthActivated;\n    \n    private enum EnemyState\n    {\n        Patrolling,\n        Stalking,\n        Ambushing,\n        Attacking,\n        Retreating,\n        Cooldown\n    }\n    \n    private EnemyState _currentState = EnemyState.Patrolling;\n    private Transform _player;\n    private Renderer _renderer;\n    private Material _material;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _lastKnownPlayerPosition;\n    private float _stealthTimer;\n    private float _attackTimer;\n    private float _currentAlpha;\n    private bool _playerInRange;\n    private bool _hasLineOfSight;\n    private float _circleAngle;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _material = new Material(_renderer.material);\n            _renderer.material = _material;\n            _currentAlpha = _maxAlpha;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.freezeRotation = true;\n        \n        _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n        \n        SetStealth(false);\n    }\n    \n    private void Update()\n    {\n        if (_player == null)\n        {\n            _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n            return;\n        }\n        \n        UpdatePlayerDetection();\n        UpdateState();\n        UpdateVisibility();\n        UpdateTimers();\n    }\n    \n    private void UpdatePlayerDetection()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _playerInRange = distanceToPlayer <= _detectionRadius;\n        \n        if (_playerInRange)\n        {\n            _hasLineOfSight = HasLineOfSight(_player.position);\n            if (_hasLineOfSight)\n            {\n                _lastKnownPlayerPosition = _player.position;\n            }\n        }\n        else\n        {\n            _hasLineOfSight = false;\n        }\n    }\n    \n    private void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Patrolling:\n                HandlePatrolling();\n                break;\n            case EnemyState.Stalking:\n                HandleStalking();\n                break;\n            case EnemyState.Ambushing:\n                HandleAmbushing();\n                break;\n            case EnemyState.Attacking:\n                HandleAttacking();\n                break;\n            case EnemyState.Retreating:\n                HandleRetreating();\n                break;\n            case EnemyState.Cooldown:\n                HandleCooldown();\n                break;\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        if (_playerInRange && _hasLineOfSight)\n        {\n            ChangeState(EnemyState.Stalking);\n            return;\n        }\n        \n        // Simple patrol around original position\n        Vector3 patrolTarget = _originalPosition + new Vector3(\n            Mathf.Sin(Time.time * 0.5f) * 3f,\n            0,\n            Mathf.Cos(Time.time * 0.5f) * 3f\n        );\n        \n        MoveTowards(patrolTarget, _moveSpeed * 0.5f);\n    }\n    \n    private void HandleStalking()\n    {\n        if (!_playerInRange)\n        {\n            ChangeState(EnemyState.Patrolling);\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _ambushRadius)\n        {\n            ChangeState(EnemyState.Ambushing);\n            return;\n        }\n        \n        // Circle around player while maintaining distance\n        _circleAngle += Time.deltaTime * 0.5f;\n        Vector3 circlePosition = _player.position + new Vector3(\n            Mathf.Sin(_circleAngle) * _circleDistance,\n            0,\n            Mathf.Cos(_circleAngle) * _circleDistance\n        );\n        \n        MoveTowards(circlePosition, _moveSpeed);\n        SetStealth(true);\n    }\n    \n    private void HandleAmbushing()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attackRange)\n        {\n            ChangeState(EnemyState.Attacking);\n            return;\n        }\n        \n        // Rush towards player\n        MoveTowards(_player.position, _ambushSpeed);\n        SetStealth(false);\n        \n        // Play ambush sound once\n        if (_audioSource != null && _ambushSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.PlayOneShot(_ambushSound);\n            OnAmbushTriggered?.Invoke();\n        }\n    }\n    \n    private void HandleAttacking()\n    {\n        if (_attackTimer <= 0f)\n        {\n            PerformAttack();\n            _attackTimer = _attackCooldown;\n            ChangeState(EnemyState.Retreating);\n        }\n    }\n    \n    private void HandleRetreating()\n    {\n        Vector3 retreatDirection = (transform.position - _player.position).normalized;\n        Vector3 retreatTarget = transform.position + retreatDirection * 5f;\n        \n        MoveTowards(retreatTarget, _retreatSpeed);\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer >= _detectionRadius * 0.8f)\n        {\n            ChangeState(EnemyState.Cooldown);\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_stealthTimer <= 0f)\n        {\n            ChangeState(EnemyState.Patrolling);\n        }\n    }\n    \n    private void ChangeState(EnemyState newState)\n    {\n        _currentState = newState;\n        \n        switch (newState)\n        {\n            case EnemyState.Stalking:\n                _stealthTimer = _stealthDuration;\n                OnStealthActivated?.Invoke();\n                break;\n            case EnemyState.Retreating:\n                if (_audioSource != null && _retreatSound != null)\n                {\n                    _audioSource.PlayOneShot(_retreatSound);\n                }\n                break;\n            case EnemyState.Cooldown:\n                _stealthTimer = _stealthDuration * 0.5f;\n                SetStealth(true);\n                break;\n        }\n    }\n    \n    private void MoveTowards(Vector3 target, float speed)\n    {\n        Vector3 direction = (target - transform.position).normalized;\n        direction.y = 0; // Keep movement on horizontal plane\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        }\n        else\n        {\n            transform.position += direction * speed * Time.deltaTime;\n        }\n        \n        // Face movement direction\n        if (direction != Vector3.zero)\n        {\n            transform.rotation = Quaternion.LookRotation(direction);\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            // Deal damage to player\n            var playerHealth = _player.GetComponent<MonoBehaviour>();\n            if (playerHealth != null)\n            {\n                OnPlayerAttacked?.Invoke(_attackDamage);\n            }\n            \n            if (_audioSource != null && _attackSound != null)\n            {\n                _audioSource.PlayOneShot(_attackSound);\n            }\n        }\n    }\n    \n    private void SetStealth(bool stealthed)\n    {\n        float targetAlpha = stealthed ? _minAlpha : _maxAlpha;\n        _currentAlpha = Mathf.MoveTowards(_currentAlpha, targetAlpha, _visibilityTransitionSpeed * Time.deltaTime);\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_material != null)\n        {\n            Color color = _material.color;\n            color.a = _currentAlpha;\n            _material.color = color;\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_stealthTimer > 0f)\n        {\n            _stealthTimer -= Time.deltaTime;\n        }\n        \n        if (_attackTimer > 0f)\n        {\n            _attackTimer -= Time.deltaTime;\n        }\n    }\n    \n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - transform.position;\n        float distance = direction.magnitude;\n        \n        if (Physics.Raycast(transform.position + Vector3.up * 0.5f, direction.normalized, out RaycastHit hit, distance, _obstacleLayer))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState == EnemyState.Ambushing)\n        {\n            ChangeState(EnemyState.Attacking);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Detection radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _detectionRadius);\n        \n        // Ambush radius\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCircle(transform.position, _ambushRadius);\n        \n        // Attack range\n        Gizmos.color = Color.magenta;\n        Gizmos.DrawWireCircle(transform.position, _attackRange);\n        \n        // Line of sight\n        if (_player != null && _hasLineOfSight)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position + Vector3.up * 0.5f, _player.position + Vector3.up * 0.5f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "minion that follows a leader",
      "ideal_ir": {
        "class_name": "MinionFollower",
        "components": [
          "Transform",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "leader",
            "type": "Transform",
            "default": null
          },
          {
            "name": "followDistance",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "stopDistance",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "follow_leader",
            "trigger": "when leader exists and distance to leader is greater than follow distance",
            "actions": [
              {
                "action": "move toward leader at move speed"
              }
            ]
          },
          {
            "name": "stop_following",
            "trigger": "when distance to leader is less than stop distance",
            "actions": [
              {
                "action": "stop moving"
              }
            ]
          },
          {
            "name": "face_leader",
            "trigger": "when leader exists and not moving",
            "actions": [
              {
                "action": "rotate to face leader"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class MinionFollower : MonoBehaviour\n{\n    [Header(\"Follow Settings\")]\n    [SerializeField] private Transform _leader;\n    [SerializeField] private float _followDistance = 3f;\n    [SerializeField] private float _stopDistance = 1.5f;\n    [SerializeField] private float _maxFollowDistance = 10f;\n    [SerializeField] private float _updateRate = 0.1f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3.5f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _useNavMesh = true;\n    \n    [Header(\"Behavior\")]\n    [SerializeField] private bool _teleportWhenTooFar = true;\n    [SerializeField] private float _teleportDistance = 20f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    \n    private NavMeshAgent _navAgent;\n    private Rigidbody _rigidbody;\n    private float _lastUpdateTime;\n    private Vector3 _targetPosition;\n    private bool _isFollowing;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        FindLeaderIfNull();\n        _targetPosition = transform.position;\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_useNavMesh)\n        {\n            _navAgent = GetComponent<NavMeshAgent>();\n            if (_navAgent != null)\n            {\n                _navAgent.speed = _moveSpeed;\n                _navAgent.stoppingDistance = _stopDistance;\n            }\n        }\n        else\n        {\n            _rigidbody = GetComponent<Rigidbody>();\n            if (_rigidbody == null)\n            {\n                _rigidbody = gameObject.AddComponent<Rigidbody>();\n                _rigidbody.freezeRotation = true;\n            }\n        }\n    }\n    \n    private void FindLeaderIfNull()\n    {\n        if (_leader == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n            {\n                _leader = player.transform;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (_leader == null) return;\n        \n        if (Time.time - _lastUpdateTime >= _updateRate)\n        {\n            UpdateFollowBehavior();\n            _lastUpdateTime = Time.time;\n        }\n        \n        if (!_useNavMesh && _isFollowing)\n        {\n            MoveWithoutNavMesh();\n        }\n        \n        RotateTowardsMovementDirection();\n    }\n    \n    private void UpdateFollowBehavior()\n    {\n        float distanceToLeader = Vector3.Distance(transform.position, _leader.position);\n        \n        if (_teleportWhenTooFar && distanceToLeader > _teleportDistance)\n        {\n            TeleportToLeader();\n            return;\n        }\n        \n        if (distanceToLeader > _followDistance)\n        {\n            Vector3 directionToLeader = (_leader.position - transform.position).normalized;\n            _targetPosition = _leader.position - directionToLeader * _followDistance;\n            \n            if (HasClearPath(_targetPosition))\n            {\n                StartFollowing();\n            }\n        }\n        else if (distanceToLeader <= _stopDistance)\n        {\n            StopFollowing();\n        }\n    }\n    \n    private void StartFollowing()\n    {\n        _isFollowing = true;\n        \n        if (_useNavMesh && _navAgent != null)\n        {\n            _navAgent.SetDestination(_targetPosition);\n        }\n    }\n    \n    private void StopFollowing()\n    {\n        _isFollowing = false;\n        \n        if (_useNavMesh && _navAgent != null)\n        {\n            _navAgent.ResetPath();\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n        }\n    }\n    \n    private void MoveWithoutNavMesh()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        float distanceToTarget = Vector3.Distance(transform.position, _targetPosition);\n        \n        if (distanceToTarget > _stopDistance)\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.velocity = direction * _moveSpeed;\n            }\n            else\n            {\n                transform.position += direction * _moveSpeed * Time.deltaTime;\n            }\n        }\n        else\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.velocity = Vector3.zero;\n            }\n        }\n    }\n    \n    private void RotateTowardsMovementDirection()\n    {\n        Vector3 movementDirection = Vector3.zero;\n        \n        if (_useNavMesh && _navAgent != null && _navAgent.hasPath)\n        {\n            movementDirection = _navAgent.velocity.normalized;\n        }\n        else if (_rigidbody != null)\n        {\n            movementDirection = _rigidbody.velocity.normalized;\n        }\n        else if (_isFollowing)\n        {\n            movementDirection = (_targetPosition - transform.position).normalized;\n        }\n        \n        if (movementDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(movementDirection);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private bool HasClearPath(Vector3 targetPos)\n    {\n        Vector3 direction = (targetPos - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetPos);\n        \n        return !Physics.Raycast(transform.position, direction, distance, _obstacleLayerMask);\n    }\n    \n    private void TeleportToLeader()\n    {\n        Vector3 teleportPosition = _leader.position + Random.insideUnitSphere * 2f;\n        teleportPosition.y = _leader.position.y;\n        \n        if (Physics.CheckSphere(teleportPosition, 0.5f, _obstacleLayerMask))\n        {\n            teleportPosition = _leader.position;\n        }\n        \n        transform.position = teleportPosition;\n        StopFollowing();\n    }\n    \n    public void SetLeader(Transform newLeader)\n    {\n        _leader = newLeader;\n    }\n    \n    public void SetFollowDistance(float distance)\n    {\n        _followDistance = Mathf.Max(0f, distance);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_leader == null) return;\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(_leader.position, _followDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_leader.position, _stopDistance);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_leader.position, _teleportDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(transform.position, _targetPosition);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "enemy that retreats when health is low",
      "ideal_ir": {
        "class_name": "RetreatingEnemy",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "lowHealthThreshold",
            "type": "float",
            "default": 25
          },
          {
            "name": "retreatSpeed",
            "type": "float",
            "default": 8
          },
          {
            "name": "normalSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "isRetreating",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when receiving damage",
            "actions": [
              {
                "action": "reduce current health by damage amount"
              },
              {
                "action": "clamp current health to minimum of zero"
              }
            ]
          },
          {
            "name": "check_retreat_condition",
            "trigger": "when current health drops below low health threshold",
            "actions": [
              {
                "action": "set retreating state to true"
              }
            ]
          },
          {
            "name": "retreat_behavior",
            "trigger": "when retreating state is true",
            "actions": [
              {
                "action": "move away from player at retreat speed"
              },
              {
                "action": "face away from player direction"
              }
            ]
          },
          {
            "name": "normal_behavior",
            "trigger": "when retreating state is false and player is within detection range",
            "actions": [
              {
                "action": "move toward player at normal speed"
              },
              {
                "action": "face toward player direction"
              }
            ]
          },
          {
            "name": "stop_retreat",
            "trigger": "when retreating and current health is restored above low health threshold",
            "actions": [
              {
                "action": "set retreating state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class EnemyRetreat : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _retreatHealthThreshold = 30f;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _normalSpeed = 3.5f;\n    [SerializeField] private float _retreatSpeed = 6f;\n    [SerializeField] private float _retreatDistance = 15f;\n    [SerializeField] private float _stopRetreatDistance = 20f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Renderer _enemyRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _retreatColor = Color.yellow;\n    \n    private float _currentHealth;\n    private bool _isRetreating = false;\n    private Transform _player;\n    private NavMeshAgent _navAgent;\n    private Vector3 _retreatTarget;\n    private Material _enemyMaterial;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        Retreating\n    }\n    \n    private EnemyState _currentState = EnemyState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _navAgent = GetComponent<NavMeshAgent>();\n        \n        if (_navAgent == null)\n        {\n            Debug.LogError(\"NavMeshAgent component required on \" + gameObject.name);\n            enabled = false;\n            return;\n        }\n        \n        _navAgent.speed = _normalSpeed;\n        \n        if (_enemyRenderer != null)\n        {\n            _enemyMaterial = _enemyRenderer.material;\n            _enemyMaterial.color = _normalColor;\n        }\n        \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        UpdateState(distanceToPlayer);\n        HandleMovement(distanceToPlayer);\n        UpdateVisuals();\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateState(float distanceToPlayer)\n    {\n        if (_currentHealth <= _retreatHealthThreshold)\n        {\n            if (!_isRetreating)\n            {\n                StartRetreat();\n            }\n            \n            if (distanceToPlayer >= _stopRetreatDistance)\n            {\n                _currentState = EnemyState.Idle;\n            }\n            else\n            {\n                _currentState = EnemyState.Retreating;\n            }\n        }\n        else\n        {\n            _isRetreating = false;\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                _currentState = EnemyState.Chasing;\n            }\n            else\n            {\n                _currentState = EnemyState.Idle;\n            }\n        }\n    }\n    \n    void HandleMovement(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                _navAgent.SetDestination(transform.position);\n                _navAgent.speed = _normalSpeed;\n                break;\n                \n            case EnemyState.Chasing:\n                _navAgent.SetDestination(_player.position);\n                _navAgent.speed = _normalSpeed;\n                break;\n                \n            case EnemyState.Retreating:\n                if (Vector3.Distance(transform.position, _retreatTarget) < 2f || !_navAgent.hasPath)\n                {\n                    CalculateRetreatTarget();\n                }\n                _navAgent.SetDestination(_retreatTarget);\n                _navAgent.speed = _retreatSpeed;\n                break;\n        }\n    }\n    \n    void StartRetreat()\n    {\n        _isRetreating = true;\n        CalculateRetreatTarget();\n    }\n    \n    void CalculateRetreatTarget()\n    {\n        Vector3 directionAwayFromPlayer = (transform.position - _player.position).normalized;\n        Vector3 potentialTarget = transform.position + directionAwayFromPlayer * _retreatDistance;\n        \n        NavMeshHit hit;\n        if (NavMesh.SamplePosition(potentialTarget, out hit, _retreatDistance, NavMesh.AllAreas))\n        {\n            _retreatTarget = hit.position;\n        }\n        else\n        {\n            Vector3[] alternativeDirections = {\n                Quaternion.Euler(0, 45, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, -45, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, 90, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, -90, 0) * directionAwayFromPlayer\n            };\n            \n            foreach (Vector3 direction in alternativeDirections)\n            {\n                Vector3 testTarget = transform.position + direction * _retreatDistance;\n                if (NavMesh.SamplePosition(testTarget, out hit, _retreatDistance, NavMesh.AllAreas))\n                {\n                    _retreatTarget = hit.position;\n                    return;\n                }\n            }\n            \n            _retreatTarget = transform.position;\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_enemyMaterial != null)\n        {\n            Color targetColor = _isRetreating ? _retreatColor : _normalColor;\n            _enemyMaterial.color = Color.Lerp(_enemyMaterial.color, targetColor, Time.deltaTime * 3f);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _player = other.transform;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _retreatDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _stopRetreatDistance);\n        \n        if (_isRetreating && Application.isPlaying)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _retreatTarget);\n            Gizmos.DrawWireSphere(_retreatTarget, 1f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "homing missile that tracks target",
      "ideal_ir": {
        "class_name": "HomingMissile",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "target",
            "type": "Transform",
            "default": null
          },
          {
            "name": "speed",
            "type": "float",
            "default": 15
          },
          {
            "name": "turnRate",
            "type": "float",
            "default": 5
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 3
          },
          {
            "name": "damage",
            "type": "float",
            "default": 50
          },
          {
            "name": "lifetime",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "track_target",
            "trigger": "every frame while target exists",
            "actions": [
              {
                "action": "calculate direction toward target"
              },
              {
                "action": "rotate toward target at turn rate"
              },
              {
                "action": "move forward at speed"
              }
            ]
          },
          {
            "name": "explode_on_contact",
            "trigger": "when colliding with any object",
            "actions": [
              {
                "action": "deal damage to all objects within explosion radius"
              },
              {
                "action": "create explosion effect"
              },
              {
                "action": "destroy missile"
              }
            ]
          },
          {
            "name": "explode_on_proximity",
            "trigger": "when target is within explosion radius",
            "actions": [
              {
                "action": "deal damage to all objects within explosion radius"
              },
              {
                "action": "create explosion effect"
              },
              {
                "action": "destroy missile"
              }
            ]
          },
          {
            "name": "self_destruct",
            "trigger": "when lifetime expires",
            "actions": [
              {
                "action": "create explosion effect"
              },
              {
                "action": "destroy missile"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class HomingMissile : MonoBehaviour\n{\n    [Header(\"Targeting\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private float _detectionRange = 50f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _speed = 15f;\n    [SerializeField] private float _rotationSpeed = 200f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _maxSpeed = 25f;\n    \n    [Header(\"Homing Behavior\")]\n    [SerializeField] private float _homingStrength = 2f;\n    [SerializeField] private float _predictionTime = 0.5f;\n    [SerializeField] private bool _useLeadTargeting = true;\n    \n    [Header(\"Lifetime\")]\n    [SerializeField] private float _lifeTime = 10f;\n    [SerializeField] private float _armingDelay = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionDamage = 100f;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private ParticleSystem _thrusterParticles;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentVelocity;\n    private float _currentSpeed;\n    private float _timeAlive;\n    private bool _isArmed;\n    private bool _hasExploded;\n    private Vector3 _lastTargetPosition;\n    private Vector3 _targetVelocity;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _currentSpeed = _speed;\n        _currentVelocity = transform.forward * _currentSpeed;\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Play();\n        }\n        \n        FindInitialTarget();\n    }\n    \n    private void Update()\n    {\n        _timeAlive += Time.deltaTime;\n        \n        if (_timeAlive >= _lifeTime)\n        {\n            Explode();\n            return;\n        }\n        \n        if (_timeAlive >= _armingDelay)\n        {\n            _isArmed = true;\n        }\n        \n        if (_target == null)\n        {\n            FindTarget();\n        }\n        \n        UpdateTargetVelocity();\n        UpdateMovement();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_hasExploded) return;\n        \n        _rigidbody.velocity = _currentVelocity;\n    }\n    \n    private void FindInitialTarget()\n    {\n        if (_target != null) return;\n        FindTarget();\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] potentialTargets = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayers);\n        \n        float closestDistance = float.MaxValue;\n        Transform closestTarget = null;\n        \n        foreach (Collider col in potentialTargets)\n        {\n            if (col.transform == transform) continue;\n            \n            if (!string.IsNullOrEmpty(_targetTag) && !col.CompareTag(_targetTag)) continue;\n            \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = col.transform;\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void UpdateTargetVelocity()\n    {\n        if (_target == null) return;\n        \n        Vector3 currentTargetPosition = _target.position;\n        _targetVelocity = (currentTargetPosition - _lastTargetPosition) / Time.deltaTime;\n        _lastTargetPosition = currentTargetPosition;\n    }\n    \n    private void UpdateMovement()\n    {\n        if (_target == null)\n        {\n            // Continue straight if no target\n            _currentVelocity = transform.forward * _currentSpeed;\n            return;\n        }\n        \n        Vector3 targetPosition = _target.position;\n        \n        // Lead targeting - predict where target will be\n        if (_useLeadTargeting)\n        {\n            targetPosition += _targetVelocity * _predictionTime;\n        }\n        \n        Vector3 directionToTarget = (targetPosition - transform.position).normalized;\n        Vector3 desiredVelocity = directionToTarget * _currentSpeed;\n        \n        // Apply homing behavior\n        _currentVelocity = Vector3.Lerp(_currentVelocity, desiredVelocity, _homingStrength * Time.deltaTime);\n        \n        // Accelerate over time\n        _currentSpeed = Mathf.Min(_currentSpeed + _acceleration * Time.deltaTime, _maxSpeed);\n        _currentVelocity = _currentVelocity.normalized * _currentSpeed;\n        \n        // Rotate to face movement direction\n        if (_currentVelocity != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(_currentVelocity);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasExploded || !_isArmed) return;\n        \n        if (other.transform == transform) return;\n        \n        // Check if we hit our target or any valid target\n        bool isValidTarget = false;\n        \n        if (_target != null && other.transform == _target)\n        {\n            isValidTarget = true;\n        }\n        else if (!string.IsNullOrEmpty(_targetTag) && other.CompareTag(_targetTag))\n        {\n            isValidTarget = true;\n        }\n        else if ((_targetLayers.value & (1 << other.gameObject.layer)) != 0)\n        {\n            isValidTarget = true;\n        }\n        \n        if (isValidTarget)\n        {\n            Explode();\n        }\n    }\n    \n    private void Explode()\n    {\n        if (_hasExploded) return;\n        _hasExploded = true;\n        \n        // Apply explosion damage\n        ApplyExplosionDamage();\n        \n        // Spawn explosion effect\n        if (_explosionPrefab != null)\n        {\n            GameObject explosion = Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n            Destroy(explosion, 5f);\n        }\n        \n        // Stop particles\n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        // Disable trail\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n        \n        // Destroy missile\n        Destroy(gameObject);\n    }\n    \n    private void ApplyExplosionDamage()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, hit.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            float damage = _explosionDamage * damageMultiplier;\n            \n            // Try to apply damage through various common interfaces\n            MonoBehaviour[] components = hit.GetComponents<MonoBehaviour>();\n            foreach (MonoBehaviour component in components)\n            {\n                // Use reflection to find damage methods\n                var damageMethod = component.GetType().GetMethod(\"TakeDamage\");\n                if (damageMethod != null)\n                {\n                    damageMethod.Invoke(component, new object[] { damage });\n                    break;\n                }\n            }\n            \n            // Apply physics force\n            Rigidbody hitRigidbody = hit.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                Vector3 forceDirection = (hit.transform.position - transform.position).normalized;\n                float forceMultiplier = 1f - (distance / _explosionRadius);\n                hitRigidbody.AddForce(forceDirection * _explosionDamage * forceMultiplier, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public void SetTarget(Transform target)\n    {\n        _target = target;\n    }\n    \n    public void SetTargetTag(string tag)\n    {\n        _targetTag = tag;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw explosion radius\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        // Draw line to target\n        if (_target != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "guard that alerts others when attacked",
      "ideal_ir": {
        "class_name": "AlertGuard",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "alertRadius",
            "type": "float",
            "default": 20
          },
          {
            "name": "isAlerted",
            "type": "bool",
            "default": false
          },
          {
            "name": "alertSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when this guard receives damage",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "set alerted state to true"
              },
              {
                "action": "play alert sound"
              }
            ]
          },
          {
            "name": "alert_nearby_guards",
            "trigger": "when this guard becomes alerted",
            "actions": [
              {
                "action": "find all other guards within alert radius"
              },
              {
                "action": "notify each nearby guard to become alerted"
              },
              {
                "action": "broadcast alert message to nearby guards"
              }
            ]
          },
          {
            "name": "receive_alert",
            "trigger": "when receiving alert notification from another guard",
            "actions": [
              {
                "action": "set alerted state to true"
              },
              {
                "action": "play alert sound"
              }
            ]
          },
          {
            "name": "die",
            "trigger": "when health reaches zero or below",
            "actions": [
              {
                "action": "destroy this guard object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class GuardAlertSystem : MonoBehaviour\n{\n    [Header(\"Guard Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _alertRadius = 15f;\n    [SerializeField] private LayerMask _guardLayerMask = -1;\n    [SerializeField] private float _alertDuration = 10f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _alertIndicator;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _alertedColor = Color.red;\n    [SerializeField] private Renderer _guardRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _alertSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGuardAttacked;\n    public UnityEvent OnGuardAlerted;\n    public UnityEvent OnGuardDeath;\n    \n    private bool _isAlerted = false;\n    private bool _isDead = false;\n    private float _maxHealth;\n    private float _alertTimer = 0f;\n    private List<GuardAlertSystem> _nearbyGuards = new List<GuardAlertSystem>();\n    \n    public bool IsAlerted => _isAlerted;\n    public bool IsDead => _isDead;\n    public float HealthPercentage => _health / _maxHealth;\n    \n    private void Start()\n    {\n        _maxHealth = _health;\n        \n        if (_guardRenderer == null)\n            _guardRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_alertIndicator != null)\n            _alertIndicator.SetActive(false);\n            \n        UpdateVisualState();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        if (_isAlerted)\n        {\n            _alertTimer -= Time.deltaTime;\n            if (_alertTimer <= 0f)\n            {\n                CalmDown();\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _health -= damage;\n        \n        PlaySound(_damageSound);\n        \n        if (_health <= 0f)\n        {\n            Die();\n        }\n        else\n        {\n            TriggerAlert();\n        }\n        \n        OnGuardAttacked?.Invoke();\n    }\n    \n    private void TriggerAlert()\n    {\n        if (_isAlerted) return;\n        \n        _isAlerted = true;\n        _alertTimer = _alertDuration;\n        \n        PlaySound(_alertSound);\n        UpdateVisualState();\n        \n        AlertNearbyGuards();\n        OnGuardAlerted?.Invoke();\n    }\n    \n    public void ReceiveAlert()\n    {\n        if (_isDead || _isAlerted) return;\n        \n        _isAlerted = true;\n        _alertTimer = _alertDuration;\n        \n        UpdateVisualState();\n        OnGuardAlerted?.Invoke();\n    }\n    \n    private void AlertNearbyGuards()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _alertRadius, _guardLayerMask);\n        \n        _nearbyGuards.Clear();\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            GuardAlertSystem otherGuard = col.GetComponent<GuardAlertSystem>();\n            if (otherGuard != null && !otherGuard.IsDead)\n            {\n                _nearbyGuards.Add(otherGuard);\n                otherGuard.ReceiveAlert();\n            }\n        }\n    }\n    \n    private void CalmDown()\n    {\n        _isAlerted = false;\n        _alertTimer = 0f;\n        UpdateVisualState();\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _health = 0f;\n        _isAlerted = false;\n        \n        UpdateVisualState();\n        OnGuardDeath?.Invoke();\n        \n        if (GetComponent<Collider>() != null)\n            GetComponent<Collider>().enabled = false;\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_guardRenderer != null)\n        {\n            if (_isDead)\n            {\n                _guardRenderer.material.color = Color.gray;\n            }\n            else if (_isAlerted)\n            {\n                _guardRenderer.material.color = _alertedColor;\n            }\n            else\n            {\n                _guardRenderer.material.color = _normalColor;\n            }\n        }\n        \n        if (_alertIndicator != null)\n        {\n            _alertIndicator.SetActive(_isAlerted && !_isDead);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isDead) return;\n        \n        if (other.CompareTag(\"Player\") && _isAlerted)\n        {\n            // Player detected while alerted - could trigger additional behavior\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _alertRadius);\n        \n        if (_isAlerted)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _alertRadius * 0.5f);\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        if (_isDead) return;\n        \n        _health = Mathf.Min(_health + amount, _maxHealth);\n    }\n    \n    public void SetAlertState(bool alerted)\n    {\n        if (_isDead) return;\n        \n        if (alerted && !_isAlerted)\n        {\n            TriggerAlert();\n        }\n        else if (!alerted && _isAlerted)\n        {\n            CalmDown();\n        }\n    }\n    \n    public List<GuardAlertSystem> GetNearbyGuards()\n    {\n        return new List<GuardAlertSystem>(_nearbyGuards);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "enemy that shields nearby allies",
      "ideal_ir": {
        "class_name": "ShieldingEnemy",
        "components": [
          "Transform",
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "shieldRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "shieldStrength",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "shieldCooldown",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isShielding",
            "type": "bool",
            "default": false
          },
          {
            "name": "shieldEffect",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_nearby_allies",
            "trigger": "continuously check for allies within shield radius",
            "actions": [
              {
                "action": "scan area around self for friendly units"
              },
              {
                "action": "identify allies that need protection"
              }
            ]
          },
          {
            "name": "activate_shield",
            "trigger": "when allies are detected within range and shield is not on cooldown",
            "actions": [
              {
                "action": "set shielding state to active"
              },
              {
                "action": "spawn visual shield effect around self"
              },
              {
                "action": "apply damage reduction to all allies in radius"
              },
              {
                "action": "play shield activation sound"
              }
            ]
          },
          {
            "name": "maintain_shield",
            "trigger": "while shielding is active and allies remain in range",
            "actions": [
              {
                "action": "continuously reduce incoming damage to protected allies"
              },
              {
                "action": "update shield visual effects"
              },
              {
                "action": "drain energy or resources if applicable"
              }
            ]
          },
          {
            "name": "deactivate_shield",
            "trigger": "when no allies remain in range or shield duration expires",
            "actions": [
              {
                "action": "set shielding state to inactive"
              },
              {
                "action": "remove shield visual effects"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "remove damage reduction from allies"
              }
            ]
          },
          {
            "name": "shield_feedback",
            "trigger": "when shield absorbs damage",
            "actions": [
              {
                "action": "create impact visual effect on shield"
              },
              {
                "action": "play shield hit sound"
              },
              {
                "action": "briefly intensify shield glow"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ShieldingEnemy : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _shieldRadius = 5f;\n    [SerializeField] private float _shieldStrength = 0.5f;\n    [SerializeField] private LayerMask _allyLayerMask = -1;\n    [SerializeField] private string _allyTag = \"Enemy\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldEffectPrefab;\n    [SerializeField] private LineRenderer _shieldBeamPrefab;\n    [SerializeField] private Color _shieldColor = Color.cyan;\n    [SerializeField] private bool _showShieldRadius = true;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.1f;\n    \n    private List<ShieldedAlly> _shieldedAllies = new List<ShieldedAlly>();\n    private List<GameObject> _activeShieldEffects = new List<GameObject>();\n    private List<LineRenderer> _activeBeams = new List<LineRenderer>();\n    private float _lastUpdateTime;\n    private SphereCollider _detectionCollider;\n    \n    [System.Serializable]\n    private class ShieldedAlly\n    {\n        public GameObject ally;\n        public float originalDamageMultiplier;\n        public AllyDamageReceiver damageReceiver;\n        \n        public ShieldedAlly(GameObject allyObject, AllyDamageReceiver receiver)\n        {\n            ally = allyObject;\n            damageReceiver = receiver;\n            originalDamageMultiplier = receiver.damageMultiplier;\n        }\n    }\n    \n    private class AllyDamageReceiver : MonoBehaviour\n    {\n        public float damageMultiplier = 1f;\n        public bool isShielded = false;\n        \n        public void TakeDamage(float damage)\n        {\n            float finalDamage = damage * damageMultiplier;\n            \n            if (TryGetComponent<Rigidbody>(out Rigidbody rb))\n            {\n                rb.AddForce(Vector3.up * finalDamage, ForceMode.Impulse);\n            }\n            \n            if (finalDamage >= 100f)\n            {\n                gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    void Start()\n    {\n        SetupDetectionCollider();\n        _lastUpdateTime = Time.time;\n    }\n    \n    void Update()\n    {\n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            UpdateShieldedAllies();\n            _lastUpdateTime = Time.time;\n        }\n    }\n    \n    void SetupDetectionCollider()\n    {\n        _detectionCollider = gameObject.GetComponent<SphereCollider>();\n        if (_detectionCollider == null)\n        {\n            _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _shieldRadius;\n    }\n    \n    void UpdateShieldedAllies()\n    {\n        RemoveInvalidAllies();\n        FindNewAllies();\n        UpdateVisualEffects();\n    }\n    \n    void RemoveInvalidAllies()\n    {\n        for (int i = _shieldedAllies.Count - 1; i >= 0; i--)\n        {\n            var shieldedAlly = _shieldedAllies[i];\n            \n            if (shieldedAlly.ally == null || !shieldedAlly.ally.activeInHierarchy)\n            {\n                RemoveShieldFromAlly(shieldedAlly);\n                _shieldedAllies.RemoveAt(i);\n                continue;\n            }\n            \n            float distance = Vector3.Distance(transform.position, shieldedAlly.ally.transform.position);\n            if (distance > _shieldRadius)\n            {\n                RemoveShieldFromAlly(shieldedAlly);\n                _shieldedAllies.RemoveAt(i);\n            }\n        }\n    }\n    \n    void FindNewAllies()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _shieldRadius, _allyLayerMask);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            if (collider.gameObject == gameObject) continue;\n            \n            if (!string.IsNullOrEmpty(_allyTag) && !collider.CompareTag(_allyTag)) continue;\n            \n            if (!IsAllyAlreadyShielded(collider.gameObject))\n            {\n                AddShieldToAlly(collider.gameObject);\n            }\n        }\n    }\n    \n    bool IsAllyAlreadyShielded(GameObject ally)\n    {\n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            if (shieldedAlly.ally == ally)\n                return true;\n        }\n        return false;\n    }\n    \n    void AddShieldToAlly(GameObject ally)\n    {\n        AllyDamageReceiver damageReceiver = ally.GetComponent<AllyDamageReceiver>();\n        if (damageReceiver == null)\n        {\n            damageReceiver = ally.AddComponent<AllyDamageReceiver>();\n        }\n        \n        ShieldedAlly shieldedAlly = new ShieldedAlly(ally, damageReceiver);\n        damageReceiver.damageMultiplier = _shieldStrength;\n        damageReceiver.isShielded = true;\n        \n        _shieldedAllies.Add(shieldedAlly);\n    }\n    \n    void RemoveShieldFromAlly(ShieldedAlly shieldedAlly)\n    {\n        if (shieldedAlly.damageReceiver != null)\n        {\n            shieldedAlly.damageReceiver.damageMultiplier = shieldedAlly.originalDamageMultiplier;\n            shieldedAlly.damageReceiver.isShielded = false;\n        }\n    }\n    \n    void UpdateVisualEffects()\n    {\n        ClearVisualEffects();\n        \n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            if (shieldedAlly.ally != null)\n            {\n                CreateShieldEffect(shieldedAlly.ally);\n                CreateShieldBeam(shieldedAlly.ally);\n            }\n        }\n    }\n    \n    void CreateShieldEffect(GameObject ally)\n    {\n        if (_shieldEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_shieldEffectPrefab, ally.transform.position, Quaternion.identity);\n            effect.transform.SetParent(ally.transform);\n            _activeShieldEffects.Add(effect);\n            \n            if (effect.TryGetComponent<Renderer>(out Renderer renderer))\n            {\n                renderer.material.color = _shieldColor;\n            }\n        }\n    }\n    \n    void CreateShieldBeam(GameObject ally)\n    {\n        LineRenderer beam;\n        \n        if (_shieldBeamPrefab != null)\n        {\n            beam = Instantiate(_shieldBeamPrefab, transform.position, Quaternion.identity);\n        }\n        else\n        {\n            GameObject beamObject = new GameObject(\"ShieldBeam\");\n            beam = beamObject.AddComponent<LineRenderer>();\n            beam.material = new Material(Shader.Find(\"Sprites/Default\"));\n            beam.color = _shieldColor;\n            beam.startWidth = 0.1f;\n            beam.endWidth = 0.05f;\n        }\n        \n        beam.positionCount = 2;\n        beam.SetPosition(0, transform.position);\n        beam.SetPosition(1, ally.transform.position);\n        \n        _activeBeams.Add(beam);\n    }\n    \n    void ClearVisualEffects()\n    {\n        foreach (var effect in _activeShieldEffects)\n        {\n            if (effect != null)\n                DestroyImmediate(effect);\n        }\n        _activeShieldEffects.Clear();\n        \n        foreach (var beam in _activeBeams)\n        {\n            if (beam != null)\n                DestroyImmediate(beam.gameObject);\n        }\n        _activeBeams.Clear();\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.gameObject == gameObject) return;\n        \n        if (!string.IsNullOrEmpty(_allyTag) && !other.CompareTag(_allyTag)) return;\n        \n        if (!IsAllyAlreadyShielded(other.gameObject))\n        {\n            AddShieldToAlly(other.gameObject);\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        for (int i = _shieldedAllies.Count - 1; i >= 0; i--)\n        {\n            if (_shieldedAllies[i].ally == other.gameObject)\n            {\n                RemoveShieldFromAlly(_shieldedAllies[i]);\n                _shieldedAllies.RemoveAt(i);\n                break;\n            }\n        }\n    }\n    \n    void OnDestroy()\n    {\n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            RemoveShieldFromAlly(shieldedAlly);\n        }\n        \n        ClearVisualEffects();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_showShieldRadius)\n        {\n            Gizmos.color = _shieldColor;\n            Gizmos.DrawWireSphere(transform.position, _shieldRadius);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "swarm AI that coordinates movement",
      "ideal_ir": {
        "class_name": "SwarmAgent",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "swarmRadius",
            "type": "float",
            "default": 10
          },
          {
            "name": "separationDistance",
            "type": "float",
            "default": 2
          },
          {
            "name": "alignmentWeight",
            "type": "float",
            "default": 1
          },
          {
            "name": "cohesionWeight",
            "type": "float",
            "default": 1
          },
          {
            "name": "separationWeight",
            "type": "float",
            "default": 2
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 5
          },
          {
            "name": "neighborDetectionRadius",
            "type": "float",
            "default": 8
          },
          {
            "name": "swarmCenter",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "isLeader",
            "type": "bool",
            "default": false
          },
          {
            "name": "targetPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "detect_nearby_swarm_members",
            "trigger": "continuously during gameplay",
            "actions": [
              {
                "action": "scan for other swarm agents within neighbor detection radius"
              },
              {
                "action": "store list of nearby swarm members for coordination"
              }
            ]
          },
          {
            "name": "calculate_separation_force",
            "trigger": "when nearby swarm members are too close",
            "actions": [
              {
                "action": "determine direction away from overcrowded neighbors"
              },
              {
                "action": "apply separation force to maintain minimum distance between agents"
              }
            ]
          },
          {
            "name": "calculate_alignment_force",
            "trigger": "when coordinating with nearby swarm members",
            "actions": [
              {
                "action": "observe movement direction of neighboring agents"
              },
              {
                "action": "adjust own movement direction to match average neighbor direction"
              }
            ]
          },
          {
            "name": "calculate_cohesion_force",
            "trigger": "when maintaining swarm unity",
            "actions": [
              {
                "action": "find center position of nearby swarm members"
              },
              {
                "action": "apply gentle force toward the local group center"
              }
            ]
          },
          {
            "name": "follow_swarm_leader",
            "trigger": "when not designated as leader and leader exists",
            "actions": [
              {
                "action": "locate the designated swarm leader"
              },
              {
                "action": "move toward leader position while maintaining swarm behaviors"
              }
            ]
          },
          {
            "name": "lead_swarm_movement",
            "trigger": "when designated as swarm leader",
            "actions": [
              {
                "action": "move toward the assigned target position"
              },
              {
                "action": "broadcast movement intentions to nearby swarm members"
              }
            ]
          },
          {
            "name": "combine_movement_forces",
            "trigger": "every frame during active movement",
            "actions": [
              {
                "action": "blend separation, alignment, and cohesion forces with appropriate weights"
              },
              {
                "action": "limit combined force to maximum speed threshold"
              },
              {
                "action": "apply final movement vector to agent position"
              }
            ]
          },
          {
            "name": "avoid_obstacles",
            "trigger": "when obstacles detected in movement path",
            "actions": [
              {
                "action": "detect solid obstacles ahead of current movement direction"
              },
              {
                "action": "calculate avoidance vector around detected obstacles"
              },
              {
                "action": "blend obstacle avoidance with swarm coordination forces"
              }
            ]
          },
          {
            "name": "maintain_swarm_boundaries",
            "trigger": "when moving too far from swarm center",
            "actions": [
              {
                "action": "check distance from overall swarm center position"
              },
              {
                "action": "apply return force when exceeding maximum swarm radius"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class SwarmAI : MonoBehaviour\n{\n    [Header(\"Swarm Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _separationRadius = 2f;\n    [SerializeField] private float _alignmentRadius = 5f;\n    [SerializeField] private float _cohesionRadius = 8f;\n    \n    [Header(\"Movement Forces\")]\n    [SerializeField] private float _separationForce = 2f;\n    [SerializeField] private float _alignmentForce = 1f;\n    [SerializeField] private float _cohesionForce = 1f;\n    [SerializeField] private float _seekForce = 1.5f;\n    [SerializeField] private float _maxSpeed = 5f;\n    [SerializeField] private float _maxForce = 3f;\n    \n    [Header(\"Target Settings\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _followPlayer = true;\n    [SerializeField] private float _wanderRadius = 15f;\n    [SerializeField] private float _wanderChangeInterval = 3f;\n    \n    [Header(\"Avoidance\")]\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n    [SerializeField] private float _avoidanceRadius = 3f;\n    [SerializeField] private float _avoidanceForce = 4f;\n    \n    private Vector3 _velocity;\n    private Vector3 _wanderTarget;\n    private float _wanderTimer;\n    private List<SwarmAI> _neighbors;\n    private static List<SwarmAI> _allAgents = new List<SwarmAI>();\n    \n    private void Start()\n    {\n        _allAgents.Add(this);\n        _neighbors = new List<SwarmAI>();\n        _velocity = Random.insideUnitSphere * 2f;\n        _velocity.y = 0f;\n        \n        if (_followPlayer && _target == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _target = player.transform;\n        }\n        \n        GenerateWanderTarget();\n    }\n    \n    private void OnDestroy()\n    {\n        _allAgents.Remove(this);\n    }\n    \n    private void Update()\n    {\n        UpdateNeighbors();\n        Vector3 steeringForce = CalculateSteeringForce();\n        ApplyForce(steeringForce);\n        Move();\n        \n        _wanderTimer += Time.deltaTime;\n        if (_wanderTimer >= _wanderChangeInterval)\n        {\n            GenerateWanderTarget();\n            _wanderTimer = 0f;\n        }\n    }\n    \n    private void UpdateNeighbors()\n    {\n        _neighbors.Clear();\n        \n        foreach (SwarmAI agent in _allAgents)\n        {\n            if (agent == this) continue;\n            \n            float distance = Vector3.Distance(transform.position, agent.transform.position);\n            if (distance <= _detectionRadius)\n            {\n                _neighbors.Add(agent);\n            }\n        }\n    }\n    \n    private Vector3 CalculateSteeringForce()\n    {\n        Vector3 separation = CalculateSeparation();\n        Vector3 alignment = CalculateAlignment();\n        Vector3 cohesion = CalculateCohesion();\n        Vector3 seek = CalculateSeek();\n        Vector3 avoidance = CalculateObstacleAvoidance();\n        \n        Vector3 totalForce = separation * _separationForce +\n                           alignment * _alignmentForce +\n                           cohesion * _cohesionForce +\n                           seek * _seekForce +\n                           avoidance * _avoidanceForce;\n        \n        return Vector3.ClampMagnitude(totalForce, _maxForce);\n    }\n    \n    private Vector3 CalculateSeparation()\n    {\n        Vector3 steer = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _separationRadius)\n            {\n                Vector3 diff = transform.position - neighbor.transform.position;\n                diff.Normalize();\n                diff /= distance; // Weight by distance\n                steer += diff;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            steer /= count;\n            steer.Normalize();\n            steer *= _maxSpeed;\n            steer -= _velocity;\n        }\n        \n        return steer;\n    }\n    \n    private Vector3 CalculateAlignment()\n    {\n        Vector3 sum = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _alignmentRadius)\n            {\n                sum += neighbor._velocity;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            sum /= count;\n            sum.Normalize();\n            sum *= _maxSpeed;\n            Vector3 steer = sum - _velocity;\n            return steer;\n        }\n        \n        return Vector3.zero;\n    }\n    \n    private Vector3 CalculateCohesion()\n    {\n        Vector3 sum = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _cohesionRadius)\n            {\n                sum += neighbor.transform.position;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            sum /= count;\n            return Seek(sum);\n        }\n        \n        return Vector3.zero;\n    }\n    \n    private Vector3 CalculateSeek()\n    {\n        Vector3 targetPos;\n        \n        if (_target != null)\n        {\n            targetPos = _target.position;\n        }\n        else\n        {\n            targetPos = _wanderTarget;\n        }\n        \n        return Seek(targetPos);\n    }\n    \n    private Vector3 Seek(Vector3 target)\n    {\n        Vector3 desired = target - transform.position;\n        desired.Normalize();\n        desired *= _maxSpeed;\n        \n        Vector3 steer = desired - _velocity;\n        return steer;\n    }\n    \n    private Vector3 CalculateObstacleAvoidance()\n    {\n        Vector3 avoidanceForce = Vector3.zero;\n        \n        Collider[] obstacles = Physics.OverlapSphere(transform.position, _avoidanceRadius, _obstacleLayer);\n        \n        foreach (Collider obstacle in obstacles)\n        {\n            Vector3 directionAway = transform.position - obstacle.ClosestPoint(transform.position);\n            if (directionAway.magnitude > 0)\n            {\n                directionAway.Normalize();\n                float distance = Vector3.Distance(transform.position, obstacle.ClosestPoint(transform.position));\n                directionAway /= distance; // Weight by distance\n                avoidanceForce += directionAway;\n            }\n        }\n        \n        return avoidanceForce;\n    }\n    \n    private void ApplyForce(Vector3 force)\n    {\n        _velocity += force * Time.deltaTime;\n        _velocity = Vector3.ClampMagnitude(_velocity, _maxSpeed);\n    }\n    \n    private void Move()\n    {\n        transform.position += _velocity * Time.deltaTime;\n        \n        if (_velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_velocity);\n        }\n    }\n    \n    private void GenerateWanderTarget()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _wanderRadius;\n        _wanderTarget = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _separationRadius);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _alignmentRadius);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _cohesionRadius);\n        \n        Gizmos.color = Color.magenta;\n        Gizmos.DrawWireSphere(transform.position, _avoidanceRadius);\n        \n        if (_target != null)\n        {\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n        \n        Gizmos.color = Color.white;\n        Gizmos.DrawSphere(_wanderTarget, 0.5f);\n        \n        Gizmos.color = Color.black;\n        Gizmos.DrawRay(transform.position, _velocity);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "spike trap that damages on contact",
      "ideal_ir": {
        "class_name": "SpikeTrap",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "damage_on_contact",
            "trigger": "when player or enemy enters trigger area and trap is active",
            "actions": [
              {
                "action": "deal damage to the colliding entity"
              },
              {
                "action": "play spike damage sound effect"
              },
              {
                "action": "show damage visual effect at contact point"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpikeTrap : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damageAmount = 10;\n    [SerializeField] private float _damageInterval = 1f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private GameObject _spikesVisual;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private Vector3 _extendedPosition = Vector3.up;\n    [SerializeField] private Vector3 _retractedPosition = Vector3.zero;\n    \n    [Header(\"Activation Settings\")]\n    [SerializeField] private bool _isActive = true;\n    [SerializeField] private bool _animateSpikes = true;\n    [SerializeField] private float _activationDelay = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerDamaged;\n    public UnityEvent OnTrapActivated;\n    \n    private bool _playerInRange = false;\n    private float _lastDamageTime = 0f;\n    private bool _spikesExtended = false;\n    private Vector3 _originalSpikePosition;\n    private Coroutine _activationCoroutine;\n    \n    private void Start()\n    {\n        if (_spikesVisual != null)\n        {\n            _originalSpikePosition = _spikesVisual.transform.localPosition;\n            _retractedPosition += _originalSpikePosition;\n            _extendedPosition += _originalSpikePosition;\n            \n            if (!_isActive)\n            {\n                _spikesVisual.transform.localPosition = _retractedPosition;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_animateSpikes && _spikesVisual != null)\n        {\n            Vector3 targetPosition = _spikesExtended ? _extendedPosition : _retractedPosition;\n            _spikesVisual.transform.localPosition = Vector3.Lerp(\n                _spikesVisual.transform.localPosition, \n                targetPosition, \n                Time.deltaTime * _animationSpeed\n            );\n        }\n        \n        if (_playerInRange && _isActive && Time.time >= _lastDamageTime + _damageInterval)\n        {\n            DealDamage();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = true;\n            \n            if (_isActive)\n            {\n                if (_activationCoroutine != null)\n                {\n                    StopCoroutine(_activationCoroutine);\n                }\n                _activationCoroutine = StartCoroutine(ActivateWithDelay());\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = false;\n            _spikesExtended = false;\n            \n            if (_activationCoroutine != null)\n            {\n                StopCoroutine(_activationCoroutine);\n                _activationCoroutine = null;\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ActivateWithDelay()\n    {\n        yield return new WaitForSeconds(_activationDelay);\n        \n        if (_playerInRange && _isActive)\n        {\n            ActivateTrap();\n        }\n    }\n    \n    private void ActivateTrap()\n    {\n        _spikesExtended = true;\n        \n        if (_audioSource != null && _activationSound != null)\n        {\n            _audioSource.PlayOneShot(_activationSound);\n        }\n        \n        OnTrapActivated?.Invoke();\n        \n        if (_playerInRange)\n        {\n            DealDamage();\n        }\n    }\n    \n    private void DealDamage()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _lastDamageTime = Time.time;\n            \n            // Try to find a component that can take damage\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Use SendMessage as a fallback for damage dealing\n                player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            if (_audioSource != null && _damageSound != null)\n            {\n                _audioSource.PlayOneShot(_damageSound);\n            }\n            \n            OnPlayerDamaged?.Invoke(player);\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        if (!active)\n        {\n            _spikesExtended = false;\n            _playerInRange = false;\n        }\n    }\n    \n    public void ToggleActive()\n    {\n        SetActive(!_isActive);\n    }\n    \n    public void ForceActivate()\n    {\n        if (_isActive)\n        {\n            ActivateTrap();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActive ? Color.red : Color.gray;\n        Gizmos.DrawWireCube(transform.position, GetComponent<Collider>().bounds.size);\n        \n        if (_spikesVisual != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(transform.position + _retractedPosition, transform.position + _extendedPosition);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "pressure plate that opens nearby door",
      "ideal_ir": {
        "class_name": "PressurePlate",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "targetDoor",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "activationWeight",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "pressSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "releaseSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "isPressed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_plate",
            "trigger": "when object with sufficient weight enters trigger area",
            "actions": [
              {
                "action": "lower pressure plate visually"
              },
              {
                "action": "play activation sound effect"
              },
              {
                "action": "mark plate as pressed"
              },
              {
                "action": "send open command to target door"
              }
            ]
          },
          {
            "name": "deactivate_plate",
            "trigger": "when all objects leave trigger area",
            "actions": [
              {
                "action": "raise pressure plate to original position"
              },
              {
                "action": "play release sound effect"
              },
              {
                "action": "mark plate as not pressed"
              },
              {
                "action": "send close command to target door"
              }
            ]
          },
          {
            "name": "maintain_activation",
            "trigger": "when plate remains pressed with sufficient weight",
            "actions": [
              {
                "action": "keep door in open state"
              },
              {
                "action": "maintain pressed visual state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Pressure Plate Settings\")]\n    [SerializeField] private float _activationDelay = 0.1f;\n    [SerializeField] private float _deactivationDelay = 0.5f;\n    [SerializeField] private bool _stayActivated = false;\n    [SerializeField] private string[] _activatorTags = { \"Player\", \"Box\" };\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Transform _plateTransform;\n    [SerializeField] private float _pressedHeight = -0.1f;\n    [SerializeField] private float _normalHeight = 0f;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Door Connection\")]\n    [SerializeField] private DoorController _connectedDoor;\n    [SerializeField] private float _doorSearchRadius = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnActivated;\n    public UnityEvent OnDeactivated;\n    \n    private bool _isActivated = false;\n    private bool _hasObjectsOnPlate = false;\n    private int _objectsOnPlate = 0;\n    private AudioSource _audioSource;\n    private Vector3 _targetPosition;\n    private float _activationTimer = 0f;\n    private float _deactivationTimer = 0f;\n    private bool _pendingActivation = false;\n    private bool _pendingDeactivation = false;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        if (_plateTransform == null)\n            _plateTransform = transform;\n            \n        _targetPosition = _plateTransform.localPosition;\n        _targetPosition.y = _normalHeight;\n        _plateTransform.localPosition = _targetPosition;\n        \n        if (_connectedDoor == null)\n            FindNearbyDoor();\n    }\n    \n    private void Update()\n    {\n        HandleTimers();\n        AnimatePlate();\n    }\n    \n    private void HandleTimers()\n    {\n        if (_pendingActivation)\n        {\n            _activationTimer += Time.deltaTime;\n            if (_activationTimer >= _activationDelay)\n            {\n                ActivatePlate();\n                _pendingActivation = false;\n                _activationTimer = 0f;\n            }\n        }\n        \n        if (_pendingDeactivation && !_stayActivated)\n        {\n            _deactivationTimer += Time.deltaTime;\n            if (_deactivationTimer >= _deactivationDelay)\n            {\n                DeactivatePlate();\n                _pendingDeactivation = false;\n                _deactivationTimer = 0f;\n            }\n        }\n    }\n    \n    private void AnimatePlate()\n    {\n        Vector3 currentPos = _plateTransform.localPosition;\n        currentPos = Vector3.Lerp(currentPos, _targetPosition, Time.deltaTime * _animationSpeed);\n        _plateTransform.localPosition = currentPos;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidActivator(other))\n        {\n            _objectsOnPlate++;\n            \n            if (!_hasObjectsOnPlate)\n            {\n                _hasObjectsOnPlate = true;\n                _pendingActivation = true;\n                _pendingDeactivation = false;\n                _activationTimer = 0f;\n                _deactivationTimer = 0f;\n                \n                _targetPosition.y = _pressedHeight;\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsValidActivator(other))\n        {\n            _objectsOnPlate--;\n            \n            if (_objectsOnPlate <= 0)\n            {\n                _objectsOnPlate = 0;\n                _hasObjectsOnPlate = false;\n                \n                if (!_stayActivated)\n                {\n                    _pendingDeactivation = true;\n                    _pendingActivation = false;\n                    _activationTimer = 0f;\n                    _deactivationTimer = 0f;\n                }\n                \n                _targetPosition.y = _normalHeight;\n            }\n        }\n    }\n    \n    private bool IsValidActivator(Collider other)\n    {\n        foreach (string tag in _activatorTags)\n        {\n            if (other.CompareTag(tag))\n                return true;\n        }\n        return false;\n    }\n    \n    private void ActivatePlate()\n    {\n        if (_isActivated) return;\n        \n        _isActivated = true;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.OpenDoor();\n            \n        PlaySound(_activationSound);\n        OnActivated.Invoke();\n    }\n    \n    private void DeactivatePlate()\n    {\n        if (!_isActivated) return;\n        \n        _isActivated = false;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.CloseDoor();\n            \n        PlaySound(_deactivationSound);\n        OnDeactivated.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void FindNearbyDoor()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _doorSearchRadius);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            DoorController door = col.GetComponent<DoorController>();\n            if (door != null)\n            {\n                _connectedDoor = door;\n                break;\n            }\n        }\n    }\n    \n    public void ResetPlate()\n    {\n        _isActivated = false;\n        _hasObjectsOnPlate = false;\n        _objectsOnPlate = 0;\n        _pendingActivation = false;\n        _pendingDeactivation = false;\n        _activationTimer = 0f;\n        _deactivationTimer = 0f;\n        _targetPosition.y = _normalHeight;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.CloseDoor();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _doorSearchRadius);\n        \n        if (_connectedDoor != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _connectedDoor.transform.position);\n        }\n    }\n}\n\npublic class DoorController : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private Transform _doorTransform;\n    [SerializeField] private Vector3 _openPosition;\n    [SerializeField] private Vector3 _closedPosition;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private AnimationCurve _openCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private Vector3 _targetPosition;\n    private AudioSource _audioSource;\n    private Coroutine _moveCoroutine;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_doorTransform == null)\n            _doorTransform = transform;\n            \n        _closedPosition = _doorTransform.localPosition;\n        _targetPosition = _closedPosition;\n    }\n    \n    public void OpenDoor()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _targetPosition = _openPosition;\n        \n        if (_moveCoroutine != null)\n            StopCoroutine(_moveCoroutine);\n            \n        _moveCoroutine = StartCoroutine(MoveDoor(_openPosition, _openSound));\n    }\n    \n    public void CloseDoor()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _targetPosition = _closedPosition;\n        \n        if (_moveCoroutine != null)\n            StopCoroutine(_moveCoroutine);\n            \n        _moveCoroutine = StartCoroutine(MoveDoor(_closedPosition, _closeSound));\n    }\n    \n    private System.Collections.IEnumerator MoveDoor(Vector3 targetPos, AudioClip sound)\n    {\n        _isMoving = true;\n        Vector3 startPos = _doorTransform.localPosition;\n        float journey = 0f;\n        float distance = Vector3.Distance(startPos, targetPos);\n        \n        if (_audioSource != null && sound != null)\n            _audioSource.PlayOneShot(sound);\n        \n        while (journey <= 1f)\n        {\n            journey += Time.deltaTime * _openSpeed;\n            float curveValue = _openCurve.Evaluate(journey);\n            _doorTransform.localPosition = Vector3.Lerp(startPos, targetPos, curveValue);\n            yield return null;\n        }\n        \n        _doorTransform.localPosition = targetPos;\n        _isMoving = false;\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "moving platform between two points",
      "ideal_ir": {
        "class_name": "MovingPlatform",
        "components": [
          "Transform",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "pointA",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "pointB",
            "type": "Vector3",
            "default": "Vector3(10, 0, 0)"
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isMovingToB",
            "type": "bool",
            "default": true
          },
          {
            "name": "pauseDuration",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isPaused",
            "type": "bool",
            "default": false
          },
          {
            "name": "pauseTimer",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "move_between_points",
            "trigger": "every frame when not paused",
            "actions": [
              {
                "action": "move toward current target point at move speed"
              },
              {
                "action": "when reaching target point start pause timer and set paused to true"
              }
            ]
          },
          {
            "name": "handle_pause_at_endpoints",
            "trigger": "every frame when paused",
            "actions": [
              {
                "action": "increment pause timer"
              },
              {
                "action": "when pause timer exceeds pause duration switch target point and resume movement"
              }
            ]
          },
          {
            "name": "switch_direction",
            "trigger": "when reaching point A or point B",
            "actions": [
              {
                "action": "toggle movement direction between point A and point B"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class MovingPlatform : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private Transform _pointA;\n    [SerializeField] private Transform _pointB;\n    [SerializeField] private float _speed = 2f;\n    [SerializeField] private float _waitTime = 1f;\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Platform Settings\")]\n    [SerializeField] private bool _startAtPointA = true;\n    [SerializeField] private bool _moveOnStart = true;\n    [SerializeField] private LayerMask _passengerLayer = -1;\n    \n    private Vector3 _startPoint;\n    private Vector3 _endPoint;\n    private bool _movingToB = true;\n    private float _journeyLength;\n    private float _journeyTime;\n    private float _waitTimer;\n    private bool _isWaiting;\n    private bool _isMoving;\n    private Vector3 _lastPosition;\n    private Vector3 _platformVelocity;\n    \n    private void Start()\n    {\n        InitializePlatform();\n        \n        if (_moveOnStart)\n        {\n            StartMoving();\n        }\n    }\n    \n    private void InitializePlatform()\n    {\n        if (_pointA == null || _pointB == null)\n        {\n            Debug.LogError(\"MovingPlatform: Point A and Point B must be assigned!\");\n            enabled = false;\n            return;\n        }\n        \n        _startPoint = _pointA.position;\n        _endPoint = _pointB.position;\n        _journeyLength = Vector3.Distance(_startPoint, _endPoint);\n        \n        if (_startAtPointA)\n        {\n            transform.position = _startPoint;\n            _movingToB = true;\n        }\n        else\n        {\n            transform.position = _endPoint;\n            _movingToB = false;\n        }\n        \n        _lastPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        if (!_isMoving) return;\n        \n        if (_isWaiting)\n        {\n            HandleWaiting();\n        }\n        else\n        {\n            HandleMovement();\n        }\n        \n        CalculateVelocity();\n    }\n    \n    private void HandleWaiting()\n    {\n        _waitTimer -= Time.deltaTime;\n        \n        if (_waitTimer <= 0f)\n        {\n            _isWaiting = false;\n            _journeyTime = 0f;\n            SwapPoints();\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        _journeyTime += Time.deltaTime * _speed / _journeyLength;\n        \n        float curveValue = _movementCurve.Evaluate(_journeyTime);\n        Vector3 currentTarget = _movingToB ? _endPoint : _startPoint;\n        Vector3 currentStart = _movingToB ? _startPoint : _endPoint;\n        \n        transform.position = Vector3.Lerp(currentStart, currentTarget, curveValue);\n        \n        if (_journeyTime >= 1f)\n        {\n            transform.position = currentTarget;\n            \n            if (_waitTime > 0f)\n            {\n                _isWaiting = true;\n                _waitTimer = _waitTime;\n            }\n            else\n            {\n                _journeyTime = 0f;\n                SwapPoints();\n            }\n        }\n    }\n    \n    private void SwapPoints()\n    {\n        _movingToB = !_movingToB;\n    }\n    \n    private void CalculateVelocity()\n    {\n        _platformVelocity = (transform.position - _lastPosition) / Time.deltaTime;\n        _lastPosition = transform.position;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidPassenger(other))\n        {\n            AttachPassenger(other.transform);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsValidPassenger(other))\n        {\n            DetachPassenger(other.transform);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsValidPassenger(collision.collider))\n        {\n            AttachPassenger(collision.transform);\n        }\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        if (IsValidPassenger(collision.collider))\n        {\n            DetachPassenger(collision.transform);\n        }\n    }\n    \n    private bool IsValidPassenger(Collider collider)\n    {\n        return (_passengerLayer.value & (1 << collider.gameObject.layer)) != 0;\n    }\n    \n    private void AttachPassenger(Transform passenger)\n    {\n        passenger.SetParent(transform);\n        \n        Rigidbody passengerRb = passenger.GetComponent<Rigidbody>();\n        if (passengerRb != null)\n        {\n            passengerRb.velocity += _platformVelocity;\n        }\n    }\n    \n    private void DetachPassenger(Transform passenger)\n    {\n        passenger.SetParent(null);\n    }\n    \n    public void StartMoving()\n    {\n        _isMoving = true;\n        _journeyTime = 0f;\n        _isWaiting = false;\n    }\n    \n    public void StopMoving()\n    {\n        _isMoving = false;\n        _isWaiting = false;\n    }\n    \n    public void ResetToStart()\n    {\n        StopMoving();\n        transform.position = _startAtPointA ? _startPoint : _endPoint;\n        _movingToB = _startAtPointA;\n        _lastPosition = transform.position;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_pointA != null && _pointB != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(_pointA.position, _pointB.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_pointA.position, 0.3f);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_pointB.position, 0.3f);\n            \n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, transform.localScale);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "rotating saw blade hazard",
      "ideal_ir": {
        "class_name": "RotatingSawBlade",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 360
          },
          {
            "name": "damage",
            "type": "int",
            "default": 50
          },
          {
            "name": "sawSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "continuous_rotation",
            "trigger": "every frame",
            "actions": [
              {
                "action": "rotate around forward axis at rotation speed"
              }
            ]
          },
          {
            "name": "play_saw_sound",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "play saw sound continuously in loop"
              }
            ]
          },
          {
            "name": "damage_player",
            "trigger": "when player touches saw blade",
            "actions": [
              {
                "action": "deal damage amount to player"
              },
              {
                "action": "push player away from saw blade"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RotatingSawBlade : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 360f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private bool _enableMovement = false;\n    [SerializeField] private Transform[] _waypoints;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private bool _loopMovement = true;\n    [SerializeField] private bool _pingPongMovement = false;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 1;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotationSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private float _rotationVolume = 0.5f;\n    [SerializeField] private float _hitVolume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private GameObject _hitEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerHit;\n    public UnityEvent<Collision> OnHitObject;\n    \n    private int _currentWaypointIndex = 0;\n    private bool _movingForward = true;\n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    private void Start()\n    {\n        InitializeAudio();\n        InitializeParticles();\n        ValidateWaypoints();\n    }\n    \n    private void Update()\n    {\n        RotateBlade();\n        \n        if (_enableMovement && _waypoints != null && _waypoints.Length > 1)\n        {\n            MoveBlade();\n        }\n    }\n    \n    private void InitializeAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_rotationSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _rotationSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _rotationVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void InitializeParticles()\n    {\n        if (_sparkParticles == null)\n        {\n            _sparkParticles = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void ValidateWaypoints()\n    {\n        if (_enableMovement && (_waypoints == null || _waypoints.Length < 2))\n        {\n            Debug.LogWarning($\"RotatingSawBlade '{gameObject.name}' has movement enabled but insufficient waypoints!\");\n            _enableMovement = false;\n        }\n    }\n    \n    private void RotateBlade()\n    {\n        float rotationDirection = _clockwise ? -1f : 1f;\n        Vector3 rotation = _rotationAxis * _rotationSpeed * rotationDirection * Time.deltaTime;\n        transform.Rotate(rotation, Space.Self);\n    }\n    \n    private void MoveBlade()\n    {\n        Transform targetWaypoint = _waypoints[_currentWaypointIndex];\n        if (targetWaypoint == null) return;\n        \n        Vector3 direction = (targetWaypoint.position - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetWaypoint.position);\n        \n        if (distance < 0.1f)\n        {\n            UpdateWaypointIndex();\n        }\n        else\n        {\n            transform.position += direction * _moveSpeed * Time.deltaTime;\n        }\n    }\n    \n    private void UpdateWaypointIndex()\n    {\n        if (_pingPongMovement)\n        {\n            if (_movingForward)\n            {\n                _currentWaypointIndex++;\n                if (_currentWaypointIndex >= _waypoints.Length)\n                {\n                    _currentWaypointIndex = _waypoints.Length - 2;\n                    _movingForward = false;\n                }\n            }\n            else\n            {\n                _currentWaypointIndex--;\n                if (_currentWaypointIndex < 0)\n                {\n                    _currentWaypointIndex = 1;\n                    _movingForward = true;\n                }\n            }\n        }\n        else\n        {\n            _currentWaypointIndex++;\n            if (_currentWaypointIndex >= _waypoints.Length)\n            {\n                if (_loopMovement)\n                {\n                    _currentWaypointIndex = 0;\n                }\n                else\n                {\n                    _currentWaypointIndex = _waypoints.Length - 1;\n                    _enableMovement = false;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other.gameObject, other.transform.position);\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        HandleCollision(other.gameObject, other.transform.position);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.gameObject, collision.contacts[0].point);\n        OnHitObject?.Invoke(collision);\n    }\n    \n    private void OnCollisionStay(Collision collision)\n    {\n        HandleCollision(collision.gameObject, collision.contacts[0].point);\n    }\n    \n    private void HandleCollision(GameObject hitObject, Vector3 hitPoint)\n    {\n        if (!IsInDamageableLayer(hitObject)) return;\n        \n        if (CanDamageObject(hitObject))\n        {\n            DealDamage(hitObject);\n            PlayHitEffects(hitPoint);\n            \n            if (hitObject.CompareTag(\"Player\"))\n            {\n                OnPlayerHit?.Invoke(hitObject);\n            }\n            \n            _lastDamageTime[hitObject] = Time.time;\n        }\n    }\n    \n    private bool IsInDamageableLayer(GameObject obj)\n    {\n        return (_damageableLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    private bool CanDamageObject(GameObject obj)\n    {\n        if (!_lastDamageTime.ContainsKey(obj))\n        {\n            return true;\n        }\n        \n        return Time.time - _lastDamageTime[obj] >= _damageInterval;\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        // Try different common health interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a fallback for common health methods\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"Damage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"Hit\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // If it's a rigidbody, add some force\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * 10f, ForceMode.Impulse);\n        }\n    }\n    \n    private void PlayHitEffects(Vector3 hitPoint)\n    {\n        // Play hit sound\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound, _hitVolume);\n        }\n        \n        // Play spark particles\n        if (_sparkParticles != null)\n        {\n            _sparkParticles.transform.position = hitPoint;\n            _sparkParticles.Play();\n        }\n        \n        // Instantiate hit effect\n        if (_hitEffect != null)\n        {\n            GameObject effect = Instantiate(_hitEffect, hitPoint, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = speed;\n    }\n    \n    public void SetMoveSpeed(float speed)\n    {\n        _moveSpeed = speed;\n    }\n    \n    public void ToggleMovement()\n    {\n        _enableMovement = !_enableMovement;\n    }\n    \n    public void StopBlade()\n    {\n        _rotationSpeed = 0f;\n        _enableMovement = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public void StartBlade()\n    {\n        _rotationSpeed = Mathf.Abs(_rotationSpeed) == 0 ? 360f : Mathf.Abs(_rotationSpeed);\n        \n        if (_rotationSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_enableMovement && _waypoints != null && _waypoints.Length > 1)\n        {\n            Gizmos.color = Color.yellow;\n            \n            for (int i = 0; i < _waypoints.Length; i++)\n            {\n                if (_waypoints[i] == null) continue;\n                \n                Gizmos.DrawWireSphere(_waypoints[i].position, 0.3f);\n                \n                if (i < _waypoints.Length - 1 && _waypoints[i + 1] != null)\n                {\n                    Gizmos.DrawLine(_waypoints[i].position, _waypoints[i + 1].position);\n                }\n                else if (_loopMovement && !_pingPongMovement && _waypoints[0] != null)\n                {\n                    Gizmos.DrawLine(_waypoints[i].position, _waypoints[0].position);\n                }\n            }\n        }\n        \n        // Draw rotation axis\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, _rotationAxis.normalized);\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "lava floor that damages over time",
      "ideal_ir": {
        "class_name": "LavaFloor",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "damagePerSecond",
            "type": "float",
            "default": 10
          },
          {
            "name": "damageInterval",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "burnSoundEffect",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "damage_player_on_contact",
            "trigger": "when player enters the lava area",
            "actions": [
              {
                "action": "start applying damage to player over time"
              },
              {
                "action": "play burning sound effect"
              }
            ]
          },
          {
            "name": "continuous_damage",
            "trigger": "while player remains in contact with lava",
            "actions": [
              {
                "action": "deal damage to player at regular intervals"
              },
              {
                "action": "apply burning visual effect to player"
              }
            ]
          },
          {
            "name": "stop_damage",
            "trigger": "when player exits the lava area",
            "actions": [
              {
                "action": "stop applying damage to player"
              },
              {
                "action": "stop burning sound effect"
              },
              {
                "action": "remove burning visual effect from player"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LavaFloor : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private bool _continuousDamage = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _lavaParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sizzleSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerEnterLava;\n    public UnityEvent<GameObject> OnPlayerExitLava;\n    public UnityEvent<GameObject, float> OnPlayerDamaged;\n    \n    private bool _playerInLava = false;\n    private float _damageTimer = 0f;\n    private GameObject _currentPlayer;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_lavaParticles == null)\n            _lavaParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (_playerInLava && _continuousDamage)\n        {\n            _damageTimer += Time.deltaTime;\n            \n            if (_damageTimer >= _damageInterval)\n            {\n                DealDamage();\n                _damageTimer = 0f;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInLava = true;\n            _currentPlayer = other.gameObject;\n            _damageTimer = 0f;\n            \n            OnPlayerEnterLava?.Invoke(_currentPlayer);\n            \n            if (_audioSource && _sizzleSound)\n            {\n                _audioSource.clip = _sizzleSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            if (_lavaParticles)\n                _lavaParticles.Play();\n                \n            if (!_continuousDamage)\n                DealDamage();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            _playerInLava = false;\n            _currentPlayer = null;\n            _damageTimer = 0f;\n            \n            OnPlayerExitLava?.Invoke(other.gameObject);\n            \n            if (_audioSource)\n                _audioSource.Stop();\n                \n            if (_lavaParticles)\n                _lavaParticles.Stop();\n        }\n    }\n    \n    private void DealDamage()\n    {\n        if (_currentPlayer == null) return;\n        \n        var playerHealth = _currentPlayer.GetComponent<CharacterController>();\n        if (playerHealth != null)\n        {\n            OnPlayerDamaged?.Invoke(_currentPlayer, _damageAmount);\n            \n            if (_audioSource && _damageSound)\n            {\n                _audioSource.PlayOneShot(_damageSound);\n            }\n        }\n    }\n    \n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = Mathf.Max(0f, damage);\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = Mathf.Max(0.1f, interval);\n    }\n    \n    public void EnableLava(bool enable)\n    {\n        GetComponent<Collider>().enabled = enable;\n        \n        if (!enable && _playerInLava)\n        {\n            _playerInLava = false;\n            _currentPlayer = null;\n            \n            if (_audioSource)\n                _audioSource.Stop();\n                \n            if (_lavaParticles)\n                _lavaParticles.Stop();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "wind zone that pushes objects",
      "ideal_ir": {
        "class_name": "WindZone",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "windForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "windDirection",
            "type": "Vector3",
            "default": "Vector3.forward"
          },
          {
            "name": "affectRigidbodies",
            "type": "bool",
            "default": true
          },
          {
            "name": "affectParticles",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "push_rigidbody_objects",
            "trigger": "when rigidbody object enters wind zone",
            "actions": [
              {
                "action": "apply continuous force to rigidbody in wind direction with wind force strength"
              }
            ]
          },
          {
            "name": "stop_pushing_rigidbody",
            "trigger": "when rigidbody object exits wind zone",
            "actions": [
              {
                "action": "stop applying wind force to the rigidbody"
              }
            ]
          },
          {
            "name": "affect_particle_systems",
            "trigger": "when particle system enters wind zone",
            "actions": [
              {
                "action": "apply wind force to particles in the specified direction"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WindZone : MonoBehaviour\n{\n    [Header(\"Wind Properties\")]\n    [SerializeField] private float _windStrength = 10f;\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private bool _normalizeDirection = true;\n    \n    [Header(\"Wind Variation\")]\n    [SerializeField] private bool _enableTurbulence = true;\n    [SerializeField] private float _turbulenceStrength = 2f;\n    [SerializeField] private float _turbulenceFrequency = 1f;\n    [SerializeField] private bool _enableGustiness = false;\n    [SerializeField] private float _gustStrength = 5f;\n    [SerializeField] private float _gustFrequency = 0.5f;\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _useColliderBounds = true;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectParticles = true;\n    \n    [Header(\"Force Application\")]\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    [SerializeField] private bool _useDistanceFalloff = true;\n    [SerializeField] private AnimationCurve _falloffCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showGizmos = true;\n    [SerializeField] private Color _gizmoColor = Color.cyan;\n    \n    private Collider _zoneCollider;\n    private List<Rigidbody> _affectedRigidbodies = new List<Rigidbody>();\n    private List<ParticleSystem> _affectedParticles = new List<ParticleSystem>();\n    private Vector3 _normalizedDirection;\n    private float _turbulenceOffset;\n    private float _gustOffset;\n    \n    private void Start()\n    {\n        _zoneCollider = GetComponent<Collider>();\n        if (_zoneCollider == null)\n        {\n            Debug.LogWarning(\"WindZone requires a Collider component to define the wind area.\");\n        }\n        else\n        {\n            _zoneCollider.isTrigger = true;\n        }\n        \n        UpdateWindDirection();\n        \n        _turbulenceOffset = Random.Range(0f, 100f);\n        _gustOffset = Random.Range(0f, 100f);\n    }\n    \n    private void Update()\n    {\n        if (_normalizeDirection)\n        {\n            UpdateWindDirection();\n        }\n        \n        ApplyWindForces();\n    }\n    \n    private void UpdateWindDirection()\n    {\n        _normalizedDirection = _windDirection.normalized;\n    }\n    \n    private void ApplyWindForces()\n    {\n        float currentTime = Time.time;\n        Vector3 finalWindDirection = _normalizedDirection;\n        float finalWindStrength = _windStrength;\n        \n        // Apply turbulence\n        if (_enableTurbulence)\n        {\n            Vector3 turbulence = new Vector3(\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset, 0f) - 0.5f,\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset + 100f, 0f) - 0.5f,\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset + 200f, 0f) - 0.5f\n            );\n            \n            finalWindDirection += turbulence * _turbulenceStrength * 0.1f;\n            finalWindDirection = finalWindDirection.normalized;\n        }\n        \n        // Apply gustiness\n        if (_enableGustiness)\n        {\n            float gustMultiplier = 1f + (Mathf.PerlinNoise(currentTime * _gustFrequency + _gustOffset, 0f) - 0.5f) * _gustStrength * 0.2f;\n            finalWindStrength *= gustMultiplier;\n        }\n        \n        // Apply forces to rigidbodies\n        if (_affectRigidbodies)\n        {\n            for (int i = _affectedRigidbodies.Count - 1; i >= 0; i--)\n            {\n                if (_affectedRigidbodies[i] == null)\n                {\n                    _affectedRigidbodies.RemoveAt(i);\n                    continue;\n                }\n                \n                ApplyWindToRigidbody(_affectedRigidbodies[i], finalWindDirection, finalWindStrength);\n            }\n        }\n        \n        // Apply forces to particle systems\n        if (_affectParticles)\n        {\n            for (int i = _affectedParticles.Count - 1; i >= 0; i--)\n            {\n                if (_affectedParticles[i] == null)\n                {\n                    _affectedParticles.RemoveAt(i);\n                    continue;\n                }\n                \n                ApplyWindToParticles(_affectedParticles[i], finalWindDirection, finalWindStrength);\n            }\n        }\n    }\n    \n    private void ApplyWindToRigidbody(Rigidbody rb, Vector3 windDirection, float windStrength)\n    {\n        if (rb == null) return;\n        \n        float distanceMultiplier = 1f;\n        \n        if (_useDistanceFalloff && _zoneCollider != null)\n        {\n            Vector3 closestPoint = _zoneCollider.ClosestPoint(rb.position);\n            float distance = Vector3.Distance(rb.position, closestPoint);\n            float maxDistance = GetMaxDistanceInCollider();\n            \n            if (maxDistance > 0f)\n            {\n                float normalizedDistance = Mathf.Clamp01(distance / maxDistance);\n                distanceMultiplier = _falloffCurve.Evaluate(normalizedDistance);\n            }\n        }\n        \n        Vector3 force = windDirection * windStrength * distanceMultiplier * Time.deltaTime;\n        rb.AddForce(force, _forceMode);\n    }\n    \n    private void ApplyWindToParticles(ParticleSystem particles, Vector3 windDirection, float windStrength)\n    {\n        if (particles == null) return;\n        \n        var externalForces = particles.externalForces;\n        if (externalForces.enabled)\n        {\n            // If external forces are already enabled, we can't directly control them\n            // This is a limitation of Unity's particle system\n            return;\n        }\n        \n        var velocityOverLifetime = particles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        \n        float effectiveStrength = windStrength * 0.1f; // Scale down for particles\n        velocityOverLifetime.x = new ParticleSystem.MinMaxCurve(windDirection.x * effectiveStrength);\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(windDirection.y * effectiveStrength);\n        velocityOverLifetime.z = new ParticleSystem.MinMaxCurve(windDirection.z * effectiveStrength);\n    }\n    \n    private float GetMaxDistanceInCollider()\n    {\n        if (_zoneCollider == null) return 1f;\n        \n        Bounds bounds = _zoneCollider.bounds;\n        return Mathf.Max(bounds.size.x, bounds.size.y, bounds.size.z) * 0.5f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!IsInAffectedLayers(other.gameObject)) return;\n        \n        if (_affectRigidbodies)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && !_affectedRigidbodies.Contains(rb))\n            {\n                _affectedRigidbodies.Add(rb);\n            }\n        }\n        \n        if (_affectParticles)\n        {\n            ParticleSystem particles = other.GetComponent<ParticleSystem>();\n            if (particles != null && !_affectedParticles.Contains(particles))\n            {\n                _affectedParticles.Add(particles);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!IsInAffectedLayers(other.gameObject)) return;\n        \n        if (_affectRigidbodies)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                _affectedRigidbodies.Remove(rb);\n            }\n        }\n        \n        if (_affectParticles)\n        {\n            ParticleSystem particles = other.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                _affectedParticles.Remove(particles);\n                \n                // Reset particle velocity when leaving wind zone\n                var velocityOverLifetime = particles.velocityOverLifetime;\n                velocityOverLifetime.enabled = false;\n            }\n        }\n    }\n    \n    private bool IsInAffectedLayers(GameObject obj)\n    {\n        return (_affectedLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    public void SetWindDirection(Vector3 direction)\n    {\n        _windDirection = direction;\n        UpdateWindDirection();\n    }\n    \n    public void SetWindStrength(float strength)\n    {\n        _windStrength = Mathf.Max(0f, strength);\n    }\n    \n    public Vector3 GetCurrentWindDirection()\n    {\n        return _normalizedDirection;\n    }\n    \n    public float GetCurrentWindStrength()\n    {\n        return _windStrength;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = _gizmoColor;\n        \n        if (_zoneCollider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            \n            if (_zoneCollider is BoxCollider box)\n            {\n                Gizmos.DrawWireCube(box.center, box.size);\n            }\n            else if (_zoneCollider is SphereCollider sphere)\n            {\n                Gizmos.DrawWireSphere(sphere.center, sphere.radius);\n            }\n            else if (_zoneCollider is CapsuleCollider capsule)\n            {\n                Gizmos.DrawWireCube(capsule.center, new Vector3(capsule.radius * 2, capsule.height, capsule.radius * 2));\n            }\n        }\n        \n        // Draw wind direction arrows\n        Gizmos.matrix = Matrix4x4.identity;\n        Gizmos.color = Color.yellow;\n        \n        Vector3 center = transform.position;\n        Vector3 windDir = transform.TransformDirection(_windDirection.normalized);\n        \n        for (int i = 0; i < 5; i++)\n        {\n            Vector3 offset = Random.insideUnitSphere * 2f;\n            offset.y = Mathf.Abs(offset.y);\n            Vector3 start = center + offset;\n            Vector3 end = start + windDir * 3f;\n            \n            Gizmos.DrawLine(start, end);\n            \n            // Arrow head\n            Vector3 arrowHead1 = end - windDir * 0.5f + Vector3.Cross(windDir, Vector3.up) * 0.3f;\n            Vector3 arrowHead2 = end - windDir * 0.5f - Vector3.Cross(windDir, Vector3.up) * 0.3f;\n            Gizmos.DrawLine(end, arrowHead1);\n            Gizmos.DrawLine(end, arrowHead2);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "teleporter between two locations",
      "ideal_ir": {
        "class_name": "Teleporter",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "destinationPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "teleportCooldown",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "requiresPlayerTag",
            "type": "bool",
            "default": true
          },
          {
            "name": "teleportEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isOnCooldown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "teleport_player",
            "trigger": "when player enters teleporter trigger area and teleporter is not on cooldown",
            "actions": [
              {
                "action": "play teleport effect at current position"
              },
              {
                "action": "move player to destination position"
              },
              {
                "action": "play teleport effect at destination position"
              },
              {
                "action": "activate teleporter cooldown"
              }
            ]
          },
          {
            "name": "reset_cooldown",
            "trigger": "when cooldown timer expires",
            "actions": [
              {
                "action": "disable teleporter cooldown"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when teleporter is ready to use",
            "actions": [
              {
                "action": "display ready indicator or glow effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Teleporter : MonoBehaviour\n{\n    [Header(\"Teleporter Settings\")]\n    [SerializeField] private Transform _destinationPoint;\n    [SerializeField] private bool _isTwoWay = true;\n    [SerializeField] private float _teleportCooldown = 2f;\n    [SerializeField] private LayerMask _teleportLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _teleportEffect;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private float _effectDuration = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _useScaleAnimation = true;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    [SerializeField] private float _animationDuration = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectTeleported;\n    public UnityEvent OnTeleportActivated;\n    \n    private AudioSource _audioSource;\n    private bool _canTeleport = true;\n    private Teleporter _linkedTeleporter;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _teleportSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        FindLinkedTeleporter();\n        \n        if (_destinationPoint == null)\n        {\n            Debug.LogWarning($\"Teleporter {gameObject.name} has no destination point assigned!\");\n        }\n    }\n    \n    private void FindLinkedTeleporter()\n    {\n        if (_destinationPoint != null)\n        {\n            _linkedTeleporter = _destinationPoint.GetComponent<Teleporter>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canTeleport || _destinationPoint == null)\n            return;\n            \n        if (!IsValidTeleportTarget(other))\n            return;\n            \n        StartCoroutine(TeleportSequence(other.gameObject));\n    }\n    \n    private bool IsValidTeleportTarget(Collider other)\n    {\n        int objectLayer = 1 << other.gameObject.layer;\n        return (_teleportLayers.value & objectLayer) != 0;\n    }\n    \n    private System.Collections.IEnumerator TeleportSequence(GameObject target)\n    {\n        _canTeleport = false;\n        \n        if (_linkedTeleporter != null)\n        {\n            _linkedTeleporter._canTeleport = false;\n        }\n        \n        OnTeleportActivated.Invoke();\n        \n        if (_useScaleAnimation)\n        {\n            yield return StartCoroutine(AnimateScale(target, true));\n        }\n        \n        if (_teleportEffect != null)\n        {\n            _teleportEffect.Play();\n        }\n        \n        if (_audioSource != null && _teleportSound != null)\n        {\n            _audioSource.PlayOneShot(_teleportSound);\n        }\n        \n        yield return new WaitForSeconds(_effectDuration * 0.5f);\n        \n        PerformTeleport(target);\n        \n        OnObjectTeleported.Invoke(target);\n        \n        yield return new WaitForSeconds(_effectDuration * 0.5f);\n        \n        if (_useScaleAnimation)\n        {\n            yield return StartCoroutine(AnimateScale(target, false));\n        }\n        \n        yield return new WaitForSeconds(_teleportCooldown);\n        \n        _canTeleport = true;\n        \n        if (_linkedTeleporter != null)\n        {\n            _linkedTeleporter._canTeleport = true;\n        }\n    }\n    \n    private void PerformTeleport(GameObject target)\n    {\n        CharacterController characterController = target.GetComponent<CharacterController>();\n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        \n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            target.transform.position = _destinationPoint.position;\n            target.transform.rotation = _destinationPoint.rotation;\n            characterController.enabled = true;\n        }\n        else\n        {\n            target.transform.position = _destinationPoint.position;\n            target.transform.rotation = _destinationPoint.rotation;\n        }\n        \n        if (targetRigidbody != null)\n        {\n            targetRigidbody.velocity = Vector3.zero;\n            targetRigidbody.angularVelocity = Vector3.zero;\n        }\n    }\n    \n    private System.Collections.IEnumerator AnimateScale(GameObject target, bool scaleDown)\n    {\n        Vector3 originalScale = target.transform.localScale;\n        Vector3 targetScale = scaleDown ? Vector3.zero : originalScale;\n        Vector3 startScale = scaleDown ? originalScale : Vector3.zero;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / _animationDuration;\n            float curveValue = _scaleCurve.Evaluate(normalizedTime);\n            \n            target.transform.localScale = Vector3.Lerp(startScale, targetScale, curveValue);\n            \n            yield return null;\n        }\n        \n        target.transform.localScale = targetScale;\n    }\n    \n    public void SetDestination(Transform newDestination)\n    {\n        _destinationPoint = newDestination;\n        FindLinkedTeleporter();\n    }\n    \n    public void ActivateTeleporter()\n    {\n        _canTeleport = true;\n    }\n    \n    public void DeactivateTeleporter()\n    {\n        _canTeleport = false;\n    }\n    \n    public void TeleportObject(GameObject target)\n    {\n        if (_canTeleport && _destinationPoint != null && IsValidTeleportTarget(target.GetComponent<Collider>()))\n        {\n            StartCoroutine(TeleportSequence(target));\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_destinationPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _destinationPoint.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_destinationPoint.position, 1f);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "breakable wall that shatters on impact",
      "ideal_ir": {
        "class_name": "BreakableWall",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "shatterForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "fragmentCount",
            "type": "int",
            "default": 8
          }
        ],
        "behaviors": [
          {
            "name": "shatter_on_impact",
            "trigger": "when collision occurs with sufficient force",
            "actions": [
              {
                "action": "reduce health by collision force amount"
              },
              {
                "action": "check if health reaches zero or below"
              }
            ]
          },
          {
            "name": "break_wall",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "create multiple fragment pieces at wall position"
              },
              {
                "action": "apply explosive force to each fragment in random directions"
              },
              {
                "action": "play shattering sound effect"
              },
              {
                "action": "spawn particle effect at break location"
              },
              {
                "action": "destroy original wall object"
              }
            ]
          },
          {
            "name": "show_damage",
            "trigger": "when health decreases but wall not broken",
            "actions": [
              {
                "action": "display cracks on wall surface based on damage amount"
              },
              {
                "action": "play impact sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class BreakableWall : MonoBehaviour\n{\n    [Header(\"Breaking Settings\")]\n    [SerializeField] private float _breakForce = 10f;\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private bool _breakOnAnyImpact = false;\n    [SerializeField] private string[] _breakableTags = { \"Player\", \"Projectile\" };\n    \n    [Header(\"Shatter Effects\")]\n    [SerializeField] private GameObject _shatterPrefab;\n    [SerializeField] private int _fragmentCount = 20;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private Material _fragmentMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWallBroken;\n    \n    private bool _isBroken = false;\n    private Collider _wallCollider;\n    private MeshRenderer _meshRenderer;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _wallCollider = GetComponent<Collider>();\n        _meshRenderer = GetComponent<MeshRenderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isBroken) return;\n        \n        bool canBreak = _breakOnAnyImpact;\n        \n        if (!canBreak)\n        {\n            foreach (string tag in _breakableTags)\n            {\n                if (collision.gameObject.CompareTag(tag))\n                {\n                    canBreak = true;\n                    break;\n                }\n            }\n        }\n        \n        if (canBreak)\n        {\n            float impactForce = collision.relativeVelocity.magnitude;\n            \n            if (impactForce >= _breakForce)\n            {\n                TakeDamage(_health);\n            }\n            else\n            {\n                TakeDamage(impactForce * 10f);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isBroken) return;\n        \n        foreach (string tag in _breakableTags)\n        {\n            if (other.CompareTag(tag))\n            {\n                TakeDamage(_health);\n                break;\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isBroken) return;\n        \n        _health -= damage;\n        \n        if (_health <= 0f)\n        {\n            BreakWall();\n        }\n    }\n    \n    public void BreakWall()\n    {\n        if (_isBroken) return;\n        \n        _isBroken = true;\n        \n        PlayBreakSound();\n        CreateShatterEffect();\n        OnWallBroken?.Invoke();\n        \n        if (_wallCollider != null)\n            _wallCollider.enabled = false;\n        \n        if (_meshRenderer != null)\n            _meshRenderer.enabled = false;\n        \n        StartCoroutine(DestroyAfterDelay(5f));\n    }\n    \n    private void PlayBreakSound()\n    {\n        if (_breakSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _breakSound;\n            _audioSource.volume = _volume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void CreateShatterEffect()\n    {\n        Vector3 center = transform.position;\n        Bounds bounds = GetComponent<Renderer>().bounds;\n        \n        if (_shatterPrefab != null)\n        {\n            GameObject shatterEffect = Instantiate(_shatterPrefab, center, transform.rotation);\n            Destroy(shatterEffect, 10f);\n        }\n        else\n        {\n            CreateProceduralFragments(center, bounds);\n        }\n    }\n    \n    private void CreateProceduralFragments(Vector3 center, Bounds bounds)\n    {\n        for (int i = 0; i < _fragmentCount; i++)\n        {\n            GameObject fragment = CreateFragment(bounds);\n            \n            Vector3 randomPos = new Vector3(\n                Random.Range(bounds.min.x, bounds.max.x),\n                Random.Range(bounds.min.y, bounds.max.y),\n                Random.Range(bounds.min.z, bounds.max.z)\n            );\n            \n            fragment.transform.position = randomPos;\n            \n            Rigidbody rb = fragment.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 explosionDir = (randomPos - center).normalized;\n                rb.AddForce(explosionDir * _explosionForce + Vector3.up * _explosionForce * 0.5f);\n                rb.AddTorque(Random.insideUnitSphere * _explosionForce);\n            }\n            \n            Destroy(fragment, Random.Range(3f, 8f));\n        }\n    }\n    \n    private GameObject CreateFragment(Bounds bounds)\n    {\n        GameObject fragment = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        \n        float scale = Random.Range(0.1f, 0.3f);\n        fragment.transform.localScale = Vector3.one * scale;\n        \n        Rigidbody rb = fragment.AddComponent<Rigidbody>();\n        rb.mass = scale;\n        \n        if (_fragmentMaterial != null)\n        {\n            fragment.GetComponent<Renderer>().material = _fragmentMaterial;\n        }\n        else if (_meshRenderer != null && _meshRenderer.material != null)\n        {\n            fragment.GetComponent<Renderer>().material = _meshRenderer.material;\n        }\n        \n        fragment.AddComponent<FragmentBehavior>();\n        \n        return fragment;\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    public void ForceBreak()\n    {\n        BreakWall();\n    }\n    \n    public bool IsBroken()\n    {\n        return _isBroken;\n    }\n    \n    public float GetHealth()\n    {\n        return _health;\n    }\n    \n    private class FragmentBehavior : MonoBehaviour\n    {\n        private void Start()\n        {\n            StartCoroutine(FadeOut());\n        }\n        \n        private IEnumerator FadeOut()\n        {\n            yield return new WaitForSeconds(2f);\n            \n            Renderer renderer = GetComponent<Renderer>();\n            Material material = renderer.material;\n            Color originalColor = material.color;\n            \n            float fadeTime = 1f;\n            float elapsed = 0f;\n            \n            while (elapsed < fadeTime)\n            {\n                elapsed += Time.deltaTime;\n                float alpha = Mathf.Lerp(1f, 0f, elapsed / fadeTime);\n                material.color = new Color(originalColor.r, originalColor.g, originalColor.b, alpha);\n                yield return null;\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "falling boulder triggered by proximity",
      "ideal_ir": {
        "class_name": "FallingBoulder",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "hasTriggered",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "trigger_fall",
            "trigger": "when player enters detection radius and boulder has not been triggered yet",
            "actions": [
              {
                "action": "set hasTriggered to true"
              },
              {
                "action": "enable physics on the boulder"
              },
              {
                "action": "apply downward force to make boulder fall"
              },
              {
                "action": "play falling sound effect"
              }
            ]
          },
          {
            "name": "impact_ground",
            "trigger": "when boulder collides with ground or solid surface",
            "actions": [
              {
                "action": "play impact sound effect"
              },
              {
                "action": "create dust particle effect at impact point"
              },
              {
                "action": "apply screen shake effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FallingBoulder : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Boulder Settings\")]\n    [SerializeField] private float _fallSpeed = 10f;\n    [SerializeField] private float _fallAcceleration = 9.81f;\n    [SerializeField] private float _maxFallSpeed = 20f;\n    [SerializeField] private float _destroyDelay = 3f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _triggerSound;\n    [SerializeField] private AudioClip _impactSound;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 50f;\n    [SerializeField] private float _damageRadius = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _isTriggered = false;\n    private bool _hasFallen = false;\n    private Vector3 _initialPosition;\n    private float _currentFallSpeed = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _initialPosition = transform.position;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n    }\n    \n    private void Update()\n    {\n        if (!_isTriggered && !_hasFallen)\n        {\n            CheckForPlayer();\n        }\n        \n        if (_isTriggered && !_hasFallen)\n        {\n            HandleFalling();\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        \n        foreach (Collider player in playersInRange)\n        {\n            if (player.CompareTag(_playerTag))\n            {\n                TriggerFall();\n                break;\n            }\n        }\n    }\n    \n    private void TriggerFall()\n    {\n        if (_isTriggered) return;\n        \n        _isTriggered = true;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        \n        if (_triggerSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_triggerSound);\n        }\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Play();\n        }\n    }\n    \n    private void HandleFalling()\n    {\n        _currentFallSpeed += _fallAcceleration * Time.deltaTime;\n        _currentFallSpeed = Mathf.Min(_currentFallSpeed, _maxFallSpeed);\n        \n        Vector3 velocity = _rigidbody.velocity;\n        velocity.y = -_currentFallSpeed;\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasFallen) return;\n        \n        if (collision.gameObject.CompareTag(\"Ground\") || collision.gameObject.layer == LayerMask.NameToLayer(\"Ground\"))\n        {\n            HandleImpact();\n        }\n        else if (collision.gameObject.CompareTag(_playerTag))\n        {\n            DealDamageToPlayer(collision.gameObject);\n            HandleImpact();\n        }\n    }\n    \n    private void HandleImpact()\n    {\n        _hasFallen = true;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_impactSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_impactSound);\n        }\n        \n        DealAreaDamage();\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n            _dustEffect.Play();\n        }\n        \n        Invoke(nameof(DestroyBoulder), _destroyDelay);\n    }\n    \n    private void DealDamageToPlayer(GameObject player)\n    {\n        var playerHealth = player.GetComponent<Health>();\n        if (playerHealth != null)\n        {\n            playerHealth.TakeDamage(_damageAmount);\n        }\n    }\n    \n    private void DealAreaDamage()\n    {\n        Collider[] objectsInDamageRadius = Physics.OverlapSphere(transform.position, _damageRadius);\n        \n        foreach (Collider obj in objectsInDamageRadius)\n        {\n            if (obj.CompareTag(_playerTag))\n            {\n                var health = obj.GetComponent<Health>();\n                if (health != null)\n                {\n                    float distance = Vector3.Distance(transform.position, obj.transform.position);\n                    float damageMultiplier = 1f - (distance / _damageRadius);\n                    float finalDamage = _damageAmount * damageMultiplier;\n                    health.TakeDamage(finalDamage);\n                }\n            }\n        }\n    }\n    \n    private void DestroyBoulder()\n    {\n        Destroy(gameObject);\n    }\n    \n    public void ResetBoulder()\n    {\n        transform.position = _initialPosition;\n        _isTriggered = false;\n        _hasFallen = false;\n        _currentFallSpeed = 0f;\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _damageRadius);\n    }\n    \n    [System.Serializable]\n    public class Health : MonoBehaviour\n    {\n        [SerializeField] private float _maxHealth = 100f;\n        [SerializeField] private float _currentHealth;\n        \n        private void Start()\n        {\n            _currentHealth = _maxHealth;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            _currentHealth -= damage;\n            _currentHealth = Mathf.Max(0, _currentHealth);\n            \n            if (_currentHealth <= 0)\n            {\n                Die();\n            }\n        }\n        \n        public void Heal(float amount)\n        {\n            _currentHealth += amount;\n            _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        }\n        \n        private void Die()\n        {\n            gameObject.SetActive(false);\n        }\n        \n        public float GetCurrentHealth()\n        {\n            return _currentHealth;\n        }\n        \n        public float GetMaxHealth()\n        {\n            return _maxHealth;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "laser beam that toggles on and off",
      "ideal_ir": {
        "class_name": "LaserBeam",
        "components": [
          "LineRenderer",
          "Light"
        ],
        "fields": [
          {
            "name": "toggleInterval",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          },
          {
            "name": "beamWidth",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "beamColor",
            "type": "Color",
            "default": "red"
          }
        ],
        "behaviors": [
          {
            "name": "toggle_laser_periodically",
            "trigger": "every toggle interval seconds",
            "actions": [
              {
                "action": "switch laser beam visibility state"
              },
              {
                "action": "toggle light component on or off"
              },
              {
                "action": "update beam active status"
              }
            ]
          },
          {
            "name": "initialize_laser",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "set line renderer width to beam width"
              },
              {
                "action": "set line renderer color to beam color"
              },
              {
                "action": "position beam from start point to end point"
              },
              {
                "action": "configure light intensity and color"
              }
            ]
          },
          {
            "name": "update_beam_appearance",
            "trigger": "when laser state changes",
            "actions": [
              {
                "action": "show or hide line renderer based on active state"
              },
              {
                "action": "enable or disable light component based on active state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class LaserBeam : MonoBehaviour\n{\n    [Header(\"Laser Settings\")]\n    [SerializeField] private bool _startActive = true;\n    [SerializeField] private float _toggleInterval = 2f;\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private LineRenderer _lineRenderer;\n    [SerializeField] private Transform _startPoint;\n    [SerializeField] private Transform _endPoint;\n    [SerializeField] private ParticleSystem _startEffect;\n    [SerializeField] private ParticleSystem _endEffect;\n    [SerializeField] private Light _laserLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    [SerializeField] private AudioClip _loopSound;\n    \n    [Header(\"Raycast Settings\")]\n    [SerializeField] private float _maxDistance = 100f;\n    [SerializeField] private float _damageInterval = 0.1f;\n    \n    private bool _isActive;\n    private float _toggleTimer;\n    private float _damageTimer;\n    private Collider _currentTarget;\n    private Vector3 _hitPoint;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _isActive = _startActive;\n        _toggleTimer = _toggleInterval;\n        UpdateLaserState();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_lineRenderer == null)\n            _lineRenderer = GetComponent<LineRenderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_startPoint == null)\n            _startPoint = transform;\n            \n        if (_lineRenderer != null)\n        {\n            _lineRenderer.positionCount = 2;\n            _lineRenderer.useWorldSpace = true;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleToggleTimer();\n        \n        if (_isActive)\n        {\n            UpdateLaserRaycast();\n            HandleDamage();\n        }\n    }\n    \n    private void HandleToggleTimer()\n    {\n        if (_toggleInterval > 0)\n        {\n            _toggleTimer -= Time.deltaTime;\n            if (_toggleTimer <= 0)\n            {\n                ToggleLaser();\n                _toggleTimer = _toggleInterval;\n            }\n        }\n    }\n    \n    private void UpdateLaserRaycast()\n    {\n        Vector3 startPos = _startPoint.position;\n        Vector3 direction = _endPoint != null ? (_endPoint.position - startPos).normalized : transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(startPos, direction, out hit, _maxDistance, _damageableLayers))\n        {\n            _hitPoint = hit.point;\n            _currentTarget = hit.collider;\n        }\n        else\n        {\n            _hitPoint = startPos + direction * _maxDistance;\n            _currentTarget = null;\n        }\n        \n        UpdateVisuals();\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_lineRenderer != null)\n        {\n            _lineRenderer.SetPosition(0, _startPoint.position);\n            _lineRenderer.SetPosition(1, _hitPoint);\n            _lineRenderer.enabled = _isActive;\n        }\n        \n        if (_startEffect != null)\n        {\n            if (_isActive && !_startEffect.isPlaying)\n                _startEffect.Play();\n            else if (!_isActive && _startEffect.isPlaying)\n                _startEffect.Stop();\n        }\n        \n        if (_endEffect != null)\n        {\n            _endEffect.transform.position = _hitPoint;\n            if (_isActive && !_endEffect.isPlaying)\n                _endEffect.Play();\n            else if (!_isActive && _endEffect.isPlaying)\n                _endEffect.Stop();\n        }\n        \n        if (_laserLight != null)\n            _laserLight.enabled = _isActive;\n    }\n    \n    private void HandleDamage()\n    {\n        if (_currentTarget == null || _damage <= 0)\n            return;\n            \n        _damageTimer += Time.deltaTime;\n        if (_damageTimer >= _damageInterval)\n        {\n            ApplyDamage(_currentTarget);\n            _damageTimer = 0f;\n        }\n    }\n    \n    private void ApplyDamage(Collider target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            // Apply damage to player using standard Unity components\n            var rigidbody = target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                Vector3 knockback = (_hitPoint - _startPoint.position).normalized * _damage * 0.1f;\n                rigidbody.AddForce(knockback, ForceMode.Impulse);\n            }\n        }\n        \n        // Send damage message to any component that might handle it\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        target.SendMessage(\"OnLaserHit\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void ToggleLaser()\n    {\n        _isActive = !_isActive;\n        UpdateLaserState();\n    }\n    \n    public void SetLaserActive(bool active)\n    {\n        _isActive = active;\n        UpdateLaserState();\n    }\n    \n    private void UpdateLaserState()\n    {\n        if (_audioSource != null)\n        {\n            if (_isActive)\n            {\n                if (_activationSound != null)\n                    _audioSource.PlayOneShot(_activationSound);\n                    \n                if (_loopSound != null)\n                {\n                    _audioSource.clip = _loopSound;\n                    _audioSource.loop = true;\n                    _audioSource.Play();\n                }\n            }\n            else\n            {\n                if (_deactivationSound != null)\n                    _audioSource.PlayOneShot(_deactivationSound);\n                    \n                if (_audioSource.isPlaying && _audioSource.clip == _loopSound)\n                    _audioSource.Stop();\n            }\n        }\n        \n        UpdateVisuals();\n        _damageTimer = 0f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_startPoint != null)\n        {\n            Gizmos.color = _isActive ? Color.red : Color.gray;\n            Vector3 direction = _endPoint != null ? (_endPoint.position - _startPoint.position).normalized : transform.forward;\n            Gizmos.DrawRay(_startPoint.position, direction * _maxDistance);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_startEffect != null && _startEffect.isPlaying)\n            _startEffect.Stop();\n            \n        if (_endEffect != null && _endEffect.isPlaying)\n            _endEffect.Stop();\n            \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "conveyor belt that moves objects",
      "ideal_ir": {
        "class_name": "ConveyorBelt",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "beltSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "beltDirection",
            "type": "Vector3",
            "default": "Vector3.forward"
          }
        ],
        "behaviors": [
          {
            "name": "move_objects_on_belt",
            "trigger": "when object is touching the conveyor belt surface",
            "actions": [
              {
                "action": "apply force to the object in the belt direction at belt speed"
              }
            ]
          },
          {
            "name": "continuous_belt_movement",
            "trigger": "every frame while belt is active",
            "actions": [
              {
                "action": "move belt surface texture in the direction of movement to create visual motion effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ConveyorBelt : MonoBehaviour\n{\n    [Header(\"Conveyor Settings\")]\n    [SerializeField] private float _speed = 2f;\n    [SerializeField] private Vector3 _direction = Vector3.forward;\n    [SerializeField] private bool _isActive = true;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Material _beltMaterial;\n    [SerializeField] private float _textureScrollSpeed = 1f;\n    [SerializeField] private string _texturePropertyName = \"_MainTex\";\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private bool _useRigidbodyForce = true;\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _conveyorSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private List<Rigidbody> _objectsOnBelt = new List<Rigidbody>();\n    private List<Transform> _kinematicObjects = new List<Transform>();\n    private Renderer _beltRenderer;\n    private Vector2 _textureOffset;\n    private Vector3 _normalizedDirection;\n    \n    private void Start()\n    {\n        _normalizedDirection = _direction.normalized;\n        _beltRenderer = GetComponent<Renderer>();\n        \n        SetupAudio();\n        \n        if (_beltRenderer != null && _beltMaterial != null)\n        {\n            _beltRenderer.material = _beltMaterial;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _conveyorSound != null)\n        {\n            _audioSource.clip = _conveyorSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            \n            if (_isActive)\n            {\n                _audioSource.Play();\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isActive) return;\n        \n        UpdateTextureAnimation();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_isActive) return;\n        \n        MoveObjectsOnBelt();\n    }\n    \n    private void UpdateTextureAnimation()\n    {\n        if (_beltRenderer != null && _beltRenderer.material != null)\n        {\n            _textureOffset.x += _speed * _textureScrollSpeed * Time.deltaTime;\n            _beltRenderer.material.SetTextureOffset(_texturePropertyName, _textureOffset);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null)\n        {\n            if (_isActive && !_audioSource.isPlaying && _conveyorSound != null)\n            {\n                _audioSource.Play();\n            }\n            else if (!_isActive && _audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void MoveObjectsOnBelt()\n    {\n        Vector3 movement = _normalizedDirection * _speed;\n        \n        // Move rigidbody objects\n        for (int i = _objectsOnBelt.Count - 1; i >= 0; i--)\n        {\n            if (_objectsOnBelt[i] == null)\n            {\n                _objectsOnBelt.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody rb = _objectsOnBelt[i];\n            \n            if (_useRigidbodyForce)\n            {\n                rb.AddForce(movement, _forceMode);\n            }\n            else\n            {\n                rb.velocity = new Vector3(movement.x, rb.velocity.y, movement.z);\n            }\n        }\n        \n        // Move kinematic objects\n        for (int i = _kinematicObjects.Count - 1; i >= 0; i--)\n        {\n            if (_kinematicObjects[i] == null)\n            {\n                _kinematicObjects.RemoveAt(i);\n                continue;\n            }\n            \n            Transform obj = _kinematicObjects[i];\n            obj.Translate(movement * Time.fixedDeltaTime, Space.World);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!IsInAffectedLayer(other.gameObject)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            if (rb.isKinematic)\n            {\n                if (!_kinematicObjects.Contains(other.transform))\n                {\n                    _kinematicObjects.Add(other.transform);\n                }\n            }\n            else\n            {\n                if (!_objectsOnBelt.Contains(rb))\n                {\n                    _objectsOnBelt.Add(rb);\n                }\n            }\n        }\n        else\n        {\n            // Objects without rigidbody are moved as transforms\n            if (!_kinematicObjects.Contains(other.transform))\n            {\n                _kinematicObjects.Add(other.transform);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!IsInAffectedLayer(other.gameObject)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            _objectsOnBelt.Remove(rb);\n        }\n        \n        _kinematicObjects.Remove(other.transform);\n    }\n    \n    private bool IsInAffectedLayer(GameObject obj)\n    {\n        return (_affectedLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_audioSource != null)\n        {\n            if (_isActive && _conveyorSound != null)\n            {\n                _audioSource.Play();\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    public void SetSpeed(float newSpeed)\n    {\n        _speed = newSpeed;\n    }\n    \n    public void SetDirection(Vector3 newDirection)\n    {\n        _direction = newDirection;\n        _normalizedDirection = _direction.normalized;\n    }\n    \n    public void ReverseDirection()\n    {\n        _direction = -_direction;\n        _normalizedDirection = _direction.normalized;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = transform.position;\n        Vector3 direction = _direction.normalized;\n        \n        // Draw direction arrow\n        Gizmos.DrawRay(center, direction * 2f);\n        Gizmos.DrawWireCube(center + direction * 1.8f, Vector3.one * 0.2f);\n        \n        // Draw conveyor bounds\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.matrix = transform.localToWorldMatrix;\n            \n            if (col is BoxCollider boxCol)\n            {\n                Gizmos.DrawWireCube(boxCol.center, boxCol.size);\n            }\n            else if (col is CapsuleCollider capsuleCol)\n            {\n                Gizmos.DrawWireCube(capsuleCol.center, new Vector3(capsuleCol.radius * 2, capsuleCol.height, capsuleCol.radius * 2));\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "electrified floor that pulses",
      "ideal_ir": {
        "class_name": "ElectrifiedFloor",
        "components": [
          "Renderer",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "pulseInterval",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "pulseDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 10
          },
          {
            "name": "maxBrightness",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "minBrightness",
            "type": "float",
            "default": 0.3
          }
        ],
        "behaviors": [
          {
            "name": "pulse_electricity",
            "trigger": "every pulse interval seconds",
            "actions": [
              {
                "action": "play electrical crackling sound"
              },
              {
                "action": "increase material emission brightness to maximum over pulse duration"
              },
              {
                "action": "decrease material emission brightness to minimum after pulse duration"
              },
              {
                "action": "create electrical particle effects during pulse"
              }
            ]
          },
          {
            "name": "damage_on_contact",
            "trigger": "when player or enemy touches the floor during electrical pulse",
            "actions": [
              {
                "action": "deal damage amount to touching entity"
              },
              {
                "action": "play electrical shock sound"
              },
              {
                "action": "create spark particle effects at contact point"
              }
            ]
          },
          {
            "name": "warning_flicker",
            "trigger": "half a second before each electrical pulse",
            "actions": [
              {
                "action": "briefly flicker material emission"
              },
              {
                "action": "play subtle electrical humming sound"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class ElectrifiedFloor : MonoBehaviour\n{\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _electricMaterial;\n    [SerializeField] private Color _baseColor = Color.blue;\n    [SerializeField] private Color _pulseColor = Color.white;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Electrical Effects\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private float _knockbackForce = 500f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _electricHumSound;\n    [SerializeField] private AudioClip _zapSound;\n    [SerializeField] private float _humVolume = 0.3f;\n    [SerializeField] private float _zapVolume = 0.7f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private Light _electricLight;\n    \n    private Renderer _renderer;\n    private Collider _floorCollider;\n    private float _pulseTimer;\n    private bool _isActive = true;\n    private System.Collections.Generic.HashSet<GameObject> _objectsOnFloor = new System.Collections.Generic.HashSet<GameObject>();\n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = new System.Collections.Generic.Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        InitializeComponents();\n        StartCoroutine(PulseEffect());\n        \n        if (_audioSource && _electricHumSound)\n        {\n            _audioSource.clip = _electricHumSound;\n            _audioSource.volume = _humVolume;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _floorCollider = GetComponent<Collider>();\n        \n        if (!_floorCollider)\n        {\n            _floorCollider = gameObject.AddComponent<BoxCollider>();\n            _floorCollider.isTrigger = true;\n        }\n        \n        if (!_audioSource)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_renderer && _electricMaterial)\n        {\n            _renderer.material = _electricMaterial;\n        }\n        \n        if (_sparkParticles)\n        {\n            _sparkParticles.Play();\n        }\n    }\n\n    private void Update()\n    {\n        if (_isActive)\n        {\n            DamageObjectsOnFloor();\n            UpdateLightIntensity();\n        }\n    }\n\n    private IEnumerator PulseEffect()\n    {\n        while (true)\n        {\n            _pulseTimer += Time.deltaTime * _pulseSpeed;\n            \n            if (_renderer && _renderer.material)\n            {\n                float pulseValue = _pulseCurve.Evaluate(Mathf.PingPong(_pulseTimer, 1f));\n                Color currentColor = Color.Lerp(_baseColor, _pulseColor, pulseValue);\n                \n                if (_renderer.material.HasProperty(\"_Color\"))\n                {\n                    _renderer.material.color = currentColor;\n                }\n                else if (_renderer.material.HasProperty(\"_BaseColor\"))\n                {\n                    _renderer.material.SetColor(\"_BaseColor\", currentColor);\n                }\n                \n                if (_renderer.material.HasProperty(\"_EmissionColor\"))\n                {\n                    _renderer.material.SetColor(\"_EmissionColor\", currentColor * 0.5f);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n\n    private void UpdateLightIntensity()\n    {\n        if (_electricLight)\n        {\n            float pulseValue = _pulseCurve.Evaluate(Mathf.PingPong(_pulseTimer, 1f));\n            _electricLight.intensity = Mathf.Lerp(0.5f, 2f, pulseValue);\n            _electricLight.color = Color.Lerp(_baseColor, _pulseColor, pulseValue);\n        }\n    }\n\n    private void DamageObjectsOnFloor()\n    {\n        foreach (GameObject obj in _objectsOnFloor)\n        {\n            if (obj == null) continue;\n            \n            if (!_lastDamageTime.ContainsKey(obj))\n            {\n                _lastDamageTime[obj] = 0f;\n            }\n            \n            if (Time.time - _lastDamageTime[obj] >= _damageInterval)\n            {\n                ApplyElectricalDamage(obj);\n                _lastDamageTime[obj] = Time.time;\n            }\n        }\n    }\n\n    private void ApplyElectricalDamage(GameObject target)\n    {\n        // Apply damage if target has health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Try to find common health method names\n            var healthType = healthComponent.GetType();\n            var takeDamageMethod = healthType.GetMethod(\"TakeDamage\");\n            var damageMethod = healthType.GetMethod(\"Damage\");\n            \n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n            else if (damageMethod != null)\n            {\n                damageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Apply knockback\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.5f; // Add upward force\n            rb.AddForce(knockbackDirection * _knockbackForce, ForceMode.Impulse);\n        }\n        \n        // Play zap sound\n        if (_audioSource && _zapSound)\n        {\n            _audioSource.PlayOneShot(_zapSound, _zapVolume);\n        }\n        \n        // Spawn spark effect at target position\n        if (_sparkParticles)\n        {\n            _sparkParticles.transform.position = target.transform.position;\n            _sparkParticles.Emit(10);\n        }\n        \n        // Screen shake effect for player\n        if (target.CompareTag(\"Player\"))\n        {\n            StartCoroutine(ScreenShake());\n        }\n    }\n\n    private IEnumerator ScreenShake()\n    {\n        Camera mainCamera = Camera.main;\n        if (mainCamera == null) yield break;\n        \n        Vector3 originalPosition = mainCamera.transform.position;\n        float shakeDuration = 0.2f;\n        float shakeIntensity = 0.1f;\n        \n        float elapsed = 0f;\n        while (elapsed < shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * shakeIntensity;\n            float y = Random.Range(-1f, 1f) * shakeIntensity;\n            \n            mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        mainCamera.transform.position = originalPosition;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidTarget(other.gameObject))\n        {\n            _objectsOnFloor.Add(other.gameObject);\n            \n            // Immediate damage on entry\n            if (_isActive)\n            {\n                ApplyElectricalDamage(other.gameObject);\n                _lastDamageTime[other.gameObject] = Time.time;\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (_objectsOnFloor.Contains(other.gameObject))\n        {\n            _objectsOnFloor.Remove(other.gameObject);\n            _lastDamageTime.Remove(other.gameObject);\n        }\n    }\n\n    private bool IsValidTarget(GameObject target)\n    {\n        return (_affectedLayers.value & (1 << target.layer)) != 0;\n    }\n\n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_sparkParticles)\n        {\n            if (active)\n                _sparkParticles.Play();\n            else\n                _sparkParticles.Stop();\n        }\n        \n        if (_electricLight)\n        {\n            _electricLight.enabled = active;\n        }\n        \n        if (_audioSource)\n        {\n            if (active && !_audioSource.isPlaying)\n                _audioSource.Play();\n            else if (!active && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n    }\n\n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = damage;\n    }\n\n    public void SetPulseSpeed(float speed)\n    {\n        _pulseSpeed = speed;\n    }\n\n    private void OnDestroy()\n    {\n        StopAllCoroutines();\n        _objectsOnFloor.Clear();\n        _lastDamageTime.Clear();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "poison gas cloud that damages",
      "ideal_ir": {
        "class_name": "PoisonGasCloud",
        "components": [
          "Collider",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "damageAmount",
            "type": "float",
            "default": 5
          },
          {
            "name": "damageInterval",
            "type": "float",
            "default": 1
          },
          {
            "name": "cloudDuration",
            "type": "float",
            "default": 10
          },
          {
            "name": "cloudRadius",
            "type": "float",
            "default": 3
          }
        ],
        "behaviors": [
          {
            "name": "spawn_gas_cloud",
            "trigger": "when object is created",
            "actions": [
              {
                "action": "create green particle effect with poison appearance"
              },
              {
                "action": "set collider to trigger mode with cloud radius size"
              },
              {
                "action": "start cloud lifetime timer"
              }
            ]
          },
          {
            "name": "damage_entities_in_cloud",
            "trigger": "when living entity enters or stays in gas cloud area",
            "actions": [
              {
                "action": "apply poison damage to entity at regular intervals"
              },
              {
                "action": "show damage effect on affected entity"
              }
            ]
          },
          {
            "name": "dissipate_cloud",
            "trigger": "when cloud duration timer expires",
            "actions": [
              {
                "action": "gradually fade out particle effects"
              },
              {
                "action": "destroy gas cloud object"
              }
            ]
          },
          {
            "name": "stop_damage_on_exit",
            "trigger": "when entity leaves gas cloud area",
            "actions": [
              {
                "action": "stop applying poison damage to that entity"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class PoisonGasCloud : MonoBehaviour\n{\n    [Header(\"Gas Properties\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    [SerializeField] private float _cloudDuration = 15f;\n    [SerializeField] private bool _destroyAfterDuration = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _gasParticles;\n    [SerializeField] private Color _gasColor = Color.green;\n    [SerializeField] private AnimationCurve _opacityOverTime = AnimationCurve.Linear(0, 1, 1, 0);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _gasHissSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    private float _currentLifetime;\n    private Collider _gasCollider;\n    private Renderer _gasRenderer;\n    private Material _gasMaterial;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        _gasCollider = GetComponent<Collider>();\n        _gasRenderer = GetComponent<Renderer>();\n        \n        if (_gasCollider != null)\n        {\n            _gasCollider.isTrigger = true;\n        }\n        \n        if (_gasRenderer != null && _gasRenderer.material != null)\n        {\n            _gasMaterial = _gasRenderer.material;\n            _originalColor = _gasMaterial.color;\n            _gasMaterial.color = _gasColor;\n        }\n        \n        if (_gasParticles != null)\n        {\n            _gasParticles.Play();\n        }\n        \n        if (_audioSource != null && _gasHissSound != null)\n        {\n            _audioSource.clip = _gasHissSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        _currentLifetime = 0f;\n    }\n    \n    private void Update()\n    {\n        if (_destroyAfterDuration)\n        {\n            _currentLifetime += Time.deltaTime;\n            \n            float normalizedTime = _currentLifetime / _cloudDuration;\n            \n            if (_gasMaterial != null)\n            {\n                float opacity = _opacityOverTime.Evaluate(normalizedTime);\n                Color currentColor = _gasMaterial.color;\n                currentColor.a = opacity;\n                _gasMaterial.color = currentColor;\n            }\n            \n            if (_currentLifetime >= _cloudDuration)\n            {\n                DestroyGasCloud();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCoroutine(DamageOverTime(other.gameObject));\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopCoroutine(DamageOverTime(other.gameObject));\n        }\n    }\n    \n    private System.Collections.IEnumerator DamageOverTime(GameObject target)\n    {\n        while (target != null && _gasCollider.bounds.Contains(target.transform.position))\n        {\n            DealDamage(target);\n            yield return new WaitForSeconds(_damageInterval);\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try to find a component that can take damage\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - target object should implement this\n            target.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Play damage sound\n        if (_audioSource != null && _damageSound != null)\n        {\n            _audioSource.PlayOneShot(_damageSound);\n        }\n        \n        // Create damage effect at target position\n        CreateDamageEffect(target.transform.position);\n    }\n    \n    private void CreateDamageEffect(Vector3 position)\n    {\n        // Create a simple damage indicator\n        GameObject damageIndicator = new GameObject(\"DamageIndicator\");\n        damageIndicator.transform.position = position + Vector3.up * 2f;\n        \n        TextMesh textMesh = damageIndicator.AddComponent<TextMesh>();\n        textMesh.text = \"-\" + _damageAmount.ToString();\n        textMesh.color = Color.red;\n        textMesh.fontSize = 20;\n        textMesh.anchor = TextAnchor.MiddleCenter;\n        \n        // Animate the damage text\n        StartCoroutine(AnimateDamageText(damageIndicator));\n    }\n    \n    private System.Collections.IEnumerator AnimateDamageText(GameObject textObject)\n    {\n        Vector3 startPos = textObject.transform.position;\n        Vector3 endPos = startPos + Vector3.up * 1f;\n        float duration = 1f;\n        float elapsed = 0f;\n        \n        TextMesh textMesh = textObject.GetComponent<TextMesh>();\n        Color startColor = textMesh.color;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n            \n            textObject.transform.position = Vector3.Lerp(startPos, endPos, progress);\n            \n            Color currentColor = startColor;\n            currentColor.a = 1f - progress;\n            textMesh.color = currentColor;\n            \n            yield return null;\n        }\n        \n        Destroy(textObject);\n    }\n    \n    private void DestroyGasCloud()\n    {\n        if (_gasParticles != null)\n        {\n            _gasParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        StartCoroutine(FadeOutAndDestroy());\n    }\n    \n    private System.Collections.IEnumerator FadeOutAndDestroy()\n    {\n        float fadeTime = 2f;\n        float elapsed = 0f;\n        \n        while (elapsed < fadeTime)\n        {\n            elapsed += Time.deltaTime;\n            float alpha = 1f - (elapsed / fadeTime);\n            \n            if (_gasMaterial != null)\n            {\n                Color currentColor = _gasMaterial.color;\n                currentColor.a = alpha;\n                _gasMaterial.color = currentColor;\n            }\n            \n            yield return null;\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    public void SetDamage(float damage)\n    {\n        _damageAmount = damage;\n    }\n    \n    public void SetDuration(float duration)\n    {\n        _cloudDuration = duration;\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = interval;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_gasMaterial != null)\n        {\n            _gasMaterial.color = _originalColor;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ice floor that reduces friction",
      "ideal_ir": {
        "class_name": "IceFloor",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "frictionReduction",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "slideForce",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "reduce_friction_on_contact",
            "trigger": "when object enters ice surface area",
            "actions": [
              {
                "action": "reduce the friction of the contacting object"
              },
              {
                "action": "apply sliding physics to the object"
              }
            ]
          },
          {
            "name": "restore_friction_on_exit",
            "trigger": "when object leaves ice surface area",
            "actions": [
              {
                "action": "restore normal friction to the object"
              },
              {
                "action": "remove sliding physics effects"
              }
            ]
          },
          {
            "name": "continuous_slide_effect",
            "trigger": "while object remains on ice surface",
            "actions": [
              {
                "action": "maintain reduced friction state"
              },
              {
                "action": "allow momentum to carry object forward with minimal resistance"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class IceFloor : MonoBehaviour\n{\n    [Header(\"Ice Properties\")]\n    [SerializeField] private float _frictionReduction = 0.1f;\n    [SerializeField] private float _slidingForce = 5f;\n    [SerializeField] private bool _maintainMomentum = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _iceParticles;\n    [SerializeField] private AudioClip _slideSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Physics Materials\")]\n    [SerializeField] private PhysicMaterial _icyMaterial;\n    [SerializeField] private PhysicMaterial _originalMaterial;\n    \n    private Collider _floorCollider;\n    \n    private void Start()\n    {\n        _floorCollider = GetComponent<Collider>();\n        \n        if (_floorCollider == null)\n        {\n            Debug.LogError(\"IceFloor requires a Collider component!\");\n            return;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        SetupIcyPhysicsMaterial();\n    }\n    \n    private void SetupIcyPhysicsMaterial()\n    {\n        if (_icyMaterial == null)\n        {\n            _icyMaterial = new PhysicMaterial(\"IcyMaterial\");\n            _icyMaterial.dynamicFriction = _frictionReduction;\n            _icyMaterial.staticFriction = _frictionReduction;\n            _icyMaterial.bounciness = 0f;\n            _icyMaterial.frictionCombine = PhysicMaterialCombine.Minimum;\n            _icyMaterial.bounceCombine = PhysicMaterialCombine.Minimum;\n        }\n        \n        _floorCollider.material = _icyMaterial;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyIceEffect(other);\n            PlayIceEffects();\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _maintainMomentum)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && rb.velocity.magnitude > 0.1f)\n            {\n                Vector3 slideDirection = rb.velocity.normalized;\n                rb.AddForce(slideDirection * _slidingForce, ForceMode.Acceleration);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            RestoreNormalFriction(other);\n            StopIceEffects();\n        }\n    }\n    \n    private void ApplyIceEffect(Collider player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.drag = _frictionReduction;\n        }\n        \n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null)\n        {\n            if (_originalMaterial == null)\n                _originalMaterial = playerCollider.material;\n            \n            playerCollider.material = _icyMaterial;\n        }\n    }\n    \n    private void RestoreNormalFriction(Collider player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.drag = 0f;\n        }\n        \n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null && _originalMaterial != null)\n        {\n            playerCollider.material = _originalMaterial;\n        }\n    }\n    \n    private void PlayIceEffects()\n    {\n        if (_iceParticles != null && !_iceParticles.isPlaying)\n        {\n            _iceParticles.Play();\n        }\n        \n        if (_audioSource != null && _slideSound != null)\n        {\n            _audioSource.clip = _slideSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopIceEffects()\n    {\n        if (_iceParticles != null && _iceParticles.isPlaying)\n        {\n            _iceParticles.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _frictionReduction = Mathf.Clamp01(_frictionReduction);\n        _slidingForce = Mathf.Max(0f, _slidingForce);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "crumbling platform that falls after stepping",
      "ideal_ir": {
        "class_name": "CrumblingPlatform",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "crumbleDelay",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "hasBeenStepped",
            "type": "bool",
            "default": false
          },
          {
            "name": "isCrumbling",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_step",
            "trigger": "when player steps on platform",
            "actions": [
              {
                "action": "mark platform as stepped on"
              },
              {
                "action": "start crumble countdown timer"
              }
            ]
          },
          {
            "name": "begin_crumbling",
            "trigger": "when crumble delay time has elapsed after being stepped on",
            "actions": [
              {
                "action": "mark platform as crumbling"
              },
              {
                "action": "enable physics gravity"
              },
              {
                "action": "play crumbling sound effect"
              },
              {
                "action": "start particle effects for debris"
              }
            ]
          },
          {
            "name": "fall_down",
            "trigger": "when platform is crumbling",
            "actions": [
              {
                "action": "fall downward at fall speed"
              },
              {
                "action": "continue playing debris particles"
              }
            ]
          },
          {
            "name": "destroy_platform",
            "trigger": "when platform has fallen far below original position",
            "actions": [
              {
                "action": "destroy platform object"
              },
              {
                "action": "stop all particle effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class CrumblingPlatform : MonoBehaviour\n{\n    [Header(\"Crumbling Settings\")]\n    [SerializeField] private float _crumbleDelay = 1.0f;\n    [SerializeField] private float _fallSpeed = 5.0f;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 0.8f;\n    [SerializeField] private float _respawnDelay = 5.0f;\n    [SerializeField] private bool _respawnAfterFall = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _crumbleSound;\n    [SerializeField] private AudioClip _fallSound;\n    \n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private bool _isTriggered = false;\n    private bool _isFalling = false;\n    private Rigidbody _rigidbody;\n    private Collider _platformCollider;\n    private AudioSource _audioSource;\n    private Coroutine _crumbleCoroutine;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        _rigidbody.isKinematic = true;\n        \n        _platformCollider = GetComponent<Collider>();\n        if (_platformCollider == null)\n        {\n            _platformCollider = gameObject.AddComponent<BoxCollider>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isTriggered && !_isFalling && other.CompareTag(\"Player\"))\n        {\n            TriggerCrumble();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_isTriggered && !_isFalling && collision.gameObject.CompareTag(\"Player\"))\n        {\n            TriggerCrumble();\n        }\n    }\n    \n    private void TriggerCrumble()\n    {\n        _isTriggered = true;\n        \n        if (_crumbleCoroutine != null)\n        {\n            StopCoroutine(_crumbleCoroutine);\n        }\n        \n        _crumbleCoroutine = StartCoroutine(CrumbleSequence());\n    }\n    \n    private IEnumerator CrumbleSequence()\n    {\n        // Play crumble sound\n        if (_crumbleSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_crumbleSound);\n        }\n        \n        // Shake effect\n        float shakeTimer = 0f;\n        Vector3 shakePosition = _originalPosition;\n        \n        while (shakeTimer < _shakeDuration)\n        {\n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.y = Mathf.Abs(randomOffset.y) * 0.5f; // Reduce vertical shake\n            transform.position = shakePosition + randomOffset;\n            \n            shakeTimer += Time.deltaTime;\n            yield return null;\n        }\n        \n        // Wait for crumble delay\n        yield return new WaitForSeconds(_crumbleDelay - _shakeDuration);\n        \n        // Start falling\n        StartFalling();\n    }\n    \n    private void StartFalling()\n    {\n        _isFalling = true;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        \n        // Add downward force\n        _rigidbody.AddForce(Vector3.down * _fallSpeed, ForceMode.VelocityChange);\n        \n        // Play fall sound\n        if (_fallSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_fallSound);\n        }\n        \n        // Start respawn timer if enabled\n        if (_respawnAfterFall)\n        {\n            StartCoroutine(RespawnAfterDelay());\n        }\n    }\n    \n    private IEnumerator RespawnAfterDelay()\n    {\n        yield return new WaitForSeconds(_respawnDelay);\n        RespawnPlatform();\n    }\n    \n    private void RespawnPlatform()\n    {\n        // Reset position and rotation\n        transform.position = _originalPosition;\n        transform.rotation = _originalRotation;\n        \n        // Reset rigidbody\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        \n        // Reset flags\n        _isTriggered = false;\n        _isFalling = false;\n        \n        // Re-enable collider if it was disabled\n        if (_platformCollider != null)\n        {\n            _platformCollider.enabled = true;\n        }\n    }\n    \n    public void ResetPlatform()\n    {\n        if (_crumbleCoroutine != null)\n        {\n            StopCoroutine(_crumbleCoroutine);\n            _crumbleCoroutine = null;\n        }\n        \n        StopAllCoroutines();\n        RespawnPlatform();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        if (Application.isPlaying && _isTriggered)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(transform.position, transform.localScale * 1.1f);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "gun that fires projectiles",
      "ideal_ir": {
        "class_name": "Gun",
        "components": [
          "Transform",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "projectilePrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "firePoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "fireRate",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "projectileSpeed",
            "type": "float",
            "default": 20
          },
          {
            "name": "ammoCount",
            "type": "int",
            "default": 30
          },
          {
            "name": "maxAmmo",
            "type": "int",
            "default": 30
          },
          {
            "name": "fireSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "lastFireTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "fire_projectile",
            "trigger": "when fire input is pressed and enough time has passed since last shot and ammo count is greater than zero",
            "actions": [
              {
                "action": "create projectile at fire point position and rotation"
              },
              {
                "action": "apply forward velocity to projectile based on projectile speed"
              },
              {
                "action": "play fire sound effect"
              },
              {
                "action": "reduce ammo count by one"
              },
              {
                "action": "record current time as last fire time"
              }
            ]
          },
          {
            "name": "reload_ammo",
            "trigger": "when reload input is pressed and ammo count is less than maximum ammo",
            "actions": [
              {
                "action": "set ammo count to maximum ammo value"
              },
              {
                "action": "play reload sound effect"
              }
            ]
          },
          {
            "name": "prevent_rapid_fire",
            "trigger": "when fire input is pressed but not enough time has passed since last shot",
            "actions": [
              {
                "action": "ignore the fire input"
              }
            ]
          },
          {
            "name": "handle_empty_ammo",
            "trigger": "when fire input is pressed but ammo count is zero",
            "actions": [
              {
                "action": "play empty chamber sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Gun : MonoBehaviour\n{\n    [System.Serializable]\n    public class Projectile : MonoBehaviour\n    {\n        [Header(\"Projectile Settings\")]\n        [SerializeField] private float _speed = 10f;\n        [SerializeField] private float _lifetime = 5f;\n        [SerializeField] private int _damage = 10;\n        [SerializeField] private LayerMask _hitLayers = -1;\n        \n        private Rigidbody _rigidbody;\n        private bool _hasHit = false;\n        \n        public UnityEvent<GameObject> OnHit;\n        \n        private void Awake()\n        {\n            _rigidbody = GetComponent<Rigidbody>();\n            if (_rigidbody == null)\n                _rigidbody = gameObject.AddComponent<Rigidbody>();\n                \n            _rigidbody.useGravity = false;\n            Destroy(gameObject, _lifetime);\n        }\n        \n        private void Start()\n        {\n            _rigidbody.velocity = transform.forward * _speed;\n        }\n        \n        private void OnTriggerEnter(Collider other)\n        {\n            if (_hasHit) return;\n            \n            if ((_hitLayers.value & (1 << other.gameObject.layer)) != 0)\n            {\n                _hasHit = true;\n                OnHit?.Invoke(other.gameObject);\n                \n                if (other.CompareTag(\"Player\"))\n                {\n                    Debug.Log($\"Player hit for {_damage} damage!\");\n                }\n                \n                Destroy(gameObject);\n            }\n        }\n    }\n    \n    [Header(\"Gun Settings\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private bool _autoFire = false;\n    [SerializeField] private KeyCode _fireKey = KeyCode.Space;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private GameObject _muzzleFlashEffect;\n    \n    [Header(\"Ammo\")]\n    [SerializeField] private int _maxAmmo = 30;\n    [SerializeField] private int _currentAmmo;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    private float _nextFireTime = 0f;\n    private bool _isReloading = false;\n    \n    public UnityEvent OnFire;\n    public UnityEvent OnReload;\n    public UnityEvent OnAmmoEmpty;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_projectilePrefab == null)\n        {\n            _projectilePrefab = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            _projectilePrefab.transform.localScale = Vector3.one * 0.1f;\n            _projectilePrefab.AddComponent<Projectile>();\n            \n            Collider collider = _projectilePrefab.GetComponent<Collider>();\n            if (collider != null)\n                collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isReloading) return;\n        \n        bool shouldFire = false;\n        \n        if (_autoFire)\n        {\n            shouldFire = Input.GetKey(_fireKey);\n        }\n        else\n        {\n            shouldFire = Input.GetKeyDown(_fireKey);\n        }\n        \n        if (shouldFire && CanFire())\n        {\n            Fire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && _currentAmmo < _maxAmmo)\n        {\n            StartReload();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return Time.time >= _nextFireTime && _currentAmmo > 0 && !_isReloading;\n    }\n    \n    public void Fire()\n    {\n        if (!CanFire()) return;\n        \n        _nextFireTime = Time.time + (1f / _fireRate);\n        _currentAmmo--;\n        \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Projectile projectileScript = projectile.GetComponent<Projectile>();\n        if (projectileScript != null)\n        {\n            projectileScript.OnHit.AddListener(OnProjectileHit);\n        }\n        \n        PlayFireEffects();\n        OnFire?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            OnAmmoEmpty?.Invoke();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.PlayOneShot(_fireSound);\n        }\n        \n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n        \n        if (_muzzleFlashEffect != null)\n        {\n            GameObject flash = Instantiate(_muzzleFlashEffect, _firePoint.position, _firePoint.rotation);\n            Destroy(flash, 0.1f);\n        }\n    }\n    \n    private void OnProjectileHit(GameObject hitObject)\n    {\n        Debug.Log($\"Projectile hit: {hitObject.name}\");\n    }\n    \n    public void StartReload()\n    {\n        if (_isReloading || _currentAmmo >= _maxAmmo) return;\n        \n        _isReloading = true;\n        OnReload?.Invoke();\n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n    \n    public void AddAmmo(int amount)\n    {\n        _currentAmmo = Mathf.Min(_currentAmmo + amount, _maxAmmo);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_firePoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_firePoint.position, 0.1f);\n            Gizmos.DrawRay(_firePoint.position, _firePoint.forward * 2f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "sword that swings with animation",
      "ideal_ir": {
        "class_name": "SwingSword",
        "components": [
          "Animator"
        ],
        "fields": [
          {
            "name": "swingCooldown",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isSwinging",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "swing_sword",
            "trigger": "when left mouse button is pressed and sword is not currently swinging and cooldown period has passed",
            "actions": [
              {
                "action": "set swinging state to true"
              },
              {
                "action": "play sword swing animation"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "finish_swing",
            "trigger": "when sword swing animation completes",
            "actions": [
              {
                "action": "set swinging state to false"
              }
            ]
          },
          {
            "name": "update_cooldown",
            "trigger": "every frame while cooldown timer is active",
            "actions": [
              {
                "action": "decrease cooldown timer by frame time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SwordController : MonoBehaviour\n{\n    [Header(\"Sword Settings\")]\n    [SerializeField] private float _swingDuration = 0.5f;\n    [SerializeField] private float _swingAngle = 90f;\n    [SerializeField] private AnimationCurve _swingCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private KeyCode _swingKey = KeyCode.Mouse0;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private LayerMask _enemyLayers = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _slashEffect;\n    [SerializeField] private Transform _effectSpawnPoint;\n    \n    private bool _isSwinging = false;\n    private float _swingTimer = 0f;\n    private Vector3 _initialRotation;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private bool _hasDealtDamage = false;\n    \n    private void Start()\n    {\n        _initialRotation = transform.localEulerAngles;\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_effectSpawnPoint == null)\n        {\n            _effectSpawnPoint = transform;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateSwingAnimation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_swingKey) && !_isSwinging)\n        {\n            StartSwing();\n        }\n    }\n    \n    private void StartSwing()\n    {\n        _isSwinging = true;\n        _swingTimer = 0f;\n        _hasDealtDamage = false;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Swing\");\n        }\n        \n        PlaySwingSound();\n        SpawnSlashEffect();\n    }\n    \n    private void UpdateSwingAnimation()\n    {\n        if (!_isSwinging) return;\n        \n        _swingTimer += Time.deltaTime;\n        float progress = _swingTimer / _swingDuration;\n        \n        if (progress >= 1f)\n        {\n            progress = 1f;\n            _isSwinging = false;\n        }\n        \n        float curveValue = _swingCurve.Evaluate(progress);\n        float currentAngle = curveValue * _swingAngle;\n        \n        Vector3 rotation = _initialRotation;\n        rotation.z += currentAngle;\n        transform.localEulerAngles = rotation;\n        \n        // Check for hits during the middle portion of the swing\n        if (progress >= 0.3f && progress <= 0.7f && !_hasDealtDamage)\n        {\n            CheckForHits();\n        }\n        \n        // Return to initial position when swing is complete\n        if (!_isSwinging)\n        {\n            transform.localEulerAngles = _initialRotation;\n        }\n    }\n    \n    private void CheckForHits()\n    {\n        Vector3 attackPosition = transform.position + transform.forward * (_attackRange * 0.5f);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, _attackRange, _enemyLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject != gameObject && \n                hitCollider.transform.parent != transform.parent)\n            {\n                DealDamage(hitCollider.gameObject);\n                _hasDealtDamage = true;\n                break;\n            }\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        // Try to find common health components\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - target can implement this method\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Apply knockback\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n        \n        PlayHitSound();\n        \n        // Destroy objects tagged as destructible\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    private void PlaySwingSound()\n    {\n        if (_audioSource != null && _swingSound != null)\n        {\n            _audioSource.PlayOneShot(_swingSound);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void SpawnSlashEffect()\n    {\n        if (_slashEffect != null && _effectSpawnPoint != null)\n        {\n            GameObject effect = Instantiate(_slashEffect, _effectSpawnPoint.position, _effectSpawnPoint.rotation);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw attack range\n        Gizmos.color = Color.red;\n        Vector3 attackPosition = transform.position + transform.forward * (_attackRange * 0.5f);\n        Gizmos.DrawWireSphere(attackPosition, _attackRange);\n        \n        // Draw swing arc\n        Gizmos.color = Color.yellow;\n        Vector3 startDirection = Quaternion.Euler(0, 0, -_swingAngle * 0.5f) * transform.right;\n        Vector3 endDirection = Quaternion.Euler(0, 0, _swingAngle * 0.5f) * transform.right;\n        \n        Gizmos.DrawRay(transform.position, startDirection * _attackRange);\n        Gizmos.DrawRay(transform.position, endDirection * _attackRange);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "grenade that explodes after delay",
      "ideal_ir": {
        "class_name": "Grenade",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "explosionDelay",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "explosionDamage",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 1000.0
          },
          {
            "name": "hasExploded",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_countdown",
            "trigger": "when grenade is created or thrown",
            "actions": [
              {
                "action": "start countdown timer for explosion delay"
              }
            ]
          },
          {
            "name": "explode",
            "trigger": "when countdown timer reaches zero",
            "actions": [
              {
                "action": "create explosion effect at grenade position"
              },
              {
                "action": "play explosion sound"
              },
              {
                "action": "find all objects within explosion radius"
              },
              {
                "action": "apply explosion damage to damageable objects in range"
              },
              {
                "action": "apply explosion force to rigidbodies in range"
              },
              {
                "action": "mark grenade as exploded"
              },
              {
                "action": "destroy grenade object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class Grenade : MonoBehaviour\n{\n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionDelay = 3f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _damage = 100f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private ParticleSystem _fuseParticles;\n    [SerializeField] private Light _fuseLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fuseSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _bounceForce = 0.3f;\n    [SerializeField] private int _maxBounces = 3;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _hasExploded = false;\n    private bool _fuseStarted = false;\n    private int _bounceCount = 0;\n    private float _fuseTimer = 0f;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        StartFuse();\n    }\n    \n    private void Update()\n    {\n        if (_fuseStarted && !_hasExploded)\n        {\n            _fuseTimer += Time.deltaTime;\n            \n            UpdateFuseEffects();\n            \n            if (_fuseTimer >= _explosionDelay)\n            {\n                Explode();\n            }\n        }\n    }\n    \n    private void StartFuse()\n    {\n        _fuseStarted = true;\n        _fuseTimer = 0f;\n        \n        if (_fuseParticles != null)\n            _fuseParticles.Play();\n            \n        if (_fuseLight != null)\n            _fuseLight.enabled = true;\n            \n        if (_audioSource != null && _fuseSound != null)\n        {\n            _audioSource.clip = _fuseSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void UpdateFuseEffects()\n    {\n        float timeRemaining = _explosionDelay - _fuseTimer;\n        float normalizedTime = 1f - (timeRemaining / _explosionDelay);\n        \n        if (_fuseLight != null)\n        {\n            _fuseLight.intensity = Mathf.Lerp(0.5f, 2f, normalizedTime);\n            \n            if (timeRemaining < 1f)\n            {\n                _fuseLight.intensity *= Mathf.Sin(Time.time * 20f) * 0.5f + 1f;\n            }\n        }\n        \n        if (_fuseParticles != null && timeRemaining < 1f)\n        {\n            var emission = _fuseParticles.emission;\n            emission.rateOverTime = Mathf.Lerp(10f, 50f, normalizedTime);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded || _bounceCount >= _maxBounces)\n            return;\n            \n        _bounceCount++;\n        \n        Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n        _rigidbody.velocity = bounceDirection * _bounceForce * _rigidbody.velocity.magnitude;\n        \n        if (_audioSource != null && !_audioSource.isPlaying)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_fuseSound, 0.3f);\n        }\n    }\n    \n    private void Explode()\n    {\n        if (_hasExploded)\n            return;\n            \n        _hasExploded = true;\n        \n        CreateExplosionEffects();\n        ApplyExplosionDamage();\n        ApplyExplosionForce();\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    private void CreateExplosionEffects()\n    {\n        if (_explosionPrefab != null)\n        {\n            GameObject explosion = Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n            Destroy(explosion, 5f);\n        }\n        \n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n            _audioSource.clip = _explosionSound;\n            _audioSource.volume = 1f;\n            _audioSource.Play();\n        }\n        \n        if (_fuseParticles != null)\n            _fuseParticles.Stop();\n            \n        if (_fuseLight != null)\n            _fuseLight.enabled = false;\n            \n        if (_collider != null)\n            _collider.enabled = false;\n            \n        GetComponent<Renderer>().enabled = false;\n    }\n    \n    private void ApplyExplosionDamage()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider == _collider)\n                continue;\n                \n            float distance = Vector3.Distance(transform.position, hitCollider.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            float finalDamage = _damage * damageMultiplier;\n            \n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                ApplyDamageToTarget(hitCollider.gameObject, finalDamage);\n            }\n            else if (hitCollider.CompareTag(\"Enemy\"))\n            {\n                ApplyDamageToTarget(hitCollider.gameObject, finalDamage);\n            }\n            \n            Destructible destructible = hitCollider.GetComponent<Destructible>();\n            if (destructible != null)\n            {\n                destructible.TakeDamage(finalDamage);\n            }\n        }\n    }\n    \n    private void ApplyDamageToTarget(GameObject target, float damage)\n    {\n        target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        \n        CharacterController controller = target.GetComponent<CharacterController>();\n        if (controller != null)\n        {\n            target.SendMessage(\"OnExplosionHit\", damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n    \n    private void ApplyExplosionForce()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider == _collider)\n                continue;\n                \n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, 3f);\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius * 0.5f);\n    }\n    \n    public void SetExplosionDelay(float delay)\n    {\n        _explosionDelay = delay;\n    }\n    \n    public void SetExplosionRadius(float radius)\n    {\n        _explosionRadius = radius;\n    }\n    \n    public void SetDamage(float damage)\n    {\n        _damage = damage;\n    }\n    \n    public void ExplodeImmediately()\n    {\n        _fuseTimer = _explosionDelay;\n    }\n}\n\npublic class Destructible : MonoBehaviour\n{\n    [Header(\"Destructible Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private GameObject _destroyedPrefab;\n    \n    private float _currentHealth;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0f)\n        {\n            DestroyObject();\n        }\n    }\n    \n    private void DestroyObject()\n    {\n        if (_destroyedPrefab != null)\n        {\n            Instantiate(_destroyedPrefab, transform.position, transform.rotation);\n        }\n        \n        Destroy(gameObject);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "shotgun with spread pattern",
      "ideal_ir": {
        "class_name": "Shotgun",
        "components": [
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "pelletCount",
            "type": "int",
            "default": 8
          },
          {
            "name": "spreadAngle",
            "type": "float",
            "default": 15
          },
          {
            "name": "damage",
            "type": "float",
            "default": 25
          },
          {
            "name": "range",
            "type": "float",
            "default": 20
          },
          {
            "name": "fireRate",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "reloadTime",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "ammoCapacity",
            "type": "int",
            "default": 6
          },
          {
            "name": "currentAmmo",
            "type": "int",
            "default": 6
          },
          {
            "name": "muzzleFlashPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "shotgunSoundClip",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "fire_shotgun",
            "trigger": "when fire input is pressed and weapon is ready and has ammo",
            "actions": [
              {
                "action": "create multiple pellets in spread pattern around aim direction"
              },
              {
                "action": "apply random angle variation to each pellet within spread cone"
              },
              {
                "action": "fire all pellets simultaneously in their calculated directions"
              },
              {
                "action": "deal damage to any targets hit by pellets within range"
              },
              {
                "action": "play shotgun firing sound effect"
              },
              {
                "action": "show muzzle flash particle effect"
              },
              {
                "action": "reduce current ammo by one"
              },
              {
                "action": "apply recoil effect to weapon"
              },
              {
                "action": "start fire rate cooldown timer"
              }
            ]
          },
          {
            "name": "reload_weapon",
            "trigger": "when reload input is pressed and current ammo is less than capacity",
            "actions": [
              {
                "action": "start reload animation"
              },
              {
                "action": "play reload sound effect"
              },
              {
                "action": "disable firing during reload time"
              },
              {
                "action": "restore ammo to full capacity after reload duration"
              }
            ]
          },
          {
            "name": "auto_reload",
            "trigger": "when attempting to fire with no ammo remaining",
            "actions": [
              {
                "action": "play empty chamber click sound"
              },
              {
                "action": "automatically start reload sequence"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Shotgun : MonoBehaviour\n{\n    [Header(\"Shotgun Settings\")]\n    [SerializeField] private int _pelletsPerShot = 8;\n    [SerializeField] private float _damage = 15f;\n    [SerializeField] private float _range = 20f;\n    [SerializeField] private float _spreadAngle = 30f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private LineRenderer _tracerPrefab;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private float _tracerDuration = 0.1f;\n    \n    [Header(\"Ammo\")]\n    [SerializeField] private int _maxAmmo = 6;\n    [SerializeField] private int _currentAmmo = 6;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnFire;\n    public UnityEvent OnReload;\n    public UnityEvent OnEmpty;\n    \n    private Transform _firePoint;\n    private AudioSource _audioSource;\n    private float _lastFireTime;\n    private bool _isReloading;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _firePoint = transform.Find(\"FirePoint\");\n        if (_firePoint == null)\n        {\n            GameObject firePointObj = new GameObject(\"FirePoint\");\n            firePointObj.transform.SetParent(transform);\n            firePointObj.transform.localPosition = Vector3.forward;\n            _firePoint = firePointObj.transform;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n        {\n            _playerCamera = FindObjectOfType<Camera>();\n        }\n        \n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    private void Update()\n    {\n        if (_isReloading) return;\n        \n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && _currentAmmo < _maxAmmo)\n        {\n            StartReload();\n        }\n    }\n    \n    private void TryFire()\n    {\n        if (Time.time - _lastFireTime < 1f / _fireRate) return;\n        \n        if (_currentAmmo <= 0)\n        {\n            OnEmpty?.Invoke();\n            return;\n        }\n        \n        Fire();\n        _lastFireTime = Time.time;\n    }\n    \n    private void Fire()\n    {\n        _currentAmmo--;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnFire?.Invoke();\n        \n        PlayFireSound();\n        ShowMuzzleFlash();\n        \n        Vector3 fireDirection = _firePoint.forward;\n        if (_playerCamera != null)\n        {\n            fireDirection = _playerCamera.transform.forward;\n        }\n        \n        for (int i = 0; i < _pelletsPerShot; i++)\n        {\n            Vector3 spreadDirection = ApplySpread(fireDirection);\n            FirePellet(spreadDirection);\n        }\n    }\n    \n    private Vector3 ApplySpread(Vector3 baseDirection)\n    {\n        float halfSpread = _spreadAngle * 0.5f;\n        float randomX = Random.Range(-halfSpread, halfSpread);\n        float randomY = Random.Range(-halfSpread, halfSpread);\n        \n        Quaternion spreadRotation = Quaternion.Euler(randomX, randomY, 0);\n        return spreadRotation * baseDirection;\n    }\n    \n    private void FirePellet(Vector3 direction)\n    {\n        RaycastHit hit;\n        Vector3 startPoint = _firePoint.position;\n        \n        if (Physics.Raycast(startPoint, direction, out hit, _range, _targetLayers))\n        {\n            ProcessHit(hit);\n            CreateTracer(startPoint, hit.point);\n            CreateImpactEffect(hit.point, hit.normal);\n        }\n        else\n        {\n            Vector3 endPoint = startPoint + direction * _range;\n            CreateTracer(startPoint, endPoint);\n        }\n    }\n    \n    private void ProcessHit(RaycastHit hit)\n    {\n        Rigidbody hitRigidbody = hit.collider.GetComponent<Rigidbody>();\n        if (hitRigidbody != null)\n        {\n            Vector3 force = hit.normal * -_damage * 10f;\n            hitRigidbody.AddForceAtPosition(force, hit.point, ForceMode.Impulse);\n        }\n        \n        IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n        if (damageable != null)\n        {\n            damageable.TakeDamage(_damage);\n        }\n        \n        if (hit.collider.CompareTag(\"Enemy\"))\n        {\n            Destroy(hit.collider.gameObject);\n        }\n    }\n    \n    private void CreateTracer(Vector3 start, Vector3 end)\n    {\n        if (_tracerPrefab == null) return;\n        \n        LineRenderer tracer = Instantiate(_tracerPrefab);\n        tracer.positionCount = 2;\n        tracer.SetPosition(0, start);\n        tracer.SetPosition(1, end);\n        \n        Destroy(tracer.gameObject, _tracerDuration);\n    }\n    \n    private void CreateImpactEffect(Vector3 position, Vector3 normal)\n    {\n        if (_impactEffect == null) return;\n        \n        GameObject effect = Instantiate(_impactEffect, position, Quaternion.LookRotation(normal));\n        Destroy(effect, 2f);\n    }\n    \n    private void PlayFireSound()\n    {\n        if (_fireSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_fireSound, _volume);\n        }\n    }\n    \n    private void ShowMuzzleFlash()\n    {\n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n    }\n    \n    private void StartReload()\n    {\n        if (_isReloading) return;\n        \n        _isReloading = true;\n        OnReload?.Invoke();\n        \n        if (_reloadSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_reloadSound, _volume);\n        }\n        \n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    public void AddAmmo(int amount)\n    {\n        _currentAmmo = Mathf.Min(_currentAmmo + amount, _maxAmmo);\n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    public bool IsReloading => _isReloading;\n    public int CurrentAmmo => _currentAmmo;\n    public int MaxAmmo => _maxAmmo;\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "laser weapon with continuous beam",
      "ideal_ir": {
        "class_name": "LaserWeapon",
        "components": [
          "LineRenderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxRange",
            "type": "float",
            "default": 50
          },
          {
            "name": "damage",
            "type": "float",
            "default": 25
          },
          {
            "name": "beamWidth",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "energyCost",
            "type": "float",
            "default": 10
          },
          {
            "name": "overheatingThreshold",
            "type": "float",
            "default": 100
          },
          {
            "name": "coolingRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "currentHeat",
            "type": "float",
            "default": 0
          },
          {
            "name": "currentEnergy",
            "type": "float",
            "default": 100
          },
          {
            "name": "isFiring",
            "type": "bool",
            "default": false
          },
          {
            "name": "isOverheated",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_firing",
            "trigger": "when fire input is pressed and weapon is not overheated and has energy",
            "actions": [
              {
                "action": "set firing state to true"
              },
              {
                "action": "enable laser beam visual"
              },
              {
                "action": "play laser firing sound"
              },
              {
                "action": "cast ray from weapon position in forward direction"
              }
            ]
          },
          {
            "name": "continuous_beam",
            "trigger": "while firing state is active",
            "actions": [
              {
                "action": "update laser beam endpoint to hit position or max range"
              },
              {
                "action": "apply damage to hit target continuously"
              },
              {
                "action": "increase weapon heat over time"
              },
              {
                "action": "decrease energy over time"
              },
              {
                "action": "create sparks effect at beam impact point"
              }
            ]
          },
          {
            "name": "stop_firing",
            "trigger": "when fire input is released or energy depleted or weapon overheats",
            "actions": [
              {
                "action": "set firing state to false"
              },
              {
                "action": "disable laser beam visual"
              },
              {
                "action": "stop laser firing sound"
              },
              {
                "action": "play weapon cooldown sound"
              }
            ]
          },
          {
            "name": "weapon_cooling",
            "trigger": "when weapon is not firing",
            "actions": [
              {
                "action": "decrease weapon heat over time"
              },
              {
                "action": "regenerate energy slowly over time"
              }
            ]
          },
          {
            "name": "overheat_protection",
            "trigger": "when weapon heat exceeds overheating threshold",
            "actions": [
              {
                "action": "set overheated state to true"
              },
              {
                "action": "force stop firing"
              },
              {
                "action": "play overheating warning sound"
              },
              {
                "action": "show overheating visual effect"
              }
            ]
          },
          {
            "name": "cooldown_complete",
            "trigger": "when overheated weapon heat drops below safe threshold",
            "actions": [
              {
                "action": "set overheated state to false"
              },
              {
                "action": "play ready sound"
              },
              {
                "action": "hide overheating visual effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LaserWeapon : MonoBehaviour\n{\n    [Header(\"Laser Configuration\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private LineRenderer _laserLine;\n    [SerializeField] private ParticleSystem _muzzleEffect;\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private float _maxRange = 100f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageInterval = 0.1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Color _laserColor = Color.red;\n    [SerializeField] private float _laserWidth = 0.1f;\n    [SerializeField] private Material _laserMaterial;\n    [SerializeField] private Light _laserLight;\n    [SerializeField] private float _lightIntensity = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Mouse0;\n    [SerializeField] private bool _useInput = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLaserStart;\n    public UnityEvent OnLaserStop;\n    public UnityEvent<Vector3> OnLaserHit;\n    \n    private bool _isFiring;\n    private float _lastDamageTime;\n    private RaycastHit _currentHit;\n    private GameObject _currentTarget;\n    private TargetHealth _currentTargetHealth;\n    \n    [System.Serializable]\n    public class TargetHealth\n    {\n        public float maxHealth = 100f;\n        public float currentHealth;\n        public bool isDead;\n        \n        public TargetHealth(float health)\n        {\n            maxHealth = health;\n            currentHealth = health;\n            isDead = false;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            if (isDead) return;\n            \n            currentHealth -= damage;\n            if (currentHealth <= 0)\n            {\n                currentHealth = 0;\n                isDead = true;\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeLaser();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateLaser();\n    }\n    \n    private void InitializeLaser()\n    {\n        if (_laserLine == null)\n        {\n            _laserLine = GetComponent<LineRenderer>();\n            if (_laserLine == null)\n            {\n                _laserLine = gameObject.AddComponent<LineRenderer>();\n            }\n        }\n        \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupLineRenderer();\n        SetupLight();\n        \n        _laserLine.enabled = false;\n        if (_laserLight != null)\n            _laserLight.enabled = false;\n    }\n    \n    private void SetupLineRenderer()\n    {\n        _laserLine.positionCount = 2;\n        _laserLine.startWidth = _laserWidth;\n        _laserLine.endWidth = _laserWidth;\n        _laserLine.color = _laserColor;\n        _laserLine.useWorldSpace = true;\n        \n        if (_laserMaterial != null)\n            _laserLine.material = _laserMaterial;\n    }\n    \n    private void SetupLight()\n    {\n        if (_laserLight == null)\n        {\n            GameObject lightObj = new GameObject(\"LaserLight\");\n            lightObj.transform.SetParent(_firePoint);\n            lightObj.transform.localPosition = Vector3.zero;\n            _laserLight = lightObj.AddComponent<Light>();\n        }\n        \n        _laserLight.type = LightType.Spot;\n        _laserLight.color = _laserColor;\n        _laserLight.intensity = _lightIntensity;\n        _laserLight.range = _maxRange;\n        _laserLight.spotAngle = 30f;\n    }\n    \n    private void HandleInput()\n    {\n        if (!_useInput) return;\n        \n        if (Input.GetKeyDown(_fireKey))\n        {\n            StartFiring();\n        }\n        else if (Input.GetKeyUp(_fireKey))\n        {\n            StopFiring();\n        }\n    }\n    \n    public void StartFiring()\n    {\n        if (_isFiring) return;\n        \n        _isFiring = true;\n        _laserLine.enabled = true;\n        \n        if (_laserLight != null)\n            _laserLight.enabled = true;\n            \n        if (_muzzleEffect != null)\n            _muzzleEffect.Play();\n            \n        PlayFireSound();\n        OnLaserStart?.Invoke();\n    }\n    \n    public void StopFiring()\n    {\n        if (!_isFiring) return;\n        \n        _isFiring = false;\n        _laserLine.enabled = false;\n        \n        if (_laserLight != null)\n            _laserLight.enabled = false;\n            \n        if (_muzzleEffect != null)\n            _muzzleEffect.Stop();\n            \n        if (_hitEffect != null)\n            _hitEffect.Stop();\n            \n        StopFireSound();\n        _currentTarget = null;\n        _currentTargetHealth = null;\n        OnLaserStop?.Invoke();\n    }\n    \n    private void UpdateLaser()\n    {\n        if (!_isFiring) return;\n        \n        Vector3 startPos = _firePoint.position;\n        Vector3 direction = _firePoint.forward;\n        Vector3 endPos = startPos + direction * _maxRange;\n        \n        if (Physics.Raycast(startPos, direction, out _currentHit, _maxRange, _targetLayers))\n        {\n            endPos = _currentHit.point;\n            HandleHit();\n        }\n        else\n        {\n            _currentTarget = null;\n            _currentTargetHealth = null;\n            if (_hitEffect != null)\n                _hitEffect.Stop();\n        }\n        \n        _laserLine.SetPosition(0, startPos);\n        _laserLine.SetPosition(1, endPos);\n        \n        if (_laserLight != null)\n        {\n            _laserLight.transform.position = startPos;\n            _laserLight.transform.LookAt(endPos);\n        }\n    }\n    \n    private void HandleHit()\n    {\n        if (_currentHit.collider == null) return;\n        \n        // Visual effects\n        if (_hitEffect != null)\n        {\n            _hitEffect.transform.position = _currentHit.point;\n            _hitEffect.transform.LookAt(_currentHit.point + _currentHit.normal);\n            if (!_hitEffect.isPlaying)\n                _hitEffect.Play();\n        }\n        \n        // Damage handling\n        if (Time.time >= _lastDamageTime + _damageInterval)\n        {\n            ApplyDamage(_currentHit.collider.gameObject);\n            _lastDamageTime = Time.time;\n            OnLaserHit?.Invoke(_currentHit.point);\n        }\n    }\n    \n    private void ApplyDamage(GameObject target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            // Handle player damage\n            HandlePlayerDamage(target);\n        }\n        else if (target.CompareTag(\"Enemy\"))\n        {\n            // Handle enemy damage\n            HandleEnemyDamage(target);\n        }\n        else\n        {\n            // Handle other objects\n            HandleGenericDamage(target);\n        }\n        \n        PlayHitSound();\n    }\n    \n    private void HandlePlayerDamage(GameObject player)\n    {\n        // Send damage message if the player has a damage receiver\n        player.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void HandleEnemyDamage(GameObject enemy)\n    {\n        if (_currentTarget != enemy)\n        {\n            _currentTarget = enemy;\n            _currentTargetHealth = enemy.GetComponent<TargetHealth>();\n            \n            if (_currentTargetHealth == null)\n            {\n                _currentTargetHealth = enemy.AddComponent<TargetHealth>();\n                _currentTargetHealth.maxHealth = 100f;\n                _currentTargetHealth.currentHealth = 100f;\n            }\n        }\n        \n        if (_currentTargetHealth != null && !_currentTargetHealth.isDead)\n        {\n            _currentTargetHealth.TakeDamage(_damage);\n            \n            if (_currentTargetHealth.isDead)\n            {\n                DestroyTarget(enemy);\n            }\n        }\n    }\n    \n    private void HandleGenericDamage(GameObject target)\n    {\n        // Try to send damage message\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Check for destructible objects\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    private void DestroyTarget(GameObject target)\n    {\n        // Add explosion effect if available\n        if (_hitEffect != null)\n        {\n            ParticleSystem explosion = Instantiate(_hitEffect, target.transform.position, Quaternion.identity);\n            explosion.Play();\n            Destroy(explosion.gameObject, 2f);\n        }\n        \n        Destroy(target);\n        _currentTarget = null;\n        _currentTargetHealth = null;\n    }\n    \n    private void PlayFireSound()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.clip = _fireSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopFireSound()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        StopFiring();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_firePoint == null) return;\n        \n        Gizmos.color = _laserColor;\n        Gizmos.DrawRay(_firePoint.position, _firePoint.forward * _maxRange);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "rocket launcher with splash damage",
      "ideal_ir": {
        "class_name": "RocketLauncher",
        "components": [
          "Rigidbody",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "damage",
            "type": "float",
            "default": 100
          },
          {
            "name": "splashRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "splashDamage",
            "type": "float",
            "default": 50
          },
          {
            "name": "projectileSpeed",
            "type": "float",
            "default": 20
          },
          {
            "name": "reloadTime",
            "type": "float",
            "default": 3
          },
          {
            "name": "rocketPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "explosionEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "launchPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isReloaded",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "fire_rocket",
            "trigger": "when fire input is pressed and weapon is reloaded",
            "actions": [
              {
                "action": "spawn rocket projectile at launch point"
              },
              {
                "action": "launch rocket forward at projectile speed"
              },
              {
                "action": "play launch sound effect"
              },
              {
                "action": "set weapon to not reloaded"
              },
              {
                "action": "start reload timer"
              }
            ]
          },
          {
            "name": "rocket_impact",
            "trigger": "when rocket collides with any surface or object",
            "actions": [
              {
                "action": "create explosion effect at impact point"
              },
              {
                "action": "deal direct damage to hit target"
              },
              {
                "action": "find all objects within splash radius"
              },
              {
                "action": "deal splash damage to nearby objects based on distance"
              },
              {
                "action": "apply knockback force to affected objects"
              },
              {
                "action": "play explosion sound"
              },
              {
                "action": "destroy rocket projectile"
              }
            ]
          },
          {
            "name": "reload_complete",
            "trigger": "when reload time has elapsed",
            "actions": [
              {
                "action": "set weapon to reloaded"
              },
              {
                "action": "play reload complete sound"
              }
            ]
          },
          {
            "name": "calculate_splash_damage",
            "trigger": "when applying splash damage to target",
            "actions": [
              {
                "action": "calculate distance from explosion center to target"
              },
              {
                "action": "reduce damage based on distance from center"
              },
              {
                "action": "apply calculated damage to target"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RocketLauncher : MonoBehaviour\n{\n    [Header(\"Rocket Settings\")]\n    [SerializeField] private GameObject _rocketPrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _rocketSpeed = 20f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private int _maxAmmo = 10;\n    [SerializeField] private float _reloadTime = 3f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnReloadStarted;\n    public UnityEvent OnReloadCompleted;\n\n    private float _lastFireTime;\n    private int _currentAmmo;\n    private bool _isReloading;\n\n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n\n    private void Update()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && CanFire())\n        {\n            Fire();\n        }\n\n        if (Input.GetKeyDown(KeyCode.R) && !_isReloading && _currentAmmo < _maxAmmo)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n\n    private bool CanFire()\n    {\n        return !_isReloading && \n               _currentAmmo > 0 && \n               Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n\n    private void Fire()\n    {\n        _lastFireTime = Time.time;\n        _currentAmmo--;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n\n        if (_rocketPrefab != null && _firePoint != null)\n        {\n            GameObject rocket = Instantiate(_rocketPrefab, _firePoint.position, _firePoint.rotation);\n            Rocket rocketScript = rocket.GetComponent<Rocket>();\n            if (rocketScript == null)\n            {\n                rocketScript = rocket.AddComponent<Rocket>();\n            }\n            rocketScript.Initialize(_rocketSpeed);\n        }\n\n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n\n        if (_audioSource != null && _fireSound != null)\n            _audioSource.PlayOneShot(_fireSound);\n\n        if (_currentAmmo <= 0)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n\n    private IEnumerator Reload()\n    {\n        _isReloading = true;\n        OnReloadStarted?.Invoke();\n\n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n\n        yield return new WaitForSeconds(_reloadTime);\n\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnReloadCompleted?.Invoke();\n    }\n}\n\npublic class Rocket : MonoBehaviour\n{\n    [Header(\"Rocket Properties\")]\n    [SerializeField] private float _speed = 20f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionDamage = 100f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _lifetime = 10f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n\n    [Header(\"Layers\")]\n    [SerializeField] private LayerMask _damageableLayers = -1;\n\n    private Rigidbody _rigidbody;\n    private bool _hasExploded;\n\n    public void Initialize(float speed)\n    {\n        _speed = speed;\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        _rigidbody.velocity = transform.forward * _speed;\n        _rigidbody.useGravity = true;\n\n        Destroy(gameObject, _lifetime);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_hasExploded)\n        {\n            Explode();\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_hasExploded)\n        {\n            Explode();\n        }\n    }\n\n    private void Explode()\n    {\n        _hasExploded = true;\n\n        // Create explosion effect\n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n\n        // Play explosion sound\n        if (_explosionSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n\n        // Apply splash damage\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _damageableLayers);\n        \n        foreach (Collider hit in colliders)\n        {\n            float distance = Vector3.Distance(transform.position, hit.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            damageMultiplier = Mathf.Clamp01(damageMultiplier);\n            \n            float finalDamage = _explosionDamage * damageMultiplier;\n\n            // Apply damage to player\n            if (hit.CompareTag(\"Player\"))\n            {\n                PlayerDamageReceiver playerDamage = hit.GetComponent<PlayerDamageReceiver>();\n                if (playerDamage != null)\n                {\n                    playerDamage.TakeDamage(finalDamage);\n                }\n            }\n\n            // Apply damage to enemies\n            EnemyDamageReceiver enemyDamage = hit.GetComponent<EnemyDamageReceiver>();\n            if (enemyDamage != null)\n            {\n                enemyDamage.TakeDamage(finalDamage);\n            }\n\n            // Apply explosion force to rigidbodies\n            Rigidbody hitRigidbody = hit.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n        }\n\n        Destroy(gameObject);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n}\n\npublic class PlayerDamageReceiver : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n}\n\npublic class EnemyDamageReceiver : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 50f;\n    [SerializeField] private float _currentHealth;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n            Destroy(gameObject, 0.1f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "melee weapon with combo attacks",
      "ideal_ir": {
        "class_name": "MeleeWeapon",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "damage",
            "type": "float",
            "default": 25
          },
          {
            "name": "comboWindow",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "attackCooldown",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "comboCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "maxComboCount",
            "type": "int",
            "default": 3
          },
          {
            "name": "comboDamageMultiplier",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "isAttacking",
            "type": "bool",
            "default": false
          },
          {
            "name": "canCombo",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initiate_attack",
            "trigger": "when attack input is pressed and weapon is not on cooldown",
            "actions": [
              {
                "action": "start attack animation"
              },
              {
                "action": "set attacking state to true"
              },
              {
                "action": "enable weapon collider"
              },
              {
                "action": "play attack sound effect"
              }
            ]
          },
          {
            "name": "combo_attack",
            "trigger": "when attack input is pressed during combo window and combo count is less than maximum",
            "actions": [
              {
                "action": "increment combo count"
              },
              {
                "action": "start next combo animation"
              },
              {
                "action": "increase damage by combo multiplier"
              },
              {
                "action": "reset combo window timer"
              },
              {
                "action": "play combo sound effect"
              }
            ]
          },
          {
            "name": "deal_damage",
            "trigger": "when weapon collider hits enemy during attack",
            "actions": [
              {
                "action": "calculate final damage with combo multiplier"
              },
              {
                "action": "apply damage to hit enemy"
              },
              {
                "action": "create hit effect at contact point"
              },
              {
                "action": "play impact sound"
              },
              {
                "action": "add screen shake effect"
              }
            ]
          },
          {
            "name": "end_attack",
            "trigger": "when attack animation completes",
            "actions": [
              {
                "action": "disable weapon collider"
              },
              {
                "action": "set attacking state to false"
              },
              {
                "action": "start combo window timer"
              },
              {
                "action": "enable combo possibility"
              }
            ]
          },
          {
            "name": "reset_combo",
            "trigger": "when combo window expires without new attack input",
            "actions": [
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "disable combo possibility"
              },
              {
                "action": "start attack cooldown timer"
              }
            ]
          },
          {
            "name": "finish_combo_sequence",
            "trigger": "when maximum combo count is reached",
            "actions": [
              {
                "action": "play finishing move animation"
              },
              {
                "action": "apply maximum damage with full multiplier"
              },
              {
                "action": "create powerful visual effect"
              },
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "start extended cooldown period"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MeleeWeapon : MonoBehaviour\n{\n    [System.Serializable]\n    public class ComboAttack\n    {\n        public string attackName;\n        public float damage;\n        public float range;\n        public float attackDuration;\n        public float comboWindow;\n        public AnimationClip attackAnimation;\n        public AudioClip attackSound;\n        public GameObject hitEffect;\n        public Vector3 attackOffset;\n        public float knockbackForce;\n    }\n\n    [Header(\"Weapon Settings\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    [SerializeField] private float _baseDamage = 10f;\n    \n    [Header(\"Combo System\")]\n    [SerializeField] private List<ComboAttack> _comboAttacks = new List<ComboAttack>();\n    [SerializeField] private float _comboResetTime = 2f;\n    [SerializeField] private bool _canCancelCombo = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private TrailRenderer _weaponTrail;\n    [SerializeField] private ParticleSystem _hitParticles;\n    [SerializeField] private GameObject _slashEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnAttackHit;\n    public UnityEvent OnComboComplete;\n    public UnityEvent<int> OnComboStep;\n\n    private Animator _animator;\n    private int _currentComboIndex = 0;\n    private bool _isAttacking = false;\n    private bool _canAttack = true;\n    private float _lastAttackTime;\n    private Coroutine _comboResetCoroutine;\n    private List<Collider> _hitTargets = new List<Collider>();\n\n    private void Start()\n    {\n        _animator = GetComponentInParent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_attackPoint == null)\n            _attackPoint = transform;\n            \n        SetupDefaultCombo();\n    }\n\n    private void Update()\n    {\n        HandleInput();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            PerformAttack();\n        }\n    }\n\n    private void SetupDefaultCombo()\n    {\n        if (_comboAttacks.Count == 0)\n        {\n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Light Attack\",\n                damage = _baseDamage,\n                range = 2f,\n                attackDuration = 0.5f,\n                comboWindow = 1f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 5f\n            });\n            \n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Medium Attack\",\n                damage = _baseDamage * 1.5f,\n                range = 2.5f,\n                attackDuration = 0.7f,\n                comboWindow = 1.2f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 8f\n            });\n            \n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Heavy Attack\",\n                damage = _baseDamage * 2f,\n                range = 3f,\n                attackDuration = 1f,\n                comboWindow = 0.5f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 12f\n            });\n        }\n    }\n\n    public void PerformAttack()\n    {\n        if (!_canAttack || _isAttacking) return;\n\n        ComboAttack currentAttack = _comboAttacks[_currentComboIndex];\n        StartCoroutine(ExecuteAttack(currentAttack));\n    }\n\n    private IEnumerator ExecuteAttack(ComboAttack attack)\n    {\n        _isAttacking = true;\n        _canAttack = false;\n        _hitTargets.Clear();\n\n        PlayAttackAnimation(attack);\n        PlayAttackSound(attack);\n        ShowVisualEffects(attack);\n\n        yield return new WaitForSeconds(attack.attackDuration * 0.3f);\n\n        PerformHitDetection(attack);\n\n        yield return new WaitForSeconds(attack.attackDuration * 0.7f);\n\n        _isAttacking = false;\n        \n        float currentTime = Time.time;\n        bool withinComboWindow = (currentTime - _lastAttackTime) <= attack.comboWindow;\n        \n        if (withinComboWindow && _currentComboIndex < _comboAttacks.Count - 1)\n        {\n            _currentComboIndex++;\n            _canAttack = true;\n            OnComboStep?.Invoke(_currentComboIndex);\n        }\n        else\n        {\n            if (_currentComboIndex >= _comboAttacks.Count - 1)\n            {\n                OnComboComplete?.Invoke();\n            }\n            ResetCombo();\n        }\n\n        _lastAttackTime = currentTime;\n        StartComboResetTimer();\n    }\n\n    private void PerformHitDetection(ComboAttack attack)\n    {\n        Vector3 attackPosition = _attackPoint.position + transform.TransformDirection(attack.attackOffset);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attack.range, _enemyLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (_hitTargets.Contains(hitCollider)) continue;\n            \n            _hitTargets.Add(hitCollider);\n            \n            if (hitCollider.CompareTag(\"Enemy\"))\n            {\n                DealDamage(hitCollider, attack);\n                ApplyKnockback(hitCollider, attack);\n                SpawnHitEffect(hitCollider.transform.position, attack);\n                PlayHitSound();\n                OnAttackHit?.Invoke(attack.damage);\n            }\n        }\n    }\n\n    private void DealDamage(Collider target, ComboAttack attack)\n    {\n        var healthComponent = target.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(attack.damage);\n        }\n        else\n        {\n            target.SendMessage(\"TakeDamage\", attack.damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n\n    private void ApplyKnockback(Collider target, ComboAttack attack)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * attack.knockbackForce, ForceMode.Impulse);\n        }\n    }\n\n    private void PlayAttackAnimation(ComboAttack attack)\n    {\n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Attack\");\n            _animator.SetInteger(\"ComboIndex\", _currentComboIndex);\n        }\n    }\n\n    private void PlayAttackSound(ComboAttack attack)\n    {\n        if (_audioSource != null)\n        {\n            AudioClip soundToPlay = attack.attackSound != null ? attack.attackSound : _swingSound;\n            if (soundToPlay != null)\n            {\n                _audioSource.PlayOneShot(soundToPlay);\n            }\n        }\n    }\n\n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n\n    private void ShowVisualEffects(ComboAttack attack)\n    {\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = true;\n            StartCoroutine(DisableTrailAfterDelay(0.3f));\n        }\n\n        if (_slashEffect != null)\n        {\n            GameObject effect = Instantiate(_slashEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(effect, 2f);\n        }\n    }\n\n    private void SpawnHitEffect(Vector3 position, ComboAttack attack)\n    {\n        if (_hitParticles != null)\n        {\n            _hitParticles.transform.position = position;\n            _hitParticles.Play();\n        }\n\n        if (attack.hitEffect != null)\n        {\n            GameObject effect = Instantiate(attack.hitEffect, position, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n\n    private IEnumerator DisableTrailAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = false;\n        }\n    }\n\n    private void StartComboResetTimer()\n    {\n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n        _comboResetCoroutine = StartCoroutine(ComboResetTimer());\n    }\n\n    private IEnumerator ComboResetTimer()\n    {\n        yield return new WaitForSeconds(_comboResetTime);\n        ResetCombo();\n    }\n\n    private void ResetCombo()\n    {\n        _currentComboIndex = 0;\n        _canAttack = true;\n        _isAttacking = false;\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n            _comboResetCoroutine = null;\n        }\n    }\n\n    public void CancelCombo()\n    {\n        if (_canCancelCombo)\n        {\n            ResetCombo();\n        }\n    }\n\n    public bool IsAttacking()\n    {\n        return _isAttacking;\n    }\n\n    public int GetCurrentComboStep()\n    {\n        return _currentComboIndex;\n    }\n\n    public int GetMaxComboSteps()\n    {\n        return _comboAttacks.Count;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_attackPoint == null) return;\n\n        Gizmos.color = Color.red;\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            ComboAttack attack = _comboAttacks[i];\n            Vector3 attackPos = _attackPoint.position + transform.TransformDirection(attack.attackOffset);\n            Gizmos.DrawWireSphere(attackPos, attack.range);\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n\n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n\n    public bool IsAlive()\n    {\n        return _currentHealth > 0f;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "bow that charges for power shots",
      "ideal_ir": {
        "class_name": "ChargingBow",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxChargeTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "minArrowSpeed",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "maxArrowSpeed",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "arrowPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "shootPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "currentChargeTime",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "isCharging",
            "type": "bool",
            "default": false
          },
          {
            "name": "chargingSoundPitch",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "start_charging",
            "trigger": "when player presses and holds fire button",
            "actions": [
              {
                "action": "begin charging the bow"
              },
              {
                "action": "reset charge time to zero"
              },
              {
                "action": "play charging sound effect"
              },
              {
                "action": "show visual charging indicator"
              }
            ]
          },
          {
            "name": "continue_charging",
            "trigger": "while fire button is held and charge time is less than maximum",
            "actions": [
              {
                "action": "increase charge time"
              },
              {
                "action": "increase charging sound pitch based on charge level"
              },
              {
                "action": "update visual charging indicator intensity"
              }
            ]
          },
          {
            "name": "release_arrow",
            "trigger": "when fire button is released",
            "actions": [
              {
                "action": "calculate arrow speed based on charge time"
              },
              {
                "action": "spawn arrow at shoot point"
              },
              {
                "action": "launch arrow forward with calculated speed"
              },
              {
                "action": "stop charging sound"
              },
              {
                "action": "hide charging indicator"
              },
              {
                "action": "reset charge time to zero"
              }
            ]
          },
          {
            "name": "max_charge_reached",
            "trigger": "when charge time reaches maximum",
            "actions": [
              {
                "action": "maintain maximum charge level"
              },
              {
                "action": "play fully charged sound effect"
              },
              {
                "action": "show maximum charge visual effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Bow : MonoBehaviour\n{\n    [Header(\"Bow Settings\")]\n    [SerializeField] private float _maxChargeTime = 2f;\n    [SerializeField] private float _minPower = 0.3f;\n    [SerializeField] private float _maxPower = 1f;\n    [SerializeField] private AnimationCurve _chargeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Arrow Settings\")]\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _arrowSpawnPoint;\n    [SerializeField] private float _baseArrowSpeed = 20f;\n    [SerializeField] private float _maxArrowSpeed = 50f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private LineRenderer _trajectoryLine;\n    [SerializeField] private int _trajectoryPoints = 30;\n    [SerializeField] private float _trajectoryTimeStep = 0.1f;\n    [SerializeField] private ParticleSystem _chargeEffect;\n    [SerializeField] private Transform _bowString;\n    [SerializeField] private float _maxStringPull = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drawSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _chargeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeChanged;\n    public UnityEvent<float> OnArrowFired;\n    \n    private bool _isCharging;\n    private float _currentChargeTime;\n    private float _currentPower;\n    private Vector3 _originalStringPosition;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_bowString != null)\n            _originalStringPosition = _bowString.localPosition;\n            \n        if (_trajectoryLine != null)\n        {\n            _trajectoryLine.positionCount = _trajectoryPoints;\n            _trajectoryLine.enabled = false;\n        }\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharging();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        bool drawInput = Input.GetMouseButton(0) || Input.GetKey(KeyCode.Space);\n        bool releaseInput = Input.GetMouseButtonUp(0) || Input.GetKeyUp(KeyCode.Space);\n        \n        if (drawInput && !_isCharging && CanFire())\n        {\n            StartCharging();\n        }\n        else if (releaseInput && _isCharging)\n        {\n            FireArrow();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return _arrowPrefab != null && _arrowSpawnPoint != null;\n    }\n    \n    private void StartCharging()\n    {\n        _isCharging = true;\n        _currentChargeTime = 0f;\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Play();\n            \n        if (_trajectoryLine != null)\n            _trajectoryLine.enabled = true;\n            \n        PlaySound(_drawSound);\n    }\n    \n    private void UpdateCharging()\n    {\n        if (!_isCharging) return;\n        \n        _currentChargeTime += Time.deltaTime;\n        float chargeProgress = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        _currentPower = Mathf.Lerp(_minPower, _maxPower, _chargeCurve.Evaluate(chargeProgress));\n        \n        OnChargeChanged?.Invoke(_currentPower);\n        \n        if (_chargeSound != null && _audioSource != null && !_audioSource.isPlaying)\n        {\n            _audioSource.clip = _chargeSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_isCharging)\n        {\n            UpdateBowString();\n            UpdateTrajectory();\n            UpdateChargeEffect();\n        }\n    }\n    \n    private void UpdateBowString()\n    {\n        if (_bowString == null) return;\n        \n        float pullAmount = _currentPower * _maxStringPull;\n        Vector3 pullDirection = -transform.forward;\n        _bowString.localPosition = _originalStringPosition + pullDirection * pullAmount;\n    }\n    \n    private void UpdateTrajectory()\n    {\n        if (_trajectoryLine == null || _arrowSpawnPoint == null) return;\n        \n        Vector3 velocity = GetArrowVelocity();\n        Vector3 startPos = _arrowSpawnPoint.position;\n        \n        for (int i = 0; i < _trajectoryPoints; i++)\n        {\n            float time = i * _trajectoryTimeStep;\n            Vector3 point = startPos + velocity * time + 0.5f * Physics.gravity * time * time;\n            _trajectoryLine.SetPosition(i, point);\n        }\n    }\n    \n    private void UpdateChargeEffect()\n    {\n        if (_chargeEffect == null) return;\n        \n        var main = _chargeEffect.main;\n        main.startLifetime = _currentPower * 2f;\n        \n        var emission = _chargeEffect.emission;\n        emission.rateOverTime = _currentPower * 50f;\n    }\n    \n    private Vector3 GetArrowVelocity()\n    {\n        Vector3 direction = GetAimDirection();\n        float speed = Mathf.Lerp(_baseArrowSpeed, _maxArrowSpeed, _currentPower);\n        return direction * speed;\n    }\n    \n    private Vector3 GetAimDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f));\n            return ray.direction;\n        }\n        \n        return transform.forward;\n    }\n    \n    private void FireArrow()\n    {\n        if (_arrowPrefab == null || _arrowSpawnPoint == null) return;\n        \n        GameObject arrow = Instantiate(_arrowPrefab, _arrowSpawnPoint.position, _arrowSpawnPoint.rotation);\n        \n        Rigidbody arrowRb = arrow.GetComponent<Rigidbody>();\n        if (arrowRb == null)\n            arrowRb = arrow.AddComponent<Rigidbody>();\n            \n        Vector3 velocity = GetArrowVelocity();\n        arrowRb.velocity = velocity;\n        \n        Arrow arrowScript = arrow.GetComponent<Arrow>();\n        if (arrowScript == null)\n            arrowScript = arrow.AddComponent<Arrow>();\n            \n        arrowScript.Initialize(_currentPower);\n        \n        OnArrowFired?.Invoke(_currentPower);\n        PlaySound(_releaseSound);\n        ResetBow();\n    }\n    \n    private void ResetBow()\n    {\n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _currentPower = 0f;\n        \n        if (_bowString != null)\n            _bowString.localPosition = _originalStringPosition;\n            \n        if (_trajectoryLine != null)\n            _trajectoryLine.enabled = false;\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _chargeSound)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.loop = false;\n            _audioSource.Play();\n        }\n    }\n    \n    public float GetCurrentPower()\n    {\n        return _currentPower;\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n}\n\npublic class Arrow : MonoBehaviour\n{\n    [Header(\"Arrow Settings\")]\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private float _lifetime = 10f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private float _powerMultiplier = 1f;\n    private bool _hasHit;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    public void Initialize(float powerMultiplier)\n    {\n        _powerMultiplier = powerMultiplier;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        HandleHit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit) return;\n        \n        HandleHit(collision.collider);\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        if (hitCollider.CompareTag(\"Player\"))\n            return;\n            \n        float finalDamage = _damage * _powerMultiplier;\n        \n        if (hitCollider.CompareTag(\"Enemy\"))\n        {\n            var enemyHealth = hitCollider.GetComponent<EnemyHealth>();\n            if (enemyHealth != null)\n                enemyHealth.TakeDamage(finalDamage);\n        }\n        \n        if (_stickToSurfaces)\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.isKinematic = true;\n                _rigidbody.velocity = Vector3.zero;\n            }\n            \n            transform.SetParent(hitCollider.transform);\n        }\n        \n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n        \n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n        \n        if (!_stickToSurfaces)\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n}\n\npublic class EnemyHealth : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioClip _deathSound;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0f, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        OnDeath?.Invoke();\n        \n        if (_deathEffect != null)\n        {\n            Instantiate(_deathEffect, transform.position, transform.rotation);\n        }\n        \n        if (_deathSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n            Destroy(gameObject, _deathSound.length);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "flamethrower with particle effects",
      "ideal_ir": {
        "class_name": "Flamethrower",
        "components": [
          "ParticleSystem",
          "AudioSource",
          "LineRenderer"
        ],
        "fields": [
          {
            "name": "maxRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "damage",
            "type": "float",
            "default": 25
          },
          {
            "name": "fuelCapacity",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentFuel",
            "type": "float",
            "default": 100
          },
          {
            "name": "fuelConsumptionRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "isFiring",
            "type": "bool",
            "default": false
          },
          {
            "name": "fireButton",
            "type": "string",
            "default": "Fire1"
          },
          {
            "name": "flameParticles",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "smokeParticles",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "fireSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "igniteSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "start_firing",
            "trigger": "when fire button is pressed and fuel is available",
            "actions": [
              {
                "action": "set firing state to true"
              },
              {
                "action": "start flame particle emission"
              },
              {
                "action": "start smoke particle emission"
              },
              {
                "action": "play ignite sound effect"
              },
              {
                "action": "begin continuous fire sound loop"
              }
            ]
          },
          {
            "name": "maintain_firing",
            "trigger": "while fire button is held and fuel remains",
            "actions": [
              {
                "action": "continue flame particle emission"
              },
              {
                "action": "reduce current fuel by consumption rate"
              },
              {
                "action": "cast ray forward to detect targets within range"
              },
              {
                "action": "apply damage to any flammable objects hit"
              },
              {
                "action": "create heat distortion effect along flame path"
              }
            ]
          },
          {
            "name": "stop_firing",
            "trigger": "when fire button is released or fuel is depleted",
            "actions": [
              {
                "action": "set firing state to false"
              },
              {
                "action": "stop flame particle emission"
              },
              {
                "action": "gradually reduce smoke particle emission"
              },
              {
                "action": "stop fire sound loop"
              },
              {
                "action": "clear heat distortion effect"
              }
            ]
          },
          {
            "name": "fuel_warning",
            "trigger": "when fuel drops below twenty percent",
            "actions": [
              {
                "action": "reduce flame particle intensity"
              },
              {
                "action": "create flickering flame effect"
              },
              {
                "action": "play low fuel warning sound"
              }
            ]
          },
          {
            "name": "reload_fuel",
            "trigger": "when reload button is pressed and not currently firing",
            "actions": [
              {
                "action": "restore fuel to maximum capacity"
              },
              {
                "action": "play fuel reload sound effect"
              },
              {
                "action": "reset flame particle intensity to full"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Flamethrower : MonoBehaviour\n{\n    [Header(\"Flame Settings\")]\n    [SerializeField] private float _maxRange = 10f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageRate = 0.1f;\n    [SerializeField] private float _fuelConsumption = 10f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _currentFuel = 100f;\n    [SerializeField] private float _refuelRate = 20f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private ParticleSystem _sparkParticles;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _igniteSound;\n    [SerializeField] private AudioClip _flameLoopSound;\n    [SerializeField] private AudioClip _extinguishSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _flameLight;\n    [SerializeField] private float _lightIntensity = 2f;\n    [SerializeField] private Color _flameColor = Color.red;\n    [SerializeField] private AnimationCurve _lightFlicker = AnimationCurve.Linear(0, 0.8f, 1, 1.2f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _refuelKey = KeyCode.R;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnIgnite;\n    public UnityEvent OnExtinguish;\n    public UnityEvent OnFuelEmpty;\n    public UnityEvent<float> OnFuelChanged;\n    \n    private bool _isFiring;\n    private float _damageTimer;\n    private float _lightFlickerTime;\n    private System.Collections.Generic.HashSet<Collider> _targetsInRange = new System.Collections.Generic.HashSet<Collider>();\n    private ParticleSystem.MainModule _flameMain;\n    private ParticleSystem.MainModule _smokeMain;\n    private ParticleSystem.MainModule _sparkMain;\n    private float _originalLightIntensity;\n    \n    private void Start()\n    {\n        _currentFuel = _maxFuel;\n        \n        if (_flameParticles != null)\n        {\n            _flameMain = _flameParticles.main;\n            _flameParticles.Stop();\n        }\n        \n        if (_smokeParticles != null)\n        {\n            _smokeMain = _smokeParticles.main;\n            _smokeParticles.Stop();\n        }\n        \n        if (_sparkParticles != null)\n        {\n            _sparkMain = _sparkParticles.main;\n            _sparkParticles.Stop();\n        }\n        \n        if (_flameLight != null)\n        {\n            _originalLightIntensity = _flameLight.intensity;\n            _flameLight.intensity = 0f;\n            _flameLight.color = _flameColor;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateFlamethrower();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        bool shouldFire = Input.GetKey(_fireKey) && _currentFuel > 0f;\n        \n        if (shouldFire && !_isFiring)\n        {\n            StartFiring();\n        }\n        else if (!shouldFire && _isFiring)\n        {\n            StopFiring();\n        }\n        \n        if (Input.GetKeyDown(_refuelKey))\n        {\n            Refuel();\n        }\n    }\n    \n    private void UpdateFlamethrower()\n    {\n        if (_isFiring)\n        {\n            ConsumeFuel();\n            DealDamage();\n            DetectTargets();\n        }\n        \n        _lightFlickerTime += Time.deltaTime * 5f;\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_flameLight != null)\n        {\n            if (_isFiring)\n            {\n                float flickerValue = _lightFlicker.Evaluate(Mathf.PingPong(_lightFlickerTime, 1f));\n                _flameLight.intensity = _lightIntensity * flickerValue;\n            }\n            else\n            {\n                _flameLight.intensity = Mathf.Lerp(_flameLight.intensity, 0f, Time.deltaTime * 5f);\n            }\n        }\n    }\n    \n    private void StartFiring()\n    {\n        _isFiring = true;\n        \n        if (_flameParticles != null)\n            _flameParticles.Play();\n        \n        if (_smokeParticles != null)\n            _smokeParticles.Play();\n        \n        if (_sparkParticles != null)\n            _sparkParticles.Play();\n        \n        PlaySound(_igniteSound);\n        \n        if (_flameLoopSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _flameLoopSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        OnIgnite?.Invoke();\n    }\n    \n    private void StopFiring()\n    {\n        _isFiring = false;\n        \n        if (_flameParticles != null)\n            _flameParticles.Stop();\n        \n        if (_smokeParticles != null)\n            _smokeParticles.Stop();\n        \n        if (_sparkParticles != null)\n            _sparkParticles.Stop();\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n        \n        PlaySound(_extinguishSound);\n        \n        _targetsInRange.Clear();\n        OnExtinguish?.Invoke();\n    }\n    \n    private void ConsumeFuel()\n    {\n        _currentFuel -= _fuelConsumption * Time.deltaTime;\n        _currentFuel = Mathf.Max(0f, _currentFuel);\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n        \n        if (_currentFuel <= 0f)\n        {\n            StopFiring();\n            OnFuelEmpty?.Invoke();\n        }\n    }\n    \n    private void DetectTargets()\n    {\n        _targetsInRange.Clear();\n        \n        RaycastHit[] hits = Physics.SphereCastAll(\n            transform.position,\n            1f,\n            transform.forward,\n            _maxRange,\n            _targetLayers\n        );\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider != null && hit.collider.gameObject != gameObject)\n            {\n                _targetsInRange.Add(hit.collider);\n            }\n        }\n    }\n    \n    private void DealDamage()\n    {\n        _damageTimer += Time.deltaTime;\n        \n        if (_damageTimer >= _damageRate)\n        {\n            _damageTimer = 0f;\n            \n            foreach (Collider target in _targetsInRange)\n            {\n                if (target == null) continue;\n                \n                // Apply damage to objects with health components\n                var healthComponent = target.GetComponent<Health>();\n                if (healthComponent != null)\n                {\n                    healthComponent.TakeDamage(_damage);\n                }\n                \n                // Apply fire effect to burnable objects\n                var burnableComponent = target.GetComponent<Burnable>();\n                if (burnableComponent != null)\n                {\n                    burnableComponent.Ignite();\n                }\n                \n                // Push rigidbodies away\n                var rb = target.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 pushDirection = (target.transform.position - transform.position).normalized;\n                    rb.AddForce(pushDirection * 5f, ForceMode.Impulse);\n                }\n            }\n        }\n    }\n    \n    private void Refuel()\n    {\n        _currentFuel = _maxFuel;\n        OnFuelChanged?.Invoke(1f);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetFuel(float amount)\n    {\n        _currentFuel = Mathf.Clamp(amount, 0f, _maxFuel);\n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return _currentFuel / _maxFuel;\n    }\n    \n    public bool IsFiring()\n    {\n        return _isFiring;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position + transform.forward * _maxRange, 1f);\n        Gizmos.DrawRay(transform.position, transform.forward * _maxRange);\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0f, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n}\n\n[System.Serializable]\npublic class Burnable : MonoBehaviour\n{\n    [SerializeField] private float _burnDuration = 5f;\n    [SerializeField] private float _burnDamage = 10f;\n    [SerializeField] private ParticleSystem _fireEffect;\n    \n    public UnityEvent OnIgnited;\n    public UnityEvent OnExtinguished;\n    \n    private bool _isBurning;\n    private float _burnTimer;\n    private Health _health;\n    \n    private void Start()\n    {\n        _health = GetComponent<Health>();\n    }\n    \n    private void Update()\n    {\n        if (_isBurning)\n        {\n            _burnTimer -= Time.deltaTime;\n            \n            if (_health != null)\n            {\n                _health.TakeDamage(_burnDamage * Time.deltaTime);\n            }\n            \n            if (_burnTimer <= 0f)\n            {\n                Extinguish();\n            }\n        }\n    }\n    \n    public void Ignite()\n    {\n        if (!_isBurning)\n        {\n            _isBurning = true;\n            _burnTimer = _burnDuration;\n            \n            if (_fireEffect != null)\n                _fireEffect.Play();\n            \n            OnIgnited?.Invoke();\n        }\n        else\n        {\n            _burnTimer = _burnDuration; // Reset burn timer\n        }\n    }\n    \n    public void Extinguish()\n    {\n        if (_isBurning)\n        {\n            _isBurning = false;\n            \n            if (_fireEffect != null)\n                _fireEffect.Stop();\n            \n            OnExtinguished?.Invoke();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "shield that blocks incoming damage",
      "ideal_ir": {
        "class_name": "Shield",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "durability",
            "type": "float",
            "default": 100
          },
          {
            "name": "maxDurability",
            "type": "float",
            "default": 100
          },
          {
            "name": "blockEffectiveness",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "block_damage",
            "trigger": "when projectile or attack collides with shield and shield is active",
            "actions": [
              {
                "action": "reduce incoming damage by block effectiveness percentage"
              },
              {
                "action": "decrease shield durability by remaining damage amount"
              },
              {
                "action": "play shield impact visual effect"
              },
              {
                "action": "play shield impact sound effect"
              }
            ]
          },
          {
            "name": "shield_break",
            "trigger": "when shield durability reaches zero",
            "actions": [
              {
                "action": "set shield as inactive"
              },
              {
                "action": "play shield breaking visual effect"
              },
              {
                "action": "play shield breaking sound effect"
              },
              {
                "action": "disable shield collider"
              }
            ]
          },
          {
            "name": "repair_shield",
            "trigger": "when repair ability is used on shield",
            "actions": [
              {
                "action": "restore shield durability to maximum"
              },
              {
                "action": "set shield as active"
              },
              {
                "action": "enable shield collider"
              },
              {
                "action": "play shield repair visual effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Shield : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _maxShieldHealth = 100f;\n    [SerializeField] private float _rechargeDelay = 3f;\n    [SerializeField] private float _rechargeRate = 20f;\n    [SerializeField] private bool _blockAllDamage = true;\n    [SerializeField] private float _damageReduction = 0.8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldVisual;\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private ParticleSystem _rechargeEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private AudioClip _rechargeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnShieldDamaged;\n    public UnityEvent OnShieldBroken;\n    public UnityEvent OnShieldRestored;\n    public UnityEvent<float, float> OnShieldHealthChanged;\n    \n    private float _currentShieldHealth;\n    private bool _isRecharging;\n    private float _lastDamageTime;\n    private Renderer _shieldRenderer;\n    private Color _originalColor;\n    private bool _isShieldActive;\n    \n    private void Start()\n    {\n        _currentShieldHealth = _maxShieldHealth;\n        _isShieldActive = true;\n        \n        if (_shieldVisual != null)\n        {\n            _shieldRenderer = _shieldVisual.GetComponent<Renderer>();\n            if (_shieldRenderer != null)\n            {\n                _originalColor = _shieldRenderer.material.color;\n            }\n        }\n        \n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    private void Update()\n    {\n        if (!_isShieldActive && !_isRecharging && Time.time - _lastDamageTime >= _rechargeDelay)\n        {\n            StartRecharge();\n        }\n        \n        if (_isRecharging)\n        {\n            RechargeShield();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Projectile\") || other.CompareTag(\"Enemy\"))\n        {\n            HandleIncomingDamage(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Projectile\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            HandleIncomingDamage(collision.collider);\n        }\n    }\n    \n    private void HandleIncomingDamage(Collider damageSource)\n    {\n        if (!_isShieldActive) return;\n        \n        float damage = GetDamageFromSource(damageSource);\n        \n        if (_blockAllDamage)\n        {\n            BlockDamage(damage, damageSource);\n        }\n        else\n        {\n            float reducedDamage = damage * (1f - _damageReduction);\n            float shieldDamage = damage * _damageReduction;\n            BlockDamage(shieldDamage, damageSource);\n            \n            // Pass reduced damage to player if they have a health component\n            var playerHealth = GetComponentInParent<MonoBehaviour>();\n            if (playerHealth != null)\n            {\n                playerHealth.SendMessage(\"TakeDamage\", reducedDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private float GetDamageFromSource(Collider source)\n    {\n        // Try to get damage from various common damage components\n        var damageComponent = source.GetComponent<MonoBehaviour>();\n        if (damageComponent != null)\n        {\n            // Try to get damage value through reflection or common field names\n            var damageField = damageComponent.GetType().GetField(\"damage\");\n            if (damageField != null && damageField.FieldType == typeof(float))\n            {\n                return (float)damageField.GetValue(damageComponent);\n            }\n            \n            var damageProperty = damageComponent.GetType().GetProperty(\"Damage\");\n            if (damageProperty != null && damageProperty.PropertyType == typeof(float))\n            {\n                return (float)damageProperty.GetValue(damageComponent);\n            }\n        }\n        \n        // Default damage if no damage component found\n        return 25f;\n    }\n    \n    private void BlockDamage(float damage, Collider source)\n    {\n        _currentShieldHealth -= damage;\n        _lastDamageTime = Time.time;\n        _isRecharging = false;\n        \n        PlayHitEffect();\n        PlaySound(_hitSound);\n        OnShieldDamaged?.Invoke(damage);\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n        \n        if (_currentShieldHealth <= 0)\n        {\n            BreakShield();\n        }\n        \n        // Destroy or disable the damage source\n        if (source.CompareTag(\"Projectile\"))\n        {\n            Destroy(source.gameObject);\n        }\n        \n        UpdateShieldVisual();\n    }\n    \n    private void BreakShield()\n    {\n        _isShieldActive = false;\n        _currentShieldHealth = 0;\n        \n        PlaySound(_breakSound);\n        OnShieldBroken?.Invoke();\n        UpdateShieldVisual();\n        \n        if (_hitEffect != null)\n        {\n            _hitEffect.Stop();\n        }\n    }\n    \n    private void StartRecharge()\n    {\n        _isRecharging = true;\n        PlaySound(_rechargeSound);\n        \n        if (_rechargeEffect != null)\n        {\n            _rechargeEffect.Play();\n        }\n    }\n    \n    private void RechargeShield()\n    {\n        _currentShieldHealth += _rechargeRate * Time.deltaTime;\n        \n        if (_currentShieldHealth >= _maxShieldHealth)\n        {\n            _currentShieldHealth = _maxShieldHealth;\n            _isRecharging = false;\n            _isShieldActive = true;\n            \n            OnShieldRestored?.Invoke();\n            \n            if (_rechargeEffect != null)\n            {\n                _rechargeEffect.Stop();\n            }\n        }\n        \n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n        UpdateShieldVisual();\n    }\n    \n    private void UpdateShieldVisual()\n    {\n        if (_shieldVisual != null)\n        {\n            _shieldVisual.SetActive(_isShieldActive);\n            \n            if (_shieldRenderer != null)\n            {\n                float healthPercent = _currentShieldHealth / _maxShieldHealth;\n                Color shieldColor = Color.Lerp(Color.red, _originalColor, healthPercent);\n                shieldColor.a = _originalColor.a * healthPercent;\n                _shieldRenderer.material.color = shieldColor;\n            }\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_hitEffect != null)\n        {\n            _hitEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetShieldHealth(float health)\n    {\n        _currentShieldHealth = Mathf.Clamp(health, 0, _maxShieldHealth);\n        _isShieldActive = _currentShieldHealth > 0;\n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    public void RepairShield(float amount)\n    {\n        float oldHealth = _currentShieldHealth;\n        _currentShieldHealth = Mathf.Clamp(_currentShieldHealth + amount, 0, _maxShieldHealth);\n        \n        if (oldHealth <= 0 && _currentShieldHealth > 0)\n        {\n            _isShieldActive = true;\n            OnShieldRestored?.Invoke();\n        }\n        \n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    public float GetShieldHealthPercent()\n    {\n        return _currentShieldHealth / _maxShieldHealth;\n    }\n    \n    public bool IsShieldActive()\n    {\n        return _isShieldActive;\n    }\n    \n    public void ToggleShield(bool active)\n    {\n        _isShieldActive = active && _currentShieldHealth > 0;\n        UpdateShieldVisual();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mine that detonates when stepped on",
      "ideal_ir": {
        "class_name": "ProximityMine",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "explosionDamage",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "armingDelay",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isArmed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "arm_mine",
            "trigger": "when arming delay time has passed after being placed",
            "actions": [
              {
                "action": "set mine to armed state"
              },
              {
                "action": "play arming sound effect"
              },
              {
                "action": "activate blinking light indicator"
              }
            ]
          },
          {
            "name": "detonate_on_contact",
            "trigger": "when something steps on or touches the mine and mine is armed",
            "actions": [
              {
                "action": "create explosion effect at mine location"
              },
              {
                "action": "play explosion sound"
              },
              {
                "action": "deal damage to all objects within explosion radius"
              },
              {
                "action": "apply explosive force to nearby objects"
              },
              {
                "action": "destroy the mine object"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when mine is armed",
            "actions": [
              {
                "action": "slowly pulse red light to indicate active state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LandMine : MonoBehaviour\n{\n    [Header(\"Mine Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _damage = 100f;\n    [SerializeField] private float _armingDelay = 1f;\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private GameObject _armedIndicator;\n    [SerializeField] private AudioClip _armingSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _blinkRate = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnMineArmed;\n    public UnityEvent OnMineTriggered;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private bool _isArmed = false;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Collider _triggerCollider;\n    private Renderer _indicatorRenderer;\n    private float _blinkTimer = 0f;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider == null)\n        {\n            _triggerCollider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_triggerCollider).radius = 0.5f;\n        }\n        _triggerCollider.isTrigger = true;\n        \n        if (_armedIndicator != null)\n        {\n            _indicatorRenderer = _armedIndicator.GetComponent<Renderer>();\n            _armedIndicator.SetActive(false);\n        }\n        \n        StartCoroutine(ArmMineAfterDelay());\n    }\n    \n    private void Update()\n    {\n        if (_isArmed && !_hasExploded && _indicatorRenderer != null)\n        {\n            _blinkTimer += Time.deltaTime;\n            if (_blinkTimer >= 1f / _blinkRate)\n            {\n                _blinkTimer = 0f;\n                _indicatorRenderer.enabled = !_indicatorRenderer.enabled;\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ArmMineAfterDelay()\n    {\n        yield return new WaitForSeconds(_armingDelay);\n        ArmMine();\n    }\n    \n    private void ArmMine()\n    {\n        if (_hasExploded) return;\n        \n        _isArmed = true;\n        \n        if (_armedIndicator != null)\n        {\n            _armedIndicator.SetActive(true);\n        }\n        \n        if (_armingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_armingSound);\n        }\n        \n        OnMineArmed?.Invoke();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isArmed || _hasExploded) return;\n        \n        if (IsValidTrigger(other))\n        {\n            TriggerExplosion();\n        }\n    }\n    \n    private bool IsValidTrigger(Collider other)\n    {\n        return (_triggerLayers.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    private void TriggerExplosion()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        OnMineTriggered?.Invoke();\n        \n        if (_explosionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n        \n        if (_explosionPrefab != null)\n        {\n            Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n        }\n        \n        ApplyExplosionEffects();\n        \n        if (_armedIndicator != null)\n        {\n            _armedIndicator.SetActive(false);\n        }\n        \n        StartCoroutine(DestroyAfterExplosion());\n    }\n    \n    private void ApplyExplosionEffects()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hit in colliders)\n        {\n            if (hit == _triggerCollider) continue;\n            \n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            if (hit.CompareTag(\"Player\"))\n            {\n                ApplyDamageToPlayer(hit.gameObject);\n            }\n            \n            IDamageable damageable = hit.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                float finalDamage = _damage * damageMultiplier;\n                \n                damageable.TakeDamage(finalDamage);\n                OnDamageDealt?.Invoke(finalDamage);\n            }\n        }\n    }\n    \n    private void ApplyDamageToPlayer(GameObject player)\n    {\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        float damageMultiplier = 1f - (distance / _explosionRadius);\n        float finalDamage = _damage * damageMultiplier;\n        \n        OnDamageDealt?.Invoke(finalDamage);\n        \n        player.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private System.Collections.IEnumerator DestroyAfterExplosion()\n    {\n        GetComponent<Renderer>().enabled = false;\n        _triggerCollider.enabled = false;\n        \n        yield return new WaitForSeconds(2f);\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isArmed ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        if (!_isArmed)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n        }\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "boomerang that returns to thrower",
      "ideal_ir": {
        "class_name": "Boomerang",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "throwForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "returnForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "spinSpeed",
            "type": "float",
            "default": 720
          },
          {
            "name": "maxDistance",
            "type": "float",
            "default": 20
          },
          {
            "name": "thrower",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isReturning",
            "type": "bool",
            "default": false
          },
          {
            "name": "hasBeenThrown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "throw_boomerang",
            "trigger": "when throw input is pressed and boomerang has not been thrown",
            "actions": [
              {
                "action": "store reference to the player as thrower"
              },
              {
                "action": "apply forward force based on throw force"
              },
              {
                "action": "mark boomerang as thrown"
              },
              {
                "action": "start spinning continuously at spin speed"
              }
            ]
          },
          {
            "name": "start_returning",
            "trigger": "when boomerang has traveled maximum distance from thrower",
            "actions": [
              {
                "action": "mark boomerang as returning"
              },
              {
                "action": "reduce forward velocity"
              },
              {
                "action": "begin moving toward thrower position"
              }
            ]
          },
          {
            "name": "return_to_thrower",
            "trigger": "when boomerang is marked as returning",
            "actions": [
              {
                "action": "move toward thrower at return force speed"
              },
              {
                "action": "continue spinning"
              }
            ]
          },
          {
            "name": "catch_boomerang",
            "trigger": "when boomerang touches the thrower while returning",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "stop spinning"
              },
              {
                "action": "reset thrown status"
              },
              {
                "action": "reset returning status"
              },
              {
                "action": "attach to thrower"
              }
            ]
          },
          {
            "name": "bounce_off_obstacles",
            "trigger": "when boomerang collides with solid objects while not returning",
            "actions": [
              {
                "action": "reflect movement direction away from obstacle"
              },
              {
                "action": "reduce velocity slightly"
              },
              {
                "action": "continue spinning"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Boomerang : MonoBehaviour\n{\n    [Header(\"Flight Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _returnForce = 10f;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _returnDelay = 0.5f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _spinSpeed = 720f;\n    [SerializeField] private Vector3 _spinAxis = Vector3.forward;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _drag = 0.5f;\n    [SerializeField] private float _gravityScale = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _catchSound;\n    [SerializeField] private AudioClip _whooshSound;\n    \n    private Transform _thrower;\n    private Vector3 _throwDirection;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private bool _isReturning = false;\n    private bool _isThrown = false;\n    private float _returnTimer = 0f;\n    private Vector3 _startPosition;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.drag = _drag;\n        _rigidbody.useGravity = true;\n        _startPosition = transform.position;\n    }\n    \n    private void Start()\n    {\n        Physics.gravity = new Vector3(0, -9.81f * _gravityScale, 0);\n    }\n    \n    private void Update()\n    {\n        if (_isThrown)\n        {\n            HandleSpin();\n            HandleReturn();\n            CheckMaxDistance();\n        }\n    }\n    \n    private void HandleSpin()\n    {\n        transform.Rotate(_spinAxis * _spinSpeed * Time.deltaTime);\n    }\n    \n    private void HandleReturn()\n    {\n        if (!_isReturning)\n        {\n            _returnTimer += Time.deltaTime;\n            if (_returnTimer >= _returnDelay)\n            {\n                StartReturning();\n            }\n        }\n        else if (_thrower != null)\n        {\n            Vector3 directionToThrower = (_thrower.position - transform.position).normalized;\n            _rigidbody.AddForce(directionToThrower * _returnForce, ForceMode.Acceleration);\n            \n            float distanceToThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceToThrower < 1f)\n            {\n                ReturnToThrower();\n            }\n        }\n    }\n    \n    private void CheckMaxDistance()\n    {\n        if (_thrower != null)\n        {\n            float distanceFromThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceFromThrower >= _maxDistance && !_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void StartReturning()\n    {\n        _isReturning = true;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_whooshSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_whooshSound);\n        }\n    }\n    \n    public void ThrowBoomerang(Transform thrower, Vector3 direction)\n    {\n        if (_isThrown) return;\n        \n        _thrower = thrower;\n        _throwDirection = direction.normalized;\n        _isThrown = true;\n        _isReturning = false;\n        _returnTimer = 0f;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.AddForce(_throwDirection * _throwForce, ForceMode.Impulse);\n        \n        if (_throwSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_throwSound);\n        }\n    }\n    \n    private void ReturnToThrower()\n    {\n        _isThrown = false;\n        _isReturning = false;\n        _returnTimer = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        \n        transform.position = _thrower.position;\n        transform.SetParent(_thrower);\n        \n        if (_catchSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_catchSound);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isThrown && other.transform == _thrower)\n        {\n            ReturnToThrower();\n        }\n        else if (_isThrown && !other.CompareTag(\"Player\") && !other.isTrigger)\n        {\n            if (!_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isThrown && collision.transform != _thrower)\n        {\n            if (!_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    public void ResetBoomerang()\n    {\n        _isThrown = false;\n        _isReturning = false;\n        _returnTimer = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        transform.position = _startPosition;\n        transform.SetParent(null);\n    }\n    \n    public bool IsAvailable()\n    {\n        return !_isThrown;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "player jump with variable height",
      "ideal_ir": {
        "class_name": "PlayerJump",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "jumpForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "maxJumpTime",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "isGrounded",
            "type": "bool",
            "default": true
          },
          {
            "name": "isJumping",
            "type": "bool",
            "default": false
          },
          {
            "name": "jumpTimeCounter",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "initiate_jump",
            "trigger": "when jump input is pressed and player is grounded",
            "actions": [
              {
                "action": "apply upward force to rigidbody"
              },
              {
                "action": "set jumping state to true"
              },
              {
                "action": "reset jump time counter"
              },
              {
                "action": "set grounded state to false"
              }
            ]
          },
          {
            "name": "continue_jump",
            "trigger": "when jump input is held and player is jumping and jump time is less than maximum",
            "actions": [
              {
                "action": "apply additional upward force to rigidbody"
              },
              {
                "action": "increment jump time counter"
              }
            ]
          },
          {
            "name": "end_jump",
            "trigger": "when jump input is released or maximum jump time is reached",
            "actions": [
              {
                "action": "set jumping state to false"
              },
              {
                "action": "reset jump time counter"
              }
            ]
          },
          {
            "name": "ground_detection",
            "trigger": "when player collides with ground surface",
            "actions": [
              {
                "action": "set grounded state to true"
              },
              {
                "action": "set jumping state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class PlayerJump : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _variableJumpMultiplier = 0.5f;\n    [SerializeField] private float _maxJumpTime = 0.3f;\n    [SerializeField] private float _fallMultiplier = 2.5f;\n    [SerializeField] private float _lowJumpMultiplier = 2f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheck;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _jumpKey = KeyCode.Space;\n    \n    private Rigidbody2D _rigidbody;\n    private bool _isGrounded;\n    private bool _isJumping;\n    private float _jumpTimeCounter;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"PlayerJump requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_groundCheck == null)\n        {\n            GameObject groundCheckObj = new GameObject(\"GroundCheck\");\n            groundCheckObj.transform.SetParent(transform);\n            groundCheckObj.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheck = groundCheckObj.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleJumpInput();\n        ApplyVariableJump();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBetterJump();\n    }\n    \n    private void CheckGrounded()\n    {\n        _isGrounded = Physics2D.OverlapCircle(_groundCheck.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    private void HandleJumpInput()\n    {\n        if (Input.GetKeyDown(_jumpKey) && _isGrounded)\n        {\n            StartJump();\n        }\n        \n        if (Input.GetKey(_jumpKey) && _isJumping)\n        {\n            if (_jumpTimeCounter > 0)\n            {\n                _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, _jumpForce);\n                _jumpTimeCounter -= Time.deltaTime;\n            }\n            else\n            {\n                _isJumping = false;\n            }\n        }\n        \n        if (Input.GetKeyUp(_jumpKey))\n        {\n            _isJumping = false;\n        }\n    }\n    \n    private void StartJump()\n    {\n        _isJumping = true;\n        _jumpTimeCounter = _maxJumpTime;\n        _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, _jumpForce);\n    }\n    \n    private void ApplyVariableJump()\n    {\n        if (_rigidbody.velocity.y < 0 && !Input.GetKey(_jumpKey))\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_lowJumpMultiplier - 1) * Time.deltaTime;\n        }\n    }\n    \n    private void ApplyBetterJump()\n    {\n        if (_rigidbody.velocity.y < 0)\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_fallMultiplier - 1) * Time.deltaTime;\n        }\n        else if (_rigidbody.velocity.y > 0 && !Input.GetKey(_jumpKey))\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_lowJumpMultiplier - 1) * Time.deltaTime;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheck != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheck.position, _groundCheckRadius);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "double jump ability",
      "ideal_ir": {
        "class_name": "DoubleJump",
        "components": [
          "Rigidbody2D"
        ],
        "fields": [
          {
            "name": "jumpForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "maxJumps",
            "type": "int",
            "default": 2
          },
          {
            "name": "currentJumps",
            "type": "int",
            "default": 0
          },
          {
            "name": "isGrounded",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "reset_jumps_on_ground",
            "trigger": "when character touches ground",
            "actions": [
              {
                "action": "set current jumps to zero"
              },
              {
                "action": "mark character as grounded"
              }
            ]
          },
          {
            "name": "leave_ground",
            "trigger": "when character leaves ground",
            "actions": [
              {
                "action": "mark character as not grounded"
              }
            ]
          },
          {
            "name": "perform_jump",
            "trigger": "when jump input is pressed and current jumps is less than max jumps",
            "actions": [
              {
                "action": "apply upward force equal to jump force"
              },
              {
                "action": "increase current jumps by one"
              },
              {
                "action": "mark character as not grounded"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class DoubleJumpController : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _doubleJumpForce = 8f;\n    [SerializeField] private int _maxJumps = 2;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheck;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _doubleJumpSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _jumpParticles;\n    [SerializeField] private ParticleSystem _doubleJumpParticles;\n    \n    private Rigidbody2D _rigidbody2D;\n    private AudioSource _audioSource;\n    private int _jumpsRemaining;\n    private bool _isGrounded;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody2D == null)\n        {\n            Debug.LogError(\"DoubleJumpController requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_groundCheck == null)\n        {\n            _groundCheck = transform;\n        }\n        \n        _jumpsRemaining = _maxJumps;\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleJumpInput();\n    }\n    \n    private void CheckGrounded()\n    {\n        _wasGrounded = _isGrounded;\n        _isGrounded = Physics2D.OverlapCircle(_groundCheck.position, _groundCheckRadius, _groundLayerMask);\n        \n        if (_isGrounded && !_wasGrounded)\n        {\n            _jumpsRemaining = _maxJumps;\n        }\n    }\n    \n    private void HandleJumpInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && CanJump())\n        {\n            PerformJump();\n        }\n    }\n    \n    private bool CanJump()\n    {\n        return _jumpsRemaining > 0;\n    }\n    \n    private void PerformJump()\n    {\n        _rigidbody2D.velocity = new Vector2(_rigidbody2D.velocity.x, 0f);\n        \n        bool isFirstJump = _jumpsRemaining == _maxJumps;\n        float jumpForce = isFirstJump ? _jumpForce : _doubleJumpForce;\n        \n        _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);\n        _jumpsRemaining--;\n        \n        PlayJumpEffects(isFirstJump);\n    }\n    \n    private void PlayJumpEffects(bool isFirstJump)\n    {\n        if (_audioSource != null)\n        {\n            AudioClip soundToPlay = isFirstJump ? _jumpSound : _doubleJumpSound;\n            if (soundToPlay != null)\n            {\n                _audioSource.PlayOneShot(soundToPlay);\n            }\n        }\n        \n        ParticleSystem particlesToPlay = isFirstJump ? _jumpParticles : _doubleJumpParticles;\n        if (particlesToPlay != null)\n        {\n            particlesToPlay.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheck != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheck.position, _groundCheckRadius);\n        }\n    }\n    \n    public bool IsGrounded => _isGrounded;\n    public int JumpsRemaining => _jumpsRemaining;\n    public int MaxJumps => _maxJumps;\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "wall jump and slide",
      "ideal_ir": {
        "class_name": "WallJumpSlide",
        "components": [
          "Rigidbody2D",
          "Collider2D"
        ],
        "fields": [
          {
            "name": "wallJumpForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "wallSlideSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "wallJumpDirection",
            "type": "Vector2",
            "default": "1,1"
          },
          {
            "name": "isWallSliding",
            "type": "bool",
            "default": false
          },
          {
            "name": "canWallJump",
            "type": "bool",
            "default": false
          },
          {
            "name": "wallJumpCooldown",
            "type": "float",
            "default": 0.2
          }
        ],
        "behaviors": [
          {
            "name": "detect_wall_contact",
            "trigger": "when touching a wall on the left or right side",
            "actions": [
              {
                "action": "enable wall jump ability"
              },
              {
                "action": "prepare for wall sliding"
              }
            ]
          },
          {
            "name": "start_wall_slide",
            "trigger": "when touching wall and moving downward and not grounded",
            "actions": [
              {
                "action": "set wall sliding state to true"
              },
              {
                "action": "reduce downward velocity to wall slide speed"
              },
              {
                "action": "play wall slide particle effect"
              }
            ]
          },
          {
            "name": "perform_wall_jump",
            "trigger": "when jump input pressed while wall sliding or touching wall",
            "actions": [
              {
                "action": "apply wall jump force away from wall and upward"
              },
              {
                "action": "disable wall jump temporarily for cooldown period"
              },
              {
                "action": "stop wall sliding"
              },
              {
                "action": "play wall jump sound effect"
              }
            ]
          },
          {
            "name": "stop_wall_slide",
            "trigger": "when no longer touching wall or becomes grounded",
            "actions": [
              {
                "action": "set wall sliding state to false"
              },
              {
                "action": "restore normal gravity"
              },
              {
                "action": "stop wall slide particle effect"
              }
            ]
          },
          {
            "name": "wall_jump_cooldown",
            "trigger": "when wall jump cooldown timer expires",
            "actions": [
              {
                "action": "re-enable wall jump ability"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class WallJumpSlide : MonoBehaviour\n{\n    [Header(\"Wall Detection\")]\n    [SerializeField] private LayerMask _wallLayerMask = 1;\n    [SerializeField] private float _wallCheckDistance = 0.6f;\n    [SerializeField] private Transform _wallCheckPoint;\n    \n    [Header(\"Wall Slide\")]\n    [SerializeField] private float _wallSlideSpeed = 2f;\n    [SerializeField] private float _wallSlideGravityScale = 0.3f;\n    \n    [Header(\"Wall Jump\")]\n    [SerializeField] private float _wallJumpForce = 15f;\n    [SerializeField] private Vector2 _wallJumpDirection = new Vector2(1f, 1.2f);\n    [SerializeField] private float _wallJumpTime = 0.2f;\n    [SerializeField] private float _wallJumpCooldown = 0.1f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    [SerializeField] private Transform _groundCheckPoint;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _jumpKey = KeyCode.Space;\n    \n    private Rigidbody2D _rigidbody;\n    private bool _isTouchingWall;\n    private bool _isWallSliding;\n    private bool _isWallJumping;\n    private bool _isGrounded;\n    private float _wallJumpTimer;\n    private float _wallJumpCooldownTimer;\n    private float _originalGravityScale;\n    private int _wallDirection;\n    private float _horizontalInput;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _originalGravityScale = _rigidbody.gravityScale;\n        \n        if (_wallCheckPoint == null)\n        {\n            GameObject wallCheck = new GameObject(\"WallCheck\");\n            wallCheck.transform.SetParent(transform);\n            wallCheck.transform.localPosition = new Vector3(0.5f, 0f, 0f);\n            _wallCheckPoint = wallCheck.transform;\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheck = new GameObject(\"GroundCheck\");\n            groundCheck.transform.SetParent(transform);\n            groundCheck.transform.localPosition = new Vector3(0f, -0.5f, 0f);\n            _groundCheckPoint = groundCheck.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        _horizontalInput = Input.GetAxisRaw(\"Horizontal\");\n        \n        CheckWallTouch();\n        CheckGrounded();\n        HandleWallSlide();\n        HandleWallJump();\n        \n        if (_wallJumpTimer > 0)\n        {\n            _wallJumpTimer -= Time.deltaTime;\n        }\n        else\n        {\n            _isWallJumping = false;\n        }\n        \n        if (_wallJumpCooldownTimer > 0)\n        {\n            _wallJumpCooldownTimer -= Time.deltaTime;\n        }\n    }\n    \n    private void CheckWallTouch()\n    {\n        _isTouchingWall = false;\n        _wallDirection = 0;\n        \n        // Check right wall\n        RaycastHit2D rightHit = Physics2D.Raycast(_wallCheckPoint.position, Vector2.right, _wallCheckDistance, _wallLayerMask);\n        if (rightHit.collider != null)\n        {\n            _isTouchingWall = true;\n            _wallDirection = 1;\n        }\n        else\n        {\n            // Check left wall\n            RaycastHit2D leftHit = Physics2D.Raycast(_wallCheckPoint.position, Vector2.left, _wallCheckDistance, _wallLayerMask);\n            if (leftHit.collider != null)\n            {\n                _isTouchingWall = true;\n                _wallDirection = -1;\n            }\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit2D hit = Physics2D.Raycast(_groundCheckPoint.position, Vector2.down, _groundCheckDistance, _groundLayerMask);\n        _isGrounded = hit.collider != null;\n    }\n    \n    private void HandleWallSlide()\n    {\n        if (_isTouchingWall && !_isGrounded && _rigidbody.velocity.y < 0 && !_isWallJumping)\n        {\n            bool shouldSlide = (_wallDirection == 1 && _horizontalInput > 0) || (_wallDirection == -1 && _horizontalInput < 0);\n            \n            if (shouldSlide)\n            {\n                _isWallSliding = true;\n                _rigidbody.gravityScale = _wallSlideGravityScale;\n                \n                if (_rigidbody.velocity.y < -_wallSlideSpeed)\n                {\n                    _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, -_wallSlideSpeed);\n                }\n            }\n            else\n            {\n                StopWallSlide();\n            }\n        }\n        else\n        {\n            StopWallSlide();\n        }\n    }\n    \n    private void StopWallSlide()\n    {\n        if (_isWallSliding)\n        {\n            _isWallSliding = false;\n            _rigidbody.gravityScale = _originalGravityScale;\n        }\n    }\n    \n    private void HandleWallJump()\n    {\n        if (Input.GetKeyDown(_jumpKey) && _isWallSliding && _wallJumpCooldownTimer <= 0)\n        {\n            PerformWallJump();\n        }\n    }\n    \n    private void PerformWallJump()\n    {\n        _isWallJumping = true;\n        _isWallSliding = false;\n        _wallJumpTimer = _wallJumpTime;\n        _wallJumpCooldownTimer = _wallJumpCooldown;\n        \n        _rigidbody.gravityScale = _originalGravityScale;\n        \n        Vector2 jumpDirection = new Vector2(_wallJumpDirection.x * -_wallDirection, _wallJumpDirection.y);\n        jumpDirection.Normalize();\n        \n        _rigidbody.velocity = new Vector2(0f, 0f);\n        _rigidbody.AddForce(jumpDirection * _wallJumpForce, ForceMode2D.Impulse);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_wallCheckPoint != null)\n        {\n            Gizmos.color = _isTouchingWall ? Color.red : Color.green;\n            Gizmos.DrawRay(_wallCheckPoint.position, Vector3.right * _wallCheckDistance);\n            Gizmos.DrawRay(_wallCheckPoint.position, Vector3.left * _wallCheckDistance);\n        }\n        \n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.red : Color.blue;\n            Gizmos.DrawRay(_groundCheckPoint.position, Vector3.down * _groundCheckDistance);\n        }\n        \n        if (_isWallSliding)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "dash ability with cooldown",
      "ideal_ir": {
        "class_name": "DashAbility",
        "components": [
          "Rigidbody2D"
        ],
        "fields": [
          {
            "name": "dashForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "dashDuration",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 2
          },
          {
            "name": "currentCooldown",
            "type": "float",
            "default": 0
          },
          {
            "name": "isDashing",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "dash_input",
            "trigger": "when dash key is pressed and cooldown is finished and not currently dashing",
            "actions": [
              {
                "action": "set dashing state to true"
              },
              {
                "action": "apply dash force in movement direction"
              },
              {
                "action": "start dash duration timer"
              },
              {
                "action": "set cooldown to maximum cooldown time"
              }
            ]
          },
          {
            "name": "end_dash",
            "trigger": "when dash duration timer expires",
            "actions": [
              {
                "action": "set dashing state to false"
              },
              {
                "action": "stop applying dash force"
              },
              {
                "action": "reset dash duration timer"
              }
            ]
          },
          {
            "name": "cooldown_timer",
            "trigger": "every frame when cooldown is greater than zero",
            "actions": [
              {
                "action": "reduce cooldown by time elapsed this frame"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DashAbility : MonoBehaviour\n{\n    [Header(\"Dash Settings\")]\n    [SerializeField] private float _dashDistance = 5f;\n    [SerializeField] private float _dashDuration = 0.2f;\n    [SerializeField] private float _dashCooldown = 2f;\n    [SerializeField] private KeyCode _dashKey = KeyCode.LeftShift;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    [SerializeField] private float _raycastRadius = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _dashEffect;\n    [SerializeField] private TrailRenderer _dashTrail;\n    [SerializeField] private float _invulnerabilityDuration = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _dashSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDashStart;\n    public UnityEvent OnDashEnd;\n    public UnityEvent OnDashCooldownComplete;\n    \n    private Rigidbody2D _rigidbody2D;\n    private Collider2D _collider2D;\n    private Vector2 _originalVelocity;\n    private bool _isDashing;\n    private bool _isOnCooldown;\n    private float _cooldownTimer;\n    private float _dashTimer;\n    private Vector2 _dashDirection;\n    private Vector2 _dashStartPosition;\n    private Vector2 _dashTargetPosition;\n    \n    public bool IsDashing => _isDashing;\n    public bool IsOnCooldown => _isOnCooldown;\n    public float CooldownProgress => _isOnCooldown ? (_dashCooldown - _cooldownTimer) / _dashCooldown : 1f;\n    \n    private void Awake()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _collider2D = GetComponent<Collider2D>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        if (_dashTrail != null)\n            _dashTrail.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateDash();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_dashKey) && CanDash())\n        {\n            Vector2 inputDirection = GetInputDirection();\n            if (inputDirection != Vector2.zero)\n            {\n                StartDash(inputDirection);\n            }\n        }\n    }\n    \n    private Vector2 GetInputDirection()\n    {\n        float horizontal = Input.GetAxisRaw(\"Horizontal\");\n        float vertical = Input.GetAxisRaw(\"Vertical\");\n        return new Vector2(horizontal, vertical).normalized;\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnDashCooldownComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateDash()\n    {\n        if (!_isDashing) return;\n        \n        _dashTimer -= Time.deltaTime;\n        \n        float dashProgress = 1f - (_dashTimer / _dashDuration);\n        Vector2 currentPosition = Vector2.Lerp(_dashStartPosition, _dashTargetPosition, dashProgress);\n        transform.position = currentPosition;\n        \n        if (_dashTimer <= 0f)\n        {\n            EndDash();\n        }\n    }\n    \n    private bool CanDash()\n    {\n        return !_isDashing && !_isOnCooldown && _rigidbody2D != null;\n    }\n    \n    private void StartDash(Vector2 direction)\n    {\n        _dashDirection = direction;\n        _dashStartPosition = transform.position;\n        \n        Vector2 targetPosition = _dashStartPosition + (_dashDirection * _dashDistance);\n        RaycastHit2D hit = Physics2D.CircleCast(_dashStartPosition, _raycastRadius, _dashDirection, _dashDistance, _obstacleLayerMask);\n        \n        if (hit.collider != null && hit.collider != _collider2D)\n        {\n            _dashTargetPosition = hit.point - (_dashDirection * _raycastRadius);\n        }\n        else\n        {\n            _dashTargetPosition = targetPosition;\n        }\n        \n        _isDashing = true;\n        _dashTimer = _dashDuration;\n        _originalVelocity = _rigidbody2D.velocity;\n        _rigidbody2D.velocity = Vector2.zero;\n        _rigidbody2D.isKinematic = true;\n        \n        if (_collider2D != null && _invulnerabilityDuration > 0f)\n        {\n            _collider2D.enabled = false;\n            Invoke(nameof(RestoreCollider), _invulnerabilityDuration);\n        }\n        \n        if (_dashTrail != null)\n            _dashTrail.enabled = true;\n        \n        if (_dashEffect != null)\n            _dashEffect.Play();\n        \n        if (_audioSource != null && _dashSound != null)\n            _audioSource.PlayOneShot(_dashSound);\n        \n        OnDashStart?.Invoke();\n    }\n    \n    private void EndDash()\n    {\n        _isDashing = false;\n        _rigidbody2D.isKinematic = false;\n        _rigidbody2D.velocity = _originalVelocity;\n        \n        _isOnCooldown = true;\n        _cooldownTimer = _dashCooldown;\n        \n        if (_dashTrail != null)\n            _dashTrail.enabled = false;\n        \n        OnDashEnd?.Invoke();\n    }\n    \n    private void RestoreCollider()\n    {\n        if (_collider2D != null)\n            _collider2D.enabled = true;\n    }\n    \n    public void SetDashDistance(float distance)\n    {\n        _dashDistance = Mathf.Max(0f, distance);\n    }\n    \n    public void SetDashCooldown(float cooldown)\n    {\n        _dashCooldown = Mathf.Max(0f, cooldown);\n    }\n    \n    public void ResetCooldown()\n    {\n        _isOnCooldown = false;\n        _cooldownTimer = 0f;\n    }\n    \n    public void ForceDash(Vector2 direction)\n    {\n        if (!_isDashing && direction != Vector2.zero)\n        {\n            StartDash(direction.normalized);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _raycastRadius);\n        \n        if (_isDashing)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_dashStartPosition, _dashTargetPosition);\n        }\n        else\n        {\n            Vector2 inputDir = GetInputDirection();\n            if (inputDir != Vector2.zero)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawRay(transform.position, inputDir * _dashDistance);\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "grappling hook movement",
      "ideal_ir": {
        "class_name": "GrapplingHook",
        "components": [
          "Rigidbody",
          "LineRenderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "hookRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "hookSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "swingForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "hookPoint",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "isHooked",
            "type": "bool",
            "default": false
          },
          {
            "name": "isSwinging",
            "type": "bool",
            "default": false
          },
          {
            "name": "ropeLength",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "fire_hook",
            "trigger": "when fire input is pressed and not currently hooked",
            "actions": [
              {
                "action": "cast ray from player position toward aim direction"
              },
              {
                "action": "check if ray hits hookable surface within hook range"
              },
              {
                "action": "if surface is hookable set hook point to hit location"
              },
              {
                "action": "set hooked state to true"
              },
              {
                "action": "calculate rope length as distance to hook point"
              },
              {
                "action": "play hook firing sound effect"
              }
            ]
          },
          {
            "name": "draw_rope",
            "trigger": "when hooked state is true",
            "actions": [
              {
                "action": "draw line from player position to hook point"
              },
              {
                "action": "set line width based on rope thickness"
              },
              {
                "action": "update line positions every frame"
              }
            ]
          },
          {
            "name": "swing_movement",
            "trigger": "when hooked and player is in air",
            "actions": [
              {
                "action": "calculate direction from player to hook point"
              },
              {
                "action": "maintain rope length constraint"
              },
              {
                "action": "apply swing physics based on player input"
              },
              {
                "action": "add momentum in swing direction"
              },
              {
                "action": "set swinging state to true"
              }
            ]
          },
          {
            "name": "release_hook",
            "trigger": "when fire input is released or hook key is pressed again",
            "actions": [
              {
                "action": "set hooked state to false"
              },
              {
                "action": "set swinging state to false"
              },
              {
                "action": "hide rope line renderer"
              },
              {
                "action": "preserve current momentum for continued movement"
              },
              {
                "action": "play hook release sound effect"
              }
            ]
          },
          {
            "name": "rope_physics",
            "trigger": "when swinging and rope is at maximum length",
            "actions": [
              {
                "action": "prevent player from moving further away from hook point"
              },
              {
                "action": "apply pendulum physics to player movement"
              },
              {
                "action": "calculate swing arc based on rope length and gravity"
              }
            ]
          },
          {
            "name": "hook_break",
            "trigger": "when hook point object is destroyed or moves",
            "actions": [
              {
                "action": "automatically release hook"
              },
              {
                "action": "set hooked state to false"
              },
              {
                "action": "hide rope line renderer"
              },
              {
                "action": "play hook break sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GrapplingHook : MonoBehaviour\n{\n    [Header(\"Grappling Settings\")]\n    [SerializeField] private float _maxGrappleDistance = 20f;\n    [SerializeField] private float _grappleSpeed = 30f;\n    [SerializeField] private float _swingForce = 15f;\n    [SerializeField] private float _climbSpeed = 8f;\n    [SerializeField] private LayerMask _grappleableLayers = -1;\n    [SerializeField] private float _jointSpring = 4.5f;\n    [SerializeField] private float _jointDamper = 7f;\n    [SerializeField] private float _jointMassScale = 4.5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grappleKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Mouse1;\n    [SerializeField] private KeyCode _climbUpKey = KeyCode.W;\n    [SerializeField] private KeyCode _climbDownKey = KeyCode.S;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private LineRenderer _grappleLine;\n    [SerializeField] private Transform _grapplePoint;\n    [SerializeField] private GameObject _hookPrefab;\n    [SerializeField] private float _lineWidth = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGrappleStart;\n    public UnityEvent OnGrappleHit;\n    public UnityEvent OnGrappleRelease;\n    \n    private Camera _playerCamera;\n    private Rigidbody _rigidbody;\n    private SpringJoint _springJoint;\n    private Vector3 _grappleTarget;\n    private bool _isGrappling;\n    private bool _isHooked;\n    private GameObject _hookInstance;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    \n    private enum GrappleState\n    {\n        Idle,\n        Shooting,\n        Hooked,\n        Retracting\n    }\n    \n    private GrappleState _currentState = GrappleState.Idle;\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupLineRenderer();\n        \n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateVisuals();\n        HandleClimbing();\n    }\n    \n    void FixedUpdate()\n    {\n        switch (_currentState)\n        {\n            case GrappleState.Shooting:\n                UpdateShooting();\n                break;\n            case GrappleState.Hooked:\n                UpdateSwinging();\n                break;\n        }\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_grappleKey) && !_isGrappling)\n        {\n            StartGrapple();\n        }\n        \n        if (Input.GetKeyDown(_releaseKey) && _isGrappling)\n        {\n            ReleaseGrapple();\n        }\n    }\n    \n    void StartGrapple()\n    {\n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _maxGrappleDistance, _grappleableLayers))\n        {\n            _grappleTarget = hit.point;\n            _isGrappling = true;\n            _currentState = GrappleState.Shooting;\n            \n            PlaySound(_shootSound);\n            OnGrappleStart?.Invoke();\n            \n            if (_hookPrefab != null)\n            {\n                _hookInstance = Instantiate(_hookPrefab, _grapplePoint.position, Quaternion.identity);\n            }\n        }\n    }\n    \n    void UpdateShooting()\n    {\n        if (_hookInstance != null)\n        {\n            Vector3 direction = (_grappleTarget - _hookInstance.transform.position).normalized;\n            _hookInstance.transform.position += direction * _grappleSpeed * Time.fixedDeltaTime;\n            \n            float distanceToTarget = Vector3.Distance(_hookInstance.transform.position, _grappleTarget);\n            \n            if (distanceToTarget < 0.5f)\n            {\n                _hookInstance.transform.position = _grappleTarget;\n                CreateSpringJoint();\n                _currentState = GrappleState.Hooked;\n                _isHooked = true;\n                \n                PlaySound(_hitSound);\n                OnGrappleHit?.Invoke();\n            }\n        }\n        else\n        {\n            CreateSpringJoint();\n            _currentState = GrappleState.Hooked;\n            _isHooked = true;\n            \n            PlaySound(_hitSound);\n            OnGrappleHit?.Invoke();\n        }\n    }\n    \n    void CreateSpringJoint()\n    {\n        _springJoint = gameObject.AddComponent<SpringJoint>();\n        _springJoint.autoConfigureConnectedAnchor = false;\n        _springJoint.connectedAnchor = _grappleTarget;\n        \n        float distanceFromPoint = Vector3.Distance(transform.position, _grappleTarget);\n        _springJoint.maxDistance = distanceFromPoint * 0.8f;\n        _springJoint.minDistance = distanceFromPoint * 0.25f;\n        \n        _springJoint.spring = _jointSpring;\n        _springJoint.damper = _jointDamper;\n        _springJoint.massScale = _jointMassScale;\n        \n        _rigidbody.drag = 0f;\n        _rigidbody.angularDrag = 0f;\n    }\n    \n    void UpdateSwinging()\n    {\n        Vector3 swingDirection = Vector3.zero;\n        \n        if (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow))\n            swingDirection += -_playerCamera.transform.right;\n        if (Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow))\n            swingDirection += _playerCamera.transform.right;\n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n            swingDirection += _playerCamera.transform.forward;\n        if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n            swingDirection += -_playerCamera.transform.forward;\n        \n        swingDirection.y = 0;\n        swingDirection = swingDirection.normalized;\n        \n        if (swingDirection != Vector3.zero)\n        {\n            _rigidbody.AddForce(swingDirection * _swingForce, ForceMode.Force);\n        }\n    }\n    \n    void HandleClimbing()\n    {\n        if (!_isHooked || _springJoint == null) return;\n        \n        if (Input.GetKey(_climbUpKey))\n        {\n            if (_springJoint.maxDistance > 2f)\n            {\n                _springJoint.maxDistance -= _climbSpeed * Time.deltaTime;\n                _springJoint.minDistance -= _climbSpeed * Time.deltaTime;\n            }\n        }\n        else if (Input.GetKey(_climbDownKey))\n        {\n            _springJoint.maxDistance += _climbSpeed * Time.deltaTime;\n            _springJoint.minDistance += _climbSpeed * Time.deltaTime;\n        }\n    }\n    \n    void ReleaseGrapple()\n    {\n        _isGrappling = false;\n        _isHooked = false;\n        _currentState = GrappleState.Idle;\n        \n        if (_springJoint != null)\n        {\n            Destroy(_springJoint);\n            _springJoint = null;\n        }\n        \n        if (_hookInstance != null)\n        {\n            Destroy(_hookInstance);\n            _hookInstance = null;\n        }\n        \n        _rigidbody.drag = _originalDrag;\n        _rigidbody.angularDrag = _originalAngularDrag;\n        \n        PlaySound(_releaseSound);\n        OnGrappleRelease?.Invoke();\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_grappleLine == null) return;\n        \n        if (_isGrappling)\n        {\n            _grappleLine.enabled = true;\n            _grappleLine.positionCount = 2;\n            \n            Vector3 startPoint = _grapplePoint != null ? _grapplePoint.position : transform.position;\n            Vector3 endPoint = _isHooked ? _grappleTarget : \n                              (_hookInstance != null ? _hookInstance.transform.position : _grappleTarget);\n            \n            _grappleLine.SetPosition(0, startPoint);\n            _grappleLine.SetPosition(1, endPoint);\n        }\n        else\n        {\n            _grappleLine.enabled = false;\n        }\n    }\n    \n    void SetupLineRenderer()\n    {\n        if (_grappleLine == null)\n        {\n            _grappleLine = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _grappleLine.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _grappleLine.color = Color.white;\n        _grappleLine.startWidth = _lineWidth;\n        _grappleLine.endWidth = _lineWidth;\n        _grappleLine.enabled = false;\n        _grappleLine.useWorldSpace = true;\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        if (_playerCamera != null)\n        {\n            Vector3 rayOrigin = _playerCamera.transform.position;\n            Vector3 rayDirection = _playerCamera.transform.forward;\n            Gizmos.DrawRay(rayOrigin, rayDirection * _maxGrappleDistance);\n        }\n        \n        if (_isGrappling)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_grappleTarget, 0.5f);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        if (_springJoint != null)\n        {\n            Destroy(_springJoint);\n        }\n        \n        if (_hookInstance != null)\n        {\n            Destroy(_hookInstance);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "climbing on marked surfaces",
      "ideal_ir": {
        "class_name": "SurfaceClimber",
        "components": [
          "Rigidbody",
          "CapsuleCollider"
        ],
        "fields": [
          {
            "name": "climbSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "climbableTag",
            "type": "string",
            "default": "Climbable"
          },
          {
            "name": "isClimbing",
            "type": "bool",
            "default": false
          },
          {
            "name": "climbDirection",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "detect_climbable_surface",
            "trigger": "when touching object with climbable tag",
            "actions": [
              {
                "action": "enable climbing mode"
              },
              {
                "action": "disable gravity"
              },
              {
                "action": "calculate surface normal direction"
              }
            ]
          },
          {
            "name": "climb_movement",
            "trigger": "when climbing mode is active and movement input is received",
            "actions": [
              {
                "action": "move along surface in input direction at climb speed"
              },
              {
                "action": "maintain contact with climbable surface"
              },
              {
                "action": "rotate character to face climbing direction"
              }
            ]
          },
          {
            "name": "stop_climbing",
            "trigger": "when no longer touching climbable surface or jump input is pressed",
            "actions": [
              {
                "action": "disable climbing mode"
              },
              {
                "action": "enable gravity"
              },
              {
                "action": "restore normal movement physics"
              }
            ]
          },
          {
            "name": "climb_transition",
            "trigger": "when moving from one climbable surface to another",
            "actions": [
              {
                "action": "smoothly transition between surface orientations"
              },
              {
                "action": "maintain climbing speed during transition"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ClimbingSystem : MonoBehaviour\n{\n    [Header(\"Climbing Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private float _climbDetectionDistance = 1.5f;\n    [SerializeField] private LayerMask _climbableLayerMask = 1;\n    [SerializeField] private string _climbableTag = \"Climbable\";\n    \n    [Header(\"Movement Controls\")]\n    [SerializeField] private KeyCode _climbKey = KeyCode.E;\n    [SerializeField] private float _horizontalClimbSpeed = 2f;\n    [SerializeField] private float _gravityScale = 1f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private Transform _climbDetectionPoint;\n    [SerializeField] private float _climbDetectionRadius = 0.3f;\n    [SerializeField] private Vector3 _climbOffset = new Vector3(0, 0, -0.5f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnClimbStart;\n    public UnityEvent OnClimbEnd;\n    \n    private Rigidbody _rigidbody;\n    private Collider _playerCollider;\n    private bool _isClimbing;\n    private bool _canClimb;\n    private GameObject _currentClimbSurface;\n    private Vector3 _climbDirection;\n    private float _originalGravityScale;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _playerCollider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"ClimbingSystem requires a Rigidbody component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_climbDetectionPoint == null)\n        {\n            GameObject detectionPoint = new GameObject(\"ClimbDetectionPoint\");\n            detectionPoint.transform.SetParent(transform);\n            detectionPoint.transform.localPosition = Vector3.forward * 0.5f;\n            _climbDetectionPoint = detectionPoint.transform;\n        }\n        \n        _originalGravityScale = _rigidbody.drag;\n    }\n    \n    private void Update()\n    {\n        DetectClimbableSurfaces();\n        HandleClimbInput();\n        \n        if (_isClimbing)\n        {\n            HandleClimbMovement();\n        }\n    }\n    \n    private void DetectClimbableSurfaces()\n    {\n        Collider[] climbableObjects = Physics.OverlapSphere(\n            _climbDetectionPoint.position, \n            _climbDetectionRadius, \n            _climbableLayerMask\n        );\n        \n        _canClimb = false;\n        _currentClimbSurface = null;\n        \n        foreach (Collider col in climbableObjects)\n        {\n            if (col.CompareTag(_climbableTag) && col.gameObject != gameObject)\n            {\n                _canClimb = true;\n                _currentClimbSurface = col.gameObject;\n                \n                Vector3 surfaceNormal = GetSurfaceNormal(col);\n                _climbDirection = -surfaceNormal;\n                break;\n            }\n        }\n        \n        if (!_canClimb && _isClimbing)\n        {\n            StopClimbing();\n        }\n    }\n    \n    private Vector3 GetSurfaceNormal(Collider surface)\n    {\n        Vector3 directionToSurface = (surface.transform.position - transform.position).normalized;\n        \n        if (Physics.Raycast(transform.position, directionToSurface, out RaycastHit hit, _climbDetectionDistance, _climbableLayerMask))\n        {\n            return hit.normal;\n        }\n        \n        return -transform.forward;\n    }\n    \n    private void HandleClimbInput()\n    {\n        if (Input.GetKeyDown(_climbKey))\n        {\n            if (_canClimb && !_isClimbing)\n            {\n                StartClimbing();\n            }\n            else if (_isClimbing)\n            {\n                StopClimbing();\n            }\n        }\n    }\n    \n    private void StartClimbing()\n    {\n        if (!_canClimb || _currentClimbSurface == null) return;\n        \n        _isClimbing = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 climbPosition = _currentClimbSurface.transform.position + _climbOffset;\n        transform.position = Vector3.Lerp(transform.position, climbPosition, Time.deltaTime * 5f);\n        \n        OnClimbStart?.Invoke();\n    }\n    \n    private void StopClimbing()\n    {\n        _isClimbing = false;\n        _rigidbody.useGravity = true;\n        _currentClimbSurface = null;\n        \n        OnClimbEnd?.Invoke();\n    }\n    \n    private void HandleClimbMovement()\n    {\n        if (!_isClimbing || _currentClimbSurface == null) return;\n        \n        Vector3 moveDirection = Vector3.zero;\n        \n        float verticalInput = Input.GetAxis(\"Vertical\");\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(verticalInput) > 0.1f)\n        {\n            moveDirection += Vector3.up * verticalInput * _climbSpeed;\n        }\n        \n        if (Mathf.Abs(horizontalInput) > 0.1f)\n        {\n            Vector3 rightDirection = Vector3.Cross(Vector3.up, _climbDirection).normalized;\n            moveDirection += rightDirection * horizontalInput * _horizontalClimbSpeed;\n        }\n        \n        _rigidbody.velocity = moveDirection;\n        \n        Vector3 targetPosition = transform.position + _climbDirection * 0.1f;\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 2f);\n        \n        if (_currentClimbSurface != null)\n        {\n            transform.LookAt(transform.position + _climbDirection, Vector3.up);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_climbableTag))\n        {\n            _canClimb = true;\n            _currentClimbSurface = other.gameObject;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_climbableTag) && other.gameObject == _currentClimbSurface)\n        {\n            _canClimb = false;\n            if (_isClimbing)\n            {\n                StopClimbing();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_climbDetectionPoint != null)\n        {\n            Gizmos.color = _canClimb ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_climbDetectionPoint.position, _climbDetectionRadius);\n            \n            if (_isClimbing && _currentClimbSurface != null)\n            {\n                Gizmos.color = Color.blue;\n                Gizmos.DrawRay(transform.position, _climbDirection * 2f);\n            }\n        }\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, transform.forward * _climbDetectionDistance);\n    }\n    \n    public bool IsClimbing => _isClimbing;\n    public bool CanClimb => _canClimb;\n    public GameObject CurrentClimbSurface => _currentClimbSurface;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "swimming with oxygen meter",
      "ideal_ir": {
        "class_name": "SwimmingController",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "maxOxygen",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentOxygen",
            "type": "float",
            "default": 100
          },
          {
            "name": "oxygenDepletionRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "oxygenRecoveryRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "swimSpeed",
            "type": "float",
            "default": 5
          },
          {
            "name": "isUnderwater",
            "type": "bool",
            "default": false
          },
          {
            "name": "isDrowning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "enter_water",
            "trigger": "when player enters water trigger zone",
            "actions": [
              {
                "action": "set underwater status to true"
              },
              {
                "action": "enable swimming movement controls"
              }
            ]
          },
          {
            "name": "exit_water",
            "trigger": "when player exits water trigger zone",
            "actions": [
              {
                "action": "set underwater status to false"
              },
              {
                "action": "disable swimming movement controls"
              },
              {
                "action": "restore normal movement"
              }
            ]
          },
          {
            "name": "swim_movement",
            "trigger": "when underwater and movement input is detected",
            "actions": [
              {
                "action": "move player in input direction at swim speed"
              },
              {
                "action": "apply water resistance to movement"
              }
            ]
          },
          {
            "name": "deplete_oxygen",
            "trigger": "when underwater every second",
            "actions": [
              {
                "action": "reduce current oxygen by depletion rate"
              },
              {
                "action": "update oxygen meter display"
              }
            ]
          },
          {
            "name": "recover_oxygen",
            "trigger": "when above water surface every second",
            "actions": [
              {
                "action": "increase current oxygen by recovery rate up to maximum"
              },
              {
                "action": "update oxygen meter display"
              }
            ]
          },
          {
            "name": "start_drowning",
            "trigger": "when current oxygen reaches zero",
            "actions": [
              {
                "action": "set drowning status to true"
              },
              {
                "action": "begin taking drowning damage over time"
              },
              {
                "action": "display drowning warning effects"
              }
            ]
          },
          {
            "name": "stop_drowning",
            "trigger": "when drowning and oxygen is restored above zero",
            "actions": [
              {
                "action": "set drowning status to false"
              },
              {
                "action": "stop taking drowning damage"
              },
              {
                "action": "remove drowning warning effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class SwimmingController : MonoBehaviour\n{\n    [System.Serializable]\n    public class SwimmingEvents\n    {\n        public UnityEvent OnStartSwimming;\n        public UnityEvent OnStopSwimming;\n        public UnityEvent OnOxygenDepleted;\n        public UnityEvent OnOxygenRestored;\n    }\n\n    [Header(\"Swimming Settings\")]\n    [SerializeField] private float _swimSpeed = 3f;\n    [SerializeField] private float _swimUpForce = 5f;\n    [SerializeField] private float _swimDownForce = 3f;\n    [SerializeField] private float _waterDrag = 5f;\n    [SerializeField] private float _waterAngularDrag = 5f;\n    [SerializeField] private LayerMask _waterLayer = 1;\n\n    [Header(\"Oxygen System\")]\n    [SerializeField] private float _maxOxygen = 100f;\n    [SerializeField] private float _oxygenDepletionRate = 10f;\n    [SerializeField] private float _oxygenRestoreRate = 20f;\n    [SerializeField] private float _lowOxygenThreshold = 25f;\n    [SerializeField] private bool _canDrownWhenOxygenDepleted = true;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Slider _oxygenMeter;\n    [SerializeField] private Image _oxygenFill;\n    [SerializeField] private Color _normalOxygenColor = Color.cyan;\n    [SerializeField] private Color _lowOxygenColor = Color.red;\n    [SerializeField] private GameObject _oxygenUI;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _drowningSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _splashEffect;\n\n    [Header(\"Events\")]\n    [SerializeField] private SwimmingEvents _events;\n\n    private Rigidbody _rigidbody;\n    private bool _isSwimming = false;\n    private bool _isUnderwater = false;\n    private float _currentOxygen;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    private bool _isDrowning = false;\n    private float _breathingTimer = 0f;\n    private float _breathingInterval = 2f;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n\n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n        _currentOxygen = _maxOxygen;\n\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n\n        InitializeUI();\n    }\n\n    private void Update()\n    {\n        HandleSwimmingInput();\n        UpdateOxygenSystem();\n        UpdateUI();\n        UpdateEffects();\n    }\n\n    private void HandleSwimmingInput()\n    {\n        if (!_isSwimming) return;\n\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        bool swimUp = Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.E);\n        bool swimDown = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.Q);\n\n        Vector3 swimDirection = Vector3.zero;\n\n        // Horizontal movement\n        swimDirection += transform.right * horizontal;\n        swimDirection += transform.forward * vertical;\n\n        // Vertical movement\n        if (swimUp)\n        {\n            swimDirection += Vector3.up;\n        }\n        else if (swimDown)\n        {\n            swimDirection += Vector3.down;\n        }\n\n        // Apply swimming force\n        if (swimDirection.magnitude > 0.1f)\n        {\n            swimDirection.Normalize();\n            Vector3 force = swimDirection * _swimSpeed;\n            \n            if (swimDirection.y > 0)\n            {\n                force.y *= _swimUpForce / _swimSpeed;\n            }\n            else if (swimDirection.y < 0)\n            {\n                force.y *= _swimDownForce / _swimSpeed;\n            }\n\n            _rigidbody.AddForce(force, ForceMode.Acceleration);\n        }\n    }\n\n    private void UpdateOxygenSystem()\n    {\n        if (_isUnderwater)\n        {\n            _currentOxygen -= _oxygenDepletionRate * Time.deltaTime;\n            _currentOxygen = Mathf.Max(0f, _currentOxygen);\n\n            if (_currentOxygen <= 0f && !_isDrowning)\n            {\n                StartDrowning();\n            }\n\n            // Breathing sound effect\n            _breathingTimer += Time.deltaTime;\n            if (_breathingTimer >= _breathingInterval && _breathingSound != null)\n            {\n                _audioSource.PlayOneShot(_breathingSound, 0.3f);\n                _breathingTimer = 0f;\n            }\n        }\n        else if (_isSwimming && !_isUnderwater)\n        {\n            // Restore oxygen when at surface\n            _currentOxygen += _oxygenRestoreRate * Time.deltaTime;\n            _currentOxygen = Mathf.Min(_maxOxygen, _currentOxygen);\n\n            if (_isDrowning && _currentOxygen > _lowOxygenThreshold)\n            {\n                StopDrowning();\n            }\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_oxygenMeter != null)\n        {\n            _oxygenMeter.value = _currentOxygen / _maxOxygen;\n        }\n\n        if (_oxygenFill != null)\n        {\n            _oxygenFill.color = _currentOxygen <= _lowOxygenThreshold ? _lowOxygenColor : _normalOxygenColor;\n        }\n\n        if (_oxygenUI != null)\n        {\n            _oxygenUI.SetActive(_isSwimming);\n        }\n    }\n\n    private void UpdateEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            if (_isUnderwater && _currentOxygen > 0f)\n            {\n                if (!_bubbleEffect.isPlaying)\n                {\n                    _bubbleEffect.Play();\n                }\n            }\n            else\n            {\n                if (_bubbleEffect.isPlaying)\n                {\n                    _bubbleEffect.Stop();\n                }\n            }\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            StartSwimming();\n            \n            if (_splashEffect != null)\n            {\n                _splashEffect.transform.position = other.ClosestPoint(transform.position);\n                _splashEffect.Play();\n            }\n\n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            // Check if player is fully submerged\n            Vector3 waterSurface = other.bounds.max;\n            waterSurface.x = transform.position.x;\n            waterSurface.z = transform.position.z;\n\n            _isUnderwater = transform.position.y < waterSurface.y - 0.5f;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            StopSwimming();\n            _isUnderwater = false;\n\n            if (_splashEffect != null)\n            {\n                _splashEffect.transform.position = other.ClosestPoint(transform.position);\n                _splashEffect.Play();\n            }\n\n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n\n    private void StartSwimming()\n    {\n        if (_isSwimming) return;\n\n        _isSwimming = true;\n        _rigidbody.drag = _waterDrag;\n        _rigidbody.angularDrag = _waterAngularDrag;\n        \n        _events?.OnStartSwimming?.Invoke();\n    }\n\n    private void StopSwimming()\n    {\n        if (!_isSwimming) return;\n\n        _isSwimming = false;\n        _rigidbody.drag = _originalDrag;\n        _rigidbody.angularDrag = _originalAngularDrag;\n        \n        if (_isDrowning)\n        {\n            StopDrowning();\n        }\n\n        _events?.OnStopSwimming?.Invoke();\n    }\n\n    private void StartDrowning()\n    {\n        _isDrowning = true;\n        \n        if (_drowningSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_drowningSound);\n        }\n\n        _events?.OnOxygenDepleted?.Invoke();\n\n        if (_canDrownWhenOxygenDepleted)\n        {\n            // Apply damage or death logic here\n            Debug.Log(\"Player is drowning!\");\n        }\n    }\n\n    private void StopDrowning()\n    {\n        _isDrowning = false;\n        _events?.OnOxygenRestored?.Invoke();\n    }\n\n    private bool IsWaterLayer(int layer)\n    {\n        return (_waterLayer.value & (1 << layer)) != 0;\n    }\n\n    private void InitializeUI()\n    {\n        if (_oxygenMeter != null)\n        {\n            _oxygenMeter.minValue = 0f;\n            _oxygenMeter.maxValue = 1f;\n            _oxygenMeter.value = 1f;\n        }\n\n        if (_oxygenUI != null)\n        {\n            _oxygenUI.SetActive(false);\n        }\n    }\n\n    public float GetOxygenPercentage()\n    {\n        return _currentOxygen / _maxOxygen;\n    }\n\n    public bool IsSwimming()\n    {\n        return _isSwimming;\n    }\n\n    public bool IsUnderwater()\n    {\n        return _isUnderwater;\n    }\n\n    public bool IsDrowning()\n    {\n        return _isDrowning;\n    }\n\n    public void RestoreOxygen(float amount)\n    {\n        _currentOxygen = Mathf.Min(_maxOxygen, _currentOxygen + amount);\n    }\n\n    public void SetMaxOxygen(float newMaxOxygen)\n    {\n        _maxOxygen = newMaxOxygen;\n        _currentOxygen = Mathf.Min(_currentOxygen, _maxOxygen);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "gliding with parachute",
      "ideal_ir": {
        "class_name": "ParachuteGlider",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "glidingSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "steeringForce",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isParachuteDeployed",
            "type": "bool",
            "default": false
          },
          {
            "name": "minDeployHeight",
            "type": "float",
            "default": 10.0
          }
        ],
        "behaviors": [
          {
            "name": "deploy_parachute",
            "trigger": "when player presses deploy key and is above minimum height",
            "actions": [
              {
                "action": "set parachute as deployed"
              },
              {
                "action": "reduce falling speed significantly"
              },
              {
                "action": "enable horizontal gliding movement"
              }
            ]
          },
          {
            "name": "glide_forward",
            "trigger": "when parachute is deployed and moving forward",
            "actions": [
              {
                "action": "move forward at gliding speed"
              },
              {
                "action": "maintain gentle downward descent"
              }
            ]
          },
          {
            "name": "steer_left",
            "trigger": "when parachute is deployed and left input is pressed",
            "actions": [
              {
                "action": "apply leftward steering force"
              },
              {
                "action": "slightly tilt parachute to the left"
              }
            ]
          },
          {
            "name": "steer_right",
            "trigger": "when parachute is deployed and right input is pressed",
            "actions": [
              {
                "action": "apply rightward steering force"
              },
              {
                "action": "slightly tilt parachute to the right"
              }
            ]
          },
          {
            "name": "land_safely",
            "trigger": "when parachute is deployed and touching ground",
            "actions": [
              {
                "action": "reduce all movement to zero"
              },
              {
                "action": "disable parachute physics"
              },
              {
                "action": "transition to ground movement state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class ParachuteGlider : MonoBehaviour\n{\n    [Header(\"Parachute Settings\")]\n    [SerializeField] private GameObject _parachuteModel;\n    [SerializeField] private float _deployTime = 1.5f;\n    [SerializeField] private float _packTime = 0.8f;\n    \n    [Header(\"Gliding Physics\")]\n    [SerializeField] private float _glidingGravity = 2f;\n    [SerializeField] private float _normalGravity = 9.81f;\n    [SerializeField] private float _horizontalSpeed = 8f;\n    [SerializeField] private float _maxFallSpeed = 3f;\n    [SerializeField] private float _liftForce = 5f;\n    \n    [Header(\"Controls\")]\n    [SerializeField] private KeyCode _deployKey = KeyCode.Space;\n    [SerializeField] private float _turnSpeed = 45f;\n    [SerializeField] private float _tiltAmount = 15f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 1.5f;\n    [SerializeField] private float _autoPackHeight = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isGliding = false;\n    private bool _isDeploying = false;\n    private bool _isPacking = false;\n    private float _deployTimer = 0f;\n    private float _originalDrag;\n    private Vector3 _originalScale;\n    private bool _isGrounded = false;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        \n        if (_parachuteModel != null)\n        {\n            _originalScale = _parachuteModel.transform.localScale;\n            _parachuteModel.transform.localScale = Vector3.zero;\n            _parachuteModel.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleInput();\n        UpdateParachuteAnimation();\n        \n        if (_isGliding && !_isGrounded)\n        {\n            HandleGlidingMovement();\n        }\n        \n        if (_isGrounded && _isGliding)\n        {\n            PackParachute();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGliding && !_isGrounded)\n        {\n            ApplyGlidingPhysics();\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _groundCheckDistance, _groundLayer);\n        \n        if (_isGrounded && hit.distance < _autoPackHeight && _isGliding)\n        {\n            PackParachute();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_deployKey))\n        {\n            if (!_isGliding && !_isGrounded && !_isDeploying && !_isPacking)\n            {\n                DeployParachute();\n            }\n            else if (_isGliding && !_isDeploying && !_isPacking)\n            {\n                PackParachute();\n            }\n        }\n    }\n    \n    private void HandleGlidingMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        // Horizontal movement\n        Vector3 moveDirection = new Vector3(horizontal, 0, vertical).normalized;\n        if (moveDirection.magnitude > 0.1f)\n        {\n            Vector3 targetDirection = transform.TransformDirection(moveDirection);\n            _rigidbody.AddForce(targetDirection * _horizontalSpeed, ForceMode.Acceleration);\n        }\n        \n        // Turning\n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            transform.Rotate(0, horizontal * _turnSpeed * Time.deltaTime, 0);\n            \n            // Tilt parachute\n            if (_parachuteModel != null)\n            {\n                Vector3 tiltRotation = new Vector3(0, 0, -horizontal * _tiltAmount);\n                _parachuteModel.transform.localRotation = Quaternion.Lerp(\n                    _parachuteModel.transform.localRotation,\n                    Quaternion.Euler(tiltRotation),\n                    Time.deltaTime * 3f\n                );\n            }\n        }\n        else if (_parachuteModel != null)\n        {\n            _parachuteModel.transform.localRotation = Quaternion.Lerp(\n                _parachuteModel.transform.localRotation,\n                Quaternion.identity,\n                Time.deltaTime * 3f\n            );\n        }\n        \n        // Forward lift\n        if (vertical > 0.1f)\n        {\n            _rigidbody.AddForce(transform.forward * _liftForce * vertical, ForceMode.Acceleration);\n        }\n    }\n    \n    private void ApplyGlidingPhysics()\n    {\n        // Apply custom gravity\n        _rigidbody.AddForce(Vector3.down * _glidingGravity, ForceMode.Acceleration);\n        \n        // Limit fall speed\n        if (_rigidbody.velocity.y < -_maxFallSpeed)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = -_maxFallSpeed;\n            _rigidbody.velocity = velocity;\n        }\n        \n        // Add air resistance\n        Vector3 airResistance = -_rigidbody.velocity * 0.5f;\n        airResistance.y *= 0.8f; // Less resistance on vertical movement\n        _rigidbody.AddForce(airResistance, ForceMode.Acceleration);\n    }\n    \n    private void DeployParachute()\n    {\n        if (_isDeploying || _isPacking || _isGliding) return;\n        \n        _isDeploying = true;\n        _deployTimer = 0f;\n        \n        if (_parachuteModel != null)\n        {\n            _parachuteModel.SetActive(true);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Deploy\");\n        }\n    }\n    \n    private void PackParachute()\n    {\n        if (_isPacking || !_isGliding) return;\n        \n        _isPacking = true;\n        _isGliding = false;\n        _deployTimer = 0f;\n        \n        // Restore normal physics\n        _rigidbody.drag = _originalDrag;\n        _rigidbody.useGravity = true;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Pack\");\n        }\n    }\n    \n    private void UpdateParachuteAnimation()\n    {\n        if (_isDeploying)\n        {\n            _deployTimer += Time.deltaTime;\n            float progress = _deployTimer / _deployTime;\n            \n            if (_parachuteModel != null)\n            {\n                _parachuteModel.transform.localScale = Vector3.Lerp(Vector3.zero, _originalScale, progress);\n            }\n            \n            if (progress >= 1f)\n            {\n                _isDeploying = false;\n                _isGliding = true;\n                \n                // Apply gliding physics\n                _rigidbody.drag = 3f;\n                _rigidbody.useGravity = false;\n            }\n        }\n        else if (_isPacking)\n        {\n            _deployTimer += Time.deltaTime;\n            float progress = _deployTimer / _packTime;\n            \n            if (_parachuteModel != null)\n            {\n                _parachuteModel.transform.localScale = Vector3.Lerp(_originalScale, Vector3.zero, progress);\n            }\n            \n            if (progress >= 1f)\n            {\n                _isPacking = false;\n                \n                if (_parachuteModel != null)\n                {\n                    _parachuteModel.SetActive(false);\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, Vector3.down * _groundCheckDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position - Vector3.up * _autoPackHeight, 0.5f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ground pound attack",
      "ideal_ir": {
        "class_name": "GroundPoundAttack",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "chargeTime",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "poundForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "damageRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 50
          },
          {
            "name": "shakeIntensity",
            "type": "float",
            "default": 2
          },
          {
            "name": "isCharging",
            "type": "bool",
            "default": false
          },
          {
            "name": "isPounding",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_ground_pound",
            "trigger": "when ground pound input is pressed and character is in air",
            "actions": [
              {
                "action": "set charging state to true"
              },
              {
                "action": "freeze horizontal movement"
              },
              {
                "action": "play charging animation"
              },
              {
                "action": "play charging sound effect"
              }
            ]
          },
          {
            "name": "execute_pound",
            "trigger": "when charge time has elapsed while charging",
            "actions": [
              {
                "action": "set pounding state to true"
              },
              {
                "action": "set charging state to false"
              },
              {
                "action": "apply downward force with pound strength"
              },
              {
                "action": "play pound animation"
              }
            ]
          },
          {
            "name": "impact_ground",
            "trigger": "when character hits ground while pounding",
            "actions": [
              {
                "action": "create damage area around impact point with damage radius"
              },
              {
                "action": "deal damage to all enemies within damage area"
              },
              {
                "action": "shake camera with shake intensity"
              },
              {
                "action": "play impact sound effect"
              },
              {
                "action": "spawn dust particle effects"
              },
              {
                "action": "set pounding state to false"
              },
              {
                "action": "restore normal movement"
              }
            ]
          },
          {
            "name": "cancel_pound",
            "trigger": "when character touches wall while charging or pounding",
            "actions": [
              {
                "action": "set charging state to false"
              },
              {
                "action": "set pounding state to false"
              },
              {
                "action": "restore normal movement"
              },
              {
                "action": "stop charging effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GroundPoundAttack : MonoBehaviour\n{\n    [Header(\"Ground Pound Settings\")]\n    [SerializeField] private float _poundForce = 20f;\n    [SerializeField] private float _poundRadius = 5f;\n    [SerializeField] private float _poundDamage = 50f;\n    [SerializeField] private float _chargeTime = 0.5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private LayerMask _enemyLayer = -1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _poundKey = KeyCode.Q;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _chargingEffect;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private ParticleSystem _dustParticles;\n    [SerializeField] private float _cameraShakeIntensity = 0.5f;\n    [SerializeField] private float _cameraShakeDuration = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _impactSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGroundPoundStart;\n    public UnityEvent OnGroundPoundImpact;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Camera _mainCamera;\n    private bool _isCharging = false;\n    private bool _isPounding = false;\n    private bool _isOnCooldown = false;\n    private float _chargeTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Vector3 _originalCameraPosition;\n    private float _cameraShakeTimer = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _mainCamera = Camera.main;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharging();\n        UpdateCooldown();\n        UpdateCameraShake();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isOnCooldown || _isPounding) return;\n        \n        if (Input.GetKeyDown(_poundKey) && !_isCharging && IsGrounded())\n        {\n            StartCharging();\n        }\n        \n        if (Input.GetKeyUp(_poundKey) && _isCharging)\n        {\n            if (_chargeTimer >= _chargeTime)\n            {\n                ExecuteGroundPound();\n            }\n            else\n            {\n                CancelCharging();\n            }\n        }\n    }\n    \n    private void UpdateCharging()\n    {\n        if (!_isCharging) return;\n        \n        _chargeTimer += Time.deltaTime;\n        \n        if (Input.GetKey(_poundKey))\n        {\n            if (_chargeTimer >= _chargeTime && !_isPounding)\n            {\n                ExecuteGroundPound();\n            }\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_isOnCooldown) return;\n        \n        _cooldownTimer -= Time.deltaTime;\n        if (_cooldownTimer <= 0f)\n        {\n            _isOnCooldown = false;\n        }\n    }\n    \n    private void UpdateCameraShake()\n    {\n        if (_cameraShakeTimer <= 0f || _mainCamera == null) return;\n        \n        _cameraShakeTimer -= Time.deltaTime;\n        \n        if (_cameraShakeTimer > 0f)\n        {\n            Vector3 shakeOffset = Random.insideUnitSphere * _cameraShakeIntensity;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n        else\n        {\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n        }\n    }\n    \n    private void StartCharging()\n    {\n        _isCharging = true;\n        _chargeTimer = 0f;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(true);\n        }\n        \n        PlaySound(_chargeSound);\n        OnGroundPoundStart?.Invoke();\n    }\n    \n    private void CancelCharging()\n    {\n        _isCharging = false;\n        _chargeTimer = 0f;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n    }\n    \n    private void ExecuteGroundPound()\n    {\n        _isCharging = false;\n        _isPounding = true;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n        \n        _rigidbody.velocity = Vector3.down * _poundForce;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_isPounding) return;\n        \n        if (IsInLayerMask(collision.gameObject.layer, _groundLayer))\n        {\n            PerformGroundImpact();\n        }\n    }\n    \n    private void PerformGroundImpact()\n    {\n        _isPounding = false;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        Vector3 impactPosition = transform.position;\n        \n        // Create impact effect\n        if (_impactEffect != null)\n        {\n            Instantiate(_impactEffect, impactPosition, Quaternion.identity);\n        }\n        \n        // Play dust particles\n        if (_dustParticles != null)\n        {\n            _dustParticles.transform.position = impactPosition;\n            _dustParticles.Play();\n        }\n        \n        // Camera shake\n        if (_mainCamera != null)\n        {\n            _cameraShakeTimer = _cameraShakeDuration;\n        }\n        \n        // Play impact sound\n        PlaySound(_impactSound);\n        \n        // Deal damage to enemies in radius\n        DealDamageInRadius(impactPosition);\n        \n        // Apply knockback to rigidbodies in radius\n        ApplyKnockbackInRadius(impactPosition);\n        \n        OnGroundPoundImpact?.Invoke();\n    }\n    \n    private void DealDamageInRadius(Vector3 center)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(center, _poundRadius, _enemyLayer);\n        float totalDamage = 0f;\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Try to find health component or similar\n            var healthComponent = hitCollider.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send damage message if the object can receive it\n                hitCollider.SendMessage(\"TakeDamage\", _poundDamage, SendMessageOptions.DontRequireReceiver);\n                totalDamage += _poundDamage;\n            }\n            \n            // Alternative: destroy objects with specific tags\n            if (hitCollider.CompareTag(\"Enemy\") || hitCollider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hitCollider.gameObject);\n                totalDamage += _poundDamage;\n            }\n        }\n        \n        if (totalDamage > 0f)\n        {\n            OnDamageDealt?.Invoke(totalDamage);\n        }\n    }\n    \n    private void ApplyKnockbackInRadius(Vector3 center)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(center, _poundRadius);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject == gameObject) continue;\n            \n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - center).normalized;\n                float distance = Vector3.Distance(center, hitCollider.transform.position);\n                float knockbackForce = Mathf.Lerp(_poundForce, 0f, distance / _poundRadius);\n                \n                hitRigidbody.AddForce(direction * knockbackForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        float rayDistance = 1.1f;\n        return Physics.Raycast(transform.position, Vector3.down, rayDistance, _groundLayer);\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _poundRadius);\n        \n        if (_isCharging)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _poundRadius * 0.5f);\n        }\n    }\n    \n    public bool IsOnCooldown => _isOnCooldown;\n    public bool IsCharging => _isCharging;\n    public bool IsPounding => _isPounding;\n    public float CooldownProgress => _isOnCooldown ? (1f - _cooldownTimer / _cooldownTime) : 1f;\n    public float ChargeProgress => _isCharging ? Mathf.Clamp01(_chargeTimer / _chargeTime) : 0f;\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "sprint with stamina cost",
      "ideal_ir": {
        "class_name": "SprintController",
        "components": [
          "CharacterController"
        ],
        "fields": [
          {
            "name": "maxStamina",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentStamina",
            "type": "float",
            "default": 100
          },
          {
            "name": "staminaDrainRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "staminaRegenRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "sprintSpeed",
            "type": "float",
            "default": 8
          },
          {
            "name": "walkSpeed",
            "type": "float",
            "default": 4
          },
          {
            "name": "isSprinting",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_sprinting",
            "trigger": "when sprint key is pressed and stamina is above zero",
            "actions": [
              {
                "action": "set sprinting state to true"
              },
              {
                "action": "increase movement speed to sprint speed"
              }
            ]
          },
          {
            "name": "drain_stamina_while_sprinting",
            "trigger": "while sprinting is active",
            "actions": [
              {
                "action": "decrease current stamina by drain rate over time"
              }
            ]
          },
          {
            "name": "stop_sprinting_no_stamina",
            "trigger": "when current stamina reaches zero while sprinting",
            "actions": [
              {
                "action": "set sprinting state to false"
              },
              {
                "action": "reduce movement speed to walk speed"
              }
            ]
          },
          {
            "name": "stop_sprinting_key_release",
            "trigger": "when sprint key is released",
            "actions": [
              {
                "action": "set sprinting state to false"
              },
              {
                "action": "reduce movement speed to walk speed"
              }
            ]
          },
          {
            "name": "regenerate_stamina",
            "trigger": "while not sprinting and stamina is below maximum",
            "actions": [
              {
                "action": "increase current stamina by regeneration rate over time"
              },
              {
                "action": "clamp stamina to maximum value"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SprintSystem : MonoBehaviour\n{\n    [Header(\"Sprint Settings\")]\n    [SerializeField] private float _normalSpeed = 5f;\n    [SerializeField] private float _sprintSpeed = 8f;\n    [SerializeField] private KeyCode _sprintKey = KeyCode.LeftShift;\n    \n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    [SerializeField] private float _regenDelay = 1f;\n    [SerializeField] private float _minStaminaToSprint = 10f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sprintSound;\n    [SerializeField] private AudioClip _exhaustedSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float, float> OnStaminaChanged;\n    public UnityEvent OnSprintStarted;\n    public UnityEvent OnSprintStopped;\n    public UnityEvent OnExhausted;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _currentStamina;\n    private bool _isSprinting;\n    private bool _canSprint = true;\n    private float _lastSprintTime;\n    private Vector3 _moveDirection;\n    private bool _isMoving;\n    \n    private void Start()\n    {\n        _currentStamina = _maxStamina;\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleSprinting();\n        HandleStamina();\n        HandleMovement();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        _moveDirection = new Vector3(horizontal, 0f, vertical).normalized;\n        _isMoving = _moveDirection.magnitude > 0.1f;\n        \n        bool sprintInput = Input.GetKey(_sprintKey);\n        bool shouldSprint = sprintInput && _isMoving && _canSprint && _currentStamina >= _minStaminaToSprint;\n        \n        if (shouldSprint && !_isSprinting)\n        {\n            StartSprint();\n        }\n        else if ((!sprintInput || !_isMoving || _currentStamina <= 0f) && _isSprinting)\n        {\n            StopSprint();\n        }\n    }\n    \n    private void HandleSprinting()\n    {\n        if (_isSprinting && _currentStamina > 0f)\n        {\n            _currentStamina -= _staminaDrainRate * Time.deltaTime;\n            _lastSprintTime = Time.time;\n            \n            if (_currentStamina <= 0f)\n            {\n                _currentStamina = 0f;\n                StopSprint();\n                OnExhausted?.Invoke();\n                \n                if (_audioSource && _exhaustedSound)\n                    _audioSource.PlayOneShot(_exhaustedSound);\n            }\n        }\n    }\n    \n    private void HandleStamina()\n    {\n        if (!_isSprinting && _currentStamina < _maxStamina)\n        {\n            if (Time.time - _lastSprintTime >= _regenDelay)\n            {\n                _currentStamina += _staminaRegenRate * Time.deltaTime;\n                _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n            }\n        }\n        \n        _canSprint = _currentStamina >= _minStaminaToSprint;\n        OnStaminaChanged?.Invoke(_currentStamina, _maxStamina);\n    }\n    \n    private void HandleMovement()\n    {\n        if (!_isMoving) return;\n        \n        float currentSpeed = _isSprinting ? _sprintSpeed : _normalSpeed;\n        Vector3 movement = transform.TransformDirection(_moveDirection) * currentSpeed;\n        \n        if (_characterController != null)\n        {\n            movement.y = -9.81f;\n            _characterController.Move(movement * Time.deltaTime);\n        }\n        else if (_rigidbody != null)\n        {\n            Vector3 velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n            _rigidbody.velocity = velocity;\n        }\n        else\n        {\n            transform.Translate(movement * Time.deltaTime, Space.World);\n        }\n    }\n    \n    private void StartSprint()\n    {\n        _isSprinting = true;\n        OnSprintStarted?.Invoke();\n        \n        if (_audioSource && _sprintSound)\n        {\n            _audioSource.clip = _sprintSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopSprint()\n    {\n        _isSprinting = false;\n        OnSprintStopped?.Invoke();\n        \n        if (_audioSource && _audioSource.isPlaying && _audioSource.clip == _sprintSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsSprinting()\n    {\n        return _isSprinting;\n    }\n    \n    public bool CanSprint()\n    {\n        return _canSprint;\n    }\n    \n    public void RestoreStamina(float amount)\n    {\n        _currentStamina = Mathf.Clamp(_currentStamina + amount, 0f, _maxStamina);\n    }\n    \n    public void DrainStamina(float amount)\n    {\n        _currentStamina = Mathf.Clamp(_currentStamina - amount, 0f, _maxStamina);\n        \n        if (_currentStamina <= 0f && _isSprinting)\n        {\n            StopSprint();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "crouch and crawl movement",
      "ideal_ir": {
        "class_name": "CrouchCrawlMovement",
        "components": [
          "CharacterController",
          "Animator"
        ],
        "fields": [
          {
            "name": "walkSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "crouchSpeed",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "crawlSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "standingHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "crouchHeight",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "crawlHeight",
            "type": "float",
            "default": 0.6
          },
          {
            "name": "transitionSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "currentMovementState",
            "type": "string",
            "default": "standing"
          },
          {
            "name": "isMoving",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "enter_crouch_mode",
            "trigger": "when crouch input is pressed while standing",
            "actions": [
              {
                "action": "set movement state to crouching"
              },
              {
                "action": "smoothly reduce character height to crouch height"
              },
              {
                "action": "play crouch animation"
              },
              {
                "action": "reduce movement speed to crouch speed"
              }
            ]
          },
          {
            "name": "exit_crouch_mode",
            "trigger": "when crouch input is released while crouching and there is space above",
            "actions": [
              {
                "action": "set movement state to standing"
              },
              {
                "action": "smoothly increase character height to standing height"
              },
              {
                "action": "play stand animation"
              },
              {
                "action": "restore movement speed to walk speed"
              }
            ]
          },
          {
            "name": "enter_crawl_mode",
            "trigger": "when crouch input is held and crawl input is pressed while crouching",
            "actions": [
              {
                "action": "set movement state to crawling"
              },
              {
                "action": "smoothly reduce character height to crawl height"
              },
              {
                "action": "play crawl idle animation"
              },
              {
                "action": "reduce movement speed to crawl speed"
              }
            ]
          },
          {
            "name": "exit_crawl_mode",
            "trigger": "when crawl input is released while crawling",
            "actions": [
              {
                "action": "set movement state to crouching"
              },
              {
                "action": "smoothly increase character height to crouch height"
              },
              {
                "action": "play crouch animation"
              },
              {
                "action": "increase movement speed to crouch speed"
              }
            ]
          },
          {
            "name": "crouch_movement",
            "trigger": "when movement input is received while in crouching state",
            "actions": [
              {
                "action": "move character in input direction at crouch speed"
              },
              {
                "action": "play crouch walk animation"
              },
              {
                "action": "set is moving to true"
              }
            ]
          },
          {
            "name": "crawl_movement",
            "trigger": "when movement input is received while in crawling state",
            "actions": [
              {
                "action": "move character in input direction at crawl speed"
              },
              {
                "action": "play crawl movement animation"
              },
              {
                "action": "set is moving to true"
              }
            ]
          },
          {
            "name": "stop_movement",
            "trigger": "when no movement input is received",
            "actions": [
              {
                "action": "stop character movement"
              },
              {
                "action": "play appropriate idle animation based on current state"
              },
              {
                "action": "set is moving to false"
              }
            ]
          },
          {
            "name": "check_overhead_clearance",
            "trigger": "when attempting to stand up from crouch or crawl",
            "actions": [
              {
                "action": "check if there is sufficient space above character"
              },
              {
                "action": "prevent standing if obstacle is detected overhead"
              },
              {
                "action": "maintain current posture if blocked"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class CrouchCrawlMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _walkSpeed = 5f;\n    [SerializeField] private float _crouchSpeed = 2.5f;\n    [SerializeField] private float _crawlSpeed = 1.5f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 10f;\n    \n    [Header(\"Stance Settings\")]\n    [SerializeField] private float _standingHeight = 2f;\n    [SerializeField] private float _crouchHeight = 1.2f;\n    [SerializeField] private float _crawlHeight = 0.6f;\n    [SerializeField] private float _stanceTransitionSpeed = 8f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _crouchKey = KeyCode.LeftControl;\n    [SerializeField] private KeyCode _crawlKey = KeyCode.C;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Ceiling Check\")]\n    [SerializeField] private float _ceilingCheckDistance = 0.1f;\n    [SerializeField] private LayerMask _ceilingLayerMask = 1;\n    \n    private CharacterController _characterController;\n    private Camera _playerCamera;\n    private Vector3 _moveDirection;\n    private Vector3 _velocity;\n    private float _currentSpeed;\n    private float _targetHeight;\n    private float _currentCameraHeight;\n    private bool _isGrounded;\n    private MovementStance _currentStance = MovementStance.Standing;\n    \n    private enum MovementStance\n    {\n        Standing,\n        Crouching,\n        Crawling\n    }\n    \n    void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _playerCamera = GetComponentInChildren<Camera>();\n        \n        if (_characterController == null)\n        {\n            Debug.LogError(\"CharacterController component required!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_playerCamera == null)\n        {\n            _playerCamera = Camera.main;\n        }\n        \n        _targetHeight = _standingHeight;\n        _currentCameraHeight = _standingHeight - 0.1f;\n        _characterController.height = _standingHeight;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        HandleStanceTransition();\n        HandleMovement();\n        UpdateCameraPosition();\n    }\n    \n    void HandleInput()\n    {\n        bool crouchInput = Input.GetKey(_crouchKey);\n        bool crawlInput = Input.GetKey(_crawlKey);\n        \n        MovementStance desiredStance = MovementStance.Standing;\n        \n        if (crawlInput)\n        {\n            desiredStance = MovementStance.Crawling;\n        }\n        else if (crouchInput)\n        {\n            desiredStance = MovementStance.Crouching;\n        }\n        \n        if (desiredStance != _currentStance)\n        {\n            if (CanChangeStance(desiredStance))\n            {\n                _currentStance = desiredStance;\n                UpdateTargetHeight();\n            }\n        }\n    }\n    \n    bool CanChangeStance(MovementStance newStance)\n    {\n        if (newStance == MovementStance.Standing || newStance == MovementStance.Crouching)\n        {\n            float checkHeight = newStance == MovementStance.Standing ? _standingHeight : _crouchHeight;\n            return !CheckCeiling(checkHeight);\n        }\n        return true;\n    }\n    \n    bool CheckCeiling(float checkHeight)\n    {\n        Vector3 rayStart = transform.position + Vector3.up * _characterController.height * 0.5f;\n        Vector3 rayEnd = transform.position + Vector3.up * (checkHeight * 0.5f + _ceilingCheckDistance);\n        \n        return Physics.Raycast(rayStart, Vector3.up, Vector3.Distance(rayStart, rayEnd), _ceilingLayerMask);\n    }\n    \n    void UpdateTargetHeight()\n    {\n        switch (_currentStance)\n        {\n            case MovementStance.Standing:\n                _targetHeight = _standingHeight;\n                break;\n            case MovementStance.Crouching:\n                _targetHeight = _crouchHeight;\n                break;\n            case MovementStance.Crawling:\n                _targetHeight = _crawlHeight;\n                break;\n        }\n    }\n    \n    void HandleStanceTransition()\n    {\n        if (Mathf.Abs(_characterController.height - _targetHeight) > 0.01f)\n        {\n            float newHeight = Mathf.Lerp(_characterController.height, _targetHeight, Time.deltaTime * _stanceTransitionSpeed);\n            \n            Vector3 centerOffset = Vector3.up * (newHeight - _characterController.height) * 0.5f;\n            _characterController.height = newHeight;\n            _characterController.center = Vector3.up * newHeight * 0.5f;\n            \n            transform.position += centerOffset;\n        }\n    }\n    \n    void HandleMovement()\n    {\n        _isGrounded = CheckGrounded();\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 inputDirection = new Vector3(horizontal, 0, vertical).normalized;\n        Vector3 worldDirection = transform.TransformDirection(inputDirection);\n        \n        float targetSpeed = GetCurrentMaxSpeed();\n        if (inputDirection.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, targetSpeed, Time.deltaTime * _acceleration);\n        }\n        else\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0f, Time.deltaTime * _deceleration);\n        }\n        \n        _moveDirection = worldDirection * _currentSpeed;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        \n        Vector3 finalMovement = _moveDirection + Vector3.up * _velocity.y;\n        _characterController.Move(finalMovement * Time.deltaTime);\n    }\n    \n    float GetCurrentMaxSpeed()\n    {\n        switch (_currentStance)\n        {\n            case MovementStance.Standing:\n                return _walkSpeed;\n            case MovementStance.Crouching:\n                return _crouchSpeed;\n            case MovementStance.Crawling:\n                return _crawlSpeed;\n            default:\n                return _walkSpeed;\n        }\n    }\n    \n    bool CheckGrounded()\n    {\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        return Physics.Raycast(rayStart, Vector3.down, _characterController.height * 0.5f + _groundCheckDistance, _groundLayerMask);\n    }\n    \n    void UpdateCameraPosition()\n    {\n        if (_playerCamera != null)\n        {\n            float targetCameraHeight = _targetHeight - 0.1f;\n            _currentCameraHeight = Mathf.Lerp(_currentCameraHeight, targetCameraHeight, Time.deltaTime * _stanceTransitionSpeed);\n            \n            Vector3 cameraPosition = _playerCamera.transform.localPosition;\n            cameraPosition.y = _currentCameraHeight;\n            _playerCamera.transform.localPosition = cameraPosition;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_characterController != null)\n        {\n            Gizmos.color = Color.green;\n            Vector3 groundCheckStart = transform.position + Vector3.up * 0.1f;\n            Vector3 groundCheckEnd = groundCheckStart + Vector3.down * (_characterController.height * 0.5f + _groundCheckDistance);\n            Gizmos.DrawLine(groundCheckStart, groundCheckEnd);\n            \n            Gizmos.color = Color.red;\n            Vector3 ceilingCheckStart = transform.position + Vector3.up * _characterController.height * 0.5f;\n            Vector3 ceilingCheckEnd = ceilingCheckStart + Vector3.up * _ceilingCheckDistance;\n            Gizmos.DrawLine(ceilingCheckStart, ceilingCheckEnd);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "ledge grab and climb up",
      "ideal_ir": {
        "class_name": "LedgeGrabClimb",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "grabRange",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "climbSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "grabHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "isGrabbing",
            "type": "bool",
            "default": false
          },
          {
            "name": "canClimb",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "detect_ledge",
            "trigger": "when player is near a ledge and moving upward",
            "actions": [
              {
                "action": "check for ledge within grab range above player"
              },
              {
                "action": "verify ledge is at appropriate height for grabbing"
              }
            ]
          },
          {
            "name": "grab_ledge",
            "trigger": "when ledge is detected and grab input is pressed",
            "actions": [
              {
                "action": "snap player position to ledge grab point"
              },
              {
                "action": "disable gravity and movement controls"
              },
              {
                "action": "play ledge grab animation"
              },
              {
                "action": "set grabbing state to true"
              }
            ]
          },
          {
            "name": "hang_on_ledge",
            "trigger": "when player is grabbing ledge",
            "actions": [
              {
                "action": "maintain position at ledge grab point"
              },
              {
                "action": "play hanging idle animation"
              },
              {
                "action": "listen for climb or drop inputs"
              }
            ]
          },
          {
            "name": "climb_up",
            "trigger": "when grabbing ledge and climb input is pressed",
            "actions": [
              {
                "action": "play climb up animation"
              },
              {
                "action": "move player upward and forward onto ledge"
              },
              {
                "action": "restore normal movement controls when climb completes"
              },
              {
                "action": "set grabbing state to false"
              }
            ]
          },
          {
            "name": "drop_from_ledge",
            "trigger": "when grabbing ledge and drop input is pressed",
            "actions": [
              {
                "action": "release ledge grab"
              },
              {
                "action": "restore gravity and movement controls"
              },
              {
                "action": "play falling animation"
              },
              {
                "action": "set grabbing state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LedgeGrabber : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private LayerMask _ledgeLayerMask = 1;\n    [SerializeField] private float _grabDistance = 1.5f;\n    [SerializeField] private float _grabHeight = 0.5f;\n    [SerializeField] private Vector3 _grabOffset = new Vector3(0, 0.5f, 0);\n    \n    [Header(\"Climb Settings\")]\n    [SerializeField] private float _climbDuration = 1.0f;\n    [SerializeField] private AnimationCurve _climbCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private Vector3 _climbEndOffset = new Vector3(0, 1.5f, 0.5f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _climbKey = KeyCode.Space;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.S;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onLedgeGrabbed;\n    [SerializeField] private UnityEvent _onLedgeReleased;\n    [SerializeField] private UnityEvent _onClimbComplete;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _isGrabbingLedge = false;\n    private bool _isClimbing = false;\n    private Transform _currentLedge;\n    private Vector3 _grabPosition;\n    private Vector3 _climbStartPosition;\n    private Vector3 _climbEndPosition;\n    private float _climbTimer = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"LedgeGrabber requires a Rigidbody component!\");\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isClimbing)\n        {\n            HandleClimbing();\n            return;\n        }\n        \n        if (_isGrabbingLedge)\n        {\n            HandleLedgeInput();\n        }\n        else\n        {\n            CheckForLedgeGrab();\n        }\n    }\n    \n    private void CheckForLedgeGrab()\n    {\n        if (_rigidbody == null || _rigidbody.velocity.y > 0) return;\n        \n        Vector3 rayOrigin = transform.position + Vector3.up * _grabHeight;\n        Vector3 rayDirection = transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _grabDistance, _ledgeLayerMask))\n        {\n            Vector3 ledgeTop = hit.point + Vector3.up * 0.1f;\n            Vector3 checkPosition = ledgeTop + rayDirection * 0.2f;\n            \n            if (!Physics.Raycast(checkPosition, Vector3.down, 0.3f, _ledgeLayerMask))\n            {\n                GrabLedge(hit.transform, hit.point);\n            }\n        }\n    }\n    \n    private void GrabLedge(Transform ledge, Vector3 grabPoint)\n    {\n        _currentLedge = ledge;\n        _isGrabbingLedge = true;\n        _grabPosition = grabPoint + _grabOffset;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.useGravity = false;\n            _rigidbody.isKinematic = true;\n        }\n        \n        transform.position = _grabPosition;\n        transform.LookAt(_grabPosition + transform.forward);\n        \n        _onLedgeGrabbed?.Invoke();\n    }\n    \n    private void HandleLedgeInput()\n    {\n        if (Input.GetKeyDown(_climbKey))\n        {\n            StartClimbing();\n        }\n        else if (Input.GetKeyDown(_releaseKey))\n        {\n            ReleaseLedge();\n        }\n    }\n    \n    private void StartClimbing()\n    {\n        if (_isClimbing || _currentLedge == null) return;\n        \n        _isClimbing = true;\n        _climbTimer = 0f;\n        _climbStartPosition = transform.position;\n        _climbEndPosition = _grabPosition + _climbEndOffset;\n        \n        Vector3 ledgeForward = _currentLedge.forward;\n        if (Vector3.Dot(transform.forward, ledgeForward) < 0)\n        {\n            ledgeForward = -ledgeForward;\n        }\n        _climbEndPosition = _grabPosition + Vector3.up * _climbEndOffset.y + ledgeForward * _climbEndOffset.z;\n    }\n    \n    private void HandleClimbing()\n    {\n        _climbTimer += Time.deltaTime;\n        float progress = _climbTimer / _climbDuration;\n        \n        if (progress >= 1f)\n        {\n            CompleteClimb();\n            return;\n        }\n        \n        float curveValue = _climbCurve.Evaluate(progress);\n        Vector3 currentPosition = Vector3.Lerp(_climbStartPosition, _climbEndPosition, curveValue);\n        transform.position = currentPosition;\n    }\n    \n    private void CompleteClimb()\n    {\n        _isClimbing = false;\n        _isGrabbingLedge = false;\n        transform.position = _climbEndPosition;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = true;\n        }\n        \n        _currentLedge = null;\n        _onClimbComplete?.Invoke();\n    }\n    \n    private void ReleaseLedge()\n    {\n        _isGrabbingLedge = false;\n        _isClimbing = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = true;\n        }\n        \n        _currentLedge = null;\n        _onLedgeReleased?.Invoke();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 rayOrigin = transform.position + Vector3.up * _grabHeight;\n        Gizmos.DrawRay(rayOrigin, transform.forward * _grabDistance);\n        \n        if (_isGrabbingLedge)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_grabPosition, 0.2f);\n            \n            if (_isClimbing)\n            {\n                Gizmos.color = Color.blue;\n                Gizmos.DrawWireSphere(_climbEndPosition, 0.2f);\n                Gizmos.DrawLine(_climbStartPosition, _climbEndPosition);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "health bar that updates visually",
      "ideal_ir": {
        "class_name": "HealthBar",
        "components": [
          "Image",
          "Canvas"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "fillImage",
            "type": "Image",
            "default": null
          },
          {
            "name": "backgroundColor",
            "type": "Image",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "update_health_display",
            "trigger": "when current health value changes",
            "actions": [
              {
                "action": "calculate health percentage based on current health and maximum health"
              },
              {
                "action": "adjust fill image width to match health percentage"
              },
              {
                "action": "change fill color to red when health is low"
              },
              {
                "action": "change fill color to yellow when health is medium"
              },
              {
                "action": "change fill color to green when health is high"
              }
            ]
          },
          {
            "name": "smooth_health_transition",
            "trigger": "when health bar needs to update visually",
            "actions": [
              {
                "action": "smoothly animate fill bar to new health percentage"
              },
              {
                "action": "play visual effect when health decreases"
              },
              {
                "action": "flash red briefly when taking damage"
              }
            ]
          },
          {
            "name": "initialize_health_bar",
            "trigger": "when health bar starts",
            "actions": [
              {
                "action": "set fill image to full width"
              },
              {
                "action": "set initial color based on starting health"
              },
              {
                "action": "position health bar in correct screen location"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class HealthBar : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Slider _healthSlider;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _healthyColor = Color.green;\n    [SerializeField] private Color _warningColor = Color.yellow;\n    [SerializeField] private Color _criticalColor = Color.red;\n    [SerializeField] private float _warningThreshold = 0.6f;\n    [SerializeField] private float _criticalThreshold = 0.3f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useSmoothing = true;\n    [SerializeField] private float _smoothSpeed = 5f;\n    [SerializeField] private bool _usePulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnHealthChanged;\n    public UnityEvent OnHealthDepleted;\n    public UnityEvent OnHealthCritical;\n    \n    private float _targetHealth;\n    private bool _isInitialized = false;\n    private float _originalAlpha;\n    \n    void Start()\n    {\n        InitializeHealthBar();\n    }\n    \n    void Update()\n    {\n        if (!_isInitialized) return;\n        \n        UpdateHealthBarVisual();\n        UpdateColorBasedOnHealth();\n        \n        if (_usePulseEffect && GetHealthPercentage() <= _criticalThreshold)\n        {\n            ApplyPulseEffect();\n        }\n    }\n    \n    private void InitializeHealthBar()\n    {\n        _currentHealth = _maxHealth;\n        _targetHealth = _maxHealth;\n        \n        if (_healthSlider == null)\n            _healthSlider = GetComponent<Slider>();\n            \n        if (_fillImage == null && _healthSlider != null)\n            _fillImage = _healthSlider.fillRect?.GetComponent<Image>();\n            \n        if (_backgroundImage == null && _healthSlider != null)\n            _backgroundImage = _healthSlider.GetComponent<Image>();\n        \n        if (_healthSlider != null)\n        {\n            _healthSlider.maxValue = _maxHealth;\n            _healthSlider.value = _currentHealth;\n        }\n        \n        if (_fillImage != null)\n        {\n            _originalAlpha = _fillImage.color.a;\n        }\n        \n        _isInitialized = true;\n    }\n    \n    private void UpdateHealthBarVisual()\n    {\n        if (_healthSlider == null) return;\n        \n        if (_useSmoothing)\n        {\n            _healthSlider.value = Mathf.Lerp(_healthSlider.value, _targetHealth, Time.deltaTime * _smoothSpeed);\n        }\n        else\n        {\n            _healthSlider.value = _targetHealth;\n        }\n    }\n    \n    private void UpdateColorBasedOnHealth()\n    {\n        if (_fillImage == null) return;\n        \n        float healthPercentage = GetHealthPercentage();\n        Color targetColor;\n        \n        if (healthPercentage > _warningThreshold)\n        {\n            targetColor = _healthyColor;\n        }\n        else if (healthPercentage > _criticalThreshold)\n        {\n            targetColor = _warningColor;\n        }\n        else\n        {\n            targetColor = _criticalColor;\n        }\n        \n        _fillImage.color = targetColor;\n    }\n    \n    private void ApplyPulseEffect()\n    {\n        if (_fillImage == null) return;\n        \n        float pulse = Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n        float alpha = _originalAlpha + pulse;\n        alpha = Mathf.Clamp01(alpha);\n        \n        Color currentColor = _fillImage.color;\n        currentColor.a = alpha;\n        _fillImage.color = currentColor;\n    }\n    \n    public void SetMaxHealth(float maxHealth)\n    {\n        _maxHealth = Mathf.Max(1f, maxHealth);\n        _currentHealth = Mathf.Min(_currentHealth, _maxHealth);\n        _targetHealth = _currentHealth;\n        \n        if (_healthSlider != null)\n        {\n            _healthSlider.maxValue = _maxHealth;\n        }\n        \n        OnHealthChanged?.Invoke();\n    }\n    \n    public void SetHealth(float health)\n    {\n        float previousHealth = _currentHealth;\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        _targetHealth = _currentHealth;\n        \n        if (previousHealth != _currentHealth)\n        {\n            OnHealthChanged?.Invoke();\n            \n            if (_currentHealth <= 0f && previousHealth > 0f)\n            {\n                OnHealthDepleted?.Invoke();\n            }\n            else if (_currentHealth <= _maxHealth * _criticalThreshold && previousHealth > _maxHealth * _criticalThreshold)\n            {\n                OnHealthCritical?.Invoke();\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        SetHealth(_currentHealth - damage);\n    }\n    \n    public void Heal(float healAmount)\n    {\n        SetHealth(_currentHealth + healAmount);\n    }\n    \n    public void RestoreToFull()\n    {\n        SetHealth(_maxHealth);\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _maxHealth > 0 ? _currentHealth / _maxHealth : 0f;\n    }\n    \n    public bool IsHealthFull()\n    {\n        return _currentHealth >= _maxHealth;\n    }\n    \n    public bool IsHealthEmpty()\n    {\n        return _currentHealth <= 0f;\n    }\n    \n    public bool IsHealthCritical()\n    {\n        return GetHealthPercentage() <= _criticalThreshold;\n    }\n    \n    void OnValidate()\n    {\n        _maxHealth = Mathf.Max(1f, _maxHealth);\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _warningThreshold = Mathf.Clamp01(_warningThreshold);\n        _criticalThreshold = Mathf.Clamp01(_criticalThreshold);\n        _smoothSpeed = Mathf.Max(0.1f, _smoothSpeed);\n        _pulseSpeed = Mathf.Max(0.1f, _pulseSpeed);\n        _pulseIntensity = Mathf.Clamp01(_pulseIntensity);\n        \n        if (_criticalThreshold > _warningThreshold)\n        {\n            _criticalThreshold = _warningThreshold;\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "damage numbers that float up",
      "ideal_ir": {
        "class_name": "DamageNumber",
        "components": [
          "TextMeshPro"
        ],
        "fields": [
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "lifetime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "initialize_damage_text",
            "trigger": "when damage number is created",
            "actions": [
              {
                "action": "set text to display damage amount"
              },
              {
                "action": "set text color to red for damage"
              },
              {
                "action": "start floating upward movement"
              }
            ]
          },
          {
            "name": "float_upward",
            "trigger": "every frame while active",
            "actions": [
              {
                "action": "move upward at float speed"
              },
              {
                "action": "gradually fade out text opacity"
              },
              {
                "action": "reduce remaining lifetime"
              }
            ]
          },
          {
            "name": "destroy_when_expired",
            "trigger": "when lifetime reaches zero",
            "actions": [
              {
                "action": "destroy this damage number object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\npublic class DamageNumber : MonoBehaviour\n{\n    [Header(\"Damage Display\")]\n    [SerializeField] private TextMeshProUGUI _damageText;\n    [SerializeField] private float _damage;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _fadeSpeed = 1f;\n    [SerializeField] private float _lifetime = 2f;\n    [SerializeField] private Vector3 _floatDirection = Vector3.up;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 1f);\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _criticalColor = Color.red;\n    [SerializeField] private Color _healColor = Color.green;\n    [SerializeField] private float _criticalThreshold = 50f;\n    [SerializeField] private bool _randomizeDirection = true;\n    [SerializeField] private float _randomAngle = 30f;\n    \n    private Vector3 _startPosition;\n    private float _timer;\n    private CanvasGroup _canvasGroup;\n    private RectTransform _rectTransform;\n    private bool _isInitialized;\n    \n    public enum DamageType\n    {\n        Normal,\n        Critical,\n        Heal\n    }\n    \n    private void Awake()\n    {\n        _rectTransform = GetComponent<RectTransform>();\n        _canvasGroup = GetComponent<CanvasGroup>();\n        \n        if (_canvasGroup == null)\n        {\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n        }\n        \n        if (_damageText == null)\n        {\n            _damageText = GetComponent<TextMeshProUGUI>();\n            if (_damageText == null)\n            {\n                _damageText = GetComponentInChildren<TextMeshProUGUI>();\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        if (!_isInitialized)\n        {\n            Initialize(10f, DamageType.Normal);\n        }\n    }\n    \n    public void Initialize(float damage, DamageType damageType = DamageType.Normal)\n    {\n        _damage = damage;\n        _startPosition = transform.position;\n        _timer = 0f;\n        _isInitialized = true;\n        \n        SetupText(damageType);\n        SetupDirection();\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = 1f;\n        }\n        \n        transform.localScale = Vector3.zero;\n    }\n    \n    private void SetupText(DamageType damageType)\n    {\n        if (_damageText == null) return;\n        \n        string displayText = Mathf.Abs(_damage).ToString(\"F0\");\n        Color textColor = _normalColor;\n        \n        switch (damageType)\n        {\n            case DamageType.Critical:\n                displayText = \"CRIT! \" + displayText;\n                textColor = _criticalColor;\n                break;\n            case DamageType.Heal:\n                displayText = \"+\" + displayText;\n                textColor = _healColor;\n                break;\n            case DamageType.Normal:\n                if (_damage >= _criticalThreshold)\n                {\n                    textColor = _criticalColor;\n                }\n                break;\n        }\n        \n        _damageText.text = displayText;\n        _damageText.color = textColor;\n    }\n    \n    private void SetupDirection()\n    {\n        if (_randomizeDirection)\n        {\n            float randomX = Random.Range(-_randomAngle, _randomAngle);\n            float randomY = Random.Range(-_randomAngle * 0.5f, _randomAngle);\n            \n            Vector3 randomDirection = Quaternion.Euler(0, 0, randomX) * _floatDirection;\n            randomDirection.y += randomY * 0.01f;\n            _floatDirection = randomDirection.normalized;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        _timer += Time.deltaTime;\n        float normalizedTime = _timer / _lifetime;\n        \n        if (normalizedTime >= 1f)\n        {\n            DestroyDamageNumber();\n            return;\n        }\n        \n        UpdatePosition(normalizedTime);\n        UpdateScale(normalizedTime);\n        UpdateAlpha(normalizedTime);\n    }\n    \n    private void UpdatePosition(float normalizedTime)\n    {\n        float movementProgress = _movementCurve.Evaluate(normalizedTime);\n        Vector3 offset = _floatDirection * (_floatSpeed * movementProgress * _timer);\n        transform.position = _startPosition + offset;\n    }\n    \n    private void UpdateScale(float normalizedTime)\n    {\n        float scaleValue = _scaleCurve.Evaluate(normalizedTime);\n        transform.localScale = Vector3.one * scaleValue;\n    }\n    \n    private void UpdateAlpha(float normalizedTime)\n    {\n        if (_canvasGroup == null) return;\n        \n        float alpha = 1f - (normalizedTime * _fadeSpeed);\n        alpha = Mathf.Clamp01(alpha);\n        _canvasGroup.alpha = alpha;\n    }\n    \n    private void DestroyDamageNumber()\n    {\n        if (gameObject != null)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public static DamageNumber Create(Vector3 worldPosition, float damage, DamageType damageType = DamageType.Normal, Transform parent = null)\n    {\n        GameObject damageNumberPrefab = Resources.Load<GameObject>(\"DamageNumber\");\n        \n        if (damageNumberPrefab == null)\n        {\n            GameObject newObj = new GameObject(\"DamageNumber\");\n            Canvas canvas = FindObjectOfType<Canvas>();\n            if (canvas != null)\n            {\n                newObj.transform.SetParent(canvas.transform, false);\n            }\n            \n            TextMeshProUGUI text = newObj.AddComponent<TextMeshProUGUI>();\n            text.text = \"0\";\n            text.fontSize = 24;\n            text.alignment = TextAlignmentOptions.Center;\n            \n            DamageNumber damageNumber = newObj.AddComponent<DamageNumber>();\n            damageNumber._damageText = text;\n            \n            RectTransform rect = newObj.GetComponent<RectTransform>();\n            rect.sizeDelta = new Vector2(100, 50);\n            \n            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPosition);\n            rect.position = screenPos;\n            \n            damageNumber.Initialize(damage, damageType);\n            return damageNumber;\n        }\n        else\n        {\n            GameObject instance = Instantiate(damageNumberPrefab, parent);\n            instance.transform.position = worldPosition;\n            \n            DamageNumber damageNumber = instance.GetComponent<DamageNumber>();\n            if (damageNumber != null)\n            {\n                damageNumber.Initialize(damage, damageType);\n            }\n            \n            return damageNumber;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "minimap marker for objectives",
      "ideal_ir": {
        "class_name": "MinimapObjectiveMarker",
        "components": [
          "Transform",
          "SpriteRenderer",
          "Canvas",
          "Image"
        ],
        "fields": [
          {
            "name": "markerIcon",
            "type": "Sprite",
            "default": null
          },
          {
            "name": "markerColor",
            "type": "Color",
            "default": "yellow"
          },
          {
            "name": "markerSize",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "blinkSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "showDistance",
            "type": "bool",
            "default": true
          },
          {
            "name": "maxVisibleDistance",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "objectiveTarget",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isCompleted",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "track_objective_position",
            "trigger": "every frame while objective exists",
            "actions": [
              {
                "action": "update marker position to match objective location on minimap"
              }
            ]
          },
          {
            "name": "show_marker_when_in_range",
            "trigger": "when objective is within maximum visible distance",
            "actions": [
              {
                "action": "make marker visible on minimap"
              }
            ]
          },
          {
            "name": "hide_marker_when_far",
            "trigger": "when objective is beyond maximum visible distance",
            "actions": [
              {
                "action": "hide marker from minimap"
              }
            ]
          },
          {
            "name": "blink_active_marker",
            "trigger": "when objective is active and not completed",
            "actions": [
              {
                "action": "make marker blink at specified speed to draw attention"
              }
            ]
          },
          {
            "name": "change_completed_appearance",
            "trigger": "when objective is marked as completed",
            "actions": [
              {
                "action": "change marker color to green"
              },
              {
                "action": "stop blinking animation"
              },
              {
                "action": "reduce marker opacity"
              }
            ]
          },
          {
            "name": "scale_with_distance",
            "trigger": "when player distance to objective changes",
            "actions": [
              {
                "action": "adjust marker size based on distance to objective"
              }
            ]
          },
          {
            "name": "remove_completed_marker",
            "trigger": "when objective has been completed for specified duration",
            "actions": [
              {
                "action": "fade out marker"
              },
              {
                "action": "remove marker from minimap"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class MinimapObjectiveMarker : MonoBehaviour\n{\n    [Header(\"Marker Settings\")]\n    [SerializeField] private GameObject _markerPrefab;\n    [SerializeField] private Transform _minimapCanvas;\n    [SerializeField] private Camera _minimapCamera;\n    [SerializeField] private RectTransform _minimapRect;\n    \n    [Header(\"Marker Appearance\")]\n    [SerializeField] private Color _activeColor = Color.yellow;\n    [SerializeField] private Color _completedColor = Color.green;\n    [SerializeField] private Color _failedColor = Color.red;\n    [SerializeField] private float _markerSize = 20f;\n    [SerializeField] private bool _showDistance = true;\n    \n    [Header(\"Objective Settings\")]\n    [SerializeField] private string _objectiveTitle = \"Objective\";\n    [SerializeField] private string _objectiveDescription = \"Complete this objective\";\n    [SerializeField] private bool _isCompleted = false;\n    [SerializeField] private bool _isFailed = false;\n    [SerializeField] private float _completionRadius = 5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _pulseAnimation = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseScale = 1.2f;\n    \n    private GameObject _markerInstance;\n    private Image _markerImage;\n    private Text _distanceText;\n    private Transform _player;\n    private RectTransform _markerRect;\n    private Vector3 _originalScale;\n    private bool _isVisible = true;\n    \n    public enum ObjectiveState\n    {\n        Active,\n        Completed,\n        Failed,\n        Hidden\n    }\n    \n    private ObjectiveState _currentState = ObjectiveState.Active;\n    \n    void Start()\n    {\n        InitializeMarker();\n        FindPlayer();\n        SetupMarkerAppearance();\n    }\n    \n    void Update()\n    {\n        if (_markerInstance == null || _player == null) return;\n        \n        UpdateMarkerPosition();\n        UpdateMarkerVisibility();\n        UpdateDistanceDisplay();\n        UpdateObjectiveCompletion();\n        \n        if (_pulseAnimation && _currentState == ObjectiveState.Active)\n        {\n            AnimateMarker();\n        }\n    }\n    \n    private void InitializeMarker()\n    {\n        if (_minimapCanvas == null)\n        {\n            _minimapCanvas = FindObjectOfType<Canvas>()?.transform;\n        }\n        \n        if (_minimapCamera == null)\n        {\n            _minimapCamera = Camera.main;\n        }\n        \n        if (_minimapRect == null)\n        {\n            _minimapRect = _minimapCanvas?.GetComponent<RectTransform>();\n        }\n        \n        CreateMarkerInstance();\n    }\n    \n    private void CreateMarkerInstance()\n    {\n        if (_minimapCanvas == null) return;\n        \n        if (_markerPrefab != null)\n        {\n            _markerInstance = Instantiate(_markerPrefab, _minimapCanvas);\n        }\n        else\n        {\n            _markerInstance = new GameObject(\"ObjectiveMarker\");\n            _markerInstance.transform.SetParent(_minimapCanvas);\n            \n            _markerImage = _markerInstance.AddComponent<Image>();\n            _markerImage.sprite = CreateCircleSprite();\n        }\n        \n        _markerRect = _markerInstance.GetComponent<RectTransform>();\n        if (_markerRect == null)\n        {\n            _markerRect = _markerInstance.AddComponent<RectTransform>();\n        }\n        \n        _markerRect.sizeDelta = Vector2.one * _markerSize;\n        _originalScale = _markerRect.localScale;\n        \n        if (_markerImage == null)\n        {\n            _markerImage = _markerInstance.GetComponent<Image>();\n        }\n        \n        SetupDistanceText();\n    }\n    \n    private void SetupDistanceText()\n    {\n        if (!_showDistance) return;\n        \n        GameObject textObj = new GameObject(\"DistanceText\");\n        textObj.transform.SetParent(_markerInstance.transform);\n        \n        _distanceText = textObj.AddComponent<Text>();\n        _distanceText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        _distanceText.fontSize = 12;\n        _distanceText.color = Color.white;\n        _distanceText.alignment = TextAnchor.MiddleCenter;\n        \n        RectTransform textRect = textObj.GetComponent<RectTransform>();\n        textRect.anchoredPosition = Vector2.zero;\n        textRect.sizeDelta = new Vector2(50, 20);\n        textRect.anchoredPosition = new Vector2(0, -25);\n    }\n    \n    private Sprite CreateCircleSprite()\n    {\n        Texture2D texture = new Texture2D(32, 32);\n        Color[] pixels = new Color[32 * 32];\n        Vector2 center = new Vector2(16, 16);\n        \n        for (int y = 0; y < 32; y++)\n        {\n            for (int x = 0; x < 32; x++)\n            {\n                float distance = Vector2.Distance(new Vector2(x, y), center);\n                pixels[y * 32 + x] = distance <= 15 ? Color.white : Color.clear;\n            }\n        }\n        \n        texture.SetPixels(pixels);\n        texture.Apply();\n        \n        return Sprite.Create(texture, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f));\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n    \n    private void SetupMarkerAppearance()\n    {\n        if (_markerImage == null) return;\n        \n        switch (_currentState)\n        {\n            case ObjectiveState.Active:\n                _markerImage.color = _activeColor;\n                break;\n            case ObjectiveState.Completed:\n                _markerImage.color = _completedColor;\n                break;\n            case ObjectiveState.Failed:\n                _markerImage.color = _failedColor;\n                break;\n            case ObjectiveState.Hidden:\n                _markerInstance.SetActive(false);\n                break;\n        }\n    }\n    \n    private void UpdateMarkerPosition()\n    {\n        if (_minimapCamera == null || _minimapRect == null) return;\n        \n        Vector3 worldPos = transform.position;\n        Vector3 screenPos = _minimapCamera.WorldToScreenPoint(worldPos);\n        \n        Vector2 localPos;\n        RectTransformUtility.ScreenPointToLocalPointInRectangle(\n            _minimapRect, screenPos, null, out localPos);\n        \n        _markerRect.anchoredPosition = localPos;\n    }\n    \n    private void UpdateMarkerVisibility()\n    {\n        if (_markerInstance == null) return;\n        \n        bool shouldBeVisible = _currentState != ObjectiveState.Hidden && _isVisible;\n        _markerInstance.SetActive(shouldBeVisible);\n    }\n    \n    private void UpdateDistanceDisplay()\n    {\n        if (_distanceText == null || _player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        _distanceText.text = $\"{distance:F0}m\";\n    }\n    \n    private void UpdateObjectiveCompletion()\n    {\n        if (_player == null || _currentState != ObjectiveState.Active) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _completionRadius && !_isCompleted)\n        {\n            CompleteObjective();\n        }\n    }\n    \n    private void AnimateMarker()\n    {\n        if (_markerRect == null) return;\n        \n        float scale = 1f + Mathf.Sin(Time.time * _pulseSpeed) * (_pulseScale - 1f) * 0.5f;\n        _markerRect.localScale = _originalScale * scale;\n    }\n    \n    public void SetObjectiveState(ObjectiveState state)\n    {\n        _currentState = state;\n        \n        switch (state)\n        {\n            case ObjectiveState.Completed:\n                _isCompleted = true;\n                break;\n            case ObjectiveState.Failed:\n                _isFailed = true;\n                break;\n        }\n        \n        SetupMarkerAppearance();\n    }\n    \n    public void CompleteObjective()\n    {\n        SetObjectiveState(ObjectiveState.Completed);\n        \n        if (_pulseAnimation)\n        {\n            _markerRect.localScale = _originalScale;\n        }\n    }\n    \n    public void FailObjective()\n    {\n        SetObjectiveState(ObjectiveState.Failed);\n        \n        if (_pulseAnimation)\n        {\n            _markerRect.localScale = _originalScale;\n        }\n    }\n    \n    public void ShowMarker()\n    {\n        _isVisible = true;\n        if (_currentState != ObjectiveState.Hidden)\n        {\n            _markerInstance?.SetActive(true);\n        }\n    }\n    \n    public void HideMarker()\n    {\n        _isVisible = false;\n        _markerInstance?.SetActive(false);\n    }\n    \n    public void SetMarkerColor(Color color)\n    {\n        if (_markerImage != null)\n        {\n            _markerImage.color = color;\n        }\n    }\n    \n    public void SetObjectiveTitle(string title)\n    {\n        _objectiveTitle = title;\n    }\n    \n    public void SetObjectiveDescription(string description)\n    {\n        _objectiveDescription = description;\n    }\n    \n    public string GetObjectiveTitle()\n    {\n        return _objectiveTitle;\n    }\n    \n    public string GetObjectiveDescription()\n    {\n        return _objectiveDescription;\n    }\n    \n    public ObjectiveState GetCurrentState()\n    {\n        return _currentState;\n    }\n    \n    public bool IsCompleted()\n    {\n        return _isCompleted;\n    }\n    \n    public bool IsFailed()\n    {\n        return _isFailed;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _completionRadius);\n    }\n    \n    void OnDestroy()\n    {\n        if (_markerInstance != null)\n        {\n            DestroyImmediate(_markerInstance);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "compass pointing to target",
      "ideal_ir": {
        "class_name": "CompassPointer",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "target",
            "type": "Transform",
            "default": null
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "point_to_target",
            "trigger": "every frame when target exists",
            "actions": [
              {
                "action": "calculate direction from compass to target"
              },
              {
                "action": "smoothly rotate compass to face target direction"
              },
              {
                "action": "maintain upright orientation while pointing"
              }
            ]
          },
          {
            "name": "stop_pointing",
            "trigger": "when target becomes null or destroyed",
            "actions": [
              {
                "action": "stop rotation movement"
              },
              {
                "action": "maintain current orientation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class Compass : MonoBehaviour\n{\n    [Header(\"Compass Settings\")]\n    [SerializeField] private Transform _compassNeedle;\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _useClosestPlayerAsTarget = true;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _smoothRotation = true;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private float _rotationOffset = 0f;\n    \n    [Header(\"Distance Settings\")]\n    [SerializeField] private bool _hideWhenClose = false;\n    [SerializeField] private float _hideDistance = 5f;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    [SerializeField] private GameObject _compassObject;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugLine = false;\n    [SerializeField] private Color _debugLineColor = Color.red;\n    \n    private Camera _playerCamera;\n    private Vector3 _lastKnownTargetPosition;\n    private bool _hasTarget;\n    \n    private void Start()\n    {\n        InitializeCompass();\n        FindTarget();\n    }\n    \n    private void Update()\n    {\n        if (_useClosestPlayerAsTarget && (_target == null || !_target.gameObject.activeInHierarchy))\n        {\n            FindTarget();\n        }\n        \n        if (_target != null && _target.gameObject.activeInHierarchy)\n        {\n            _lastKnownTargetPosition = _target.position;\n            _hasTarget = true;\n        }\n        \n        if (_hasTarget)\n        {\n            UpdateCompassRotation();\n            UpdateVisibility();\n        }\n        else\n        {\n            HideCompass();\n        }\n    }\n    \n    private void InitializeCompass()\n    {\n        if (_compassNeedle == null)\n            _compassNeedle = transform;\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_compassObject == null)\n            _compassObject = gameObject;\n    }\n    \n    private void FindTarget()\n    {\n        if (_useClosestPlayerAsTarget)\n        {\n            GameObject[] targets = GameObject.FindGameObjectsWithTag(_targetTag);\n            float closestDistance = Mathf.Infinity;\n            Transform closestTarget = null;\n            \n            foreach (GameObject targetObj in targets)\n            {\n                if (targetObj.activeInHierarchy)\n                {\n                    float distance = Vector3.Distance(transform.position, targetObj.transform.position);\n                    if (distance < closestDistance)\n                    {\n                        closestDistance = distance;\n                        closestTarget = targetObj.transform;\n                    }\n                }\n            }\n            \n            _target = closestTarget;\n        }\n    }\n    \n    private void UpdateCompassRotation()\n    {\n        Vector3 directionToTarget = (_lastKnownTargetPosition - transform.position).normalized;\n        \n        if (_playerCamera != null)\n        {\n            Vector3 cameraForward = _playerCamera.transform.forward;\n            cameraForward.y = 0;\n            cameraForward.Normalize();\n            \n            directionToTarget.y = 0;\n            directionToTarget.Normalize();\n            \n            float angle = Vector3.SignedAngle(cameraForward, directionToTarget, Vector3.up);\n            angle += _rotationOffset;\n            \n            Quaternion targetRotation = Quaternion.AngleAxis(angle, _rotationAxis);\n            \n            if (_smoothRotation)\n            {\n                _compassNeedle.rotation = Quaternion.Lerp(_compassNeedle.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _compassNeedle.rotation = targetRotation;\n            }\n        }\n        else\n        {\n            float angle = Mathf.Atan2(directionToTarget.x, directionToTarget.z) * Mathf.Rad2Deg;\n            angle += _rotationOffset;\n            \n            Quaternion targetRotation = Quaternion.AngleAxis(angle, _rotationAxis);\n            \n            if (_smoothRotation)\n            {\n                _compassNeedle.rotation = Quaternion.Lerp(_compassNeedle.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _compassNeedle.rotation = targetRotation;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_hideWhenClose)\n        {\n            float distance = Vector3.Distance(transform.position, _lastKnownTargetPosition);\n            bool shouldShow = distance > _hideDistance;\n            \n            if (_canvasGroup != null)\n            {\n                float targetAlpha = shouldShow ? 1f : 0f;\n                _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, targetAlpha, _rotationSpeed * Time.deltaTime);\n            }\n            else if (_compassObject != null)\n            {\n                _compassObject.SetActive(shouldShow);\n            }\n        }\n        else\n        {\n            ShowCompass();\n        }\n    }\n    \n    private void ShowCompass()\n    {\n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, 1f, _rotationSpeed * Time.deltaTime);\n        }\n        else if (_compassObject != null)\n        {\n            _compassObject.SetActive(true);\n        }\n    }\n    \n    private void HideCompass()\n    {\n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, 0f, _rotationSpeed * Time.deltaTime);\n        }\n        else if (_compassObject != null)\n        {\n            _compassObject.SetActive(false);\n        }\n    }\n    \n    public void SetTarget(Transform newTarget)\n    {\n        _target = newTarget;\n        _useClosestPlayerAsTarget = false;\n        _hasTarget = _target != null;\n    }\n    \n    public void SetTargetPosition(Vector3 position)\n    {\n        _lastKnownTargetPosition = position;\n        _target = null;\n        _useClosestPlayerAsTarget = false;\n        _hasTarget = true;\n    }\n    \n    public void ClearTarget()\n    {\n        _target = null;\n        _hasTarget = false;\n        _useClosestPlayerAsTarget = false;\n    }\n    \n    public float GetDistanceToTarget()\n    {\n        if (_hasTarget)\n        {\n            return Vector3.Distance(transform.position, _lastKnownTargetPosition);\n        }\n        return -1f;\n    }\n    \n    public Vector3 GetDirectionToTarget()\n    {\n        if (_hasTarget)\n        {\n            return (_lastKnownTargetPosition - transform.position).normalized;\n        }\n        return Vector3.zero;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_showDebugLine && _hasTarget)\n        {\n            Gizmos.color = _debugLineColor;\n            Gizmos.DrawLine(transform.position, _lastKnownTargetPosition);\n            Gizmos.DrawWireSphere(_lastKnownTargetPosition, 1f);\n            \n            if (_hideWhenClose)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawWireSphere(transform.position, _hideDistance);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "screen shake on impact",
      "ideal_ir": {
        "class_name": "ScreenShakeOnImpact",
        "components": [
          "Camera"
        ],
        "fields": [
          {
            "name": "shakeIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "shakeDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "shakeFrequency",
            "type": "float",
            "default": 20.0
          }
        ],
        "behaviors": [
          {
            "name": "trigger_screen_shake",
            "trigger": "when collision occurs with any object",
            "actions": [
              {
                "action": "start camera shake with specified intensity and duration"
              },
              {
                "action": "apply random displacement to camera position based on shake frequency"
              }
            ]
          },
          {
            "name": "update_shake_effect",
            "trigger": "while screen shake is active",
            "actions": [
              {
                "action": "generate random offset values for camera position"
              },
              {
                "action": "gradually reduce shake intensity over time"
              },
              {
                "action": "apply shake offset to camera transform"
              }
            ]
          },
          {
            "name": "end_screen_shake",
            "trigger": "when shake duration has elapsed",
            "actions": [
              {
                "action": "stop applying shake effects"
              },
              {
                "action": "return camera to original position"
              },
              {
                "action": "reset shake parameters"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class ScreenShake : MonoBehaviour\n{\n    [Header(\"Shake Settings\")]\n    [SerializeField] private float _shakeDuration = 0.5f;\n    [SerializeField] private float _shakeIntensity = 1.0f;\n    [SerializeField] private AnimationCurve _shakeCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Impact Detection\")]\n    [SerializeField] private bool _shakeOnCollision = true;\n    [SerializeField] private bool _shakeOnTrigger = false;\n    [SerializeField] private string[] _impactTags = { \"Player\", \"Enemy\", \"Projectile\" };\n    [SerializeField] private float _minimumImpactForce = 5.0f;\n    \n    [Header(\"Manual Shake\")]\n    [SerializeField] private KeyCode _testShakeKey = KeyCode.Space;\n    \n    private Vector3 _originalPosition;\n    private bool _isShaking = false;\n    private Camera _camera;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n            _camera = Camera.main;\n            \n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_camera != null)\n            _originalPosition = _camera.transform.localPosition;\n        else\n            _originalPosition = transform.localPosition;\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_testShakeKey))\n        {\n            TriggerShake(_shakeIntensity, _shakeDuration);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_shakeOnCollision) return;\n        \n        if (ShouldShakeFromImpact(collision.gameObject, collision.relativeVelocity.magnitude))\n        {\n            float intensity = Mathf.Clamp(collision.relativeVelocity.magnitude / 10f, 0.1f, _shakeIntensity);\n            TriggerShake(intensity, _shakeDuration);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_shakeOnTrigger) return;\n        \n        float impactForce = _minimumImpactForce;\n        Rigidbody otherRb = other.GetComponent<Rigidbody>();\n        if (otherRb != null)\n            impactForce = otherRb.velocity.magnitude;\n            \n        if (ShouldShakeFromImpact(other.gameObject, impactForce))\n        {\n            float intensity = Mathf.Clamp(impactForce / 10f, 0.1f, _shakeIntensity);\n            TriggerShake(intensity, _shakeDuration);\n        }\n    }\n    \n    private bool ShouldShakeFromImpact(GameObject impactObject, float force)\n    {\n        if (force < _minimumImpactForce) return false;\n        \n        if (_impactTags.Length == 0) return true;\n        \n        foreach (string tag in _impactTags)\n        {\n            if (impactObject.CompareTag(tag))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    public void TriggerShake(float intensity, float duration)\n    {\n        if (_isShaking) return;\n        \n        StartCoroutine(ShakeCoroutine(intensity, duration));\n    }\n    \n    public void TriggerShake()\n    {\n        TriggerShake(_shakeIntensity, _shakeDuration);\n    }\n    \n    private IEnumerator ShakeCoroutine(float intensity, float duration)\n    {\n        _isShaking = true;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float progress = elapsed / duration;\n            float currentIntensity = intensity * _shakeCurve.Evaluate(progress);\n            \n            Vector3 randomOffset = new Vector3(\n                Random.Range(-1f, 1f),\n                Random.Range(-1f, 1f),\n                0f\n            ) * currentIntensity;\n            \n            if (_camera != null)\n                _camera.transform.localPosition = _originalPosition + randomOffset;\n            else\n                transform.localPosition = _originalPosition + randomOffset;\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        if (_camera != null)\n            _camera.transform.localPosition = _originalPosition;\n        else\n            transform.localPosition = _originalPosition;\n            \n        _isShaking = false;\n    }\n    \n    private void OnDisable()\n    {\n        StopAllCoroutines();\n        \n        if (_camera != null)\n            _camera.transform.localPosition = _originalPosition;\n        else\n            transform.localPosition = _originalPosition;\n            \n        _isShaking = false;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "hit flash effect on damage",
      "ideal_ir": {
        "class_name": "HitFlashEffect",
        "components": [
          "Renderer"
        ],
        "fields": [
          {
            "name": "flashColor",
            "type": "Color",
            "default": "Color.red"
          },
          {
            "name": "flashDuration",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "originalColor",
            "type": "Color",
            "default": "Color.white"
          },
          {
            "name": "isFlashing",
            "type": "bool",
            "default": false
          },
          {
            "name": "flashTimer",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "trigger_flash_on_damage",
            "trigger": "when this object takes damage",
            "actions": [
              {
                "action": "change renderer material color to flash color"
              },
              {
                "action": "set flashing state to true"
              },
              {
                "action": "reset flash timer to zero"
              }
            ]
          },
          {
            "name": "update_flash_effect",
            "trigger": "every frame while flashing",
            "actions": [
              {
                "action": "increase flash timer by frame time"
              },
              {
                "action": "if flash timer exceeds flash duration then stop flashing and restore original color"
              }
            ]
          },
          {
            "name": "store_original_color",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "save the current material color as original color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class HitFlashEffect : MonoBehaviour\n{\n    [Header(\"Flash Settings\")]\n    [SerializeField] private Color _flashColor = Color.red;\n    [SerializeField] private float _flashDuration = 0.1f;\n    [SerializeField] private int _flashCount = 1;\n    [SerializeField] private float _flashInterval = 0.05f;\n    \n    [Header(\"Component References\")]\n    [SerializeField] private Renderer _targetRenderer;\n    [SerializeField] private SpriteRenderer _spriteRenderer;\n    \n    private Material _originalMaterial;\n    private Color _originalColor;\n    private bool _isFlashing = false;\n    private Coroutine _flashCoroutine;\n    \n    private void Start()\n    {\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n            \n        if (_spriteRenderer == null)\n            _spriteRenderer = GetComponent<SpriteRenderer>();\n            \n        if (_targetRenderer != null)\n        {\n            _originalMaterial = _targetRenderer.material;\n        }\n        \n        if (_spriteRenderer != null)\n        {\n            _originalColor = _spriteRenderer.color;\n        }\n    }\n    \n    public void TriggerFlash()\n    {\n        if (_isFlashing)\n        {\n            StopFlash();\n        }\n        \n        _flashCoroutine = StartCoroutine(FlashRoutine());\n    }\n    \n    public void TriggerFlash(Color flashColor)\n    {\n        _flashColor = flashColor;\n        TriggerFlash();\n    }\n    \n    public void TriggerFlash(float duration)\n    {\n        _flashDuration = duration;\n        TriggerFlash();\n    }\n    \n    public void TriggerFlash(Color flashColor, float duration)\n    {\n        _flashColor = flashColor;\n        _flashDuration = duration;\n        TriggerFlash();\n    }\n    \n    public void StopFlash()\n    {\n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n            _flashCoroutine = null;\n        }\n        \n        _isFlashing = false;\n        RestoreOriginalAppearance();\n    }\n    \n    private IEnumerator FlashRoutine()\n    {\n        _isFlashing = true;\n        \n        for (int i = 0; i < _flashCount; i++)\n        {\n            ApplyFlashEffect();\n            yield return new WaitForSeconds(_flashDuration);\n            \n            RestoreOriginalAppearance();\n            \n            if (i < _flashCount - 1)\n            {\n                yield return new WaitForSeconds(_flashInterval);\n            }\n        }\n        \n        _isFlashing = false;\n        _flashCoroutine = null;\n    }\n    \n    private void ApplyFlashEffect()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = _flashColor;\n        }\n        else if (_targetRenderer != null)\n        {\n            _targetRenderer.material.color = _flashColor;\n        }\n    }\n    \n    private void RestoreOriginalAppearance()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = _originalColor;\n        }\n        else if (_targetRenderer != null && _originalMaterial != null)\n        {\n            _targetRenderer.material.color = _originalMaterial.color;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_flashDuration < 0.01f)\n            _flashDuration = 0.01f;\n            \n        if (_flashCount < 1)\n            _flashCount = 1;\n            \n        if (_flashInterval < 0f)\n            _flashInterval = 0f;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "crosshair that changes on hover",
      "ideal_ir": {
        "class_name": "HoverCrosshair",
        "components": [
          "Image"
        ],
        "fields": [
          {
            "name": "normalSprite",
            "type": "Sprite",
            "default": null
          },
          {
            "name": "hoverSprite",
            "type": "Sprite",
            "default": null
          },
          {
            "name": "normalColor",
            "type": "Color",
            "default": "white"
          },
          {
            "name": "hoverColor",
            "type": "Color",
            "default": "red"
          }
        ],
        "behaviors": [
          {
            "name": "change_to_hover_state",
            "trigger": "when mouse cursor enters this UI element area",
            "actions": [
              {
                "action": "change crosshair sprite to hover sprite"
              },
              {
                "action": "change crosshair color to hover color"
              }
            ]
          },
          {
            "name": "change_to_normal_state",
            "trigger": "when mouse cursor exits this UI element area",
            "actions": [
              {
                "action": "change crosshair sprite to normal sprite"
              },
              {
                "action": "change crosshair color to normal color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class DynamicCrosshair : MonoBehaviour\n{\n    [Header(\"Crosshair Settings\")]\n    [SerializeField] private Image _crosshairImage;\n    [SerializeField] private Sprite _defaultCrosshair;\n    [SerializeField] private Sprite _hoverCrosshair;\n    [SerializeField] private Color _defaultColor = Color.white;\n    [SerializeField] private Color _hoverColor = Color.red;\n    \n    [Header(\"Raycast Settings\")]\n    [SerializeField] private Camera _playerCamera;\n    [SerializeField] private float _raycastDistance = 100f;\n    [SerializeField] private LayerMask _interactableLayerMask = -1;\n    [SerializeField] private string[] _interactableTags = { \"Interactable\", \"Enemy\", \"Pickup\" };\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useAnimation = true;\n    [SerializeField] private float _transitionSpeed = 5f;\n    [SerializeField] private float _hoverScale = 1.2f;\n    \n    private bool _isHovering = false;\n    private Vector3 _defaultScale;\n    private Color _currentColor;\n    private Vector3 _targetScale;\n    \n    private void Start()\n    {\n        if (_crosshairImage == null)\n            _crosshairImage = GetComponent<Image>();\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_crosshairImage != null)\n        {\n            _defaultScale = _crosshairImage.transform.localScale;\n            _targetScale = _defaultScale;\n            _currentColor = _defaultColor;\n            _crosshairImage.color = _currentColor;\n            \n            if (_defaultCrosshair != null)\n                _crosshairImage.sprite = _defaultCrosshair;\n        }\n    }\n    \n    private void Update()\n    {\n        CheckForHoverTarget();\n        UpdateCrosshairAppearance();\n    }\n    \n    private void CheckForHoverTarget()\n    {\n        if (_playerCamera == null) return;\n        \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f));\n        RaycastHit hit;\n        \n        bool wasHovering = _isHovering;\n        _isHovering = false;\n        \n        if (Physics.Raycast(ray, out hit, _raycastDistance, _interactableLayerMask))\n        {\n            GameObject hitObject = hit.collider.gameObject;\n            \n            foreach (string tag in _interactableTags)\n            {\n                if (hitObject.CompareTag(tag))\n                {\n                    _isHovering = true;\n                    break;\n                }\n            }\n        }\n        \n        if (_isHovering != wasHovering)\n        {\n            OnHoverStateChanged(_isHovering);\n        }\n    }\n    \n    private void OnHoverStateChanged(bool hovering)\n    {\n        if (_crosshairImage == null) return;\n        \n        if (hovering)\n        {\n            if (_hoverCrosshair != null)\n                _crosshairImage.sprite = _hoverCrosshair;\n                \n            _targetScale = _defaultScale * _hoverScale;\n        }\n        else\n        {\n            if (_defaultCrosshair != null)\n                _crosshairImage.sprite = _defaultCrosshair;\n                \n            _targetScale = _defaultScale;\n        }\n    }\n    \n    private void UpdateCrosshairAppearance()\n    {\n        if (_crosshairImage == null) return;\n        \n        Color targetColor = _isHovering ? _hoverColor : _defaultColor;\n        \n        if (_useAnimation)\n        {\n            _currentColor = Color.Lerp(_currentColor, targetColor, Time.deltaTime * _transitionSpeed);\n            _crosshairImage.transform.localScale = Vector3.Lerp(_crosshairImage.transform.localScale, _targetScale, Time.deltaTime * _transitionSpeed);\n        }\n        else\n        {\n            _currentColor = targetColor;\n            _crosshairImage.transform.localScale = _targetScale;\n        }\n        \n        _crosshairImage.color = _currentColor;\n    }\n    \n    public void SetCrosshairSprites(Sprite defaultSprite, Sprite hoverSprite)\n    {\n        _defaultCrosshair = defaultSprite;\n        _hoverCrosshair = hoverSprite;\n        \n        if (_crosshairImage != null && !_isHovering)\n            _crosshairImage.sprite = _defaultCrosshair;\n    }\n    \n    public void SetCrosshairColors(Color defaultColor, Color hoverColor)\n    {\n        _defaultColor = defaultColor;\n        _hoverColor = hoverColor;\n    }\n    \n    public void SetRaycastDistance(float distance)\n    {\n        _raycastDistance = Mathf.Max(0f, distance);\n    }\n    \n    public void AddInteractableTag(string tag)\n    {\n        if (System.Array.IndexOf(_interactableTags, tag) == -1)\n        {\n            string[] newTags = new string[_interactableTags.Length + 1];\n            _interactableTags.CopyTo(newTags, 0);\n            newTags[_interactableTags.Length] = tag;\n            _interactableTags = newTags;\n        }\n    }\n    \n    public bool IsHoveringInteractable()\n    {\n        return _isHovering;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "tooltip on hover over item",
      "ideal_ir": {
        "class_name": "TooltipOnHover",
        "components": [
          "EventTrigger",
          "Canvas",
          "Text"
        ],
        "fields": [
          {
            "name": "tooltipText",
            "type": "string",
            "default": "Item Description"
          },
          {
            "name": "tooltipPanel",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "offsetPosition",
            "type": "Vector2",
            "default": {
              "x": 10,
              "y": 10
            }
          }
        ],
        "behaviors": [
          {
            "name": "show_tooltip_on_hover",
            "trigger": "when mouse cursor enters the item area",
            "actions": [
              {
                "action": "make tooltip panel visible"
              },
              {
                "action": "position tooltip panel near mouse cursor with offset"
              },
              {
                "action": "display tooltip text in the panel"
              }
            ]
          },
          {
            "name": "hide_tooltip_on_exit",
            "trigger": "when mouse cursor leaves the item area",
            "actions": [
              {
                "action": "make tooltip panel invisible"
              }
            ]
          },
          {
            "name": "follow_mouse_while_hovering",
            "trigger": "while mouse cursor is over the item area",
            "actions": [
              {
                "action": "update tooltip panel position to follow mouse cursor"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing TMPro;\n\npublic class TooltipOnHover : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerMoveHandler\n{\n    [Header(\"Tooltip Settings\")]\n    [SerializeField] private string _tooltipTitle = \"Item Name\";\n    [SerializeField] private string _tooltipDescription = \"Item description goes here\";\n    [SerializeField] private Sprite _tooltipIcon;\n    [SerializeField] private float _showDelay = 0.5f;\n    [SerializeField] private Vector2 _offset = new Vector2(10f, 10f);\n    \n    [Header(\"Tooltip Prefab\")]\n    [SerializeField] private GameObject _tooltipPrefab;\n    \n    private static TooltipDisplay _currentTooltip;\n    private static Canvas _tooltipCanvas;\n    private Coroutine _showTooltipCoroutine;\n    \n    private void Start()\n    {\n        if (_tooltipCanvas == null)\n        {\n            CreateTooltipCanvas();\n        }\n    }\n    \n    private void CreateTooltipCanvas()\n    {\n        GameObject canvasGO = new GameObject(\"TooltipCanvas\");\n        _tooltipCanvas = canvasGO.AddComponent<Canvas>();\n        _tooltipCanvas.renderMode = RenderMode.ScreenSpaceOverlay;\n        _tooltipCanvas.sortingOrder = 1000;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;\n        scaler.referenceResolution = new Vector2(1920, 1080);\n        \n        canvasGO.AddComponent<GraphicRaycaster>();\n        DontDestroyOnLoad(canvasGO);\n    }\n    \n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        _showTooltipCoroutine = StartCoroutine(ShowTooltipAfterDelay());\n    }\n    \n    public void OnPointerExit(PointerEventData eventData)\n    {\n        if (_showTooltipCoroutine != null)\n        {\n            StopCoroutine(_showTooltipCoroutine);\n            _showTooltipCoroutine = null;\n        }\n        HideTooltip();\n    }\n    \n    public void OnPointerMove(PointerEventData eventData)\n    {\n        if (_currentTooltip != null)\n        {\n            UpdateTooltipPosition(eventData.position);\n        }\n    }\n    \n    private System.Collections.IEnumerator ShowTooltipAfterDelay()\n    {\n        yield return new WaitForSeconds(_showDelay);\n        ShowTooltip();\n    }\n    \n    private void ShowTooltip()\n    {\n        if (_tooltipCanvas == null) return;\n        \n        HideTooltip();\n        \n        GameObject tooltipGO;\n        if (_tooltipPrefab != null)\n        {\n            tooltipGO = Instantiate(_tooltipPrefab, _tooltipCanvas.transform);\n        }\n        else\n        {\n            tooltipGO = CreateDefaultTooltip();\n        }\n        \n        _currentTooltip = tooltipGO.GetComponent<TooltipDisplay>();\n        if (_currentTooltip == null)\n        {\n            _currentTooltip = tooltipGO.AddComponent<TooltipDisplay>();\n        }\n        \n        _currentTooltip.SetupTooltip(_tooltipTitle, _tooltipDescription, _tooltipIcon);\n        UpdateTooltipPosition(Input.mousePosition);\n    }\n    \n    private GameObject CreateDefaultTooltip()\n    {\n        GameObject tooltipGO = new GameObject(\"Tooltip\");\n        tooltipGO.transform.SetParent(_tooltipCanvas.transform);\n        \n        Image background = tooltipGO.AddComponent<Image>();\n        background.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);\n        \n        RectTransform rectTransform = tooltipGO.GetComponent<RectTransform>();\n        rectTransform.sizeDelta = new Vector2(300, 100);\n        \n        GameObject textGO = new GameObject(\"Text\");\n        textGO.transform.SetParent(tooltipGO.transform);\n        \n        TextMeshProUGUI text = textGO.AddComponent<TextMeshProUGUI>();\n        text.text = _tooltipTitle + \"\\n\" + _tooltipDescription;\n        text.fontSize = 14;\n        text.color = Color.white;\n        text.alignment = TextAlignmentOptions.TopLeft;\n        \n        RectTransform textRect = textGO.GetComponent<RectTransform>();\n        textRect.anchorMin = Vector2.zero;\n        textRect.anchorMax = Vector2.one;\n        textRect.offsetMin = new Vector2(10, 10);\n        textRect.offsetMax = new Vector2(-10, -10);\n        \n        return tooltipGO;\n    }\n    \n    private void UpdateTooltipPosition(Vector2 mousePosition)\n    {\n        if (_currentTooltip == null) return;\n        \n        RectTransform tooltipRect = _currentTooltip.GetComponent<RectTransform>();\n        Vector2 position = mousePosition + _offset;\n        \n        Vector2 screenSize = new Vector2(Screen.width, Screen.height);\n        Vector2 tooltipSize = tooltipRect.sizeDelta;\n        \n        if (position.x + tooltipSize.x > screenSize.x)\n        {\n            position.x = mousePosition.x - tooltipSize.x - _offset.x;\n        }\n        \n        if (position.y - tooltipSize.y < 0)\n        {\n            position.y = mousePosition.y + tooltipSize.y + _offset.y;\n        }\n        \n        tooltipRect.position = position;\n    }\n    \n    private void HideTooltip()\n    {\n        if (_currentTooltip != null)\n        {\n            Destroy(_currentTooltip.gameObject);\n            _currentTooltip = null;\n        }\n    }\n    \n    public void SetTooltipContent(string title, string description, Sprite icon = null)\n    {\n        _tooltipTitle = title;\n        _tooltipDescription = description;\n        _tooltipIcon = icon;\n    }\n}\n\npublic class TooltipDisplay : MonoBehaviour\n{\n    private TextMeshProUGUI _titleText;\n    private TextMeshProUGUI _descriptionText;\n    private Image _iconImage;\n    \n    private void Awake()\n    {\n        SetupComponents();\n    }\n    \n    private void SetupComponents()\n    {\n        Transform titleTransform = transform.Find(\"Title\");\n        if (titleTransform != null)\n        {\n            _titleText = titleTransform.GetComponent<TextMeshProUGUI>();\n        }\n        \n        Transform descTransform = transform.Find(\"Description\");\n        if (descTransform != null)\n        {\n            _descriptionText = descTransform.GetComponent<TextMeshProUGUI>();\n        }\n        \n        Transform iconTransform = transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            _iconImage = iconTransform.GetComponent<Image>();\n        }\n    }\n    \n    public void SetupTooltip(string title, string description, Sprite icon)\n    {\n        if (_titleText != null)\n        {\n            _titleText.text = title;\n        }\n        \n        if (_descriptionText != null)\n        {\n            _descriptionText.text = description;\n        }\n        \n        if (_iconImage != null && icon != null)\n        {\n            _iconImage.sprite = icon;\n            _iconImage.gameObject.SetActive(true);\n        }\n        else if (_iconImage != null)\n        {\n            _iconImage.gameObject.SetActive(false);\n        }\n        \n        LayoutRebuilder.ForceRebuildLayoutImmediate(GetComponent<RectTransform>());\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "car with acceleration and steering",
      "ideal_ir": {
        "class_name": "Car",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "accelerationForce",
            "type": "float",
            "default": 1500
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 20
          },
          {
            "name": "steeringAngle",
            "type": "float",
            "default": 30
          },
          {
            "name": "brakeForce",
            "type": "float",
            "default": 3000
          },
          {
            "name": "currentSpeed",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "accelerate_forward",
            "trigger": "when forward input is pressed",
            "actions": [
              {
                "action": "apply forward force based on acceleration force"
              },
              {
                "action": "limit speed to maximum speed"
              }
            ]
          },
          {
            "name": "accelerate_backward",
            "trigger": "when backward input is pressed",
            "actions": [
              {
                "action": "apply backward force based on acceleration force"
              },
              {
                "action": "limit reverse speed to half of maximum speed"
              }
            ]
          },
          {
            "name": "steer_left",
            "trigger": "when left input is pressed and car is moving",
            "actions": [
              {
                "action": "rotate car left based on steering angle and current speed"
              }
            ]
          },
          {
            "name": "steer_right",
            "trigger": "when right input is pressed and car is moving",
            "actions": [
              {
                "action": "rotate car right based on steering angle and current speed"
              }
            ]
          },
          {
            "name": "apply_brakes",
            "trigger": "when brake input is pressed",
            "actions": [
              {
                "action": "apply brake force to reduce current speed"
              },
              {
                "action": "gradually stop the car"
              }
            ]
          },
          {
            "name": "natural_deceleration",
            "trigger": "when no input is pressed",
            "actions": [
              {
                "action": "gradually reduce speed due to friction"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class CarController : MonoBehaviour\n{\n    [Header(\"Car Settings\")]\n    [SerializeField] private float _motorForce = 1500f;\n    [SerializeField] private float _brakeForce = 3000f;\n    [SerializeField] private float _maxSteerAngle = 30f;\n    [SerializeField] private float _downForce = 100f;\n    \n    [Header(\"Wheel Colliders\")]\n    [SerializeField] private WheelCollider _frontLeftWheelCollider;\n    [SerializeField] private WheelCollider _frontRightWheelCollider;\n    [SerializeField] private WheelCollider _rearLeftWheelCollider;\n    [SerializeField] private WheelCollider _rearRightWheelCollider;\n    \n    [Header(\"Wheel Transforms\")]\n    [SerializeField] private Transform _frontLeftWheelTransform;\n    [SerializeField] private Transform _frontRightWheelTransform;\n    [SerializeField] private Transform _rearLeftWheelTransform;\n    [SerializeField] private Transform _rearRightWheelTransform;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private string _horizontalInputAxis = \"Horizontal\";\n    [SerializeField] private string _verticalInputAxis = \"Vertical\";\n    [SerializeField] private KeyCode _brakeKey = KeyCode.Space;\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _steerAngle;\n    private bool _isBreaking;\n    private Rigidbody _carRigidbody;\n    \n    private void Start()\n    {\n        _carRigidbody = GetComponent<Rigidbody>();\n        if (_carRigidbody == null)\n        {\n            _carRigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _carRigidbody.centerOfMass = new Vector3(0, -0.5f, 0.5f);\n    }\n    \n    private void Update()\n    {\n        GetInput();\n        HandleMotor();\n        HandleSteering();\n        UpdateWheels();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyDownForce();\n    }\n    \n    private void GetInput()\n    {\n        _horizontalInput = Input.GetAxis(_horizontalInputAxis);\n        _verticalInput = Input.GetAxis(_verticalInputAxis);\n        _isBreaking = Input.GetKey(_brakeKey);\n    }\n    \n    private void HandleMotor()\n    {\n        if (_frontLeftWheelCollider == null || _frontRightWheelCollider == null) return;\n        \n        _frontLeftWheelCollider.motorTorque = _verticalInput * _motorForce;\n        _frontRightWheelCollider.motorTorque = _verticalInput * _motorForce;\n        \n        float currentBrakeForce = _isBreaking ? _brakeForce : 0f;\n        ApplyBreaking(currentBrakeForce);\n    }\n    \n    private void ApplyBreaking(float brakeForce)\n    {\n        if (_frontRightWheelCollider != null)\n            _frontRightWheelCollider.brakeTorque = brakeForce;\n        if (_frontLeftWheelCollider != null)\n            _frontLeftWheelCollider.brakeTorque = brakeForce;\n        if (_rearLeftWheelCollider != null)\n            _rearLeftWheelCollider.brakeTorque = brakeForce;\n        if (_rearRightWheelCollider != null)\n            _rearRightWheelCollider.brakeTorque = brakeForce;\n    }\n    \n    private void HandleSteering()\n    {\n        _steerAngle = _maxSteerAngle * _horizontalInput;\n        \n        if (_frontLeftWheelCollider != null)\n            _frontLeftWheelCollider.steerAngle = _steerAngle;\n        if (_frontRightWheelCollider != null)\n            _frontRightWheelCollider.steerAngle = _steerAngle;\n    }\n    \n    private void UpdateWheels()\n    {\n        UpdateSingleWheel(_frontLeftWheelCollider, _frontLeftWheelTransform);\n        UpdateSingleWheel(_frontRightWheelCollider, _frontRightWheelTransform);\n        UpdateSingleWheel(_rearRightWheelCollider, _rearRightWheelTransform);\n        UpdateSingleWheel(_rearLeftWheelCollider, _rearLeftWheelTransform);\n    }\n    \n    private void UpdateSingleWheel(WheelCollider wheelCollider, Transform wheelTransform)\n    {\n        if (wheelCollider == null || wheelTransform == null) return;\n        \n        Vector3 pos;\n        Quaternion rot;\n        wheelCollider.GetWorldPose(out pos, out rot);\n        wheelTransform.rotation = rot;\n        wheelTransform.position = pos;\n    }\n    \n    private void ApplyDownForce()\n    {\n        if (_carRigidbody != null)\n        {\n            _carRigidbody.AddForce(-transform.up * _downForce * _carRigidbody.velocity.magnitude);\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _carRigidbody != null ? _carRigidbody.velocity.magnitude * 3.6f : 0f;\n    }\n    \n    public bool IsGrounded()\n    {\n        return (_frontLeftWheelCollider != null && _frontLeftWheelCollider.isGrounded) ||\n               (_frontRightWheelCollider != null && _frontRightWheelCollider.isGrounded) ||\n               (_rearLeftWheelCollider != null && _rearLeftWheelCollider.isGrounded) ||\n               (_rearRightWheelCollider != null && _rearRightWheelCollider.isGrounded);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "boat that floats on water",
      "ideal_ir": {
        "class_name": "FloatingBoat",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "buoyancyForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "waterLevel",
            "type": "float",
            "default": 0
          },
          {
            "name": "floatHeight",
            "type": "float",
            "default": 2
          },
          {
            "name": "dampening",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "apply_buoyancy",
            "trigger": "when boat is below water surface",
            "actions": [
              {
                "action": "apply upward force proportional to how deep underwater the boat is"
              },
              {
                "action": "reduce vertical velocity to create dampening effect"
              }
            ]
          },
          {
            "name": "stabilize_rotation",
            "trigger": "when boat is tilted",
            "actions": [
              {
                "action": "apply torque to return boat to upright position"
              },
              {
                "action": "reduce angular velocity for stability"
              }
            ]
          },
          {
            "name": "water_resistance",
            "trigger": "when boat is moving through water",
            "actions": [
              {
                "action": "apply drag force opposite to movement direction"
              },
              {
                "action": "reduce velocity over time when no input is applied"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FloatingBoat : MonoBehaviour\n{\n    [Header(\"Buoyancy Settings\")]\n    [SerializeField] private float _buoyancyForce = 15f;\n    [SerializeField] private float _waterLevel = 0f;\n    [SerializeField] private float _waterDrag = 0.99f;\n    [SerializeField] private float _waterAngularDrag = 0.5f;\n    \n    [Header(\"Float Points\")]\n    [SerializeField] private Transform[] _floatPoints;\n    [SerializeField] private float _underwaterDrag = 3f;\n    [SerializeField] private float _underwaterAngularDrag = 1f;\n    \n    [Header(\"Wave Settings\")]\n    [SerializeField] private bool _useWaves = true;\n    [SerializeField] private float _waveHeight = 0.5f;\n    [SerializeField] private float _waveSpeed = 1f;\n    [SerializeField] private float _waveLength = 10f;\n    \n    [Header(\"Stability\")]\n    [SerializeField] private float _stabilityForce = 50f;\n    [SerializeField] private float _stabilityTorque = 50f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isUnderwater;\n    private int _underwaterCount;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n        \n        if (_floatPoints == null || _floatPoints.Length == 0)\n        {\n            CreateDefaultFloatPoints();\n        }\n    }\n    \n    private void CreateDefaultFloatPoints()\n    {\n        _floatPoints = new Transform[4];\n        Bounds bounds = GetComponent<Collider>()?.bounds ?? new Bounds(transform.position, Vector3.one);\n        \n        GameObject frontLeft = new GameObject(\"FloatPoint_FrontLeft\");\n        GameObject frontRight = new GameObject(\"FloatPoint_FrontRight\");\n        GameObject backLeft = new GameObject(\"FloatPoint_BackLeft\");\n        GameObject backRight = new GameObject(\"FloatPoint_BackRight\");\n        \n        frontLeft.transform.SetParent(transform);\n        frontRight.transform.SetParent(transform);\n        backLeft.transform.SetParent(transform);\n        backRight.transform.SetParent(transform);\n        \n        Vector3 size = bounds.size;\n        frontLeft.transform.localPosition = new Vector3(-size.x * 0.4f, -size.y * 0.5f, size.z * 0.4f);\n        frontRight.transform.localPosition = new Vector3(size.x * 0.4f, -size.y * 0.5f, size.z * 0.4f);\n        backLeft.transform.localPosition = new Vector3(-size.x * 0.4f, -size.y * 0.5f, -size.z * 0.4f);\n        backRight.transform.localPosition = new Vector3(size.x * 0.4f, -size.y * 0.5f, -size.z * 0.4f);\n        \n        _floatPoints[0] = frontLeft.transform;\n        _floatPoints[1] = frontRight.transform;\n        _floatPoints[2] = backLeft.transform;\n        _floatPoints[3] = backRight.transform;\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyStability();\n        UpdateDrag();\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        _underwaterCount = 0;\n        \n        foreach (Transform floatPoint in _floatPoints)\n        {\n            if (floatPoint == null) continue;\n            \n            float waterHeight = GetWaterHeightAtPosition(floatPoint.position);\n            float difference = floatPoint.position.y - waterHeight;\n            \n            if (difference < 0)\n            {\n                _underwaterCount++;\n                Vector3 buoyancyForceVector = Vector3.up * _buoyancyForce * Mathf.Abs(difference);\n                _rigidbody.AddForceAtPosition(buoyancyForceVector, floatPoint.position, ForceMode.Force);\n            }\n        }\n        \n        _isUnderwater = _underwaterCount > 0;\n    }\n    \n    private float GetWaterHeightAtPosition(Vector3 position)\n    {\n        if (!_useWaves)\n        {\n            return _waterLevel;\n        }\n        \n        float wave1 = Mathf.Sin((position.x / _waveLength + Time.time * _waveSpeed) * 2 * Mathf.PI) * _waveHeight;\n        float wave2 = Mathf.Sin((position.z / _waveLength + Time.time * _waveSpeed * 0.8f) * 2 * Mathf.PI) * _waveHeight * 0.5f;\n        \n        return _waterLevel + wave1 + wave2;\n    }\n    \n    private void ApplyStability()\n    {\n        Vector3 stabilityTorqueVector = Vector3.Cross(transform.up, Vector3.up);\n        _rigidbody.AddTorque(stabilityTorqueVector * _stabilityTorque, ForceMode.Force);\n        \n        Vector3 stabilityForceVector = Vector3.up * _stabilityForce;\n        _rigidbody.AddForce(stabilityForceVector * (Vector3.Dot(Vector3.down, transform.up) + 1) * 0.5f, ForceMode.Force);\n    }\n    \n    private void UpdateDrag()\n    {\n        if (_isUnderwater)\n        {\n            float dragMultiplier = (float)_underwaterCount / _floatPoints.Length;\n            _rigidbody.drag = Mathf.Lerp(_originalDrag, _underwaterDrag, dragMultiplier);\n            _rigidbody.angularDrag = Mathf.Lerp(_originalAngularDrag, _underwaterAngularDrag, dragMultiplier);\n        }\n        else\n        {\n            _rigidbody.drag = _originalDrag;\n            _rigidbody.angularDrag = _originalAngularDrag;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_floatPoints == null) return;\n        \n        Gizmos.color = Color.blue;\n        foreach (Transform floatPoint in _floatPoints)\n        {\n            if (floatPoint != null)\n            {\n                Gizmos.DrawWireSphere(floatPoint.position, 0.2f);\n            }\n        }\n        \n        Gizmos.color = Color.cyan;\n        Vector3 waterPlaneSize = new Vector3(20f, 0.1f, 20f);\n        Gizmos.DrawCube(new Vector3(transform.position.x, _waterLevel, transform.position.z), waterPlaneSize);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "helicopter with altitude control",
      "ideal_ir": {
        "class_name": "HelicopterController",
        "components": [
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "targetAltitude",
            "type": "float",
            "default": 50
          },
          {
            "name": "maxAltitude",
            "type": "float",
            "default": 100
          },
          {
            "name": "minAltitude",
            "type": "float",
            "default": 5
          },
          {
            "name": "altitudeSpeed",
            "type": "float",
            "default": 10
          },
          {
            "name": "hoverForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "stabilityForce",
            "type": "float",
            "default": 5
          },
          {
            "name": "rotorSpeed",
            "type": "float",
            "default": 1000
          },
          {
            "name": "enginePower",
            "type": "float",
            "default": 100
          }
        ],
        "behaviors": [
          {
            "name": "maintain_target_altitude",
            "trigger": "every frame while helicopter is active",
            "actions": [
              {
                "action": "check current altitude against target altitude"
              },
              {
                "action": "apply upward force when below target altitude"
              },
              {
                "action": "apply downward force when above target altitude"
              },
              {
                "action": "adjust force strength based on altitude difference"
              }
            ]
          },
          {
            "name": "altitude_input_control",
            "trigger": "when altitude increase input is pressed",
            "actions": [
              {
                "action": "increase target altitude within maximum limit"
              },
              {
                "action": "play engine acceleration sound"
              }
            ]
          },
          {
            "name": "altitude_decrease_control",
            "trigger": "when altitude decrease input is pressed",
            "actions": [
              {
                "action": "decrease target altitude within minimum limit"
              },
              {
                "action": "play engine deceleration sound"
              }
            ]
          },
          {
            "name": "hover_stabilization",
            "trigger": "when helicopter velocity is low and near target altitude",
            "actions": [
              {
                "action": "apply gentle upward hover force to counteract gravity"
              },
              {
                "action": "reduce horizontal drift with stabilizing forces"
              }
            ]
          },
          {
            "name": "altitude_safety_limits",
            "trigger": "when helicopter approaches maximum or minimum altitude",
            "actions": [
              {
                "action": "prevent further altitude changes beyond safe limits"
              },
              {
                "action": "play warning sound when near altitude boundaries"
              }
            ]
          },
          {
            "name": "rotor_sound_control",
            "trigger": "every frame based on engine power and altitude changes",
            "actions": [
              {
                "action": "adjust rotor sound pitch based on engine power"
              },
              {
                "action": "modify rotor sound volume based on altitude change rate"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class HelicopterController : MonoBehaviour\n{\n    [Header(\"Flight Controls\")]\n    [SerializeField] private float _liftForce = 1000f;\n    [SerializeField] private float _maxAltitude = 100f;\n    [SerializeField] private float _minAltitude = 0.5f;\n    [SerializeField] private float _altitudeControlSensitivity = 2f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _forwardSpeed = 20f;\n    [SerializeField] private float _sidewaysSpeed = 15f;\n    [SerializeField] private float _rotationSpeed = 50f;\n    \n    [Header(\"Stability\")]\n    [SerializeField] private float _stabilizationForce = 500f;\n    [SerializeField] private float _tiltAmount = 15f;\n    [SerializeField] private float _tiltSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _rotorAudioSource;\n    [SerializeField] private float _minRotorPitch = 0.5f;\n    [SerializeField] private float _maxRotorPitch = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private float _dustEffectHeight = 5f;\n    \n    private Rigidbody _rigidbody;\n    private float _currentThrottle;\n    private float _targetAltitude;\n    private Vector3 _initialRotation;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = 1000f;\n        _rigidbody.drag = 1f;\n        _rigidbody.angularDrag = 5f;\n        \n        _initialRotation = transform.eulerAngles;\n        _targetAltitude = transform.position.y;\n        \n        if (_rotorAudioSource == null)\n        {\n            _rotorAudioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateAudio();\n        UpdateEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyLift();\n        ApplyMovement();\n        ApplyStabilization();\n        CheckGroundContact();\n    }\n    \n    private void HandleInput()\n    {\n        float throttleInput = Input.GetAxis(\"Vertical\");\n        float yawInput = Input.GetAxis(\"Horizontal\");\n        \n        _currentThrottle = Mathf.Clamp01(_currentThrottle + throttleInput * Time.deltaTime * _altitudeControlSensitivity);\n        \n        if (Input.GetKey(KeyCode.Q))\n        {\n            _targetAltitude = Mathf.Min(_targetAltitude + 10f * Time.deltaTime, _maxAltitude);\n        }\n        if (Input.GetKey(KeyCode.E))\n        {\n            _targetAltitude = Mathf.Max(_targetAltitude - 10f * Time.deltaTime, _minAltitude);\n        }\n        \n        if (Mathf.Abs(yawInput) > 0.1f)\n        {\n            transform.Rotate(0, yawInput * _rotationSpeed * Time.deltaTime, 0);\n        }\n    }\n    \n    private void ApplyLift()\n    {\n        float currentAltitude = transform.position.y;\n        float altitudeDifference = _targetAltitude - currentAltitude;\n        \n        float liftMultiplier = _currentThrottle;\n        \n        if (Mathf.Abs(altitudeDifference) > 0.5f)\n        {\n            liftMultiplier += Mathf.Sign(altitudeDifference) * 0.5f;\n        }\n        \n        liftMultiplier = Mathf.Clamp01(liftMultiplier);\n        \n        Vector3 liftVector = Vector3.up * _liftForce * liftMultiplier;\n        _rigidbody.AddForce(liftVector);\n        \n        Vector3 counterGravity = -Physics.gravity * _rigidbody.mass * 0.8f;\n        _rigidbody.AddForce(counterGravity);\n    }\n    \n    private void ApplyMovement()\n    {\n        float forwardInput = 0f;\n        float sidewaysInput = 0f;\n        \n        if (Input.GetKey(KeyCode.W)) forwardInput = 1f;\n        if (Input.GetKey(KeyCode.S)) forwardInput = -1f;\n        if (Input.GetKey(KeyCode.A)) sidewaysInput = -1f;\n        if (Input.GetKey(KeyCode.D)) sidewaysInput = 1f;\n        \n        Vector3 forwardForce = transform.forward * forwardInput * _forwardSpeed;\n        Vector3 sidewaysForce = transform.right * sidewaysInput * _sidewaysSpeed;\n        \n        _rigidbody.AddForce(forwardForce + sidewaysForce);\n        \n        float tiltX = -forwardInput * _tiltAmount;\n        float tiltZ = -sidewaysInput * _tiltAmount;\n        \n        Vector3 targetRotation = new Vector3(\n            _initialRotation.x + tiltX,\n            transform.eulerAngles.y,\n            _initialRotation.z + tiltZ\n        );\n        \n        transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(targetRotation), _tiltSpeed * Time.deltaTime);\n    }\n    \n    private void ApplyStabilization()\n    {\n        Vector3 stabilizationForce = -_rigidbody.velocity * _stabilizationForce * Time.fixedDeltaTime;\n        stabilizationForce.y *= 0.1f;\n        _rigidbody.AddForce(stabilizationForce);\n        \n        Vector3 angularStabilization = -_rigidbody.angularVelocity * _stabilizationForce * 0.1f * Time.fixedDeltaTime;\n        _rigidbody.AddTorque(angularStabilization);\n    }\n    \n    private void CheckGroundContact()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _minAltitude + 0.5f);\n        \n        if (_isGrounded && hit.distance < _minAltitude)\n        {\n            Vector3 position = transform.position;\n            position.y = hit.point.y + _minAltitude;\n            transform.position = position;\n            \n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = Mathf.Max(velocity.y, 0f);\n            _rigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rotorAudioSource != null)\n        {\n            float pitchTarget = Mathf.Lerp(_minRotorPitch, _maxRotorPitch, _currentThrottle);\n            _rotorAudioSource.pitch = Mathf.Lerp(_rotorAudioSource.pitch, pitchTarget, Time.deltaTime * 2f);\n            \n            if (!_rotorAudioSource.isPlaying)\n            {\n                _rotorAudioSource.Play();\n            }\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_dustEffect != null)\n        {\n            bool shouldPlayDust = _isGrounded && transform.position.y < _dustEffectHeight;\n            \n            if (shouldPlayDust && !_dustEffect.isPlaying)\n            {\n                _dustEffect.Play();\n            }\n            else if (!shouldPlayDust && _dustEffect.isPlaying)\n            {\n                _dustEffect.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.up * _targetAltitude, 1f);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * _maxAltitude, Vector3.one * 2f);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * _minAltitude, Vector3.one * 2f);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(transform.position, Vector3.down * (_minAltitude + 0.5f));\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "horse that player can mount",
      "ideal_ir": {
        "class_name": "MountableHorse",
        "components": [
          "Rigidbody",
          "CapsuleCollider",
          "Animator"
        ],
        "fields": [
          {
            "name": "walkSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "runSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "jumpForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "interactionRange",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isMounted",
            "type": "bool",
            "default": false
          },
          {
            "name": "mountedPlayer",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "show_mount_prompt",
            "trigger": "when player is within interaction range and horse is not mounted",
            "actions": [
              {
                "action": "display mount interaction prompt to player"
              }
            ]
          },
          {
            "name": "hide_mount_prompt",
            "trigger": "when player moves away from interaction range",
            "actions": [
              {
                "action": "hide mount interaction prompt"
              }
            ]
          },
          {
            "name": "mount_player",
            "trigger": "when player presses interact key while near horse and horse is not mounted",
            "actions": [
              {
                "action": "set horse as mounted"
              },
              {
                "action": "attach player to horse saddle position"
              },
              {
                "action": "disable player movement controls"
              },
              {
                "action": "enable horse movement controls for player"
              },
              {
                "action": "play mount animation"
              },
              {
                "action": "hide interaction prompt"
              }
            ]
          },
          {
            "name": "dismount_player",
            "trigger": "when player presses dismount key while mounted",
            "actions": [
              {
                "action": "set horse as not mounted"
              },
              {
                "action": "detach player from horse"
              },
              {
                "action": "place player beside horse"
              },
              {
                "action": "enable player movement controls"
              },
              {
                "action": "disable horse movement controls"
              },
              {
                "action": "play dismount animation"
              }
            ]
          },
          {
            "name": "horse_walk",
            "trigger": "when horse is mounted and player holds forward movement key",
            "actions": [
              {
                "action": "move horse forward at walking speed"
              },
              {
                "action": "play walking animation"
              },
              {
                "action": "play walking sound effects"
              }
            ]
          },
          {
            "name": "horse_run",
            "trigger": "when horse is mounted and player holds run key with forward movement",
            "actions": [
              {
                "action": "move horse forward at running speed"
              },
              {
                "action": "play running animation"
              },
              {
                "action": "play galloping sound effects"
              }
            ]
          },
          {
            "name": "horse_turn",
            "trigger": "when horse is mounted and player uses left or right movement keys",
            "actions": [
              {
                "action": "rotate horse in the direction of input"
              },
              {
                "action": "lean horse slightly in turn direction"
              }
            ]
          },
          {
            "name": "horse_jump",
            "trigger": "when horse is mounted and player presses jump key",
            "actions": [
              {
                "action": "make horse jump upward with jump force"
              },
              {
                "action": "play jumping animation"
              },
              {
                "action": "play horse neigh sound"
              }
            ]
          },
          {
            "name": "idle_behavior",
            "trigger": "when horse is not mounted and no player is nearby",
            "actions": [
              {
                "action": "play idle animation"
              },
              {
                "action": "occasionally look around"
              },
              {
                "action": "occasionally make horse sounds"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MountableHorse : MonoBehaviour\n{\n    [Header(\"Horse Settings\")]\n    [SerializeField] private float _moveSpeed = 8f;\n    [SerializeField] private float _rotationSpeed = 120f;\n    [SerializeField] private float _jumpForce = 12f;\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    \n    [Header(\"Mount Points\")]\n    [SerializeField] private Transform _mountPoint;\n    [SerializeField] private float _mountRange = 3f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckRadius = 0.3f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _hoofstepSounds;\n    [SerializeField] private AudioClip _neighSound;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private float _hoofstepInterval = 0.5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerMounted;\n    public UnityEvent OnPlayerDismounted;\n    public UnityEvent OnHorseJump;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Transform _mountedPlayer;\n    private bool _isPlayerMounted;\n    private float _currentStamina;\n    private bool _isGrounded;\n    private float _lastHoofstepTime;\n    private Vector3 _originalPlayerPosition;\n    private Transform _originalPlayerParent;\n    private bool _canMount = true;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_mountPoint == null)\n        {\n            GameObject mountPointObj = new GameObject(\"MountPoint\");\n            mountPointObj.transform.SetParent(transform);\n            mountPointObj.transform.localPosition = new Vector3(0, 1.5f, 0);\n            _mountPoint = mountPointObj.transform;\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheckObj = new GameObject(\"GroundCheck\");\n            groundCheckObj.transform.SetParent(transform);\n            groundCheckObj.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheckPoint = groundCheckObj.transform;\n        }\n    }\n    \n    private void Start()\n    {\n        _currentStamina = _maxStamina;\n        _rigidbody.freezeRotation = true;\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n        UpdateStamina();\n        CheckGrounded();\n        UpdateAnimations();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isPlayerMounted)\n        {\n            HandleMovement();\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_isPlayerMounted || !_canMount) return;\n        \n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _mountRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                ShowMountPrompt(true);\n                return;\n            }\n        }\n        \n        ShowMountPrompt(false);\n    }\n    \n    private void ShowMountPrompt(bool show)\n    {\n        // This would typically show UI prompt - for now just a debug message\n        if (show && !_isPlayerMounted)\n        {\n            Debug.Log($\"Press {_mountKey} to mount horse\");\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_mountKey))\n        {\n            if (!_isPlayerMounted)\n            {\n                TryMountPlayer();\n            }\n            else\n            {\n                DismountPlayer();\n            }\n        }\n        \n        if (_isPlayerMounted && Input.GetKeyDown(KeyCode.Space) && _isGrounded && _currentStamina > 20f)\n        {\n            Jump();\n        }\n    }\n    \n    private void TryMountPlayer()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _mountRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                MountPlayer(col.transform);\n                break;\n            }\n        }\n    }\n    \n    private void MountPlayer(Transform player)\n    {\n        _mountedPlayer = player;\n        _isPlayerMounted = true;\n        \n        // Store original player state\n        _originalPlayerPosition = player.position;\n        _originalPlayerParent = player.parent;\n        \n        // Attach player to mount point\n        player.SetParent(_mountPoint);\n        player.localPosition = Vector3.zero;\n        player.localRotation = Quaternion.identity;\n        \n        // Disable player's rigidbody and collider if they exist\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.isKinematic = true;\n        }\n        \n        Collider playerCol = player.GetComponent<Collider>();\n        if (playerCol != null)\n        {\n            playerCol.enabled = false;\n        }\n        \n        PlaySound(_neighSound);\n        OnPlayerMounted?.Invoke();\n    }\n    \n    private void DismountPlayer()\n    {\n        if (!_isPlayerMounted || _mountedPlayer == null) return;\n        \n        // Find safe dismount position\n        Vector3 dismountPosition = FindSafeDismountPosition();\n        \n        // Restore player state\n        _mountedPlayer.SetParent(_originalPlayerParent);\n        _mountedPlayer.position = dismountPosition;\n        \n        // Re-enable player components\n        Rigidbody playerRb = _mountedPlayer.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.isKinematic = false;\n        }\n        \n        Collider playerCol = _mountedPlayer.GetComponent<Collider>();\n        if (playerCol != null)\n        {\n            playerCol.enabled = true;\n        }\n        \n        _mountedPlayer = null;\n        _isPlayerMounted = false;\n        \n        OnPlayerDismounted?.Invoke();\n    }\n    \n    private Vector3 FindSafeDismountPosition()\n    {\n        Vector3[] directions = {\n            -transform.right,\n            transform.right,\n            -transform.forward,\n            transform.forward\n        };\n        \n        foreach (Vector3 direction in directions)\n        {\n            Vector3 testPosition = transform.position + direction * 2f;\n            \n            if (!Physics.CheckSphere(testPosition, 0.5f, _groundLayerMask))\n            {\n                return testPosition;\n            }\n        }\n        \n        return transform.position + Vector3.back * 2f;\n    }\n    \n    private void HandleMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        if (Mathf.Abs(horizontal) > 0.1f || Mathf.Abs(vertical) > 0.1f)\n        {\n            // Movement\n            Vector3 movement = transform.forward * vertical * _moveSpeed;\n            _rigidbody.velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n            \n            // Rotation\n            transform.Rotate(0, horizontal * _rotationSpeed * Time.fixedDeltaTime, 0);\n            \n            // Drain stamina when running\n            if (Input.GetKey(KeyCode.LeftShift) && _currentStamina > 0)\n            {\n                _rigidbody.velocity = new Vector3(_rigidbody.velocity.x * 1.5f, _rigidbody.velocity.y, _rigidbody.velocity.z * 1.5f);\n                _currentStamina -= _staminaDrainRate * Time.fixedDeltaTime;\n            }\n            \n            PlayHoofstepSounds();\n        }\n    }\n    \n    private void Jump()\n    {\n        _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        _currentStamina -= 20f;\n        PlaySound(_jumpSound);\n        OnHorseJump?.Invoke();\n    }\n    \n    private void UpdateStamina()\n    {\n        if (_currentStamina < _maxStamina)\n        {\n            _currentStamina += _staminaRegenRate * Time.deltaTime;\n            _currentStamina = Mathf.Clamp(_currentStamina, 0, _maxStamina);\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        _isGrounded = Physics.CheckSphere(_groundCheckPoint.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"IsGrounded\", _isGrounded);\n        _animator.SetBool(\"IsMounted\", _isPlayerMounted);\n    }\n    \n    private void PlayHoofstepSounds()\n    {\n        if (_hoofstepSounds.Length == 0 || Time.time - _lastHoofstepTime < _hoofstepInterval) return;\n        \n        AudioClip randomHoofstep = _hoofstepSounds[Random.Range(0, _hoofstepSounds.Length)];\n        PlaySound(randomHoofstep);\n        _lastHoofstepTime = Time.time;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw mount range\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        // Draw ground check\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, _groundCheckRadius);\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsPlayerMounted()\n    {\n        return _isPlayerMounted;\n    }\n    \n    public void SetCanMount(bool canMount)\n    {\n        _canMount = canMount;\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "tank with turret rotation",
      "ideal_ir": {
        "class_name": "Tank",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90.0
          },
          {
            "name": "turretRotationSpeed",
            "type": "float",
            "default": 45.0
          },
          {
            "name": "turret",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "move_forward",
            "trigger": "when forward input is pressed",
            "actions": [
              {
                "action": "move tank forward at move speed"
              }
            ]
          },
          {
            "name": "move_backward",
            "trigger": "when backward input is pressed",
            "actions": [
              {
                "action": "move tank backward at move speed"
              }
            ]
          },
          {
            "name": "rotate_left",
            "trigger": "when left input is pressed",
            "actions": [
              {
                "action": "rotate tank left at rotation speed"
              }
            ]
          },
          {
            "name": "rotate_right",
            "trigger": "when right input is pressed",
            "actions": [
              {
                "action": "rotate tank right at rotation speed"
              }
            ]
          },
          {
            "name": "rotate_turret_left",
            "trigger": "when turret left input is pressed",
            "actions": [
              {
                "action": "rotate turret left at turret rotation speed"
              }
            ]
          },
          {
            "name": "rotate_turret_right",
            "trigger": "when turret right input is pressed",
            "actions": [
              {
                "action": "rotate turret right at turret rotation speed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Tank : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Turret\")]\n    [SerializeField] private Transform _turret;\n    [SerializeField] private float _turretRotationSpeed = 120f;\n    [SerializeField] private Transform _firePoint;\n    \n    [Header(\"Shooting\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 20f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseAiming = true;\n    \n    private Rigidbody _rigidbody;\n    private Camera _mainCamera;\n    private float _lastFireTime;\n    private Vector3 _targetDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _mainCamera = Camera.main;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_turret == null)\n        {\n            Transform turretChild = transform.Find(\"Turret\");\n            if (turretChild != null)\n            {\n                _turret = turretChild;\n            }\n        }\n        \n        if (_firePoint == null && _turret != null)\n        {\n            Transform firePointChild = _turret.Find(\"FirePoint\");\n            if (firePointChild != null)\n            {\n                _firePoint = firePointChild;\n            }\n        }\n        \n        _rigidbody.centerOfMass = Vector3.zero;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleTurretRotation();\n        HandleShooting();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n    }\n    \n    private void HandleInput()\n    {\n        if (_useMouseAiming && _mainCamera != null)\n        {\n            Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit))\n            {\n                Vector3 targetPosition = hit.point;\n                targetPosition.y = _turret.position.y;\n                _targetDirection = (targetPosition - _turret.position).normalized;\n            }\n        }\n        else\n        {\n            float horizontalAim = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(horizontalAim) > 0.1f)\n            {\n                _turret.Rotate(0, horizontalAim * _turretRotationSpeed * Time.deltaTime, 0);\n            }\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        float vertical = Input.GetAxis(\"Vertical\");\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        \n        Vector3 movement = transform.forward * vertical * _moveSpeed;\n        _rigidbody.MovePosition(_rigidbody.position + movement * Time.fixedDeltaTime);\n        \n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            float rotation = horizontal * _rotationSpeed * Time.fixedDeltaTime;\n            Quaternion deltaRotation = Quaternion.Euler(0, rotation, 0);\n            _rigidbody.MoveRotation(_rigidbody.rotation * deltaRotation);\n        }\n    }\n    \n    private void HandleTurretRotation()\n    {\n        if (_turret == null) return;\n        \n        if (_useMouseAiming && _targetDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(_targetDirection);\n            targetRotation = Quaternion.Euler(0, targetRotation.eulerAngles.y, 0);\n            \n            _turret.rotation = Quaternion.RotateTowards(\n                _turret.rotation, \n                targetRotation, \n                _turretRotationSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void HandleShooting()\n    {\n        if (Input.GetKey(_fireKey) && CanFire())\n        {\n            Fire();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n    \n    private void Fire()\n    {\n        if (_projectilePrefab == null || _firePoint == null) return;\n        \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb == null)\n        {\n            projectileRb = projectile.AddComponent<Rigidbody>();\n        }\n        \n        projectileRb.velocity = _firePoint.forward * _projectileSpeed;\n        \n        ProjectileDestroyer destroyer = projectile.GetComponent<ProjectileDestroyer>();\n        if (destroyer == null)\n        {\n            destroyer = projectile.AddComponent<ProjectileDestroyer>();\n        }\n        destroyer.SetLifetime(5f);\n        \n        _lastFireTime = Time.time;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_turret != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_turret.position, 0.5f);\n            \n            if (_firePoint != null)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawWireSphere(_firePoint.position, 0.2f);\n                Gizmos.DrawRay(_firePoint.position, _firePoint.forward * 3f);\n            }\n        }\n        \n        if (_useMouseAiming && _targetDirection != Vector3.zero)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawRay(transform.position, _targetDirection * 5f);\n        }\n    }\n}\n\npublic class ProjectileDestroyer : MonoBehaviour\n{\n    private float _lifetime = 5f;\n    private float _spawnTime;\n    \n    private void Start()\n    {\n        _spawnTime = Time.time;\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _spawnTime + _lifetime)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public void SetLifetime(float lifetime)\n    {\n        _lifetime = lifetime;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\") && !other.isTrigger)\n        {\n            Destroy(gameObject);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "motorcycle with leaning turns",
      "ideal_ir": {
        "class_name": "MotorcycleController",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "acceleration",
            "type": "float",
            "default": 15
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 30
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 80
          },
          {
            "name": "leanAngle",
            "type": "float",
            "default": 45
          },
          {
            "name": "leanSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "currentSpeed",
            "type": "float",
            "default": 0
          },
          {
            "name": "currentLean",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "accelerate_forward",
            "trigger": "when forward input is pressed",
            "actions": [
              {
                "action": "increase speed toward maximum speed using acceleration rate"
              },
              {
                "action": "move motorcycle forward at current speed"
              }
            ]
          },
          {
            "name": "decelerate",
            "trigger": "when no forward input is pressed",
            "actions": [
              {
                "action": "gradually reduce speed to zero"
              }
            ]
          },
          {
            "name": "turn_left_with_lean",
            "trigger": "when left turn input is pressed and motorcycle is moving",
            "actions": [
              {
                "action": "rotate motorcycle left at turn speed based on current speed"
              },
              {
                "action": "lean motorcycle left toward maximum lean angle"
              },
              {
                "action": "smoothly interpolate lean rotation over time"
              }
            ]
          },
          {
            "name": "turn_right_with_lean",
            "trigger": "when right turn input is pressed and motorcycle is moving",
            "actions": [
              {
                "action": "rotate motorcycle right at turn speed based on current speed"
              },
              {
                "action": "lean motorcycle right toward maximum lean angle"
              },
              {
                "action": "smoothly interpolate lean rotation over time"
              }
            ]
          },
          {
            "name": "return_to_upright",
            "trigger": "when no turn input is pressed",
            "actions": [
              {
                "action": "gradually return motorcycle to upright position"
              },
              {
                "action": "smoothly reduce lean angle to zero"
              }
            ]
          },
          {
            "name": "prevent_turning_when_stopped",
            "trigger": "when motorcycle speed is zero",
            "actions": [
              {
                "action": "disable turning and leaning"
              },
              {
                "action": "keep motorcycle upright"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class MotorcycleController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 30f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 15f;\n    [SerializeField] private float _brakeForce = 25f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _reverseSpeed = 10f;\n\n    [Header(\"Leaning Settings\")]\n    [SerializeField] private float _maxLeanAngle = 45f;\n    [SerializeField] private float _leanSpeed = 3f;\n    [SerializeField] private float _leanReturnSpeed = 2f;\n    [SerializeField] private Transform _motorcycleBody;\n\n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _downForce = 100f;\n    [SerializeField] private float _centerOfMassOffset = -0.5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _engineIdleClip;\n    [SerializeField] private AudioClip _engineRevClip;\n    [SerializeField] private float _minPitch = 0.8f;\n    [SerializeField] private float _maxPitch = 2f;\n\n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private float _motorInput;\n    private float _steerInput;\n    private float _currentLeanAngle;\n    private bool _isGrounded;\n    private Vector3 _originalCenterOfMass;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n\n        _originalCenterOfMass = _rigidbody.centerOfMass;\n        _rigidbody.centerOfMass = _originalCenterOfMass + Vector3.up * _centerOfMassOffset;\n\n        if (_motorcycleBody == null)\n        {\n            _motorcycleBody = transform;\n        }\n\n        if (_engineAudioSource == null)\n        {\n            _engineAudioSource = gameObject.AddComponent<AudioSource>();\n            _engineAudioSource.loop = true;\n            _engineAudioSource.playOnAwake = false;\n        }\n\n        if (_engineIdleClip != null)\n        {\n            _engineAudioSource.clip = _engineIdleClip;\n            _engineAudioSource.Play();\n        }\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        CheckGrounded();\n        UpdateEngineAudio();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isGrounded)\n        {\n            HandleMotorcycleMovement();\n            HandleLeaning();\n            ApplyDownForce();\n        }\n    }\n\n    private void HandleInput()\n    {\n        _motorInput = Input.GetAxis(\"Vertical\");\n        _steerInput = Input.GetAxis(\"Horizontal\");\n    }\n\n    private void HandleMotorcycleMovement()\n    {\n        _currentSpeed = Vector3.Dot(_rigidbody.velocity, transform.forward);\n\n        // Forward/Backward movement\n        if (_motorInput > 0)\n        {\n            // Accelerating forward\n            if (_currentSpeed < _maxSpeed)\n            {\n                _rigidbody.AddForce(transform.forward * _motorInput * _acceleration, ForceMode.Acceleration);\n            }\n        }\n        else if (_motorInput < 0)\n        {\n            if (_currentSpeed > 0)\n            {\n                // Braking\n                _rigidbody.AddForce(transform.forward * _motorInput * _brakeForce, ForceMode.Acceleration);\n            }\n            else if (_currentSpeed > -_reverseSpeed)\n            {\n                // Reversing\n                _rigidbody.AddForce(transform.forward * _motorInput * _acceleration * 0.5f, ForceMode.Acceleration);\n            }\n        }\n        else\n        {\n            // Natural deceleration\n            _rigidbody.AddForce(-_rigidbody.velocity * _deceleration * 0.1f, ForceMode.Acceleration);\n        }\n\n        // Steering (only when moving)\n        if (Mathf.Abs(_currentSpeed) > 0.1f && Mathf.Abs(_steerInput) > 0.1f)\n        {\n            float steerAmount = _steerInput * _turnSpeed * (_currentSpeed / _maxSpeed) * Time.fixedDeltaTime;\n            transform.Rotate(0, steerAmount, 0);\n        }\n    }\n\n    private void HandleLeaning()\n    {\n        float targetLeanAngle = 0f;\n\n        // Calculate lean angle based on steering input and speed\n        if (Mathf.Abs(_steerInput) > 0.1f && Mathf.Abs(_currentSpeed) > 1f)\n        {\n            float speedFactor = Mathf.Clamp01(Mathf.Abs(_currentSpeed) / _maxSpeed);\n            targetLeanAngle = -_steerInput * _maxLeanAngle * speedFactor;\n        }\n\n        // Smoothly interpolate to target lean angle\n        float lerpSpeed = Mathf.Abs(targetLeanAngle) > Mathf.Abs(_currentLeanAngle) ? _leanSpeed : _leanReturnSpeed;\n        _currentLeanAngle = Mathf.Lerp(_currentLeanAngle, targetLeanAngle, lerpSpeed * Time.fixedDeltaTime);\n\n        // Apply lean rotation to motorcycle body\n        if (_motorcycleBody != null)\n        {\n            Vector3 currentRotation = _motorcycleBody.localEulerAngles;\n            _motorcycleBody.localRotation = Quaternion.Euler(currentRotation.x, currentRotation.y, _currentLeanAngle);\n        }\n    }\n\n    private void CheckGrounded()\n    {\n        float rayDistance = 1.5f;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, rayDistance, _groundLayer);\n    }\n\n    private void ApplyDownForce()\n    {\n        if (_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.down * _downForce * _rigidbody.velocity.magnitude, ForceMode.Force);\n        }\n    }\n\n    private void UpdateEngineAudio()\n    {\n        if (_engineAudioSource != null)\n        {\n            float speedRatio = Mathf.Abs(_currentSpeed) / _maxSpeed;\n            float inputRatio = Mathf.Abs(_motorInput);\n            \n            float targetPitch = Mathf.Lerp(_minPitch, _maxPitch, Mathf.Max(speedRatio, inputRatio * 0.5f));\n            _engineAudioSource.pitch = Mathf.Lerp(_engineAudioSource.pitch, targetPitch, Time.deltaTime * 3f);\n\n            float targetVolume = Mathf.Lerp(0.3f, 1f, Mathf.Max(speedRatio, inputRatio * 0.3f));\n            _engineAudioSource.volume = Mathf.Lerp(_engineAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n\n            // Switch between idle and rev clips based on input\n            if (_motorInput > 0.1f && _engineRevClip != null && _engineAudioSource.clip != _engineRevClip)\n            {\n                _engineAudioSource.clip = _engineRevClip;\n                _engineAudioSource.Play();\n            }\n            else if (_motorInput <= 0.1f && _engineIdleClip != null && _engineAudioSource.clip != _engineIdleClip)\n            {\n                _engineAudioSource.clip = _engineIdleClip;\n                _engineAudioSource.Play();\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Draw ground check ray\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * 1.5f);\n\n        // Draw center of mass\n        Gizmos.color = Color.yellow;\n        if (_rigidbody != null)\n        {\n            Gizmos.DrawSphere(transform.TransformPoint(_rigidbody.centerOfMass), 0.1f);\n        }\n\n        // Draw lean angle visualization\n        Gizmos.color = Color.blue;\n        Vector3 leanDirection = Quaternion.AngleAxis(_currentLeanAngle, transform.forward) * transform.right;\n        Gizmos.DrawRay(transform.position, leanDirection * 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "spaceship with thrust controls",
      "ideal_ir": {
        "class_name": "Spaceship",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "thrustPower",
            "type": "float",
            "default": 100
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 50
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 20
          }
        ],
        "behaviors": [
          {
            "name": "forward_thrust",
            "trigger": "when thrust input is pressed",
            "actions": [
              {
                "action": "apply forward force based on thrust power"
              },
              {
                "action": "limit velocity to maximum speed"
              }
            ]
          },
          {
            "name": "rotate_left",
            "trigger": "when left rotation input is pressed",
            "actions": [
              {
                "action": "rotate spaceship left at rotation speed"
              }
            ]
          },
          {
            "name": "rotate_right",
            "trigger": "when right rotation input is pressed",
            "actions": [
              {
                "action": "rotate spaceship right at rotation speed"
              }
            ]
          },
          {
            "name": "drift_in_space",
            "trigger": "when no thrust input is active",
            "actions": [
              {
                "action": "maintain current velocity with no additional forces"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SpaceshipController : MonoBehaviour\n{\n    [Header(\"Thrust Settings\")]\n    [SerializeField] private float _thrustForce = 10f;\n    [SerializeField] private float _rotationSpeed = 100f;\n    [SerializeField] private float _maxVelocity = 20f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.W;\n    [SerializeField] private KeyCode _leftRotateKey = KeyCode.A;\n    [SerializeField] private KeyCode _rightRotateKey = KeyCode.D;\n    [SerializeField] private KeyCode _reverseKey = KeyCode.S;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _thrustParticles;\n    [SerializeField] private AudioSource _thrustAudioSource;\n    [SerializeField] private Transform _thrustPoint;\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _drag = 0.98f;\n    [SerializeField] private float _angularDrag = 0.95f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isThrusting;\n    private Vector3 _thrustDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 0f;\n        _rigidbody.angularDrag = 0f;\n        \n        if (_thrustPoint == null)\n        {\n            _thrustPoint = transform;\n        }\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleVisualEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleThrust();\n        HandleRotation();\n        ApplyDrag();\n        ClampVelocity();\n    }\n    \n    private void HandleInput()\n    {\n        _isThrusting = Input.GetKey(_thrustKey) || Input.GetKey(_reverseKey);\n        \n        if (Input.GetKey(_thrustKey))\n        {\n            _thrustDirection = transform.forward;\n        }\n        else if (Input.GetKey(_reverseKey))\n        {\n            _thrustDirection = -transform.forward;\n        }\n        else\n        {\n            _thrustDirection = Vector3.zero;\n        }\n    }\n    \n    private void HandleThrust()\n    {\n        if (_isThrusting && _thrustDirection != Vector3.zero)\n        {\n            Vector3 thrustForceVector = _thrustDirection * _thrustForce;\n            _rigidbody.AddForce(thrustForceVector, ForceMode.Force);\n        }\n    }\n    \n    private void HandleRotation()\n    {\n        float rotationInput = 0f;\n        \n        if (Input.GetKey(_leftRotateKey))\n        {\n            rotationInput = -1f;\n        }\n        else if (Input.GetKey(_rightRotateKey))\n        {\n            rotationInput = 1f;\n        }\n        \n        if (Mathf.Abs(rotationInput) > 0.1f)\n        {\n            Vector3 torque = transform.up * rotationInput * _rotationSpeed;\n            _rigidbody.AddTorque(torque, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyDrag()\n    {\n        _rigidbody.velocity *= _drag;\n        _rigidbody.angularVelocity *= _angularDrag;\n    }\n    \n    private void ClampVelocity()\n    {\n        if (_rigidbody.velocity.magnitude > _maxVelocity)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxVelocity;\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        if (_thrustParticles != null)\n        {\n            if (_isThrusting && Input.GetKey(_thrustKey))\n            {\n                if (!_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Play();\n                }\n            }\n            else\n            {\n                if (_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Stop();\n                }\n            }\n        }\n        \n        if (_thrustAudioSource != null)\n        {\n            if (_isThrusting)\n            {\n                if (!_thrustAudioSource.isPlaying)\n                {\n                    _thrustAudioSource.Play();\n                }\n            }\n            else\n            {\n                if (_thrustAudioSource.isPlaying)\n                {\n                    _thrustAudioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    public void SetThrustForce(float force)\n    {\n        _thrustForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetMaxVelocity(float maxVel)\n    {\n        _maxVelocity = Mathf.Max(0f, maxVel);\n    }\n    \n    public Vector3 GetVelocity()\n    {\n        return _rigidbody != null ? _rigidbody.velocity : Vector3.zero;\n    }\n    \n    public float GetSpeed()\n    {\n        return _rigidbody != null ? _rigidbody.velocity.magnitude : 0f;\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    private void OnValidate()\n    {\n        _thrustForce = Mathf.Max(0f, _thrustForce);\n        _rotationSpeed = Mathf.Max(0f, _rotationSpeed);\n        _maxVelocity = Mathf.Max(0f, _maxVelocity);\n        _drag = Mathf.Clamp01(_drag);\n        _angularDrag = Mathf.Clamp01(_angularDrag);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "minecart on rails",
      "ideal_ir": {
        "class_name": "Minecart",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "speed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "brakeForce",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "isOccupied",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentRail",
            "type": "Transform",
            "default": null
          },
          {
            "name": "railDetectionDistance",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "wheelRotationSpeed",
            "type": "float",
            "default": 360.0
          }
        ],
        "behaviors": [
          {
            "name": "follow_rails",
            "trigger": "when minecart is on rails and moving",
            "actions": [
              {
                "action": "align minecart direction with rail direction"
              },
              {
                "action": "move forward along the rail path"
              },
              {
                "action": "maintain position centered on rails"
              }
            ]
          },
          {
            "name": "detect_rail_changes",
            "trigger": "when approaching rail junction or curve",
            "actions": [
              {
                "action": "scan for next rail segment ahead"
              },
              {
                "action": "smoothly transition to new rail direction"
              },
              {
                "action": "adjust speed based on curve sharpness"
              }
            ]
          },
          {
            "name": "accelerate_downhill",
            "trigger": "when rail slopes downward",
            "actions": [
              {
                "action": "increase speed gradually due to gravity"
              },
              {
                "action": "clamp speed to maximum allowed"
              },
              {
                "action": "play acceleration sound effects"
              }
            ]
          },
          {
            "name": "brake_uphill",
            "trigger": "when rail slopes upward",
            "actions": [
              {
                "action": "reduce speed due to gravity resistance"
              },
              {
                "action": "apply additional braking force if needed"
              },
              {
                "action": "prevent rolling backward"
              }
            ]
          },
          {
            "name": "handle_passenger_boarding",
            "trigger": "when player interacts with stationary minecart",
            "actions": [
              {
                "action": "set player as passenger"
              },
              {
                "action": "attach player to minecart seat"
              },
              {
                "action": "mark minecart as occupied"
              },
              {
                "action": "enable player controls for minecart"
              }
            ]
          },
          {
            "name": "handle_passenger_exit",
            "trigger": "when occupied and player presses exit key",
            "actions": [
              {
                "action": "detach player from minecart"
              },
              {
                "action": "place player safely beside rails"
              },
              {
                "action": "mark minecart as unoccupied"
              },
              {
                "action": "gradually slow minecart to stop"
              }
            ]
          },
          {
            "name": "animate_wheels",
            "trigger": "when minecart is moving",
            "actions": [
              {
                "action": "rotate wheel objects based on movement speed"
              },
              {
                "action": "sync wheel rotation with forward motion"
              },
              {
                "action": "stop wheel animation when stationary"
              }
            ]
          },
          {
            "name": "play_movement_sounds",
            "trigger": "when minecart is in motion",
            "actions": [
              {
                "action": "play rolling wheel sounds on rails"
              },
              {
                "action": "adjust sound pitch based on speed"
              },
              {
                "action": "play creaking sounds during turns"
              }
            ]
          },
          {
            "name": "handle_rail_end",
            "trigger": "when reaching end of rail track",
            "actions": [
              {
                "action": "gradually reduce speed to zero"
              },
              {
                "action": "prevent minecart from leaving rails"
              },
              {
                "action": "play stopping sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MinecartController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 10f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 3f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _railDetectionDistance = 2f;\n    \n    [Header(\"Rail Following\")]\n    [SerializeField] private LayerMask _railLayerMask = 1;\n    [SerializeField] private float _railSnapDistance = 0.5f;\n    [SerializeField] private float _turnSpeed = 180f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _mass = 100f;\n    [SerializeField] private float _friction = 0.1f;\n    [SerializeField] private float _airResistance = 0.05f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rollingSound;\n    [SerializeField] private AudioClip _brakeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerEnter;\n    public UnityEvent OnPlayerExit;\n    public UnityEvent OnMaxSpeedReached;\n    \n    private Rigidbody _rigidbody;\n    private bool _hasPlayer = false;\n    private float _currentSpeed = 0f;\n    private Vector3 _currentDirection = Vector3.forward;\n    private RaycastHit _railHit;\n    private bool _isOnRails = true;\n    private float _inputAcceleration = 0f;\n    private bool _isBraking = false;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        DetectRails();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isOnRails)\n        {\n            MoveOnRails();\n        }\n        else\n        {\n            ApplyGravity();\n        }\n        \n        ApplyResistance();\n        UpdateRigidbody();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_hasPlayer) return;\n        \n        _inputAcceleration = 0f;\n        _isBraking = false;\n        \n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n        {\n            _inputAcceleration = 1f;\n        }\n        else if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n        {\n            _inputAcceleration = -1f;\n        }\n        \n        if (Input.GetKey(KeyCode.Space))\n        {\n            _isBraking = true;\n        }\n    }\n    \n    private void DetectRails()\n    {\n        Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;\n        Vector3 rayDirection = Vector3.down;\n        \n        _isOnRails = Physics.Raycast(rayOrigin, rayDirection, out _railHit, _railDetectionDistance, _railLayerMask);\n        \n        if (_isOnRails)\n        {\n            SnapToRail();\n            UpdateDirection();\n        }\n    }\n    \n    private void SnapToRail()\n    {\n        Vector3 targetPosition = _railHit.point + Vector3.up * 0.1f;\n        float snapDistance = Vector3.Distance(transform.position, targetPosition);\n        \n        if (snapDistance > _railSnapDistance)\n        {\n            transform.position = Vector3.Lerp(transform.position, targetPosition, Time.fixedDeltaTime * 10f);\n        }\n    }\n    \n    private void UpdateDirection()\n    {\n        Vector3 railForward = Vector3.Cross(_railHit.normal, transform.right).normalized;\n        if (Vector3.Dot(railForward, _currentDirection) < 0)\n        {\n            railForward = -railForward;\n        }\n        \n        _currentDirection = Vector3.Slerp(_currentDirection, railForward, Time.fixedDeltaTime * _turnSpeed);\n        transform.rotation = Quaternion.LookRotation(_currentDirection, _railHit.normal);\n    }\n    \n    private void MoveOnRails()\n    {\n        float targetSpeed = _currentSpeed;\n        \n        if (_isBraking)\n        {\n            targetSpeed = Mathf.Max(0f, _currentSpeed - _deceleration * Time.fixedDeltaTime);\n        }\n        else if (_inputAcceleration != 0f)\n        {\n            targetSpeed = _currentSpeed + _inputAcceleration * _acceleration * Time.fixedDeltaTime;\n        }\n        else\n        {\n            float slopeInfluence = Vector3.Dot(_currentDirection, Vector3.down) * _gravity * 0.1f;\n            targetSpeed = _currentSpeed + slopeInfluence * Time.fixedDeltaTime;\n        }\n        \n        _currentSpeed = Mathf.Clamp(targetSpeed, -_maxSpeed, _maxSpeed);\n        \n        if (Mathf.Abs(_currentSpeed) >= _maxSpeed * 0.95f && !_isBraking)\n        {\n            OnMaxSpeedReached?.Invoke();\n        }\n    }\n    \n    private void ApplyGravity()\n    {\n        _rigidbody.AddForce(Vector3.down * _gravity * _mass, ForceMode.Force);\n    }\n    \n    private void ApplyResistance()\n    {\n        float frictionForce = _friction * _mass * _gravity;\n        float airResistanceForce = _airResistance * _currentSpeed * _currentSpeed;\n        \n        float totalResistance = frictionForce + airResistanceForce;\n        \n        if (_currentSpeed > 0)\n        {\n            _currentSpeed = Mathf.Max(0f, _currentSpeed - totalResistance * Time.fixedDeltaTime);\n        }\n        else if (_currentSpeed < 0)\n        {\n            _currentSpeed = Mathf.Min(0f, _currentSpeed + totalResistance * Time.fixedDeltaTime);\n        }\n    }\n    \n    private void UpdateRigidbody()\n    {\n        if (_isOnRails)\n        {\n            Vector3 velocity = _currentDirection * _currentSpeed;\n            _rigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rollingSound != null && _audioSource != null)\n        {\n            if (Mathf.Abs(_currentSpeed) > 0.1f)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _rollingSound;\n                    _audioSource.Play();\n                }\n                \n                _audioSource.pitch = Mathf.Lerp(0.5f, 2f, Mathf.Abs(_currentSpeed) / _maxSpeed);\n                _audioSource.volume = Mathf.Lerp(0.1f, 1f, Mathf.Abs(_currentSpeed) / _maxSpeed);\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n        \n        if (_isBraking && _brakeSound != null && _audioSource != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _brakeSound)\n            {\n                _audioSource.PlayOneShot(_brakeSound);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _hasPlayer = true;\n            OnPlayerEnter?.Invoke();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _hasPlayer = false;\n            OnPlayerExit?.Invoke();\n        }\n    }\n    \n    public void SetSpeed(float speed)\n    {\n        _currentSpeed = Mathf.Clamp(speed, -_maxSpeed, _maxSpeed);\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsOnRails()\n    {\n        return _isOnRails;\n    }\n    \n    public void EmergencyStop()\n    {\n        _currentSpeed = 0f;\n        _rigidbody.velocity = Vector3.zero;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position + Vector3.up * 0.1f, Vector3.down * _railDetectionDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n        \n        if (_isOnRails)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawSphere(_railHit.point, 0.1f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "door that opens on approach",
      "ideal_ir": {
        "class_name": "AutoDoor",
        "components": [
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isOpen",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "open_door_on_approach",
            "trigger": "when player enters detection radius and door is closed",
            "actions": [
              {
                "action": "play door opening animation"
              },
              {
                "action": "set door state to open"
              }
            ]
          },
          {
            "name": "close_door_on_exit",
            "trigger": "when player leaves detection radius and door is open",
            "actions": [
              {
                "action": "play door closing animation"
              },
              {
                "action": "set door state to closed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ProximityDoor : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private float _detectionRange = 3f;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private float _closeSpeed = 1f;\n    [SerializeField] private Vector3 _openOffset = new Vector3(0, 3f, 0);\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Door Components\")]\n    [SerializeField] private Transform _doorTransform;\n    [SerializeField] private Collider _doorCollider;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorClosed;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        InitializeDoor();\n    }\n    \n    private void InitializeDoor()\n    {\n        if (_doorTransform == null)\n            _doorTransform = transform;\n            \n        _closedPosition = _doorTransform.localPosition;\n        _openPosition = _closedPosition + _openOffset;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleDoorMovement();\n    }\n    \n    private void CheckForPlayer()\n    {\n        bool playerWasInRange = _playerInRange;\n        _playerInRange = false;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n                break;\n            }\n        }\n        \n        if (_playerInRange && !playerWasInRange)\n        {\n            OpenDoor();\n        }\n        else if (!_playerInRange && playerWasInRange)\n        {\n            CloseDoor();\n        }\n    }\n    \n    private void HandleDoorMovement()\n    {\n        if (!_isMoving) return;\n        \n        Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n        float speed = _isOpen ? _openSpeed : _closeSpeed;\n        \n        _doorTransform.localPosition = Vector3.MoveTowards(\n            _doorTransform.localPosition, \n            targetPosition, \n            speed * Time.deltaTime\n        );\n        \n        if (Vector3.Distance(_doorTransform.localPosition, targetPosition) < 0.01f)\n        {\n            _doorTransform.localPosition = targetPosition;\n            _isMoving = false;\n            \n            if (_doorCollider != null)\n                _doorCollider.enabled = !_isOpen;\n        }\n    }\n    \n    private void OpenDoor()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        PlaySound(_openSound);\n        OnDoorOpened?.Invoke();\n    }\n    \n    private void CloseDoor()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _isMoving = true;\n        \n        PlaySound(_closeSound);\n        OnDoorClosed?.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_doorTransform != null)\n        {\n            Gizmos.color = Color.green;\n            Vector3 openPos = transform.TransformPoint(_closedPosition + _openOffset);\n            Gizmos.DrawWireCube(openPos, _doorTransform.localScale);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "chest that contains random loot",
      "ideal_ir": {
        "class_name": "LootChest",
        "components": [
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isOpened",
            "type": "bool",
            "default": false
          },
          {
            "name": "lootItems",
            "type": "GameObject[]",
            "default": null
          },
          {
            "name": "minLootCount",
            "type": "int",
            "default": 1
          },
          {
            "name": "maxLootCount",
            "type": "int",
            "default": 3
          },
          {
            "name": "openSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "chestLid",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "open_chest",
            "trigger": "when player interacts with chest and chest is not already opened",
            "actions": [
              {
                "action": "mark chest as opened"
              },
              {
                "action": "play chest opening sound"
              },
              {
                "action": "rotate chest lid upward to open position"
              },
              {
                "action": "generate random number of loot items between minimum and maximum count"
              },
              {
                "action": "randomly select loot items from available loot array"
              },
              {
                "action": "spawn selected loot items above chest position"
              },
              {
                "action": "apply random scatter force to spawned loot items"
              }
            ]
          },
          {
            "name": "prevent_reopening",
            "trigger": "when player tries to interact with chest that is already opened",
            "actions": [
              {
                "action": "do nothing and ignore interaction"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class LootChest : MonoBehaviour\n{\n    [System.Serializable]\n    public class LootItem\n    {\n        public GameObject itemPrefab;\n        public int minQuantity = 1;\n        public int maxQuantity = 1;\n        [Range(0f, 100f)]\n        public float dropChance = 100f;\n    }\n\n    [Header(\"Chest Settings\")]\n    [SerializeField] private bool _isOpen = false;\n    [SerializeField] private bool _canReopen = false;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Loot Configuration\")]\n    [SerializeField] private List<LootItem> _possibleLoot = new List<LootItem>();\n    [SerializeField] private int _minItemsToSpawn = 1;\n    [SerializeField] private int _maxItemsToSpawn = 3;\n    [SerializeField] private float _lootSpawnRadius = 1.5f;\n    [SerializeField] private float _lootSpawnForce = 5f;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Animator _chestAnimator;\n    [SerializeField] private ParticleSystem _openEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _alreadyOpenSound;\n\n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n\n    [Header(\"Events\")]\n    public UnityEvent OnChestOpened;\n    public UnityEvent OnChestAlreadyOpen;\n\n    private Transform _player;\n    private bool _playerInRange = false;\n\n    private void Start()\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n\n        if (_chestAnimator == null)\n            _chestAnimator = GetComponent<Animator>();\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        UpdateChestVisuals();\n    }\n\n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInteraction();\n    }\n\n    private void CheckForPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _player = player.transform;\n            float distance = Vector3.Distance(transform.position, _player.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _interactionRange;\n\n            if (_playerInRange != wasInRange)\n            {\n                UpdateInteractionPrompt();\n            }\n        }\n        else\n        {\n            if (_playerInRange)\n            {\n                _playerInRange = false;\n                UpdateInteractionPrompt();\n            }\n        }\n    }\n\n    private void HandleInteraction()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            OpenChest();\n        }\n    }\n\n    private void UpdateInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            bool shouldShow = _playerInRange && (!_isOpen || _canReopen);\n            _interactionPrompt.SetActive(shouldShow);\n        }\n    }\n\n    public void OpenChest()\n    {\n        if (_isOpen && !_canReopen)\n        {\n            PlayAlreadyOpenFeedback();\n            return;\n        }\n\n        _isOpen = true;\n        UpdateChestVisuals();\n        SpawnLoot();\n        PlayOpenEffects();\n        OnChestOpened?.Invoke();\n        UpdateInteractionPrompt();\n    }\n\n    private void SpawnLoot()\n    {\n        if (_possibleLoot.Count == 0) return;\n\n        int itemsToSpawn = Random.Range(_minItemsToSpawn, _maxItemsToSpawn + 1);\n        \n        for (int i = 0; i < itemsToSpawn; i++)\n        {\n            LootItem selectedLoot = SelectRandomLoot();\n            if (selectedLoot != null && selectedLoot.itemPrefab != null)\n            {\n                SpawnLootItem(selectedLoot);\n            }\n        }\n    }\n\n    private LootItem SelectRandomLoot()\n    {\n        List<LootItem> availableLoot = new List<LootItem>();\n        \n        foreach (LootItem loot in _possibleLoot)\n        {\n            if (Random.Range(0f, 100f) <= loot.dropChance)\n            {\n                availableLoot.Add(loot);\n            }\n        }\n\n        if (availableLoot.Count == 0) return null;\n        \n        return availableLoot[Random.Range(0, availableLoot.Count)];\n    }\n\n    private void SpawnLootItem(LootItem lootItem)\n    {\n        int quantity = Random.Range(lootItem.minQuantity, lootItem.maxQuantity + 1);\n        \n        for (int i = 0; i < quantity; i++)\n        {\n            Vector3 spawnPosition = GetRandomSpawnPosition();\n            GameObject spawnedItem = Instantiate(lootItem.itemPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody rb = spawnedItem.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 randomDirection = Random.insideUnitSphere;\n                randomDirection.y = Mathf.Abs(randomDirection.y);\n                rb.AddForce(randomDirection * _lootSpawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n\n    private Vector3 GetRandomSpawnPosition()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _lootSpawnRadius;\n        Vector3 spawnOffset = new Vector3(randomCircle.x, 1f, randomCircle.y);\n        return transform.position + spawnOffset;\n    }\n\n    private void UpdateChestVisuals()\n    {\n        if (_chestAnimator != null)\n        {\n            _chestAnimator.SetBool(\"IsOpen\", _isOpen);\n        }\n    }\n\n    private void PlayOpenEffects()\n    {\n        if (_openEffect != null)\n        {\n            _openEffect.Play();\n        }\n\n        if (_audioSource != null && _openSound != null)\n        {\n            _audioSource.PlayOneShot(_openSound);\n        }\n    }\n\n    private void PlayAlreadyOpenFeedback()\n    {\n        if (_audioSource != null && _alreadyOpenSound != null)\n        {\n            _audioSource.PlayOneShot(_alreadyOpenSound);\n        }\n\n        OnChestAlreadyOpen?.Invoke();\n    }\n\n    public void ResetChest()\n    {\n        _isOpen = false;\n        UpdateChestVisuals();\n        UpdateInteractionPrompt();\n    }\n\n    public void AddLootItem(GameObject itemPrefab, int minQty = 1, int maxQty = 1, float chance = 100f)\n    {\n        LootItem newLoot = new LootItem\n        {\n            itemPrefab = itemPrefab,\n            minQuantity = minQty,\n            maxQuantity = maxQty,\n            dropChance = chance\n        };\n        _possibleLoot.Add(newLoot);\n    }\n\n    public void ClearLoot()\n    {\n        _possibleLoot.Clear();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _lootSpawnRadius);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "lever that activates mechanism",
      "ideal_ir": {
        "class_name": "ActivationLever",
        "components": [
          "Transform",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "rotationAngle",
            "type": "float",
            "default": 45
          },
          {
            "name": "activationSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "mechanismToActivate",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "activate_lever",
            "trigger": "when player interacts with lever",
            "actions": [
              {
                "action": "rotate lever to activated position"
              },
              {
                "action": "play activation sound effect"
              },
              {
                "action": "set activation state to true"
              },
              {
                "action": "send activation signal to connected mechanism"
              }
            ]
          },
          {
            "name": "deactivate_lever",
            "trigger": "when player interacts with activated lever",
            "actions": [
              {
                "action": "rotate lever back to default position"
              },
              {
                "action": "play deactivation sound effect"
              },
              {
                "action": "set activation state to false"
              },
              {
                "action": "send deactivation signal to connected mechanism"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Lever : MonoBehaviour\n{\n    [Header(\"Lever Settings\")]\n    [SerializeField] private bool _isActivated = false;\n    [SerializeField] private bool _canBeToggled = true;\n    [SerializeField] private float _activationDistance = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Transform _leverHandle;\n    [SerializeField] private float _rotationAngle = 45f;\n    [SerializeField] private float _animationSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Light _indicatorLight;\n    [SerializeField] private Color _activeColor = Color.green;\n    [SerializeField] private Color _inactiveColor = Color.red;\n    [SerializeField] private ParticleSystem _activationEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLeverActivated;\n    public UnityEvent OnLeverDeactivated;\n    public UnityEvent<bool> OnLeverStateChanged;\n    \n    private Transform _player;\n    private bool _playerInRange = false;\n    private Vector3 _originalRotation;\n    private Vector3 _targetRotation;\n    private bool _isAnimating = false;\n    \n    private void Start()\n    {\n        if (_leverHandle != null)\n        {\n            _originalRotation = _leverHandle.localEulerAngles;\n            _targetRotation = _originalRotation;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        UpdateVisualState();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n        AnimateLever();\n    }\n    \n    private void CheckForPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _player = player.transform;\n            float distance = Vector3.Distance(transform.position, _player.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _activationDistance;\n            \n            if (_playerInRange != wasInRange)\n            {\n                if (_interactionPrompt != null)\n                    _interactionPrompt.SetActive(_playerInRange);\n            }\n        }\n        else\n        {\n            _playerInRange = false;\n            if (_interactionPrompt != null)\n                _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey) && !_isAnimating)\n        {\n            if (_canBeToggled || !_isActivated)\n            {\n                ToggleLever();\n            }\n        }\n    }\n    \n    private void AnimateLever()\n    {\n        if (_leverHandle != null && _isAnimating)\n        {\n            _leverHandle.localEulerAngles = Vector3.Lerp(_leverHandle.localEulerAngles, _targetRotation, Time.deltaTime * _animationSpeed);\n            \n            if (Vector3.Distance(_leverHandle.localEulerAngles, _targetRotation) < 0.1f)\n            {\n                _leverHandle.localEulerAngles = _targetRotation;\n                _isAnimating = false;\n            }\n        }\n    }\n    \n    public void ToggleLever()\n    {\n        if (_isAnimating) return;\n        \n        _isActivated = !_isActivated;\n        UpdateLeverState();\n    }\n    \n    public void ActivateLever()\n    {\n        if (_isActivated || _isAnimating) return;\n        \n        _isActivated = true;\n        UpdateLeverState();\n    }\n    \n    public void DeactivateLever()\n    {\n        if (!_isActivated || _isAnimating) return;\n        \n        _isActivated = false;\n        UpdateLeverState();\n    }\n    \n    private void UpdateLeverState()\n    {\n        if (_leverHandle != null)\n        {\n            _targetRotation = _originalRotation + (_isActivated ? Vector3.forward * _rotationAngle : Vector3.zero);\n            _isAnimating = true;\n        }\n        \n        PlaySound();\n        UpdateVisualState();\n        TriggerEffects();\n        InvokeEvents();\n    }\n    \n    private void PlaySound()\n    {\n        if (_audioSource != null)\n        {\n            AudioClip clipToPlay = _isActivated ? _activationSound : _deactivationSound;\n            if (clipToPlay != null)\n            {\n                _audioSource.PlayOneShot(clipToPlay);\n            }\n        }\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.color = _isActivated ? _activeColor : _inactiveColor;\n            _indicatorLight.enabled = _isActivated;\n        }\n    }\n    \n    private void TriggerEffects()\n    {\n        if (_activationEffect != null && _isActivated)\n        {\n            _activationEffect.Play();\n        }\n    }\n    \n    private void InvokeEvents()\n    {\n        if (_isActivated)\n        {\n            OnLeverActivated?.Invoke();\n        }\n        else\n        {\n            OnLeverDeactivated?.Invoke();\n        }\n        \n        OnLeverStateChanged?.Invoke(_isActivated);\n    }\n    \n    public bool IsActivated()\n    {\n        return _isActivated;\n    }\n    \n    public void SetCanBeToggled(bool canToggle)\n    {\n        _canBeToggled = canToggle;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _activationDistance);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "button that triggers event once",
      "ideal_ir": {
        "class_name": "OneTimeButton",
        "components": [
          "Button"
        ],
        "fields": [
          {
            "name": "hasBeenPressed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "trigger_event_once",
            "trigger": "when button is clicked and has not been pressed before",
            "actions": [
              {
                "action": "invoke button click event"
              },
              {
                "action": "mark button as having been pressed"
              },
              {
                "action": "disable button interaction"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.UI;\n\npublic class OneTimeButton : MonoBehaviour\n{\n    [Header(\"Button Settings\")]\n    [SerializeField] private Button _button;\n    [SerializeField] private bool _disableAfterUse = true;\n    [SerializeField] private bool _hideAfterUse = false;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private string _usedText = \"Used\";\n    [SerializeField] private Color _disabledColor = Color.gray;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onButtonPressed;\n    \n    private bool _hasBeenUsed = false;\n    private Text _buttonText;\n    private Image _buttonImage;\n    private string _originalText;\n    private Color _originalColor;\n    \n    private void Awake()\n    {\n        if (_button == null)\n            _button = GetComponent<Button>();\n            \n        if (_button != null)\n        {\n            _buttonText = _button.GetComponentInChildren<Text>();\n            _buttonImage = _button.GetComponent<Image>();\n            \n            if (_buttonText != null)\n                _originalText = _buttonText.text;\n                \n            if (_buttonImage != null)\n                _originalColor = _buttonImage.color;\n        }\n    }\n    \n    private void Start()\n    {\n        if (_button != null)\n        {\n            _button.onClick.AddListener(OnButtonClick);\n        }\n    }\n    \n    private void OnButtonClick()\n    {\n        if (_hasBeenUsed) return;\n        \n        _hasBeenUsed = true;\n        _onButtonPressed?.Invoke();\n        \n        HandlePostClickBehavior();\n    }\n    \n    private void HandlePostClickBehavior()\n    {\n        if (_button == null) return;\n        \n        if (_disableAfterUse)\n        {\n            _button.interactable = false;\n            \n            if (_buttonImage != null)\n                _buttonImage.color = _disabledColor;\n        }\n        \n        if (_buttonText != null && !string.IsNullOrEmpty(_usedText))\n        {\n            _buttonText.text = _usedText;\n        }\n        \n        if (_hideAfterUse)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n    \n    public void ResetButton()\n    {\n        _hasBeenUsed = false;\n        \n        if (_button != null)\n        {\n            _button.interactable = true;\n            \n            if (_buttonImage != null)\n                _buttonImage.color = _originalColor;\n        }\n        \n        if (_buttonText != null && !string.IsNullOrEmpty(_originalText))\n        {\n            _buttonText.text = _originalText;\n        }\n        \n        if (!gameObject.activeInHierarchy)\n        {\n            gameObject.SetActive(true);\n        }\n    }\n    \n    public bool HasBeenUsed => _hasBeenUsed;\n    \n    private void OnDestroy()\n    {\n        if (_button != null)\n        {\n            _button.onClick.RemoveListener(OnButtonClick);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "NPC with dialogue options",
      "ideal_ir": {
        "class_name": "DialogueNPC",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "dialogueOptions",
            "type": "string[]",
            "default": [
              "Hello there!",
              "How can I help you?",
              "Goodbye!"
            ]
          },
          {
            "name": "currentDialogueIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "isInConversation",
            "type": "bool",
            "default": false
          },
          {
            "name": "interactionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "conversationCooldown",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "lastInteractionTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "start_dialogue",
            "trigger": "when player enters interaction range and presses interaction key",
            "actions": [
              {
                "action": "set conversation state to active"
              },
              {
                "action": "display first dialogue option to player"
              },
              {
                "action": "face toward player"
              },
              {
                "action": "record current interaction time"
              }
            ]
          },
          {
            "name": "cycle_dialogue",
            "trigger": "when in conversation and player presses interaction key again",
            "actions": [
              {
                "action": "advance to next dialogue option"
              },
              {
                "action": "display current dialogue text"
              },
              {
                "action": "reset to first option if reached end of dialogue list"
              }
            ]
          },
          {
            "name": "end_conversation",
            "trigger": "when player moves outside interaction range or after cooldown period",
            "actions": [
              {
                "action": "set conversation state to inactive"
              },
              {
                "action": "hide dialogue display"
              },
              {
                "action": "reset dialogue index to beginning"
              },
              {
                "action": "return to idle animation"
              }
            ]
          },
          {
            "name": "show_interaction_prompt",
            "trigger": "when player is within interaction range and not in conversation",
            "actions": [
              {
                "action": "display interaction prompt above NPC"
              },
              {
                "action": "highlight NPC with outline or glow effect"
              }
            ]
          },
          {
            "name": "hide_interaction_prompt",
            "trigger": "when player moves outside interaction range",
            "actions": [
              {
                "action": "hide interaction prompt"
              },
              {
                "action": "remove highlight effect from NPC"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class DialogueNPC : MonoBehaviour\n{\n    [System.Serializable]\n    public class DialogueOption\n    {\n        [TextArea(2, 4)]\n        public string optionText;\n        [TextArea(3, 6)]\n        public string responseText;\n        public bool endsConversation;\n        public UnityEvent onOptionSelected;\n    }\n\n    [System.Serializable]\n    public class DialogueSequence\n    {\n        [TextArea(3, 6)]\n        public string initialText;\n        public List<DialogueOption> options = new List<DialogueOption>();\n    }\n\n    [Header(\"NPC Settings\")]\n    [SerializeField] private string _npcName = \"NPC\";\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Dialogue Content\")]\n    [SerializeField] private List<DialogueSequence> _dialogueSequences = new List<DialogueSequence>();\n    [SerializeField] private int _currentSequenceIndex = 0;\n    [SerializeField] private bool _canRepeatDialogue = true;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _dialogueCanvas;\n    [SerializeField] private Text _npcNameText;\n    [SerializeField] private Text _dialogueText;\n    [SerializeField] private Transform _optionsParent;\n    [SerializeField] private Button _optionButtonPrefab;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Interaction Prompt\")]\n    [SerializeField] private Canvas _promptCanvas;\n    [SerializeField] private Text _promptText;\n\n    [Header(\"Events\")]\n    public UnityEvent OnDialogueStart;\n    public UnityEvent OnDialogueEnd;\n\n    private Transform _player;\n    private bool _playerInRange = false;\n    private bool _dialogueActive = false;\n    private List<Button> _currentOptionButtons = new List<Button>();\n\n    private void Start()\n    {\n        InitializeUI();\n        SetupDefaultDialogue();\n    }\n\n    private void Update()\n    {\n        CheckPlayerDistance();\n        HandleInput();\n    }\n\n    private void InitializeUI()\n    {\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(false);\n\n        if (_promptCanvas != null)\n            _promptCanvas.gameObject.SetActive(false);\n\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(EndDialogue);\n\n        if (_npcNameText != null)\n            _npcNameText.text = _npcName;\n\n        if (_promptText != null)\n            _promptText.text = $\"Press {_interactionKey} to talk\";\n    }\n\n    private void SetupDefaultDialogue()\n    {\n        if (_dialogueSequences.Count == 0)\n        {\n            DialogueSequence defaultSequence = new DialogueSequence();\n            defaultSequence.initialText = \"Hello there! How can I help you?\";\n            \n            DialogueOption option1 = new DialogueOption();\n            option1.optionText = \"Just looking around.\";\n            option1.responseText = \"Feel free to explore! Let me know if you need anything.\";\n            option1.endsConversation = true;\n            \n            DialogueOption option2 = new DialogueOption();\n            option2.optionText = \"What is this place?\";\n            option2.responseText = \"This is a peaceful village where travelers often stop to rest.\";\n            option2.endsConversation = false;\n            \n            defaultSequence.options.Add(option1);\n            defaultSequence.options.Add(option2);\n            _dialogueSequences.Add(defaultSequence);\n        }\n    }\n\n    private void CheckPlayerDistance()\n    {\n        if (_player == null)\n        {\n            GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObj != null)\n                _player = playerObj.transform;\n            return;\n        }\n\n        float distance = Vector3.Distance(transform.position, _player.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange;\n\n        if (_playerInRange && !wasInRange)\n            ShowPrompt();\n        else if (!_playerInRange && wasInRange)\n            HidePrompt();\n    }\n\n    private void HandleInput()\n    {\n        if (_playerInRange && !_dialogueActive && Input.GetKeyDown(_interactionKey))\n        {\n            StartDialogue();\n        }\n    }\n\n    private void ShowPrompt()\n    {\n        if (_promptCanvas != null && !_dialogueActive)\n            _promptCanvas.gameObject.SetActive(true);\n    }\n\n    private void HidePrompt()\n    {\n        if (_promptCanvas != null)\n            _promptCanvas.gameObject.SetActive(false);\n    }\n\n    public void StartDialogue()\n    {\n        if (_dialogueActive || _dialogueSequences.Count == 0)\n            return;\n\n        _dialogueActive = true;\n        HidePrompt();\n\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(true);\n\n        DisplayCurrentSequence();\n        OnDialogueStart?.Invoke();\n\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n\n    private void DisplayCurrentSequence()\n    {\n        if (_currentSequenceIndex >= _dialogueSequences.Count)\n        {\n            if (_canRepeatDialogue)\n                _currentSequenceIndex = 0;\n            else\n            {\n                EndDialogue();\n                return;\n            }\n        }\n\n        DialogueSequence currentSequence = _dialogueSequences[_currentSequenceIndex];\n        \n        if (_dialogueText != null)\n            _dialogueText.text = currentSequence.initialText;\n\n        ClearOptionButtons();\n        CreateOptionButtons(currentSequence.options);\n    }\n\n    private void ClearOptionButtons()\n    {\n        foreach (Button button in _currentOptionButtons)\n        {\n            if (button != null)\n                DestroyImmediate(button.gameObject);\n        }\n        _currentOptionButtons.Clear();\n    }\n\n    private void CreateOptionButtons(List<DialogueOption> options)\n    {\n        if (_optionsParent == null || _optionButtonPrefab == null)\n            return;\n\n        for (int i = 0; i < options.Count; i++)\n        {\n            DialogueOption option = options[i];\n            Button optionButton = Instantiate(_optionButtonPrefab, _optionsParent);\n            \n            Text buttonText = optionButton.GetComponentInChildren<Text>();\n            if (buttonText != null)\n                buttonText.text = option.optionText;\n\n            int optionIndex = i;\n            optionButton.onClick.AddListener(() => SelectOption(optionIndex));\n            \n            _currentOptionButtons.Add(optionButton);\n        }\n    }\n\n    private void SelectOption(int optionIndex)\n    {\n        if (_currentSequenceIndex >= _dialogueSequences.Count)\n            return;\n\n        DialogueSequence currentSequence = _dialogueSequences[_currentSequenceIndex];\n        if (optionIndex >= currentSequence.options.Count)\n            return;\n\n        DialogueOption selectedOption = currentSequence.options[optionIndex];\n        \n        if (_dialogueText != null)\n            _dialogueText.text = selectedOption.responseText;\n\n        selectedOption.onOptionSelected?.Invoke();\n\n        ClearOptionButtons();\n\n        if (selectedOption.endsConversation)\n        {\n            Invoke(nameof(EndDialogue), 2f);\n        }\n        else\n        {\n            _currentSequenceIndex++;\n            Invoke(nameof(DisplayCurrentSequence), 2f);\n        }\n    }\n\n    public void EndDialogue()\n    {\n        if (!_dialogueActive)\n            return;\n\n        _dialogueActive = false;\n        ClearOptionButtons();\n\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(false);\n\n        if (_playerInRange)\n            ShowPrompt();\n\n        OnDialogueEnd?.Invoke();\n\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n\n    public void SetDialogueSequence(int sequenceIndex)\n    {\n        if (sequenceIndex >= 0 && sequenceIndex < _dialogueSequences.Count)\n            _currentSequenceIndex = sequenceIndex;\n    }\n\n    public void AddDialogueSequence(DialogueSequence newSequence)\n    {\n        _dialogueSequences.Add(newSequence);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n\n    private void OnDisable()\n    {\n        if (_dialogueActive)\n            EndDialogue();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "shop that displays purchasable items",
      "ideal_ir": {
        "class_name": "Shop",
        "components": [
          "Canvas",
          "GraphicRaycaster"
        ],
        "fields": [
          {
            "name": "itemPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "itemContainer",
            "type": "Transform",
            "default": null
          },
          {
            "name": "playerCurrency",
            "type": "int",
            "default": 100
          },
          {
            "name": "currencyText",
            "type": "Text",
            "default": null
          },
          {
            "name": "purchaseSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initialize_shop",
            "trigger": "when shop starts",
            "actions": [
              {
                "action": "create item display for each available item"
              },
              {
                "action": "show item name price and icon for each item"
              },
              {
                "action": "update currency display with current player money"
              }
            ]
          },
          {
            "name": "handle_item_purchase",
            "trigger": "when player clicks on item purchase button",
            "actions": [
              {
                "action": "check if player has enough currency for selected item"
              },
              {
                "action": "deduct item cost from player currency if affordable"
              },
              {
                "action": "add purchased item to player inventory"
              },
              {
                "action": "update currency display with new amount"
              },
              {
                "action": "play purchase confirmation sound"
              },
              {
                "action": "show purchase success message"
              }
            ]
          },
          {
            "name": "handle_insufficient_funds",
            "trigger": "when player tries to buy item without enough money",
            "actions": [
              {
                "action": "show insufficient funds warning message"
              },
              {
                "action": "highlight currency display briefly"
              },
              {
                "action": "prevent purchase from completing"
              }
            ]
          },
          {
            "name": "update_item_availability",
            "trigger": "when player currency changes",
            "actions": [
              {
                "action": "check affordability of each displayed item"
              },
              {
                "action": "dim or disable purchase buttons for unaffordable items"
              },
              {
                "action": "highlight affordable items"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System;\n\npublic class Shop : MonoBehaviour\n{\n    [System.Serializable]\n    public class ShopItem\n    {\n        [Header(\"Item Info\")]\n        public string itemName;\n        public string description;\n        public Sprite icon;\n        public int price;\n        public int maxQuantity = 1;\n        \n        [Header(\"Item Data\")]\n        public GameObject itemPrefab;\n        public bool isConsumable = false;\n        \n        [HideInInspector]\n        public int currentQuantity = 0;\n    }\n\n    [System.Serializable]\n    public class ShopItemUI\n    {\n        public GameObject itemPanel;\n        public Image itemIcon;\n        public Text itemName;\n        public Text itemDescription;\n        public Text itemPrice;\n        public Text quantityText;\n        public Button purchaseButton;\n        public Button sellButton;\n        \n        [HideInInspector]\n        public ShopItem linkedItem;\n    }\n\n    [Header(\"Shop Configuration\")]\n    [SerializeField] private List<ShopItem> _shopItems = new List<ShopItem>();\n    [SerializeField] private GameObject _shopPanel;\n    [SerializeField] private GameObject _itemUIPrefab;\n    [SerializeField] private Transform _itemContainer;\n    [SerializeField] private ScrollRect _scrollRect;\n    \n    [Header(\"Player Currency\")]\n    [SerializeField] private int _playerMoney = 1000;\n    [SerializeField] private Text _moneyDisplay;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private Button _closeShopButton;\n    [SerializeField] private Text _shopTitle;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _purchaseSound;\n    [SerializeField] private AudioClip _sellSound;\n    [SerializeField] private AudioClip _errorSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string, int> OnItemPurchased;\n    public UnityEvent<string, int> OnItemSold;\n    public UnityEvent<int> OnMoneyChanged;\n    \n    private List<ShopItemUI> _itemUIElements = new List<ShopItemUI>();\n    private bool _isShopOpen = false;\n    private Dictionary<string, int> _playerInventory = new Dictionary<string, int>();\n\n    private void Start()\n    {\n        InitializeShop();\n        UpdateMoneyDisplay();\n        \n        if (_closeShopButton != null)\n            _closeShopButton.onClick.AddListener(CloseShop);\n            \n        CloseShop();\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape) && _isShopOpen)\n        {\n            CloseShop();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            OpenShop();\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            CloseShop();\n        }\n    }\n\n    private void InitializeShop()\n    {\n        if (_itemContainer == null || _itemUIPrefab == null) return;\n\n        foreach (Transform child in _itemContainer)\n        {\n            if (Application.isPlaying)\n                Destroy(child.gameObject);\n            else\n                DestroyImmediate(child.gameObject);\n        }\n\n        _itemUIElements.Clear();\n\n        for (int i = 0; i < _shopItems.Count; i++)\n        {\n            CreateItemUI(_shopItems[i]);\n        }\n    }\n\n    private void CreateItemUI(ShopItem item)\n    {\n        GameObject itemUI = Instantiate(_itemUIPrefab, _itemContainer);\n        ShopItemUI uiElement = new ShopItemUI();\n\n        uiElement.itemPanel = itemUI;\n        uiElement.itemIcon = itemUI.transform.Find(\"Icon\")?.GetComponent<Image>();\n        uiElement.itemName = itemUI.transform.Find(\"ItemName\")?.GetComponent<Text>();\n        uiElement.itemDescription = itemUI.transform.Find(\"Description\")?.GetComponent<Text>();\n        uiElement.itemPrice = itemUI.transform.Find(\"Price\")?.GetComponent<Text>();\n        uiElement.quantityText = itemUI.transform.Find(\"Quantity\")?.GetComponent<Text>();\n        uiElement.purchaseButton = itemUI.transform.Find(\"PurchaseButton\")?.GetComponent<Button>();\n        uiElement.sellButton = itemUI.transform.Find(\"SellButton\")?.GetComponent<Button>();\n        uiElement.linkedItem = item;\n\n        if (uiElement.itemIcon != null && item.icon != null)\n            uiElement.itemIcon.sprite = item.icon;\n\n        if (uiElement.itemName != null)\n            uiElement.itemName.text = item.itemName;\n\n        if (uiElement.itemDescription != null)\n            uiElement.itemDescription.text = item.description;\n\n        if (uiElement.itemPrice != null)\n            uiElement.itemPrice.text = \"$\" + item.price.ToString();\n\n        if (uiElement.purchaseButton != null)\n        {\n            uiElement.purchaseButton.onClick.AddListener(() => PurchaseItem(item));\n        }\n\n        if (uiElement.sellButton != null)\n        {\n            uiElement.sellButton.onClick.AddListener(() => SellItem(item));\n        }\n\n        _itemUIElements.Add(uiElement);\n        UpdateItemUI(uiElement);\n    }\n\n    private void UpdateItemUI(ShopItemUI uiElement)\n    {\n        if (uiElement.linkedItem == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(uiElement.linkedItem.itemName);\n        \n        if (uiElement.quantityText != null)\n        {\n            uiElement.quantityText.text = \"Owned: \" + ownedQuantity.ToString();\n        }\n\n        bool canPurchase = _playerMoney >= uiElement.linkedItem.price && \n                          ownedQuantity < uiElement.linkedItem.maxQuantity;\n        \n        if (uiElement.purchaseButton != null)\n        {\n            uiElement.purchaseButton.interactable = canPurchase;\n        }\n\n        bool canSell = ownedQuantity > 0;\n        if (uiElement.sellButton != null)\n        {\n            uiElement.sellButton.interactable = canSell;\n            uiElement.sellButton.gameObject.SetActive(canSell);\n        }\n    }\n\n    private void UpdateAllItemUI()\n    {\n        foreach (var uiElement in _itemUIElements)\n        {\n            UpdateItemUI(uiElement);\n        }\n    }\n\n    public void OpenShop()\n    {\n        if (_shopPanel != null)\n        {\n            _shopPanel.SetActive(true);\n            _isShopOpen = true;\n            UpdateAllItemUI();\n            Time.timeScale = 0f;\n        }\n    }\n\n    public void CloseShop()\n    {\n        if (_shopPanel != null)\n        {\n            _shopPanel.SetActive(false);\n            _isShopOpen = false;\n            Time.timeScale = 1f;\n        }\n    }\n\n    public void PurchaseItem(ShopItem item)\n    {\n        if (item == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(item.itemName);\n        \n        if (_playerMoney >= item.price && ownedQuantity < item.maxQuantity)\n        {\n            _playerMoney -= item.price;\n            AddItemToInventory(item.itemName, 1);\n            \n            UpdateMoneyDisplay();\n            UpdateAllItemUI();\n            \n            PlaySound(_purchaseSound);\n            OnItemPurchased?.Invoke(item.itemName, 1);\n            OnMoneyChanged?.Invoke(_playerMoney);\n            \n            Debug.Log($\"Purchased {item.itemName} for ${item.price}\");\n        }\n        else\n        {\n            PlaySound(_errorSound);\n            string reason = _playerMoney < item.price ? \"Not enough money!\" : \"Maximum quantity reached!\";\n            Debug.Log($\"Cannot purchase {item.itemName}: {reason}\");\n        }\n    }\n\n    public void SellItem(ShopItem item)\n    {\n        if (item == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(item.itemName);\n        \n        if (ownedQuantity > 0)\n        {\n            int sellPrice = Mathf.RoundToInt(item.price * 0.5f);\n            _playerMoney += sellPrice;\n            RemoveItemFromInventory(item.itemName, 1);\n            \n            UpdateMoneyDisplay();\n            UpdateAllItemUI();\n            \n            PlaySound(_sellSound);\n            OnItemSold?.Invoke(item.itemName, 1);\n            OnMoneyChanged?.Invoke(_playerMoney);\n            \n            Debug.Log($\"Sold {item.itemName} for ${sellPrice}\");\n        }\n        else\n        {\n            PlaySound(_errorSound);\n            Debug.Log($\"Cannot sell {item.itemName}: You don't own any!\");\n        }\n    }\n\n    private void AddItemToInventory(string itemName, int quantity)\n    {\n        if (_playerInventory.ContainsKey(itemName))\n        {\n            _playerInventory[itemName] += quantity;\n        }\n        else\n        {\n            _playerInventory[itemName] = quantity;\n        }\n    }\n\n    private void RemoveItemFromInventory(string itemName, int quantity)\n    {\n        if (_playerInventory.ContainsKey(itemName))\n        {\n            _playerInventory[itemName] = Mathf.Max(0, _playerInventory[itemName] - quantity);\n            \n            if (_playerInventory[itemName] == 0)\n            {\n                _playerInventory.Remove(itemName);\n            }\n        }\n    }\n\n    private int GetPlayerItemQuantity(string itemName)\n    {\n        return _playerInventory.ContainsKey(itemName) ? _playerInventory[itemName] : 0;\n    }\n\n    private void UpdateMoneyDisplay()\n    {\n        if (_moneyDisplay != null)\n        {\n            _moneyDisplay.text = \"$\" + _playerMoney.ToString();\n        }\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n\n    public void AddMoney(int amount)\n    {\n        _playerMoney += amount;\n        UpdateMoneyDisplay();\n        OnMoneyChanged?.Invoke(_playerMoney);\n    }\n\n    public bool HasMoney(int amount)\n    {\n        return _playerMoney >= amount;\n    }\n\n    public int GetMoney()\n    {\n        return _playerMoney;\n    }\n\n    public bool HasItem(string itemName, int quantity = 1)\n    {\n        return GetPlayerItemQuantity(itemName) >= quantity;\n    }\n\n    public Dictionary<string, int> GetInventory()\n    {\n        return new Dictionary<string, int>(_playerInventory);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "save point that checkpoints progress",
      "ideal_ir": {
        "class_name": "SavePoint",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "saveRadius",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "activationSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_approach",
            "trigger": "when player enters save point area",
            "actions": [
              {
                "action": "check if save point is not already activated"
              },
              {
                "action": "activate save point if conditions are met"
              }
            ]
          },
          {
            "name": "activate_save_point",
            "trigger": "when save point becomes activated",
            "actions": [
              {
                "action": "save current game progress to file"
              },
              {
                "action": "save player position and stats"
              },
              {
                "action": "save current level state"
              },
              {
                "action": "play activation sound effect"
              },
              {
                "action": "increase visual glow effect"
              },
              {
                "action": "mark save point as permanently activated"
              },
              {
                "action": "display save confirmation message to player"
              }
            ]
          },
          {
            "name": "maintain_visual_state",
            "trigger": "continuously while save point exists",
            "actions": [
              {
                "action": "pulse glow effect if activated"
              },
              {
                "action": "remain dim if not yet activated"
              }
            ]
          },
          {
            "name": "handle_repeat_visits",
            "trigger": "when activated player enters area again",
            "actions": [
              {
                "action": "update save file with current progress"
              },
              {
                "action": "play gentle confirmation sound"
              },
              {
                "action": "briefly brighten glow effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System;\n\npublic class SavePoint : MonoBehaviour\n{\n    [Header(\"Save Point Settings\")]\n    [SerializeField] private float _activationRange = 2f;\n    [SerializeField] private bool _autoSave = true;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private string _savePointId = \"\";\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _activeIndicator;\n    [SerializeField] private ParticleSystem _saveEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _saveSound;\n    [SerializeField] private Color _activeColor = Color.green;\n    [SerializeField] private Color _inactiveColor = Color.gray;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerSaved;\n    public UnityEvent OnSavePointActivated;\n    \n    private bool _isActivated = false;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private Transform _player;\n    private Renderer _renderer;\n    private Material _material;\n    private Color _originalColor;\n    \n    [System.Serializable]\n    public class SaveData\n    {\n        public Vector3 position;\n        public Quaternion rotation;\n        public string savePointId;\n        public float timestamp;\n        public int health;\n        public int score;\n        \n        public SaveData(Vector3 pos, Quaternion rot, string id)\n        {\n            position = pos;\n            rotation = rot;\n            savePointId = id;\n            timestamp = Time.time;\n            health = 100;\n            score = 0;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeSavePoint();\n        LoadSavePointState();\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        CheckPlayerProximity();\n        UpdateVisuals();\n    }\n    \n    private void InitializeSavePoint()\n    {\n        if (string.IsNullOrEmpty(_savePointId))\n        {\n            _savePointId = \"SavePoint_\" + transform.position.ToString();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _originalColor = _material.color;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_activeIndicator != null)\n        {\n            _activeIndicator.SetActive(false);\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n            }\n        }\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        if (_player == null)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n            {\n                _player = playerObject.transform;\n            }\n            return;\n        }\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        \n        if (distance <= _activationRange && !_isOnCooldown)\n        {\n            if (_autoSave && !_isActivated)\n            {\n                ActivateSavePoint();\n            }\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_material != null)\n        {\n            Color targetColor = _isActivated ? _activeColor : _inactiveColor;\n            _material.color = Color.Lerp(_material.color, targetColor, Time.deltaTime * 2f);\n        }\n        \n        if (_activeIndicator != null)\n        {\n            _activeIndicator.SetActive(_isActivated);\n        }\n    }\n    \n    public void ActivateSavePoint()\n    {\n        if (_isOnCooldown) return;\n        \n        _isActivated = true;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        SavePlayerProgress();\n        PlaySaveEffects();\n        \n        OnSavePointActivated.Invoke();\n        OnPlayerSaved.Invoke();\n    }\n    \n    private void SavePlayerProgress()\n    {\n        if (_player == null) return;\n        \n        SaveData saveData = new SaveData(_player.position, _player.rotation, _savePointId);\n        \n        // Save additional player data if available\n        GameObject playerObject = _player.gameObject;\n        \n        // Try to get health from various possible components\n        var healthComponent = playerObject.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to find health-related fields\n            var fields = healthComponent.GetType().GetFields();\n            foreach (var field in fields)\n            {\n                if (field.Name.ToLower().Contains(\"health\") && field.FieldType == typeof(int))\n                {\n                    saveData.health = (int)field.GetValue(healthComponent);\n                    break;\n                }\n            }\n        }\n        \n        string jsonData = JsonUtility.ToJson(saveData);\n        PlayerPrefs.SetString(\"SavePoint_\" + _savePointId, jsonData);\n        PlayerPrefs.SetString(\"LastSavePoint\", _savePointId);\n        PlayerPrefs.Save();\n        \n        Debug.Log($\"Progress saved at {_savePointId}\");\n    }\n    \n    public void LoadPlayerProgress()\n    {\n        string jsonData = PlayerPrefs.GetString(\"SavePoint_\" + _savePointId, \"\");\n        \n        if (!string.IsNullOrEmpty(jsonData))\n        {\n            SaveData saveData = JsonUtility.FromJson<SaveData>(jsonData);\n            \n            if (_player != null)\n            {\n                // Disable character controller if present\n                var characterController = _player.GetComponent<CharacterController>();\n                if (characterController != null)\n                {\n                    characterController.enabled = false;\n                }\n                \n                _player.position = saveData.position;\n                _player.rotation = saveData.rotation;\n                \n                // Re-enable character controller\n                if (characterController != null)\n                {\n                    characterController.enabled = true;\n                }\n                \n                Debug.Log($\"Progress loaded from {_savePointId}\");\n            }\n        }\n    }\n    \n    private void LoadSavePointState()\n    {\n        string lastSavePoint = PlayerPrefs.GetString(\"LastSavePoint\", \"\");\n        if (lastSavePoint == _savePointId)\n        {\n            _isActivated = true;\n        }\n    }\n    \n    private void PlaySaveEffects()\n    {\n        if (_saveEffect != null)\n        {\n            _saveEffect.Play();\n        }\n        \n        if (_audioSource != null && _saveSound != null)\n        {\n            _audioSource.PlayOneShot(_saveSound);\n        }\n    }\n    \n    public static void LoadLastSavePoint()\n    {\n        string lastSavePointId = PlayerPrefs.GetString(\"LastSavePoint\", \"\");\n        \n        if (!string.IsNullOrEmpty(lastSavePointId))\n        {\n            SavePoint[] savePoints = FindObjectsOfType<SavePoint>();\n            \n            foreach (SavePoint savePoint in savePoints)\n            {\n                if (savePoint._savePointId == lastSavePointId)\n                {\n                    savePoint.LoadPlayerProgress();\n                    break;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_autoSave && !_isOnCooldown)\n        {\n            ActivateSavePoint();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _activeColor;\n        Gizmos.DrawWireSphere(transform.position, _activationRange);\n    }\n    \n    public bool IsActivated => _isActivated;\n    public string SavePointId => _savePointId;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "sign that displays message",
      "ideal_ir": {
        "class_name": "MessageSign",
        "components": [
          "Canvas",
          "Text"
        ],
        "fields": [
          {
            "name": "message",
            "type": "string",
            "default": "Welcome!"
          },
          {
            "name": "displayDistance",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_message",
            "trigger": "when player comes within display distance",
            "actions": [
              {
                "action": "make text visible"
              },
              {
                "action": "display the message text"
              }
            ]
          },
          {
            "name": "hide_message",
            "trigger": "when player moves away from display distance",
            "actions": [
              {
                "action": "make text invisible"
              }
            ]
          },
          {
            "name": "initialize_sign",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "hide text initially"
              },
              {
                "action": "set up message display"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\npublic class MessageSign : MonoBehaviour\n{\n    [Header(\"Sign Configuration\")]\n    [SerializeField] private string _signMessage = \"Welcome to the game!\";\n    [SerializeField] private float _displayDistance = 3f;\n    [SerializeField] private bool _requireInteraction = false;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _messageCanvas;\n    [SerializeField] private TextMeshProUGUI _messageText;\n    [SerializeField] private Text _legacyMessageText;\n    [SerializeField] private GameObject _interactionPrompt;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private float _fadeSpeed = 2f;\n    [SerializeField] private bool _lookAtPlayer = true;\n    [SerializeField] private Vector3 _canvasOffset = Vector3.up;\n    \n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    private bool _messageVisible = false;\n    private CanvasGroup _canvasGroup;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        SetupCanvas();\n        SetupMessageText();\n        \n        if (_messageCanvas != null)\n            _messageCanvas.gameObject.SetActive(false);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void SetupCanvas()\n    {\n        if (_messageCanvas == null)\n        {\n            GameObject canvasObj = new GameObject(\"MessageCanvas\");\n            canvasObj.transform.SetParent(transform);\n            canvasObj.transform.localPosition = _canvasOffset;\n            \n            _messageCanvas = canvasObj.AddComponent<Canvas>();\n            _messageCanvas.renderMode = RenderMode.WorldSpace;\n            _messageCanvas.worldCamera = _mainCamera;\n            \n            canvasObj.AddComponent<CanvasScaler>();\n            canvasObj.AddComponent<GraphicRaycaster>();\n            \n            RectTransform rectTransform = canvasObj.GetComponent<RectTransform>();\n            rectTransform.sizeDelta = new Vector2(200, 100);\n            rectTransform.localScale = Vector3.one * 0.01f;\n        }\n        \n        _canvasGroup = _messageCanvas.GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = _messageCanvas.gameObject.AddComponent<CanvasGroup>();\n            \n        _canvasGroup.alpha = 0f;\n    }\n    \n    private void SetupMessageText()\n    {\n        if (_messageText == null && _legacyMessageText == null)\n        {\n            GameObject textObj = new GameObject(\"MessageText\");\n            textObj.transform.SetParent(_messageCanvas.transform);\n            \n            RectTransform textRect = textObj.AddComponent<RectTransform>();\n            textRect.anchorMin = Vector2.zero;\n            textRect.anchorMax = Vector2.one;\n            textRect.offsetMin = Vector2.zero;\n            textRect.offsetMax = Vector2.zero;\n            \n            _messageText = textObj.AddComponent<TextMeshProUGUI>();\n            if (_messageText != null)\n            {\n                _messageText.text = _signMessage;\n                _messageText.fontSize = 24;\n                _messageText.color = Color.white;\n                _messageText.alignment = TextAlignmentOptions.Center;\n            }\n            else\n            {\n                _legacyMessageText = textObj.AddComponent<Text>();\n                _legacyMessageText.text = _signMessage;\n                _legacyMessageText.fontSize = 24;\n                _legacyMessageText.color = Color.white;\n                _legacyMessageText.alignment = TextAnchor.MiddleCenter;\n                _legacyMessageText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n            }\n        }\n        \n        UpdateMessageText();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInteraction();\n        UpdateCanvasRotation();\n        UpdateCanvasAlpha();\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_mainCamera == null) return;\n        \n        _playerTransform = _mainCamera.transform;\n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        bool wasInRange = _playerInRange;\n        _playerInRange = distanceToPlayer <= _displayDistance;\n        \n        if (_playerInRange && !wasInRange)\n        {\n            OnPlayerEnterRange();\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            OnPlayerExitRange();\n        }\n    }\n    \n    private void HandleInteraction()\n    {\n        if (!_playerInRange) return;\n        \n        if (_requireInteraction)\n        {\n            if (_interactionPrompt != null)\n                _interactionPrompt.SetActive(true);\n                \n            if (Input.GetKeyDown(_interactionKey))\n            {\n                ToggleMessage();\n            }\n        }\n        else\n        {\n            if (!_messageVisible)\n                ShowMessage();\n        }\n    }\n    \n    private void UpdateCanvasRotation()\n    {\n        if (_messageCanvas == null || _playerTransform == null || !_lookAtPlayer) return;\n        \n        Vector3 directionToPlayer = _playerTransform.position - _messageCanvas.transform.position;\n        directionToPlayer.y = 0;\n        \n        if (directionToPlayer != Vector3.zero)\n        {\n            _messageCanvas.transform.rotation = Quaternion.LookRotation(directionToPlayer);\n        }\n    }\n    \n    private void UpdateCanvasAlpha()\n    {\n        if (_canvasGroup == null) return;\n        \n        float targetAlpha = _messageVisible ? 1f : 0f;\n        _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha, targetAlpha, _fadeSpeed * Time.deltaTime);\n        \n        if (_canvasGroup.alpha <= 0f && _messageCanvas.gameObject.activeSelf)\n        {\n            _messageCanvas.gameObject.SetActive(false);\n        }\n    }\n    \n    private void OnPlayerEnterRange()\n    {\n        if (!_requireInteraction)\n        {\n            ShowMessage();\n        }\n    }\n    \n    private void OnPlayerExitRange()\n    {\n        HideMessage();\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void ShowMessage()\n    {\n        if (_messageCanvas != null)\n        {\n            _messageCanvas.gameObject.SetActive(true);\n            _messageVisible = true;\n        }\n    }\n    \n    private void HideMessage()\n    {\n        _messageVisible = false;\n    }\n    \n    private void ToggleMessage()\n    {\n        if (_messageVisible)\n            HideMessage();\n        else\n            ShowMessage();\n    }\n    \n    private void UpdateMessageText()\n    {\n        if (_messageText != null)\n            _messageText.text = _signMessage;\n        else if (_legacyMessageText != null)\n            _legacyMessageText.text = _signMessage;\n    }\n    \n    public void SetMessage(string newMessage)\n    {\n        _signMessage = newMessage;\n        UpdateMessageText();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _displayDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position + _canvasOffset, Vector3.one * 0.5f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "terminal with hackable interface",
      "ideal_ir": {
        "class_name": "HackableTerminal",
        "components": [
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isHacked",
            "type": "bool",
            "default": false
          },
          {
            "name": "hackingTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "accessLevel",
            "type": "int",
            "default": 1
          },
          {
            "name": "terminalData",
            "type": "string",
            "default": "SYSTEM_LOCKED"
          },
          {
            "name": "hackingProgress",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "isBeingHacked",
            "type": "bool",
            "default": false
          },
          {
            "name": "requiredHackingSkill",
            "type": "int",
            "default": 1
          },
          {
            "name": "lockoutTime",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isLockedOut",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "display_locked_interface",
            "trigger": "when player approaches terminal and terminal is not hacked",
            "actions": [
              {
                "action": "show locked terminal interface with blinking cursor"
              },
              {
                "action": "display access denied message"
              },
              {
                "action": "play electronic beeping sound"
              }
            ]
          },
          {
            "name": "start_hacking_process",
            "trigger": "when player interacts with terminal and has sufficient hacking skill",
            "actions": [
              {
                "action": "begin hacking progress timer"
              },
              {
                "action": "show hacking interface with progress bar"
              },
              {
                "action": "play hacking sound effects"
              },
              {
                "action": "set terminal as being hacked"
              }
            ]
          },
          {
            "name": "update_hacking_progress",
            "trigger": "while terminal is being hacked",
            "actions": [
              {
                "action": "increase hacking progress over time"
              },
              {
                "action": "update progress bar display"
              },
              {
                "action": "show scrolling code text effect"
              },
              {
                "action": "play continuous typing sounds"
              }
            ]
          },
          {
            "name": "complete_successful_hack",
            "trigger": "when hacking progress reaches completion",
            "actions": [
              {
                "action": "set terminal as successfully hacked"
              },
              {
                "action": "unlock terminal access"
              },
              {
                "action": "display access granted message"
              },
              {
                "action": "show terminal data and files"
              },
              {
                "action": "play success confirmation sound"
              }
            ]
          },
          {
            "name": "handle_hacking_interruption",
            "trigger": "when player moves away during hacking process",
            "actions": [
              {
                "action": "reset hacking progress to zero"
              },
              {
                "action": "hide hacking interface"
              },
              {
                "action": "return terminal to locked state"
              },
              {
                "action": "stop hacking sound effects"
              }
            ]
          },
          {
            "name": "display_hacked_interface",
            "trigger": "when player approaches successfully hacked terminal",
            "actions": [
              {
                "action": "show unlocked terminal interface"
              },
              {
                "action": "display available data files"
              },
              {
                "action": "allow file browsing and data extraction"
              },
              {
                "action": "show green access indicator"
              }
            ]
          },
          {
            "name": "trigger_security_lockout",
            "trigger": "when hacking fails or player lacks required skill",
            "actions": [
              {
                "action": "activate security lockout mode"
              },
              {
                "action": "display warning message"
              },
              {
                "action": "disable terminal interaction temporarily"
              },
              {
                "action": "play alarm sound effect"
              },
              {
                "action": "start lockout countdown timer"
              }
            ]
          },
          {
            "name": "end_security_lockout",
            "trigger": "when lockout timer expires",
            "actions": [
              {
                "action": "restore normal terminal function"
              },
              {
                "action": "allow new hacking attempts"
              },
              {
                "action": "clear warning messages"
              },
              {
                "action": "reset terminal to locked state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class HackableTerminal : MonoBehaviour\n{\n    [System.Serializable]\n    public class TerminalFile\n    {\n        public string fileName;\n        public string content;\n        public bool isLocked;\n        public string password;\n    }\n\n    [System.Serializable]\n    public class HackingPuzzle\n    {\n        public string targetWord;\n        public List<string> decoyWords;\n        public int attempts;\n    }\n\n    [Header(\"Terminal UI\")]\n    [SerializeField] private Canvas _terminalCanvas;\n    [SerializeField] private Text _terminalDisplay;\n    [SerializeField] private InputField _inputField;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Hacking Interface\")]\n    [SerializeField] private GameObject _hackingPanel;\n    [SerializeField] private Text _hackingDisplay;\n    [SerializeField] private Text _attemptsText;\n    [SerializeField] private Transform _wordContainer;\n    [SerializeField] private Button _wordButtonPrefab;\n\n    [Header(\"Terminal Settings\")]\n    [SerializeField] private float _typewriterSpeed = 0.05f;\n    [SerializeField] private int _maxDisplayLines = 20;\n    [SerializeField] private string _terminalPrompt = \"TERMINAL> \";\n    [SerializeField] private Color _successColor = Color.green;\n    [SerializeField] private Color _errorColor = Color.red;\n    [SerializeField] private Color _normalColor = Color.white;\n\n    [Header(\"Files and Security\")]\n    [SerializeField] private List<TerminalFile> _files = new List<TerminalFile>();\n    [SerializeField] private HackingPuzzle _hackingPuzzle;\n    [SerializeField] private bool _requiresHacking = true;\n    [SerializeField] private float _interactionRange = 3f;\n\n    [Header(\"Events\")]\n    public UnityEvent OnTerminalAccessed;\n    public UnityEvent OnHackingSuccess;\n    public UnityEvent OnHackingFailed;\n    public UnityEvent OnTerminalClosed;\n\n    private List<string> _displayLines = new List<string>();\n    private bool _isPlayerNear = false;\n    private bool _isTerminalOpen = false;\n    private bool _isHacked = false;\n    private bool _isHacking = false;\n    private int _currentAttempts;\n    private Transform _playerTransform;\n    private Coroutine _typewriterCoroutine;\n\n    private Dictionary<string, System.Action<string[]>> _commands;\n\n    private void Start()\n    {\n        InitializeTerminal();\n        InitializeCommands();\n        SetupUI();\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n\n    private void InitializeTerminal()\n    {\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n\n        _currentAttempts = _hackingPuzzle.attempts;\n        \n        if (_files.Count == 0)\n        {\n            _files.Add(new TerminalFile \n            { \n                fileName = \"readme.txt\", \n                content = \"Welcome to the terminal system.\", \n                isLocked = false \n            });\n            _files.Add(new TerminalFile \n            { \n                fileName = \"secure.dat\", \n                content = \"Classified information stored here.\", \n                isLocked = true, \n                password = \"admin123\" \n            });\n        }\n    }\n\n    private void InitializeCommands()\n    {\n        _commands = new Dictionary<string, System.Action<string[]>>\n        {\n            { \"help\", ShowHelp },\n            { \"ls\", ListFiles },\n            { \"dir\", ListFiles },\n            { \"cat\", ReadFile },\n            { \"type\", ReadFile },\n            { \"clear\", ClearScreen },\n            { \"cls\", ClearScreen },\n            { \"hack\", StartHacking },\n            { \"login\", AttemptLogin },\n            { \"exit\", CloseTerminal },\n            { \"quit\", CloseTerminal }\n        };\n    }\n\n    private void SetupUI()\n    {\n        if (_inputField != null)\n        {\n            _inputField.onEndEdit.AddListener(ProcessCommand);\n        }\n\n        if (_closeButton != null)\n        {\n            _closeButton.onClick.AddListener(CloseTerminal);\n        }\n\n        AddLine(\"SYSTEM INITIALIZED\");\n        AddLine(\"Type 'help' for available commands\");\n        AddLine(\"\");\n    }\n\n    private void CheckPlayerProximity()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n\n        if (_playerTransform != null)\n        {\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            bool wasNear = _isPlayerNear;\n            _isPlayerNear = distance <= _interactionRange;\n\n            if (_isPlayerNear && !wasNear)\n            {\n                ShowInteractionPrompt();\n            }\n            else if (!_isPlayerNear && wasNear)\n            {\n                HideInteractionPrompt();\n            }\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_isPlayerNear && Input.GetKeyDown(KeyCode.E) && !_isTerminalOpen)\n        {\n            OpenTerminal();\n        }\n        else if (_isTerminalOpen && Input.GetKeyDown(KeyCode.Escape))\n        {\n            CloseTerminal();\n        }\n    }\n\n    private void ShowInteractionPrompt()\n    {\n        // This would typically show UI prompt - implement based on your UI system\n        Debug.Log(\"Press E to access terminal\");\n    }\n\n    private void HideInteractionPrompt()\n    {\n        // Hide interaction prompt\n    }\n\n    private void OpenTerminal()\n    {\n        if (_requiresHacking && !_isHacked)\n        {\n            StartHackingSequence();\n            return;\n        }\n\n        _isTerminalOpen = true;\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(true);\n\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n\n        if (_inputField != null)\n        {\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n\n        OnTerminalAccessed?.Invoke();\n        AddLine(\"Terminal access granted\");\n        AddLine(\"\");\n    }\n\n    private void CloseTerminal()\n    {\n        _isTerminalOpen = false;\n        _isHacking = false;\n\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n\n        OnTerminalClosed?.Invoke();\n    }\n\n    private void ProcessCommand(string input)\n    {\n        if (string.IsNullOrEmpty(input) || _isHacking)\n            return;\n\n        AddLine(_terminalPrompt + input);\n        \n        string[] parts = input.ToLower().Split(' ');\n        string command = parts[0];\n\n        if (_commands.ContainsKey(command))\n        {\n            _commands[command](parts);\n        }\n        else\n        {\n            AddLine(\"Unknown command: \" + command, _errorColor);\n            AddLine(\"Type 'help' for available commands\");\n        }\n\n        AddLine(\"\");\n        \n        if (_inputField != null)\n        {\n            _inputField.text = \"\";\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n    }\n\n    private void ShowHelp(string[] args)\n    {\n        AddLine(\"Available commands:\");\n        AddLine(\"help - Show this help message\");\n        AddLine(\"ls/dir - List files\");\n        AddLine(\"cat/type [filename] - Read file content\");\n        AddLine(\"clear/cls - Clear screen\");\n        if (!_isHacked && _requiresHacking)\n            AddLine(\"hack - Start hacking sequence\");\n        AddLine(\"login [password] - Login with password\");\n        AddLine(\"exit/quit - Close terminal\");\n    }\n\n    private void ListFiles(string[] args)\n    {\n        AddLine(\"Files:\");\n        foreach (var file in _files)\n        {\n            string status = file.isLocked ? \" [LOCKED]\" : \"\";\n            AddLine(\"  \" + file.fileName + status);\n        }\n    }\n\n    private void ReadFile(string[] args)\n    {\n        if (args.Length < 2)\n        {\n            AddLine(\"Usage: cat [filename]\", _errorColor);\n            return;\n        }\n\n        string filename = args[1];\n        var file = _files.FirstOrDefault(f => f.fileName.ToLower() == filename.ToLower());\n\n        if (file == null)\n        {\n            AddLine(\"File not found: \" + filename, _errorColor);\n            return;\n        }\n\n        if (file.isLocked)\n        {\n            AddLine(\"Access denied: File is locked\", _errorColor);\n            return;\n        }\n\n        AddLine(\"--- \" + file.fileName + \" ---\");\n        string[] lines = file.content.Split('\\n');\n        foreach (string line in lines)\n        {\n            AddLine(line);\n        }\n        AddLine(\"--- End of file ---\");\n    }\n\n    private void ClearScreen(string[] args)\n    {\n        _displayLines.Clear();\n        UpdateDisplay();\n    }\n\n    private void StartHacking(string[] args)\n    {\n        if (_isHacked)\n        {\n            AddLine(\"System already compromised\", _successColor);\n            return;\n        }\n\n        StartHackingSequence();\n    }\n\n    private void AttemptLogin(string[] args)\n    {\n        if (args.Length < 2)\n        {\n            AddLine(\"Usage: login [password]\", _errorColor);\n            return;\n        }\n\n        string password = args[1];\n        var lockedFile = _files.FirstOrDefault(f => f.isLocked && f.password == password);\n\n        if (lockedFile != null)\n        {\n            lockedFile.isLocked = false;\n            AddLine(\"File unlocked: \" + lockedFile.fileName, _successColor);\n        }\n        else\n        {\n            AddLine(\"Invalid password\", _errorColor);\n        }\n    }\n\n    private void StartHackingSequence()\n    {\n        _isHacking = true;\n        _currentAttempts = _hackingPuzzle.attempts;\n\n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(true);\n\n        SetupHackingPuzzle();\n    }\n\n    private void SetupHackingPuzzle()\n    {\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"BREACH PROTOCOL INITIATED\\nSelect the correct access code:\";\n        }\n\n        UpdateAttemptsDisplay();\n        CreateWordButtons();\n    }\n\n    private void CreateWordButtons()\n    {\n        if (_wordContainer == null || _wordButtonPrefab == null)\n            return;\n\n        // Clear existing buttons\n        foreach (Transform child in _wordContainer)\n        {\n            Destroy(child.gameObject);\n        }\n\n        // Create list of all words (target + decoys)\n        List<string> allWords = new List<string>(_hackingPuzzle.decoyWords);\n        allWords.Add(_hackingPuzzle.targetWord);\n        \n        // Shuffle the words\n        for (int i = 0; i < allWords.Count; i++)\n        {\n            string temp = allWords[i];\n            int randomIndex = Random.Range(i, allWords.Count);\n            allWords[i] = allWords[randomIndex];\n            allWords[randomIndex] = temp;\n        }\n\n        // Create buttons\n        foreach (string word in allWords)\n        {\n            Button wordButton = Instantiate(_wordButtonPrefab, _wordContainer);\n            Text buttonText = wordButton.GetComponentInChildren<Text>();\n            if (buttonText != null)\n                buttonText.text = word;\n\n            wordButton.onClick.AddListener(() => OnWordSelected(word));\n        }\n    }\n\n    private void OnWordSelected(string selectedWord)\n    {\n        if (selectedWord == _hackingPuzzle.targetWord)\n        {\n            HackingSuccess();\n        }\n        else\n        {\n            _currentAttempts--;\n            UpdateAttemptsDisplay();\n\n            if (_currentAttempts <= 0)\n            {\n                HackingFailed();\n            }\n            else\n            {\n                if (_hackingDisplay != null)\n                {\n                    _hackingDisplay.text = \"ACCESS DENIED\\nIncorrect code. Try again.\";\n                }\n            }\n        }\n    }\n\n    private void HackingSuccess()\n    {\n        _isHacked = true;\n        _isHacking = false;\n\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"ACCESS GRANTED\\nSystem compromised successfully!\";\n        }\n\n        // Unlock all files\n        foreach (var file in _files)\n        {\n            file.isLocked = false;\n        }\n\n        OnHackingSuccess?.Invoke();\n        \n        StartCoroutine(DelayedOpenTerminal());\n    }\n\n    private void HackingFailed()\n    {\n        _isHacking = false;\n\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"SECURITY BREACH DETECTED\\nTerminal locked down.\";\n        }\n\n        OnHackingFailed?.Invoke();\n        \n        StartCoroutine(DelayedCloseTerminal());\n    }\n\n    private IEnumerator DelayedOpenTerminal()\n    {\n        yield return new WaitForSeconds(2f);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n        \n        OpenTerminal();\n    }\n\n    private IEnumerator DelayedCloseTerminal()\n    {\n        yield return new WaitForSeconds(2f);\n        CloseTerminal();\n    }\n\n    private void UpdateAttemptsDisplay()\n    {\n        if (_attemptsText != null)\n        {\n            _attemptsText.text = \"Attempts remaining: \" + _currentAttempts;\n        }\n    }\n\n    private void AddLine(string text, Color? color = null)\n    {\n        _displayLines.Add(text);\n        \n        if (_displayLines.Count > _maxDisplayLines)\n        {\n            _displayLines.RemoveAt(0);\n        }\n\n        if (_typewriterCoroutine != null)\n        {\n            StopCoroutine(_typewriterCoroutine);\n        }\n\n        _typewriterCoroutine = StartCoroutine(TypewriterEffect(text, color ?? _normalColor));\n    }\n\n    private IEnumerator TypewriterEffect(string text, Color color)\n    {\n        UpdateDisplay();\n        \n        if (_terminalDisplay != null)\n        {\n            _terminalDisplay.color = color;\n        }\n\n        yield return new WaitForSeconds(_typewriterSpeed);\n        \n        if (_scrollRect != null)\n        {\n            Canvas.ForceUpdateCanvases();\n            _scrollRect.verticalNormalizedPosition = 0f;\n        }\n    }\n\n    private void UpdateDisplay()\n    {\n        if (_terminalDisplay != null)\n        {\n            _terminalDisplay.text = string.Join(\"\\n\", _display",
      "behavior_type": "general"
    },
    {
      "prompt": "campfire that restores health over time",
      "ideal_ir": {
        "class_name": "Campfire",
        "components": [
          "Collider",
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "healingAmount",
            "type": "float",
            "default": 5
          },
          {
            "name": "healingInterval",
            "type": "float",
            "default": 1
          },
          {
            "name": "maxHealth",
            "type": "float",
            "default": 100
          }
        ],
        "behaviors": [
          {
            "name": "heal_nearby_player",
            "trigger": "when player enters campfire area",
            "actions": [
              {
                "action": "start healing process for player"
              },
              {
                "action": "play healing sound effect"
              },
              {
                "action": "show healing particle effects"
              }
            ]
          },
          {
            "name": "continuous_healing",
            "trigger": "every healing interval while player is near campfire",
            "actions": [
              {
                "action": "restore player health by healing amount"
              },
              {
                "action": "clamp player health to maximum health value"
              },
              {
                "action": "display health restoration visual feedback"
              }
            ]
          },
          {
            "name": "stop_healing",
            "trigger": "when player leaves campfire area",
            "actions": [
              {
                "action": "stop healing process"
              },
              {
                "action": "stop healing sound effect"
              },
              {
                "action": "fade out healing particle effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Campfire : MonoBehaviour\n{\n    [Header(\"Healing Settings\")]\n    [SerializeField] private float _healingRate = 10f;\n    [SerializeField] private float _healingInterval = 1f;\n    [SerializeField] private float _healingRadius = 3f;\n    [SerializeField] private float _maxHealth = 100f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private AudioSource _fireAudioSource;\n    [SerializeField] private GameObject _healingEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerEnterHealing;\n    public UnityEvent<GameObject> OnPlayerExitHealing;\n    public UnityEvent<GameObject, float> OnPlayerHealed;\n    \n    private bool _isActive = true;\n    private Coroutine _healingCoroutine;\n    \n    [System.Serializable]\n    public class PlayerHealthData\n    {\n        public GameObject player;\n        public float currentHealth;\n        public bool isHealing;\n        \n        public PlayerHealthData(GameObject playerObj)\n        {\n            player = playerObj;\n            currentHealth = 100f;\n            isHealing = false;\n        }\n    }\n    \n    private System.Collections.Generic.List<PlayerHealthData> _playersInRange = \n        new System.Collections.Generic.List<PlayerHealthData>();\n    \n    private void Start()\n    {\n        SetupComponents();\n        StartHealing();\n    }\n    \n    private void SetupComponents()\n    {\n        if (_fireParticles == null)\n            _fireParticles = GetComponentInChildren<ParticleSystem>();\n            \n        if (_fireLight == null)\n            _fireLight = GetComponentInChildren<Light>();\n            \n        if (_fireAudioSource == null)\n            _fireAudioSource = GetComponent<AudioSource>();\n            \n        if (_fireAudioSource != null)\n        {\n            _fireAudioSource.loop = true;\n            _fireAudioSource.Play();\n        }\n        \n        SphereCollider trigger = GetComponent<SphereCollider>();\n        if (trigger == null)\n        {\n            trigger = gameObject.AddComponent<SphereCollider>();\n        }\n        trigger.isTrigger = true;\n        trigger.radius = _healingRadius;\n    }\n    \n    private void StartHealing()\n    {\n        if (_healingCoroutine == null)\n        {\n            _healingCoroutine = StartCoroutine(HealingLoop());\n        }\n    }\n    \n    private void StopHealing()\n    {\n        if (_healingCoroutine != null)\n        {\n            StopCoroutine(_healingCoroutine);\n            _healingCoroutine = null;\n        }\n    }\n    \n    private IEnumerator HealingLoop()\n    {\n        while (_isActive)\n        {\n            yield return new WaitForSeconds(_healingInterval);\n            \n            for (int i = _playersInRange.Count - 1; i >= 0; i--)\n            {\n                if (_playersInRange[i].player == null)\n                {\n                    _playersInRange.RemoveAt(i);\n                    continue;\n                }\n                \n                HealPlayer(_playersInRange[i]);\n            }\n        }\n    }\n    \n    private void HealPlayer(PlayerHealthData playerData)\n    {\n        if (playerData.currentHealth >= _maxHealth) return;\n        \n        float previousHealth = playerData.currentHealth;\n        playerData.currentHealth = Mathf.Min(playerData.currentHealth + _healingRate, _maxHealth);\n        \n        float healedAmount = playerData.currentHealth - previousHealth;\n        if (healedAmount > 0)\n        {\n            OnPlayerHealed?.Invoke(playerData.player, healedAmount);\n            ShowHealingEffect(playerData.player);\n        }\n    }\n    \n    private void ShowHealingEffect(GameObject player)\n    {\n        if (_healingEffect != null)\n        {\n            GameObject effect = Instantiate(_healingEffect, player.transform.position + Vector3.up, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        PlayerHealthData existingData = _playersInRange.Find(p => p.player == other.gameObject);\n        if (existingData == null)\n        {\n            PlayerHealthData newPlayerData = new PlayerHealthData(other.gameObject);\n            _playersInRange.Add(newPlayerData);\n            OnPlayerEnterHealing?.Invoke(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == other.gameObject);\n        if (playerData != null)\n        {\n            _playersInRange.Remove(playerData);\n            OnPlayerExitHealing?.Invoke(other.gameObject);\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_fireParticles != null)\n        {\n            if (active)\n                _fireParticles.Play();\n            else\n                _fireParticles.Stop();\n        }\n        \n        if (_fireLight != null)\n            _fireLight.enabled = active;\n            \n        if (_fireAudioSource != null)\n        {\n            if (active)\n                _fireAudioSource.Play();\n            else\n                _fireAudioSource.Stop();\n        }\n        \n        if (active)\n            StartHealing();\n        else\n            StopHealing();\n    }\n    \n    public float GetPlayerHealth(GameObject player)\n    {\n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == player);\n        return playerData?.currentHealth ?? 0f;\n    }\n    \n    public void SetPlayerHealth(GameObject player, float health)\n    {\n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == player);\n        if (playerData != null)\n        {\n            playerData.currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _healingRadius);\n    }\n    \n    private void OnDestroy()\n    {\n        StopHealing();\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "footstep sounds based on surface",
      "ideal_ir": {
        "class_name": "FootstepSoundController",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "grassSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "stoneSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "woodSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "metalSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "waterSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "stepVolume",
            "type": "float",
            "default": 0.7
          },
          {
            "name": "stepPitchVariation",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "raycastDistance",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "detect_surface_type",
            "trigger": "when character takes a step",
            "actions": [
              {
                "action": "cast ray downward from character position to detect ground surface"
              },
              {
                "action": "identify surface material type from hit object tag or material"
              }
            ]
          },
          {
            "name": "play_grass_footstep",
            "trigger": "when surface type is grass and step occurs",
            "actions": [
              {
                "action": "select random sound from grass sounds array"
              },
              {
                "action": "apply slight pitch variation to selected sound"
              },
              {
                "action": "play selected grass footstep sound at step volume"
              }
            ]
          },
          {
            "name": "play_stone_footstep",
            "trigger": "when surface type is stone and step occurs",
            "actions": [
              {
                "action": "select random sound from stone sounds array"
              },
              {
                "action": "apply slight pitch variation to selected sound"
              },
              {
                "action": "play selected stone footstep sound at step volume"
              }
            ]
          },
          {
            "name": "play_wood_footstep",
            "trigger": "when surface type is wood and step occurs",
            "actions": [
              {
                "action": "select random sound from wood sounds array"
              },
              {
                "action": "apply slight pitch variation to selected sound"
              },
              {
                "action": "play selected wood footstep sound at step volume"
              }
            ]
          },
          {
            "name": "play_metal_footstep",
            "trigger": "when surface type is metal and step occurs",
            "actions": [
              {
                "action": "select random sound from metal sounds array"
              },
              {
                "action": "apply slight pitch variation to selected sound"
              },
              {
                "action": "play selected metal footstep sound at step volume"
              }
            ]
          },
          {
            "name": "play_water_footstep",
            "trigger": "when surface type is water and step occurs",
            "actions": [
              {
                "action": "select random sound from water sounds array"
              },
              {
                "action": "apply slight pitch variation to selected sound"
              },
              {
                "action": "play selected water footstep sound at step volume"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FootstepSoundController : MonoBehaviour\n{\n    [System.Serializable]\n    public class SurfaceAudioData\n    {\n        public string surfaceTag;\n        public AudioClip[] footstepClips;\n        [Range(0f, 1f)]\n        public float volume = 1f;\n        [Range(0.5f, 2f)]\n        public float pitchVariation = 0.1f;\n    }\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private List<SurfaceAudioData> _surfaceAudioData = new List<SurfaceAudioData>();\n    \n    [Header(\"Footstep Detection\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _raycastDistance = 1.1f;\n    [SerializeField] private Transform _raycastOrigin;\n    \n    [Header(\"Timing\")]\n    [SerializeField] private float _stepInterval = 0.5f;\n    [SerializeField] private float _minimumVelocity = 0.1f;\n    \n    [Header(\"Default Audio\")]\n    [SerializeField] private AudioClip[] _defaultFootstepClips;\n    [SerializeField] private float _defaultVolume = 0.7f;\n\n    private Rigidbody _rigidbody;\n    private CharacterController _characterController;\n    private float _lastStepTime;\n    private string _currentSurfaceTag = \"\";\n    private Dictionary<string, SurfaceAudioData> _surfaceDataDict;\n\n    private void Awake()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        if (_raycastOrigin == null)\n            _raycastOrigin = transform;\n\n        _rigidbody = GetComponent<Rigidbody>();\n        _characterController = GetComponent<CharacterController>();\n\n        InitializeSurfaceDataDictionary();\n    }\n\n    private void Start()\n    {\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n\n    private void Update()\n    {\n        if (ShouldPlayFootstep())\n        {\n            DetectSurfaceAndPlayFootstep();\n        }\n    }\n\n    private void InitializeSurfaceDataDictionary()\n    {\n        _surfaceDataDict = new Dictionary<string, SurfaceAudioData>();\n        \n        foreach (var surfaceData in _surfaceAudioData)\n        {\n            if (!string.IsNullOrEmpty(surfaceData.surfaceTag))\n            {\n                _surfaceDataDict[surfaceData.surfaceTag] = surfaceData;\n            }\n        }\n    }\n\n    private bool ShouldPlayFootstep()\n    {\n        if (Time.time - _lastStepTime < _stepInterval)\n            return false;\n\n        bool isMoving = false;\n\n        if (_characterController != null)\n        {\n            isMoving = _characterController.velocity.magnitude > _minimumVelocity && _characterController.isGrounded;\n        }\n        else if (_rigidbody != null)\n        {\n            Vector3 horizontalVelocity = new Vector3(_rigidbody.velocity.x, 0, _rigidbody.velocity.z);\n            isMoving = horizontalVelocity.magnitude > _minimumVelocity && IsGrounded();\n        }\n        else\n        {\n            isMoving = transform.hasChanged && IsGrounded();\n            transform.hasChanged = false;\n        }\n\n        return isMoving;\n    }\n\n    private bool IsGrounded()\n    {\n        return Physics.Raycast(_raycastOrigin.position, Vector3.down, _raycastDistance, _groundLayerMask);\n    }\n\n    private void DetectSurfaceAndPlayFootstep()\n    {\n        RaycastHit hit;\n        if (Physics.Raycast(_raycastOrigin.position, Vector3.down, out hit, _raycastDistance, _groundLayerMask))\n        {\n            string surfaceTag = hit.collider.tag;\n            PlayFootstepSound(surfaceTag);\n            _currentSurfaceTag = surfaceTag;\n        }\n    }\n\n    private void PlayFootstepSound(string surfaceTag)\n    {\n        AudioClip[] clipsToUse = _defaultFootstepClips;\n        float volumeToUse = _defaultVolume;\n        float pitchVariation = 0.1f;\n\n        if (_surfaceDataDict.ContainsKey(surfaceTag))\n        {\n            var surfaceData = _surfaceDataDict[surfaceTag];\n            if (surfaceData.footstepClips != null && surfaceData.footstepClips.Length > 0)\n            {\n                clipsToUse = surfaceData.footstepClips;\n                volumeToUse = surfaceData.volume;\n                pitchVariation = surfaceData.pitchVariation;\n            }\n        }\n\n        if (clipsToUse != null && clipsToUse.Length > 0)\n        {\n            AudioClip clipToPlay = clipsToUse[Random.Range(0, clipsToUse.Length)];\n            \n            if (clipToPlay != null)\n            {\n                _audioSource.clip = clipToPlay;\n                _audioSource.volume = volumeToUse;\n                _audioSource.pitch = 1f + Random.Range(-pitchVariation, pitchVariation);\n                _audioSource.Play();\n                \n                _lastStepTime = Time.time;\n            }\n        }\n    }\n\n    public void SetStepInterval(float interval)\n    {\n        _stepInterval = Mathf.Max(0.1f, interval);\n    }\n\n    public void SetMinimumVelocity(float velocity)\n    {\n        _minimumVelocity = Mathf.Max(0f, velocity);\n    }\n\n    public string GetCurrentSurfaceTag()\n    {\n        return _currentSurfaceTag;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_raycastOrigin != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_raycastOrigin.position, _raycastOrigin.position + Vector3.down * _raycastDistance);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ambient sound zone",
      "ideal_ir": {
        "class_name": "AmbientSoundZone",
        "components": [
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "maxVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "isPlayerInside",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_fade_in",
            "trigger": "when player enters the sound zone",
            "actions": [
              {
                "action": "set player inside flag to true"
              },
              {
                "action": "gradually increase audio volume from zero to maximum volume over fade in duration"
              }
            ]
          },
          {
            "name": "start_fade_out",
            "trigger": "when player exits the sound zone",
            "actions": [
              {
                "action": "set player inside flag to false"
              },
              {
                "action": "gradually decrease audio volume from current level to zero over fade out duration"
              }
            ]
          },
          {
            "name": "initialize_audio",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "set audio source to loop continuously"
              },
              {
                "action": "set initial volume to zero"
              },
              {
                "action": "begin playing the ambient sound"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\n[RequireComponent(typeof(AudioSource))]\npublic class AmbientSoundZone : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _ambientClips;\n    [SerializeField] private bool _playOnAwake = true;\n    [SerializeField] private bool _loop = true;\n    [SerializeField] private bool _randomizeClips = false;\n    \n    [Header(\"Volume Control\")]\n    [SerializeField] private float _baseVolume = 0.5f;\n    [SerializeField] private float _fadeInDuration = 2f;\n    [SerializeField] private float _fadeOutDuration = 2f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _useDistanceAttenuation = true;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _minDistance = 1f;\n    [SerializeField] private bool _triggerBasedZone = false;\n    \n    [Header(\"Playback Options\")]\n    [SerializeField] private float _clipChangeInterval = 30f;\n    [SerializeField] private bool _crossfade = false;\n    [SerializeField] private float _crossfadeDuration = 3f;\n    \n    private AudioSource _primaryAudioSource;\n    private AudioSource _secondaryAudioSource;\n    private bool _isPlayerInZone = false;\n    private bool _isPlaying = false;\n    private float _currentVolume = 0f;\n    private float _targetVolume = 0f;\n    private Coroutine _fadeCoroutine;\n    private Coroutine _clipChangeCoroutine;\n    private int _currentClipIndex = 0;\n    private Transform _playerTransform;\n    \n    private void Awake()\n    {\n        _primaryAudioSource = GetComponent<AudioSource>();\n        _primaryAudioSource.playOnAwake = false;\n        _primaryAudioSource.loop = _loop && !_randomizeClips;\n        _primaryAudioSource.volume = 0f;\n        \n        if (_crossfade)\n        {\n            _secondaryAudioSource = gameObject.AddComponent<AudioSource>();\n            _secondaryAudioSource.playOnAwake = false;\n            _secondaryAudioSource.loop = _loop && !_randomizeClips;\n            _secondaryAudioSource.volume = 0f;\n        }\n        \n        SetupAudioSource(_primaryAudioSource);\n        if (_secondaryAudioSource != null)\n        {\n            SetupAudioSource(_secondaryAudioSource);\n        }\n    }\n    \n    private void Start()\n    {\n        if (_playOnAwake && !_triggerBasedZone)\n        {\n            StartAmbientSound();\n        }\n        \n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _playerTransform = playerObject.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_triggerBasedZone && _useDistanceAttenuation && _playerTransform != null)\n        {\n            UpdateDistanceBasedVolume();\n        }\n        \n        UpdateVolumeSmoothing();\n    }\n    \n    private void SetupAudioSource(AudioSource audioSource)\n    {\n        if (_useDistanceAttenuation)\n        {\n            audioSource.spatialBlend = 1f;\n            audioSource.rolloffMode = AudioRolloffMode.Linear;\n            audioSource.minDistance = _minDistance;\n            audioSource.maxDistance = _maxDistance;\n        }\n        else\n        {\n            audioSource.spatialBlend = 0f;\n        }\n    }\n    \n    private void UpdateDistanceBasedVolume()\n    {\n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        float normalizedDistance = Mathf.Clamp01((distance - _minDistance) / (_maxDistance - _minDistance));\n        float distanceVolume = _volumeCurve.Evaluate(1f - normalizedDistance);\n        \n        _targetVolume = _isPlaying ? _baseVolume * distanceVolume : 0f;\n    }\n    \n    private void UpdateVolumeSmoothing()\n    {\n        if (!Mathf.Approximately(_currentVolume, _targetVolume))\n        {\n            float fadeSpeed = _targetVolume > _currentVolume ? 1f / _fadeInDuration : 1f / _fadeOutDuration;\n            _currentVolume = Mathf.MoveTowards(_currentVolume, _targetVolume, fadeSpeed * Time.deltaTime);\n            \n            _primaryAudioSource.volume = _currentVolume;\n            if (_secondaryAudioSource != null)\n            {\n                _secondaryAudioSource.volume = _currentVolume;\n            }\n        }\n    }\n    \n    public void StartAmbientSound()\n    {\n        if (_ambientClips == null || _ambientClips.Length == 0) return;\n        \n        _isPlaying = true;\n        \n        if (_triggerBasedZone)\n        {\n            _targetVolume = _baseVolume;\n        }\n        else if (_useDistanceAttenuation && _playerTransform != null)\n        {\n            UpdateDistanceBasedVolume();\n        }\n        else\n        {\n            _targetVolume = _baseVolume;\n        }\n        \n        PlayCurrentClip();\n        \n        if (_randomizeClips && _clipChangeInterval > 0f)\n        {\n            _clipChangeCoroutine = StartCoroutine(ClipChangeRoutine());\n        }\n    }\n    \n    public void StopAmbientSound()\n    {\n        _isPlaying = false;\n        _targetVolume = 0f;\n        \n        if (_clipChangeCoroutine != null)\n        {\n            StopCoroutine(_clipChangeCoroutine);\n            _clipChangeCoroutine = null;\n        }\n    }\n    \n    private void PlayCurrentClip()\n    {\n        if (_ambientClips == null || _ambientClips.Length == 0) return;\n        \n        AudioClip clipToPlay = _ambientClips[_currentClipIndex];\n        if (clipToPlay == null) return;\n        \n        if (_crossfade && _secondaryAudioSource != null && _primaryAudioSource.isPlaying)\n        {\n            StartCoroutine(CrossfadeToClip(clipToPlay));\n        }\n        else\n        {\n            _primaryAudioSource.clip = clipToPlay;\n            _primaryAudioSource.Play();\n        }\n    }\n    \n    private System.Collections.IEnumerator CrossfadeToClip(AudioClip newClip)\n    {\n        _secondaryAudioSource.clip = newClip;\n        _secondaryAudioSource.volume = 0f;\n        _secondaryAudioSource.Play();\n        \n        float timer = 0f;\n        float primaryStartVolume = _primaryAudioSource.volume;\n        \n        while (timer < _crossfadeDuration)\n        {\n            timer += Time.deltaTime;\n            float progress = timer / _crossfadeDuration;\n            \n            _primaryAudioSource.volume = Mathf.Lerp(primaryStartVolume, 0f, progress);\n            _secondaryAudioSource.volume = Mathf.Lerp(0f, _currentVolume, progress);\n            \n            yield return null;\n        }\n        \n        _primaryAudioSource.Stop();\n        \n        AudioSource temp = _primaryAudioSource;\n        _primaryAudioSource = _secondaryAudioSource;\n        _secondaryAudioSource = temp;\n    }\n    \n    private System.Collections.IEnumerator ClipChangeRoutine()\n    {\n        while (_isPlaying)\n        {\n            yield return new WaitForSeconds(_clipChangeInterval);\n            \n            if (_isPlaying && _randomizeClips)\n            {\n                int previousIndex = _currentClipIndex;\n                _currentClipIndex = Random.Range(0, _ambientClips.Length);\n                \n                if (_ambientClips.Length > 1 && _currentClipIndex == previousIndex)\n                {\n                    _currentClipIndex = (_currentClipIndex + 1) % _ambientClips.Length;\n                }\n                \n                PlayCurrentClip();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerBasedZone) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInZone = true;\n            StartAmbientSound();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_triggerBasedZone) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInZone = false;\n            StopAmbientSound();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _baseVolume = Mathf.Clamp01(_baseVolume);\n        _fadeInDuration = Mathf.Max(0.1f, _fadeInDuration);\n        _fadeOutDuration = Mathf.Max(0.1f, _fadeOutDuration);\n        _maxDistance = Mathf.Max(_minDistance + 0.1f, _maxDistance);\n        _clipChangeInterval = Mathf.Max(1f, _clipChangeInterval);\n        _crossfadeDuration = Mathf.Max(0.1f, _crossfadeDuration);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_useDistanceAttenuation)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, _minDistance);\n            \n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _maxDistance);\n        }\n        \n        if (_triggerBasedZone)\n        {\n            Collider col = GetComponent<Collider>();\n            if (col != null && col.isTrigger)\n            {\n                Gizmos.color = Color.cyan;\n                Gizmos.DrawWireCube(transform.position, col.bounds.size);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "music that changes by area",
      "ideal_ir": {
        "class_name": "AreaMusicController",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "currentArea",
            "type": "string",
            "default": ""
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "detect_area_change",
            "trigger": "when player enters a new area with different music",
            "actions": [
              {
                "action": "identify the new area type"
              },
              {
                "action": "store the new area name"
              }
            ]
          },
          {
            "name": "fade_out_current_music",
            "trigger": "when area change is detected and music is currently playing",
            "actions": [
              {
                "action": "gradually reduce current music volume to zero"
              },
              {
                "action": "stop the current audio track when volume reaches zero"
              }
            ]
          },
          {
            "name": "fade_in_new_music",
            "trigger": "when current music has finished fading out and new area is detected",
            "actions": [
              {
                "action": "load the appropriate music track for the new area"
              },
              {
                "action": "start playing the new music track at zero volume"
              },
              {
                "action": "gradually increase volume to full level"
              }
            ]
          },
          {
            "name": "handle_same_area",
            "trigger": "when player moves within the same area type",
            "actions": [
              {
                "action": "continue playing current music without changes"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AreaMusicManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class MusicArea\n    {\n        [Header(\"Area Settings\")]\n        public string areaName;\n        public AudioClip musicClip;\n        public float volume = 1f;\n        public bool loop = true;\n        public float fadeInDuration = 2f;\n        public float fadeOutDuration = 2f;\n        \n        [Header(\"Area Detection\")]\n        public Transform areaCenter;\n        public float areaRadius = 10f;\n        public LayerMask playerLayer = 1;\n        \n        [Header(\"Trigger Alternative\")]\n        public Collider areaTrigger;\n    }\n\n    [Header(\"Music Areas\")]\n    [SerializeField] private List<MusicArea> _musicAreas = new List<MusicArea>();\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _musicSource;\n    [SerializeField] private float _globalVolume = 1f;\n    [SerializeField] private bool _playOnStart = true;\n    \n    [Header(\"Default Music\")]\n    [SerializeField] private AudioClip _defaultMusicClip;\n    [SerializeField] private float _defaultVolume = 0.5f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _checkInterval = 0.5f;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    private Transform _player;\n    private MusicArea _currentArea;\n    private Coroutine _fadeCoroutine;\n    private bool _isTransitioning = false;\n    private Dictionary<Collider, MusicArea> _triggerToAreaMap = new Dictionary<Collider, MusicArea>();\n\n    private void Start()\n    {\n        InitializeAudioSource();\n        FindPlayer();\n        SetupTriggerMappings();\n        \n        if (_playOnStart)\n        {\n            PlayDefaultMusic();\n        }\n        \n        StartCoroutine(CheckPlayerAreaRoutine());\n    }\n\n    private void InitializeAudioSource()\n    {\n        if (_musicSource == null)\n        {\n            _musicSource = GetComponent<AudioSource>();\n            if (_musicSource == null)\n            {\n                _musicSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _musicSource.playOnAwake = false;\n        _musicSource.volume = 0f;\n    }\n\n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(_playerTag);\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n\n    private void SetupTriggerMappings()\n    {\n        _triggerToAreaMap.Clear();\n        \n        foreach (var area in _musicAreas)\n        {\n            if (area.areaTrigger != null)\n            {\n                _triggerToAreaMap[area.areaTrigger] = area;\n                \n                if (area.areaTrigger.isTrigger == false)\n                {\n                    Debug.LogWarning($\"Area trigger for {area.areaName} is not set as trigger!\");\n                }\n            }\n        }\n    }\n\n    private void PlayDefaultMusic()\n    {\n        if (_defaultMusicClip != null)\n        {\n            PlayMusic(_defaultMusicClip, _defaultVolume, true, 1f);\n        }\n    }\n\n    private IEnumerator CheckPlayerAreaRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_checkInterval);\n            \n            if (_player != null && !_isTransitioning)\n            {\n                CheckPlayerArea();\n            }\n        }\n    }\n\n    private void CheckPlayerArea()\n    {\n        MusicArea newArea = GetPlayerCurrentArea();\n        \n        if (newArea != _currentArea)\n        {\n            ChangeToArea(newArea);\n        }\n    }\n\n    private MusicArea GetPlayerCurrentArea()\n    {\n        Vector3 playerPosition = _player.position;\n        \n        foreach (var area in _musicAreas)\n        {\n            if (IsPlayerInArea(area, playerPosition))\n            {\n                return area;\n            }\n        }\n        \n        return null;\n    }\n\n    private bool IsPlayerInArea(MusicArea area, Vector3 playerPosition)\n    {\n        if (area.areaTrigger != null)\n        {\n            return area.areaTrigger.bounds.Contains(playerPosition);\n        }\n        \n        if (area.areaCenter != null)\n        {\n            float distance = Vector3.Distance(playerPosition, area.areaCenter.position);\n            return distance <= area.areaRadius;\n        }\n        \n        return false;\n    }\n\n    private void ChangeToArea(MusicArea newArea)\n    {\n        _currentArea = newArea;\n        \n        if (newArea != null && newArea.musicClip != null)\n        {\n            PlayAreaMusic(newArea);\n        }\n        else\n        {\n            PlayDefaultMusic();\n        }\n    }\n\n    private void PlayAreaMusic(MusicArea area)\n    {\n        float fadeIn = area.fadeInDuration;\n        float fadeOut = _currentArea != null ? _currentArea.fadeOutDuration : 1f;\n        \n        PlayMusic(area.musicClip, area.volume, area.loop, fadeIn, fadeOut);\n    }\n\n    private void PlayMusic(AudioClip clip, float volume, bool loop, float fadeInDuration, float fadeOutDuration = 1f)\n    {\n        if (clip == null) return;\n        \n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n        }\n        \n        _fadeCoroutine = StartCoroutine(FadeToNewMusic(clip, volume, loop, fadeInDuration, fadeOutDuration));\n    }\n\n    private IEnumerator FadeToNewMusic(AudioClip newClip, float targetVolume, bool loop, float fadeInDuration, float fadeOutDuration)\n    {\n        _isTransitioning = true;\n        \n        // Fade out current music\n        if (_musicSource.isPlaying)\n        {\n            float startVolume = _musicSource.volume;\n            float fadeOutTime = 0f;\n            \n            while (fadeOutTime < fadeOutDuration)\n            {\n                fadeOutTime += Time.deltaTime;\n                float t = fadeOutTime / fadeOutDuration;\n                _musicSource.volume = Mathf.Lerp(startVolume, 0f, t);\n                yield return null;\n            }\n        }\n        \n        // Change to new music\n        _musicSource.clip = newClip;\n        _musicSource.loop = loop;\n        _musicSource.volume = 0f;\n        _musicSource.Play();\n        \n        // Fade in new music\n        float fadeInTime = 0f;\n        float finalVolume = targetVolume * _globalVolume;\n        \n        while (fadeInTime < fadeInDuration)\n        {\n            fadeInTime += Time.deltaTime;\n            float t = fadeInTime / fadeInDuration;\n            _musicSource.volume = Mathf.Lerp(0f, finalVolume, t);\n            yield return null;\n        }\n        \n        _musicSource.volume = finalVolume;\n        _isTransitioning = false;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_playerTag) && _triggerToAreaMap.ContainsKey(other))\n        {\n            MusicArea area = _triggerToAreaMap[other];\n            if (area != _currentArea)\n            {\n                ChangeToArea(area);\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_playerTag) && _triggerToAreaMap.ContainsKey(other))\n        {\n            MusicArea area = _triggerToAreaMap[other];\n            if (area == _currentArea)\n            {\n                ChangeToArea(null);\n            }\n        }\n    }\n\n    public void SetGlobalVolume(float volume)\n    {\n        _globalVolume = Mathf.Clamp01(volume);\n        if (_musicSource.isPlaying && _currentArea != null)\n        {\n            _musicSource.volume = _currentArea.volume * _globalVolume;\n        }\n    }\n\n    public void StopMusic(float fadeOutDuration = 1f)\n    {\n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n        }\n        \n        _fadeCoroutine = StartCoroutine(FadeOutMusic(fadeOutDuration));\n    }\n\n    private IEnumerator FadeOutMusic(float fadeOutDuration)\n    {\n        _isTransitioning = true;\n        float startVolume = _musicSource.volume;\n        float fadeTime = 0f;\n        \n        while (fadeTime < fadeOutDuration)\n        {\n            fadeTime += Time.deltaTime;\n            float t = fadeTime / fadeOutDuration;\n            _musicSource.volume = Mathf.Lerp(startVolume, 0f, t);\n            yield return null;\n        }\n        \n        _musicSource.Stop();\n        _musicSource.volume = 0f;\n        _currentArea = null;\n        _isTransitioning = false;\n    }\n\n    public void ForceAreaChange(string areaName)\n    {\n        MusicArea area = _musicAreas.Find(a => a.areaName == areaName);\n        if (area != null)\n        {\n            ChangeToArea(area);\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        foreach (var area in _musicAreas)\n        {\n            if (area.areaCenter != null)\n            {\n                Gizmos.color = Color.cyan;\n                Gizmos.DrawWireSphere(area.areaCenter.position, area.areaRadius);\n                \n                Gizmos.color = Color.blue;\n                Gizmos.DrawWireCube(area.areaCenter.position, Vector3.one * 0.5f);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "light that flickers randomly",
      "ideal_ir": {
        "class_name": "FlickeringLight",
        "components": [
          "Light"
        ],
        "fields": [
          {
            "name": "minIntensity",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "maxIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "flickerSpeed",
            "type": "float",
            "default": 0.1
          }
        ],
        "behaviors": [
          {
            "name": "random_flicker",
            "trigger": "continuously at random intervals",
            "actions": [
              {
                "action": "change light intensity to random value between minimum and maximum intensity"
              },
              {
                "action": "wait for flicker speed duration before next change"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FlickeringLight : MonoBehaviour\n{\n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _targetLight;\n    [SerializeField] private float _originalIntensity = 1f;\n    [SerializeField] private bool _useOriginalColor = true;\n    [SerializeField] private Color _originalColor = Color.white;\n    \n    [Header(\"Flicker Behavior\")]\n    [SerializeField] private float _minFlickerInterval = 0.1f;\n    [SerializeField] private float _maxFlickerInterval = 2f;\n    [SerializeField] private float _minIntensity = 0.1f;\n    [SerializeField] private float _maxIntensity = 1.2f;\n    [SerializeField] private float _flickerSpeed = 10f;\n    \n    [Header(\"Advanced Settings\")]\n    [SerializeField] private bool _randomizeColor = false;\n    [SerializeField] private Color _flickerColorMin = Color.yellow;\n    [SerializeField] private Color _flickerColorMax = Color.orange;\n    [SerializeField] private AnimationCurve _flickerCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private bool _enableSmoothTransition = true;\n    \n    private float _nextFlickerTime;\n    private float _targetIntensity;\n    private Color _targetColor;\n    private bool _isFlickering = false;\n    private float _flickerDuration = 0.2f;\n    private float _flickerStartTime;\n    \n    private void Start()\n    {\n        if (_targetLight == null)\n        {\n            _targetLight = GetComponent<Light>();\n        }\n        \n        if (_targetLight == null)\n        {\n            Debug.LogError(\"FlickeringLight: No Light component found!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalIntensity = _targetLight.intensity;\n        if (_useOriginalColor)\n        {\n            _originalColor = _targetLight.color;\n        }\n        \n        _targetIntensity = _originalIntensity;\n        _targetColor = _originalColor;\n        \n        ScheduleNextFlicker();\n    }\n    \n    private void Update()\n    {\n        if (_targetLight == null) return;\n        \n        if (Time.time >= _nextFlickerTime && !_isFlickering)\n        {\n            StartFlicker();\n        }\n        \n        if (_isFlickering)\n        {\n            UpdateFlicker();\n        }\n        else if (_enableSmoothTransition)\n        {\n            SmoothReturnToOriginal();\n        }\n    }\n    \n    private void StartFlicker()\n    {\n        _isFlickering = true;\n        _flickerStartTime = Time.time;\n        _flickerDuration = Random.Range(0.05f, 0.3f);\n        \n        _targetIntensity = Random.Range(_minIntensity, _maxIntensity);\n        \n        if (_randomizeColor)\n        {\n            _targetColor = Color.Lerp(_flickerColorMin, _flickerColorMax, Random.value);\n        }\n        else\n        {\n            _targetColor = _originalColor;\n        }\n    }\n    \n    private void UpdateFlicker()\n    {\n        float flickerProgress = (Time.time - _flickerStartTime) / _flickerDuration;\n        \n        if (flickerProgress >= 1f)\n        {\n            _isFlickering = false;\n            ScheduleNextFlicker();\n            return;\n        }\n        \n        float curveValue = _flickerCurve.Evaluate(flickerProgress);\n        float noise = Mathf.PerlinNoise(Time.time * _flickerSpeed, 0f);\n        float flickerMultiplier = Mathf.Lerp(0.3f, 1f, noise);\n        \n        float currentIntensity = Mathf.Lerp(_originalIntensity, _targetIntensity * flickerMultiplier, curveValue);\n        Color currentColor = Color.Lerp(_originalColor, _targetColor, curveValue);\n        \n        _targetLight.intensity = currentIntensity;\n        _targetLight.color = currentColor;\n    }\n    \n    private void SmoothReturnToOriginal()\n    {\n        _targetLight.intensity = Mathf.Lerp(_targetLight.intensity, _originalIntensity, Time.deltaTime * 5f);\n        _targetLight.color = Color.Lerp(_targetLight.color, _originalColor, Time.deltaTime * 5f);\n    }\n    \n    private void ScheduleNextFlicker()\n    {\n        float interval = Random.Range(_minFlickerInterval, _maxFlickerInterval);\n        _nextFlickerTime = Time.time + interval;\n    }\n    \n    public void SetFlickerEnabled(bool enabled)\n    {\n        if (!enabled)\n        {\n            _isFlickering = false;\n            _targetLight.intensity = _originalIntensity;\n            _targetLight.color = _originalColor;\n        }\n        \n        this.enabled = enabled;\n    }\n    \n    public void TriggerFlicker()\n    {\n        if (!_isFlickering)\n        {\n            _nextFlickerTime = Time.time;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _minFlickerInterval = Mathf.Max(0.01f, _minFlickerInterval);\n        _maxFlickerInterval = Mathf.Max(_minFlickerInterval, _maxFlickerInterval);\n        _minIntensity = Mathf.Max(0f, _minIntensity);\n        _maxIntensity = Mathf.Max(_minIntensity, _maxIntensity);\n        _flickerSpeed = Mathf.Max(0.1f, _flickerSpeed);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "particle emitter on trigger",
      "ideal_ir": {
        "class_name": "ParticleEmitterTrigger",
        "components": [
          "ParticleSystem",
          "Collider"
        ],
        "fields": [
          {
            "name": "emissionDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "particleCount",
            "type": "int",
            "default": 50
          }
        ],
        "behaviors": [
          {
            "name": "emit_particles_on_trigger_enter",
            "trigger": "when another object enters the trigger area",
            "actions": [
              {
                "action": "start emitting particles"
              },
              {
                "action": "set particle emission count to specified amount"
              },
              {
                "action": "play particle system for the specified duration"
              }
            ]
          },
          {
            "name": "stop_particles_on_trigger_exit",
            "trigger": "when object leaves the trigger area",
            "actions": [
              {
                "action": "stop emitting new particles"
              },
              {
                "action": "allow existing particles to fade out naturally"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class ParticleEmitterTrigger : MonoBehaviour\n{\n    [Header(\"Particle System\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private bool _createParticleSystemIfNull = true;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private bool _emitOnEnter = true;\n    [SerializeField] private bool _emitOnExit = false;\n    [SerializeField] private bool _emitOnStay = false;\n    [SerializeField] private float _stayEmissionInterval = 0.5f;\n    \n    [Header(\"Emission Settings\")]\n    [SerializeField] private int _particlesToEmit = 50;\n    [SerializeField] private bool _useCustomEmissionRate = false;\n    [SerializeField] private float _customEmissionRate = 100f;\n    [SerializeField] private float _emissionDuration = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _emissionSound;\n    [SerializeField] private bool _playAudioOnEmit = false;\n    \n    private float _lastStayEmissionTime;\n    private bool _isEmitting;\n    private float _emissionStartTime;\n    private float _originalEmissionRate;\n    \n    private void Start()\n    {\n        if (_particleSystem == null)\n        {\n            _particleSystem = GetComponent<ParticleSystem>();\n            \n            if (_particleSystem == null && _createParticleSystemIfNull)\n            {\n                _particleSystem = gameObject.AddComponent<ParticleSystem>();\n                ConfigureDefaultParticleSystem();\n            }\n        }\n        \n        if (_particleSystem != null)\n        {\n            var emission = _particleSystem.emission;\n            _originalEmissionRate = emission.rateOverTime.constant;\n            emission.enabled = false;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        Collider triggerCollider = GetComponent<Collider>();\n        if (triggerCollider != null)\n        {\n            triggerCollider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isEmitting && _useCustomEmissionRate)\n        {\n            if (Time.time - _emissionStartTime >= _emissionDuration)\n            {\n                StopEmission();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnEnter)\n        {\n            EmitParticles();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnExit)\n        {\n            EmitParticles();\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnStay)\n        {\n            if (Time.time - _lastStayEmissionTime >= _stayEmissionInterval)\n            {\n                EmitParticles();\n                _lastStayEmissionTime = Time.time;\n            }\n        }\n    }\n    \n    private void EmitParticles()\n    {\n        if (_particleSystem == null) return;\n        \n        if (_useCustomEmissionRate)\n        {\n            StartCustomEmission();\n        }\n        else\n        {\n            _particleSystem.Emit(_particlesToEmit);\n        }\n        \n        PlayEmissionAudio();\n    }\n    \n    private void StartCustomEmission()\n    {\n        var emission = _particleSystem.emission;\n        emission.enabled = true;\n        emission.rateOverTime = _customEmissionRate;\n        \n        _isEmitting = true;\n        _emissionStartTime = Time.time;\n    }\n    \n    private void StopEmission()\n    {\n        if (_particleSystem == null) return;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        emission.rateOverTime = _originalEmissionRate;\n        \n        _isEmitting = false;\n    }\n    \n    private void PlayEmissionAudio()\n    {\n        if (_playAudioOnEmit && _audioSource != null && _emissionSound != null)\n        {\n            _audioSource.PlayOneShot(_emissionSound);\n        }\n    }\n    \n    private void ConfigureDefaultParticleSystem()\n    {\n        if (_particleSystem == null) return;\n        \n        var main = _particleSystem.main;\n        main.startLifetime = 2f;\n        main.startSpeed = 5f;\n        main.startSize = 0.1f;\n        main.startColor = Color.white;\n        main.maxParticles = 1000;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        emission.rateOverTime = 50f;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Sphere;\n        shape.radius = 1f;\n        \n        var velocityOverLifetime = _particleSystem.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;\n        velocityOverLifetime.radial = new ParticleSystem.MinMaxCurve(2f);\n    }\n    \n    public void ForceEmit()\n    {\n        EmitParticles();\n    }\n    \n    public void ForceEmit(int particleCount)\n    {\n        if (_particleSystem != null)\n        {\n            _particleSystem.Emit(particleCount);\n            PlayEmissionAudio();\n        }\n    }\n    \n    public void SetTargetTag(string newTag)\n    {\n        _targetTag = newTag;\n    }\n    \n    public void SetParticleCount(int count)\n    {\n        _particlesToEmit = Mathf.Max(0, count);\n    }\n    \n    private void OnValidate()\n    {\n        _particlesToEmit = Mathf.Max(0, _particlesToEmit);\n        _stayEmissionInterval = Mathf.Max(0.1f, _stayEmissionInterval);\n        _emissionDuration = Mathf.Max(0.1f, _emissionDuration);\n        _customEmissionRate = Mathf.Max(0f, _customEmissionRate);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "color matching puzzle blocks",
      "ideal_ir": {
        "class_name": "ColorMatchingPuzzleBlock",
        "components": [
          "Renderer",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "blockColor",
            "type": "Color",
            "default": "Color.red"
          },
          {
            "name": "targetColor",
            "type": "Color",
            "default": "Color.red"
          },
          {
            "name": "isMatched",
            "type": "bool",
            "default": false
          },
          {
            "name": "canBeClicked",
            "type": "bool",
            "default": true
          },
          {
            "name": "matchSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "clickSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "animationDuration",
            "type": "float",
            "default": 0.3
          }
        ],
        "behaviors": [
          {
            "name": "initialize_block",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "set block color to a random color from available colors"
              },
              {
                "action": "set target color based on puzzle configuration"
              },
              {
                "action": "update visual appearance to show current color"
              }
            ]
          },
          {
            "name": "handle_click",
            "trigger": "when player clicks on this block",
            "actions": [
              {
                "action": "play click sound effect"
              },
              {
                "action": "cycle to next available color in sequence"
              },
              {
                "action": "update visual appearance with new color"
              },
              {
                "action": "animate color transition smoothly"
              }
            ]
          },
          {
            "name": "check_color_match",
            "trigger": "when block color changes",
            "actions": [
              {
                "action": "compare current color with target color"
              },
              {
                "action": "set matched status if colors are identical"
              },
              {
                "action": "notify puzzle manager of match status change"
              }
            ]
          },
          {
            "name": "show_match_feedback",
            "trigger": "when block becomes matched",
            "actions": [
              {
                "action": "play success sound effect"
              },
              {
                "action": "add glowing effect around block edges"
              },
              {
                "action": "disable further clicking on this block"
              },
              {
                "action": "animate celebration effect briefly"
              }
            ]
          },
          {
            "name": "show_hover_effect",
            "trigger": "when mouse hovers over clickable block",
            "actions": [
              {
                "action": "slightly increase block scale"
              },
              {
                "action": "add subtle highlight outline"
              },
              {
                "action": "show preview of next color in sequence"
              }
            ]
          },
          {
            "name": "remove_hover_effect",
            "trigger": "when mouse stops hovering over block",
            "actions": [
              {
                "action": "return block to normal scale"
              },
              {
                "action": "remove highlight outline"
              },
              {
                "action": "hide color preview"
              }
            ]
          },
          {
            "name": "reset_block",
            "trigger": "when puzzle is reset",
            "actions": [
              {
                "action": "set block color back to initial random color"
              },
              {
                "action": "clear matched status"
              },
              {
                "action": "enable clicking functionality"
              },
              {
                "action": "remove any visual effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class ColorMatchingPuzzle : MonoBehaviour\n{\n    [System.Serializable]\n    public class PuzzleBlock\n    {\n        public GameObject blockObject;\n        public Renderer blockRenderer;\n        public Color currentColor;\n        public Vector2Int gridPosition;\n        public bool isMatched;\n        \n        public PuzzleBlock(GameObject obj, Vector2Int pos)\n        {\n            blockObject = obj;\n            blockRenderer = obj.GetComponent<Renderer>();\n            gridPosition = pos;\n            isMatched = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class ColorSet\n    {\n        public Color color;\n        public Material material;\n    }\n    \n    [Header(\"Grid Settings\")]\n    [SerializeField] private int _gridWidth = 5;\n    [SerializeField] private int _gridHeight = 5;\n    [SerializeField] private float _blockSpacing = 1.1f;\n    [SerializeField] private GameObject _blockPrefab;\n    \n    [Header(\"Colors\")]\n    [SerializeField] private ColorSet[] _availableColors;\n    [SerializeField] private int _minMatchCount = 3;\n    \n    [Header(\"Gameplay\")]\n    [SerializeField] private float _swapAnimationDuration = 0.3f;\n    [SerializeField] private float _matchDelay = 0.5f;\n    [SerializeField] private float _fallSpeed = 5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _matchEffectPrefab;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swapSound;\n    [SerializeField] private AudioClip _matchSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnBlocksMatched;\n    public UnityEvent OnPuzzleCompleted;\n    public UnityEvent OnNoMovesAvailable;\n    \n    private PuzzleBlock[,] _grid;\n    private PuzzleBlock _selectedBlock;\n    private bool _isProcessing;\n    private Camera _mainCamera;\n    private int _totalMatches;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        InitializeGrid();\n        GenerateInitialBlocks();\n    }\n    \n    private void Update()\n    {\n        if (!_isProcessing)\n        {\n            HandleInput();\n        }\n    }\n    \n    private void InitializeGrid()\n    {\n        _grid = new PuzzleBlock[_gridWidth, _gridHeight];\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Vector3 position = new Vector3(\n                    (x - _gridWidth / 2f) * _blockSpacing,\n                    (y - _gridHeight / 2f) * _blockSpacing,\n                    0\n                );\n                \n                GameObject blockObj = Instantiate(_blockPrefab, position, Quaternion.identity, transform);\n                blockObj.name = $\"Block_{x}_{y}\";\n                \n                PuzzleBlock block = new PuzzleBlock(blockObj, new Vector2Int(x, y));\n                _grid[x, y] = block;\n                \n                // Add collider for mouse interaction\n                if (blockObj.GetComponent<Collider>() == null)\n                {\n                    blockObj.AddComponent<BoxCollider>();\n                }\n            }\n        }\n    }\n    \n    private void GenerateInitialBlocks()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                AssignRandomColor(_grid[x, y]);\n            }\n        }\n        \n        // Ensure no initial matches\n        while (HasMatches())\n        {\n            for (int x = 0; x < _gridWidth; x++)\n            {\n                for (int y = 0; y < _gridHeight; y++)\n                {\n                    if (IsPartOfMatch(_grid[x, y]))\n                    {\n                        AssignRandomColor(_grid[x, y]);\n                    }\n                }\n            }\n        }\n    }\n    \n    private void AssignRandomColor(PuzzleBlock block)\n    {\n        if (_availableColors.Length == 0) return;\n        \n        ColorSet colorSet = _availableColors[Random.Range(0, _availableColors.Length)];\n        block.currentColor = colorSet.color;\n        \n        if (block.blockRenderer != null && colorSet.material != null)\n        {\n            block.blockRenderer.material = colorSet.material;\n        }\n        else if (block.blockRenderer != null)\n        {\n            block.blockRenderer.material.color = colorSet.color;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n            \n            if (Physics.Raycast(ray, out hit))\n            {\n                PuzzleBlock clickedBlock = GetBlockFromGameObject(hit.collider.gameObject);\n                \n                if (clickedBlock != null)\n                {\n                    if (_selectedBlock == null)\n                    {\n                        SelectBlock(clickedBlock);\n                    }\n                    else if (_selectedBlock == clickedBlock)\n                    {\n                        DeselectBlock();\n                    }\n                    else if (AreAdjacent(_selectedBlock, clickedBlock))\n                    {\n                        StartCoroutine(SwapBlocks(_selectedBlock, clickedBlock));\n                    }\n                    else\n                    {\n                        SelectBlock(clickedBlock);\n                    }\n                }\n            }\n        }\n    }\n    \n    private PuzzleBlock GetBlockFromGameObject(GameObject obj)\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (_grid[x, y].blockObject == obj)\n                {\n                    return _grid[x, y];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private void SelectBlock(PuzzleBlock block)\n    {\n        DeselectBlock();\n        _selectedBlock = block;\n        \n        // Visual feedback for selection\n        if (block.blockRenderer != null)\n        {\n            block.blockRenderer.material.color = Color.Lerp(block.currentColor, Color.white, 0.3f);\n        }\n    }\n    \n    private void DeselectBlock()\n    {\n        if (_selectedBlock != null && _selectedBlock.blockRenderer != null)\n        {\n            _selectedBlock.blockRenderer.material.color = _selectedBlock.currentColor;\n        }\n        _selectedBlock = null;\n    }\n    \n    private bool AreAdjacent(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        Vector2Int pos1 = block1.gridPosition;\n        Vector2Int pos2 = block2.gridPosition;\n        \n        int deltaX = Mathf.Abs(pos1.x - pos2.x);\n        int deltaY = Mathf.Abs(pos1.y - pos2.y);\n        \n        return (deltaX == 1 && deltaY == 0) || (deltaX == 0 && deltaY == 1);\n    }\n    \n    private IEnumerator SwapBlocks(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        _isProcessing = true;\n        DeselectBlock();\n        \n        // Play swap sound\n        if (_audioSource != null && _swapSound != null)\n        {\n            _audioSource.PlayOneShot(_swapSound);\n        }\n        \n        // Animate swap\n        Vector3 pos1 = block1.blockObject.transform.position;\n        Vector3 pos2 = block2.blockObject.transform.position;\n        \n        float elapsed = 0f;\n        while (elapsed < _swapAnimationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / _swapAnimationDuration;\n            \n            block1.blockObject.transform.position = Vector3.Lerp(pos1, pos2, t);\n            block2.blockObject.transform.position = Vector3.Lerp(pos2, pos1, t);\n            \n            yield return null;\n        }\n        \n        // Complete swap\n        block1.blockObject.transform.position = pos2;\n        block2.blockObject.transform.position = pos1;\n        \n        // Swap colors\n        Color tempColor = block1.currentColor;\n        Material tempMaterial = block1.blockRenderer.material;\n        \n        block1.currentColor = block2.currentColor;\n        block1.blockRenderer.material = block2.blockRenderer.material;\n        \n        block2.currentColor = tempColor;\n        block2.blockRenderer.material = tempMaterial;\n        \n        // Check for matches\n        yield return new WaitForSeconds(_matchDelay);\n        \n        if (HasMatches())\n        {\n            yield return StartCoroutine(ProcessMatches());\n        }\n        else\n        {\n            // Swap back if no matches\n            yield return StartCoroutine(SwapBlocksBack(block1, block2));\n        }\n        \n        _isProcessing = false;\n    }\n    \n    private IEnumerator SwapBlocksBack(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        Vector3 pos1 = block1.blockObject.transform.position;\n        Vector3 pos2 = block2.blockObject.transform.position;\n        \n        float elapsed = 0f;\n        while (elapsed < _swapAnimationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / _swapAnimationDuration;\n            \n            block1.blockObject.transform.position = Vector3.Lerp(pos1, pos2, t);\n            block2.blockObject.transform.position = Vector3.Lerp(pos2, pos1, t);\n            \n            yield return null;\n        }\n        \n        // Swap colors back\n        Color tempColor = block1.currentColor;\n        Material tempMaterial = block1.blockRenderer.material;\n        \n        block1.currentColor = block2.currentColor;\n        block1.blockRenderer.material = block2.blockRenderer.material;\n        \n        block2.currentColor = tempColor;\n        block2.blockRenderer.material = tempMaterial;\n    }\n    \n    private bool HasMatches()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (IsPartOfMatch(_grid[x, y]))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private bool IsPartOfMatch(PuzzleBlock block)\n    {\n        return GetHorizontalMatchLength(block) >= _minMatchCount || \n               GetVerticalMatchLength(block) >= _minMatchCount;\n    }\n    \n    private int GetHorizontalMatchLength(PuzzleBlock block)\n    {\n        int count = 1;\n        Color color = block.currentColor;\n        Vector2Int pos = block.gridPosition;\n        \n        // Check left\n        for (int x = pos.x - 1; x >= 0; x--)\n        {\n            if (_grid[x, pos.y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        // Check right\n        for (int x = pos.x + 1; x < _gridWidth; x++)\n        {\n            if (_grid[x, pos.y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        return count;\n    }\n    \n    private int GetVerticalMatchLength(PuzzleBlock block)\n    {\n        int count = 1;\n        Color color = block.currentColor;\n        Vector2Int pos = block.gridPosition;\n        \n        // Check down\n        for (int y = pos.y - 1; y >= 0; y--)\n        {\n            if (_grid[pos.x, y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        // Check up\n        for (int y = pos.y + 1; y < _gridHeight; y++)\n        {\n            if (_grid[pos.x, y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        return count;\n    }\n    \n    private IEnumerator ProcessMatches()\n    {\n        List<PuzzleBlock> matchedBlocks = new List<PuzzleBlock>();\n        \n        // Find all matched blocks\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (IsPartOfMatch(_grid[x, y]))\n                {\n                    matchedBlocks.Add(_grid[x, y]);\n                    _grid[x, y].isMatched = true;\n                }\n            }\n        }\n        \n        // Play match sound and effects\n        if (_audioSource != null && _matchSound != null)\n        {\n            _audioSource.PlayOneShot(_matchSound);\n        }\n        \n        foreach (PuzzleBlock block in matchedBlocks)\n        {\n            if (_matchEffectPrefab != null)\n            {\n                Instantiate(_matchEffectPrefab, block.blockObject.transform.position, Quaternion.identity);\n            }\n        }\n        \n        _totalMatches += matchedBlocks.Count;\n        OnBlocksMatched?.Invoke(matchedBlocks.Count);\n        \n        // Remove matched blocks\n        foreach (PuzzleBlock block in matchedBlocks)\n        {\n            block.blockObject.SetActive(false);\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        // Drop blocks down\n        yield return StartCoroutine(DropBlocks());\n        \n        // Fill empty spaces\n        FillEmptySpaces();\n        \n        // Check for more matches\n        if (HasMatches())\n        {\n            yield return StartCoroutine(ProcessMatches());\n        }\n        else\n        {\n            CheckGameState();\n        }\n    }\n    \n    private IEnumerator DropBlocks()\n    {\n        bool blocksDropped = true;\n        \n        while (blocksDropped)\n        {\n            blocksDropped = false;\n            \n            for (int x = 0; x < _gridWidth; x++)\n            {\n                for (int y = 0; y < _gridHeight - 1; y++)\n                {\n                    if (!_grid[x, y].blockObject.activeInHierarchy && _grid[x, y + 1].blockObject.activeInHierarchy)\n                    {\n                        // Move block down\n                        _grid[x, y].blockObject.SetActive(true);\n                        _grid[x, y].currentColor = _grid[x, y + 1].currentColor;\n                        _grid[x, y].blockRenderer.material = _grid[x, y + 1].blockRenderer.material;\n                        \n                        _grid[x, y + 1].blockObject.SetActive(false);\n                        blocksDropped = true;\n                    }\n                }\n            }\n            \n            if (blocksDropped)\n            {\n                yield return new",
      "behavior_type": "general"
    },
    {
      "prompt": "pressure plates requiring weight",
      "ideal_ir": {
        "class_name": "PressurePlate",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "requiredWeight",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "currentWeight",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "activationThreshold",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "pressDepth",
            "type": "float",
            "default": 0.2
          }
        ],
        "behaviors": [
          {
            "name": "detect_weight_added",
            "trigger": "when object with rigidbody enters trigger area",
            "actions": [
              {
                "action": "add the mass of the entering object to current weight"
              },
              {
                "action": "check if total weight meets activation requirements"
              }
            ]
          },
          {
            "name": "detect_weight_removed",
            "trigger": "when object with rigidbody exits trigger area",
            "actions": [
              {
                "action": "subtract the mass of the exiting object from current weight"
              },
              {
                "action": "check if total weight still meets activation requirements"
              }
            ]
          },
          {
            "name": "activate_plate",
            "trigger": "when current weight exceeds required weight threshold",
            "actions": [
              {
                "action": "set activation state to true"
              },
              {
                "action": "lower the plate by press depth amount"
              },
              {
                "action": "play activation sound effect"
              },
              {
                "action": "change plate material to activated appearance"
              },
              {
                "action": "send activation signal to connected mechanisms"
              }
            ]
          },
          {
            "name": "deactivate_plate",
            "trigger": "when current weight falls below required weight threshold",
            "actions": [
              {
                "action": "set activation state to false"
              },
              {
                "action": "raise the plate back to original position"
              },
              {
                "action": "play deactivation sound effect"
              },
              {
                "action": "change plate material back to inactive appearance"
              },
              {
                "action": "send deactivation signal to connected mechanisms"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when weight changes on the plate",
            "actions": [
              {
                "action": "adjust plate height based on current weight ratio"
              },
              {
                "action": "update visual indicator showing weight progress"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Pressure Plate Settings\")]\n    [SerializeField] private float _requiredWeight = 10f;\n    [SerializeField] private float _activationDelay = 0.1f;\n    [SerializeField] private bool _requiresContinuousWeight = true;\n    [SerializeField] private bool _isOneTimeUse = false;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Transform _plateTransform;\n    [SerializeField] private float _pressedHeight = -0.1f;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private Material _activeMaterial;\n    [SerializeField] private Material _inactiveMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onActivated;\n    [SerializeField] private UnityEvent _onDeactivated;\n    \n    private List<WeightedObject> _objectsOnPlate = new List<WeightedObject>();\n    private float _currentWeight = 0f;\n    private bool _isActivated = false;\n    private bool _hasBeenUsed = false;\n    private float _originalHeight;\n    private float _activationTimer = 0f;\n    private Renderer _plateRenderer;\n    private Collider _plateCollider;\n    \n    [System.Serializable]\n    public class WeightedObject\n    {\n        public GameObject gameObject;\n        public float weight;\n        \n        public WeightedObject(GameObject obj, float w)\n        {\n            gameObject = obj;\n            weight = w;\n        }\n    }\n    \n    void Start()\n    {\n        if (_plateTransform == null)\n            _plateTransform = transform;\n            \n        _originalHeight = _plateTransform.position.y;\n        _plateRenderer = GetComponent<Renderer>();\n        _plateCollider = GetComponent<Collider>();\n        \n        if (_plateCollider != null)\n            _plateCollider.isTrigger = true;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        UpdateVisuals();\n    }\n    \n    void Update()\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        UpdatePlatePosition();\n        \n        if (_activationTimer > 0f)\n        {\n            _activationTimer -= Time.deltaTime;\n            if (_activationTimer <= 0f)\n            {\n                CheckActivation();\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        float weight = GetObjectWeight(other.gameObject);\n        if (weight > 0f)\n        {\n            WeightedObject weightedObj = new WeightedObject(other.gameObject, weight);\n            _objectsOnPlate.Add(weightedObj);\n            _currentWeight += weight;\n            \n            _activationTimer = _activationDelay;\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        WeightedObject objToRemove = _objectsOnPlate.Find(obj => obj.gameObject == other.gameObject);\n        if (objToRemove != null)\n        {\n            _objectsOnPlate.Remove(objToRemove);\n            _currentWeight -= objToRemove.weight;\n            _currentWeight = Mathf.Max(0f, _currentWeight);\n            \n            if (_requiresContinuousWeight)\n            {\n                _activationTimer = _activationDelay;\n            }\n        }\n    }\n    \n    private float GetObjectWeight(GameObject obj)\n    {\n        // Check for Rigidbody mass\n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            return rb.mass;\n        }\n        \n        // Check for player tag (default weight)\n        if (obj.CompareTag(\"Player\"))\n        {\n            return 5f;\n        }\n        \n        // Check for specific tags with predefined weights\n        if (obj.CompareTag(\"Heavy\"))\n            return 15f;\n        if (obj.CompareTag(\"Light\"))\n            return 2f;\n            \n        // Default weight for untagged objects\n        return 1f;\n    }\n    \n    private void CheckActivation()\n    {\n        bool shouldBeActive = _currentWeight >= _requiredWeight;\n        \n        if (shouldBeActive && !_isActivated)\n        {\n            ActivatePlate();\n        }\n        else if (!shouldBeActive && _isActivated && _requiresContinuousWeight)\n        {\n            DeactivatePlate();\n        }\n    }\n    \n    private void ActivatePlate()\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        _isActivated = true;\n        _hasBeenUsed = true;\n        \n        UpdateVisuals();\n        PlaySound(_activationSound);\n        _onActivated?.Invoke();\n    }\n    \n    private void DeactivatePlate()\n    {\n        if (_isOneTimeUse && _hasBeenUsed)\n            return;\n            \n        _isActivated = false;\n        \n        UpdateVisuals();\n        PlaySound(_deactivationSound);\n        _onDeactivated?.Invoke();\n    }\n    \n    private void UpdatePlatePosition()\n    {\n        float targetHeight = _isActivated ? _originalHeight + _pressedHeight : _originalHeight;\n        Vector3 currentPos = _plateTransform.position;\n        Vector3 targetPos = new Vector3(currentPos.x, targetHeight, currentPos.z);\n        \n        _plateTransform.position = Vector3.Lerp(currentPos, targetPos, Time.deltaTime * _animationSpeed);\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_plateRenderer != null)\n        {\n            if (_isActivated && _activeMaterial != null)\n            {\n                _plateRenderer.material = _activeMaterial;\n            }\n            else if (!_isActivated && _inactiveMaterial != null)\n            {\n                _plateRenderer.material = _inactiveMaterial;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsActivated()\n    {\n        return _isActivated;\n    }\n    \n    public float GetCurrentWeight()\n    {\n        return _currentWeight;\n    }\n    \n    public float GetRequiredWeight()\n    {\n        return _requiredWeight;\n    }\n    \n    public void SetRequiredWeight(float weight)\n    {\n        _requiredWeight = weight;\n    }\n    \n    public void ResetPlate()\n    {\n        if (_isOneTimeUse)\n            return;\n            \n        _objectsOnPlate.Clear();\n        _currentWeight = 0f;\n        _isActivated = false;\n        _hasBeenUsed = false;\n        _activationTimer = 0f;\n        \n        UpdateVisuals();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActivated ? Color.green : Color.red;\n        Gizmos.DrawWireCube(transform.position, GetComponent<Collider>()?.bounds.size ?? Vector3.one);\n        \n        // Draw weight indicator\n        Gizmos.color = Color.yellow;\n        Vector3 textPos = transform.position + Vector3.up * 2f;\n        \n        #if UNITY_EDITOR\n        UnityEditor.Handles.Label(textPos, $\"Weight: {_currentWeight:F1}/{_requiredWeight:F1}\");\n        #endif\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rotating puzzle ring",
      "ideal_ir": {
        "class_name": "RotatingPuzzleRing",
        "components": [
          "Transform",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 45
          },
          {
            "name": "targetRotation",
            "type": "float",
            "default": 0
          },
          {
            "name": "currentRotation",
            "type": "float",
            "default": 0
          },
          {
            "name": "isLocked",
            "type": "bool",
            "default": false
          },
          {
            "name": "correctPosition",
            "type": "float",
            "default": 180
          },
          {
            "name": "tolerance",
            "type": "float",
            "default": 5
          },
          {
            "name": "clickSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "solveSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "rotate_ring",
            "trigger": "when player clicks on the ring and ring is not locked",
            "actions": [
              {
                "action": "play click sound"
              },
              {
                "action": "rotate ring by rotation speed amount"
              },
              {
                "action": "update current rotation value"
              }
            ]
          },
          {
            "name": "check_solution",
            "trigger": "when ring rotation changes",
            "actions": [
              {
                "action": "check if current rotation is within tolerance of correct position"
              },
              {
                "action": "if position is correct then lock the ring and play solve sound"
              },
              {
                "action": "if position is correct then change ring color to indicate solved state"
              }
            ]
          },
          {
            "name": "smooth_rotation",
            "trigger": "every frame when ring is rotating",
            "actions": [
              {
                "action": "smoothly rotate ring toward target rotation"
              },
              {
                "action": "stop rotation when target is reached"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when mouse hovers over ring and ring is not locked",
            "actions": [
              {
                "action": "highlight ring with glow effect"
              },
              {
                "action": "show rotation indicator"
              }
            ]
          },
          {
            "name": "reset_ring",
            "trigger": "when puzzle is reset",
            "actions": [
              {
                "action": "unlock the ring"
              },
              {
                "action": "reset rotation to starting position"
              },
              {
                "action": "restore original ring color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RotatingPuzzleRing : MonoBehaviour\n{\n    [Header(\"Ring Configuration\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _targetAngle = 0f;\n    [SerializeField] private float _angleThreshold = 5f;\n    [SerializeField] private bool _canRotate = true;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _rotateClockwiseKey = KeyCode.E;\n    [SerializeField] private KeyCode _rotateCounterClockwiseKey = KeyCode.Q;\n    [SerializeField] private bool _useMouseInteraction = true;\n    [SerializeField] private float _interactionDistance = 5f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _correctColor = Color.green;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    [SerializeField] private Renderer _ringRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotateSound;\n    [SerializeField] private AudioClip _correctPositionSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCorrectPosition;\n    public UnityEvent OnRotationStart;\n    public UnityEvent OnRotationComplete;\n    \n    private float _currentAngle;\n    private bool _isRotating;\n    private bool _isInCorrectPosition;\n    private bool _isHighlighted;\n    private Camera _playerCamera;\n    private Material _ringMaterial;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_ringRenderer == null)\n            _ringRenderer = GetComponent<Renderer>();\n            \n        if (_ringRenderer != null)\n        {\n            _ringMaterial = _ringRenderer.material;\n            _originalColor = _ringMaterial.color;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        _currentAngle = transform.eulerAngles.z;\n        CheckCorrectPosition();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateRotation();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_canRotate || _isRotating)\n            return;\n            \n        bool rotateClockwise = false;\n        bool rotateCounterClockwise = false;\n        \n        // Keyboard input\n        if (Input.GetKeyDown(_rotateClockwiseKey))\n            rotateClockwise = true;\n        else if (Input.GetKeyDown(_rotateCounterClockwiseKey))\n            rotateCounterClockwise = true;\n            \n        // Mouse interaction\n        if (_useMouseInteraction && Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit, _interactionDistance))\n            {\n                if (hit.collider.gameObject == gameObject)\n                {\n                    Vector3 hitPoint = hit.point;\n                    Vector3 centerToHit = hitPoint - transform.position;\n                    Vector3 mouseWorldPos = _playerCamera.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, hit.distance));\n                    \n                    float angle = Vector3.SignedAngle(Vector3.right, centerToHit, Vector3.forward);\n                    if (angle > 0)\n                        rotateClockwise = true;\n                    else\n                        rotateCounterClockwise = true;\n                }\n            }\n        }\n        \n        if (rotateClockwise)\n            StartRotation(90f);\n        else if (rotateCounterClockwise)\n            StartRotation(-90f);\n    }\n    \n    private void StartRotation(float rotationAmount)\n    {\n        if (_isRotating)\n            return;\n            \n        _isRotating = true;\n        _targetAngle = _currentAngle + rotationAmount;\n        \n        // Normalize angle\n        while (_targetAngle >= 360f)\n            _targetAngle -= 360f;\n        while (_targetAngle < 0f)\n            _targetAngle += 360f;\n            \n        OnRotationStart?.Invoke();\n        PlaySound(_rotateSound);\n    }\n    \n    private void UpdateRotation()\n    {\n        if (!_isRotating)\n            return;\n            \n        float step = _rotationSpeed * Time.deltaTime;\n        _currentAngle = Mathf.MoveTowardsAngle(_currentAngle, _targetAngle, step);\n        \n        transform.rotation = Quaternion.Euler(0, 0, _currentAngle);\n        \n        if (Mathf.Abs(Mathf.DeltaAngle(_currentAngle, _targetAngle)) < 0.1f)\n        {\n            _currentAngle = _targetAngle;\n            transform.rotation = Quaternion.Euler(0, 0, _currentAngle);\n            _isRotating = false;\n            \n            OnRotationComplete?.Invoke();\n            CheckCorrectPosition();\n        }\n    }\n    \n    private void CheckCorrectPosition()\n    {\n        float angleDifference = Mathf.Abs(Mathf.DeltaAngle(_currentAngle, 0f));\n        bool wasInCorrectPosition = _isInCorrectPosition;\n        _isInCorrectPosition = angleDifference <= _angleThreshold;\n        \n        if (_isInCorrectPosition && !wasInCorrectPosition)\n        {\n            OnCorrectPosition?.Invoke();\n            PlaySound(_correctPositionSound);\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_ringMaterial == null)\n            return;\n            \n        Color targetColor = _originalColor;\n        \n        if (_isInCorrectPosition)\n            targetColor = _correctColor;\n        else if (_isHighlighted)\n            targetColor = _highlightColor;\n        else\n            targetColor = _normalColor;\n            \n        _ringMaterial.color = Color.Lerp(_ringMaterial.color, targetColor, Time.deltaTime * 5f);\n    }\n    \n    private void OnMouseEnter()\n    {\n        if (_useMouseInteraction && _canRotate)\n        {\n            _isHighlighted = true;\n        }\n    }\n    \n    private void OnMouseExit()\n    {\n        _isHighlighted = false;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetCanRotate(bool canRotate)\n    {\n        _canRotate = canRotate;\n    }\n    \n    public void SetTargetAngle(float angle)\n    {\n        while (angle >= 360f)\n            angle -= 360f;\n        while (angle < 0f)\n            angle += 360f;\n            \n        // Update the correct position check to use the new target\n        float angleDifference = Mathf.Abs(Mathf.DeltaAngle(_currentAngle, angle));\n        _isInCorrectPosition = angleDifference <= _angleThreshold;\n    }\n    \n    public bool IsInCorrectPosition()\n    {\n        return _isInCorrectPosition;\n    }\n    \n    public float GetCurrentAngle()\n    {\n        return _currentAngle;\n    }\n    \n    public void ResetRing()\n    {\n        _isRotating = false;\n        _currentAngle = 0f;\n        transform.rotation = Quaternion.identity;\n        CheckCorrectPosition();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "sequence memory game",
      "ideal_ir": {
        "class_name": "SequenceMemoryGame",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "gameButtons",
            "type": "GameObject[]",
            "default": null
          },
          {
            "name": "buttonColors",
            "type": "Color[]",
            "default": null
          },
          {
            "name": "gameSequence",
            "type": "int[]",
            "default": null
          },
          {
            "name": "playerSequence",
            "type": "int[]",
            "default": null
          },
          {
            "name": "currentSequenceIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "playerInputIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "sequenceLength",
            "type": "int",
            "default": 1
          },
          {
            "name": "maxSequenceLength",
            "type": "int",
            "default": 10
          },
          {
            "name": "displaySpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "buttonHighlightDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "isShowingSequence",
            "type": "bool",
            "default": false
          },
          {
            "name": "isWaitingForInput",
            "type": "bool",
            "default": false
          },
          {
            "name": "gameScore",
            "type": "int",
            "default": 0
          },
          {
            "name": "gameState",
            "type": "string",
            "default": "menu"
          }
        ],
        "behaviors": [
          {
            "name": "start_new_game",
            "trigger": "when start button is pressed",
            "actions": [
              {
                "action": "reset game score to zero"
              },
              {
                "action": "set sequence length to one"
              },
              {
                "action": "clear game sequence array"
              },
              {
                "action": "generate new random button for sequence"
              },
              {
                "action": "change game state to playing"
              },
              {
                "action": "begin showing sequence to player"
              }
            ]
          },
          {
            "name": "show_sequence",
            "trigger": "when beginning to show sequence",
            "actions": [
              {
                "action": "set showing sequence flag to true"
              },
              {
                "action": "disable player input"
              },
              {
                "action": "reset sequence display index to zero"
              },
              {
                "action": "start highlighting buttons in sequence order"
              }
            ]
          },
          {
            "name": "highlight_sequence_button",
            "trigger": "when displaying next button in sequence",
            "actions": [
              {
                "action": "change button color to bright highlight color"
              },
              {
                "action": "play button sound effect"
              },
              {
                "action": "wait for highlight duration"
              },
              {
                "action": "return button to normal color"
              },
              {
                "action": "move to next button in sequence"
              }
            ]
          },
          {
            "name": "finish_sequence_display",
            "trigger": "when all sequence buttons have been shown",
            "actions": [
              {
                "action": "set showing sequence flag to false"
              },
              {
                "action": "enable player input"
              },
              {
                "action": "set waiting for input flag to true"
              },
              {
                "action": "reset player input index to zero"
              },
              {
                "action": "clear player sequence array"
              }
            ]
          },
          {
            "name": "handle_button_press",
            "trigger": "when player clicks a game button",
            "actions": [
              {
                "action": "add clicked button to player sequence"
              },
              {
                "action": "highlight clicked button briefly"
              },
              {
                "action": "play button press sound"
              },
              {
                "action": "check if input matches sequence"
              }
            ]
          },
          {
            "name": "validate_correct_input",
            "trigger": "when player input matches sequence so far",
            "actions": [
              {
                "action": "increment player input index"
              },
              {
                "action": "check if complete sequence entered correctly"
              }
            ]
          },
          {
            "name": "handle_sequence_success",
            "trigger": "when player completes sequence correctly",
            "actions": [
              {
                "action": "increase game score"
              },
              {
                "action": "play success sound effect"
              },
              {
                "action": "increment sequence length"
              },
              {
                "action": "add new random button to sequence"
              },
              {
                "action": "check if maximum length reached"
              }
            ]
          },
          {
            "name": "advance_to_next_round",
            "trigger": "when ready for next sequence round",
            "actions": [
              {
                "action": "set waiting for input flag to false"
              },
              {
                "action": "wait brief pause between rounds"
              },
              {
                "action": "begin showing new sequence"
              }
            ]
          },
          {
            "name": "handle_wrong_input",
            "trigger": "when player input does not match sequence",
            "actions": [
              {
                "action": "play error sound effect"
              },
              {
                "action": "flash all buttons red briefly"
              },
              {
                "action": "change game state to game over"
              },
              {
                "action": "display final score"
              },
              {
                "action": "show restart option"
              }
            ]
          },
          {
            "name": "handle_game_completion",
            "trigger": "when maximum sequence length is reached",
            "actions": [
              {
                "action": "play victory sound effect"
              },
              {
                "action": "flash all buttons in celebration pattern"
              },
              {
                "action": "change game state to victory"
              },
              {
                "action": "display congratulations message"
              },
              {
                "action": "show final score and restart option"
              }
            ]
          },
          {
            "name": "reset_game",
            "trigger": "when restart button is pressed",
            "actions": [
              {
                "action": "return all buttons to normal colors"
              },
              {
                "action": "clear all sequence arrays"
              },
              {
                "action": "reset all game variables to defaults"
              },
              {
                "action": "change game state back to menu"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class SequenceMemoryGame : MonoBehaviour\n{\n    [System.Serializable]\n    public class GameButton\n    {\n        public Button button;\n        public Color normalColor = Color.white;\n        public Color highlightColor = Color.yellow;\n        public AudioClip soundClip;\n        [HideInInspector] public Image buttonImage;\n        [HideInInspector] public AudioSource audioSource;\n    }\n\n    [Header(\"Game Setup\")]\n    [SerializeField] private GameButton[] _gameButtons;\n    [SerializeField] private float _sequenceDisplayTime = 1f;\n    [SerializeField] private float _buttonHighlightDuration = 0.5f;\n    [SerializeField] private float _timeBetweenButtons = 0.3f;\n    [SerializeField] private int _startingSequenceLength = 3;\n    [SerializeField] private int _maxSequenceLength = 10;\n\n    [Header(\"UI Elements\")]\n    [SerializeField] private Button _startButton;\n    [SerializeField] private Button _resetButton;\n    [SerializeField] private Text _scoreText;\n    [SerializeField] private Text _levelText;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private GameObject _gameOverPanel;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _successSound;\n    [SerializeField] private AudioClip _failSound;\n    [SerializeField] private AudioSource _mainAudioSource;\n\n    [Header(\"Events\")]\n    public UnityEvent OnGameStart;\n    public UnityEvent OnGameOver;\n    public UnityEvent OnLevelComplete;\n    public UnityEvent<int> OnScoreChanged;\n\n    private List<int> _currentSequence = new List<int>();\n    private List<int> _playerInput = new List<int>();\n    private int _currentLevel = 1;\n    private int _score = 0;\n    private bool _isShowingSequence = false;\n    private bool _isWaitingForInput = false;\n    private bool _gameActive = false;\n    private Coroutine _sequenceCoroutine;\n\n    private void Start()\n    {\n        InitializeGame();\n    }\n\n    private void InitializeGame()\n    {\n        // Initialize button components\n        for (int i = 0; i < _gameButtons.Length; i++)\n        {\n            if (_gameButtons[i].button != null)\n            {\n                _gameButtons[i].buttonImage = _gameButtons[i].button.GetComponent<Image>();\n                _gameButtons[i].audioSource = _gameButtons[i].button.GetComponent<AudioSource>();\n                \n                if (_gameButtons[i].audioSource == null)\n                {\n                    _gameButtons[i].audioSource = _gameButtons[i].button.gameObject.AddComponent<AudioSource>();\n                }\n\n                int buttonIndex = i;\n                _gameButtons[i].button.onClick.AddListener(() => OnButtonPressed(buttonIndex));\n                \n                if (_gameButtons[i].buttonImage != null)\n                {\n                    _gameButtons[i].buttonImage.color = _gameButtons[i].normalColor;\n                }\n            }\n        }\n\n        // Setup UI buttons\n        if (_startButton != null)\n            _startButton.onClick.AddListener(StartGame);\n        \n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetGame);\n\n        // Initialize UI\n        UpdateUI();\n        SetGameButtonsInteractable(false);\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n    }\n\n    public void StartGame()\n    {\n        _gameActive = true;\n        _currentLevel = 1;\n        _score = 0;\n        _currentSequence.Clear();\n        _playerInput.Clear();\n\n        if (_startButton != null)\n            _startButton.interactable = false;\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n\n        UpdateUI();\n        OnGameStart?.Invoke();\n        \n        StartNewLevel();\n    }\n\n    public void ResetGame()\n    {\n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n            _sequenceCoroutine = null;\n        }\n\n        _gameActive = false;\n        _isShowingSequence = false;\n        _isWaitingForInput = false;\n        _currentLevel = 1;\n        _score = 0;\n        _currentSequence.Clear();\n        _playerInput.Clear();\n\n        if (_startButton != null)\n            _startButton.interactable = true;\n\n        SetGameButtonsInteractable(false);\n        ResetButtonColors();\n        UpdateUI();\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n    }\n\n    private void StartNewLevel()\n    {\n        if (!_gameActive) return;\n\n        _playerInput.Clear();\n        GenerateSequence();\n        \n        if (_statusText != null)\n            _statusText.text = \"Watch the sequence...\";\n\n        _sequenceCoroutine = StartCoroutine(ShowSequence());\n    }\n\n    private void GenerateSequence()\n    {\n        int sequenceLength = Mathf.Min(_startingSequenceLength + _currentLevel - 1, _maxSequenceLength);\n        \n        if (_currentLevel == 1)\n        {\n            _currentSequence.Clear();\n        }\n        else\n        {\n            // Add one more button to existing sequence\n        }\n\n        while (_currentSequence.Count < sequenceLength)\n        {\n            int randomButton = Random.Range(0, _gameButtons.Length);\n            _currentSequence.Add(randomButton);\n        }\n    }\n\n    private IEnumerator ShowSequence()\n    {\n        _isShowingSequence = true;\n        SetGameButtonsInteractable(false);\n        \n        yield return new WaitForSeconds(_sequenceDisplayTime);\n\n        for (int i = 0; i < _currentSequence.Count; i++)\n        {\n            int buttonIndex = _currentSequence[i];\n            yield return StartCoroutine(HighlightButton(buttonIndex));\n            yield return new WaitForSeconds(_timeBetweenButtons);\n        }\n\n        _isShowingSequence = false;\n        _isWaitingForInput = true;\n        SetGameButtonsInteractable(true);\n        \n        if (_statusText != null)\n            _statusText.text = \"Repeat the sequence!\";\n    }\n\n    private IEnumerator HighlightButton(int buttonIndex)\n    {\n        if (buttonIndex < 0 || buttonIndex >= _gameButtons.Length) yield break;\n\n        GameButton gameButton = _gameButtons[buttonIndex];\n        \n        // Highlight button\n        if (gameButton.buttonImage != null)\n        {\n            gameButton.buttonImage.color = gameButton.highlightColor;\n        }\n\n        // Play sound\n        if (gameButton.audioSource != null && gameButton.soundClip != null)\n        {\n            gameButton.audioSource.PlayOneShot(gameButton.soundClip);\n        }\n\n        yield return new WaitForSeconds(_buttonHighlightDuration);\n\n        // Return to normal color\n        if (gameButton.buttonImage != null)\n        {\n            gameButton.buttonImage.color = gameButton.normalColor;\n        }\n    }\n\n    private void OnButtonPressed(int buttonIndex)\n    {\n        if (!_isWaitingForInput || !_gameActive) return;\n\n        _playerInput.Add(buttonIndex);\n        StartCoroutine(HighlightButton(buttonIndex));\n\n        // Check if input matches sequence so far\n        bool isCorrect = true;\n        for (int i = 0; i < _playerInput.Count; i++)\n        {\n            if (_playerInput[i] != _currentSequence[i])\n            {\n                isCorrect = false;\n                break;\n            }\n        }\n\n        if (!isCorrect)\n        {\n            GameOver();\n            return;\n        }\n\n        // Check if sequence is complete\n        if (_playerInput.Count == _currentSequence.Count)\n        {\n            LevelComplete();\n        }\n    }\n\n    private void LevelComplete()\n    {\n        _isWaitingForInput = false;\n        SetGameButtonsInteractable(false);\n        \n        _score += _currentLevel * 10;\n        _currentLevel++;\n        \n        OnScoreChanged?.Invoke(_score);\n        OnLevelComplete?.Invoke();\n\n        if (_mainAudioSource != null && _successSound != null)\n        {\n            _mainAudioSource.PlayOneShot(_successSound);\n        }\n\n        if (_statusText != null)\n            _statusText.text = \"Correct! Next level...\";\n\n        UpdateUI();\n        \n        Invoke(nameof(StartNewLevel), 2f);\n    }\n\n    private void GameOver()\n    {\n        _gameActive = false;\n        _isWaitingForInput = false;\n        SetGameButtonsInteractable(false);\n        \n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n            _sequenceCoroutine = null;\n        }\n\n        if (_mainAudioSource != null && _failSound != null)\n        {\n            _mainAudioSource.PlayOneShot(_failSound);\n        }\n\n        if (_statusText != null)\n            _statusText.text = \"Game Over!\";\n\n        if (_startButton != null)\n            _startButton.interactable = true;\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(true);\n\n        OnGameOver?.Invoke();\n    }\n\n    private void SetGameButtonsInteractable(bool interactable)\n    {\n        foreach (GameButton gameButton in _gameButtons)\n        {\n            if (gameButton.button != null)\n            {\n                gameButton.button.interactable = interactable;\n            }\n        }\n    }\n\n    private void ResetButtonColors()\n    {\n        foreach (GameButton gameButton in _gameButtons)\n        {\n            if (gameButton.buttonImage != null)\n            {\n                gameButton.buttonImage.color = gameButton.normalColor;\n            }\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_scoreText != null)\n            _scoreText.text = \"Score: \" + _score;\n\n        if (_levelText != null)\n            _levelText.text = \"Level: \" + _currentLevel;\n\n        if (_statusText != null && !_gameActive)\n            _statusText.text = \"Press Start to begin!\";\n    }\n\n    private void OnDestroy()\n    {\n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "sliding tile puzzle",
      "ideal_ir": {
        "class_name": "SlidingTilePuzzle",
        "components": [
          "Transform",
          "Collider2D",
          "SpriteRenderer"
        ],
        "fields": [
          {
            "name": "gridSize",
            "type": "int",
            "default": 3
          },
          {
            "name": "tileSize",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "slideSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isSliding",
            "type": "bool",
            "default": false
          },
          {
            "name": "emptyPosition",
            "type": "Vector2Int",
            "default": "2,2"
          },
          {
            "name": "currentPosition",
            "type": "Vector2Int",
            "default": "0,0"
          },
          {
            "name": "targetPosition",
            "type": "Vector3",
            "default": "0,0,0"
          },
          {
            "name": "shuffleCount",
            "type": "int",
            "default": 100
          },
          {
            "name": "isPuzzleSolved",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initialize_puzzle",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "create grid of numbered tiles"
              },
              {
                "action": "position tiles in correct order"
              },
              {
                "action": "remove bottom right tile to create empty space"
              },
              {
                "action": "shuffle tiles randomly"
              }
            ]
          },
          {
            "name": "handle_tile_click",
            "trigger": "when tile is clicked by player",
            "actions": [
              {
                "action": "check if clicked tile is adjacent to empty space"
              },
              {
                "action": "if adjacent and not currently sliding then start sliding tile toward empty space"
              }
            ]
          },
          {
            "name": "slide_tile",
            "trigger": "when tile should move to empty space",
            "actions": [
              {
                "action": "set sliding state to true"
              },
              {
                "action": "smoothly move tile from current position to empty space position"
              },
              {
                "action": "update grid positions when movement completes"
              },
              {
                "action": "set sliding state to false"
              }
            ]
          },
          {
            "name": "check_puzzle_completion",
            "trigger": "when any tile finishes moving",
            "actions": [
              {
                "action": "verify all tiles are in correct numerical order"
              },
              {
                "action": "if puzzle is solved then display victory message"
              },
              {
                "action": "if puzzle is solved then disable further tile interactions"
              }
            ]
          },
          {
            "name": "shuffle_puzzle",
            "trigger": "when shuffle button is pressed",
            "actions": [
              {
                "action": "perform random valid moves to scramble tiles"
              },
              {
                "action": "ensure puzzle remains solvable after shuffling"
              },
              {
                "action": "reset solved state to false"
              }
            ]
          },
          {
            "name": "validate_move",
            "trigger": "when checking if tile can move",
            "actions": [
              {
                "action": "determine if tile shares row or column with empty space"
              },
              {
                "action": "confirm tile is exactly one space away from empty position"
              },
              {
                "action": "verify no other tiles are currently sliding"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SlidingTilePuzzle : MonoBehaviour\n{\n    [System.Serializable]\n    public class PuzzleTile\n    {\n        public GameObject tileObject;\n        public int correctPosition;\n        public int currentPosition;\n        public bool isEmpty;\n        \n        public PuzzleTile(GameObject obj, int correct, int current, bool empty = false)\n        {\n            tileObject = obj;\n            correctPosition = correct;\n            currentPosition = current;\n            isEmpty = empty;\n        }\n    }\n\n    [Header(\"Puzzle Configuration\")]\n    [SerializeField] private int _gridSize = 3;\n    [SerializeField] private float _tileSize = 1f;\n    [SerializeField] private float _tileSpacing = 0.1f;\n    [SerializeField] private float _slideSpeed = 5f;\n    \n    [Header(\"Tile Setup\")]\n    [SerializeField] private GameObject _tilePrefab;\n    [SerializeField] private Transform _puzzleContainer;\n    [SerializeField] private Material _tileMaterial;\n    [SerializeField] private Material _emptyTileMaterial;\n    \n    [Header(\"Input\")]\n    [SerializeField] private LayerMask _tileLayerMask = 1;\n    [SerializeField] private Camera _puzzleCamera;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _slideSFX;\n    [SerializeField] private AudioClip _completeSFX;\n    [SerializeField] private AudioClip _invalidMoveSFX;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Button _shuffleButton;\n    [SerializeField] private Button _solveButton;\n    [SerializeField] private Text _movesText;\n    [SerializeField] private Text _statusText;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPuzzleComplete;\n    public UnityEvent OnTileSlide;\n    public UnityEvent OnInvalidMove;\n\n    private PuzzleTile[,] _grid;\n    private List<PuzzleTile> _tiles;\n    private Vector2Int _emptyPosition;\n    private int _totalTiles;\n    private int _moveCount;\n    private bool _isSliding;\n    private bool _isPuzzleComplete;\n    private bool _isShuffling;\n\n    private void Start()\n    {\n        InitializePuzzle();\n        SetupUI();\n        \n        if (_puzzleCamera == null)\n            _puzzleCamera = Camera.main;\n    }\n\n    private void Update()\n    {\n        if (!_isSliding && !_isShuffling && !_isPuzzleComplete)\n        {\n            HandleInput();\n        }\n    }\n\n    private void InitializePuzzle()\n    {\n        _totalTiles = _gridSize * _gridSize;\n        _grid = new PuzzleTile[_gridSize, _gridSize];\n        _tiles = new List<PuzzleTile>();\n        _moveCount = 0;\n        _isPuzzleComplete = false;\n        \n        CreateTiles();\n        PositionTiles();\n        ShufflePuzzle();\n    }\n\n    private void CreateTiles()\n    {\n        if (_puzzleContainer == null)\n        {\n            GameObject container = new GameObject(\"Puzzle Container\");\n            _puzzleContainer = container.transform;\n        }\n\n        // Clear existing tiles\n        foreach (Transform child in _puzzleContainer)\n        {\n            if (Application.isPlaying)\n                Destroy(child.gameObject);\n            else\n                DestroyImmediate(child.gameObject);\n        }\n\n        _tiles.Clear();\n\n        // Create tiles (leave last position empty)\n        for (int i = 0; i < _totalTiles - 1; i++)\n        {\n            GameObject tileObj = Instantiate(_tilePrefab, _puzzleContainer);\n            tileObj.name = $\"Tile_{i + 1}\";\n            \n            // Add number text\n            Text numberText = tileObj.GetComponentInChildren<Text>();\n            if (numberText == null)\n            {\n                GameObject textObj = new GameObject(\"Number\");\n                textObj.transform.SetParent(tileObj.transform);\n                textObj.transform.localPosition = Vector3.zero;\n                numberText = textObj.AddComponent<Text>();\n                numberText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n                numberText.fontSize = 24;\n                numberText.alignment = TextAnchor.MiddleCenter;\n                numberText.color = Color.black;\n            }\n            numberText.text = (i + 1).ToString();\n\n            // Ensure collider exists\n            if (tileObj.GetComponent<Collider>() == null)\n            {\n                BoxCollider collider = tileObj.AddComponent<BoxCollider>();\n                collider.size = Vector3.one * _tileSize;\n            }\n\n            // Set material\n            Renderer renderer = tileObj.GetComponent<Renderer>();\n            if (renderer != null && _tileMaterial != null)\n                renderer.material = _tileMaterial;\n\n            PuzzleTile tile = new PuzzleTile(tileObj, i, i);\n            _tiles.Add(tile);\n        }\n\n        // Create empty tile (invisible)\n        GameObject emptyObj = new GameObject(\"Empty Tile\");\n        emptyObj.transform.SetParent(_puzzleContainer);\n        if (_emptyTileMaterial != null)\n        {\n            MeshRenderer emptyRenderer = emptyObj.AddComponent<MeshRenderer>();\n            emptyRenderer.material = _emptyTileMaterial;\n            MeshFilter emptyFilter = emptyObj.AddComponent<MeshFilter>();\n            emptyFilter.mesh = Resources.GetBuiltinResource<Mesh>(\"Cube\");\n            emptyObj.transform.localScale = Vector3.one * _tileSize * 0.1f; // Very small\n        }\n\n        PuzzleTile emptyTile = new PuzzleTile(emptyObj, _totalTiles - 1, _totalTiles - 1, true);\n        _tiles.Add(emptyTile);\n        _emptyPosition = new Vector2Int(_gridSize - 1, _gridSize - 1);\n    }\n\n    private void PositionTiles()\n    {\n        float startX = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n        float startZ = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n\n        for (int i = 0; i < _tiles.Count; i++)\n        {\n            int row = i / _gridSize;\n            int col = i % _gridSize;\n            \n            Vector3 position = new Vector3(\n                startX + col * (_tileSize + _tileSpacing),\n                0,\n                startZ + row * (_tileSize + _tileSpacing)\n            );\n\n            _tiles[i].tileObject.transform.localPosition = position;\n            _tiles[i].currentPosition = i;\n            _grid[row, col] = _tiles[i];\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _puzzleCamera.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n\n            if (Physics.Raycast(ray, out hit, Mathf.Infinity, _tileLayerMask))\n            {\n                PuzzleTile clickedTile = GetTileFromGameObject(hit.collider.gameObject);\n                if (clickedTile != null && !clickedTile.isEmpty)\n                {\n                    TryMoveTile(clickedTile);\n                }\n            }\n        }\n    }\n\n    private PuzzleTile GetTileFromGameObject(GameObject obj)\n    {\n        return _tiles.FirstOrDefault(tile => tile.tileObject == obj);\n    }\n\n    private void TryMoveTile(PuzzleTile tile)\n    {\n        Vector2Int tileGridPos = GetGridPosition(tile.currentPosition);\n        Vector2Int emptyGridPos = _emptyPosition;\n\n        // Check if tile is adjacent to empty space\n        int distance = Mathf.Abs(tileGridPos.x - emptyGridPos.x) + Mathf.Abs(tileGridPos.y - emptyGridPos.y);\n        \n        if (distance == 1)\n        {\n            StartCoroutine(SlideTile(tile, tileGridPos, emptyGridPos));\n        }\n        else\n        {\n            PlayInvalidMoveSound();\n            OnInvalidMove?.Invoke();\n        }\n    }\n\n    private System.Collections.IEnumerator SlideTile(PuzzleTile tile, Vector2Int fromPos, Vector2Int toPos)\n    {\n        _isSliding = true;\n        \n        Vector3 startPosition = tile.tileObject.transform.localPosition;\n        Vector3 targetPosition = GetWorldPosition(toPos);\n        \n        float elapsed = 0f;\n        float duration = 1f / _slideSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            tile.tileObject.transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);\n            yield return null;\n        }\n\n        tile.tileObject.transform.localPosition = targetPosition;\n\n        // Update grid\n        _grid[fromPos.y, fromPos.x] = _grid[toPos.y, toPos.x];\n        _grid[toPos.y, toPos.x] = tile;\n        \n        // Update positions\n        tile.currentPosition = toPos.y * _gridSize + toPos.x;\n        _emptyPosition = fromPos;\n\n        _moveCount++;\n        UpdateUI();\n        \n        PlaySlideSound();\n        OnTileSlide?.Invoke();\n        \n        _isSliding = false;\n\n        if (CheckPuzzleComplete())\n        {\n            CompletePuzzle();\n        }\n    }\n\n    private Vector2Int GetGridPosition(int index)\n    {\n        return new Vector2Int(index % _gridSize, index / _gridSize);\n    }\n\n    private Vector3 GetWorldPosition(Vector2Int gridPos)\n    {\n        float startX = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n        float startZ = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n\n        return new Vector3(\n            startX + gridPos.x * (_tileSize + _tileSpacing),\n            0,\n            startZ + gridPos.y * (_tileSize + _tileSpacing)\n        );\n    }\n\n    private bool CheckPuzzleComplete()\n    {\n        for (int i = 0; i < _tiles.Count; i++)\n        {\n            if (_tiles[i].currentPosition != _tiles[i].correctPosition)\n                return false;\n        }\n        return true;\n    }\n\n    private void CompletePuzzle()\n    {\n        _isPuzzleComplete = true;\n        PlayCompleteSound();\n        OnPuzzleComplete?.Invoke();\n        \n        if (_statusText != null)\n            _statusText.text = \"Puzzle Complete!\";\n    }\n\n    public void ShufflePuzzle()\n    {\n        if (_isSliding) return;\n        \n        StartCoroutine(ShuffleCoroutine());\n    }\n\n    private System.Collections.IEnumerator ShuffleCoroutine()\n    {\n        _isShuffling = true;\n        _isPuzzleComplete = false;\n        _moveCount = 0;\n\n        // Perform random valid moves\n        int shuffleMoves = _gridSize * _gridSize * 10;\n        \n        for (int i = 0; i < shuffleMoves; i++)\n        {\n            List<PuzzleTile> validTiles = GetValidMovableTiles();\n            if (validTiles.Count > 0)\n            {\n                PuzzleTile randomTile = validTiles[Random.Range(0, validTiles.Count)];\n                Vector2Int tilePos = GetGridPosition(randomTile.currentPosition);\n                \n                // Instant move without animation\n                _grid[_emptyPosition.y, _emptyPosition.x] = randomTile;\n                _grid[tilePos.y, tilePos.x] = _tiles.Last(); // empty tile\n                \n                randomTile.currentPosition = _emptyPosition.y * _gridSize + _emptyPosition.x;\n                randomTile.tileObject.transform.localPosition = GetWorldPosition(_emptyPosition);\n                \n                _emptyPosition = tilePos;\n            }\n            \n            if (i % 10 == 0)\n                yield return null; // Yield occasionally to prevent freezing\n        }\n\n        UpdateUI();\n        _isShuffling = false;\n    }\n\n    private List<PuzzleTile> GetValidMovableTiles()\n    {\n        List<PuzzleTile> validTiles = new List<PuzzleTile>();\n        \n        Vector2Int[] directions = { Vector2Int.up, Vector2Int.down, Vector2Int.left, Vector2Int.right };\n        \n        foreach (Vector2Int dir in directions)\n        {\n            Vector2Int checkPos = _emptyPosition + dir;\n            \n            if (checkPos.x >= 0 && checkPos.x < _gridSize && checkPos.y >= 0 && checkPos.y < _gridSize)\n            {\n                PuzzleTile tile = _grid[checkPos.y, checkPos.x];\n                if (tile != null && !tile.isEmpty)\n                {\n                    validTiles.Add(tile);\n                }\n            }\n        }\n        \n        return validTiles;\n    }\n\n    public void SolvePuzzle()\n    {\n        if (_isSliding || _isShuffling) return;\n        \n        StartCoroutine(SolveCoroutine());\n    }\n\n    private System.Collections.IEnumerator SolveCoroutine()\n    {\n        _isShuffling = true;\n\n        // Simple solve: move each tile to correct position\n        for (int i = 0; i < _tiles.Count - 1; i++)\n        {\n            PuzzleTile tile = _tiles[i];\n            Vector2Int targetPos = GetGridPosition(tile.correctPosition);\n            Vector2Int currentPos = GetGridPosition(tile.currentPosition);\n            \n            if (currentPos != targetPos)\n            {\n                // Move tile to correct position instantly\n                _grid[currentPos.y, currentPos.x] = _grid[targetPos.y, targetPos.x];\n                _grid[targetPos.y, targetPos.x] = tile;\n                \n                tile.currentPosition = tile.correctPosition;\n                tile.tileObject.transform.localPosition = GetWorldPosition(targetPos);\n                \n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n\n        _emptyPosition = GetGridPosition(_totalTiles - 1);\n        _moveCount = 0;\n        UpdateUI();\n        CompletePuzzle();\n        \n        _isShuffling = false;\n    }\n\n    private void SetupUI()\n    {\n        if (_shuffleButton != null)\n            _shuffleButton.onClick.AddListener(ShufflePuzzle);\n            \n        if (_solveButton != null)\n            _solveButton.onClick.AddListener(SolvePuzzle);\n            \n        UpdateUI();\n    }\n\n    private void UpdateUI()\n    {\n        if (_movesText != null)\n            _movesText.text = $\"Moves: {_moveCount}\";",
      "behavior_type": "general"
    },
    {
      "prompt": "coin that spins and plays sound when collected",
      "ideal_ir": {
        "class_name": "CollectibleCoin",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "collectSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "continuous_spin",
            "trigger": "every frame while coin exists",
            "actions": [
              {
                "action": "rotate coin around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "collect_coin",
            "trigger": "when player touches coin",
            "actions": [
              {
                "action": "play collect sound"
              },
              {
                "action": "destroy coin object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Coin : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 180, 0);\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectSoundVolume = 1f;\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _destroyDelay = 0.1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _collectEffectDuration = 2f;\n    \n    private AudioSource _audioSource;\n    private bool _isCollected = false;\n    private Collider _coinCollider;\n    private Renderer _coinRenderer;\n    \n    private void Start()\n    {\n        SetupAudioSource();\n        CacheComponents();\n    }\n    \n    private void Update()\n    {\n        if (!_isCollected)\n        {\n            RotateCoin();\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _collectSound;\n        _audioSource.volume = _collectSoundVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void CacheComponents()\n    {\n        _coinCollider = GetComponent<Collider>();\n        _coinRenderer = GetComponent<Renderer>();\n        \n        if (_coinCollider == null)\n        {\n            Debug.LogWarning($\"Coin {gameObject.name} is missing a Collider component!\");\n        }\n        else\n        {\n            _coinCollider.isTrigger = true;\n        }\n    }\n    \n    private void RotateCoin()\n    {\n        transform.Rotate(_rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        DisableVisuals();\n        \n        if (_destroyOnCollect)\n        {\n            Destroy(gameObject, _destroyDelay);\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            Destroy(effect, _collectEffectDuration);\n        }\n    }\n    \n    private void DisableVisuals()\n    {\n        if (_coinRenderer != null)\n        {\n            _coinRenderer.enabled = false;\n        }\n        \n        if (_coinCollider != null)\n        {\n            _coinCollider.enabled = false;\n        }\n    }\n    \n    public void ResetCoin()\n    {\n        _isCollected = false;\n        \n        if (_coinRenderer != null)\n        {\n            _coinRenderer.enabled = true;\n        }\n        \n        if (_coinCollider != null)\n        {\n            _coinCollider.enabled = true;\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "treasure chest that opens with key",
      "ideal_ir": {
        "class_name": "TreasureChest",
        "components": [
          "Collider",
          "AudioSource",
          "Animator"
        ],
        "fields": [
          {
            "name": "isLocked",
            "type": "bool",
            "default": true
          },
          {
            "name": "isOpen",
            "type": "bool",
            "default": false
          },
          {
            "name": "requiredKeyType",
            "type": "string",
            "default": "golden_key"
          },
          {
            "name": "treasureContents",
            "type": "GameObject[]",
            "default": null
          },
          {
            "name": "openSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "lockedSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "attempt_open",
            "trigger": "when player interacts with chest",
            "actions": [
              {
                "action": "check if player has required key in inventory"
              },
              {
                "action": "if player has key then unlock and open chest"
              },
              {
                "action": "if player lacks key then play locked sound and show locked message"
              }
            ]
          },
          {
            "name": "open_chest",
            "trigger": "when chest becomes unlocked",
            "actions": [
              {
                "action": "play opening animation"
              },
              {
                "action": "play chest opening sound"
              },
              {
                "action": "spawn treasure contents inside chest"
              },
              {
                "action": "remove required key from player inventory"
              },
              {
                "action": "set chest state to open"
              }
            ]
          },
          {
            "name": "show_interaction_prompt",
            "trigger": "when player is near chest and looking at it",
            "actions": [
              {
                "action": "display interaction prompt based on chest state"
              },
              {
                "action": "show key requirement if chest is locked"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest Settings\")]\n    [SerializeField] private string requiredKeyTag = \"Key\";\n    [SerializeField] private float interactionRange = 2f;\n    [SerializeField] private KeyCode interactionKey = KeyCode.E;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator chestAnimator;\n    [SerializeField] private string openAnimationTrigger = \"Open\";\n    [SerializeField] private AudioClip openSound;\n    [SerializeField] private AudioClip lockedSound;\n    \n    [Header(\"Treasure Contents\")]\n    [SerializeField] private GameObject[] treasureItems;\n    [SerializeField] private Transform spawnPoint;\n    [SerializeField] private float spawnForce = 5f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject interactionPrompt;\n    [SerializeField] private GameObject lockedPrompt;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnChestOpened;\n    public UnityEvent OnChestLocked;\n    \n    private bool _isOpened = false;\n    private bool _playerInRange = false;\n    private GameObject _playerObject;\n    private AudioSource _audioSource;\n    private PlayerInventory _playerInventory;\n    \n    [System.Serializable]\n    private class PlayerInventory\n    {\n        private bool _hasKey = false;\n        \n        public bool HasKey => _hasKey;\n        \n        public void AddKey()\n        {\n            _hasKey = true;\n        }\n        \n        public bool UseKey()\n        {\n            if (_hasKey)\n            {\n                _hasKey = false;\n                return true;\n            }\n            return false;\n        }\n    }\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (interactionPrompt != null)\n            interactionPrompt.SetActive(false);\n            \n        if (lockedPrompt != null)\n            lockedPrompt.SetActive(false);\n            \n        if (spawnPoint == null)\n            spawnPoint = transform;\n    }\n    \n    private void Update()\n    {\n        if (_playerInRange && !_isOpened && Input.GetKeyDown(interactionKey))\n        {\n            TryOpenChest();\n        }\n        \n        UpdateUI();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = true;\n            _playerObject = other.gameObject;\n            \n            _playerInventory = other.GetComponent<PlayerInventory>();\n            if (_playerInventory == null)\n            {\n                _playerInventory = other.gameObject.AddComponent<PlayerInventory>();\n            }\n        }\n        else if (other.CompareTag(requiredKeyTag))\n        {\n            CollectKey(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = false;\n            _playerObject = null;\n            _playerInventory = null;\n            \n            if (interactionPrompt != null)\n                interactionPrompt.SetActive(false);\n                \n            if (lockedPrompt != null)\n                lockedPrompt.SetActive(false);\n        }\n    }\n    \n    private void CollectKey(GameObject keyObject)\n    {\n        if (_playerInventory != null)\n        {\n            _playerInventory.AddKey();\n            Destroy(keyObject);\n        }\n    }\n    \n    private void TryOpenChest()\n    {\n        if (_playerInventory != null && _playerInventory.HasKey)\n        {\n            if (_playerInventory.UseKey())\n            {\n                OpenChest();\n            }\n        }\n        else\n        {\n            PlayLockedSound();\n            OnChestLocked?.Invoke();\n        }\n    }\n    \n    private void OpenChest()\n    {\n        _isOpened = true;\n        \n        if (chestAnimator != null)\n            chestAnimator.SetTrigger(openAnimationTrigger);\n            \n        PlayOpenSound();\n        SpawnTreasure();\n        OnChestOpened?.Invoke();\n    }\n    \n    private void SpawnTreasure()\n    {\n        if (treasureItems == null || treasureItems.Length == 0)\n            return;\n            \n        foreach (GameObject treasureItem in treasureItems)\n        {\n            if (treasureItem != null)\n            {\n                Vector3 spawnPosition = spawnPoint.position + Random.insideUnitSphere * 0.5f;\n                GameObject spawnedItem = Instantiate(treasureItem, spawnPosition, Random.rotation);\n                \n                Rigidbody rb = spawnedItem.GetComponent<Rigidbody>();\n                if (rb == null)\n                    rb = spawnedItem.AddComponent<Rigidbody>();\n                    \n                Vector3 randomDirection = Random.insideUnitSphere;\n                randomDirection.y = Mathf.Abs(randomDirection.y);\n                rb.AddForce(randomDirection * spawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (!_playerInRange || _isOpened)\n        {\n            if (interactionPrompt != null)\n                interactionPrompt.SetActive(false);\n            if (lockedPrompt != null)\n                lockedPrompt.SetActive(false);\n            return;\n        }\n        \n        bool hasKey = _playerInventory != null && _playerInventory.HasKey;\n        \n        if (interactionPrompt != null)\n            interactionPrompt.SetActive(hasKey);\n            \n        if (lockedPrompt != null)\n            lockedPrompt.SetActive(!hasKey);\n    }\n    \n    private void PlayOpenSound()\n    {\n        if (openSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(openSound);\n        }\n    }\n    \n    private void PlayLockedSound()\n    {\n        if (lockedSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(lockedSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, interactionRange);\n        \n        if (spawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(spawnPoint.position, Vector3.one * 0.2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "potion bottle with swirling particles",
      "ideal_ir": {
        "class_name": "PotionBottle",
        "components": [
          "ParticleSystem",
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "swirl_speed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "particle_count",
            "type": "int",
            "default": 50
          },
          {
            "name": "glow_intensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "bubble_sound_volume",
            "type": "float",
            "default": 0.3
          }
        ],
        "behaviors": [
          {
            "name": "continuous_swirl",
            "trigger": "always active",
            "actions": [
              {
                "action": "emit particles in circular swirling motion"
              },
              {
                "action": "rotate particles around bottle center at swirl speed"
              },
              {
                "action": "vary particle colors between magical hues"
              }
            ]
          },
          {
            "name": "glow_pulse",
            "trigger": "always active",
            "actions": [
              {
                "action": "pulse glow intensity up and down smoothly"
              },
              {
                "action": "illuminate surrounding area with magical light"
              }
            ]
          },
          {
            "name": "bubble_effects",
            "trigger": "randomly every few seconds",
            "actions": [
              {
                "action": "spawn larger bubble particles that rise upward"
              },
              {
                "action": "play soft bubbling sound effect"
              }
            ]
          },
          {
            "name": "interaction_response",
            "trigger": "when player approaches closely",
            "actions": [
              {
                "action": "increase particle emission rate"
              },
              {
                "action": "brighten glow intensity"
              },
              {
                "action": "speed up swirling motion"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class PotionBottle : MonoBehaviour\n{\n    [Header(\"Potion Settings\")]\n    [SerializeField] private Color _potionColor = Color.red;\n    [SerializeField] private float _swirlingSpeed = 2f;\n    [SerializeField] private float _swirlingRadius = 0.5f;\n    [SerializeField] private int _particleCount = 20;\n    \n    [Header(\"Bottle Components\")]\n    [SerializeField] private Transform _liquidTransform;\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private Light _potionLight;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private float _glowIntensity = 1f;\n    [SerializeField] private float _bobHeight = 0.1f;\n    [SerializeField] private float _bobSpeed = 1f;\n    [SerializeField] private AudioClip _bubbleSound;\n    [SerializeField] private bool _playAmbientSound = true;\n    \n    private Vector3 _initialPosition;\n    private float _timeOffset;\n    private ParticleSystem.Particle[] _particles;\n    private float[] _particleAngles;\n    private float[] _particleHeights;\n    private Renderer _liquidRenderer;\n    \n    private void Start()\n    {\n        _initialPosition = transform.position;\n        _timeOffset = Random.Range(0f, 2f * Mathf.PI);\n        \n        InitializeParticleSystem();\n        InitializeLiquid();\n        InitializeLight();\n        InitializeAudio();\n    }\n    \n    private void InitializeParticleSystem()\n    {\n        if (_particleSystem == null)\n        {\n            GameObject particleObj = new GameObject(\"PotionParticles\");\n            particleObj.transform.SetParent(transform);\n            particleObj.transform.localPosition = Vector3.zero;\n            _particleSystem = particleObj.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _particleSystem.main;\n        main.startLifetime = float.MaxValue;\n        main.startSpeed = 0f;\n        main.startSize = 0.05f;\n        main.startColor = _potionColor;\n        main.maxParticles = _particleCount;\n        main.simulationSpace = ParticleSystemSimulationSpace.Local;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = false;\n        \n        _particles = new ParticleSystem.Particle[_particleCount];\n        _particleAngles = new float[_particleCount];\n        _particleHeights = new float[_particleCount];\n        \n        for (int i = 0; i < _particleCount; i++)\n        {\n            _particleAngles[i] = (float)i / _particleCount * 2f * Mathf.PI;\n            _particleHeights[i] = Random.Range(-0.8f, 0.8f);\n            \n            _particles[i].position = CalculateParticlePosition(i, 0f);\n            _particles[i].startColor = Color.Lerp(_potionColor, Color.white, Random.Range(0f, 0.3f));\n            _particles[i].startSize = Random.Range(0.03f, 0.08f);\n        }\n        \n        _particleSystem.SetParticles(_particles, _particleCount);\n    }\n    \n    private void InitializeLiquid()\n    {\n        if (_liquidTransform != null)\n        {\n            _liquidRenderer = _liquidTransform.GetComponent<Renderer>();\n            if (_liquidRenderer != null)\n            {\n                _liquidRenderer.material.color = _potionColor;\n                if (_liquidRenderer.material.HasProperty(\"_EmissionColor\"))\n                {\n                    _liquidRenderer.material.SetColor(\"_EmissionColor\", _potionColor * _glowIntensity);\n                }\n            }\n        }\n    }\n    \n    private void InitializeLight()\n    {\n        if (_potionLight == null)\n        {\n            GameObject lightObj = new GameObject(\"PotionLight\");\n            lightObj.transform.SetParent(transform);\n            lightObj.transform.localPosition = Vector3.zero;\n            _potionLight = lightObj.AddComponent<Light>();\n        }\n        \n        _potionLight.type = LightType.Point;\n        _potionLight.color = _potionColor;\n        _potionLight.intensity = _glowIntensity;\n        _potionLight.range = 3f;\n    }\n    \n    private void InitializeAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.clip = _bubbleSound;\n        _audioSource.loop = true;\n        _audioSource.volume = 0.3f;\n        _audioSource.pitch = Random.Range(0.8f, 1.2f);\n        \n        if (_playAmbientSound && _bubbleSound != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateBottlePosition();\n        UpdateParticles();\n        UpdateLightEffect();\n    }\n    \n    private void UpdateBottlePosition()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed + _timeOffset) * _bobHeight;\n        transform.position = _initialPosition + Vector3.up * bobOffset;\n    }\n    \n    private void UpdateParticles()\n    {\n        if (_particleSystem == null || _particles == null) return;\n        \n        float time = Time.time * _swirlingSpeed;\n        \n        for (int i = 0; i < _particleCount; i++)\n        {\n            _particles[i].position = CalculateParticlePosition(i, time);\n            \n            // Add some random movement\n            Vector3 randomOffset = new Vector3(\n                Mathf.Sin(time * 2f + i) * 0.02f,\n                Mathf.Cos(time * 1.5f + i) * 0.01f,\n                Mathf.Sin(time * 1.8f + i) * 0.02f\n            );\n            \n            _particles[i].position += randomOffset;\n        }\n        \n        _particleSystem.SetParticles(_particles, _particleCount);\n    }\n    \n    private Vector3 CalculateParticlePosition(int index, float time)\n    {\n        float angle = _particleAngles[index] + time;\n        float radius = _swirlingRadius * (0.5f + 0.5f * Mathf.Sin(time * 0.5f + index));\n        \n        float x = Mathf.Cos(angle) * radius;\n        float z = Mathf.Sin(angle) * radius;\n        float y = _particleHeights[index] + Mathf.Sin(time + index) * 0.1f;\n        \n        return new Vector3(x, y, z);\n    }\n    \n    private void UpdateLightEffect()\n    {\n        if (_potionLight != null)\n        {\n            float flicker = 1f + Mathf.Sin(Time.time * 3f + _timeOffset) * 0.1f;\n            _potionLight.intensity = _glowIntensity * flicker;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCoroutine(ConsumePotion());\n        }\n    }\n    \n    private IEnumerator ConsumePotion()\n    {\n        // Increase swirling speed\n        float originalSpeed = _swirlingSpeed;\n        _swirlingSpeed *= 3f;\n        \n        // Play consumption sound\n        if (_audioSource != null && _bubbleSound != null)\n        {\n            _audioSource.pitch = 1.5f;\n            _audioSource.volume = 0.6f;\n        }\n        \n        // Shrink effect\n        Vector3 originalScale = transform.localScale;\n        float shrinkTime = 1f;\n        float elapsed = 0f;\n        \n        while (elapsed < shrinkTime)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / shrinkTime;\n            \n            transform.localScale = Vector3.Lerp(originalScale, Vector3.zero, progress);\n            \n            if (_potionLight != null)\n            {\n                _potionLight.intensity = Mathf.Lerp(_glowIntensity, 0f, progress);\n            }\n            \n            yield return null;\n        }\n        \n        gameObject.SetActive(false);\n    }\n    \n    public void SetPotionColor(Color newColor)\n    {\n        _potionColor = newColor;\n        \n        if (_liquidRenderer != null)\n        {\n            _liquidRenderer.material.color = _potionColor;\n            if (_liquidRenderer.material.HasProperty(\"_EmissionColor\"))\n            {\n                _liquidRenderer.material.SetColor(\"_EmissionColor\", _potionColor * _glowIntensity);\n            }\n        }\n        \n        if (_potionLight != null)\n        {\n            _potionLight.color = _potionColor;\n        }\n        \n        if (_particles != null)\n        {\n            for (int i = 0; i < _particles.Length; i++)\n            {\n                _particles[i].startColor = Color.Lerp(_potionColor, Color.white, Random.Range(0f, 0.3f));\n            }\n            _particleSystem.SetParticles(_particles, _particleCount);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            SetPotionColor(_potionColor);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "magnet that attracts nearby coins",
      "ideal_ir": {
        "class_name": "CoinMagnet",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "attractionRange",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "attractionForce",
            "type": "float",
            "default": 10.0
          }
        ],
        "behaviors": [
          {
            "name": "attract_coins",
            "trigger": "when coin is within attraction range",
            "actions": [
              {
                "action": "pull coin toward magnet with attraction force"
              },
              {
                "action": "increase coin movement speed as it gets closer"
              }
            ]
          },
          {
            "name": "collect_coin",
            "trigger": "when coin touches magnet",
            "actions": [
              {
                "action": "destroy the coin"
              },
              {
                "action": "play collection sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class CoinMagnet : MonoBehaviour\n{\n    [Header(\"Magnet Settings\")]\n    [SerializeField] private float _attractionRadius = 5f;\n    [SerializeField] private float _attractionForce = 10f;\n    [SerializeField] private float _maxAttractionSpeed = 15f;\n    [SerializeField] private LayerMask _coinLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _magnetEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attractionSound;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showGizmos = true;\n    \n    private List<Rigidbody> _attractedCoins = new List<Rigidbody>();\n    private SphereCollider _detectionCollider;\n    \n    void Start()\n    {\n        SetupDetectionCollider();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    void SetupDetectionCollider()\n    {\n        _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _attractionRadius;\n    }\n    \n    void FixedUpdate()\n    {\n        AttractCoins();\n        CleanupNullReferences();\n    }\n    \n    void AttractCoins()\n    {\n        for (int i = _attractedCoins.Count - 1; i >= 0; i--)\n        {\n            if (_attractedCoins[i] == null)\n            {\n                _attractedCoins.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody coinRb = _attractedCoins[i];\n            Vector3 direction = (transform.position - coinRb.transform.position).normalized;\n            float distance = Vector3.Distance(transform.position, coinRb.transform.position);\n            \n            if (distance > _attractionRadius)\n            {\n                _attractedCoins.RemoveAt(i);\n                continue;\n            }\n            \n            float forceMagnitude = _attractionForce / Mathf.Max(distance, 0.1f);\n            Vector3 force = direction * forceMagnitude;\n            \n            coinRb.AddForce(force, ForceMode.Force);\n            \n            if (coinRb.velocity.magnitude > _maxAttractionSpeed)\n            {\n                coinRb.velocity = coinRb.velocity.normalized * _maxAttractionSpeed;\n            }\n        }\n    }\n    \n    void CleanupNullReferences()\n    {\n        _attractedCoins.RemoveAll(coin => coin == null);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (IsValidCoin(other))\n        {\n            Rigidbody coinRb = other.GetComponent<Rigidbody>();\n            if (coinRb != null && !_attractedCoins.Contains(coinRb))\n            {\n                _attractedCoins.Add(coinRb);\n                PlayAttractionEffect();\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (IsValidCoin(other))\n        {\n            Rigidbody coinRb = other.GetComponent<Rigidbody>();\n            if (coinRb != null)\n            {\n                _attractedCoins.Remove(coinRb);\n            }\n        }\n    }\n    \n    bool IsValidCoin(Collider other)\n    {\n        return other.CompareTag(\"Coin\") && \n               (_coinLayerMask.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    void PlayAttractionEffect()\n    {\n        if (_magnetEffect != null && !_magnetEffect.isPlaying)\n        {\n            _magnetEffect.Play();\n        }\n        \n        if (_audioSource != null && _attractionSound != null)\n        {\n            _audioSource.PlayOneShot(_attractionSound);\n        }\n    }\n    \n    public void SetAttractionRadius(float radius)\n    {\n        _attractionRadius = Mathf.Max(0f, radius);\n        if (_detectionCollider != null)\n        {\n            _detectionCollider.radius = _attractionRadius;\n        }\n    }\n    \n    public void SetAttractionForce(float force)\n    {\n        _attractionForce = Mathf.Max(0f, force);\n    }\n    \n    public int GetAttractedCoinCount()\n    {\n        return _attractedCoins.Count;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_showGizmos)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _attractionRadius);\n            \n            Gizmos.color = Color.red;\n            foreach (var coin in _attractedCoins)\n            {\n                if (coin != null)\n                {\n                    Gizmos.DrawLine(transform.position, coin.transform.position);\n                }\n            }\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "star collectible that bounces",
      "ideal_ir": {
        "class_name": "BouncingStar",
        "components": [
          "Rigidbody",
          "Collider",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "bounceForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "bounceInterval",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "collectPoints",
            "type": "int",
            "default": 100
          }
        ],
        "behaviors": [
          {
            "name": "continuous_bounce",
            "trigger": "every bounce interval seconds",
            "actions": [
              {
                "action": "apply upward bounce force"
              }
            ]
          },
          {
            "name": "collect_star",
            "trigger": "when player touches this star",
            "actions": [
              {
                "action": "add collect points to player score"
              },
              {
                "action": "play collection sound effect"
              },
              {
                "action": "destroy this star object"
              }
            ]
          },
          {
            "name": "sparkle_effect",
            "trigger": "continuously while star exists",
            "actions": [
              {
                "action": "rotate slowly around vertical axis"
              },
              {
                "action": "emit sparkle particles"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class StarCollectible : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _bounceHeight = 2f;\n    [SerializeField] private float _bounceSpeed = 2f;\n    [SerializeField] private AnimationCurve _bounceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.up;\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _destroyDelay = 0f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectAnimationDuration = 0.5f;\n    [SerializeField] private AnimationCurve _collectScaleCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStarCollected;\n    \n    private Vector3 _startPosition;\n    private float _bounceTimer;\n    private bool _isCollected;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _bounceTimer = 0f;\n        _isCollected = false;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        UpdateBounce();\n        UpdateRotation();\n    }\n    \n    private void UpdateBounce()\n    {\n        _bounceTimer += Time.deltaTime * _bounceSpeed;\n        float normalizedTime = (_bounceTimer % (2f * Mathf.PI)) / (2f * Mathf.PI);\n        float bounceOffset = _bounceCurve.Evaluate(normalizedTime) * _bounceHeight;\n        \n        Vector3 newPosition = _startPosition;\n        newPosition.y += Mathf.Sin(_bounceTimer) * bounceOffset;\n        transform.position = newPosition;\n    }\n    \n    private void UpdateRotation()\n    {\n        transform.Rotate(_rotationAxis * _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(_playerTag))\n        {\n            CollectStar();\n        }\n    }\n    \n    private void CollectStar()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        OnStarCollected?.Invoke();\n        \n        if (_destroyOnCollect)\n        {\n            StartCoroutine(CollectAnimation());\n        }\n        else\n        {\n            DisableStar();\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_audioSource != null && _collectSound != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            \n            ParticleSystem particles = effect.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                Destroy(effect, particles.main.duration + particles.main.startLifetime.constantMax);\n            }\n            else\n            {\n                Destroy(effect, 2f);\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator CollectAnimation()\n    {\n        Vector3 originalScale = transform.localScale;\n        float timer = 0f;\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        while (timer < _collectAnimationDuration)\n        {\n            timer += Time.deltaTime;\n            float normalizedTime = timer / _collectAnimationDuration;\n            float scaleMultiplier = _collectScaleCurve.Evaluate(normalizedTime);\n            \n            transform.localScale = originalScale * scaleMultiplier;\n            \n            yield return null;\n        }\n        \n        if (_destroyDelay > 0f)\n        {\n            yield return new WaitForSeconds(_destroyDelay);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void DisableStar()\n    {\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    public void ResetStar()\n    {\n        _isCollected = false;\n        _bounceTimer = 0f;\n        transform.position = _startPosition;\n        transform.localScale = Vector3.one;\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_bounceHeight < 0f)\n            _bounceHeight = 0f;\n            \n        if (_bounceSpeed < 0f)\n            _bounceSpeed = 0f;\n            \n        if (_collectAnimationDuration < 0f)\n            _collectAnimationDuration = 0f;\n            \n        if (_destroyDelay < 0f)\n            _destroyDelay = 0f;\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "crystal that glows when near player",
      "ideal_ir": {
        "class_name": "GlowingCrystal",
        "components": [
          "Light",
          "Renderer"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "maxGlowIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "glowSpeed",
            "type": "float",
            "default": 3.0
          }
        ],
        "behaviors": [
          {
            "name": "glow_when_player_near",
            "trigger": "when player is within detection range",
            "actions": [
              {
                "action": "increase light intensity based on proximity to player"
              },
              {
                "action": "make crystal material more emissive based on proximity"
              }
            ]
          },
          {
            "name": "dim_when_player_far",
            "trigger": "when player moves outside detection range",
            "actions": [
              {
                "action": "gradually decrease light intensity to zero"
              },
              {
                "action": "reduce crystal material emission to normal state"
              }
            ]
          },
          {
            "name": "pulse_glow_effect",
            "trigger": "when crystal is actively glowing",
            "actions": [
              {
                "action": "create subtle pulsing effect with light intensity"
              },
              {
                "action": "add gentle color shifting to the glow"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class GlowingCrystal : MonoBehaviour\n{\n    [Header(\"Glow Settings\")]\n    [SerializeField] private float _glowDistance = 5f;\n    [SerializeField] private float _maxGlowIntensity = 2f;\n    [SerializeField] private float _minGlowIntensity = 0.1f;\n    [SerializeField] private Color _glowColor = Color.cyan;\n    [SerializeField] private float _glowSpeed = 2f;\n    \n    [Header(\"Pulse Settings\")]\n    [SerializeField] private bool _enablePulse = true;\n    [SerializeField] private float _pulseSpeed = 1f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _glowSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private Light _crystalLight;\n    private Renderer _crystalRenderer;\n    private Material _crystalMaterial;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private bool _isGlowing = false;\n    private float _baseIntensity;\n    private Color _originalEmissionColor;\n    private float _currentGlowIntensity;\n    \n    void Start()\n    {\n        SetupComponents();\n        FindPlayer();\n        InitializeMaterial();\n    }\n    \n    void Update()\n    {\n        if (_player != null)\n        {\n            UpdateGlow();\n        }\n        else\n        {\n            FindPlayer();\n        }\n    }\n    \n    void SetupComponents()\n    {\n        _crystalLight = GetComponent<Light>();\n        if (_crystalLight == null)\n        {\n            _crystalLight = gameObject.AddComponent<Light>();\n            _crystalLight.type = LightType.Point;\n            _crystalLight.color = _glowColor;\n            _crystalLight.intensity = _minGlowIntensity;\n            _crystalLight.range = _glowDistance * 1.5f;\n        }\n        \n        _baseIntensity = _crystalLight.intensity;\n        _currentGlowIntensity = _minGlowIntensity;\n        \n        _crystalRenderer = GetComponent<Renderer>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.clip = _glowSound;\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.loop = true;\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void InitializeMaterial()\n    {\n        if (_crystalRenderer != null)\n        {\n            _crystalMaterial = _crystalRenderer.material;\n            if (_crystalMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _originalEmissionColor = _crystalMaterial.GetColor(\"_EmissionColor\");\n            }\n        }\n    }\n    \n    void UpdateGlow()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        float normalizedDistance = Mathf.Clamp01(distanceToPlayer / _glowDistance);\n        float glowFactor = 1f - normalizedDistance;\n        \n        bool shouldGlow = distanceToPlayer <= _glowDistance;\n        \n        if (shouldGlow && !_isGlowing)\n        {\n            StartGlowing();\n        }\n        else if (!shouldGlow && _isGlowing)\n        {\n            StopGlowing();\n        }\n        \n        if (shouldGlow)\n        {\n            UpdateGlowIntensity(glowFactor);\n        }\n    }\n    \n    void StartGlowing()\n    {\n        _isGlowing = true;\n        \n        if (_glowSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    void StopGlowing()\n    {\n        _isGlowing = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        _currentGlowIntensity = Mathf.Lerp(_currentGlowIntensity, _minGlowIntensity, Time.deltaTime * _glowSpeed);\n        UpdateLightAndMaterial();\n    }\n    \n    void UpdateGlowIntensity(float glowFactor)\n    {\n        float targetIntensity = Mathf.Lerp(_minGlowIntensity, _maxGlowIntensity, glowFactor);\n        \n        if (_enablePulse)\n        {\n            float pulseOffset = Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n            targetIntensity += pulseOffset * glowFactor;\n        }\n        \n        _currentGlowIntensity = Mathf.Lerp(_currentGlowIntensity, targetIntensity, Time.deltaTime * _glowSpeed);\n        UpdateLightAndMaterial();\n    }\n    \n    void UpdateLightAndMaterial()\n    {\n        if (_crystalLight != null)\n        {\n            _crystalLight.intensity = _currentGlowIntensity;\n            _crystalLight.color = _glowColor;\n        }\n        \n        if (_crystalMaterial != null && _crystalMaterial.HasProperty(\"_EmissionColor\"))\n        {\n            Color emissionColor = _glowColor * _currentGlowIntensity;\n            _crystalMaterial.SetColor(\"_EmissionColor\", emissionColor);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _glowColor;\n        Gizmos.DrawWireSphere(transform.position, _glowDistance);\n    }\n    \n    void OnDestroy()\n    {\n        if (_crystalMaterial != null)\n        {\n            if (_crystalMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _crystalMaterial.SetColor(\"_EmissionColor\", _originalEmissionColor);\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "food item that restores stamina",
      "ideal_ir": {
        "class_name": "FoodItem",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "staminaRestoreAmount",
            "type": "float",
            "default": 25
          },
          {
            "name": "isConsumed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "restore_stamina_on_pickup",
            "trigger": "when player touches this food item",
            "actions": [
              {
                "action": "increase player stamina by stamina restore amount"
              },
              {
                "action": "mark this food item as consumed"
              },
              {
                "action": "destroy this food item"
              }
            ]
          },
          {
            "name": "prevent_multiple_consumption",
            "trigger": "when player tries to interact with already consumed food",
            "actions": [
              {
                "action": "do nothing"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FoodItem : MonoBehaviour\n{\n    [Header(\"Food Properties\")]\n    [SerializeField] private float _staminaRestoreAmount = 25f;\n    [SerializeField] private bool _destroyOnUse = true;\n    [SerializeField] private float _interactionRange = 2f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _consumeEffect;\n    [SerializeField] private AudioClip _consumeSound;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnStaminaRestore;\n    public UnityEvent OnFoodConsumed;\n    \n    private Renderer _renderer;\n    private Color _originalColor;\n    private AudioSource _audioSource;\n    private bool _isPlayerInRange = false;\n    private GameObject _currentPlayer;\n    private Camera _mainCamera;\n    \n    [System.Serializable]\n    public class PlayerStamina\n    {\n        public float currentStamina = 100f;\n        public float maxStamina = 100f;\n        \n        public void RestoreStamina(float amount)\n        {\n            currentStamina = Mathf.Min(currentStamina + amount, maxStamina);\n        }\n        \n        public float GetStaminaPercentage()\n        {\n            return currentStamina / maxStamina;\n        }\n    }\n    \n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _mainCamera = Camera.main;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        SetupCollider();\n    }\n    \n    private void SetupCollider()\n    {\n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            SphereCollider sphereCol = gameObject.AddComponent<SphereCollider>();\n            sphereCol.isTrigger = true;\n            sphereCol.radius = _interactionRange;\n        }\n        else\n        {\n            col.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPlayerInRange && _currentPlayer != null)\n        {\n            if (Input.GetKeyDown(_interactionKey))\n            {\n                ConsumeFoodItem();\n            }\n            \n            UpdateInteractionPromptPosition();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInRange = true;\n            _currentPlayer = other.gameObject;\n            ShowInteractionPrompt();\n            HighlightItem(true);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInRange = false;\n            _currentPlayer = null;\n            HideInteractionPrompt();\n            HighlightItem(false);\n        }\n    }\n    \n    private void ConsumeFoodItem()\n    {\n        if (_currentPlayer == null) return;\n        \n        PlayerStamina playerStamina = _currentPlayer.GetComponent<PlayerStamina>();\n        if (playerStamina == null)\n        {\n            playerStamina = _currentPlayer.AddComponent<PlayerStamina>();\n        }\n        \n        float previousStamina = playerStamina.currentStamina;\n        playerStamina.RestoreStamina(_staminaRestoreAmount);\n        float actualRestored = playerStamina.currentStamina - previousStamina;\n        \n        OnStaminaRestore?.Invoke(actualRestored);\n        OnFoodConsumed?.Invoke();\n        \n        PlayConsumeEffects();\n        \n        Debug.Log($\"Restored {actualRestored} stamina. Current: {playerStamina.currentStamina}/{playerStamina.maxStamina}\");\n        \n        if (_destroyOnUse)\n        {\n            HideInteractionPrompt();\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void PlayConsumeEffects()\n    {\n        if (_consumeEffect != null)\n        {\n            GameObject effect = Instantiate(_consumeEffect, transform.position, transform.rotation);\n            Destroy(effect, 3f);\n        }\n        \n        if (_consumeSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_consumeSound);\n        }\n    }\n    \n    private void HighlightItem(bool highlight)\n    {\n        if (_renderer == null) return;\n        \n        if (highlight)\n        {\n            _renderer.material.color = _highlightColor;\n        }\n        else\n        {\n            _renderer.material.color = _originalColor;\n        }\n    }\n    \n    private void ShowInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(true);\n        }\n    }\n    \n    private void HideInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void UpdateInteractionPromptPosition()\n    {\n        if (_interactionPrompt == null || _mainCamera == null) return;\n        \n        Vector3 screenPos = _mainCamera.WorldToScreenPoint(transform.position + Vector3.up * 2f);\n        _interactionPrompt.transform.position = screenPos;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n    \n    public void SetStaminaRestoreAmount(float amount)\n    {\n        _staminaRestoreAmount = Mathf.Max(0f, amount);\n    }\n    \n    public float GetStaminaRestoreAmount()\n    {\n        return _staminaRestoreAmount;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "armor piece that increases defense",
      "ideal_ir": {
        "class_name": "ArmorPiece",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "defenseBonus",
            "type": "int",
            "default": 5
          },
          {
            "name": "armorType",
            "type": "string",
            "default": "Light"
          },
          {
            "name": "durability",
            "type": "int",
            "default": 100
          },
          {
            "name": "isEquipped",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "equip_armor",
            "trigger": "when player interacts with this armor piece",
            "actions": [
              {
                "action": "add defense bonus to player stats"
              },
              {
                "action": "mark armor as equipped"
              },
              {
                "action": "attach armor to player character model"
              },
              {
                "action": "play equip sound effect"
              }
            ]
          },
          {
            "name": "unequip_armor",
            "trigger": "when player chooses to remove this armor",
            "actions": [
              {
                "action": "remove defense bonus from player stats"
              },
              {
                "action": "mark armor as not equipped"
              },
              {
                "action": "detach armor from player character model"
              },
              {
                "action": "return armor to inventory"
              }
            ]
          },
          {
            "name": "durability_loss",
            "trigger": "when player takes damage while wearing this armor",
            "actions": [
              {
                "action": "reduce armor durability by small amount"
              },
              {
                "action": "check if durability reaches zero"
              }
            ]
          },
          {
            "name": "armor_breaks",
            "trigger": "when armor durability reaches zero",
            "actions": [
              {
                "action": "remove all defense bonuses"
              },
              {
                "action": "display broken armor visual effect"
              },
              {
                "action": "mark armor as broken and unusable"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ArmorPiece : MonoBehaviour\n{\n    [Header(\"Armor Properties\")]\n    [SerializeField] private string _armorName = \"Basic Armor\";\n    [SerializeField] private int _defenseBonus = 10;\n    [SerializeField] private ArmorType _armorType = ArmorType.Chest;\n    [SerializeField] private bool _isEquipped = false;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private GameObject _visualModel;\n    [SerializeField] private Material _equippedMaterial;\n    [SerializeField] private Material _unequippedMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _equipSound;\n    [SerializeField] private AudioClip _unequipSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnDefenseChanged;\n    public UnityEvent<string> OnArmorEquipped;\n    public UnityEvent<string> OnArmorUnequipped;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    private GameObject _currentWearer;\n    \n    public enum ArmorType\n    {\n        Helmet,\n        Chest,\n        Legs,\n        Boots,\n        Gloves,\n        Shield\n    }\n    \n    public int DefenseBonus => _defenseBonus;\n    public ArmorType Type => _armorType;\n    public bool IsEquipped => _isEquipped;\n    public string ArmorName => _armorName;\n    public GameObject CurrentWearer => _currentWearer;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider>();\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Start()\n    {\n        UpdateVisualState();\n        \n        if (!_isEquipped && _collider != null)\n            _collider.enabled = true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isEquipped && other.CompareTag(\"Player\"))\n        {\n            TryEquipArmor(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_isEquipped && other.CompareTag(\"Player\") && other.gameObject == _currentWearer)\n        {\n            // Optional: Auto-unequip when player moves away\n            // UnequipArmor();\n        }\n    }\n    \n    public bool TryEquipArmor(GameObject wearer)\n    {\n        if (_isEquipped || wearer == null)\n            return false;\n            \n        // Check if wearer already has this armor type equipped\n        ArmorPiece[] existingArmor = wearer.GetComponentsInChildren<ArmorPiece>();\n        foreach (ArmorPiece armor in existingArmor)\n        {\n            if (armor != this && armor.IsEquipped && armor.Type == _armorType)\n            {\n                armor.UnequipArmor();\n                break;\n            }\n        }\n        \n        EquipArmor(wearer);\n        return true;\n    }\n    \n    public void EquipArmor(GameObject wearer)\n    {\n        if (_isEquipped || wearer == null)\n            return;\n            \n        _isEquipped = true;\n        _currentWearer = wearer;\n        \n        // Attach to wearer\n        transform.SetParent(wearer.transform);\n        transform.localPosition = GetArmorPosition();\n        transform.localRotation = Quaternion.identity;\n        \n        // Disable collider when equipped\n        if (_collider != null)\n            _collider.enabled = false;\n            \n        // Apply defense bonus\n        ApplyDefenseBonus(wearer, _defenseBonus);\n        \n        // Update visuals and audio\n        UpdateVisualState();\n        PlayEquipSound();\n        \n        // Trigger events\n        OnDefenseChanged?.Invoke(_defenseBonus);\n        OnArmorEquipped?.Invoke(_armorName);\n        \n        Debug.Log($\"{_armorName} equipped! Defense bonus: +{_defenseBonus}\");\n    }\n    \n    public void UnequipArmor()\n    {\n        if (!_isEquipped)\n            return;\n            \n        GameObject previousWearer = _currentWearer;\n        \n        // Remove defense bonus\n        if (previousWearer != null)\n            ApplyDefenseBonus(previousWearer, -_defenseBonus);\n            \n        _isEquipped = false;\n        _currentWearer = null;\n        \n        // Detach from wearer\n        transform.SetParent(null);\n        \n        // Re-enable collider\n        if (_collider != null)\n            _collider.enabled = true;\n            \n        // Update visuals and audio\n        UpdateVisualState();\n        PlayUnequipSound();\n        \n        // Trigger events\n        OnDefenseChanged?.Invoke(-_defenseBonus);\n        OnArmorUnequipped?.Invoke(_armorName);\n        \n        Debug.Log($\"{_armorName} unequipped! Defense bonus removed: -{_defenseBonus}\");\n    }\n    \n    private void ApplyDefenseBonus(GameObject target, int bonus)\n    {\n        // Store defense bonus in a component on the target\n        DefenseTracker tracker = target.GetComponent<DefenseTracker>();\n        if (tracker == null)\n            tracker = target.AddComponent<DefenseTracker>();\n            \n        tracker.ModifyDefense(bonus);\n    }\n    \n    private Vector3 GetArmorPosition()\n    {\n        switch (_armorType)\n        {\n            case ArmorType.Helmet:\n                return new Vector3(0, 1.8f, 0);\n            case ArmorType.Chest:\n                return new Vector3(0, 1.2f, 0);\n            case ArmorType.Legs:\n                return new Vector3(0, 0.6f, 0);\n            case ArmorType.Boots:\n                return new Vector3(0, 0.1f, 0);\n            case ArmorType.Gloves:\n                return new Vector3(0.3f, 1.0f, 0);\n            case ArmorType.Shield:\n                return new Vector3(-0.5f, 1.0f, 0);\n            default:\n                return Vector3.zero;\n        }\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_renderer != null)\n        {\n            if (_isEquipped && _equippedMaterial != null)\n                _renderer.material = _equippedMaterial;\n            else if (!_isEquipped && _unequippedMaterial != null)\n                _renderer.material = _unequippedMaterial;\n        }\n        \n        if (_visualModel != null)\n            _visualModel.SetActive(_isEquipped);\n    }\n    \n    private void PlayEquipSound()\n    {\n        if (_audioSource != null && _equipSound != null)\n        {\n            _audioSource.clip = _equipSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void PlayUnequipSound()\n    {\n        if (_audioSource != null && _unequipSound != null)\n        {\n            _audioSource.clip = _unequipSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _defenseBonus = Mathf.Max(0, _defenseBonus);\n    }\n    \n    [System.Serializable]\n    public class DefenseTracker : MonoBehaviour\n    {\n        [SerializeField] private int _totalDefense = 0;\n        \n        public int TotalDefense => _totalDefense;\n        \n        public void ModifyDefense(int amount)\n        {\n            _totalDefense += amount;\n            _totalDefense = Mathf.Max(0, _totalDefense);\n        }\n        \n        public void SetDefense(int value)\n        {\n            _totalDefense = Mathf.Max(0, value);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "scroll that teaches new ability",
      "ideal_ir": {
        "class_name": "AbilityScroll",
        "components": [
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "abilityName",
            "type": "string",
            "default": "Fireball"
          },
          {
            "name": "abilityDescription",
            "type": "string",
            "default": "Launches a fiery projectile"
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 30
          },
          {
            "name": "bobHeight",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "bobSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "isConsumed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "float_and_glow",
            "trigger": "always while not consumed",
            "actions": [
              {
                "action": "rotate slowly around vertical axis"
              },
              {
                "action": "bob up and down gently"
              },
              {
                "action": "emit magical glow effect"
              }
            ]
          },
          {
            "name": "teach_ability",
            "trigger": "when player touches scroll",
            "actions": [
              {
                "action": "display ability learning notification with name and description"
              },
              {
                "action": "add new ability to player ability list"
              },
              {
                "action": "play magical learning sound effect"
              },
              {
                "action": "create sparkle particle effect"
              },
              {
                "action": "mark scroll as consumed"
              },
              {
                "action": "fade out and destroy scroll object"
              }
            ]
          },
          {
            "name": "highlight_on_approach",
            "trigger": "when player is nearby",
            "actions": [
              {
                "action": "increase glow intensity"
              },
              {
                "action": "display ability name above scroll"
              }
            ]
          },
          {
            "name": "stop_highlight",
            "trigger": "when player moves away",
            "actions": [
              {
                "action": "return glow to normal intensity"
              },
              {
                "action": "hide ability name display"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AbilityScroll : MonoBehaviour\n{\n    [Header(\"Scroll Settings\")]\n    [SerializeField] private string _abilityName = \"New Ability\";\n    [SerializeField] private string _abilityDescription = \"You have learned a new ability!\";\n    [SerializeField] private Sprite _abilityIcon;\n    [SerializeField] private KeyCode _abilityKey = KeyCode.Q;\n    [SerializeField] private float _abilityCooldown = 5f;\n    [SerializeField] private float _abilityDuration = 3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _glowEffect;\n    [SerializeField] private ParticleSystem _learnEffect;\n    [SerializeField] private AudioClip _learnSound;\n    [SerializeField] private float _floatSpeed = 1f;\n    [SerializeField] private float _floatHeight = 0.5f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _abilityUI;\n    [SerializeField] private UnityEngine.UI.Text _abilityNameText;\n    [SerializeField] private UnityEngine.UI.Text _abilityDescriptionText;\n    [SerializeField] private UnityEngine.UI.Image _abilityIconImage;\n    [SerializeField] private UnityEngine.UI.Text _keyBindText;\n    [SerializeField] private float _uiDisplayTime = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnAbilityLearned;\n    public UnityEvent OnScrollCollected;\n    \n    private Vector3 _startPosition;\n    private bool _isLearned = false;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private GameObject _currentPlayer;\n    \n    [System.Serializable]\n    public class LearnedAbility\n    {\n        public string name;\n        public string description;\n        public KeyCode keyCode;\n        public float cooldown;\n        public float duration;\n        public bool isActive;\n        public float lastUsedTime;\n        \n        public bool CanUse()\n        {\n            return Time.time >= lastUsedTime + cooldown;\n        }\n        \n        public void Use()\n        {\n            lastUsedTime = Time.time;\n        }\n    }\n    \n    private static System.Collections.Generic.List<LearnedAbility> _learnedAbilities = new System.Collections.Generic.List<LearnedAbility>();\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.SetActive(true);\n        }\n        \n        if (_abilityUI != null)\n        {\n            _abilityUI.gameObject.SetActive(false);\n        }\n    }\n    \n    void Update()\n    {\n        if (!_isLearned)\n        {\n            FloatAnimation();\n        }\n        \n        HandleAbilityInput();\n    }\n    \n    void FloatAnimation()\n    {\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatHeight;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.transform.Rotate(0, 50f * Time.deltaTime, 0);\n        }\n    }\n    \n    void HandleAbilityInput()\n    {\n        if (_currentPlayer == null) return;\n        \n        foreach (var ability in _learnedAbilities)\n        {\n            if (Input.GetKeyDown(ability.keyCode) && ability.CanUse())\n            {\n                ActivateAbility(ability);\n            }\n        }\n    }\n    \n    void ActivateAbility(LearnedAbility ability)\n    {\n        ability.Use();\n        ability.isActive = true;\n        \n        StartCoroutine(DeactivateAbilityAfterDuration(ability));\n        \n        Debug.Log($\"Activated ability: {ability.name}\");\n    }\n    \n    System.Collections.IEnumerator DeactivateAbilityAfterDuration(LearnedAbility ability)\n    {\n        yield return new WaitForSeconds(ability.duration);\n        ability.isActive = false;\n        Debug.Log($\"Deactivated ability: {ability.name}\");\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isLearned) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            LearnAbility(other.gameObject);\n        }\n    }\n    \n    void LearnAbility(GameObject player)\n    {\n        _isLearned = true;\n        _currentPlayer = player;\n        \n        LearnedAbility newAbility = new LearnedAbility\n        {\n            name = _abilityName,\n            description = _abilityDescription,\n            keyCode = _abilityKey,\n            cooldown = _abilityCooldown,\n            duration = _abilityDuration,\n            isActive = false,\n            lastUsedTime = -_abilityCooldown\n        };\n        \n        _learnedAbilities.Add(newAbility);\n        \n        PlayLearnEffects();\n        ShowAbilityUI();\n        \n        OnAbilityLearned?.Invoke(_abilityName);\n        OnScrollCollected?.Invoke();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.SetActive(false);\n        }\n        \n        Destroy(gameObject, 2f);\n    }\n    \n    void PlayLearnEffects()\n    {\n        if (_learnEffect != null)\n        {\n            _learnEffect.Play();\n        }\n        \n        if (_learnSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_learnSound);\n        }\n    }\n    \n    void ShowAbilityUI()\n    {\n        if (_abilityUI == null) return;\n        \n        _abilityUI.gameObject.SetActive(true);\n        \n        if (_abilityNameText != null)\n        {\n            _abilityNameText.text = _abilityName;\n        }\n        \n        if (_abilityDescriptionText != null)\n        {\n            _abilityDescriptionText.text = _abilityDescription;\n        }\n        \n        if (_abilityIconImage != null && _abilityIcon != null)\n        {\n            _abilityIconImage.sprite = _abilityIcon;\n        }\n        \n        if (_keyBindText != null)\n        {\n            _keyBindText.text = $\"Press {_abilityKey} to use\";\n        }\n        \n        StartCoroutine(HideUIAfterDelay());\n    }\n    \n    System.Collections.IEnumerator HideUIAfterDelay()\n    {\n        yield return new WaitForSeconds(_uiDisplayTime);\n        \n        if (_abilityUI != null)\n        {\n            _abilityUI.gameObject.SetActive(false);\n        }\n    }\n    \n    public static bool HasAbility(string abilityName)\n    {\n        return _learnedAbilities.Exists(a => a.name == abilityName);\n    }\n    \n    public static bool IsAbilityActive(string abilityName)\n    {\n        var ability = _learnedAbilities.Find(a => a.name == abilityName);\n        return ability != null && ability.isActive;\n    }\n    \n    public static float GetAbilityCooldownRemaining(string abilityName)\n    {\n        var ability = _learnedAbilities.Find(a => a.name == abilityName);\n        if (ability == null) return 0f;\n        \n        float timeRemaining = (ability.lastUsedTime + ability.cooldown) - Time.time;\n        return Mathf.Max(0f, timeRemaining);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        Gizmos.color = Color.blue;\n        Vector3 floatPos = transform.position + Vector3.up * _floatHeight;\n        Gizmos.DrawWireSphere(floatPos, 0.1f);\n        \n        Vector3 floatPosDown = transform.position - Vector3.up * _floatHeight;\n        Gizmos.DrawWireSphere(floatPosDown, 0.1f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rare drop with sparkle effects",
      "ideal_ir": {
        "class_name": "RareDropItem",
        "components": [
          "Rigidbody",
          "Collider",
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "dropChance",
            "type": "float",
            "default": 0.05
          },
          {
            "name": "sparkleIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "bobHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "bobSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 45.0
          },
          {
            "name": "magnetRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "magnetSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "despawnTime",
            "type": "float",
            "default": 30.0
          }
        ],
        "behaviors": [
          {
            "name": "spawn_with_sparkles",
            "trigger": "when item spawns",
            "actions": [
              {
                "action": "start sparkle particle effects"
              },
              {
                "action": "play rare item spawn sound"
              },
              {
                "action": "emit bright golden glow"
              },
              {
                "action": "begin floating animation"
              }
            ]
          },
          {
            "name": "floating_animation",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "bob up and down smoothly"
              },
              {
                "action": "rotate slowly around vertical axis"
              },
              {
                "action": "pulse sparkle effects rhythmically"
              }
            ]
          },
          {
            "name": "attract_to_player",
            "trigger": "when player enters magnet range",
            "actions": [
              {
                "action": "move toward player with increasing speed"
              },
              {
                "action": "intensify sparkle effects"
              },
              {
                "action": "play attraction sound effect"
              }
            ]
          },
          {
            "name": "collect_item",
            "trigger": "when player touches item",
            "actions": [
              {
                "action": "add item to player inventory"
              },
              {
                "action": "burst sparkle explosion"
              },
              {
                "action": "play collection sound"
              },
              {
                "action": "show rare item notification"
              },
              {
                "action": "destroy item object"
              }
            ]
          },
          {
            "name": "despawn_timer",
            "trigger": "after despawn time elapses without collection",
            "actions": [
              {
                "action": "fade out sparkle effects"
              },
              {
                "action": "gradually reduce glow intensity"
              },
              {
                "action": "destroy item object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RareDrop : MonoBehaviour\n{\n    [Header(\"Drop Settings\")]\n    [SerializeField] private float _magnetRange = 5f;\n    [SerializeField] private float _magnetSpeed = 8f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _despawnTime = 30f;\n    \n    [Header(\"Sparkle Effects\")]\n    [SerializeField] private GameObject _sparklePrefab;\n    [SerializeField] private int _sparkleCount = 8;\n    [SerializeField] private float _sparkleRadius = 1.5f;\n    [SerializeField] private float _sparkleSpeed = 2f;\n    [SerializeField] private float _sparkleLifetime = 1f;\n    [SerializeField] private Color _sparkleColor = Color.yellow;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    private Vector3 _startPosition;\n    private bool _isBeingMagneted = false;\n    private Transform _playerTransform;\n    private AudioSource _audioSource;\n    private float _bobTimer;\n    private Coroutine _sparkleCoroutine;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_spawnSound != null)\n        {\n            _audioSource.PlayOneShot(_spawnSound);\n        }\n        \n        _sparkleCoroutine = StartCoroutine(SparkleEffect());\n        \n        Destroy(gameObject, _despawnTime);\n    }\n    \n    private void Update()\n    {\n        HandleBobbing();\n        HandleRotation();\n        CheckForPlayer();\n        \n        if (_isBeingMagneted && _playerTransform != null)\n        {\n            MoveTowardsPlayer();\n        }\n    }\n    \n    private void HandleBobbing()\n    {\n        if (!_isBeingMagneted)\n        {\n            _bobTimer += Time.deltaTime * _bobSpeed;\n            Vector3 newPosition = _startPosition;\n            newPosition.y += Mathf.Sin(_bobTimer) * _bobHeight;\n            transform.position = newPosition;\n        }\n    }\n    \n    private void HandleRotation()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_isBeingMagneted) return;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _magnetRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerTransform = col.transform;\n                _isBeingMagneted = true;\n                break;\n            }\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_playerTransform == null) return;\n        \n        Vector3 direction = (_playerTransform.position - transform.position).normalized;\n        transform.position += direction * _magnetSpeed * Time.deltaTime;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            CollectDrop();\n        }\n    }\n    \n    private void CollectDrop()\n    {\n        if (_pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        CreatePickupEffect();\n        \n        if (_sparkleCoroutine != null)\n        {\n            StopCoroutine(_sparkleCoroutine);\n        }\n        \n        GetComponent<Renderer>().enabled = false;\n        GetComponent<Collider>().enabled = false;\n        \n        Destroy(gameObject, _pickupSound != null ? _pickupSound.length : 0.1f);\n    }\n    \n    private void CreatePickupEffect()\n    {\n        for (int i = 0; i < _sparkleCount * 2; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere;\n            Vector3 spawnPosition = transform.position + randomDirection * 0.5f;\n            \n            GameObject sparkle = CreateSparkle(spawnPosition);\n            if (sparkle != null)\n            {\n                Rigidbody rb = sparkle.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    rb.velocity = randomDirection * _sparkleSpeed * 2f;\n                }\n                \n                Destroy(sparkle, _sparkleLifetime);\n            }\n        }\n    }\n    \n    private IEnumerator SparkleEffect()\n    {\n        while (true)\n        {\n            for (int i = 0; i < _sparkleCount; i++)\n            {\n                float angle = (360f / _sparkleCount) * i;\n                float radian = angle * Mathf.Deg2Rad;\n                \n                Vector3 offset = new Vector3(\n                    Mathf.Cos(radian) * _sparkleRadius,\n                    Random.Range(-0.5f, 0.5f),\n                    Mathf.Sin(radian) * _sparkleRadius\n                );\n                \n                Vector3 sparklePosition = transform.position + offset;\n                GameObject sparkle = CreateSparkle(sparklePosition);\n                \n                if (sparkle != null)\n                {\n                    StartCoroutine(AnimateSparkle(sparkle));\n                }\n            }\n            \n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n    \n    private GameObject CreateSparkle(Vector3 position)\n    {\n        GameObject sparkle;\n        \n        if (_sparklePrefab != null)\n        {\n            sparkle = Instantiate(_sparklePrefab, position, Quaternion.identity);\n        }\n        else\n        {\n            sparkle = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            sparkle.transform.position = position;\n            sparkle.transform.localScale = Vector3.one * 0.1f;\n            \n            Renderer renderer = sparkle.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Material material = new Material(Shader.Find(\"Standard\"));\n                material.color = _sparkleColor;\n                material.SetFloat(\"_Metallic\", 1f);\n                material.SetFloat(\"_Smoothness\", 1f);\n                renderer.material = material;\n            }\n            \n            Destroy(sparkle.GetComponent<Collider>());\n            \n            Rigidbody rb = sparkle.AddComponent<Rigidbody>();\n            rb.useGravity = false;\n            rb.drag = 2f;\n        }\n        \n        return sparkle;\n    }\n    \n    private IEnumerator AnimateSparkle(GameObject sparkle)\n    {\n        if (sparkle == null) yield break;\n        \n        Vector3 startScale = sparkle.transform.localScale;\n        float timer = 0f;\n        \n        while (timer < _sparkleLifetime && sparkle != null)\n        {\n            timer += Time.deltaTime;\n            float progress = timer / _sparkleLifetime;\n            \n            float scale = Mathf.Lerp(1f, 0f, progress);\n            sparkle.transform.localScale = startScale * scale;\n            \n            sparkle.transform.Rotate(Vector3.up, 360f * Time.deltaTime);\n            \n            Renderer renderer = sparkle.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Color color = renderer.material.color;\n                color.a = Mathf.Lerp(1f, 0f, progress);\n                renderer.material.color = color;\n            }\n            \n            yield return null;\n        }\n        \n        if (sparkle != null)\n        {\n            Destroy(sparkle);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _magnetRange);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _sparkleRadius);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "bouncing gem that moves randomly",
      "ideal_ir": {
        "class_name": "BouncingGem",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "bounceForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "randomMoveInterval",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3.0
          }
        ],
        "behaviors": [
          {
            "name": "random_movement",
            "trigger": "every random move interval seconds",
            "actions": [
              {
                "action": "choose random direction"
              },
              {
                "action": "apply force in random direction at move speed"
              }
            ]
          },
          {
            "name": "bounce_on_collision",
            "trigger": "when colliding with any surface",
            "actions": [
              {
                "action": "apply upward bounce force"
              },
              {
                "action": "add slight random horizontal force for variation"
              }
            ]
          },
          {
            "name": "continuous_gentle_movement",
            "trigger": "every frame",
            "actions": [
              {
                "action": "apply small random forces to keep gem moving"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class BouncingGem : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _bounceForce = 10f;\n    [SerializeField] private float _directionChangeInterval = 2f;\n    \n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _minBounceAngle = 30f;\n    [SerializeField] private float _maxBounceAngle = 150f;\n    [SerializeField] private LayerMask _bounceLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobAmplitude = 0.5f;\n    [SerializeField] private float _bobFrequency = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentDirection;\n    private float _directionTimer;\n    private Vector3 _startPosition;\n    private float _bobTimer;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 0.5f;\n        _rigidbody.angularDrag = 0.5f;\n        \n        _startPosition = transform.position;\n        _directionTimer = _directionChangeInterval;\n        \n        ChooseRandomDirection();\n    }\n    \n    private void Update()\n    {\n        HandleDirectionChange();\n        HandleVisualEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyMovement();\n    }\n    \n    private void HandleDirectionChange()\n    {\n        _directionTimer -= Time.deltaTime;\n        \n        if (_directionTimer <= 0f)\n        {\n            ChooseRandomDirection();\n            _directionTimer = _directionChangeInterval + Random.Range(-0.5f, 0.5f);\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n        \n        _bobTimer += Time.deltaTime * _bobFrequency;\n        float bobOffset = Mathf.Sin(_bobTimer) * _bobAmplitude;\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _startPosition.y + bobOffset;\n        transform.position = newPosition;\n        \n        _startPosition.x = transform.position.x;\n        _startPosition.z = transform.position.z;\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 targetVelocity = _currentDirection * _moveSpeed;\n        targetVelocity.y = _rigidbody.velocity.y;\n        \n        _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 5f);\n    }\n    \n    private void ChooseRandomDirection()\n    {\n        float randomAngle = Random.Range(0f, 360f);\n        _currentDirection = new Vector3(\n            Mathf.Cos(randomAngle * Mathf.Deg2Rad),\n            0f,\n            Mathf.Sin(randomAngle * Mathf.Deg2Rad)\n        ).normalized;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsInLayerMask(collision.gameObject.layer, _bounceLayerMask))\n        {\n            HandleBounce(collision);\n        }\n    }\n    \n    private void HandleBounce(Collision collision)\n    {\n        Vector3 normal = collision.contacts[0].normal;\n        Vector3 reflectedDirection = Vector3.Reflect(_currentDirection, normal);\n        \n        float bounceAngle = Random.Range(_minBounceAngle, _maxBounceAngle);\n        Vector3 randomDirection = Random.insideUnitSphere;\n        randomDirection.y = 0f;\n        randomDirection.Normalize();\n        \n        _currentDirection = Vector3.Slerp(reflectedDirection, randomDirection, 0.3f).normalized;\n        \n        _rigidbody.AddForce(normal * _bounceForce, ForceMode.Impulse);\n        \n        _directionTimer = _directionChangeInterval;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HandlePlayerInteraction();\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        _rigidbody.AddForce(Vector3.up * _bounceForce * 0.5f, ForceMode.Impulse);\n        ChooseRandomDirection();\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "floating heart health pickup",
      "ideal_ir": {
        "class_name": "FloatingHeartPickup",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "healthAmount",
            "type": "int",
            "default": 25
          },
          {
            "name": "floatHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90.0
          },
          {
            "name": "pulseScale",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "pulseSpeed",
            "type": "float",
            "default": 3.0
          }
        ],
        "behaviors": [
          {
            "name": "float_up_and_down",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "move up and down in a smooth sine wave pattern at float height and float speed"
              }
            ]
          },
          {
            "name": "rotate_continuously",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "rotate around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "pulse_scale",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "scale up and down smoothly between normal size and pulse scale at pulse speed"
              }
            ]
          },
          {
            "name": "heal_player_on_pickup",
            "trigger": "when player touches this pickup",
            "actions": [
              {
                "action": "restore health amount to player"
              },
              {
                "action": "play pickup sound effect"
              },
              {
                "action": "create healing particle effect"
              },
              {
                "action": "destroy this pickup object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FloatingHeartPickup : MonoBehaviour\n{\n    [Header(\"Pickup Settings\")]\n    [SerializeField] private int _healthAmount = 20;\n    [SerializeField] private float _pickupRange = 2f;\n    [SerializeField] private bool _destroyOnPickup = true;\n    \n    [Header(\"Floating Animation\")]\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _scaleOnPickup = 1.2f;\n    [SerializeField] private float _pickupAnimationDuration = 0.3f;\n    \n    [Header(\"Magnet Effect\")]\n    [SerializeField] private bool _enableMagnetEffect = true;\n    [SerializeField] private float _magnetRange = 5f;\n    [SerializeField] private float _magnetSpeed = 8f;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    private Transform _playerTransform;\n    private bool _isMagneting = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPickedUp) return;\n        \n        HandleFloatingAnimation();\n        HandleMagnetEffect();\n        CheckForPlayerPickup();\n    }\n    \n    private void HandleFloatingAnimation()\n    {\n        if (!_isMagneting)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n        \n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n    }\n    \n    private void HandleMagnetEffect()\n    {\n        if (!_enableMagnetEffect || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer <= _magnetRange && distanceToPlayer > _pickupRange)\n        {\n            _isMagneting = true;\n            Vector3 direction = (_playerTransform.position - transform.position).normalized;\n            transform.position = Vector3.MoveTowards(transform.position, _playerTransform.position, _magnetSpeed * Time.deltaTime);\n        }\n        else if (distanceToPlayer > _magnetRange)\n        {\n            _isMagneting = false;\n        }\n    }\n    \n    private void CheckForPlayerPickup()\n    {\n        if (_playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer <= _pickupRange)\n        {\n            PickupHeart();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PickupHeart();\n        }\n    }\n    \n    private void PickupHeart()\n    {\n        if (_isPickedUp) return;\n        \n        _isPickedUp = true;\n        \n        // Try to heal the player\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            // Try different common health component patterns\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send message to any health-related methods that might exist\n                player.SendMessage(\"Heal\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n                player.SendMessage(\"AddHealth\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n                player.SendMessage(\"RestoreHealth\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n        \n        // Play pickup effects\n        PlayPickupEffects();\n        \n        // Handle pickup animation or immediate destruction\n        if (_destroyOnPickup)\n        {\n            StartCoroutine(PickupAnimation());\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            _pickupEffect.Play();\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator PickupAnimation()\n    {\n        Vector3 originalScale = transform.localScale;\n        Vector3 targetScale = originalScale * _scaleOnPickup;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _pickupAnimationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _pickupAnimationDuration;\n            \n            // Scale up then down\n            float scaleMultiplier = progress < 0.5f ? \n                Mathf.Lerp(1f, _scaleOnPickup, progress * 2f) : \n                Mathf.Lerp(_scaleOnPickup, 0f, (progress - 0.5f) * 2f);\n            \n            transform.localScale = originalScale * scaleMultiplier;\n            \n            // Fade out if renderer exists\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null && renderer.material.HasProperty(\"_Color\"))\n            {\n                Color color = renderer.material.color;\n                color.a = 1f - progress;\n                renderer.material.color = color;\n            }\n            \n            yield return null;\n        }\n        \n        // Wait for sound to finish if playing\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            yield return new WaitWhile(() => _audioSource.isPlaying);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw pickup range\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _pickupRange);\n        \n        // Draw magnet range\n        if (_enableMagnetEffect)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _magnetRange);\n        }\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "weapon upgrade pickup",
      "ideal_ir": {
        "class_name": "WeaponUpgradePickup",
        "components": [
          "Collider",
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "upgradeType",
            "type": "string",
            "default": "damage"
          },
          {
            "name": "upgradeAmount",
            "type": "float",
            "default": 10
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "bobHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "bobSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "pickupSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "pickupEffect",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "idle_animation",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "rotate around vertical axis at rotation speed"
              },
              {
                "action": "bob up and down smoothly at bob height and bob speed"
              }
            ]
          },
          {
            "name": "pickup_weapon_upgrade",
            "trigger": "when player touches this pickup",
            "actions": [
              {
                "action": "apply weapon upgrade of specified type and amount to player"
              },
              {
                "action": "play pickup sound effect"
              },
              {
                "action": "spawn pickup visual effect at current position"
              },
              {
                "action": "destroy this pickup object"
              }
            ]
          },
          {
            "name": "attract_to_player",
            "trigger": "when player is very close to pickup",
            "actions": [
              {
                "action": "move toward player position with increasing speed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponUpgradePickup : MonoBehaviour\n{\n    [Header(\"Upgrade Configuration\")]\n    [SerializeField] private UpgradeType _upgradeType = UpgradeType.Damage;\n    [SerializeField] private float _upgradeValue = 10f;\n    [SerializeField] private string _upgradeName = \"Damage Boost\";\n    [SerializeField] private string _upgradeDescription = \"Increases weapon damage\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Pickup Settings\")]\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private float _pickupCooldown = 0.5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Events\")]\n    public UnityEvent<WeaponUpgrade> OnUpgradePickedUp;\n    public UnityEvent OnPickupDestroyed;\n    \n    private Vector3 _startPosition;\n    private bool _canBePickedUp = true;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    public enum UpgradeType\n    {\n        Damage,\n        FireRate,\n        Range,\n        Accuracy,\n        AmmoCapacity,\n        ReloadSpeed,\n        CriticalChance,\n        Penetration\n    }\n    \n    [System.Serializable]\n    public class WeaponUpgrade\n    {\n        public UpgradeType type;\n        public float value;\n        public string name;\n        public string description;\n        \n        public WeaponUpgrade(UpgradeType upgradeType, float upgradeValue, string upgradeName, string upgradeDescription)\n        {\n            type = upgradeType;\n            value = upgradeValue;\n            name = upgradeName;\n            description = upgradeDescription;\n        }\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        ValidateUpgradeSettings();\n    }\n    \n    private void Update()\n    {\n        if (_canBePickedUp)\n        {\n            AnimatePickup();\n        }\n    }\n    \n    private void AnimatePickup()\n    {\n        // Rotate the pickup\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        // Bob up and down\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canBePickedUp) return;\n        \n        if (IsPlayer(other))\n        {\n            PickupUpgrade(other.gameObject);\n        }\n    }\n    \n    private bool IsPlayer(Collider other)\n    {\n        return other.CompareTag(\"Player\") && ((_playerLayer.value & (1 << other.gameObject.layer)) != 0);\n    }\n    \n    private void PickupUpgrade(GameObject player)\n    {\n        _canBePickedUp = false;\n        \n        WeaponUpgrade upgrade = new WeaponUpgrade(_upgradeType, _upgradeValue, _upgradeName, _upgradeDescription);\n        \n        // Apply upgrade to player's weapon\n        ApplyUpgradeToPlayer(player, upgrade);\n        \n        // Trigger events\n        OnUpgradePickedUp?.Invoke(upgrade);\n        \n        // Play effects\n        PlayPickupEffects();\n        \n        // Handle pickup completion\n        if (_destroyOnPickup)\n        {\n            Invoke(nameof(DestroyPickup), 0.1f);\n        }\n        else\n        {\n            StartCooldown();\n        }\n    }\n    \n    private void ApplyUpgradeToPlayer(GameObject player, WeaponUpgrade upgrade)\n    {\n        // Look for weapon components on player or children\n        WeaponStats weaponStats = player.GetComponentInChildren<WeaponStats>();\n        if (weaponStats == null)\n        {\n            weaponStats = player.GetComponent<WeaponStats>();\n        }\n        \n        if (weaponStats != null)\n        {\n            weaponStats.ApplyUpgrade(upgrade);\n        }\n        else\n        {\n            Debug.LogWarning($\"No WeaponStats component found on player {player.name}. Upgrade not applied.\");\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        // Play sound\n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn visual effect\n        if (_pickupEffect != null)\n        {\n            GameObject effect = Instantiate(_pickupEffect, transform.position, transform.rotation);\n            Destroy(effect, 3f);\n        }\n        \n        // Hide visual\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void StartCooldown()\n    {\n        Invoke(nameof(ResetPickup), _pickupCooldown);\n    }\n    \n    private void ResetPickup()\n    {\n        _canBePickedUp = true;\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void DestroyPickup()\n    {\n        OnPickupDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    private void ValidateUpgradeSettings()\n    {\n        if (string.IsNullOrEmpty(_upgradeName))\n        {\n            _upgradeName = _upgradeType.ToString() + \" Upgrade\";\n        }\n        \n        if (string.IsNullOrEmpty(_upgradeDescription))\n        {\n            _upgradeDescription = $\"Improves {_upgradeType.ToString().ToLower()}\";\n        }\n        \n        if (_upgradeValue <= 0)\n        {\n            _upgradeValue = 1f;\n        }\n    }\n    \n    public void SetUpgrade(UpgradeType type, float value, string name = \"\", string description = \"\")\n    {\n        _upgradeType = type;\n        _upgradeValue = value;\n        \n        if (!string.IsNullOrEmpty(name))\n            _upgradeName = name;\n        \n        if (!string.IsNullOrEmpty(description))\n            _upgradeDescription = description;\n        \n        ValidateUpgradeSettings();\n    }\n    \n    public WeaponUpgrade GetUpgradeInfo()\n    {\n        return new WeaponUpgrade(_upgradeType, _upgradeValue, _upgradeName, _upgradeDescription);\n    }\n}\n\n[System.Serializable]\npublic class WeaponStats : MonoBehaviour\n{\n    [Header(\"Base Stats\")]\n    [SerializeField] private float _baseDamage = 25f;\n    [SerializeField] private float _baseFireRate = 1f;\n    [SerializeField] private float _baseRange = 100f;\n    [SerializeField] private float _baseAccuracy = 0.95f;\n    [SerializeField] private int _baseAmmoCapacity = 30;\n    [SerializeField] private float _baseReloadSpeed = 2f;\n    [SerializeField] private float _baseCriticalChance = 0.1f;\n    [SerializeField] private int _basePenetration = 1;\n    \n    [Header(\"Current Stats\")]\n    public float currentDamage;\n    public float currentFireRate;\n    public float currentRange;\n    public float currentAccuracy;\n    public int currentAmmoCapacity;\n    public float currentReloadSpeed;\n    public float currentCriticalChance;\n    public int currentPenetration;\n    \n    [Header(\"Upgrade Multipliers\")]\n    [SerializeField] private float _damageMultiplier = 1.1f;\n    [SerializeField] private float _fireRateMultiplier = 1.15f;\n    [SerializeField] private float _rangeMultiplier = 1.2f;\n    [SerializeField] private float _accuracyMultiplier = 1.05f;\n    [SerializeField] private float _ammoMultiplier = 1.25f;\n    [SerializeField] private float _reloadSpeedMultiplier = 0.9f;\n    [SerializeField] private float _criticalChanceMultiplier = 1.1f;\n    [SerializeField] private int _penetrationBonus = 1;\n    \n    private void Start()\n    {\n        InitializeStats();\n    }\n    \n    private void InitializeStats()\n    {\n        currentDamage = _baseDamage;\n        currentFireRate = _baseFireRate;\n        currentRange = _baseRange;\n        currentAccuracy = _baseAccuracy;\n        currentAmmoCapacity = _baseAmmoCapacity;\n        currentReloadSpeed = _baseReloadSpeed;\n        currentCriticalChance = _baseCriticalChance;\n        currentPenetration = _basePenetration;\n    }\n    \n    public void ApplyUpgrade(WeaponUpgradePickup.WeaponUpgrade upgrade)\n    {\n        switch (upgrade.type)\n        {\n            case WeaponUpgradePickup.UpgradeType.Damage:\n                currentDamage += upgrade.value;\n                break;\n            case WeaponUpgradePickup.UpgradeType.FireRate:\n                currentFireRate *= _fireRateMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.Range:\n                currentRange *= _rangeMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.Accuracy:\n                currentAccuracy = Mathf.Min(1f, currentAccuracy * _accuracyMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.AmmoCapacity:\n                currentAmmoCapacity = Mathf.RoundToInt(currentAmmoCapacity * _ammoMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.ReloadSpeed:\n                currentReloadSpeed *= _reloadSpeedMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.CriticalChance:\n                currentCriticalChance = Mathf.Min(1f, currentCriticalChance * _criticalChanceMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.Penetration:\n                currentPenetration += _penetrationBonus;\n                break;\n        }\n        \n        Debug.Log($\"Applied {upgrade.name}: {upgrade.description}\");\n    }\n    \n    public void ResetToBaseStats()\n    {\n        InitializeStats();\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "skill point orb",
      "ideal_ir": {
        "class_name": "SkillPointOrb",
        "components": [
          "Rigidbody",
          "SphereCollider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "skillPointValue",
            "type": "int",
            "default": 1
          },
          {
            "name": "floatHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90.0
          },
          {
            "name": "attractionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "attractionSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "pulseSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isCollected",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "idle_floating",
            "trigger": "when orb is spawned and not collected",
            "actions": [
              {
                "action": "float up and down smoothly at specified height and speed"
              },
              {
                "action": "rotate continuously around vertical axis at rotation speed"
              },
              {
                "action": "pulse glow intensity using sine wave pattern"
              },
              {
                "action": "emit magical particle effects around orb"
              }
            ]
          },
          {
            "name": "attract_to_player",
            "trigger": "when player enters attraction range and orb is not collected",
            "actions": [
              {
                "action": "move toward player position at attraction speed"
              },
              {
                "action": "increase glow intensity as orb gets closer to player"
              },
              {
                "action": "play attraction sound effect"
              },
              {
                "action": "increase particle emission rate"
              }
            ]
          },
          {
            "name": "collect_skill_points",
            "trigger": "when orb collides with player",
            "actions": [
              {
                "action": "add skill point value to player skill points"
              },
              {
                "action": "play collection sound effect"
              },
              {
                "action": "create bright flash particle burst"
              },
              {
                "action": "display floating text showing skill points gained"
              },
              {
                "action": "mark orb as collected"
              },
              {
                "action": "destroy orb after brief delay"
              }
            ]
          },
          {
            "name": "despawn_timer",
            "trigger": "when orb exists for extended time without being collected",
            "actions": [
              {
                "action": "start blinking glow effect to indicate despawn warning"
              },
              {
                "action": "gradually fade out orb transparency"
              },
              {
                "action": "destroy orb after fade completes"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SkillPointOrb : MonoBehaviour\n{\n    [Header(\"Orb Settings\")]\n    [SerializeField] private int _skillPointValue = 1;\n    [SerializeField] private float _collectRadius = 2f;\n    [SerializeField] private bool _autoCollect = true;\n    [SerializeField] private float _lifeTime = 30f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private bool _floatMovement = true;\n    [SerializeField] private float _floatSpeed = 1f;\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _attractionSpeed = 8f;\n    [SerializeField] private float _attractionRange = 5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnSkillPointCollected;\n    public UnityEvent OnOrbDestroyed;\n    \n    private Transform _player;\n    private Vector3 _startPosition;\n    private float _timeAlive;\n    private bool _isBeingCollected;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Vector3 _originalScale;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _originalScale = transform.localScale;\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n            _collider.radius = _collectRadius;\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        _timeAlive += Time.deltaTime;\n        \n        if (_timeAlive >= _lifeTime && !_isBeingCollected)\n        {\n            DestroyOrb();\n            return;\n        }\n        \n        if (_isBeingCollected)\n        {\n            MoveTowardsPlayer();\n            return;\n        }\n        \n        if (_floatMovement)\n        {\n            FloatAnimation();\n        }\n        \n        PulseEffect();\n        \n        if (_autoCollect && _player != null)\n        {\n            CheckForPlayerProximity();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void FloatAnimation()\n    {\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        \n        transform.Rotate(0, 50f * Time.deltaTime, 0);\n    }\n    \n    private void PulseEffect()\n    {\n        if (_renderer != null)\n        {\n            float pulse = 1f + Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n            transform.localScale = _originalScale * pulse;\n            \n            if (_originalMaterial != null)\n            {\n                Color color = _originalMaterial.color;\n                color.a = 0.7f + Mathf.Sin(Time.time * _pulseSpeed) * 0.3f;\n                _renderer.material.color = color;\n            }\n        }\n    }\n    \n    private void CheckForPlayerProximity()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attractionRange && !_isBeingCollected)\n        {\n            _isBeingCollected = true;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        transform.position += direction * _attractionSpeed * Time.deltaTime;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= 0.5f)\n        {\n            CollectOrb();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isBeingCollected)\n        {\n            if (_autoCollect)\n            {\n                _isBeingCollected = true;\n            }\n            else\n            {\n                CollectOrb();\n            }\n        }\n    }\n    \n    private void CollectOrb()\n    {\n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        OnSkillPointCollected?.Invoke(_skillPointValue);\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n            Destroy(gameObject, _collectSound.length);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n    }\n    \n    private void DestroyOrb()\n    {\n        OnOrbDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    public void SetSkillPointValue(int value)\n    {\n        _skillPointValue = Mathf.Max(1, value);\n    }\n    \n    public int GetSkillPointValue()\n    {\n        return _skillPointValue;\n    }\n    \n    public void ForceCollect()\n    {\n        if (!_isBeingCollected)\n        {\n            _isBeingCollected = true;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_originalMaterial != null)\n        {\n            Destroy(_originalMaterial);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "currency bag with gold coins",
      "ideal_ir": {
        "class_name": "CurrencyBag",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "goldAmount",
            "type": "int",
            "default": 50
          },
          {
            "name": "collectSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "sparkleEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isCollected",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "collect_currency",
            "trigger": "when player touches the currency bag",
            "actions": [
              {
                "action": "add gold amount to player inventory"
              },
              {
                "action": "play collection sound effect"
              },
              {
                "action": "spawn sparkle particle effect at bag position"
              },
              {
                "action": "mark bag as collected"
              },
              {
                "action": "destroy the currency bag object"
              }
            ]
          },
          {
            "name": "idle_animation",
            "trigger": "continuously while bag exists and not collected",
            "actions": [
              {
                "action": "gently rotate the bag around vertical axis"
              },
              {
                "action": "bob up and down slightly"
              }
            ]
          },
          {
            "name": "attract_attention",
            "trigger": "when player is nearby but not touching",
            "actions": [
              {
                "action": "increase rotation speed slightly"
              },
              {
                "action": "emit golden glow effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class CurrencyBag : MonoBehaviour\n{\n    [Header(\"Currency Settings\")]\n    [SerializeField] private int _goldAmount = 100;\n    [SerializeField] private bool _isCollected = false;\n    [SerializeField] private float _collectDistance = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _coinPrefab;\n    [SerializeField] private Transform _coinSpawnPoint;\n    [SerializeField] private int _coinCount = 5;\n    [SerializeField] private float _coinSpawnRadius = 1f;\n    [SerializeField] private float _coinSpawnForce = 5f;\n    [SerializeField] private ParticleSystem _collectEffect;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.2f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private AudioClip _coinSpillSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnGoldCollected;\n    public UnityEvent OnBagDestroyed;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private bool _isSpillingCoins = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        \n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_collider).isTrigger = true;\n            ((SphereCollider)_collider).radius = _collectDistance;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_coinSpawnPoint == null)\n        {\n            _coinSpawnPoint = transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        AnimateBag();\n        CheckForPlayerNearby();\n    }\n    \n    private void AnimateBag()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _startPosition + Vector3.up * bobOffset;\n        \n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayerNearby()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _collectDistance);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                CollectBag();\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectBag();\n        }\n    }\n    \n    private void CollectBag()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        SpillCoins();\n        PlayCollectEffects();\n        OnGoldCollected?.Invoke(_goldAmount);\n        \n        StartCoroutine(DestroyAfterDelay(2f));\n    }\n    \n    private void SpillCoins()\n    {\n        if (_coinPrefab == null || _isSpillingCoins) return;\n        \n        _isSpillingCoins = true;\n        \n        if (_coinSpillSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_coinSpillSound);\n        }\n        \n        for (int i = 0; i < _coinCount; i++)\n        {\n            Vector3 spawnPosition = _coinSpawnPoint.position + Random.insideUnitSphere * _coinSpawnRadius;\n            spawnPosition.y = _coinSpawnPoint.position.y;\n            \n            GameObject coin = Instantiate(_coinPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody coinRb = coin.GetComponent<Rigidbody>();\n            if (coinRb == null)\n            {\n                coinRb = coin.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 forceDirection = (spawnPosition - _coinSpawnPoint.position).normalized;\n            forceDirection.y = 0.5f;\n            coinRb.AddForce(forceDirection * _coinSpawnForce, ForceMode.Impulse);\n            \n            coin.AddComponent<CoinBehavior>().Initialize(Random.Range(5, 25));\n            \n            Destroy(coin, 10f);\n        }\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectEffect != null)\n        {\n            _collectEffect.Play();\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        \n        OnBagDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    public void SetGoldAmount(int amount)\n    {\n        _goldAmount = Mathf.Max(0, amount);\n    }\n    \n    public int GetGoldAmount()\n    {\n        return _goldAmount;\n    }\n    \n    public bool IsCollected()\n    {\n        return _isCollected;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _collectDistance);\n        \n        if (_coinSpawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_coinSpawnPoint.position, _coinSpawnRadius);\n        }\n    }\n}\n\n[System.Serializable]\npublic class CoinBehavior : MonoBehaviour\n{\n    private int _value;\n    private float _collectRadius = 1f;\n    private bool _isCollected = false;\n    private AudioSource _audioSource;\n    \n    public void Initialize(int value)\n    {\n        _value = value;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.volume = 0.3f;\n        _audioSource.playOnAwake = false;\n        \n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            col = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)col).isTrigger = true;\n            ((SphereCollider)col).radius = _collectRadius;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        transform.Rotate(Vector3.up, 180f * Time.deltaTime);\n        \n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _collectRadius);\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                CollectCoin();\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            renderer.enabled = false;\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    public int GetValue()\n    {\n        return _value;\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "mushroom power-up",
      "ideal_ir": {
        "class_name": "MushroomPowerUp",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "bounceHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "pointValue",
            "type": "int",
            "default": 1000
          },
          {
            "name": "growthMultiplier",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "spawn_from_block",
            "trigger": "when spawned from question block",
            "actions": [
              {
                "action": "emerge upward from block slowly"
              },
              {
                "action": "play mushroom spawn sound"
              },
              {
                "action": "become solid after fully emerged"
              }
            ]
          },
          {
            "name": "ground_movement",
            "trigger": "when touching ground",
            "actions": [
              {
                "action": "move horizontally at constant speed"
              },
              {
                "action": "change direction when hitting wall or obstacle"
              },
              {
                "action": "fall when reaching edge of platform"
              }
            ]
          },
          {
            "name": "player_collection",
            "trigger": "when player touches mushroom",
            "actions": [
              {
                "action": "make player grow larger"
              },
              {
                "action": "give player points"
              },
              {
                "action": "play power up sound"
              },
              {
                "action": "destroy mushroom object"
              }
            ]
          },
          {
            "name": "bounce_physics",
            "trigger": "when hitting ground after falling",
            "actions": [
              {
                "action": "bounce slightly upward"
              },
              {
                "action": "continue horizontal movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MushroomPowerUp : MonoBehaviour\n{\n    [Header(\"Power-Up Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _bounceForce = 5f;\n    [SerializeField] private int _scoreValue = 100;\n    [SerializeField] private float _lifeTime = 10f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private bool _moveOnSpawn = true;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private LayerMask _wallLayer = 1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnScoreAdded;\n    public UnityEvent OnPowerUpCollected;\n    \n    private Rigidbody2D _rigidbody;\n    private SpriteRenderer _spriteRenderer;\n    private Collider2D _collider;\n    private AudioSource _audioSource;\n    private bool _isMoving;\n    private int _moveDirection = 1;\n    private float _groundCheckDistance = 0.6f;\n    private float _wallCheckDistance = 0.6f;\n    private bool _isCollected;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        _collider = GetComponent<Collider2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody2D>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider2D>();\n        }\n        \n        _collider.isTrigger = true;\n    }\n    \n    private void Start()\n    {\n        InitializePowerUp();\n        \n        if (_spawnSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_spawnSound);\n        }\n        \n        Destroy(gameObject, _lifeTime);\n    }\n    \n    private void InitializePowerUp()\n    {\n        _isMoving = _moveOnSpawn;\n        _moveDirection = Random.Range(0, 2) == 0 ? -1 : 1;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.gravityScale = 1f;\n            _rigidbody.freezeRotation = true;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isCollected || !_isMoving) return;\n        \n        HandleMovement();\n        CheckForObstacles();\n    }\n    \n    private void HandleMovement()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector2 velocity = _rigidbody.velocity;\n        velocity.x = _moveSpeed * _moveDirection;\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void CheckForObstacles()\n    {\n        Vector2 rayOrigin = transform.position;\n        Vector2 rayDirection = Vector2.right * _moveDirection;\n        \n        RaycastHit2D wallHit = Physics2D.Raycast(rayOrigin, rayDirection, _wallCheckDistance, _wallLayer);\n        if (wallHit.collider != null)\n        {\n            _moveDirection *= -1;\n            return;\n        }\n        \n        Vector2 groundCheckOrigin = rayOrigin + rayDirection * 0.5f;\n        RaycastHit2D groundHit = Physics2D.Raycast(groundCheckOrigin, Vector2.down, _groundCheckDistance, _groundLayer);\n        if (groundHit.collider == null)\n        {\n            _moveDirection *= -1;\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectPowerUp(other.gameObject);\n        }\n    }\n    \n    private void CollectPowerUp(GameObject player)\n    {\n        _isCollected = true;\n        _isMoving = false;\n        \n        ApplyPowerUpEffect(player);\n        PlayCollectEffects();\n        AddScore();\n        \n        OnPowerUpCollected?.Invoke();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.5f);\n    }\n    \n    private void ApplyPowerUpEffect(GameObject player)\n    {\n        PlayerGrowthEffect growthEffect = player.GetComponent<PlayerGrowthEffect>();\n        if (growthEffect == null)\n        {\n            growthEffect = player.AddComponent<PlayerGrowthEffect>();\n        }\n        \n        growthEffect.GrowPlayer();\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n    }\n    \n    private void AddScore()\n    {\n        OnScoreAdded?.Invoke(_scoreValue);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector2 rayOrigin = transform.position;\n        Vector2 rayDirection = Vector2.right * _moveDirection;\n        Gizmos.DrawRay(rayOrigin, rayDirection * _wallCheckDistance);\n        \n        Gizmos.color = Color.blue;\n        Vector2 groundCheckOrigin = rayOrigin + rayDirection * 0.5f;\n        Gizmos.DrawRay(groundCheckOrigin, Vector2.down * _groundCheckDistance);\n    }\n}\n\npublic class PlayerGrowthEffect : MonoBehaviour\n{\n    [SerializeField] private float _growthScale = 1.5f;\n    [SerializeField] private float _growthDuration = 0.3f;\n    [SerializeField] private AnimationCurve _growthCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Vector3 _originalScale;\n    private Vector3 _targetScale;\n    private bool _isGrowing;\n    private float _growthTimer;\n    \n    private void Awake()\n    {\n        _originalScale = transform.localScale;\n        _targetScale = _originalScale * _growthScale;\n    }\n    \n    public void GrowPlayer()\n    {\n        if (_isGrowing) return;\n        \n        StartCoroutine(GrowthCoroutine());\n    }\n    \n    private System.Collections.IEnumerator GrowthCoroutine()\n    {\n        _isGrowing = true;\n        _growthTimer = 0f;\n        Vector3 startScale = transform.localScale;\n        \n        while (_growthTimer < _growthDuration)\n        {\n            _growthTimer += Time.deltaTime;\n            float progress = _growthTimer / _growthDuration;\n            float curveValue = _growthCurve.Evaluate(progress);\n            \n            transform.localScale = Vector3.Lerp(startScale, _targetScale, curveValue);\n            yield return null;\n        }\n        \n        transform.localScale = _targetScale;\n        _isGrowing = false;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "flower that grants special power",
      "ideal_ir": {
        "class_name": "PowerFlower",
        "components": [
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "powerType",
            "type": "string",
            "default": "speed"
          },
          {
            "name": "powerDuration",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "powerMultiplier",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "respawnTime",
            "type": "float",
            "default": 30.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "glow_effect",
            "trigger": "when flower is active",
            "actions": [
              {
                "action": "emit soft magical glow with pulsing animation"
              },
              {
                "action": "create sparkle particles around flower petals"
              }
            ]
          },
          {
            "name": "grant_power",
            "trigger": "when player touches the flower",
            "actions": [
              {
                "action": "give player the special power based on power type"
              },
              {
                "action": "apply power multiplier to player abilities"
              },
              {
                "action": "start power duration timer"
              },
              {
                "action": "play magical chime sound effect"
              },
              {
                "action": "create burst of golden particles"
              },
              {
                "action": "make flower disappear temporarily"
              }
            ]
          },
          {
            "name": "power_feedback",
            "trigger": "when power is granted to player",
            "actions": [
              {
                "action": "display power notification on screen"
              },
              {
                "action": "add glowing aura effect to player"
              },
              {
                "action": "change player movement trail color"
              }
            ]
          },
          {
            "name": "respawn_flower",
            "trigger": "when respawn time has elapsed after being picked",
            "actions": [
              {
                "action": "make flower visible again"
              },
              {
                "action": "reset flower to active state"
              },
              {
                "action": "play gentle wind chime sound"
              },
              {
                "action": "create swirling restoration particles"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MagicalFlower : MonoBehaviour\n{\n    [Header(\"Flower Settings\")]\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private float _powerDuration = 10f;\n    [SerializeField] private bool _singleUse = true;\n    [SerializeField] private float _respawnTime = 30f;\n    \n    [Header(\"Power Effects\")]\n    [SerializeField] private PowerType _powerType = PowerType.SpeedBoost;\n    [SerializeField] private float _powerMultiplier = 2f;\n    [SerializeField] private Color _powerColor = Color.magenta;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _idleParticles;\n    [SerializeField] private ParticleSystem _collectParticles;\n    [SerializeField] private GameObject _flowerModel;\n    [SerializeField] private Light _magicalLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _collectSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _bobSpeed = 1f;\n    [SerializeField] private float _bobHeight = 0.2f;\n    [SerializeField] private float _rotationSpeed = 30f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<PowerType, float, float> OnPowerGranted;\n    public UnityEvent OnFlowerCollected;\n    public UnityEvent OnFlowerRespawned;\n    \n    private bool _isAvailable = true;\n    private Vector3 _originalPosition;\n    private Transform _currentPlayer;\n    private Coroutine _respawnCoroutine;\n    \n    public enum PowerType\n    {\n        SpeedBoost,\n        JumpBoost,\n        StrengthBoost,\n        Invisibility,\n        Shield,\n        DoubleJump,\n        SlowMotion\n    }\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        \n        if (_magicalLight != null)\n        {\n            _magicalLight.color = _powerColor;\n        }\n        \n        if (_idleParticles != null)\n        {\n            var main = _idleParticles.main;\n            main.startColor = _powerColor;\n        }\n        \n        if (_collectParticles != null)\n        {\n            var main = _collectParticles.main;\n            main.startColor = _powerColor;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isAvailable) return;\n        \n        AnimateFlower();\n        CheckForPlayer();\n    }\n    \n    private void AnimateFlower()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _originalPosition + Vector3.up * bobOffset;\n        \n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                GrantPower(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isAvailable) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            GrantPower(other.gameObject);\n        }\n    }\n    \n    private void GrantPower(GameObject player)\n    {\n        if (!_isAvailable) return;\n        \n        _currentPlayer = player.transform;\n        \n        ApplyPowerToPlayer(player);\n        \n        OnPowerGranted?.Invoke(_powerType, _powerMultiplier, _powerDuration);\n        OnFlowerCollected?.Invoke();\n        \n        PlayCollectEffects();\n        \n        _isAvailable = false;\n        \n        if (_singleUse && _respawnTime <= 0)\n        {\n            gameObject.SetActive(false);\n        }\n        else\n        {\n            HideFlower();\n            if (_respawnCoroutine != null)\n                StopCoroutine(_respawnCoroutine);\n            _respawnCoroutine = StartCoroutine(RespawnCoroutine());\n        }\n    }\n    \n    private void ApplyPowerToPlayer(GameObject player)\n    {\n        PowerEffect powerEffect = player.GetComponent<PowerEffect>();\n        if (powerEffect == null)\n        {\n            powerEffect = player.AddComponent<PowerEffect>();\n        }\n        \n        powerEffect.ApplyPower(_powerType, _powerMultiplier, _powerDuration, _powerColor);\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectParticles != null)\n        {\n            _collectParticles.Play();\n        }\n        \n        if (_audioSource != null && _collectSound != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_magicalLight != null)\n        {\n            StartCoroutine(FlashLight());\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashLight()\n    {\n        float originalIntensity = _magicalLight.intensity;\n        \n        for (int i = 0; i < 3; i++)\n        {\n            _magicalLight.intensity = originalIntensity * 3f;\n            yield return new WaitForSeconds(0.1f);\n            _magicalLight.intensity = originalIntensity;\n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n    \n    private void HideFlower()\n    {\n        if (_flowerModel != null)\n            _flowerModel.SetActive(false);\n        \n        if (_idleParticles != null)\n            _idleParticles.Stop();\n        \n        if (_magicalLight != null)\n            _magicalLight.enabled = false;\n    }\n    \n    private void ShowFlower()\n    {\n        if (_flowerModel != null)\n            _flowerModel.SetActive(true);\n        \n        if (_idleParticles != null)\n            _idleParticles.Play();\n        \n        if (_magicalLight != null)\n            _magicalLight.enabled = true;\n    }\n    \n    private System.Collections.IEnumerator RespawnCoroutine()\n    {\n        yield return new WaitForSeconds(_respawnTime);\n        \n        _isAvailable = true;\n        ShowFlower();\n        OnFlowerRespawned?.Invoke();\n        \n        _respawnCoroutine = null;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}\n\npublic class PowerEffect : MonoBehaviour\n{\n    private MagicalFlower.PowerType _currentPowerType;\n    private float _powerMultiplier;\n    private float _remainingTime;\n    private Color _powerColor;\n    private bool _hasPower;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Material _powerMaterial;\n    \n    private float _originalSpeed;\n    private bool _canDoubleJump;\n    private bool _hasDoubleJumped;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponentInChildren<Renderer>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasPower)\n        {\n            _remainingTime -= Time.deltaTime;\n            \n            if (_remainingTime <= 0)\n            {\n                RemovePower();\n            }\n            else\n            {\n                UpdatePowerEffects();\n            }\n        }\n    }\n    \n    public void ApplyPower(MagicalFlower.PowerType powerType, float multiplier, float duration, Color color)\n    {\n        if (_hasPower)\n        {\n            RemovePower();\n        }\n        \n        _currentPowerType = powerType;\n        _powerMultiplier = multiplier;\n        _remainingTime = duration;\n        _powerColor = color;\n        _hasPower = true;\n        \n        ApplyVisualEffects();\n        ApplyPowerSpecificEffects();\n    }\n    \n    private void ApplyVisualEffects()\n    {\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _powerMaterial = new Material(_originalMaterial);\n            _powerMaterial.color = _powerColor;\n            _powerMaterial.SetFloat(\"_Metallic\", 0.8f);\n            _powerMaterial.EnableKeyword(\"_EMISSION\");\n            _powerMaterial.SetColor(\"_EmissionColor\", _powerColor * 0.5f);\n            _renderer.material = _powerMaterial;\n        }\n    }\n    \n    private void ApplyPowerSpecificEffects()\n    {\n        switch (_currentPowerType)\n        {\n            case MagicalFlower.PowerType.SpeedBoost:\n                if (_characterController != null)\n                {\n                    // Speed boost would be handled by movement script\n                }\n                break;\n                \n            case MagicalFlower.PowerType.DoubleJump:\n                _canDoubleJump = true;\n                _hasDoubleJumped = false;\n                break;\n                \n            case MagicalFlower.PowerType.Invisibility:\n                if (_renderer != null)\n                {\n                    Color invisColor = _renderer.material.color;\n                    invisColor.a = 0.3f;\n                    _renderer.material.color = invisColor;\n                }\n                break;\n                \n            case MagicalFlower.PowerType.SlowMotion:\n                Time.timeScale = 0.5f;\n                break;\n        }\n    }\n    \n    private void UpdatePowerEffects()\n    {\n        if (_renderer != null && _powerMaterial != null)\n        {\n            float pulse = Mathf.Sin(Time.time * 5f) * 0.3f + 0.7f;\n            _powerMaterial.SetColor(\"_EmissionColor\", _powerColor * pulse);\n        }\n    }\n    \n    private void RemovePower()\n    {\n        _hasPower = false;\n        \n        if (_renderer != null && _originalMaterial != null)\n        {\n            _renderer.material = _originalMaterial;\n        }\n        \n        if (_powerMaterial != null)\n        {\n            DestroyImmediate(_powerMaterial);\n        }\n        \n        switch (_currentPowerType)\n        {\n            case MagicalFlower.PowerType.DoubleJump:\n                _canDoubleJump = false;\n                break;\n                \n            case MagicalFlower.PowerType.SlowMotion:\n                Time.timeScale = 1f;\n                break;\n        }\n    }\n    \n    public bool HasPower()\n    {\n        return _hasPower;\n    }\n    \n    public MagicalFlower.PowerType GetCurrentPowerType()\n    {\n        return _currentPowerType;\n    }\n    \n    public float GetPowerMultiplier()\n    {\n        return _powerMultiplier;\n    }\n    \n    public float GetRemainingTime()\n    {\n        return _remainingTime;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_currentPowerType == MagicalFlower.PowerType.SlowMotion)\n        {\n            Time.timeScale = 1f;\n        }\n        \n        if (_powerMaterial != null)\n        {\n            DestroyImmediate(_powerMaterial);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "feather that enables floating",
      "ideal_ir": {
        "class_name": "FloatingFeather",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "floatHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "bobAmount",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "bobSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isFloating",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_floating",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "disable gravity on rigidbody"
              },
              {
                "action": "set floating state to true"
              },
              {
                "action": "begin gentle upward movement to float height"
              }
            ]
          },
          {
            "name": "maintain_float_height",
            "trigger": "when floating and below target height",
            "actions": [
              {
                "action": "apply gentle upward force to reach float height"
              }
            ]
          },
          {
            "name": "gentle_bobbing",
            "trigger": "when floating at target height",
            "actions": [
              {
                "action": "create subtle up and down bobbing motion"
              },
              {
                "action": "vary vertical position smoothly around float height"
              }
            ]
          },
          {
            "name": "drift_movement",
            "trigger": "when floating",
            "actions": [
              {
                "action": "apply very light random horizontal drift"
              },
              {
                "action": "create natural swaying motion like floating on air"
              }
            ]
          },
          {
            "name": "collect_feather",
            "trigger": "when player touches feather",
            "actions": [
              {
                "action": "play collection sound effect"
              },
              {
                "action": "create sparkle particle effect"
              },
              {
                "action": "destroy feather object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FloatingFeather : MonoBehaviour\n{\n    [Header(\"Feather Settings\")]\n    [SerializeField] private float _floatDuration = 5f;\n    [SerializeField] private float _floatForce = 10f;\n    [SerializeField] private float _pickupRange = 2f;\n    [SerializeField] private bool _consumeOnUse = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private ParticleSystem _floatEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private AudioClip _activateSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFeatherPickedUp;\n    public UnityEvent OnFloatActivated;\n    public UnityEvent OnFloatDeactivated;\n    \n    private Vector3 _startPosition;\n    private bool _isPickedUp = false;\n    private GameObject _currentPlayer;\n    private FloatingController _floatingController;\n    \n    [System.Serializable]\n    private class FloatingController\n    {\n        public GameObject player;\n        public Rigidbody playerRigidbody;\n        public float originalDrag;\n        public float floatTimeRemaining;\n        public bool isFloating;\n        \n        public FloatingController(GameObject playerObj, float duration)\n        {\n            player = playerObj;\n            playerRigidbody = playerObj.GetComponent<Rigidbody>();\n            floatTimeRemaining = duration;\n            isFloating = false;\n            \n            if (playerRigidbody != null)\n            {\n                originalDrag = playerRigidbody.drag;\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isPickedUp)\n        {\n            HandleFeatherAnimation();\n            CheckForPlayerInRange();\n        }\n        else if (_floatingController != null && _floatingController.isFloating)\n        {\n            UpdateFloating();\n        }\n    }\n    \n    private void HandleFeatherAnimation()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _startPosition + Vector3.up * bobOffset;\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayerInRange()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _pickupRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                PickupFeather(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isPickedUp && other.CompareTag(\"Player\"))\n        {\n            PickupFeather(other.gameObject);\n        }\n    }\n    \n    private void PickupFeather(GameObject player)\n    {\n        _isPickedUp = true;\n        _currentPlayer = player;\n        \n        PlaySound(_pickupSound);\n        PlayEffect(_pickupEffect);\n        \n        GetComponent<Renderer>().enabled = false;\n        GetComponent<Collider>().enabled = false;\n        \n        OnFeatherPickedUp?.Invoke();\n        \n        ActivateFloating();\n    }\n    \n    private void ActivateFloating()\n    {\n        if (_currentPlayer == null) return;\n        \n        _floatingController = new FloatingController(_currentPlayer, _floatDuration);\n        \n        if (_floatingController.playerRigidbody != null)\n        {\n            _floatingController.playerRigidbody.drag = 5f;\n            _floatingController.isFloating = true;\n            \n            PlaySound(_activateSound);\n            PlayEffect(_floatEffect);\n            \n            OnFloatActivated?.Invoke();\n        }\n    }\n    \n    private void UpdateFloating()\n    {\n        _floatingController.floatTimeRemaining -= Time.deltaTime;\n        \n        if (_floatingController.playerRigidbody != null)\n        {\n            Vector3 floatForceVector = Vector3.up * _floatForce;\n            _floatingController.playerRigidbody.AddForce(floatForceVector, ForceMode.Force);\n            \n            if (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.LeftShift))\n            {\n                _floatingController.playerRigidbody.AddForce(floatForceVector * 0.5f, ForceMode.Force);\n            }\n        }\n        \n        if (_floatingController.floatTimeRemaining <= 0f)\n        {\n            DeactivateFloating();\n        }\n    }\n    \n    private void DeactivateFloating()\n    {\n        if (_floatingController?.playerRigidbody != null)\n        {\n            _floatingController.playerRigidbody.drag = _floatingController.originalDrag;\n            _floatingController.isFloating = false;\n        }\n        \n        if (_floatEffect != null && _floatEffect.isPlaying)\n        {\n            _floatEffect.Stop();\n        }\n        \n        OnFloatDeactivated?.Invoke();\n        \n        if (_consumeOnUse)\n        {\n            Destroy(gameObject);\n        }\n        else\n        {\n            ResetFeather();\n        }\n    }\n    \n    private void ResetFeather()\n    {\n        _isPickedUp = false;\n        _currentPlayer = null;\n        _floatingController = null;\n        \n        GetComponent<Renderer>().enabled = true;\n        GetComponent<Collider>().enabled = true;\n        \n        transform.position = _startPosition;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    public float GetRemainingFloatTime()\n    {\n        return _floatingController?.floatTimeRemaining ?? 0f;\n    }\n    \n    public bool IsFloating()\n    {\n        return _floatingController?.isFloating ?? false;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _pickupRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "boots that increase speed",
      "ideal_ir": {
        "class_name": "SpeedBoots",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "speedMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isEquipped",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "equip_boots",
            "trigger": "when player collides with boots and presses interact key",
            "actions": [
              {
                "action": "set equipped status to true"
              },
              {
                "action": "hide boots visual"
              },
              {
                "action": "increase player movement speed by speed multiplier"
              },
              {
                "action": "play equip sound effect"
              }
            ]
          },
          {
            "name": "unequip_boots",
            "trigger": "when boots are equipped and player presses unequip key",
            "actions": [
              {
                "action": "set equipped status to false"
              },
              {
                "action": "restore player normal movement speed"
              },
              {
                "action": "drop boots at player location"
              },
              {
                "action": "show boots visual"
              },
              {
                "action": "play unequip sound effect"
              }
            ]
          },
          {
            "name": "speed_boost_effect",
            "trigger": "while boots are equipped and player is moving",
            "actions": [
              {
                "action": "apply speed multiplier to player movement"
              },
              {
                "action": "create dust particle effects at feet"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpeedBoots : MonoBehaviour\n{\n    [Header(\"Speed Boost Settings\")]\n    [SerializeField] private float _speedMultiplier = 1.5f;\n    [SerializeField] private float _boostDuration = 10f;\n    [SerializeField] private bool _isPermanent = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private ParticleSystem _speedTrailEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBootsPickedUp;\n    public UnityEvent OnSpeedBoostExpired;\n    \n    private AudioSource _audioSource;\n    private bool _hasBeenPickedUp = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasBeenPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpeedBoost(other.gameObject);\n        }\n    }\n    \n    private void ApplySpeedBoost(GameObject player)\n    {\n        CharacterController characterController = player.GetComponent<CharacterController>();\n        Rigidbody playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (characterController != null)\n        {\n            ApplySpeedBoostToCharacterController(characterController);\n        }\n        else if (playerRigidbody != null)\n        {\n            ApplySpeedBoostToRigidbody(player);\n        }\n        else\n        {\n            ApplySpeedBoostToTransform(player);\n        }\n        \n        PlayPickupEffects();\n        OnBootsPickedUp?.Invoke();\n        _hasBeenPickedUp = true;\n        \n        if (!_isPermanent)\n        {\n            Invoke(nameof(RemoveSpeedBoost), _boostDuration);\n        }\n        \n        gameObject.SetActive(false);\n    }\n    \n    private void ApplySpeedBoostToCharacterController(CharacterController controller)\n    {\n        SpeedBoostComponent speedBoost = controller.gameObject.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = controller.gameObject.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void ApplySpeedBoostToRigidbody(GameObject player)\n    {\n        SpeedBoostComponent speedBoost = player.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = player.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void ApplySpeedBoostToTransform(GameObject player)\n    {\n        SpeedBoostComponent speedBoost = player.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = player.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        OnSpeedBoostExpired?.Invoke();\n    }\n}\n\npublic class SpeedBoostComponent : MonoBehaviour\n{\n    private float _originalSpeed;\n    private float _speedMultiplier;\n    private float _boostDuration;\n    private bool _isPermanent;\n    private ParticleSystem _trailEffect;\n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private bool _isActive = false;\n    \n    public void Initialize(float speedMultiplier, float duration, bool isPermanent, ParticleSystem trailEffect)\n    {\n        _speedMultiplier = speedMultiplier;\n        _boostDuration = duration;\n        _isPermanent = isPermanent;\n        _trailEffect = trailEffect;\n        \n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        ApplySpeedBoost();\n        \n        if (_trailEffect != null)\n        {\n            ParticleSystem trail = Instantiate(_trailEffect, transform);\n            trail.Play();\n            \n            if (!_isPermanent)\n            {\n                Destroy(trail.gameObject, _boostDuration);\n            }\n        }\n        \n        if (!_isPermanent)\n        {\n            Invoke(nameof(RemoveSpeedBoost), _boostDuration);\n        }\n    }\n    \n    private void ApplySpeedBoost()\n    {\n        if (_isActive) return;\n        \n        _isActive = true;\n        \n        // Store original speed based on component type\n        if (_characterController != null)\n        {\n            // For CharacterController, we'll modify movement in a basic movement script\n            BasicPlayerMovement movement = GetComponent<BasicPlayerMovement>();\n            if (movement == null)\n            {\n                movement = gameObject.AddComponent<BasicPlayerMovement>();\n            }\n            movement.ApplySpeedMultiplier(_speedMultiplier);\n        }\n        else if (_rigidbody != null)\n        {\n            // For Rigidbody, we'll modify drag to simulate speed increase\n            _originalSpeed = _rigidbody.drag;\n            _rigidbody.drag = _originalSpeed / _speedMultiplier;\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        if (!_isActive) return;\n        \n        _isActive = false;\n        \n        if (_characterController != null)\n        {\n            BasicPlayerMovement movement = GetComponent<BasicPlayerMovement>();\n            if (movement != null)\n            {\n                movement.RemoveSpeedMultiplier();\n            }\n        }\n        else if (_rigidbody != null)\n        {\n            _rigidbody.drag = _originalSpeed;\n        }\n        \n        if (!_isPermanent)\n        {\n            Destroy(this);\n        }\n    }\n}\n\npublic class BasicPlayerMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _baseSpeed = 5f;\n    [SerializeField] private float _jumpForce = 5f;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _currentSpeedMultiplier = 1f;\n    private Vector3 _velocity;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n    }\n    \n    private void Update()\n    {\n        if (_characterController != null)\n        {\n            HandleCharacterControllerMovement();\n        }\n        else if (_rigidbody != null)\n        {\n            HandleRigidbodyMovement();\n        }\n    }\n    \n    private void HandleCharacterControllerMovement()\n    {\n        _isGrounded = _characterController.isGrounded;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _characterController.Move(moveDirection * _baseSpeed * _currentSpeedMultiplier * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _velocity.y = Mathf.Sqrt(_jumpForce * -2f * Physics.gravity.y);\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        _characterController.Move(_velocity * Time.deltaTime);\n    }\n    \n    private void HandleRigidbodyMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _rigidbody.MovePosition(transform.position + moveDirection * _baseSpeed * _currentSpeedMultiplier * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        }\n    }\n    \n    public void ApplySpeedMultiplier(float multiplier)\n    {\n        _currentSpeedMultiplier = multiplier;\n    }\n    \n    public void RemoveSpeedMultiplier()\n    {\n        _currentSpeedMultiplier = 1f;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ring that provides protection",
      "ideal_ir": {
        "class_name": "ProtectionRing",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "protectionAmount",
            "type": "float",
            "default": 50
          },
          {
            "name": "protectionDuration",
            "type": "float",
            "default": 30
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_protection",
            "trigger": "when player touches the ring",
            "actions": [
              {
                "action": "grant protection buff to player"
              },
              {
                "action": "reduce incoming damage by protection amount"
              },
              {
                "action": "start protection duration timer"
              },
              {
                "action": "make ring glow with protective aura"
              },
              {
                "action": "play protection activation sound"
              }
            ]
          },
          {
            "name": "maintain_protection",
            "trigger": "while protection is active",
            "actions": [
              {
                "action": "display protection visual effect around player"
              },
              {
                "action": "reduce all incoming damage"
              },
              {
                "action": "show remaining protection time"
              }
            ]
          },
          {
            "name": "end_protection",
            "trigger": "when protection duration expires",
            "actions": [
              {
                "action": "remove protection buff from player"
              },
              {
                "action": "fade out protective visual effects"
              },
              {
                "action": "play protection end sound"
              },
              {
                "action": "make ring available for pickup again"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when protection blocks damage",
            "actions": [
              {
                "action": "flash protective barrier effect"
              },
              {
                "action": "play damage absorption sound"
              },
              {
                "action": "show blocked damage numbers"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ProtectionRing : MonoBehaviour\n{\n    [System.Serializable]\n    public class ProtectionEvent : UnityEvent<float> { }\n    \n    [Header(\"Protection Settings\")]\n    [SerializeField] private float _protectionAmount = 50f;\n    [SerializeField] private float _protectionDuration = 10f;\n    [SerializeField] private bool _isTemporary = true;\n    [SerializeField] private bool _canStackProtection = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _protectionEffect;\n    [SerializeField] private ParticleSystem _pickupParticles;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private Color _protectionColor = Color.blue;\n    \n    [Header(\"Ring Behavior\")]\n    [SerializeField] private bool _rotateRing = true;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private bool _floatUpDown = true;\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public ProtectionEvent OnProtectionGranted;\n    public UnityEvent OnRingCollected;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    private bool _isCollected = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n            _collider.isTrigger = true;\n            \n        if (_renderer != null && _renderer.material != null)\n        {\n            _renderer.material.color = _protectionColor;\n            _renderer.material.SetFloat(\"_Metallic\", 0.8f);\n            _renderer.material.SetFloat(\"_Smoothness\", 0.9f);\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        if (_rotateRing)\n        {\n            transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        }\n        \n        if (_floatUpDown)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            GrantProtection(other.gameObject);\n            CollectRing();\n        }\n    }\n    \n    private void GrantProtection(GameObject player)\n    {\n        PlayerProtection protection = player.GetComponent<PlayerProtection>();\n        if (protection == null)\n        {\n            protection = player.AddComponent<PlayerProtection>();\n        }\n        \n        if (_canStackProtection || !protection.HasProtection())\n        {\n            protection.AddProtection(_protectionAmount, _protectionDuration, _isTemporary);\n            OnProtectionGranted?.Invoke(_protectionAmount);\n            \n            if (_protectionEffect != null)\n            {\n                GameObject effect = Instantiate(_protectionEffect, player.transform);\n                effect.transform.localPosition = Vector3.zero;\n                \n                if (_isTemporary)\n                {\n                    Destroy(effect, _protectionDuration);\n                }\n            }\n        }\n    }\n    \n    private void CollectRing()\n    {\n        _isCollected = true;\n        \n        if (_pickupParticles != null)\n        {\n            _pickupParticles.Play();\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        OnRingCollected?.Invoke();\n        \n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        if (_collider != null)\n            _collider.enabled = false;\n            \n        Destroy(gameObject, 2f);\n    }\n    \n    public void SetProtectionAmount(float amount)\n    {\n        _protectionAmount = amount;\n    }\n    \n    public void SetProtectionDuration(float duration)\n    {\n        _protectionDuration = duration;\n    }\n    \n    public float GetProtectionAmount()\n    {\n        return _protectionAmount;\n    }\n    \n    public float GetProtectionDuration()\n    {\n        return _protectionDuration;\n    }\n}\n\npublic class PlayerProtection : MonoBehaviour\n{\n    private float _currentProtection = 0f;\n    private float _protectionTimer = 0f;\n    private bool _hasTemporaryProtection = false;\n    private Renderer _playerRenderer;\n    private Color _originalColor;\n    private Material _originalMaterial;\n    \n    private void Start()\n    {\n        _playerRenderer = GetComponent<Renderer>();\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            _originalMaterial = _playerRenderer.material;\n            _originalColor = _originalMaterial.color;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasTemporaryProtection && _protectionTimer > 0f)\n        {\n            _protectionTimer -= Time.deltaTime;\n            \n            if (_protectionTimer <= 0f)\n            {\n                RemoveProtection();\n            }\n            else\n            {\n                UpdateProtectionVisual();\n            }\n        }\n    }\n    \n    public void AddProtection(float amount, float duration, bool isTemporary)\n    {\n        _currentProtection += amount;\n        \n        if (isTemporary)\n        {\n            _hasTemporaryProtection = true;\n            _protectionTimer = duration;\n        }\n        \n        ApplyProtectionVisual();\n    }\n    \n    public bool HasProtection()\n    {\n        return _currentProtection > 0f;\n    }\n    \n    public float GetProtection()\n    {\n        return _currentProtection;\n    }\n    \n    public bool TakeDamage(float damage)\n    {\n        if (_currentProtection > 0f)\n        {\n            _currentProtection -= damage;\n            \n            if (_currentProtection <= 0f)\n            {\n                _currentProtection = 0f;\n                RemoveProtection();\n            }\n            \n            return true;\n        }\n        \n        return false;\n    }\n    \n    private void ApplyProtectionVisual()\n    {\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            _playerRenderer.material.color = Color.Lerp(_originalColor, Color.blue, 0.3f);\n            _playerRenderer.material.SetFloat(\"_Metallic\", 0.5f);\n        }\n    }\n    \n    private void UpdateProtectionVisual()\n    {\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            float alpha = Mathf.PingPong(Time.time * 3f, 1f);\n            Color protectionColor = Color.Lerp(_originalColor, Color.blue, 0.3f * alpha);\n            _playerRenderer.material.color = protectionColor;\n        }\n    }\n    \n    private void RemoveProtection()\n    {\n        _hasTemporaryProtection = false;\n        _protectionTimer = 0f;\n        \n        if (_playerRenderer != null && _originalMaterial != null)\n        {\n            _playerRenderer.material.color = _originalColor;\n            _playerRenderer.material.SetFloat(\"_Metallic\", _originalMaterial.GetFloat(\"_Metallic\"));\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "slime that splits when killed",
      "ideal_ir": {
        "class_name": "SplittingSlime",
        "components": [
          "Rigidbody2D",
          "Collider2D",
          "SpriteRenderer"
        ],
        "fields": [
          {
            "name": "health",
            "type": "int",
            "default": 1
          },
          {
            "name": "splitCount",
            "type": "int",
            "default": 2
          },
          {
            "name": "childScale",
            "type": "float",
            "default": 0.7
          },
          {
            "name": "splitForce",
            "type": "float",
            "default": 5
          },
          {
            "name": "minSplitSize",
            "type": "float",
            "default": 0.3
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when hit by player attack or projectile",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "flash red briefly to indicate damage"
              }
            ]
          },
          {
            "name": "split_on_death",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "check if current scale is larger than minimum split size"
              },
              {
                "action": "create specified number of smaller slime copies at current position"
              },
              {
                "action": "set each new slime scale to current scale multiplied by child scale factor"
              },
              {
                "action": "apply random outward force to each new slime"
              },
              {
                "action": "destroy current slime object"
              }
            ]
          },
          {
            "name": "prevent_tiny_splits",
            "trigger": "when scale would be smaller than minimum split size",
            "actions": [
              {
                "action": "simply destroy slime without creating new copies"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SplittingSlime : MonoBehaviour\n{\n    [Header(\"Slime Properties\")]\n    [SerializeField] private int _health = 3;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _jumpForce = 5f;\n    [SerializeField] private float _jumpInterval = 2f;\n    \n    [Header(\"Splitting Behavior\")]\n    [SerializeField] private int _maxSplitGenerations = 3;\n    [SerializeField] private int _currentGeneration = 0;\n    [SerializeField] private int _splitCount = 2;\n    [SerializeField] private float _splitForce = 3f;\n    [SerializeField] private float _childSizeMultiplier = 0.7f;\n    [SerializeField] private float _childHealthMultiplier = 0.5f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Components\")]\n    [SerializeField] private GameObject _slimePrefab;\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioClip _splitSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSlimeDeath;\n    public UnityEvent OnSlimeSplit;\n    \n    private Rigidbody2D _rigidbody;\n    private SpriteRenderer _spriteRenderer;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private float _nextJumpTime;\n    private bool _isDead = false;\n    private Vector2 _moveDirection;\n    private float _directionChangeTime;\n    private float _nextDirectionChange;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody2D>();\n            _rigidbody.freezeRotation = true;\n        }\n        \n        if (_spriteRenderer == null)\n        {\n            _spriteRenderer = gameObject.AddComponent<SpriteRenderer>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Start()\n    {\n        _nextJumpTime = Time.time + _jumpInterval;\n        _nextDirectionChange = Time.time + Random.Range(1f, 3f);\n        _moveDirection = Random.insideUnitCircle.normalized;\n        \n        AdjustSizeForGeneration();\n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        FindPlayer();\n        HandleMovement();\n        HandleJumping();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (Time.time >= _nextDirectionChange)\n        {\n            if (_player != null && Vector2.Distance(transform.position, _player.position) <= _detectionRange)\n            {\n                _moveDirection = (_player.position - transform.position).normalized;\n            }\n            else\n            {\n                _moveDirection = Random.insideUnitCircle.normalized;\n            }\n            \n            _nextDirectionChange = Time.time + Random.Range(1f, 3f);\n        }\n        \n        _rigidbody.velocity = new Vector2(_moveDirection.x * _moveSpeed, _rigidbody.velocity.y);\n        \n        if (_moveDirection.x > 0)\n            _spriteRenderer.flipX = false;\n        else if (_moveDirection.x < 0)\n            _spriteRenderer.flipX = true;\n    }\n    \n    private void HandleJumping()\n    {\n        if (Time.time >= _nextJumpTime && IsGrounded())\n        {\n            _rigidbody.AddForce(Vector2.up * _jumpForce, ForceMode2D.Impulse);\n            _nextJumpTime = Time.time + _jumpInterval + Random.Range(-0.5f, 0.5f);\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        RaycastHit2D hit = Physics2D.Raycast(transform.position, Vector2.down, 0.6f);\n        return hit.collider != null && !hit.collider.isTrigger;\n    }\n    \n    private void AdjustSizeForGeneration()\n    {\n        float sizeMultiplier = Mathf.Pow(_childSizeMultiplier, _currentGeneration);\n        transform.localScale = Vector3.one * sizeMultiplier;\n        \n        _health = Mathf.Max(1, Mathf.RoundToInt(_health * Mathf.Pow(_childHealthMultiplier, _currentGeneration)));\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDead) return;\n        \n        _health -= damage;\n        \n        if (_spriteRenderer != null)\n        {\n            StartCoroutine(FlashRed());\n        }\n        \n        if (_health <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashRed()\n    {\n        Color originalColor = _spriteRenderer.color;\n        _spriteRenderer.color = Color.red;\n        yield return new WaitForSeconds(0.1f);\n        _spriteRenderer.color = originalColor;\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        \n        if (_currentGeneration < _maxSplitGenerations)\n        {\n            Split();\n        }\n        else\n        {\n            CompleteDeath();\n        }\n    }\n    \n    private void Split()\n    {\n        OnSlimeSplit?.Invoke();\n        \n        if (_splitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_splitSound);\n        }\n        \n        if (_slimePrefab != null)\n        {\n            for (int i = 0; i < _splitCount; i++)\n            {\n                Vector3 spawnPosition = transform.position + (Vector3)(Random.insideUnitCircle * 0.5f);\n                GameObject newSlime = Instantiate(_slimePrefab, spawnPosition, Quaternion.identity);\n                \n                SplittingSlime slimeScript = newSlime.GetComponent<SplittingSlime>();\n                if (slimeScript != null)\n                {\n                    slimeScript._currentGeneration = _currentGeneration + 1;\n                    slimeScript.AdjustSizeForGeneration();\n                    \n                    Rigidbody2D newRb = newSlime.GetComponent<Rigidbody2D>();\n                    if (newRb != null)\n                    {\n                        Vector2 splitDirection = Random.insideUnitCircle.normalized;\n                        newRb.AddForce(splitDirection * _splitForce, ForceMode2D.Impulse);\n                    }\n                }\n            }\n        }\n        \n        CompleteDeath();\n    }\n    \n    private void CompleteDeath()\n    {\n        OnSlimeDeath?.Invoke();\n        \n        if (_deathSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_deathEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_deathEffect, transform.position, Quaternion.identity);\n            Destroy(effect.gameObject, 2f);\n        }\n        \n        if (_audioSource != null && (_deathSound != null || _splitSound != null))\n        {\n            Destroy(gameObject, 1f);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            TakeDamage(_health);\n        }\n    }\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            TakeDamage(_health);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, Vector2.down * 0.6f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ghost that phases through walls",
      "ideal_ir": {
        "class_name": "PhasingGhost",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "phaseSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "wanderRadius",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "phaseOpacity",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "continuous_phasing",
            "trigger": "always active",
            "actions": [
              {
                "action": "disable collision with walls and solid objects"
              },
              {
                "action": "set material transparency to phase opacity level"
              }
            ]
          },
          {
            "name": "ethereal_movement",
            "trigger": "every frame",
            "actions": [
              {
                "action": "float smoothly through the air"
              },
              {
                "action": "ignore gravity effects"
              },
              {
                "action": "move in random wandering pattern within wander radius"
              }
            ]
          },
          {
            "name": "ghostly_appearance",
            "trigger": "when spawned",
            "actions": [
              {
                "action": "make renderer semi-transparent"
              },
              {
                "action": "add subtle floating animation"
              },
              {
                "action": "emit faint ethereal glow effect"
              }
            ]
          },
          {
            "name": "wall_traversal",
            "trigger": "when encountering any solid surface",
            "actions": [
              {
                "action": "continue moving through the obstacle unimpeded"
              },
              {
                "action": "maintain current movement direction and speed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class GhostController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _phaseSpeed = 5f;\n    [SerializeField] private float _rotationSpeed = 2f;\n    \n    [Header(\"AI Behavior\")]\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private float _wanderRadius = 10f;\n    [SerializeField] private float _wanderTimer = 3f;\n    [SerializeField] private LayerMask _wallLayers = -1;\n    \n    [Header(\"Phasing\")]\n    [SerializeField] private float _phaseTransparency = 0.3f;\n    [SerializeField] private float _normalTransparency = 0.7f;\n    [SerializeField] private float _fadeSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _ghostSound;\n    [SerializeField] private float _soundInterval = 2f;\n    \n    private Vector3 _targetPosition;\n    private Vector3 _wanderTarget;\n    private float _wanderTimer_current;\n    private float _soundTimer;\n    private bool _isPhasing;\n    private bool _chasingPlayer;\n    \n    private Transform _playerTransform;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _ghostMaterial;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.freezeRotation = true;\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n        \n        if (_renderer != null)\n        {\n            _ghostMaterial = _renderer.material;\n            SetTransparency(_normalTransparency);\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _ghostSound;\n        _audioSource.loop = false;\n        _audioSource.spatialBlend = 1f;\n        \n        _wanderTimer_current = _wanderTimer;\n        SetNewWanderTarget();\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        HandleMovement();\n        HandlePhasing();\n        HandleAudio();\n        UpdateTransparency();\n    }\n    \n    private void DetectPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        \n        if (player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                _playerTransform = player.transform;\n                _chasingPlayer = true;\n                _targetPosition = _playerTransform.position;\n            }\n            else\n            {\n                _chasingPlayer = false;\n                _playerTransform = null;\n            }\n        }\n        else\n        {\n            _chasingPlayer = false;\n            _playerTransform = null;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_chasingPlayer && _playerTransform != null)\n        {\n            _targetPosition = _playerTransform.position;\n            MoveTowardsTarget(_phaseSpeed);\n        }\n        else\n        {\n            HandleWandering();\n        }\n        \n        RotateTowardsTarget();\n    }\n    \n    private void HandleWandering()\n    {\n        _wanderTimer_current -= Time.deltaTime;\n        \n        if (_wanderTimer_current <= 0f || Vector3.Distance(transform.position, _wanderTarget) < 1f)\n        {\n            SetNewWanderTarget();\n            _wanderTimer_current = _wanderTimer;\n        }\n        \n        _targetPosition = _wanderTarget;\n        MoveTowardsTarget(_moveSpeed);\n    }\n    \n    private void SetNewWanderTarget()\n    {\n        Vector3 randomDirection = Random.insideUnitSphere * _wanderRadius;\n        randomDirection += transform.position;\n        randomDirection.y = transform.position.y;\n        _wanderTarget = randomDirection;\n    }\n    \n    private void MoveTowardsTarget(float speed)\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        _rigidbody.velocity = direction * speed;\n    }\n    \n    private void RotateTowardsTarget()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandlePhasing()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        RaycastHit hit;\n        \n        bool wallInPath = Physics.Raycast(transform.position, direction, out hit, 2f, _wallLayers);\n        \n        if (wallInPath || _chasingPlayer)\n        {\n            if (!_isPhasing)\n            {\n                StartPhasing();\n            }\n        }\n        else\n        {\n            if (_isPhasing)\n            {\n                StopPhasing();\n            }\n        }\n    }\n    \n    private void StartPhasing()\n    {\n        _isPhasing = true;\n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void StopPhasing()\n    {\n        _isPhasing = false;\n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void UpdateTransparency()\n    {\n        if (_ghostMaterial == null) return;\n        \n        float targetAlpha = _isPhasing ? _phaseTransparency : _normalTransparency;\n        Color currentColor = _ghostMaterial.color;\n        currentColor.a = Mathf.Lerp(currentColor.a, targetAlpha, _fadeSpeed * Time.deltaTime);\n        _ghostMaterial.color = currentColor;\n    }\n    \n    private void SetTransparency(float alpha)\n    {\n        if (_ghostMaterial == null) return;\n        \n        Color color = _ghostMaterial.color;\n        color.a = alpha;\n        _ghostMaterial.color = color;\n        \n        if (_ghostMaterial.HasProperty(\"_Mode\"))\n        {\n            _ghostMaterial.SetFloat(\"_Mode\", 3);\n            _ghostMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            _ghostMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            _ghostMaterial.SetInt(\"_ZWrite\", 0);\n            _ghostMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            _ghostMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            _ghostMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            _ghostMaterial.renderQueue = 3000;\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        _soundTimer -= Time.deltaTime;\n        \n        if (_soundTimer <= 0f && _ghostSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_ghostSound);\n            _soundTimer = _soundInterval;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Debug.Log(\"Ghost touched player!\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _wanderRadius);\n        \n        if (_chasingPlayer && _playerTransform != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _playerTransform.position);\n        }\n        else\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _wanderTarget);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "skeleton that reassembles after death",
      "ideal_ir": {
        "class_name": "ReassemblingSkeleton",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "reassemblyTime",
            "type": "float",
            "default": 5
          },
          {
            "name": "scatterForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "isReassembling",
            "type": "bool",
            "default": false
          },
          {
            "name": "isDead",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when receiving damage",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt animation"
              }
            ]
          },
          {
            "name": "death_sequence",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "set isDead to true"
              },
              {
                "action": "play death animation"
              },
              {
                "action": "scatter bone pieces in random directions with force"
              },
              {
                "action": "disable main collider"
              },
              {
                "action": "start reassembly timer"
              }
            ]
          },
          {
            "name": "begin_reassembly",
            "trigger": "when reassembly timer expires and skeleton is dead",
            "actions": [
              {
                "action": "set isReassembling to true"
              },
              {
                "action": "play bone gathering sound effect"
              },
              {
                "action": "create magical particle effects around scattered bones"
              }
            ]
          },
          {
            "name": "reassemble_bones",
            "trigger": "when reassembly process is active",
            "actions": [
              {
                "action": "move scattered bone pieces back toward original positions"
              },
              {
                "action": "rotate bones to correct orientations"
              },
              {
                "action": "play reassembly sound effects"
              }
            ]
          },
          {
            "name": "complete_resurrection",
            "trigger": "when all bones have returned to original positions",
            "actions": [
              {
                "action": "restore full health"
              },
              {
                "action": "set isDead to false"
              },
              {
                "action": "set isReassembling to false"
              },
              {
                "action": "enable main collider"
              },
              {
                "action": "play resurrection animation"
              },
              {
                "action": "create resurrection particle burst"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class SkeletonReassembly : MonoBehaviour\n{\n    [Header(\"Skeleton Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _reassemblyTime = 5f;\n    [SerializeField] private int _maxReassemblies = 3;\n    [SerializeField] private float _reassemblyRadius = 2f;\n    \n    [Header(\"Bone Parts\")]\n    [SerializeField] private Transform[] _boneParts;\n    [SerializeField] private Rigidbody[] _boneRigidbodies;\n    [SerializeField] private Collider _mainCollider;\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private ParticleSystem _reassemblyEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _deathSound;\n    [SerializeField] private AudioClip _reassemblySound;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    private float _currentHealth;\n    private int _reassemblyCount = 0;\n    private bool _isDead = false;\n    private bool _isReassembling = false;\n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private Transform _player;\n    private Vector3[] _originalBonePositions;\n    private Quaternion[] _originalBoneRotations;\n    \n    private enum SkeletonState\n    {\n        Alive,\n        Dead,\n        Reassembling\n    }\n    \n    private SkeletonState _currentState = SkeletonState.Alive;\n    \n    void Start()\n    {\n        _currentHealth = _health;\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n        \n        if (_mainCollider == null)\n            _mainCollider = GetComponent<Collider>();\n        \n        StoreBonePositions();\n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        switch (_currentState)\n        {\n            case SkeletonState.Alive:\n                HandleAliveState();\n                break;\n            case SkeletonState.Dead:\n                HandleDeadState();\n                break;\n            case SkeletonState.Reassembling:\n                break;\n        }\n    }\n    \n    void HandleAliveState()\n    {\n        if (_player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                Vector3 direction = (_player.position - transform.position).normalized;\n                transform.position += direction * _moveSpeed * Time.deltaTime;\n                transform.LookAt(_player);\n                \n                if (_animator != null)\n                    _animator.SetBool(\"IsWalking\", true);\n            }\n            else\n            {\n                if (_animator != null)\n                    _animator.SetBool(\"IsWalking\", false);\n            }\n        }\n    }\n    \n    void HandleDeadState()\n    {\n        if (!_isReassembling && _reassemblyCount < _maxReassemblies)\n        {\n            StartCoroutine(ReassembleCoroutine());\n        }\n    }\n    \n    void StoreBonePositions()\n    {\n        if (_boneParts != null && _boneParts.Length > 0)\n        {\n            _originalBonePositions = new Vector3[_boneParts.Length];\n            _originalBoneRotations = new Quaternion[_boneParts.Length];\n            \n            for (int i = 0; i < _boneParts.Length; i++)\n            {\n                if (_boneParts[i] != null)\n                {\n                    _originalBonePositions[i] = _boneParts[i].localPosition;\n                    _originalBoneRotations[i] = _boneParts[i].localRotation;\n                }\n            }\n        }\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n            _player = playerObject.transform;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_currentState != SkeletonState.Alive) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        _currentState = SkeletonState.Dead;\n        _isDead = true;\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsWalking\", false);\n            _animator.SetTrigger(\"Die\");\n        }\n        \n        if (_mainCollider != null)\n            _mainCollider.enabled = false;\n        \n        ScatterBones();\n        \n        if (_deathEffect != null)\n            _deathEffect.Play();\n        \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n    }\n    \n    void ScatterBones()\n    {\n        if (_boneParts == null || _boneRigidbodies == null) return;\n        \n        for (int i = 0; i < _boneParts.Length && i < _boneRigidbodies.Length; i++)\n        {\n            if (_boneParts[i] != null && _boneRigidbodies[i] != null)\n            {\n                _boneRigidbodies[i].isKinematic = false;\n                _boneRigidbodies[i].useGravity = true;\n                \n                Vector3 randomForce = new Vector3(\n                    Random.Range(-5f, 5f),\n                    Random.Range(2f, 8f),\n                    Random.Range(-5f, 5f)\n                );\n                \n                _boneRigidbodies[i].AddForce(randomForce, ForceMode.Impulse);\n                _boneRigidbodies[i].AddTorque(Random.insideUnitSphere * 10f, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    IEnumerator ReassembleCoroutine()\n    {\n        _isReassembling = true;\n        _currentState = SkeletonState.Reassembling;\n        \n        yield return new WaitForSeconds(_reassemblyTime);\n        \n        if (_reassemblyEffect != null)\n            _reassemblyEffect.Play();\n        \n        if (_audioSource != null && _reassemblySound != null)\n            _audioSource.PlayOneShot(_reassemblySound);\n        \n        yield return StartCoroutine(GatherBones());\n        \n        _currentHealth = _health;\n        _isDead = false;\n        _isReassembling = false;\n        _reassemblyCount++;\n        _currentState = SkeletonState.Alive;\n        \n        if (_mainCollider != null)\n            _mainCollider.enabled = true;\n        \n        if (_animator != null)\n            _animator.SetTrigger(\"Reassemble\");\n        \n        transform.position = _originalPosition;\n        transform.rotation = _originalRotation;\n    }\n    \n    IEnumerator GatherBones()\n    {\n        float gatherTime = 2f;\n        float elapsed = 0f;\n        \n        if (_boneParts == null || _boneRigidbodies == null) yield break;\n        \n        Vector3[] startPositions = new Vector3[_boneParts.Length];\n        Quaternion[] startRotations = new Quaternion[_boneParts.Length];\n        \n        for (int i = 0; i < _boneParts.Length; i++)\n        {\n            if (_boneParts[i] != null && _boneRigidbodies[i] != null)\n            {\n                _boneRigidbodies[i].isKinematic = true;\n                _boneRigidbodies[i].useGravity = false;\n                startPositions[i] = _boneParts[i].position;\n                startRotations[i] = _boneParts[i].rotation;\n            }\n        }\n        \n        while (elapsed < gatherTime)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / gatherTime;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            for (int i = 0; i < _boneParts.Length; i++)\n            {\n                if (_boneParts[i] != null)\n                {\n                    Vector3 targetWorldPos = transform.TransformPoint(_originalBonePositions[i]);\n                    Quaternion targetWorldRot = transform.rotation * _originalBoneRotations[i];\n                    \n                    _boneParts[i].position = Vector3.Lerp(startPositions[i], targetWorldPos, t);\n                    _boneParts[i].rotation = Quaternion.Lerp(startRotations[i], targetWorldRot, t);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        for (int i = 0; i < _boneParts.Length; i++)\n        {\n            if (_boneParts[i] != null)\n            {\n                _boneParts[i].localPosition = _originalBonePositions[i];\n                _boneParts[i].localRotation = _originalBoneRotations[i];\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_currentState != SkeletonState.Alive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            TakeDamage(25f);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _reassemblyRadius);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "bat that hangs from ceiling",
      "ideal_ir": {
        "class_name": "HangingBat",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "flySpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "hangingPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "isHanging",
            "type": "bool",
            "default": true
          },
          {
            "name": "flightDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "returnDelay",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_approach",
            "trigger": "when player enters detection range while bat is hanging",
            "actions": [
              {
                "action": "play wing flapping sound"
              },
              {
                "action": "set hanging state to false"
              },
              {
                "action": "start flying away from player"
              }
            ]
          },
          {
            "name": "fly_erratically",
            "trigger": "when bat is not hanging",
            "actions": [
              {
                "action": "move in random zigzag pattern"
              },
              {
                "action": "maintain flight speed"
              },
              {
                "action": "avoid walls and obstacles"
              }
            ]
          },
          {
            "name": "return_to_hanging",
            "trigger": "when flight duration timer expires",
            "actions": [
              {
                "action": "fly back toward original hanging position"
              },
              {
                "action": "slow down as approaching ceiling"
              },
              {
                "action": "attach to ceiling at hanging position"
              },
              {
                "action": "set hanging state to true"
              }
            ]
          },
          {
            "name": "idle_hanging",
            "trigger": "when bat is hanging and no player nearby",
            "actions": [
              {
                "action": "remain motionless"
              },
              {
                "action": "occasionally make small squeaking sounds"
              },
              {
                "action": "sway slightly as if breathing"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class HangingBat : MonoBehaviour\n{\n    [Header(\"Hanging Behavior\")]\n    [SerializeField] private float _hangHeight = 2f;\n    [SerializeField] private float _swayAmount = 0.5f;\n    [SerializeField] private float _swaySpeed = 1f;\n    [SerializeField] private bool _startHanging = true;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Flight Behavior\")]\n    [SerializeField] private float _flightSpeed = 8f;\n    [SerializeField] private float _flightHeight = 3f;\n    [SerializeField] private float _flightDuration = 5f;\n    [SerializeField] private float _returnDelay = 3f;\n    [SerializeField] private AnimationCurve _flightCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _wingFlapSpeed = 10f;\n    [SerializeField] private float _hangingRotationSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _flutterSound;\n    [SerializeField] private AudioClip _squeakSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _hangingPosition;\n    private bool _isHanging = true;\n    private bool _isFlying = false;\n    private bool _isReturning = false;\n    private float _swayTimer = 0f;\n    private float _flightTimer = 0f;\n    private Vector3 _flightStartPosition;\n    private Vector3 _flightTargetPosition;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _animator = GetComponent<Animator>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.useGravity = false;\n            _rigidbody.isKinematic = true;\n        }\n    }\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _hangingPosition = _originalPosition;\n        \n        if (_startHanging)\n        {\n            SetHangingState(true);\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _swayTimer = Random.Range(0f, Mathf.PI * 2f);\n    }\n    \n    private void Update()\n    {\n        if (_isHanging)\n        {\n            UpdateHangingBehavior();\n            CheckForPlayer();\n        }\n        else if (_isFlying)\n        {\n            UpdateFlightBehavior();\n        }\n        else if (_isReturning)\n        {\n            UpdateReturnBehavior();\n        }\n        \n        UpdateAnimations();\n    }\n    \n    private void UpdateHangingBehavior()\n    {\n        _swayTimer += Time.deltaTime * _swaySpeed;\n        \n        Vector3 swayOffset = new Vector3(\n            Mathf.Sin(_swayTimer) * _swayAmount,\n            0f,\n            Mathf.Cos(_swayTimer * 0.7f) * _swayAmount * 0.5f\n        );\n        \n        transform.position = _hangingPosition + swayOffset;\n        \n        float rotationZ = Mathf.Sin(_swayTimer) * 15f;\n        transform.rotation = Quaternion.Euler(180f, 0f, rotationZ);\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(_playerTag))\n            {\n                StartFlight();\n                break;\n            }\n        }\n    }\n    \n    private void StartFlight()\n    {\n        if (_isFlying || _isReturning) return;\n        \n        _isHanging = false;\n        _isFlying = true;\n        _flightTimer = 0f;\n        \n        _flightStartPosition = transform.position;\n        _flightTargetPosition = _originalPosition + Vector3.up * _flightHeight + \n                               new Vector3(Random.Range(-3f, 3f), 0f, Random.Range(-3f, 3f));\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = false;\n        }\n        \n        PlaySound(_flutterSound);\n        \n        if (Random.value < 0.3f)\n        {\n            PlaySound(_squeakSound);\n        }\n    }\n    \n    private void UpdateFlightBehavior()\n    {\n        _flightTimer += Time.deltaTime;\n        float progress = _flightTimer / _flightDuration;\n        \n        if (progress >= 1f)\n        {\n            StartCoroutine(ReturnToHanging());\n            return;\n        }\n        \n        float curveValue = _flightCurve.Evaluate(progress);\n        Vector3 currentTarget = Vector3.Lerp(_flightStartPosition, _flightTargetPosition, curveValue);\n        \n        Vector3 flutterOffset = new Vector3(\n            Mathf.Sin(Time.time * _wingFlapSpeed) * 0.2f,\n            Mathf.Cos(Time.time * _wingFlapSpeed * 1.3f) * 0.1f,\n            Mathf.Sin(Time.time * _wingFlapSpeed * 0.8f) * 0.15f\n        );\n        \n        transform.position = currentTarget + flutterOffset;\n        \n        Vector3 direction = (_flightTargetPosition - _flightStartPosition).normalized;\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 3f);\n        }\n    }\n    \n    private IEnumerator ReturnToHanging()\n    {\n        _isFlying = false;\n        _isReturning = true;\n        \n        yield return new WaitForSeconds(_returnDelay);\n        \n        float returnDuration = 2f;\n        float returnTimer = 0f;\n        Vector3 returnStartPosition = transform.position;\n        \n        while (returnTimer < returnDuration)\n        {\n            returnTimer += Time.deltaTime;\n            float progress = returnTimer / returnDuration;\n            \n            transform.position = Vector3.Lerp(returnStartPosition, _hangingPosition, progress);\n            \n            Quaternion targetRotation = Quaternion.Euler(180f, 0f, 0f);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, progress);\n            \n            yield return null;\n        }\n        \n        SetHangingState(true);\n    }\n    \n    private void UpdateReturnBehavior()\n    {\n        // Handled in coroutine\n    }\n    \n    private void SetHangingState(bool hanging)\n    {\n        _isHanging = hanging;\n        _isFlying = false;\n        _isReturning = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = hanging;\n            _rigidbody.useGravity = false;\n        }\n        \n        if (hanging)\n        {\n            transform.position = _hangingPosition;\n            transform.rotation = Quaternion.Euler(180f, 0f, 0f);\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsHanging\", _isHanging);\n            _animator.SetBool(\"IsFlying\", _isFlying);\n            _animator.SetFloat(\"WingFlapSpeed\", _isFlying ? _wingFlapSpeed : 0f);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Vector3 hangPos = Application.isPlaying ? _hangingPosition : transform.position;\n        Gizmos.DrawLine(hangPos, hangPos + Vector3.up * _hangHeight);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(hangPos + Vector3.up * _flightHeight, Vector3.one * 0.5f);\n    }\n    \n    public void ForceStartFlight()\n    {\n        if (_isHanging)\n        {\n            StartFlight();\n        }\n    }\n    \n    public void ForceReturnToHanging()\n    {\n        StopAllCoroutines();\n        SetHangingState(true);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "spider that drops from above",
      "ideal_ir": {
        "class_name": "DroppingSpider",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "dropHeight",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "dropSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "climbSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "waitTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isDropping",
            "type": "bool",
            "default": false
          },
          {
            "name": "isWaiting",
            "type": "bool",
            "default": false
          },
          {
            "name": "originalHeight",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_below",
            "trigger": "when player enters detection range directly below spider",
            "actions": [
              {
                "action": "store current height as original height"
              },
              {
                "action": "set dropping state to true"
              },
              {
                "action": "play dropping animation"
              }
            ]
          },
          {
            "name": "drop_down",
            "trigger": "when spider is in dropping state",
            "actions": [
              {
                "action": "move downward at drop speed"
              },
              {
                "action": "disable gravity temporarily"
              }
            ]
          },
          {
            "name": "land_on_ground",
            "trigger": "when spider touches ground while dropping",
            "actions": [
              {
                "action": "set dropping state to false"
              },
              {
                "action": "set waiting state to true"
              },
              {
                "action": "play landing animation"
              },
              {
                "action": "enable gravity"
              }
            ]
          },
          {
            "name": "wait_after_landing",
            "trigger": "when spider is in waiting state",
            "actions": [
              {
                "action": "remain stationary for wait time duration"
              },
              {
                "action": "play idle animation"
              }
            ]
          },
          {
            "name": "climb_back_up",
            "trigger": "when wait time has elapsed",
            "actions": [
              {
                "action": "set waiting state to false"
              },
              {
                "action": "move upward at climb speed toward original height"
              },
              {
                "action": "play climbing animation"
              },
              {
                "action": "disable gravity"
              }
            ]
          },
          {
            "name": "reach_original_position",
            "trigger": "when spider reaches original height",
            "actions": [
              {
                "action": "stop upward movement"
              },
              {
                "action": "play hanging animation"
              },
              {
                "action": "reset to initial state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpiderDrop : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private float _detectionHeight = 10f;\n    \n    [Header(\"Drop Behavior\")]\n    [SerializeField] private float _dropSpeed = 8f;\n    [SerializeField] private float _dropDelay = 0.5f;\n    [SerializeField] private float _maxDropDistance = 15f;\n    [SerializeField] private bool _returnToStart = true;\n    [SerializeField] private float _returnSpeed = 3f;\n    [SerializeField] private float _returnDelay = 2f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _dropSound;\n    [SerializeField] private AudioClip _landSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDropStart;\n    public UnityEvent OnLanded;\n    public UnityEvent OnReturnComplete;\n    \n    private enum SpiderState\n    {\n        Waiting,\n        Dropping,\n        OnGround,\n        Returning\n    }\n    \n    private SpiderState _currentState = SpiderState.Waiting;\n    private Vector3 _startPosition;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Transform _playerTransform;\n    private float _dropTimer;\n    private float _returnTimer;\n    private bool _hasDropped;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        switch (_currentState)\n        {\n            case SpiderState.Waiting:\n                HandleWaitingState();\n                break;\n            case SpiderState.Dropping:\n                HandleDroppingState();\n                break;\n            case SpiderState.OnGround:\n                HandleGroundState();\n                break;\n            case SpiderState.Returning:\n                HandleReturningState();\n                break;\n        }\n    }\n    \n    private void HandleWaitingState()\n    {\n        if (_hasDropped && !_returnToStart)\n            return;\n            \n        DetectPlayer();\n        \n        if (_playerTransform != null && _dropTimer > 0f)\n        {\n            _dropTimer -= Time.deltaTime;\n            if (_dropTimer <= 0f)\n            {\n                StartDrop();\n            }\n        }\n    }\n    \n    private void HandleDroppingState()\n    {\n        if (IsGrounded() || HasDroppedMaxDistance())\n        {\n            Land();\n        }\n    }\n    \n    private void HandleGroundState()\n    {\n        if (_returnToStart)\n        {\n            _returnTimer -= Time.deltaTime;\n            if (_returnTimer <= 0f)\n            {\n                StartReturn();\n            }\n        }\n    }\n    \n    private void HandleReturningState()\n    {\n        Vector3 direction = (_startPosition - transform.position).normalized;\n        transform.position += direction * _returnSpeed * Time.deltaTime;\n        \n        if (Vector3.Distance(transform.position, _startPosition) < 0.1f)\n        {\n            transform.position = _startPosition;\n            _currentState = SpiderState.Waiting;\n            _hasDropped = false;\n            _rigidbody.isKinematic = true;\n            _rigidbody.useGravity = false;\n            OnReturnComplete?.Invoke();\n        }\n    }\n    \n    private void DetectPlayer()\n    {\n        Vector3 detectionCenter = transform.position;\n        detectionCenter.y -= _detectionHeight * 0.5f;\n        \n        Collider[] hits = Physics.OverlapCylinder(\n            detectionCenter - Vector3.up * _detectionHeight * 0.5f,\n            detectionCenter + Vector3.up * _detectionHeight * 0.5f,\n            _detectionRadius,\n            _playerLayer\n        );\n        \n        Transform closestPlayer = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider hit in hits)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestPlayer = hit.transform;\n                }\n            }\n        }\n        \n        if (closestPlayer != null && _playerTransform == null)\n        {\n            _playerTransform = closestPlayer;\n            _dropTimer = _dropDelay;\n        }\n        else if (closestPlayer == null)\n        {\n            _playerTransform = null;\n            _dropTimer = 0f;\n        }\n    }\n    \n    private void StartDrop()\n    {\n        _currentState = SpiderState.Dropping;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        _rigidbody.velocity = Vector3.down * _dropSpeed;\n        \n        PlaySound(_dropSound);\n        OnDropStart?.Invoke();\n    }\n    \n    private void Land()\n    {\n        _currentState = SpiderState.OnGround;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _returnTimer = _returnDelay;\n        _hasDropped = true;\n        _playerTransform = null;\n        \n        PlaySound(_landSound);\n        OnLanded?.Invoke();\n    }\n    \n    private void StartReturn()\n    {\n        _currentState = SpiderState.Returning;\n    }\n    \n    private bool IsGrounded()\n    {\n        return Physics.Raycast(transform.position, Vector3.down, _groundCheckDistance, _groundLayer);\n    }\n    \n    private bool HasDroppedMaxDistance()\n    {\n        return Vector3.Distance(transform.position, _startPosition) >= _maxDropDistance;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState == SpiderState.Dropping)\n        {\n            // Handle player collision during drop\n            Land();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = transform.position;\n        center.y -= _detectionHeight * 0.5f;\n        Gizmos.DrawWireCylinder(center, _detectionRadius, _detectionHeight);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, 0.2f);\n        \n        if (Application.isPlaying)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_startPosition, 0.3f);\n        }\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawRay(transform.position, Vector3.down * _groundCheckDistance);\n    }\n}\n\npublic static class PhysicsExtensions\n{\n    public static Collider[] OverlapCylinder(Vector3 point0, Vector3 point1, float radius, LayerMask layerMask)\n    {\n        // Simplified cylinder overlap using capsule\n        return Physics.OverlapCapsule(point0, point1, radius, layerMask);\n    }\n    \n    public static void DrawWireCylinder(this Gizmos gizmos, Vector3 center, float radius, float height)\n    {\n        Vector3 top = center + Vector3.up * height * 0.5f;\n        Vector3 bottom = center - Vector3.up * height * 0.5f;\n        \n        // Draw circles\n        DrawCircle(top, radius);\n        DrawCircle(bottom, radius);\n        \n        // Draw connecting lines\n        Gizmos.DrawLine(top + Vector3.forward * radius, bottom + Vector3.forward * radius);\n        Gizmos.DrawLine(top - Vector3.forward * radius, bottom - Vector3.forward * radius);\n        Gizmos.DrawLine(top + Vector3.right * radius, bottom + Vector3.right * radius);\n        Gizmos.DrawLine(top - Vector3.right * radius, bottom - Vector3.right * radius);\n    }\n    \n    private static void DrawCircle(Vector3 center, float radius)\n    {\n        int segments = 16;\n        float angleStep = 360f / segments;\n        Vector3 prevPoint = center + Vector3.forward * radius;\n        \n        for (int i = 1; i <= segments; i++)\n        {\n            float angle = i * angleStep * Mathf.Deg2Rad;\n            Vector3 newPoint = center + new Vector3(Mathf.Sin(angle), 0, Mathf.Cos(angle)) * radius;\n            Gizmos.DrawLine(prevPoint, newPoint);\n            prevPoint = newPoint;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "zombie that walks slowly toward player",
      "ideal_ir": {
        "class_name": "Zombie",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "walkingSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10.0
          }
        ],
        "behaviors": [
          {
            "name": "walk_toward_player",
            "trigger": "when player is within detection range",
            "actions": [
              {
                "action": "move slowly toward player position at walking speed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class ZombieController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _stopDistance = 1.5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _groanSounds;\n    [SerializeField] private float _groanInterval = 3f;\n    \n    private Transform _player;\n    private NavMeshAgent _navMeshAgent;\n    private Rigidbody _rigidbody;\n    private float _lastGroanTime;\n    private bool _hasNavMesh;\n    \n    void Start()\n    {\n        InitializeComponents();\n        FindPlayer();\n        _lastGroanTime = Time.time + Random.Range(0f, _groanInterval);\n    }\n    \n    void InitializeComponents()\n    {\n        _navMeshAgent = GetComponent<NavMeshAgent>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_navMeshAgent != null)\n        {\n            _hasNavMesh = true;\n            _navMeshAgent.speed = _moveSpeed;\n            _navMeshAgent.stoppingDistance = _stopDistance;\n            _navMeshAgent.angularSpeed = _rotationSpeed;\n        }\n        else if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n        \n        if (_animator == null)\n        {\n            _animator = GetComponent<Animator>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _detectionRange)\n        {\n            MoveTowardsPlayer(distanceToPlayer);\n            UpdateAnimation(true);\n        }\n        else\n        {\n            UpdateAnimation(false);\n        }\n        \n        PlayRandomGroan();\n    }\n    \n    void MoveTowardsPlayer(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _stopDistance)\n        {\n            return;\n        }\n        \n        if (_hasNavMesh && _navMeshAgent.enabled)\n        {\n            _navMeshAgent.SetDestination(_player.position);\n        }\n        else\n        {\n            MoveWithoutNavMesh();\n        }\n    }\n    \n    void MoveWithoutNavMesh()\n    {\n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0f;\n        \n        if (_rigidbody != null)\n        {\n            Vector3 movement = direction * _moveSpeed * Time.deltaTime;\n            _rigidbody.MovePosition(transform.position + movement);\n        }\n        else\n        {\n            transform.Translate(direction * _moveSpeed * Time.deltaTime, Space.World);\n        }\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void UpdateAnimation(bool isMoving)\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsWalking\", isMoving);\n            \n            if (_hasNavMesh && _navMeshAgent != null)\n            {\n                _animator.SetFloat(\"Speed\", _navMeshAgent.velocity.magnitude);\n            }\n            else\n            {\n                _animator.SetFloat(\"Speed\", isMoving ? _moveSpeed : 0f);\n            }\n        }\n    }\n    \n    void PlayRandomGroan()\n    {\n        if (_audioSource != null && _groanSounds != null && _groanSounds.Length > 0)\n        {\n            if (Time.time >= _lastGroanTime + _groanInterval)\n            {\n                AudioClip randomGroan = _groanSounds[Random.Range(0, _groanSounds.Length)];\n                _audioSource.PlayOneShot(randomGroan);\n                _lastGroanTime = Time.time;\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _stopDistance);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            if (_audioSource != null && _groanSounds != null && _groanSounds.Length > 0)\n            {\n                AudioClip randomGroan = _groanSounds[Random.Range(0, _groanSounds.Length)];\n                _audioSource.PlayOneShot(randomGroan);\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "wolf that attacks in packs",
      "ideal_ir": {
        "class_name": "PackWolf",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "packRadius",
            "type": "float",
            "default": 15
          },
          {
            "name": "attackRange",
            "type": "float",
            "default": 2
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 6
          },
          {
            "name": "health",
            "type": "int",
            "default": 40
          },
          {
            "name": "damage",
            "type": "int",
            "default": 15
          },
          {
            "name": "howlCooldown",
            "type": "float",
            "default": 8
          },
          {
            "name": "isAlpha",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "alert nearby pack members"
              },
              {
                "action": "play growl sound"
              },
              {
                "action": "enter aggressive state"
              }
            ]
          },
          {
            "name": "coordinate_pack_attack",
            "trigger": "when alpha wolf detects threat",
            "actions": [
              {
                "action": "howl to summon pack"
              },
              {
                "action": "broadcast attack target to nearby wolves"
              },
              {
                "action": "coordinate flanking positions"
              }
            ]
          },
          {
            "name": "respond_to_pack_call",
            "trigger": "when hearing alpha howl",
            "actions": [
              {
                "action": "move toward alpha wolf"
              },
              {
                "action": "adopt aggressive stance"
              },
              {
                "action": "focus on shared target"
              }
            ]
          },
          {
            "name": "circle_target",
            "trigger": "when in pack attack mode",
            "actions": [
              {
                "action": "move in circular pattern around target"
              },
              {
                "action": "maintain distance from other pack members"
              },
              {
                "action": "look for opening to attack"
              }
            ]
          },
          {
            "name": "coordinated_strike",
            "trigger": "when target is distracted by other wolves",
            "actions": [
              {
                "action": "lunge at target from behind or side"
              },
              {
                "action": "deal bite damage"
              },
              {
                "action": "retreat to safe distance"
              }
            ]
          },
          {
            "name": "pack_retreat",
            "trigger": "when pack leader is defeated or heavily damaged",
            "actions": [
              {
                "action": "whimper and back away"
              },
              {
                "action": "flee in different directions"
              },
              {
                "action": "regroup at distant location"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class PackWolf : MonoBehaviour\n{\n    [Header(\"Wolf Stats\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _attackDamage = 20f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    \n    [Header(\"Pack Behavior\")]\n    [SerializeField] private float _packDetectionRadius = 15f;\n    [SerializeField] private float _packFormationDistance = 3f;\n    [SerializeField] private float _packAttackBonus = 1.2f;\n    [SerializeField] private int _maxPackSize = 5;\n    \n    [Header(\"AI Behavior\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _loseTargetDistance = 20f;\n    [SerializeField] private float _circleDistance = 4f;\n    [SerializeField] private float _circleSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _howlSound;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    public UnityEvent OnPackFormed;\n    \n    private float _currentHealth;\n    private Transform _target;\n    private List<PackWolf> _packMembers = new List<PackWolf>();\n    private bool _isPackLeader = false;\n    private float _lastAttackTime;\n    private Vector3 _circlePosition;\n    private float _circleAngle;\n    private bool _isDead = false;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Collider _collider;\n    \n    private enum WolfState\n    {\n        Idle,\n        Hunting,\n        Circling,\n        Attacking,\n        Dead\n    }\n    \n    private WolfState _currentState = WolfState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _circleAngle = Random.Range(0f, 360f);\n        \n        StartCoroutine(PackDetectionCoroutine());\n        StartCoroutine(TargetDetectionCoroutine());\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        UpdateStateMachine();\n        UpdateAnimations();\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead) return;\n        \n        switch (_currentState)\n        {\n            case WolfState.Hunting:\n                MoveTowardsTarget();\n                break;\n            case WolfState.Circling:\n                CircleTarget();\n                break;\n            case WolfState.Attacking:\n                AttackTarget();\n                break;\n        }\n    }\n    \n    private void UpdateStateMachine()\n    {\n        if (_target == null)\n        {\n            _currentState = WolfState.Idle;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget > _loseTargetDistance)\n        {\n            _target = null;\n            _currentState = WolfState.Idle;\n            return;\n        }\n        \n        switch (_currentState)\n        {\n            case WolfState.Idle:\n                if (_target != null)\n                    _currentState = WolfState.Hunting;\n                break;\n                \n            case WolfState.Hunting:\n                if (distanceToTarget <= _circleDistance)\n                    _currentState = WolfState.Circling;\n                break;\n                \n            case WolfState.Circling:\n                if (distanceToTarget <= _attackRange && Time.time >= _lastAttackTime + _attackCooldown)\n                    _currentState = WolfState.Attacking;\n                else if (distanceToTarget > _circleDistance + 2f)\n                    _currentState = WolfState.Hunting;\n                break;\n                \n            case WolfState.Attacking:\n                if (Time.time >= _lastAttackTime + _attackCooldown)\n                    _currentState = WolfState.Circling;\n                break;\n        }\n    }\n    \n    private void MoveTowardsTarget()\n    {\n        if (_target == null) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        transform.LookAt(new Vector3(_target.position.x, transform.position.y, _target.position.z));\n    }\n    \n    private void CircleTarget()\n    {\n        if (_target == null) return;\n        \n        _circleAngle += _circleSpeed * Time.fixedDeltaTime;\n        \n        Vector3 offset = new Vector3(\n            Mathf.Cos(_circleAngle) * _circleDistance,\n            0f,\n            Mathf.Sin(_circleAngle) * _circleDistance\n        );\n        \n        Vector3 targetPosition = _target.position + offset;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        transform.LookAt(new Vector3(_target.position.x, transform.position.y, _target.position.z));\n    }\n    \n    private void AttackTarget()\n    {\n        if (_target == null || Time.time < _lastAttackTime + _attackCooldown) return;\n        \n        float distance = Vector3.Distance(transform.position, _target.position);\n        if (distance <= _attackRange)\n        {\n            PerformAttack();\n            _lastAttackTime = Time.time;\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        float damage = _attackDamage;\n        \n        if (_packMembers.Count > 1)\n            damage *= _packAttackBonus;\n        \n        if (_audioSource && _attackSound)\n            _audioSource.PlayOneShot(_attackSound);\n        \n        if (_target.CompareTag(\"Player\"))\n        {\n            var playerHealth = _target.GetComponent<PlayerHealthComponent>();\n            if (playerHealth != null)\n                playerHealth.TakeDamage(damage);\n        }\n        \n        NotifyPackOfAttack();\n    }\n    \n    private void NotifyPackOfAttack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this && wolf._target == null)\n            {\n                wolf.SetTarget(_target);\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n        else\n        {\n            AlertPack();\n        }\n    }\n    \n    private void AlertPack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this && wolf._target == null)\n            {\n                wolf.SetTarget(_target);\n            }\n        }\n        \n        if (_audioSource && _howlSound)\n            _audioSource.PlayOneShot(_howlSound);\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = WolfState.Dead;\n        \n        if (_audioSource && _deathSound)\n            _audioSource.PlayOneShot(_deathSound);\n        \n        if (_collider)\n            _collider.enabled = false;\n        \n        if (_rigidbody)\n            _rigidbody.isKinematic = true;\n        \n        RemoveFromPack();\n        OnDeath?.Invoke();\n        \n        StartCoroutine(DestroyAfterDelay(5f));\n    }\n    \n    private void RemoveFromPack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this)\n                wolf._packMembers.Remove(this);\n        }\n        _packMembers.Clear();\n    }\n    \n    public void SetTarget(Transform target)\n    {\n        _target = target;\n        if (_currentState == WolfState.Idle)\n            _currentState = WolfState.Hunting;\n    }\n    \n    private IEnumerator PackDetectionCoroutine()\n    {\n        while (!_isDead)\n        {\n            DetectNearbyWolves();\n            yield return new WaitForSeconds(2f);\n        }\n    }\n    \n    private void DetectNearbyWolves()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _packDetectionRadius);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            var wolf = collider.GetComponent<PackWolf>();\n            if (wolf != null && wolf != this && !wolf._isDead)\n            {\n                if (!_packMembers.Contains(wolf) && _packMembers.Count < _maxPackSize)\n                {\n                    JoinPack(wolf);\n                }\n            }\n        }\n        \n        _packMembers.RemoveAll(wolf => wolf == null || wolf._isDead || \n                              Vector3.Distance(transform.position, wolf.transform.position) > _packDetectionRadius * 1.5f);\n    }\n    \n    private void JoinPack(PackWolf otherWolf)\n    {\n        if (!_packMembers.Contains(otherWolf))\n            _packMembers.Add(otherWolf);\n            \n        if (!otherWolf._packMembers.Contains(this))\n            otherWolf._packMembers.Add(this);\n        \n        if (_packMembers.Count >= 2 && !_isPackLeader)\n        {\n            _isPackLeader = _packMembers.Count > otherWolf._packMembers.Count;\n            OnPackFormed?.Invoke();\n        }\n    }\n    \n    private IEnumerator TargetDetectionCoroutine()\n    {\n        while (!_isDead)\n        {\n            if (_target == null)\n                DetectTarget();\n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n    \n    private void DetectTarget()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _detectionRadius);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                SetTarget(collider.transform);\n                break;\n            }\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"IsAttacking\", _currentState == WolfState.Attacking);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _packDetectionRadius);\n        \n        if (_packMembers != null)\n        {\n            Gizmos.color = Color.green;\n            foreach (var wolf in _packMembers)\n            {\n                if (wolf != null && wolf != this)\n                    Gizmos.DrawLine(transform.position, wolf.transform.position);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class PlayerHealthComponent : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    private float _currentHealth;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        if (_currentHealth <= 0f)\n        {\n            Debug.Log(\"Player died!\");\n        }\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "archer enemy that keeps distance",
      "ideal_ir": {
        "class_name": "ArcherEnemy",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "optimalDistance",
            "type": "float",
            "default": 8
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "shootCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "arrowPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "shootPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "health",
            "type": "int",
            "default": 50
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "face toward player"
              },
              {
                "action": "enter combat state"
              }
            ]
          },
          {
            "name": "maintain_distance",
            "trigger": "when player is too close to optimal distance",
            "actions": [
              {
                "action": "move backward away from player at move speed"
              },
              {
                "action": "continue facing player while moving"
              }
            ]
          },
          {
            "name": "approach_player",
            "trigger": "when player is too far from optimal distance but within detection range",
            "actions": [
              {
                "action": "move forward toward player at move speed"
              },
              {
                "action": "stop when reaching optimal distance"
              }
            ]
          },
          {
            "name": "shoot_arrow",
            "trigger": "when player is at optimal distance and shoot cooldown is ready",
            "actions": [
              {
                "action": "play shooting animation"
              },
              {
                "action": "instantiate arrow at shoot point"
              },
              {
                "action": "launch arrow toward player position"
              },
              {
                "action": "start shoot cooldown timer"
              }
            ]
          },
          {
            "name": "lose_player",
            "trigger": "when player leaves detection range",
            "actions": [
              {
                "action": "return to idle state"
              },
              {
                "action": "stop all movement"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when receiving damage",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt animation"
              },
              {
                "action": "if health reaches zero then destroy self"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ArcherEnemy : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _loseTargetRange = 20f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n\n    [Header(\"Combat\")]\n    [SerializeField] private float _preferredDistance = 8f;\n    [SerializeField] private float _minDistance = 5f;\n    [SerializeField] private float _maxDistance = 12f;\n    [SerializeField] private float _shootCooldown = 2f;\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _shootPoint;\n    [SerializeField] private float _arrowSpeed = 10f;\n\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _backpedalSpeed = 4f;\n    [SerializeField] private float _strafeSpeed = 3.5f;\n    [SerializeField] private float _rotationSpeed = 5f;\n\n    [Header(\"Health\")]\n    [SerializeField] private int _maxHealth = 50;\n    [SerializeField] private float _hitStunDuration = 0.3f;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnPlayerLost;\n    public UnityEvent OnArrowShot;\n    public UnityEvent OnDeath;\n\n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private int _currentHealth;\n    private float _lastShootTime;\n    private float _hitStunEndTime;\n    private bool _hasTarget;\n    private Vector3 _lastKnownPlayerPosition;\n    private float _strafeDirection = 1f;\n    private float _strafeTimer;\n\n    private enum State\n    {\n        Idle,\n        Pursuing,\n        Maintaining,\n        Retreating,\n        Strafing,\n        Stunned,\n        Dead\n    }\n\n    private State _currentState = State.Idle;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _currentHealth = _maxHealth;\n\n        if (_shootPoint == null)\n            _shootPoint = transform;\n\n        if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n    }\n\n    private void Update()\n    {\n        if (_currentState == State.Dead) return;\n\n        HandleTargetDetection();\n        UpdateState();\n        HandleShooting();\n        UpdateAnimations();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_currentState == State.Dead || _currentState == State.Stunned) return;\n\n        HandleMovement();\n        HandleRotation();\n    }\n\n    private void HandleTargetDetection()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        \n        if (player == null)\n        {\n            if (_hasTarget)\n            {\n                LoseTarget();\n            }\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n\n        if (!_hasTarget && distanceToPlayer <= _detectionRange)\n        {\n            if (HasLineOfSight(player.transform.position))\n            {\n                AcquireTarget(player.transform);\n            }\n        }\n        else if (_hasTarget && distanceToPlayer > _loseTargetRange)\n        {\n            LoseTarget();\n        }\n        else if (_hasTarget)\n        {\n            _lastKnownPlayerPosition = player.transform.position;\n        }\n    }\n\n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - _shootPoint.position;\n        float distance = direction.magnitude;\n        \n        return !Physics.Raycast(_shootPoint.position, direction.normalized, distance, _obstacleLayer);\n    }\n\n    private void AcquireTarget(Transform playerTransform)\n    {\n        _player = playerTransform;\n        _hasTarget = true;\n        _lastKnownPlayerPosition = playerTransform.position;\n        OnPlayerDetected?.Invoke();\n    }\n\n    private void LoseTarget()\n    {\n        _player = null;\n        _hasTarget = false;\n        _currentState = State.Idle;\n        OnPlayerLost?.Invoke();\n    }\n\n    private void UpdateState()\n    {\n        if (Time.time < _hitStunEndTime)\n        {\n            _currentState = State.Stunned;\n            return;\n        }\n\n        if (!_hasTarget)\n        {\n            _currentState = State.Idle;\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _lastKnownPlayerPosition);\n\n        if (distanceToPlayer < _minDistance)\n        {\n            _currentState = State.Retreating;\n        }\n        else if (distanceToPlayer > _maxDistance)\n        {\n            _currentState = State.Pursuing;\n        }\n        else\n        {\n            _strafeTimer += Time.deltaTime;\n            if (_strafeTimer > 2f)\n            {\n                _strafeDirection *= -1f;\n                _strafeTimer = 0f;\n            }\n            _currentState = State.Strafing;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (!_hasTarget || _rigidbody == null) return;\n\n        Vector3 moveDirection = Vector3.zero;\n        Vector3 toPlayer = (_lastKnownPlayerPosition - transform.position).normalized;\n        Vector3 strafeDirection = Vector3.Cross(toPlayer, Vector3.up) * _strafeDirection;\n\n        switch (_currentState)\n        {\n            case State.Pursuing:\n                moveDirection = toPlayer * _moveSpeed;\n                break;\n\n            case State.Retreating:\n                moveDirection = -toPlayer * _backpedalSpeed;\n                break;\n\n            case State.Strafing:\n                moveDirection = strafeDirection * _strafeSpeed;\n                break;\n        }\n\n        if (moveDirection != Vector3.zero)\n        {\n            _rigidbody.velocity = new Vector3(moveDirection.x, _rigidbody.velocity.y, moveDirection.z);\n        }\n        else\n        {\n            _rigidbody.velocity = new Vector3(0, _rigidbody.velocity.y, 0);\n        }\n    }\n\n    private void HandleRotation()\n    {\n        if (!_hasTarget) return;\n\n        Vector3 lookDirection = (_lastKnownPlayerPosition - transform.position).normalized;\n        lookDirection.y = 0;\n\n        if (lookDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(lookDirection);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.fixedDeltaTime);\n        }\n    }\n\n    private void HandleShooting()\n    {\n        if (!_hasTarget || _currentState == State.Stunned) return;\n        if (Time.time < _lastShootTime + _shootCooldown) return;\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _lastKnownPlayerPosition);\n        if (distanceToPlayer <= _maxDistance && HasLineOfSight(_lastKnownPlayerPosition))\n        {\n            ShootArrow();\n        }\n    }\n\n    private void ShootArrow()\n    {\n        if (_arrowPrefab == null) return;\n\n        Vector3 shootDirection = (_lastKnownPlayerPosition - _shootPoint.position).normalized;\n        GameObject arrow = Instantiate(_arrowPrefab, _shootPoint.position, Quaternion.LookRotation(shootDirection));\n        \n        Rigidbody arrowRb = arrow.GetComponent<Rigidbody>();\n        if (arrowRb != null)\n        {\n            arrowRb.velocity = shootDirection * _arrowSpeed;\n        }\n\n        Arrow arrowComponent = arrow.GetComponent<Arrow>();\n        if (arrowComponent == null)\n        {\n            arrowComponent = arrow.AddComponent<Arrow>();\n        }\n        arrowComponent.Initialize(10, 5f);\n\n        _lastShootTime = Time.time;\n        OnArrowShot?.Invoke();\n    }\n\n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n\n        _animator.SetBool(\"HasTarget\", _hasTarget);\n        _animator.SetFloat(\"Speed\", _rigidbody != null ? _rigidbody.velocity.magnitude : 0f);\n        _animator.SetBool(\"IsRetreating\", _currentState == State.Retreating);\n        _animator.SetBool(\"IsStunned\", _currentState == State.Stunned);\n    }\n\n    public void TakeDamage(int damage)\n    {\n        if (_currentState == State.Dead) return;\n\n        _currentHealth -= damage;\n        _hitStunEndTime = Time.time + _hitStunDuration;\n\n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        _currentState = State.Dead;\n        _hasTarget = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n\n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Die\");\n        }\n\n        OnDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState != State.Dead)\n        {\n            if (!_hasTarget)\n            {\n                AcquireTarget(other.transform);\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _minDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _preferredDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _maxDistance);\n    }\n\n    [System.Serializable]\n    public class Arrow : MonoBehaviour\n    {\n        private int _damage;\n        private float _lifetime;\n        private float _spawnTime;\n\n        public void Initialize(int damage, float lifetime)\n        {\n            _damage = damage;\n            _lifetime = lifetime;\n            _spawnTime = Time.time;\n        }\n\n        private void Update()\n        {\n            if (Time.time > _spawnTime + _lifetime)\n            {\n                Destroy(gameObject);\n            }\n        }\n\n        private void OnTriggerEnter(Collider other)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                ArcherEnemy archer = other.GetComponent<ArcherEnemy>();\n                if (archer != null)\n                {\n                    archer.TakeDamage(_damage);\n                }\n                Destroy(gameObject);\n            }\n            else if (!other.isTrigger)\n            {\n                Destroy(gameObject);\n            }\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "mage enemy that casts spells",
      "ideal_ir": {
        "class_name": "MageEnemy",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 80
          },
          {
            "name": "mana",
            "type": "int",
            "default": 100
          },
          {
            "name": "castRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "spellDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "castCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "manaCostPerSpell",
            "type": "int",
            "default": 20
          },
          {
            "name": "manaRegenRate",
            "type": "float",
            "default": 5
          },
          {
            "name": "retreatDistance",
            "type": "float",
            "default": 8
          },
          {
            "name": "movementSpeed",
            "type": "float",
            "default": 3
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "enter combat state"
              },
              {
                "action": "face toward player"
              }
            ]
          },
          {
            "name": "maintain_distance",
            "trigger": "when player is closer than retreat distance",
            "actions": [
              {
                "action": "move away from player at movement speed"
              },
              {
                "action": "maintain line of sight with player"
              }
            ]
          },
          {
            "name": "cast_spell",
            "trigger": "when player is within cast range and cooldown is ready and mana is sufficient",
            "actions": [
              {
                "action": "play casting animation"
              },
              {
                "action": "reduce mana by spell cost"
              },
              {
                "action": "create spell projectile aimed at player"
              },
              {
                "action": "start cast cooldown timer"
              }
            ]
          },
          {
            "name": "regenerate_mana",
            "trigger": "when mana is below maximum",
            "actions": [
              {
                "action": "increase mana over time at regeneration rate"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when hit by player attack",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt animation"
              },
              {
                "action": "briefly interrupt current action"
              }
            ]
          },
          {
            "name": "die",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "play death animation"
              },
              {
                "action": "disable all combat behaviors"
              },
              {
                "action": "destroy game object after animation completes"
              }
            ]
          },
          {
            "name": "lose_target",
            "trigger": "when player leaves detection range",
            "actions": [
              {
                "action": "exit combat state"
              },
              {
                "action": "return to idle patrol behavior"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MageEnemy : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _retreatDistance = 3f;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _spellCastTime = 1f;\n    \n    [Header(\"Spells\")]\n    [SerializeField] private GameObject _fireballPrefab;\n    [SerializeField] private GameObject _iceBoltPrefab;\n    [SerializeField] private GameObject _lightningPrefab;\n    [SerializeField] private Transform _spellSpawnPoint;\n    [SerializeField] private float _projectileSpeed = 15f;\n    [SerializeField] private int _projectileDamage = 25;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _castingEffect;\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private int _currentHealth;\n    private float _lastAttackTime;\n    private bool _isCasting;\n    private bool _isDead;\n    private EnemyState _currentState;\n    private Vector3 _initialPosition;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        Retreating,\n        Dead\n    }\n    \n    private enum SpellType\n    {\n        Fireball,\n        IceBolt,\n        Lightning\n    }\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _currentHealth = _maxHealth;\n        _currentState = EnemyState.Idle;\n        _initialPosition = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_spellSpawnPoint == null)\n            _spellSpawnPoint = transform;\n            \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        HandleStateMachine();\n        UpdateAnimations();\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead || _isCasting) return;\n        \n        HandleMovement();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n            _player = playerObject.transform;\n    }\n    \n    private void HandleStateMachine()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                    _currentState = EnemyState.Chasing;\n                break;\n                \n            case EnemyState.Chasing:\n                if (distanceToPlayer > _detectionRange)\n                    _currentState = EnemyState.Idle;\n                else if (distanceToPlayer <= _attackRange)\n                    _currentState = EnemyState.Attacking;\n                break;\n                \n            case EnemyState.Attacking:\n                if (distanceToPlayer > _attackRange)\n                    _currentState = EnemyState.Chasing;\n                else if (distanceToPlayer < _retreatDistance)\n                    _currentState = EnemyState.Retreating;\n                else\n                    TryAttack();\n                break;\n                \n            case EnemyState.Retreating:\n                if (distanceToPlayer >= _retreatDistance)\n                    _currentState = EnemyState.Attacking;\n                break;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case EnemyState.Chasing:\n                direction = (_player.position - transform.position).normalized;\n                break;\n                \n            case EnemyState.Retreating:\n                direction = (transform.position - _player.position).normalized;\n                break;\n        }\n        \n        if (direction != Vector3.zero)\n        {\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            transform.LookAt(new Vector3(_player.position.x, transform.position.y, _player.position.z));\n        }\n    }\n    \n    private void TryAttack()\n    {\n        if (Time.time - _lastAttackTime >= _attackCooldown && !_isCasting)\n        {\n            StartCoroutine(CastSpell());\n            _lastAttackTime = Time.time;\n        }\n    }\n    \n    private IEnumerator CastSpell()\n    {\n        _isCasting = true;\n        \n        if (_castingEffect != null)\n            _castingEffect.Play();\n            \n        if (_audioSource != null && _castSound != null)\n            _audioSource.PlayOneShot(_castSound);\n        \n        yield return new WaitForSeconds(_spellCastTime);\n        \n        SpellType spellType = (SpellType)Random.Range(0, 3);\n        LaunchSpell(spellType);\n        \n        _isCasting = false;\n    }\n    \n    private void LaunchSpell(SpellType spellType)\n    {\n        if (_player == null) return;\n        \n        GameObject spellPrefab = GetSpellPrefab(spellType);\n        if (spellPrefab == null) return;\n        \n        Vector3 direction = (_player.position - _spellSpawnPoint.position).normalized;\n        GameObject spell = Instantiate(spellPrefab, _spellSpawnPoint.position, Quaternion.LookRotation(direction));\n        \n        Rigidbody spellRb = spell.GetComponent<Rigidbody>();\n        if (spellRb != null)\n        {\n            spellRb.velocity = direction * _projectileSpeed;\n        }\n        \n        SpellProjectile projectile = spell.GetComponent<SpellProjectile>();\n        if (projectile == null)\n        {\n            projectile = spell.AddComponent<SpellProjectile>();\n        }\n        projectile.Initialize(_projectileDamage, spellType);\n        \n        Destroy(spell, 5f);\n    }\n    \n    private GameObject GetSpellPrefab(SpellType spellType)\n    {\n        switch (spellType)\n        {\n            case SpellType.Fireball:\n                return _fireballPrefab;\n            case SpellType.IceBolt:\n                return _iceBoltPrefab;\n            case SpellType.Lightning:\n                return _lightningPrefab;\n            default:\n                return _fireballPrefab;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == EnemyState.Chasing || _currentState == EnemyState.Retreating);\n        _animator.SetBool(\"IsCasting\", _isCasting);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = EnemyState.Dead;\n        \n        if (_deathEffect != null)\n            _deathEffect.Play();\n            \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n        \n        GetComponent<Collider>().enabled = false;\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            _currentState = EnemyState.Attacking;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _retreatDistance);\n    }\n}\n\npublic class SpellProjectile : MonoBehaviour\n{\n    private int _damage;\n    private MageEnemy.SpellType _spellType;\n    private bool _hasHit;\n    \n    public void Initialize(int damage, MageEnemy.SpellType spellType)\n    {\n        _damage = damage;\n        _spellType = spellType;\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpellEffect(other.gameObject);\n            _hasHit = true;\n            Destroy(gameObject);\n        }\n        else if (!other.CompareTag(\"Enemy\"))\n        {\n            _hasHit = true;\n            Destroy(gameObject);\n        }\n    }\n    \n    private void ApplySpellEffect(GameObject target)\n    {\n        // Apply damage - you would typically have a health component here\n        // For now, we'll just send a message that can be caught by any health system\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Apply spell-specific effects\n        switch (_spellType)\n        {\n            case MageEnemy.SpellType.IceBolt:\n                // Slow effect could be applied here\n                break;\n            case MageEnemy.SpellType.Lightning:\n                // Stun effect could be applied here\n                break;\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "knight with shield blocking",
      "ideal_ir": {
        "class_name": "ShieldKnight",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "blockDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "blockCooldown",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "movementSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isBlocking",
            "type": "bool",
            "default": false
          },
          {
            "name": "canBlock",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "start_blocking",
            "trigger": "when right mouse button is pressed and can block",
            "actions": [
              {
                "action": "set blocking state to true"
              },
              {
                "action": "play shield raise animation"
              },
              {
                "action": "reduce movement speed by half"
              },
              {
                "action": "set can block to false"
              }
            ]
          },
          {
            "name": "maintain_block",
            "trigger": "while blocking and right mouse button held",
            "actions": [
              {
                "action": "keep shield raised"
              },
              {
                "action": "face toward nearest threat"
              },
              {
                "action": "maintain defensive stance animation"
              }
            ]
          },
          {
            "name": "stop_blocking",
            "trigger": "when right mouse button released or block duration expires",
            "actions": [
              {
                "action": "set blocking state to false"
              },
              {
                "action": "play shield lower animation"
              },
              {
                "action": "restore normal movement speed"
              },
              {
                "action": "start block cooldown timer"
              }
            ]
          },
          {
            "name": "block_attack",
            "trigger": "when enemy attack hits while blocking",
            "actions": [
              {
                "action": "deflect incoming damage"
              },
              {
                "action": "play shield impact effect"
              },
              {
                "action": "push back slightly from impact"
              },
              {
                "action": "play metallic clang sound"
              }
            ]
          },
          {
            "name": "reset_block_ability",
            "trigger": "when block cooldown timer expires",
            "actions": [
              {
                "action": "set can block to true"
              },
              {
                "action": "show block ready indicator"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class KnightShieldController : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private GameObject _shieldObject;\n    [SerializeField] private Transform _shieldPosition;\n    [SerializeField] private float _blockDuration = 2f;\n    [SerializeField] private float _blockCooldown = 1f;\n    [SerializeField] private float _blockAngle = 90f;\n    [SerializeField] private LayerMask _projectileLayer = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _blockTrigger = \"Block\";\n    [SerializeField] private string _isBlockingBool = \"IsBlocking\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _blockSound;\n    [SerializeField] private AudioClip _deflectSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _blockEffect;\n    [SerializeField] private ParticleSystem _deflectEffect;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _blockKey = KeyCode.Mouse1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBlockStart;\n    public UnityEvent OnBlockEnd;\n    public UnityEvent OnSuccessfulBlock;\n    \n    private bool _isBlocking = false;\n    private bool _canBlock = true;\n    private float _blockTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Collider _shieldCollider;\n    private Rigidbody _rb;\n    \n    private void Start()\n    {\n        if (_shieldObject != null)\n        {\n            _shieldCollider = _shieldObject.GetComponent<Collider>();\n            if (_shieldCollider == null)\n            {\n                _shieldCollider = _shieldObject.AddComponent<BoxCollider>();\n                _shieldCollider.isTrigger = true;\n            }\n        }\n        \n        _rb = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        if (_shieldObject != null)\n            _shieldObject.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateBlockTimer();\n        UpdateCooldownTimer();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_blockKey) && _canBlock && !_isBlocking)\n        {\n            StartBlocking();\n        }\n        else if (Input.GetKeyUp(_blockKey) && _isBlocking)\n        {\n            StopBlocking();\n        }\n    }\n    \n    private void UpdateBlockTimer()\n    {\n        if (_isBlocking)\n        {\n            _blockTimer += Time.deltaTime;\n            if (_blockTimer >= _blockDuration)\n            {\n                StopBlocking();\n            }\n        }\n    }\n    \n    private void UpdateCooldownTimer()\n    {\n        if (!_canBlock)\n        {\n            _cooldownTimer += Time.deltaTime;\n            if (_cooldownTimer >= _blockCooldown)\n            {\n                _canBlock = true;\n                _cooldownTimer = 0f;\n            }\n        }\n    }\n    \n    private void StartBlocking()\n    {\n        _isBlocking = true;\n        _blockTimer = 0f;\n        \n        if (_shieldObject != null)\n        {\n            _shieldObject.SetActive(true);\n            PositionShield();\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(_blockTrigger);\n            _animator.SetBool(_isBlockingBool, true);\n        }\n        \n        if (_audioSource != null && _blockSound != null)\n        {\n            _audioSource.PlayOneShot(_blockSound);\n        }\n        \n        if (_blockEffect != null)\n        {\n            _blockEffect.Play();\n        }\n        \n        OnBlockStart?.Invoke();\n    }\n    \n    private void StopBlocking()\n    {\n        _isBlocking = false;\n        _canBlock = false;\n        _cooldownTimer = 0f;\n        \n        if (_shieldObject != null)\n        {\n            _shieldObject.SetActive(false);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(_isBlockingBool, false);\n        }\n        \n        if (_blockEffect != null)\n        {\n            _blockEffect.Stop();\n        }\n        \n        OnBlockEnd?.Invoke();\n    }\n    \n    private void PositionShield()\n    {\n        if (_shieldObject == null) return;\n        \n        if (_shieldPosition != null)\n        {\n            _shieldObject.transform.position = _shieldPosition.position;\n            _shieldObject.transform.rotation = _shieldPosition.rotation;\n        }\n        else\n        {\n            Vector3 forward = transform.forward;\n            Vector3 shieldPos = transform.position + forward * 0.5f + Vector3.up * 1f;\n            _shieldObject.transform.position = shieldPos;\n            _shieldObject.transform.LookAt(transform.position + forward * 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isBlocking) return;\n        \n        if (IsProjectile(other))\n        {\n            HandleProjectileBlock(other);\n        }\n        else if (other.CompareTag(\"Enemy\"))\n        {\n            HandleEnemyBlock(other);\n        }\n    }\n    \n    private bool IsProjectile(Collider other)\n    {\n        return (_projectileLayer.value & (1 << other.gameObject.layer)) > 0 ||\n               other.CompareTag(\"Projectile\") ||\n               other.GetComponent<Rigidbody>() != null;\n    }\n    \n    private void HandleProjectileBlock(Collider other)\n    {\n        Vector3 directionToProjectile = (other.transform.position - transform.position).normalized;\n        Vector3 shieldForward = _shieldObject != null ? _shieldObject.transform.forward : transform.forward;\n        \n        float angle = Vector3.Angle(-shieldForward, directionToProjectile);\n        \n        if (angle <= _blockAngle * 0.5f)\n        {\n            BlockProjectile(other);\n        }\n    }\n    \n    private void HandleEnemyBlock(Collider other)\n    {\n        Vector3 directionToEnemy = (other.transform.position - transform.position).normalized;\n        Vector3 shieldForward = _shieldObject != null ? _shieldObject.transform.forward : transform.forward;\n        \n        float angle = Vector3.Angle(-shieldForward, directionToEnemy);\n        \n        if (angle <= _blockAngle * 0.5f)\n        {\n            BlockEnemyAttack(other);\n        }\n    }\n    \n    private void BlockProjectile(Collider projectile)\n    {\n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb != null)\n        {\n            Vector3 reflectDirection = Vector3.Reflect(projectileRb.velocity.normalized, \n                _shieldObject != null ? _shieldObject.transform.forward : transform.forward);\n            projectileRb.velocity = reflectDirection * projectileRb.velocity.magnitude;\n        }\n        \n        PlayDeflectEffects();\n        OnSuccessfulBlock?.Invoke();\n        \n        Destroy(projectile.gameObject, 0.1f);\n    }\n    \n    private void BlockEnemyAttack(Collider enemy)\n    {\n        Rigidbody enemyRb = enemy.GetComponent<Rigidbody>();\n        if (enemyRb != null)\n        {\n            Vector3 knockbackDirection = (enemy.transform.position - transform.position).normalized;\n            enemyRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n        \n        PlayDeflectEffects();\n        OnSuccessfulBlock?.Invoke();\n    }\n    \n    private void PlayDeflectEffects()\n    {\n        if (_audioSource != null && _deflectSound != null)\n        {\n            _audioSource.PlayOneShot(_deflectSound);\n        }\n        \n        if (_deflectEffect != null)\n        {\n            _deflectEffect.Play();\n        }\n    }\n    \n    public bool IsBlocking()\n    {\n        return _isBlocking;\n    }\n    \n    public bool CanBlock()\n    {\n        return _canBlock;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        return _canBlock ? 1f : _cooldownTimer / _blockCooldown;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "dragon that breathes fire",
      "ideal_ir": {
        "class_name": "FireBreathingDragon",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "fireBreathRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "fireBreathCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "fireBreathDuration",
            "type": "float",
            "default": 2
          },
          {
            "name": "flyingSpeed",
            "type": "float",
            "default": 8
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "fireBreathDamage",
            "type": "int",
            "default": 25
          },
          {
            "name": "isBreathingFire",
            "type": "bool",
            "default": false
          },
          {
            "name": "lastFireBreathTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "detect_targets",
            "trigger": "continuously scan for enemies within detection range",
            "actions": [
              {
                "action": "identify nearest enemy target within range"
              },
              {
                "action": "face toward detected target"
              }
            ]
          },
          {
            "name": "breathe_fire",
            "trigger": "when target is within fire breath range and cooldown period has passed",
            "actions": [
              {
                "action": "play fire breathing animation"
              },
              {
                "action": "emit fire particle effects from mouth"
              },
              {
                "action": "play fire breathing sound effect"
              },
              {
                "action": "create fire damage area in front of dragon"
              },
              {
                "action": "apply fire damage to all objects in breath area"
              },
              {
                "action": "start cooldown timer for next fire breath"
              }
            ]
          },
          {
            "name": "fly_around",
            "trigger": "when no targets are in fire breath range",
            "actions": [
              {
                "action": "fly in circular patterns around the area"
              },
              {
                "action": "maintain altitude above ground"
              },
              {
                "action": "occasionally roar to intimidate nearby creatures"
              }
            ]
          },
          {
            "name": "chase_target",
            "trigger": "when target is detected but outside fire breath range",
            "actions": [
              {
                "action": "fly toward target at flying speed"
              },
              {
                "action": "maintain optimal distance for fire breathing"
              },
              {
                "action": "play wing flapping sound effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class Dragon : MonoBehaviour\n{\n    [Header(\"Dragon Settings\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 2f;\n    \n    [Header(\"Fire Breath\")]\n    [SerializeField] private Transform _fireBreathPoint;\n    [SerializeField] private GameObject _fireBreathPrefab;\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private float _fireBreathDuration = 3f;\n    [SerializeField] private float _fireBreathCooldown = 5f;\n    [SerializeField] private float _fireDamage = 25f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _roarSound;\n    [SerializeField] private AudioClip _fireBreathSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    private Transform _target;\n    private bool _isBreathingFire = false;\n    private float _lastFireBreathTime = 0f;\n    private Rigidbody _rigidbody;\n    private DragonState _currentState = DragonState.Idle;\n    \n    private enum DragonState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        BreathingFire\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_fireBreathPoint == null)\n        {\n            GameObject firePoint = new GameObject(\"FireBreathPoint\");\n            firePoint.transform.SetParent(transform);\n            firePoint.transform.localPosition = Vector3.forward * 2f;\n            _fireBreathPoint = firePoint.transform;\n        }\n        \n        _lastFireBreathTime = -_fireBreathCooldown;\n    }\n    \n    private void Update()\n    {\n        FindTarget();\n        UpdateState();\n        HandleState();\n        UpdateAnimations();\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayers);\n        float closestDistance = Mathf.Infinity;\n        Transform closestTarget = null;\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = col.transform;\n                }\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void UpdateState()\n    {\n        if (_target == null)\n        {\n            _currentState = DragonState.Idle;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (_isBreathingFire)\n        {\n            _currentState = DragonState.BreathingFire;\n        }\n        else if (distanceToTarget <= _attackRange && Time.time >= _lastFireBreathTime + _fireBreathCooldown)\n        {\n            _currentState = DragonState.Attacking;\n        }\n        else if (distanceToTarget <= _detectionRange)\n        {\n            _currentState = DragonState.Chasing;\n        }\n        else\n        {\n            _currentState = DragonState.Idle;\n        }\n    }\n    \n    private void HandleState()\n    {\n        switch (_currentState)\n        {\n            case DragonState.Idle:\n                HandleIdle();\n                break;\n            case DragonState.Chasing:\n                HandleChasing();\n                break;\n            case DragonState.Attacking:\n                HandleAttacking();\n                break;\n            case DragonState.BreathingFire:\n                HandleFireBreathing();\n                break;\n        }\n    }\n    \n    private void HandleIdle()\n    {\n        _rigidbody.velocity = Vector3.zero;\n    }\n    \n    private void HandleChasing()\n    {\n        if (_target == null) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * Time.deltaTime);\n        \n        _rigidbody.velocity = transform.forward * _moveSpeed;\n    }\n    \n    private void HandleAttacking()\n    {\n        if (_target == null) return;\n        \n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * 2f * Time.deltaTime);\n        \n        if (!_isBreathingFire)\n        {\n            StartCoroutine(BreatheFire());\n        }\n    }\n    \n    private void HandleFireBreathing()\n    {\n        if (_target == null) return;\n        \n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * Time.deltaTime);\n    }\n    \n    private IEnumerator BreatheFire()\n    {\n        _isBreathingFire = true;\n        _lastFireBreathTime = Time.time;\n        \n        PlayRoar();\n        \n        yield return new WaitForSeconds(0.5f);\n        \n        if (_fireParticles != null)\n            _fireParticles.Play();\n            \n        if (_fireBreathPrefab != null)\n        {\n            GameObject fireBreath = Instantiate(_fireBreathPrefab, _fireBreathPoint.position, _fireBreathPoint.rotation);\n            Destroy(fireBreath, _fireBreathDuration);\n        }\n        \n        PlayFireBreathSound();\n        \n        float fireTimer = 0f;\n        while (fireTimer < _fireBreathDuration)\n        {\n            DealFireDamage();\n            fireTimer += Time.deltaTime;\n            yield return null;\n        }\n        \n        if (_fireParticles != null)\n            _fireParticles.Stop();\n            \n        _isBreathingFire = false;\n    }\n    \n    private void DealFireDamage()\n    {\n        Vector3 fireDirection = _fireBreathPoint.forward;\n        RaycastHit[] hits = Physics.RaycastAll(_fireBreathPoint.position, fireDirection, _attackRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n                if (targetRb != null)\n                {\n                    Vector3 knockback = (hit.collider.transform.position - transform.position).normalized * 5f;\n                    targetRb.AddForce(knockback, ForceMode.Impulse);\n                }\n            }\n        }\n    }\n    \n    private void PlayRoar()\n    {\n        if (_audioSource != null && _roarSound != null)\n        {\n            _audioSource.PlayOneShot(_roarSound);\n        }\n    }\n    \n    private void PlayFireBreathSound()\n    {\n        if (_audioSource != null && _fireBreathSound != null)\n        {\n            _audioSource.PlayOneShot(_fireBreathSound);\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == DragonState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _currentState == DragonState.Attacking);\n        _animator.SetBool(\"IsBreathingFire\", _isBreathingFire);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        if (_fireBreathPoint != null)\n        {\n            Gizmos.color = Color.orange;\n            Gizmos.DrawRay(_fireBreathPoint.position, _fireBreathPoint.forward * _attackRange);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "golem that throws rocks",
      "ideal_ir": {
        "class_name": "RockThrowingGolem",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "throwForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "throwCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "rockPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "throwPoint",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "face toward player"
              },
              {
                "action": "play angry animation"
              },
              {
                "action": "enter combat state"
              }
            ]
          },
          {
            "name": "throw_rock",
            "trigger": "when in combat state and cooldown timer expires",
            "actions": [
              {
                "action": "play throwing animation"
              },
              {
                "action": "create rock at throw point"
              },
              {
                "action": "launch rock toward player with throw force"
              },
              {
                "action": "reset cooldown timer"
              }
            ]
          },
          {
            "name": "track_target",
            "trigger": "when in combat state",
            "actions": [
              {
                "action": "slowly rotate to face player"
              },
              {
                "action": "play tracking animation"
              }
            ]
          },
          {
            "name": "lose_target",
            "trigger": "when player leaves detection range",
            "actions": [
              {
                "action": "return to idle state"
              },
              {
                "action": "play idle animation"
              },
              {
                "action": "stop tracking player"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class RockThrowingGolem : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private Transform _eyePosition;\n    \n    [Header(\"Rock Throwing\")]\n    [SerializeField] private GameObject _rockPrefab;\n    [SerializeField] private Transform _throwPoint;\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _throwCooldown = 2f;\n    [SerializeField] private float _rockLifetime = 5f;\n    [SerializeField] private int _rockDamage = 25;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _throwTrigger = \"Throw\";\n    [SerializeField] private string _idleBool = \"IsIdle\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _rockHitSound;\n    \n    private Transform _player;\n    private bool _canThrow = true;\n    private bool _playerInRange = false;\n    private Coroutine _throwCoroutine;\n    \n    private void Start()\n    {\n        if (_eyePosition == null)\n            _eyePosition = transform;\n            \n        if (_throwPoint == null)\n            _throwPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        \n        if (_playerInRange && _canThrow && _player != null)\n        {\n            LookAtPlayer();\n            \n            if (_throwCoroutine == null)\n            {\n                _throwCoroutine = StartCoroutine(ThrowRockSequence());\n            }\n        }\n        else if (!_playerInRange && _throwCoroutine != null)\n        {\n            StopCoroutine(_throwCoroutine);\n            _throwCoroutine = null;\n            \n            if (_animator != null)\n                _animator.SetBool(_idleBool, true);\n        }\n    }\n    \n    private void DetectPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(_eyePosition.position, _detectionRange, _playerLayer);\n        \n        _playerInRange = false;\n        _player = null;\n        \n        foreach (Collider col in playersInRange)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                Vector3 directionToPlayer = (col.transform.position - _eyePosition.position).normalized;\n                \n                if (Physics.Raycast(_eyePosition.position, directionToPlayer, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider.CompareTag(\"Player\"))\n                    {\n                        _playerInRange = true;\n                        _player = col.transform;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void LookAtPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion lookRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 2f);\n        }\n    }\n    \n    private IEnumerator ThrowRockSequence()\n    {\n        while (_playerInRange && _player != null)\n        {\n            if (_canThrow)\n            {\n                _canThrow = false;\n                \n                if (_animator != null)\n                {\n                    _animator.SetBool(_idleBool, false);\n                    _animator.SetTrigger(_throwTrigger);\n                }\n                \n                yield return new WaitForSeconds(0.5f);\n                \n                ThrowRock();\n                \n                yield return new WaitForSeconds(_throwCooldown);\n                \n                _canThrow = true;\n            }\n            else\n            {\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n        \n        _throwCoroutine = null;\n    }\n    \n    private void ThrowRock()\n    {\n        if (_rockPrefab == null || _player == null) return;\n        \n        GameObject rock = Instantiate(_rockPrefab, _throwPoint.position, Quaternion.identity);\n        \n        ThrownRock rockComponent = rock.GetComponent<ThrownRock>();\n        if (rockComponent == null)\n        {\n            rockComponent = rock.AddComponent<ThrownRock>();\n        }\n        \n        rockComponent.Initialize(_rockDamage, _rockLifetime, _rockHitSound);\n        \n        Rigidbody rockRb = rock.GetComponent<Rigidbody>();\n        if (rockRb == null)\n        {\n            rockRb = rock.AddComponent<Rigidbody>();\n        }\n        \n        Vector3 throwDirection = CalculateThrowDirection();\n        rockRb.AddForce(throwDirection * _throwForce, ForceMode.Impulse);\n        \n        if (_audioSource != null && _throwSound != null)\n        {\n            _audioSource.PlayOneShot(_throwSound);\n        }\n    }\n    \n    private Vector3 CalculateThrowDirection()\n    {\n        Vector3 targetPosition = _player.position + Vector3.up * 1f;\n        Vector3 direction = (targetPosition - _throwPoint.position).normalized;\n        \n        float distance = Vector3.Distance(_throwPoint.position, targetPosition);\n        float gravity = Physics.gravity.magnitude;\n        float angle = 30f * Mathf.Deg2Rad;\n        \n        float velocity = Mathf.Sqrt(distance * gravity / Mathf.Sin(2f * angle));\n        \n        Vector3 throwVector = new Vector3(direction.x, Mathf.Tan(angle), direction.z).normalized;\n        return throwVector * velocity / _throwForce;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_eyePosition != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_eyePosition.position, _detectionRange);\n        }\n        \n        if (_throwPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_throwPoint.position, 0.2f);\n        }\n    }\n}\n\npublic class ThrownRock : MonoBehaviour\n{\n    private int _damage;\n    private float _lifetime;\n    private AudioClip _hitSound;\n    private bool _hasHit = false;\n    \n    public void Initialize(int damage, float lifetime, AudioClip hitSound)\n    {\n        _damage = damage;\n        _lifetime = lifetime;\n        _hitSound = hitSound;\n        \n        Destroy(gameObject, _lifetime);\n        \n        if (GetComponent<Collider>() == null)\n        {\n            SphereCollider col = gameObject.AddComponent<SphereCollider>();\n            col.radius = 0.2f;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _hasHit = true;\n            \n            // Apply damage to player if they have a method for it\n            other.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            \n            PlayHitEffect();\n            Destroy(gameObject);\n        }\n        else if (!other.CompareTag(\"Golem\") && !other.isTrigger)\n        {\n            _hasHit = true;\n            PlayHitEffect();\n            \n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.isKinematic = true;\n            }\n            \n            Destroy(gameObject, 2f);\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_hitSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_hitSound, transform.position);\n        }\n        \n        // Simple particle effect\n        GameObject effect = new GameObject(\"RockHitEffect\");\n        effect.transform.position = transform.position;\n        \n        ParticleSystem particles = effect.AddComponent<ParticleSystem>();\n        var main = particles.main;\n        main.startLifetime = 0.5f;\n        main.startSpeed = 5f;\n        main.maxParticles = 20;\n        \n        Destroy(effect, 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ninja that teleports behind player",
      "ideal_ir": {
        "class_name": "TeleportingNinja",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "teleportRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "teleportCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "start tracking player position"
              }
            ]
          },
          {
            "name": "teleport_behind_player",
            "trigger": "when teleport cooldown has elapsed and player is within teleport range",
            "actions": [
              {
                "action": "calculate position behind player"
              },
              {
                "action": "instantly move to position behind player"
              },
              {
                "action": "face toward player"
              },
              {
                "action": "reset teleport cooldown timer"
              }
            ]
          },
          {
            "name": "lose_player",
            "trigger": "when player exits detection range",
            "actions": [
              {
                "action": "stop tracking player"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class TeleportingNinja : MonoBehaviour\n{\n    [Header(\"Teleport Settings\")]\n    [SerializeField] private float _teleportRange = 10f;\n    [SerializeField] private float _teleportCooldown = 3f;\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _teleportDistance = 2f;\n    \n    [Header(\"Combat Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackRange = 1.5f;\n    [SerializeField] private float _attackCooldown = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _teleportEffect;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private AudioClip _attackSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTeleport;\n    public UnityEvent OnAttack;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private Transform _player;\n    private float _lastTeleportTime;\n    private float _lastAttackTime;\n    private bool _isPlayerInRange;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Rigidbody _rigidbody;\n    \n    private enum NinjaState\n    {\n        Idle,\n        Stalking,\n        Teleporting,\n        Attacking\n    }\n    \n    private NinjaState _currentState = NinjaState.Idle;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _animator = GetComponent<Animator>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n        \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _isPlayerInRange = distanceToPlayer <= _detectionRange;\n        \n        UpdateState(distanceToPlayer);\n        HandleBehavior();\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateState(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case NinjaState.Idle:\n                if (_isPlayerInRange)\n                    _currentState = NinjaState.Stalking;\n                break;\n                \n            case NinjaState.Stalking:\n                if (!_isPlayerInRange)\n                    _currentState = NinjaState.Idle;\n                else if (CanTeleport() && distanceToPlayer > _teleportDistance)\n                    _currentState = NinjaState.Teleporting;\n                else if (distanceToPlayer <= _attackRange && CanAttack())\n                    _currentState = NinjaState.Attacking;\n                break;\n                \n            case NinjaState.Teleporting:\n                _currentState = NinjaState.Stalking;\n                break;\n                \n            case NinjaState.Attacking:\n                _currentState = NinjaState.Stalking;\n                break;\n        }\n    }\n    \n    void HandleBehavior()\n    {\n        switch (_currentState)\n        {\n            case NinjaState.Teleporting:\n                TeleportBehindPlayer();\n                break;\n                \n            case NinjaState.Attacking:\n                AttackPlayer();\n                break;\n                \n            case NinjaState.Stalking:\n                LookAtPlayer();\n                break;\n        }\n    }\n    \n    bool CanTeleport()\n    {\n        return Time.time >= _lastTeleportTime + _teleportCooldown;\n    }\n    \n    bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    void TeleportBehindPlayer()\n    {\n        if (_player == null || !CanTeleport()) return;\n        \n        Vector3 playerForward = _player.forward;\n        Vector3 teleportPosition = _player.position - playerForward * _teleportDistance;\n        \n        // Ensure teleport position is on the ground\n        RaycastHit hit;\n        if (Physics.Raycast(teleportPosition + Vector3.up * 5f, Vector3.down, out hit, 10f))\n        {\n            teleportPosition.y = hit.point.y;\n        }\n        \n        // Check if teleport position is valid (not inside walls)\n        if (!Physics.CheckSphere(teleportPosition, 0.5f))\n        {\n            // Play teleport effect at current position\n            if (_teleportEffect != null)\n                _teleportEffect.Play();\n                \n            // Play sound\n            if (_teleportSound != null && _audioSource != null)\n                _audioSource.PlayOneShot(_teleportSound);\n            \n            // Teleport\n            transform.position = teleportPosition;\n            transform.LookAt(_player);\n            \n            // Play teleport effect at new position\n            if (_teleportEffect != null)\n            {\n                Invoke(nameof(PlayTeleportEffectDelayed), 0.1f);\n            }\n            \n            _lastTeleportTime = Time.time;\n            \n            if (_animator != null)\n                _animator.SetTrigger(\"Teleport\");\n                \n            OnTeleport?.Invoke();\n        }\n    }\n    \n    void PlayTeleportEffectDelayed()\n    {\n        if (_teleportEffect != null)\n            _teleportEffect.Play();\n    }\n    \n    void AttackPlayer()\n    {\n        if (_player == null || !CanAttack()) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            // Play attack animation\n            if (_animator != null)\n                _animator.SetTrigger(\"Attack\");\n            \n            // Play attack sound\n            if (_attackSound != null && _audioSource != null)\n                _audioSource.PlayOneShot(_attackSound);\n            \n            // Deal damage to player\n            DealDamageToPlayer();\n            \n            _lastAttackTime = Time.time;\n            OnAttack?.Invoke();\n        }\n    }\n    \n    void DealDamageToPlayer()\n    {\n        if (_player == null) return;\n        \n        // Try to find health component on player\n        var healthComponent = _player.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a generic way to deal damage\n            _player.SendMessage(\"TakeDamage\", _attackDamage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        OnDamageDealt?.Invoke(_attackDamage);\n    }\n    \n    void LookAtPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0; // Keep ninja upright\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 5f);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw attack range\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        // Draw teleport range\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _teleportRange);\n        \n        // Show teleport position if player exists\n        if (_player != null)\n        {\n            Vector3 teleportPos = _player.position - _player.forward * _teleportDistance;\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawWireSphere(teleportPos, 0.5f);\n            Gizmos.DrawLine(transform.position, teleportPos);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "robot with laser attacks",
      "ideal_ir": {
        "class_name": "LaserRobot",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "laserDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "laserCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "laserRange",
            "type": "float",
            "default": 20
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "start tracking player position"
              },
              {
                "action": "enter combat mode"
              }
            ]
          },
          {
            "name": "track_target",
            "trigger": "when in combat mode and player is visible",
            "actions": [
              {
                "action": "rotate to face player smoothly"
              },
              {
                "action": "move toward player at move speed"
              }
            ]
          },
          {
            "name": "fire_laser",
            "trigger": "when facing player and laser cooldown is ready",
            "actions": [
              {
                "action": "create laser beam from robot to target position"
              },
              {
                "action": "deal laser damage to player if hit"
              },
              {
                "action": "play laser firing sound effect"
              },
              {
                "action": "start laser cooldown timer"
              }
            ]
          },
          {
            "name": "patrol_behavior",
            "trigger": "when no player detected",
            "actions": [
              {
                "action": "move forward slowly"
              },
              {
                "action": "turn around when hitting obstacle"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when hit by player attack",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play damage sound effect"
              },
              {
                "action": "flash red briefly"
              }
            ]
          },
          {
            "name": "destroy_robot",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "play explosion effect"
              },
              {
                "action": "destroy robot object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LaserRobot : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Laser Settings\")]\n    [SerializeField] private Transform _laserOrigin;\n    [SerializeField] private LineRenderer _laserRenderer;\n    [SerializeField] private float _laserDamage = 25f;\n    [SerializeField] private float _laserDuration = 0.5f;\n    [SerializeField] private float _laserCooldown = 2f;\n    [SerializeField] private float _laserChargeTime = 1f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _patrolRadius = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _laserChargeSound;\n    [SerializeField] private AudioClip _laserFireSound;\n    [SerializeField] private AudioClip _detectionSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _laserChargeEffect;\n    [SerializeField] private ParticleSystem _laserImpactEffect;\n    [SerializeField] private Light _laserLight;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTargetDetected;\n    public UnityEvent OnLaserFired;\n    public UnityEvent OnTargetLost;\n    \n    private enum RobotState\n    {\n        Patrolling,\n        Chasing,\n        Charging,\n        Firing,\n        Cooldown\n    }\n    \n    private RobotState _currentState = RobotState.Patrolling;\n    private Transform _currentTarget;\n    private Vector3 _patrolCenter;\n    private Vector3 _patrolDestination;\n    private float _lastLaserTime;\n    private float _chargeStartTime;\n    private bool _hasLineOfSight;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _patrolCenter = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_laserRenderer == null)\n            _laserRenderer = GetComponent<LineRenderer>();\n            \n        if (_laserOrigin == null)\n            _laserOrigin = transform;\n            \n        SetupLaserRenderer();\n        SetNewPatrolDestination();\n        \n        _lastLaserTime = -_laserCooldown;\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        UpdateStateMachine();\n        UpdateLaserVisuals();\n        UpdateAnimations();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayerMask);\n        Transform closestTarget = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, target.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = target.transform;\n                }\n            }\n        }\n        \n        if (closestTarget != null)\n        {\n            _hasLineOfSight = HasLineOfSight(closestTarget);\n            \n            if (_hasLineOfSight && _currentTarget == null)\n            {\n                _currentTarget = closestTarget;\n                OnTargetDetected?.Invoke();\n                PlaySound(_detectionSound);\n            }\n            else if (_hasLineOfSight)\n            {\n                _currentTarget = closestTarget;\n            }\n        }\n        else if (_currentTarget != null)\n        {\n            _currentTarget = null;\n            _hasLineOfSight = false;\n            OnTargetLost?.Invoke();\n        }\n    }\n    \n    private bool HasLineOfSight(Transform target)\n    {\n        Vector3 direction = target.position - _laserOrigin.position;\n        RaycastHit hit;\n        \n        if (Physics.Raycast(_laserOrigin.position, direction.normalized, out hit, direction.magnitude, _obstacleLayerMask))\n        {\n            return hit.collider.transform == target;\n        }\n        \n        return true;\n    }\n    \n    private void UpdateStateMachine()\n    {\n        switch (_currentState)\n        {\n            case RobotState.Patrolling:\n                HandlePatrolling();\n                break;\n                \n            case RobotState.Chasing:\n                HandleChasing();\n                break;\n                \n            case RobotState.Charging:\n                HandleCharging();\n                break;\n                \n            case RobotState.Firing:\n                HandleFiring();\n                break;\n                \n            case RobotState.Cooldown:\n                HandleCooldown();\n                break;\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        if (_currentTarget != null && _hasLineOfSight)\n        {\n            _currentState = RobotState.Chasing;\n            return;\n        }\n        \n        if (Vector3.Distance(transform.position, _patrolDestination) < 1f)\n        {\n            SetNewPatrolDestination();\n        }\n    }\n    \n    private void HandleChasing()\n    {\n        if (_currentTarget == null || !_hasLineOfSight)\n        {\n            _currentState = RobotState.Patrolling;\n            SetNewPatrolDestination();\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _currentTarget.position);\n        \n        if (distanceToTarget <= _attackRange && Time.time >= _lastLaserTime + _laserCooldown)\n        {\n            _currentState = RobotState.Charging;\n            _chargeStartTime = Time.time;\n            \n            if (_laserChargeEffect != null)\n                _laserChargeEffect.Play();\n                \n            PlaySound(_laserChargeSound);\n        }\n    }\n    \n    private void HandleCharging()\n    {\n        if (_currentTarget == null || !_hasLineOfSight)\n        {\n            _currentState = RobotState.Patrolling;\n            \n            if (_laserChargeEffect != null)\n                _laserChargeEffect.Stop();\n                \n            return;\n        }\n        \n        LookAtTarget(_currentTarget.position);\n        \n        if (Time.time >= _chargeStartTime + _laserChargeTime)\n        {\n            _currentState = RobotState.Firing;\n            FireLaser();\n        }\n    }\n    \n    private void HandleFiring()\n    {\n        if (Time.time >= _lastLaserTime + _laserDuration)\n        {\n            _currentState = RobotState.Cooldown;\n            DisableLaser();\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (Time.time >= _lastLaserTime + _laserCooldown)\n        {\n            if (_currentTarget != null && _hasLineOfSight)\n            {\n                _currentState = RobotState.Chasing;\n            }\n            else\n            {\n                _currentState = RobotState.Patrolling;\n                SetNewPatrolDestination();\n            }\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector3 targetPosition = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case RobotState.Patrolling:\n                targetPosition = _patrolDestination;\n                break;\n                \n            case RobotState.Chasing:\n                if (_currentTarget != null)\n                    targetPosition = _currentTarget.position;\n                break;\n                \n            case RobotState.Charging:\n            case RobotState.Firing:\n            case RobotState.Cooldown:\n                return;\n        }\n        \n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction.magnitude > 0.1f)\n        {\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            LookAtTarget(targetPosition);\n        }\n    }\n    \n    private void LookAtTarget(Vector3 targetPosition)\n    {\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction.magnitude > 0.1f)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void SetNewPatrolDestination()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _patrolRadius;\n        _patrolDestination = _patrolCenter + new Vector3(randomCircle.x, 0, randomCircle.y);\n    }\n    \n    private void FireLaser()\n    {\n        if (_currentTarget == null) return;\n        \n        _lastLaserTime = Time.time;\n        OnLaserFired?.Invoke();\n        PlaySound(_laserFireSound);\n        \n        Vector3 laserDirection = (_currentTarget.position - _laserOrigin.position).normalized;\n        RaycastHit hit;\n        \n        if (Physics.Raycast(_laserOrigin.position, laserDirection, out hit, _attackRange))\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                // Apply damage to player\n                var playerRigidbody = hit.collider.GetComponent<Rigidbody>();\n                if (playerRigidbody != null)\n                {\n                    playerRigidbody.AddForce(laserDirection * 500f);\n                }\n                \n                // Send damage message\n                hit.collider.SendMessage(\"TakeDamage\", _laserDamage, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            ShowLaserEffect(_laserOrigin.position, hit.point);\n            \n            if (_laserImpactEffect != null)\n            {\n                _laserImpactEffect.transform.position = hit.point;\n                _laserImpactEffect.Play();\n            }\n        }\n        else\n        {\n            Vector3 endPoint = _laserOrigin.position + laserDirection * _attackRange;\n            ShowLaserEffect(_laserOrigin.position, endPoint);\n        }\n    }\n    \n    private void ShowLaserEffect(Vector3 startPoint, Vector3 endPoint)\n    {\n        if (_laserRenderer != null)\n        {\n            _laserRenderer.enabled = true;\n            _laserRenderer.SetPosition(0, startPoint);\n            _laserRenderer.SetPosition(1, endPoint);\n        }\n        \n        if (_laserLight != null)\n        {\n            _laserLight.enabled = true;\n        }\n    }\n    \n    private void DisableLaser()\n    {\n        if (_laserRenderer != null)\n            _laserRenderer.enabled = false;\n            \n        if (_laserLight != null)\n            _laserLight.enabled = false;\n            \n        if (_laserChargeEffect != null)\n            _laserChargeEffect.Stop();\n    }\n    \n    private void UpdateLaserVisuals()\n    {\n        if (_laserRenderer != null && _laserRenderer.enabled)\n        {\n            float alpha = Mathf.PingPong(Time.time * 10f, 1f);\n            Color laserColor = _laserRenderer.material.color;\n            laserColor.a = alpha;\n            _laserRenderer.material.color = laserColor;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == RobotState.Patrolling || _currentState == RobotState.Chasing);\n        _animator.SetBool(\"IsCharging\", _currentState == RobotState.Charging);\n        _animator.SetBool(\"IsFiring\", _currentState == RobotState.Firing);\n        _animator.SetBool(\"HasTarget\", _currentTarget != null);\n    }\n    \n    private void SetupLaserRenderer()\n    {\n        if (_laserRenderer != null)\n        {\n            _laserRenderer.positionCount = 2;\n            _laserRenderer.startWidth = 0.1f;\n            _laserRenderer.endWidth = 0.05f;\n            _laserRenderer.enabled = false;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_patrolCenter, _patrolRadius);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "alien with tentacle attacks",
      "ideal_ir": {
        "class_name": "TentacleAlien",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "attackRange",
            "type": "float",
            "default": 8
          },
          {
            "name": "tentacleReach",
            "type": "float",
            "default": 12
          },
          {
            "name": "attackDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "attackCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "tentacleCount",
            "type": "int",
            "default": 4
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "start aggressive behavior"
              },
              {
                "action": "play alien screech sound"
              }
            ]
          },
          {
            "name": "approach_target",
            "trigger": "when player is detected but outside attack range",
            "actions": [
              {
                "action": "move toward player at normal speed"
              },
              {
                "action": "play movement animation"
              }
            ]
          },
          {
            "name": "tentacle_whip_attack",
            "trigger": "when player is within attack range and attack is not on cooldown",
            "actions": [
              {
                "action": "extend random tentacle toward player"
              },
              {
                "action": "deal damage if tentacle hits player"
              },
              {
                "action": "play tentacle whip animation"
              },
              {
                "action": "start attack cooldown timer"
              }
            ]
          },
          {
            "name": "tentacle_grab_attack",
            "trigger": "when player is within tentacle reach and health is below half",
            "actions": [
              {
                "action": "extend multiple tentacles to grab player"
              },
              {
                "action": "pull player toward alien body"
              },
              {
                "action": "deal continuous damage while holding"
              },
              {
                "action": "play grab animation"
              }
            ]
          },
          {
            "name": "defensive_flail",
            "trigger": "when taking damage",
            "actions": [
              {
                "action": "flail all tentacles wildly"
              },
              {
                "action": "knock back nearby objects"
              },
              {
                "action": "play pain animation"
              }
            ]
          },
          {
            "name": "death_sequence",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "collapse to ground"
              },
              {
                "action": "tentacles go limp and retract"
              },
              {
                "action": "play death sound"
              },
              {
                "action": "disable all attack behaviors"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AlienTentacleController : MonoBehaviour\n{\n    [System.Serializable]\n    public class TentacleSegment\n    {\n        public Transform transform;\n        public Vector3 targetPosition;\n        public Vector3 velocity;\n        public float damping = 0.8f;\n    }\n\n    [Header(\"Alien Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"Tentacle Settings\")]\n    [SerializeField] private List<TentacleSegment> _tentacles = new List<TentacleSegment>();\n    [SerializeField] private float _tentacleSpeed = 8f;\n    [SerializeField] private float _tentacleRange = 15f;\n    [SerializeField] private float _tentacleDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _segmentDistance = 1f;\n    [SerializeField] private AnimationCurve _tentacleMoveCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _hurtSound;\n    [SerializeField] private AudioClip _deathSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _attackEffect;\n    [SerializeField] private ParticleSystem _deathEffect;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnAttack;\n    public UnityEvent OnDeath;\n\n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isAttacking = false;\n    private bool _isDead = false;\n    private float _lastAttackTime;\n    private Vector3 _originalPosition;\n    private Coroutine _currentAttackCoroutine;\n\n    private enum AlienState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        Dead\n    }\n\n    private AlienState _currentState = AlienState.Idle;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n        _originalPosition = transform.position;\n\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        InitializeTentacles();\n        FindPlayer();\n    }\n\n    private void Update()\n    {\n        if (_isDead) return;\n\n        UpdateState();\n        UpdateTentacles();\n        HandleAnimations();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isDead) return;\n\n        HandleMovement();\n    }\n\n    private void InitializeTentacles()\n    {\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform != null)\n            {\n                _tentacles[i].targetPosition = _tentacles[i].transform.position;\n                _tentacles[i].velocity = Vector3.zero;\n            }\n        }\n    }\n\n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n\n    private void UpdateState()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n\n        switch (_currentState)\n        {\n            case AlienState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                {\n                    _currentState = AlienState.Chasing;\n                    OnPlayerDetected?.Invoke();\n                }\n                break;\n\n            case AlienState.Chasing:\n                if (distanceToPlayer <= _tentacleRange && Time.time >= _lastAttackTime + _attackCooldown)\n                {\n                    _currentState = AlienState.Attacking;\n                    StartTentacleAttack();\n                }\n                else if (distanceToPlayer > _detectionRange * 1.5f)\n                {\n                    _currentState = AlienState.Idle;\n                }\n                break;\n\n            case AlienState.Attacking:\n                if (!_isAttacking)\n                {\n                    _currentState = AlienState.Chasing;\n                }\n                break;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (_currentState == AlienState.Chasing && _player != null && !_isAttacking)\n        {\n            Vector3 direction = (_player.position - transform.position).normalized;\n            direction.y = 0f;\n\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            \n            if (direction != Vector3.zero)\n            {\n                transform.rotation = Quaternion.LookRotation(direction);\n            }\n        }\n    }\n\n    private void UpdateTentacles()\n    {\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 currentPos = _tentacles[i].transform.position;\n            Vector3 targetPos = _tentacles[i].targetPosition;\n\n            _tentacles[i].velocity += (targetPos - currentPos) * _tentacleSpeed * Time.deltaTime;\n            _tentacles[i].velocity *= _tentacles[i].damping;\n\n            _tentacles[i].transform.position = currentPos + _tentacles[i].velocity * Time.deltaTime;\n\n            if (i > 0 && _tentacles[i - 1].transform != null)\n            {\n                Vector3 parentPos = _tentacles[i - 1].transform.position;\n                Vector3 currentSegmentPos = _tentacles[i].transform.position;\n                Vector3 direction = (currentSegmentPos - parentPos).normalized;\n                \n                _tentacles[i].transform.position = parentPos + direction * _segmentDistance;\n            }\n        }\n    }\n\n    private void StartTentacleAttack()\n    {\n        if (_isAttacking || _player == null) return;\n\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnAttack?.Invoke();\n        \n        if (_attackSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_attackSound);\n\n        if (_currentAttackCoroutine != null)\n            StopCoroutine(_currentAttackCoroutine);\n\n        _currentAttackCoroutine = StartCoroutine(TentacleAttackSequence());\n    }\n\n    private IEnumerator TentacleAttackSequence()\n    {\n        Vector3 playerPosition = _player.position;\n        \n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 attackPosition = playerPosition + Random.insideUnitSphere * 2f;\n            attackPosition.y = playerPosition.y;\n\n            StartCoroutine(MoveTentacleToPosition(i, attackPosition, 0.5f));\n            \n            yield return new WaitForSeconds(0.1f);\n        }\n\n        if (_attackEffect != null)\n            _attackEffect.Play();\n\n        yield return new WaitForSeconds(0.5f);\n\n        CheckTentacleHit(playerPosition);\n\n        yield return new WaitForSeconds(0.3f);\n\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 restPosition = transform.position + transform.forward * (i + 1) * _segmentDistance;\n            StartCoroutine(MoveTentacleToPosition(i, restPosition, 0.8f));\n        }\n\n        yield return new WaitForSeconds(0.8f);\n\n        _isAttacking = false;\n    }\n\n    private IEnumerator MoveTentacleToPosition(int tentacleIndex, Vector3 targetPosition, float duration)\n    {\n        if (tentacleIndex >= _tentacles.Count || _tentacles[tentacleIndex].transform == null)\n            yield break;\n\n        Vector3 startPosition = _tentacles[tentacleIndex].targetPosition;\n        float elapsed = 0f;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            float curveValue = _tentacleMoveCurve.Evaluate(t);\n\n            _tentacles[tentacleIndex].targetPosition = Vector3.Lerp(startPosition, targetPosition, curveValue);\n            yield return null;\n        }\n\n        _tentacles[tentacleIndex].targetPosition = targetPosition;\n    }\n\n    private void CheckTentacleHit(Vector3 attackCenter)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(attackCenter, 3f, _playerLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                Rigidbody playerRb = hit.GetComponent<Rigidbody>();\n                if (playerRb != null)\n                {\n                    Vector3 knockbackDirection = (hit.transform.position - transform.position).normalized;\n                    playerRb.AddForce(knockbackDirection * 500f + Vector3.up * 200f);\n                }\n\n                MonoBehaviour[] playerScripts = hit.GetComponents<MonoBehaviour>();\n                foreach (MonoBehaviour script in playerScripts)\n                {\n                    script.SendMessage(\"TakeDamage\", _tentacleDamage, SendMessageOptions.DontRequireReceiver);\n                }\n            }\n        }\n    }\n\n    private void HandleAnimations()\n    {\n        if (_animator == null) return;\n\n        _animator.SetBool(\"IsChasing\", _currentState == AlienState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _isAttacking);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n\n        _health -= damage;\n\n        if (_hurtSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_hurtSound);\n\n        if (_health <= 0f)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        if (_isDead) return;\n\n        _isDead = true;\n        _currentState = AlienState.Dead;\n\n        if (_currentAttackCoroutine != null)\n        {\n            StopCoroutine(_currentAttackCoroutine);\n            _isAttacking = false;\n        }\n\n        if (_deathSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_deathSound);\n\n        if (_deathEffect != null)\n            _deathEffect.Play();\n\n        OnDeath?.Invoke();\n\n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n\n        Collider[] colliders = GetComponents<Collider>();\n        foreach (Collider col in colliders)\n        {\n            col.enabled = false;\n        }\n\n        StartCoroutine(DestroyAfterDelay(3f));\n    }\n\n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            if (_currentState == AlienState.Idle)\n            {\n                _currentState = AlienState.Chasing;\n                OnPlayerDetected?.Invoke();\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _tentacleRange);\n\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawWireSphere(_tentacles[i].transform.position, 0.5f);\n                \n                if (i > 0 && _tentacles[i - 1].transform != null)\n                {\n                    Gizmos.DrawLine(_tentacles[i - 1].transform.position, _tentacles[i].transform.position);\n                }\n            }\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "demon that summons minions",
      "ideal_ir": {
        "class_name": "DemonSummoner",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 200
          },
          {
            "name": "summonRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "maxMinions",
            "type": "int",
            "default": 3
          },
          {
            "name": "summonCooldown",
            "type": "float",
            "default": 8
          },
          {
            "name": "minionPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "currentMinions",
            "type": "int",
            "default": 0
          },
          {
            "name": "lastSummonTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isInCombat",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "enter combat state"
              },
              {
                "action": "play demon roar sound effect"
              }
            ]
          },
          {
            "name": "summon_minions",
            "trigger": "when in combat and current minions less than maximum and summon cooldown has elapsed",
            "actions": [
              {
                "action": "play summoning animation"
              },
              {
                "action": "create dark energy particles at random positions within summon range"
              },
              {
                "action": "spawn minion at each particle location"
              },
              {
                "action": "increment current minion count"
              },
              {
                "action": "reset summon cooldown timer"
              },
              {
                "action": "play summoning sound effect"
              }
            ]
          },
          {
            "name": "track_minion_death",
            "trigger": "when a summoned minion is destroyed",
            "actions": [
              {
                "action": "decrease current minion count"
              }
            ]
          },
          {
            "name": "move_toward_player",
            "trigger": "when in combat and player is within detection range",
            "actions": [
              {
                "action": "move toward player at demon move speed"
              },
              {
                "action": "face toward player direction"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when hit by player attack",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hit sound effect"
              },
              {
                "action": "flash red briefly"
              }
            ]
          },
          {
            "name": "die",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "destroy all remaining summoned minions"
              },
              {
                "action": "play death animation"
              },
              {
                "action": "create explosion particle effect"
              },
              {
                "action": "play death sound effect"
              },
              {
                "action": "destroy this demon after animation completes"
              }
            ]
          },
          {
            "name": "exit_combat",
            "trigger": "when player leaves detection range and no minions remain",
            "actions": [
              {
                "action": "exit combat state"
              },
              {
                "action": "return to idle animation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class DemonSummoner : MonoBehaviour\n{\n    [Header(\"Demon Stats\")]\n    [SerializeField] private float _maxHealth = 200f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Summoning\")]\n    [SerializeField] private GameObject _minionPrefab;\n    [SerializeField] private int _maxMinions = 5;\n    [SerializeField] private float _summonCooldown = 3f;\n    [SerializeField] private float _summonRange = 10f;\n    [SerializeField] private float _summonRadius = 2f;\n    [SerializeField] private ParticleSystem _summonEffect;\n    [SerializeField] private AudioClip _summonSound;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _summonTrigger = \"Summon\";\n    [SerializeField] private string _attackTrigger = \"Attack\";\n    [SerializeField] private string _deathTrigger = \"Death\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDemonDeath;\n    public UnityEvent OnMinionSummoned;\n    \n    private Transform _player;\n    private List<GameObject> _activeMinions = new List<GameObject>();\n    private float _lastSummonTime;\n    private float _lastAttackTime;\n    private bool _isDead = false;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private enum DemonState\n    {\n        Idle,\n        Chasing,\n        Summoning,\n        Attacking,\n        Dead\n    }\n    \n    private DemonState _currentState = DemonState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n        \n        FindPlayer();\n        StartCoroutine(UpdateBehavior());\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        CleanupDeadMinions();\n        \n        if (_player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            UpdateState(distanceToPlayer);\n        }\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead || _player == null) return;\n        \n        if (_currentState == DemonState.Chasing)\n        {\n            MoveTowardsPlayer();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void UpdateState(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case DemonState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                {\n                    _currentState = DemonState.Chasing;\n                }\n                break;\n                \n            case DemonState.Chasing:\n                if (distanceToPlayer > _detectionRange)\n                {\n                    _currentState = DemonState.Idle;\n                }\n                else if (distanceToPlayer <= _attackRange && Time.time >= _lastAttackTime + _attackCooldown)\n                {\n                    _currentState = DemonState.Attacking;\n                    StartCoroutine(AttackSequence());\n                }\n                else if (_activeMinions.Count < _maxMinions && Time.time >= _lastSummonTime + _summonCooldown)\n                {\n                    _currentState = DemonState.Summoning;\n                    StartCoroutine(SummonSequence());\n                }\n                break;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.fixedDeltaTime);\n        }\n    }\n    \n    private IEnumerator SummonSequence()\n    {\n        if (_animator != null)\n            _animator.SetTrigger(_summonTrigger);\n        \n        yield return new WaitForSeconds(0.5f);\n        \n        SummonMinion();\n        _lastSummonTime = Time.time;\n        _currentState = DemonState.Chasing;\n    }\n    \n    private void SummonMinion()\n    {\n        if (_minionPrefab == null) return;\n        \n        Vector3 summonPosition = GetRandomSummonPosition();\n        GameObject minion = Instantiate(_minionPrefab, summonPosition, Quaternion.identity);\n        _activeMinions.Add(minion);\n        \n        if (_summonEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_summonEffect, summonPosition, Quaternion.identity);\n            Destroy(effect.gameObject, 3f);\n        }\n        \n        if (_audioSource != null && _summonSound != null)\n        {\n            _audioSource.PlayOneShot(_summonSound);\n        }\n        \n        OnMinionSummoned?.Invoke();\n    }\n    \n    private Vector3 GetRandomSummonPosition()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _summonRadius;\n        Vector3 summonPosition = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(summonPosition + Vector3.up * 10f, Vector3.down, out hit, 20f))\n        {\n            summonPosition.y = hit.point.y;\n        }\n        \n        return summonPosition;\n    }\n    \n    private IEnumerator AttackSequence()\n    {\n        if (_animator != null)\n            _animator.SetTrigger(_attackTrigger);\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        PerformAttack();\n        _lastAttackTime = Time.time;\n        _currentState = DemonState.Chasing;\n    }\n    \n    private void PerformAttack()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, _attackRange, _playerLayer);\n            \n            foreach (Collider hitCollider in hitColliders)\n            {\n                if (hitCollider.CompareTag(\"Player\"))\n                {\n                    // Deal damage to player - you would implement your damage system here\n                    Debug.Log($\"Demon deals {_attackDamage} damage to player\");\n                }\n            }\n        }\n        \n        if (_audioSource != null && _attackSound != null)\n        {\n            _audioSource.PlayOneShot(_attackSound);\n        }\n    }\n    \n    private void CleanupDeadMinions()\n    {\n        _activeMinions.RemoveAll(minion => minion == null);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = DemonState.Dead;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_deathTrigger);\n        \n        if (_audioSource != null && _deathSound != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_collider != null)\n            _collider.enabled = false;\n        \n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n        \n        OnDemonDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private IEnumerator UpdateBehavior()\n    {\n        while (!_isDead)\n        {\n            if (_player == null)\n            {\n                FindPlayer();\n            }\n            \n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            if (_currentState == DemonState.Idle)\n            {\n                _currentState = DemonState.Chasing;\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _summonRadius);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "vampire that drains health",
      "ideal_ir": {
        "class_name": "Vampire",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "drainAmount",
            "type": "float",
            "default": 20
          },
          {
            "name": "drainRange",
            "type": "float",
            "default": 3
          },
          {
            "name": "drainCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 4
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 8
          },
          {
            "name": "isDraining",
            "type": "bool",
            "default": false
          },
          {
            "name": "lastDrainTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "start moving toward player"
              }
            ]
          },
          {
            "name": "chase_player",
            "trigger": "when player is within detection range and vampire is not draining",
            "actions": [
              {
                "action": "move toward player at move speed"
              },
              {
                "action": "face direction of player"
              }
            ]
          },
          {
            "name": "start_drain",
            "trigger": "when player is within drain range and drain cooldown has elapsed",
            "actions": [
              {
                "action": "set is draining to true"
              },
              {
                "action": "stop moving"
              },
              {
                "action": "play drain sound effect"
              },
              {
                "action": "start drain visual effect"
              }
            ]
          },
          {
            "name": "drain_health",
            "trigger": "when is draining is true",
            "actions": [
              {
                "action": "reduce player health by drain amount"
              },
              {
                "action": "increase vampire current health by drain amount"
              },
              {
                "action": "clamp vampire health to maximum health"
              },
              {
                "action": "record current time as last drain time"
              },
              {
                "action": "set is draining to false"
              }
            ]
          },
          {
            "name": "stop_chase",
            "trigger": "when player exits detection range",
            "actions": [
              {
                "action": "stop moving"
              },
              {
                "action": "set is draining to false"
              },
              {
                "action": "stop drain visual effect"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when vampire receives damage",
            "actions": [
              {
                "action": "reduce current health by damage amount"
              },
              {
                "action": "play hurt sound effect"
              },
              {
                "action": "flash red briefly"
              }
            ]
          },
          {
            "name": "die",
            "trigger": "when current health reaches zero or below",
            "actions": [
              {
                "action": "play death sound effect"
              },
              {
                "action": "stop all movement"
              },
              {
                "action": "play death animation"
              },
              {
                "action": "destroy vampire after animation completes"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Vampire : MonoBehaviour\n{\n    [Header(\"Vampire Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private float _drainAmount = 10f;\n    [SerializeField] private float _drainInterval = 1f;\n    [SerializeField] private float _drainRange = 3f;\n    [SerializeField] private float _healPercentage = 0.5f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _chaseSpeed = 4f;\n    [SerializeField] private float _detectionRange = 5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _drainEffect;\n    [SerializeField] private LineRenderer _drainBeam;\n    [SerializeField] private Color _drainColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drainSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    public UnityEvent<GameObject> OnStartDraining;\n    public UnityEvent<GameObject> OnStopDraining;\n    \n    private Transform _target;\n    private bool _isDraining;\n    private Coroutine _drainCoroutine;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isDead;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_drainBeam != null)\n        {\n            _drainBeam.enabled = false;\n            _drainBeam.startColor = _drainColor;\n            _drainBeam.endColor = _drainColor;\n            _drainBeam.startWidth = 0.1f;\n            _drainBeam.endWidth = 0.05f;\n        }\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        FindTarget();\n        HandleMovement();\n        HandleDraining();\n    }\n    \n    private void FindTarget()\n    {\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        Transform closestTarget = null;\n        float closestDistance = _detectionRange;\n        \n        foreach (GameObject player in players)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = player.transform;\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void HandleMovement()\n    {\n        if (_target == null || _isDraining) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, _target.position);\n        \n        if (distance > _drainRange)\n        {\n            Vector3 movement = direction * _chaseSpeed * Time.deltaTime;\n            transform.position += movement;\n            transform.LookAt(_target);\n            \n            if (_animator != null)\n                _animator.SetBool(\"IsMoving\", true);\n        }\n        else\n        {\n            if (_animator != null)\n                _animator.SetBool(\"IsMoving\", false);\n        }\n    }\n    \n    private void HandleDraining()\n    {\n        if (_target == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _target.position);\n        \n        if (distance <= _drainRange && !_isDraining)\n        {\n            StartDraining();\n        }\n        else if (distance > _drainRange && _isDraining)\n        {\n            StopDraining();\n        }\n    }\n    \n    private void StartDraining()\n    {\n        if (_isDraining || _target == null) return;\n        \n        _isDraining = true;\n        _drainCoroutine = StartCoroutine(DrainHealthCoroutine());\n        \n        if (_drainEffect != null)\n            _drainEffect.Play();\n            \n        if (_drainBeam != null)\n        {\n            _drainBeam.enabled = true;\n            _drainBeam.SetPosition(0, transform.position + Vector3.up);\n            _drainBeam.SetPosition(1, _target.position + Vector3.up);\n        }\n        \n        if (_animator != null)\n            _animator.SetBool(\"IsDraining\", true);\n            \n        OnStartDraining?.Invoke(_target.gameObject);\n    }\n    \n    private void StopDraining()\n    {\n        if (!_isDraining) return;\n        \n        _isDraining = false;\n        \n        if (_drainCoroutine != null)\n        {\n            StopCoroutine(_drainCoroutine);\n            _drainCoroutine = null;\n        }\n        \n        if (_drainEffect != null)\n            _drainEffect.Stop();\n            \n        if (_drainBeam != null)\n            _drainBeam.enabled = false;\n            \n        if (_animator != null)\n            _animator.SetBool(\"IsDraining\", false);\n            \n        OnStopDraining?.Invoke(_target?.gameObject);\n    }\n    \n    private IEnumerator DrainHealthCoroutine()\n    {\n        while (_isDraining && _target != null)\n        {\n            DrainTargetHealth();\n            \n            if (_drainBeam != null)\n            {\n                _drainBeam.SetPosition(0, transform.position + Vector3.up);\n                _drainBeam.SetPosition(1, _target.position + Vector3.up);\n            }\n            \n            yield return new WaitForSeconds(_drainInterval);\n        }\n    }\n    \n    private void DrainTargetHealth()\n    {\n        if (_target == null) return;\n        \n        // Try to find a health component or use a simple health system\n        PlayerHealthComponent targetHealth = _target.GetComponent<PlayerHealthComponent>();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(_drainAmount);\n        }\n        else\n        {\n            // Send damage message to target\n            _target.SendMessage(\"TakeDamage\", _drainAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Heal vampire\n        float healAmount = _drainAmount * _healPercentage;\n        Heal(healAmount);\n        \n        // Play drain sound\n        if (_audioSource != null && _drainSound != null)\n            _audioSource.PlayOneShot(_drainSound);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        if (_isDead) return;\n        \n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        StopDraining();\n        \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(\"Die\");\n            \n        OnDeath?.Invoke();\n        \n        // Disable components\n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n            \n        GetComponent<Collider>().enabled = false;\n        \n        // Destroy after delay\n        Destroy(gameObject, 3f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw drain range\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _drainRange);\n    }\n}\n\n[System.Serializable]\npublic class PlayerHealthComponent : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "werewolf that transforms at night",
      "ideal_ir": {
        "class_name": "Werewolf",
        "components": [
          "Transform",
          "Animator",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isTransformed",
            "type": "bool",
            "default": false
          },
          {
            "name": "transformationTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "humanSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "werewolfSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15.0
          }
        ],
        "behaviors": [
          {
            "name": "night_transformation",
            "trigger": "when night time begins",
            "actions": [
              {
                "action": "play transformation animation"
              },
              {
                "action": "play howling sound effect"
              },
              {
                "action": "increase movement speed to werewolf speed"
              },
              {
                "action": "set transformed state to true"
              },
              {
                "action": "change appearance to werewolf form"
              }
            ]
          },
          {
            "name": "dawn_reversion",
            "trigger": "when day time begins",
            "actions": [
              {
                "action": "play reverse transformation animation"
              },
              {
                "action": "decrease movement speed to human speed"
              },
              {
                "action": "set transformed state to false"
              },
              {
                "action": "change appearance to human form"
              }
            ]
          },
          {
            "name": "werewolf_hunt",
            "trigger": "when transformed and player is within detection range",
            "actions": [
              {
                "action": "growl menacingly"
              },
              {
                "action": "chase player aggressively"
              },
              {
                "action": "play aggressive werewolf animations"
              }
            ]
          },
          {
            "name": "human_behavior",
            "trigger": "when not transformed and player approaches",
            "actions": [
              {
                "action": "act normally like a human NPC"
              },
              {
                "action": "walk at normal human pace"
              },
              {
                "action": "show no signs of being a werewolf"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Werewolf : MonoBehaviour\n{\n    [System.Serializable]\n    public class WerewolfEvents\n    {\n        public UnityEvent OnTransformToWerewolf;\n        public UnityEvent OnTransformToHuman;\n    }\n\n    [Header(\"Transformation Settings\")]\n    [SerializeField] private float _nightStartHour = 20f;\n    [SerializeField] private float _nightEndHour = 6f;\n    [SerializeField] private float _transformationDuration = 2f;\n    [SerializeField] private bool _useRealTime = false;\n    [SerializeField] private float _gameTimeSpeed = 1f;\n\n    [Header(\"Werewolf Form\")]\n    [SerializeField] private GameObject _humanModel;\n    [SerializeField] private GameObject _werewolfModel;\n    [SerializeField] private float _werewolfSpeed = 8f;\n    [SerializeField] private float _werewolfJumpForce = 15f;\n    [SerializeField] private float _werewolfDamage = 50f;\n\n    [Header(\"Human Form\")]\n    [SerializeField] private float _humanSpeed = 4f;\n    [SerializeField] private float _humanJumpForce = 8f;\n    [SerializeField] private float _humanDamage = 10f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _transformationSound;\n    [SerializeField] private AudioClip _werewolfHowl;\n    [SerializeField] private AudioClip _werewolfGrowl;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _transformationEffect;\n    [SerializeField] private Light _moonlight;\n\n    [Header(\"Events\")]\n    [SerializeField] private WerewolfEvents _events;\n\n    private bool _isWerewolf = false;\n    private bool _isTransforming = false;\n    private float _currentGameTime = 12f; // Start at noon\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Animator _humanAnimator;\n    private Animator _werewolfAnimator;\n    private float _transformTimer = 0f;\n\n    // Movement variables\n    private float _currentSpeed;\n    private float _currentJumpForce;\n    private float _currentDamage;\n    private bool _isGrounded = true;\n\n    private void Start()\n    {\n        InitializeComponents();\n        SetupInitialState();\n    }\n\n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        _collider = GetComponent<Collider>();\n\n        if (_humanModel != null)\n            _humanAnimator = _humanModel.GetComponent<Animator>();\n        \n        if (_werewolfModel != null)\n            _werewolfAnimator = _werewolfModel.GetComponent<Animator>();\n    }\n\n    private void SetupInitialState()\n    {\n        SetHumanForm();\n        \n        if (_moonlight != null)\n            _moonlight.enabled = false;\n    }\n\n    private void Update()\n    {\n        UpdateGameTime();\n        CheckTransformationConditions();\n        HandleTransformation();\n        HandleMovement();\n        UpdateAnimations();\n    }\n\n    private void UpdateGameTime()\n    {\n        if (_useRealTime)\n        {\n            System.DateTime currentTime = System.DateTime.Now;\n            _currentGameTime = currentTime.Hour + (currentTime.Minute / 60f);\n        }\n        else\n        {\n            _currentGameTime += Time.deltaTime * _gameTimeSpeed;\n            if (_currentGameTime >= 24f)\n                _currentGameTime -= 24f;\n        }\n    }\n\n    private void CheckTransformationConditions()\n    {\n        if (_isTransforming) return;\n\n        bool shouldBeWerewolf = IsNightTime();\n\n        if (shouldBeWerewolf && !_isWerewolf)\n        {\n            StartTransformation(true);\n        }\n        else if (!shouldBeWerewolf && _isWerewolf)\n        {\n            StartTransformation(false);\n        }\n    }\n\n    private bool IsNightTime()\n    {\n        if (_nightStartHour > _nightEndHour) // Night crosses midnight\n        {\n            return _currentGameTime >= _nightStartHour || _currentGameTime <= _nightEndHour;\n        }\n        else\n        {\n            return _currentGameTime >= _nightStartHour && _currentGameTime <= _nightEndHour;\n        }\n    }\n\n    private void StartTransformation(bool toWerewolf)\n    {\n        _isTransforming = true;\n        _transformTimer = 0f;\n\n        if (_transformationEffect != null)\n            _transformationEffect.Play();\n\n        if (_transformationSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_transformationSound);\n\n        if (toWerewolf)\n        {\n            _events?.OnTransformToWerewolf?.Invoke();\n            if (_werewolfHowl != null && _audioSource != null)\n                _audioSource.PlayOneShot(_werewolfHowl);\n        }\n        else\n        {\n            _events?.OnTransformToHuman?.Invoke();\n        }\n    }\n\n    private void HandleTransformation()\n    {\n        if (!_isTransforming) return;\n\n        _transformTimer += Time.deltaTime;\n\n        if (_transformTimer >= _transformationDuration)\n        {\n            CompleteTransformation();\n        }\n    }\n\n    private void CompleteTransformation()\n    {\n        _isTransforming = false;\n        \n        if (IsNightTime())\n        {\n            SetWerewolfForm();\n        }\n        else\n        {\n            SetHumanForm();\n        }\n    }\n\n    private void SetWerewolfForm()\n    {\n        _isWerewolf = true;\n        \n        if (_humanModel != null)\n            _humanModel.SetActive(false);\n        \n        if (_werewolfModel != null)\n            _werewolfModel.SetActive(true);\n\n        _currentSpeed = _werewolfSpeed;\n        _currentJumpForce = _werewolfJumpForce;\n        _currentDamage = _werewolfDamage;\n\n        if (_moonlight != null)\n            _moonlight.enabled = true;\n    }\n\n    private void SetHumanForm()\n    {\n        _isWerewolf = false;\n        \n        if (_werewolfModel != null)\n            _werewolfModel.SetActive(false);\n        \n        if (_humanModel != null)\n            _humanModel.SetActive(true);\n\n        _currentSpeed = _humanSpeed;\n        _currentJumpForce = _humanJumpForce;\n        _currentDamage = _humanDamage;\n\n        if (_moonlight != null)\n            _moonlight.enabled = false;\n    }\n\n    private void HandleMovement()\n    {\n        if (_isTransforming || _rigidbody == null) return;\n\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Vector3 movement = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (movement.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(movement);\n            _rigidbody.MovePosition(transform.position + movement * _currentSpeed * Time.deltaTime);\n        }\n\n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.up * _currentJumpForce, ForceMode.Impulse);\n            _isGrounded = false;\n        }\n    }\n\n    private void UpdateAnimations()\n    {\n        float speed = _rigidbody != null ? _rigidbody.velocity.magnitude : 0f;\n        \n        if (_isWerewolf && _werewolfAnimator != null)\n        {\n            _werewolfAnimator.SetFloat(\"Speed\", speed);\n            _werewolfAnimator.SetBool(\"IsGrounded\", _isGrounded);\n        }\n        else if (!_isWerewolf && _humanAnimator != null)\n        {\n            _humanAnimator.SetFloat(\"Speed\", speed);\n            _humanAnimator.SetBool(\"IsGrounded\", _isGrounded);\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Ground\"))\n        {\n            _isGrounded = true;\n        }\n\n        if (_isWerewolf && collision.gameObject.CompareTag(\"Player\"))\n        {\n            AttackTarget(collision.gameObject);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isWerewolf && other.CompareTag(\"Player\"))\n        {\n            if (_werewolfGrowl != null && _audioSource != null)\n                _audioSource.PlayOneShot(_werewolfGrowl);\n        }\n    }\n\n    private void AttackTarget(GameObject target)\n    {\n        // Apply damage logic here\n        Debug.Log($\"Werewolf attacks {target.name} for {_currentDamage} damage!\");\n        \n        // Push the target away\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 pushDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(pushDirection * 10f, ForceMode.Impulse);\n        }\n    }\n\n    public bool IsWerewolfForm()\n    {\n        return _isWerewolf;\n    }\n\n    public float GetCurrentGameTime()\n    {\n        return _currentGameTime;\n    }\n\n    public void ForceTransformation(bool toWerewolf)\n    {\n        if (_isTransforming) return;\n        \n        StartTransformation(toWerewolf);\n    }\n\n    public void SetGameTime(float hour)\n    {\n        _currentGameTime = Mathf.Clamp(hour, 0f, 24f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "pirate with sword and pistol",
      "ideal_ir": {
        "class_name": "PirateFighter",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "walkSpeed",
            "type": "float",
            "default": 3
          },
          {
            "name": "runSpeed",
            "type": "float",
            "default": 6
          },
          {
            "name": "swordDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "pistolDamage",
            "type": "float",
            "default": 40
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "swordRange",
            "type": "float",
            "default": 2
          },
          {
            "name": "pistolRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "pistolCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "isAlive",
            "type": "bool",
            "default": true
          },
          {
            "name": "hasAmmo",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "patrol_idle",
            "trigger": "when no enemy is detected within range",
            "actions": [
              {
                "action": "walk slowly in random directions"
              },
              {
                "action": "occasionally stop and look around"
              }
            ]
          },
          {
            "name": "detect_enemy",
            "trigger": "when enemy enters detection range",
            "actions": [
              {
                "action": "shout pirate battle cry"
              },
              {
                "action": "draw sword and pistol"
              },
              {
                "action": "run toward enemy aggressively"
              }
            ]
          },
          {
            "name": "sword_combat",
            "trigger": "when enemy is within sword range",
            "actions": [
              {
                "action": "swing sword at enemy"
              },
              {
                "action": "deal sword damage on hit"
              },
              {
                "action": "play sword clash sound effects"
              }
            ]
          },
          {
            "name": "pistol_combat",
            "trigger": "when enemy is within pistol range but outside sword range and pistol is ready",
            "actions": [
              {
                "action": "aim pistol at enemy"
              },
              {
                "action": "fire pistol shot"
              },
              {
                "action": "deal pistol damage on hit"
              },
              {
                "action": "start pistol reload cooldown"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when receiving damage from enemy attack",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play hurt animation and sound"
              },
              {
                "action": "stagger briefly"
              }
            ]
          },
          {
            "name": "death",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "play death animation"
              },
              {
                "action": "drop sword and pistol"
              },
              {
                "action": "fall to ground"
              },
              {
                "action": "become inactive"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PirateController : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 180f;\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _shootRange = 6f;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _swordDamage = 25f;\n    [SerializeField] private float _pistolDamage = 40f;\n    [SerializeField] private float _swordCooldown = 1.5f;\n    [SerializeField] private float _pistolCooldown = 3f;\n    [SerializeField] private int _maxAmmo = 6;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Health\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swordSwingSound;\n    [SerializeField] private AudioClip _pistolFireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _muzzleFlashPrefab;\n    [SerializeField] private Transform _pistolMuzzle;\n    [SerializeField] private GameObject _bloodEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnAttack;\n    public UnityEvent OnReload;\n    \n    private Transform _target;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    \n    private float _lastSwordAttack;\n    private float _lastPistolShot;\n    private int _currentAmmo;\n    private bool _isReloading;\n    private bool _isDead;\n    private float _reloadStartTime;\n    \n    private PirateState _currentState = PirateState.Patrolling;\n    private Vector3 _patrolDirection;\n    private float _patrolTimer;\n    private float _patrolChangeInterval = 3f;\n    \n    private enum PirateState\n    {\n        Patrolling,\n        Chasing,\n        Attacking,\n        Reloading,\n        Dead\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        _currentHealth = _maxHealth;\n        _currentAmmo = _maxAmmo;\n        _patrolDirection = Random.insideUnitSphere;\n        _patrolDirection.y = 0;\n        _patrolDirection.Normalize();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        HandleReloading();\n        UpdateState();\n        HandleMovement();\n        HandleCombat();\n        UpdateAnimations();\n    }\n    \n    private void HandleReloading()\n    {\n        if (_isReloading)\n        {\n            if (Time.time - _reloadStartTime >= _reloadTime)\n            {\n                _currentAmmo = _maxAmmo;\n                _isReloading = false;\n                _currentState = PirateState.Chasing;\n                OnReload?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateState()\n    {\n        if (_isReloading)\n        {\n            _currentState = PirateState.Reloading;\n            return;\n        }\n        \n        FindNearestPlayer();\n        \n        if (_target == null)\n        {\n            _currentState = PirateState.Patrolling;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget <= _attackRange)\n        {\n            _currentState = PirateState.Attacking;\n        }\n        else if (distanceToTarget <= _detectionRange)\n        {\n            _currentState = PirateState.Chasing;\n        }\n        else\n        {\n            _currentState = PirateState.Patrolling;\n            _target = null;\n        }\n    }\n    \n    private void FindNearestPlayer()\n    {\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        float nearestDistance = _detectionRange;\n        Transform nearestPlayer = null;\n        \n        foreach (GameObject player in players)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance < nearestDistance)\n            {\n                nearestDistance = distance;\n                nearestPlayer = player.transform;\n            }\n        }\n        \n        _target = nearestPlayer;\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 moveDirection = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case PirateState.Patrolling:\n                HandlePatrolling();\n                moveDirection = _patrolDirection;\n                break;\n                \n            case PirateState.Chasing:\n                if (_target != null)\n                {\n                    moveDirection = (_target.position - transform.position).normalized;\n                }\n                break;\n                \n            case PirateState.Attacking:\n                if (_target != null)\n                {\n                    Vector3 lookDirection = (_target.position - transform.position).normalized;\n                    lookDirection.y = 0;\n                    if (lookDirection != Vector3.zero)\n                    {\n                        Quaternion targetRotation = Quaternion.LookRotation(lookDirection);\n                        transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n                    }\n                }\n                return;\n                \n            case PirateState.Reloading:\n                return;\n        }\n        \n        if (moveDirection != Vector3.zero)\n        {\n            _rigidbody.MovePosition(transform.position + moveDirection * _moveSpeed * Time.deltaTime);\n            \n            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        _patrolTimer += Time.deltaTime;\n        if (_patrolTimer >= _patrolChangeInterval)\n        {\n            _patrolDirection = Random.insideUnitSphere;\n            _patrolDirection.y = 0;\n            _patrolDirection.Normalize();\n            _patrolTimer = 0f;\n        }\n    }\n    \n    private void HandleCombat()\n    {\n        if (_currentState != PirateState.Attacking || _target == null) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget <= _attackRange && Time.time - _lastSwordAttack >= _swordCooldown)\n        {\n            SwordAttack();\n        }\n        else if (distanceToTarget <= _shootRange && _currentAmmo > 0 && Time.time - _lastPistolShot >= _pistolCooldown)\n        {\n            PistolShoot();\n        }\n        else if (_currentAmmo == 0 && !_isReloading)\n        {\n            StartReload();\n        }\n    }\n    \n    private void SwordAttack()\n    {\n        _lastSwordAttack = Time.time;\n        OnAttack?.Invoke();\n        \n        if (_audioSource && _swordSwingSound)\n        {\n            _audioSource.PlayOneShot(_swordSwingSound);\n        }\n        \n        Collider[] hitColliders = Physics.OverlapSphere(transform.position + transform.forward * 1.5f, 1f);\n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DealDamageToPlayer(hit.gameObject, _swordDamage);\n            }\n        }\n    }\n    \n    private void PistolShoot()\n    {\n        _lastPistolShot = Time.time;\n        _currentAmmo--;\n        OnAttack?.Invoke();\n        \n        if (_audioSource && _pistolFireSound)\n        {\n            _audioSource.PlayOneShot(_pistolFireSound);\n        }\n        \n        if (_muzzleFlashPrefab && _pistolMuzzle)\n        {\n            GameObject flash = Instantiate(_muzzleFlashPrefab, _pistolMuzzle.position, _pistolMuzzle.rotation);\n            Destroy(flash, 0.1f);\n        }\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position + Vector3.up, transform.forward, out hit, _shootRange))\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                DealDamageToPlayer(hit.collider.gameObject, _pistolDamage);\n            }\n        }\n    }\n    \n    private void StartReload()\n    {\n        _isReloading = true;\n        _reloadStartTime = Time.time;\n        \n        if (_audioSource && _reloadSound)\n        {\n            _audioSource.PlayOneShot(_reloadSound);\n        }\n    }\n    \n    private void DealDamageToPlayer(GameObject player, float damage)\n    {\n        if (_bloodEffectPrefab)\n        {\n            GameObject blood = Instantiate(_bloodEffectPrefab, player.transform.position, Quaternion.identity);\n            Destroy(blood, 2f);\n        }\n        \n        player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_bloodEffectPrefab)\n        {\n            GameObject blood = Instantiate(_bloodEffectPrefab, transform.position + Vector3.up, Quaternion.identity);\n            Destroy(blood, 2f);\n        }\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = PirateState.Dead;\n        \n        if (_audioSource && _deathSound)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_collider)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_rigidbody)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        OnDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (!_animator) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == PirateState.Patrolling || _currentState == PirateState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _currentState == PirateState.Attacking);\n        _animator.SetBool(\"IsReloading\", _isReloading);\n        _animator.SetBool(\"IsDead\", _isDead);\n        _animator.SetFloat(\"Health\", _currentHealth / _maxHealth);\n        _animator.SetInt(\"Ammo\", _currentAmmo);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _shootRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position + transform.forward * 1.5f, 1f);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "wizard with elemental attacks",
      "ideal_ir": {
        "class_name": "ElementalWizard",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "mana",
            "type": "float",
            "default": 150
          },
          {
            "name": "castingRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "manaRegenRate",
            "type": "float",
            "default": 5
          },
          {
            "name": "fireballDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "iceShardDamage",
            "type": "float",
            "default": 20
          },
          {
            "name": "lightningDamage",
            "type": "float",
            "default": 30
          },
          {
            "name": "fireballManaCost",
            "type": "float",
            "default": 20
          },
          {
            "name": "iceShardManaCost",
            "type": "float",
            "default": 15
          },
          {
            "name": "lightningManaCost",
            "type": "float",
            "default": 25
          },
          {
            "name": "castingSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "movementSpeed",
            "type": "float",
            "default": 3
          }
        ],
        "behaviors": [
          {
            "name": "regenerate_mana",
            "trigger": "continuously over time",
            "actions": [
              {
                "action": "increase mana by regeneration rate per second up to maximum"
              }
            ]
          },
          {
            "name": "cast_fireball",
            "trigger": "when fire attack input is pressed and mana is sufficient and target is in range",
            "actions": [
              {
                "action": "reduce mana by fireball cost"
              },
              {
                "action": "play fire casting animation"
              },
              {
                "action": "create fireball projectile toward target"
              },
              {
                "action": "apply fire damage to target on impact"
              }
            ]
          },
          {
            "name": "cast_ice_shard",
            "trigger": "when ice attack input is pressed and mana is sufficient and target is in range",
            "actions": [
              {
                "action": "reduce mana by ice shard cost"
              },
              {
                "action": "play ice casting animation"
              },
              {
                "action": "create ice shard projectile toward target"
              },
              {
                "action": "apply ice damage and slow effect to target on impact"
              }
            ]
          },
          {
            "name": "cast_lightning_bolt",
            "trigger": "when lightning attack input is pressed and mana is sufficient and target is in range",
            "actions": [
              {
                "action": "reduce mana by lightning cost"
              },
              {
                "action": "play lightning casting animation"
              },
              {
                "action": "create instant lightning effect between wizard and target"
              },
              {
                "action": "apply lightning damage and stun effect to target"
              }
            ]
          },
          {
            "name": "wizard_movement",
            "trigger": "when movement input is received",
            "actions": [
              {
                "action": "move wizard in input direction at movement speed"
              },
              {
                "action": "rotate wizard to face movement direction"
              },
              {
                "action": "play walking animation"
              }
            ]
          },
          {
            "name": "face_target",
            "trigger": "when casting spell at target",
            "actions": [
              {
                "action": "rotate wizard to face target before casting"
              }
            ]
          },
          {
            "name": "wizard_death",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "play death animation"
              },
              {
                "action": "disable wizard controls"
              },
              {
                "action": "trigger game over or respawn sequence"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class WizardController : MonoBehaviour\n{\n    [System.Serializable]\n    public enum ElementType\n    {\n        Fire,\n        Ice,\n        Lightning,\n        Earth\n    }\n\n    [System.Serializable]\n    public class ElementalSpell\n    {\n        public ElementType element;\n        public GameObject projectilePrefab;\n        public ParticleSystem castEffect;\n        public AudioClip castSound;\n        public float damage = 25f;\n        public float manaCost = 20f;\n        public float cooldown = 1f;\n        public float projectileSpeed = 10f;\n        [HideInInspector] public float lastCastTime;\n    }\n\n    [Header(\"Wizard Stats\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _maxMana = 100f;\n    [SerializeField] private float _manaRegenRate = 10f;\n    [SerializeField] private float _movementSpeed = 5f;\n\n    [Header(\"Combat\")]\n    [SerializeField] private ElementalSpell[] _spells = new ElementalSpell[4];\n    [SerializeField] private Transform _castPoint;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    [SerializeField] private float _attackRange = 15f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent<float> OnManaChanged;\n    public UnityEvent<ElementType> OnSpellCast;\n    public UnityEvent OnDeath;\n\n    private float _currentHealth;\n    private float _currentMana;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private Transform _currentTarget;\n    private bool _isDead;\n    private int _currentSpellIndex;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _currentMana = _maxMana;\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_castPoint == null)\n            _castPoint = transform;\n\n        InitializeSpells();\n        StartCoroutine(ManaRegeneration());\n    }\n\n    private void Update()\n    {\n        if (_isDead) return;\n\n        HandleInput();\n        FindTarget();\n        UpdateAnimator();\n    }\n\n    private void InitializeSpells()\n    {\n        for (int i = 0; i < _spells.Length; i++)\n        {\n            if (_spells[i] == null)\n            {\n                _spells[i] = new ElementalSpell();\n                _spells[i].element = (ElementType)i;\n            }\n        }\n    }\n\n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 movement = new Vector3(horizontal, 0, vertical) * _movementSpeed;\n        _rigidbody.velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n\n        if (Input.GetKeyDown(KeyCode.Alpha1)) CastSpell(0);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) CastSpell(1);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) CastSpell(2);\n        if (Input.GetKeyDown(KeyCode.Alpha4)) CastSpell(3);\n        \n        if (Input.GetKeyDown(KeyCode.Tab)) CycleSpell();\n        if (Input.GetMouseButtonDown(0)) CastSpell(_currentSpellIndex);\n    }\n\n    private void FindTarget()\n    {\n        Collider[] enemies = Physics.OverlapSphere(transform.position, _attackRange, _enemyLayers);\n        float closestDistance = Mathf.Infinity;\n        Transform closestEnemy = null;\n\n        foreach (Collider enemy in enemies)\n        {\n            if (enemy.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, enemy.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestEnemy = enemy.transform;\n            }\n        }\n\n        _currentTarget = closestEnemy;\n        \n        if (_currentTarget != null)\n        {\n            Vector3 direction = (_currentTarget.position - transform.position).normalized;\n            direction.y = 0;\n            transform.rotation = Quaternion.LookRotation(direction);\n        }\n    }\n\n    private void CycleSpell()\n    {\n        _currentSpellIndex = (_currentSpellIndex + 1) % _spells.Length;\n    }\n\n    private void CastSpell(int spellIndex)\n    {\n        if (spellIndex < 0 || spellIndex >= _spells.Length) return;\n        \n        ElementalSpell spell = _spells[spellIndex];\n        if (spell == null) return;\n\n        if (Time.time - spell.lastCastTime < spell.cooldown) return;\n        if (_currentMana < spell.manaCost) return;\n\n        spell.lastCastTime = Time.time;\n        _currentMana = Mathf.Max(0, _currentMana - spell.manaCost);\n        OnManaChanged?.Invoke(_currentMana / _maxMana);\n\n        StartCoroutine(PerformSpellCast(spell));\n    }\n\n    private IEnumerator PerformSpellCast(ElementalSpell spell)\n    {\n        if (_animator != null)\n            _animator.SetTrigger(\"Cast\");\n\n        if (spell.castEffect != null)\n            spell.castEffect.Play();\n\n        if (spell.castSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(spell.castSound);\n\n        yield return new WaitForSeconds(0.3f);\n\n        CreateProjectile(spell);\n        OnSpellCast?.Invoke(spell.element);\n    }\n\n    private void CreateProjectile(ElementalSpell spell)\n    {\n        if (spell.projectilePrefab == null) return;\n\n        Vector3 spawnPosition = _castPoint.position;\n        Vector3 direction = _currentTarget != null ? \n            (_currentTarget.position - spawnPosition).normalized : \n            transform.forward;\n\n        GameObject projectile = Instantiate(spell.projectilePrefab, spawnPosition, Quaternion.LookRotation(direction));\n        \n        ElementalProjectile projectileScript = projectile.GetComponent<ElementalProjectile>();\n        if (projectileScript == null)\n            projectileScript = projectile.AddComponent<ElementalProjectile>();\n\n        projectileScript.Initialize(spell.element, spell.damage, spell.projectileSpeed, direction);\n    }\n\n    private IEnumerator ManaRegeneration()\n    {\n        while (!_isDead)\n        {\n            if (_currentMana < _maxMana)\n            {\n                _currentMana = Mathf.Min(_maxMana, _currentMana + _manaRegenRate * Time.deltaTime);\n                OnManaChanged?.Invoke(_currentMana / _maxMana);\n            }\n            yield return null;\n        }\n    }\n\n    private void UpdateAnimator()\n    {\n        if (_animator == null) return;\n\n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"HasTarget\", _currentTarget != null);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n\n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_animator != null)\n            _animator.SetTrigger(\"Hit\");\n\n        if (_currentHealth <= 0)\n            Die();\n    }\n\n    private void Die()\n    {\n        _isDead = true;\n        \n        if (_animator != null)\n            _animator.SetBool(\"Dead\", true);\n\n        OnDeath?.Invoke();\n        \n        Collider col = GetComponent<Collider>();\n        if (col != null)\n            col.enabled = false;\n\n        _rigidbody.isKinematic = true;\n    }\n\n    public float GetHealthPercentage() => _currentHealth / _maxHealth;\n    public float GetManaPercentage() => _currentMana / _maxMana;\n    public ElementType GetCurrentSpellElement() => _spells[_currentSpellIndex].element;\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n    }\n}\n\npublic class ElementalProjectile : MonoBehaviour\n{\n    private WizardController.ElementType _element;\n    private float _damage;\n    private float _speed;\n    private Vector3 _direction;\n    private Rigidbody _rigidbody;\n    private bool _initialized;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        \n        _rigidbody.useGravity = false;\n        Destroy(gameObject, 5f);\n    }\n\n    private void FixedUpdate()\n    {\n        if (_initialized && _rigidbody != null)\n        {\n            _rigidbody.velocity = _direction * _speed;\n        }\n    }\n\n    public void Initialize(WizardController.ElementType element, float damage, float speed, Vector3 direction)\n    {\n        _element = element;\n        _damage = damage;\n        _speed = speed;\n        _direction = direction.normalized;\n        _initialized = true;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\")) return;\n\n        ApplyElementalEffect(other);\n        CreateImpactEffect();\n        Destroy(gameObject);\n    }\n\n    private void ApplyElementalEffect(Collider target)\n    {\n        switch (_element)\n        {\n            case WizardController.ElementType.Fire:\n                ApplyBurnEffect(target);\n                break;\n            case WizardController.ElementType.Ice:\n                ApplyFreezeEffect(target);\n                break;\n            case WizardController.ElementType.Lightning:\n                ApplyShockEffect(target);\n                break;\n            case WizardController.ElementType.Earth:\n                ApplyKnockbackEffect(target);\n                break;\n        }\n    }\n\n    private void ApplyBurnEffect(Collider target)\n    {\n        // Apply damage over time\n        StartCoroutine(BurnDamage(target));\n    }\n\n    private void ApplyFreezeEffect(Collider target)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            targetRb.velocity *= 0.1f;\n        }\n    }\n\n    private void ApplyShockEffect(Collider target)\n    {\n        // Chain lightning to nearby enemies\n        Collider[] nearbyEnemies = Physics.OverlapSphere(target.transform.position, 5f);\n        foreach (Collider enemy in nearbyEnemies)\n        {\n            if (enemy != target && !enemy.CompareTag(\"Player\"))\n            {\n                // Apply reduced damage to chained targets\n            }\n        }\n    }\n\n    private void ApplyKnockbackEffect(Collider target)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockback = (target.transform.position - transform.position).normalized * 10f;\n            targetRb.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n\n    private IEnumerator BurnDamage(Collider target)\n    {\n        for (int i = 0; i < 3; i++)\n        {\n            yield return new WaitForSeconds(1f);\n            if (target != null)\n            {\n                // Apply burn damage\n            }\n        }\n    }\n\n    private void CreateImpactEffect()\n    {\n        // Create particle effect based on element type\n        GameObject effect = new GameObject(\"Impact Effect\");\n        effect.transform.position = transform.position;\n        \n        ParticleSystem particles = effect.AddComponent<ParticleSystem>();\n        var main = particles.main;\n        \n        switch (_element)\n        {\n            case WizardController.ElementType.Fire:\n                main.startColor = Color.red;\n                break;\n            case WizardController.ElementType.Ice:\n                main.startColor = Color.cyan;\n                break;\n            case WizardController.ElementType.Lightning:\n                main.startColor = Color.yellow;\n                break;\n            case WizardController.ElementType.Earth:\n                main.startColor = Color.brown;\n                break;\n        }\n        \n        Destroy(effect, 2f);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "giant that stomps ground",
      "ideal_ir": {
        "class_name": "Giant",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "stompForce",
            "type": "float",
            "default": 1000
          },
          {
            "name": "stompRadius",
            "type": "float",
            "default": 10
          },
          {
            "name": "stompCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "stompHeight",
            "type": "float",
            "default": 5
          }
        ],
        "behaviors": [
          {
            "name": "detect_target",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "look toward player"
              },
              {
                "action": "prepare stomp animation"
              }
            ]
          },
          {
            "name": "perform_stomp",
            "trigger": "when stomp cooldown is ready and target is detected",
            "actions": [
              {
                "action": "lift foot high into air"
              },
              {
                "action": "play stomp animation"
              },
              {
                "action": "slam foot down with great force"
              },
              {
                "action": "create ground impact at foot position"
              },
              {
                "action": "shake camera violently"
              },
              {
                "action": "play thunderous stomp sound"
              }
            ]
          },
          {
            "name": "ground_impact",
            "trigger": "when foot hits ground during stomp",
            "actions": [
              {
                "action": "push away all objects within stomp radius"
              },
              {
                "action": "deal damage to nearby enemies and player"
              },
              {
                "action": "create dust and debris particles"
              },
              {
                "action": "spawn shockwave effect expanding outward"
              },
              {
                "action": "start stomp cooldown timer"
              }
            ]
          },
          {
            "name": "idle_behavior",
            "trigger": "when no targets are in range",
            "actions": [
              {
                "action": "play idle breathing animation"
              },
              {
                "action": "occasionally look around slowly"
              },
              {
                "action": "shift weight from foot to foot"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GiantStomp : MonoBehaviour\n{\n    [Header(\"Stomp Settings\")]\n    [SerializeField] private float _stompInterval = 3f;\n    [SerializeField] private float _stompForce = 1000f;\n    [SerializeField] private float _stompRadius = 10f;\n    [SerializeField] private float _stompDamage = 50f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _liftHeight = 2f;\n    [SerializeField] private float _liftDuration = 1f;\n    [SerializeField] private float _stompDuration = 0.3f;\n    [SerializeField] private Transform _footTransform;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _stompEffectPrefab;\n    [SerializeField] private AudioClip _stompSound;\n    [SerializeField] private AudioClip _liftSound;\n    [SerializeField] private float _cameraShakeIntensity = 2f;\n    [SerializeField] private float _cameraShakeDuration = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStompStart;\n    public UnityEvent OnStompImpact;\n    public UnityEvent OnStompComplete;\n    \n    private AudioSource _audioSource;\n    private Vector3 _originalFootPosition;\n    private bool _isStomping = false;\n    private float _stompTimer = 0f;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private float _shakeTimer = 0f;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_footTransform == null)\n            _footTransform = transform;\n            \n        _originalFootPosition = _footTransform.position;\n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n            \n        _stompTimer = _stompInterval;\n    }\n    \n    private void Update()\n    {\n        if (!_isStomping)\n        {\n            _stompTimer -= Time.deltaTime;\n            if (_stompTimer <= 0f)\n            {\n                StartStomp();\n                _stompTimer = _stompInterval;\n            }\n        }\n        \n        UpdateCameraShake();\n    }\n    \n    private void StartStomp()\n    {\n        if (_isStomping) return;\n        \n        _isStomping = true;\n        OnStompStart?.Invoke();\n        \n        if (_liftSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_liftSound);\n            \n        StartCoroutine(StompSequence());\n    }\n    \n    private System.Collections.IEnumerator StompSequence()\n    {\n        // Lift foot\n        Vector3 startPos = _originalFootPosition;\n        Vector3 liftPos = _originalFootPosition + Vector3.up * _liftHeight;\n        \n        float elapsedTime = 0f;\n        while (elapsedTime < _liftDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime / _liftDuration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            _footTransform.position = Vector3.Lerp(startPos, liftPos, t);\n            yield return null;\n        }\n        \n        // Stomp down\n        elapsedTime = 0f;\n        while (elapsedTime < _stompDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime / _stompDuration;\n            t = t * t; // Accelerate downward\n            _footTransform.position = Vector3.Lerp(liftPos, _originalFootPosition, t);\n            yield return null;\n        }\n        \n        _footTransform.position = _originalFootPosition;\n        \n        // Impact\n        PerformStompImpact();\n        OnStompImpact?.Invoke();\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        _isStomping = false;\n        OnStompComplete?.Invoke();\n    }\n    \n    private void PerformStompImpact()\n    {\n        Vector3 stompPosition = _footTransform.position;\n        \n        // Play sound\n        if (_stompSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_stompSound);\n            \n        // Spawn effect\n        if (_stompEffectPrefab != null)\n            Instantiate(_stompEffectPrefab, stompPosition, Quaternion.identity);\n            \n        // Camera shake\n        StartCameraShake();\n        \n        // Find affected objects\n        Collider[] hitColliders = Physics.OverlapSphere(stompPosition, _stompRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Apply force to rigidbodies\n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - stompPosition).normalized;\n                float distance = Vector3.Distance(hitCollider.transform.position, stompPosition);\n                float forceMagnitude = _stompForce * (1f - distance / _stompRadius);\n                \n                rb.AddForce(direction * forceMagnitude + Vector3.up * forceMagnitude * 0.5f, ForceMode.Impulse);\n            }\n            \n            // Damage players\n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                // Send damage message if the player has a method to receive it\n                hitCollider.SendMessage(\"TakeDamage\", _stompDamage, SendMessageOptions.DontRequireReceiver);\n                \n                // Alternative: Use a simple health component if it exists\n                var healthComponent = hitCollider.GetComponent<SimpleHealth>();\n                if (healthComponent != null)\n                {\n                    healthComponent.TakeDamage(_stompDamage);\n                }\n            }\n            \n            // Destroy destructible objects\n            if (hitCollider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hitCollider.gameObject);\n            }\n        }\n    }\n    \n    private void StartCameraShake()\n    {\n        if (_mainCamera != null)\n        {\n            _shakeTimer = _cameraShakeDuration;\n        }\n    }\n    \n    private void UpdateCameraShake()\n    {\n        if (_shakeTimer > 0f && _mainCamera != null)\n        {\n            _shakeTimer -= Time.deltaTime;\n            \n            float shakeAmount = _cameraShakeIntensity * (_shakeTimer / _cameraShakeDuration);\n            Vector3 shakeOffset = Random.insideUnitSphere * shakeAmount;\n            shakeOffset.z = 0f; // Keep camera on same Z plane\n            \n            _mainCamera.transform.position = _originalCameraPosition + shakeOffset;\n            \n            if (_shakeTimer <= 0f)\n            {\n                _mainCamera.transform.position = _originalCameraPosition;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 center = _footTransform != null ? _footTransform.position : transform.position;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, _stompRadius);\n        \n        if (_footTransform != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(center + Vector3.up * _liftHeight, Vector3.one * 0.5f);\n        }\n    }\n}\n\n// Simple health component that can be used with the stomp system\npublic class SimpleHealth : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n            Destroy(gameObject);\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + amount);\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "snake that slithers and bites",
      "ideal_ir": {
        "class_name": "Snake",
        "components": [
          "Rigidbody2D",
          "Collider2D",
          "Animator"
        ],
        "fields": [
          {
            "name": "slitherSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "biteRange",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "biteDamage",
            "type": "int",
            "default": 10
          },
          {
            "name": "biteForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "patrolDistance",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 4.0
          }
        ],
        "behaviors": [
          {
            "name": "slither_patrol",
            "trigger": "when no target is detected",
            "actions": [
              {
                "action": "move in a winding serpentine pattern"
              },
              {
                "action": "play slithering animation"
              },
              {
                "action": "change direction randomly within patrol area"
              }
            ]
          },
          {
            "name": "detect_target",
            "trigger": "when player or prey enters detection range",
            "actions": [
              {
                "action": "stop patrol behavior"
              },
              {
                "action": "face toward detected target"
              },
              {
                "action": "play alert animation"
              }
            ]
          },
          {
            "name": "chase_target",
            "trigger": "when target is detected and within range",
            "actions": [
              {
                "action": "slither toward target at increased speed"
              },
              {
                "action": "play aggressive slithering animation"
              },
              {
                "action": "follow target movement"
              }
            ]
          },
          {
            "name": "bite_attack",
            "trigger": "when target is within bite range",
            "actions": [
              {
                "action": "lunge forward quickly"
              },
              {
                "action": "play bite animation"
              },
              {
                "action": "deal damage to target"
              },
              {
                "action": "apply knockback force to target"
              }
            ]
          },
          {
            "name": "retreat_after_bite",
            "trigger": "when bite attack completes",
            "actions": [
              {
                "action": "move backward briefly"
              },
              {
                "action": "return to chase behavior after short delay"
              }
            ]
          },
          {
            "name": "lose_target",
            "trigger": "when target moves beyond detection range",
            "actions": [
              {
                "action": "stop chasing"
              },
              {
                "action": "return to patrol behavior"
              },
              {
                "action": "play idle animation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Snake : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _turnSpeed = 90f;\n    [SerializeField] private float _slitherAmplitude = 0.5f;\n    [SerializeField] private float _slitherFrequency = 2f;\n    \n    [Header(\"Body\")]\n    [SerializeField] private GameObject _bodySegmentPrefab;\n    [SerializeField] private int _initialBodySegments = 5;\n    [SerializeField] private float _segmentSpacing = 0.8f;\n    \n    [Header(\"Bite\")]\n    [SerializeField] private float _biteRange = 1.5f;\n    [SerializeField] private float _biteCooldown = 2f;\n    [SerializeField] private int _biteDamage = 10;\n    [SerializeField] private LayerMask _biteTargetMask = -1;\n    [SerializeField] private AudioClip _biteSound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _chaseSpeed = 4f;\n    \n    private List<Transform> _bodySegments = new List<Transform>();\n    private List<Vector3> _positionHistory = new List<Vector3>();\n    private Transform _target;\n    private float _lastBiteTime;\n    private float _slitherTime;\n    private Vector3 _wanderDirection;\n    private float _wanderTimer;\n    private AudioSource _audioSource;\n    private bool _isChasing;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        CreateBodySegments();\n        _wanderDirection = transform.forward;\n        _wanderTimer = Random.Range(2f, 5f);\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        HandleMovement();\n        UpdateSlither();\n        UpdateBodySegments();\n        CheckForBite();\n    }\n    \n    private void CreateBodySegments()\n    {\n        if (_bodySegmentPrefab == null) return;\n        \n        for (int i = 0; i < _initialBodySegments; i++)\n        {\n            Vector3 segmentPosition = transform.position - transform.forward * (i + 1) * _segmentSpacing;\n            GameObject segment = Instantiate(_bodySegmentPrefab, segmentPosition, transform.rotation);\n            _bodySegments.Add(segment.transform);\n            _positionHistory.Add(segmentPosition);\n        }\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRange, _biteTargetMask);\n        Transform closestTarget = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = target.transform;\n            }\n        }\n        \n        _target = closestTarget;\n        _isChasing = _target != null;\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 moveDirection;\n        float currentSpeed;\n        \n        if (_isChasing && _target != null)\n        {\n            moveDirection = (_target.position - transform.position).normalized;\n            currentSpeed = _chaseSpeed;\n        }\n        else\n        {\n            _wanderTimer -= Time.deltaTime;\n            if (_wanderTimer <= 0f)\n            {\n                _wanderDirection = Quaternion.Euler(0, Random.Range(-45f, 45f), 0) * transform.forward;\n                _wanderTimer = Random.Range(2f, 5f);\n            }\n            moveDirection = _wanderDirection;\n            currentSpeed = _moveSpeed;\n        }\n        \n        if (moveDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _turnSpeed * Time.deltaTime);\n        }\n        \n        transform.Translate(Vector3.forward * currentSpeed * Time.deltaTime);\n    }\n    \n    private void UpdateSlither()\n    {\n        _slitherTime += Time.deltaTime * _slitherFrequency;\n        float slitherOffset = Mathf.Sin(_slitherTime) * _slitherAmplitude;\n        \n        Vector3 slitherPosition = transform.position + transform.right * slitherOffset;\n        transform.position = slitherPosition;\n        \n        _positionHistory.Insert(0, transform.position);\n        \n        int maxHistoryLength = _bodySegments.Count * 5;\n        if (_positionHistory.Count > maxHistoryLength)\n        {\n            _positionHistory.RemoveRange(maxHistoryLength, _positionHistory.Count - maxHistoryLength);\n        }\n    }\n    \n    private void UpdateBodySegments()\n    {\n        for (int i = 0; i < _bodySegments.Count; i++)\n        {\n            if (_bodySegments[i] == null) continue;\n            \n            int historyIndex = (i + 1) * 5;\n            if (historyIndex < _positionHistory.Count)\n            {\n                Vector3 targetPosition = _positionHistory[historyIndex];\n                _bodySegments[i].position = Vector3.Lerp(_bodySegments[i].position, targetPosition, Time.deltaTime * 10f);\n                \n                if (historyIndex + 5 < _positionHistory.Count)\n                {\n                    Vector3 direction = (_positionHistory[historyIndex] - _positionHistory[historyIndex + 5]).normalized;\n                    if (direction != Vector3.zero)\n                    {\n                        _bodySegments[i].rotation = Quaternion.LookRotation(direction);\n                    }\n                }\n            }\n        }\n    }\n    \n    private void CheckForBite()\n    {\n        if (Time.time - _lastBiteTime < _biteCooldown) return;\n        if (_target == null) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        if (distanceToTarget <= _biteRange)\n        {\n            Vector3 directionToTarget = (_target.position - transform.position).normalized;\n            float angle = Vector3.Angle(transform.forward, directionToTarget);\n            \n            if (angle < 45f)\n            {\n                PerformBite();\n            }\n        }\n    }\n    \n    private void PerformBite()\n    {\n        _lastBiteTime = Time.time;\n        \n        if (_biteSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_biteSound);\n        }\n        \n        if (_target != null)\n        {\n            if (_target.CompareTag(\"Player\"))\n            {\n                _target.SendMessage(\"TakeDamage\", _biteDamage, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            Rigidbody targetRb = _target.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 knockbackDirection = (_target.position - transform.position).normalized;\n                targetRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n            }\n        }\n        \n        transform.position += transform.forward * 0.3f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _biteRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_target != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _target = other.transform;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "scorpion with poison tail",
      "ideal_ir": {
        "class_name": "PoisonScorpion",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "movementSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "attackRange",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "poisonDamage",
            "type": "int",
            "default": 15
          },
          {
            "name": "poisonDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "attackCooldown",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "health",
            "type": "int",
            "default": 80
          },
          {
            "name": "isAttacking",
            "type": "bool",
            "default": false
          },
          {
            "name": "lastAttackTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "patrol_behavior",
            "trigger": "when no player is detected within range",
            "actions": [
              {
                "action": "move forward slowly in current direction"
              },
              {
                "action": "play walking animation"
              },
              {
                "action": "randomly change direction occasionally"
              }
            ]
          },
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "stop patrolling"
              },
              {
                "action": "face toward player"
              },
              {
                "action": "play alert animation"
              },
              {
                "action": "increase movement speed"
              }
            ]
          },
          {
            "name": "chase_player",
            "trigger": "when player is within detection range but outside attack range",
            "actions": [
              {
                "action": "move toward player at increased speed"
              },
              {
                "action": "play aggressive walking animation"
              },
              {
                "action": "keep tail raised and ready"
              }
            ]
          },
          {
            "name": "poison_sting_attack",
            "trigger": "when player is within attack range and attack cooldown has elapsed",
            "actions": [
              {
                "action": "stop moving"
              },
              {
                "action": "play tail strike animation"
              },
              {
                "action": "deal poison damage to player"
              },
              {
                "action": "apply poison effect that damages over time"
              },
              {
                "action": "start attack cooldown timer"
              },
              {
                "action": "play attack sound effect"
              }
            ]
          },
          {
            "name": "defensive_stance",
            "trigger": "when health drops below half",
            "actions": [
              {
                "action": "raise claws defensively"
              },
              {
                "action": "move more cautiously"
              },
              {
                "action": "increase attack frequency"
              },
              {
                "action": "play wounded animation"
              }
            ]
          },
          {
            "name": "death_behavior",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "play death animation"
              },
              {
                "action": "curl up tail"
              },
              {
                "action": "disable collision"
              },
              {
                "action": "fade out after delay"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Scorpion : MonoBehaviour\n{\n    [System.Serializable]\n    public class ScorpionEvents\n    {\n        public UnityEvent OnAttack;\n        public UnityEvent OnPlayerHit;\n        public UnityEvent OnDeath;\n    }\n\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _wanderRadius = 5f;\n    [SerializeField] private float _wanderTimer = 3f;\n\n    [Header(\"Combat\")]\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _poisonDamage = 10f;\n    [SerializeField] private float _poisonDuration = 5f;\n    [SerializeField] private int _maxHealth = 50;\n\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Transform _tailTransform;\n    [SerializeField] private float _tailAttackHeight = 1.5f;\n    [SerializeField] private float _tailAttackSpeed = 5f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _poisonEffect;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n\n    [Header(\"Events\")]\n    [SerializeField] private ScorpionEvents _events;\n\n    private enum ScorpionState\n    {\n        Wandering,\n        Chasing,\n        Attacking,\n        Dead\n    }\n\n    private ScorpionState _currentState = ScorpionState.Wandering;\n    private Transform _player;\n    private Vector3 _wanderTarget;\n    private Vector3 _initialPosition;\n    private float _lastAttackTime;\n    private float _wanderTime;\n    private int _currentHealth;\n    private bool _isAttacking;\n    private Vector3 _tailOriginalPosition;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _initialPosition = transform.position;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_tailTransform != null)\n        {\n            _tailOriginalPosition = _tailTransform.localPosition;\n        }\n        \n        SetNewWanderTarget();\n    }\n\n    private void Update()\n    {\n        if (_currentState == ScorpionState.Dead) return;\n\n        DetectPlayer();\n        UpdateState();\n        HandleMovement();\n        HandleTailAnimation();\n    }\n\n    private void DetectPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n        \n        if (playersInRange.Length > 0)\n        {\n            Transform closestPlayer = null;\n            float closestDistance = float.MaxValue;\n            \n            foreach (var playerCollider in playersInRange)\n            {\n                if (playerCollider.CompareTag(\"Player\"))\n                {\n                    float distance = Vector3.Distance(transform.position, playerCollider.transform.position);\n                    if (distance < closestDistance)\n                    {\n                        closestDistance = distance;\n                        closestPlayer = playerCollider.transform;\n                    }\n                }\n            }\n            \n            _player = closestPlayer;\n        }\n        else\n        {\n            _player = null;\n        }\n    }\n\n    private void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case ScorpionState.Wandering:\n                if (_player != null)\n                {\n                    _currentState = ScorpionState.Chasing;\n                }\n                else if (Vector3.Distance(transform.position, _wanderTarget) < 0.5f)\n                {\n                    SetNewWanderTarget();\n                }\n                break;\n\n            case ScorpionState.Chasing:\n                if (_player == null)\n                {\n                    _currentState = ScorpionState.Wandering;\n                    SetNewWanderTarget();\n                }\n                else if (Vector3.Distance(transform.position, _player.position) <= _attackRange)\n                {\n                    if (Time.time - _lastAttackTime >= _attackCooldown)\n                    {\n                        _currentState = ScorpionState.Attacking;\n                        StartAttack();\n                    }\n                }\n                break;\n\n            case ScorpionState.Attacking:\n                if (!_isAttacking)\n                {\n                    _currentState = _player != null ? ScorpionState.Chasing : ScorpionState.Wandering;\n                }\n                break;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (_currentState == ScorpionState.Attacking || _isAttacking) return;\n\n        Vector3 targetPosition = _currentState == ScorpionState.Chasing ? _player.position : _wanderTarget;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            \n            Vector3 movement = direction * _moveSpeed * Time.deltaTime;\n            _rigidbody.MovePosition(transform.position + movement);\n        }\n\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsMoving\", direction != Vector3.zero);\n        }\n    }\n\n    private void SetNewWanderTarget()\n    {\n        Vector2 randomDirection = Random.insideUnitCircle * _wanderRadius;\n        _wanderTarget = _initialPosition + new Vector3(randomDirection.x, 0, randomDirection.y);\n        _wanderTime = Time.time + _wanderTimer;\n    }\n\n    private void StartAttack()\n    {\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Attack\");\n        }\n        \n        if (_audioSource != null && _attackSound != null)\n        {\n            _audioSource.PlayOneShot(_attackSound);\n        }\n        \n        _events?.OnAttack?.Invoke();\n        \n        Invoke(nameof(ExecuteAttack), 0.5f);\n        Invoke(nameof(EndAttack), 1f);\n    }\n\n    private void ExecuteAttack()\n    {\n        if (_player != null && Vector3.Distance(transform.position, _player.position) <= _attackRange)\n        {\n            ApplyPoisonToPlayer(_player.gameObject);\n            _events?.OnPlayerHit?.Invoke();\n        }\n    }\n\n    private void EndAttack()\n    {\n        _isAttacking = false;\n    }\n\n    private void ApplyPoisonToPlayer(GameObject player)\n    {\n        PoisonEffect poisonComponent = player.GetComponent<PoisonEffect>();\n        if (poisonComponent == null)\n        {\n            poisonComponent = player.AddComponent<PoisonEffect>();\n        }\n        \n        poisonComponent.ApplyPoison(_poisonDamage, _poisonDuration);\n        \n        if (_poisonEffect != null)\n        {\n            GameObject effect = Instantiate(_poisonEffect, player.transform.position, Quaternion.identity);\n            effect.transform.SetParent(player.transform);\n            Destroy(effect, _poisonDuration);\n        }\n    }\n\n    private void HandleTailAnimation()\n    {\n        if (_tailTransform == null) return;\n\n        if (_isAttacking)\n        {\n            float attackProgress = Mathf.PingPong(Time.time * _tailAttackSpeed, 1f);\n            Vector3 targetPosition = _tailOriginalPosition + Vector3.up * _tailAttackHeight * attackProgress;\n            _tailTransform.localPosition = Vector3.Lerp(_tailTransform.localPosition, targetPosition, Time.deltaTime * 10f);\n        }\n        else\n        {\n            _tailTransform.localPosition = Vector3.Lerp(_tailTransform.localPosition, _tailOriginalPosition, Time.deltaTime * 5f);\n        }\n    }\n\n    public void TakeDamage(int damage)\n    {\n        if (_currentState == ScorpionState.Dead) return;\n\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        _currentState = ScorpionState.Dead;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Death\");\n        }\n        \n        if (_audioSource != null && _deathSound != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        _events?.OnDeath?.Invoke();\n        \n        GetComponent<Collider>().enabled = false;\n        _rigidbody.isKinematic = true;\n        \n        Destroy(gameObject, 3f);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState != ScorpionState.Dead)\n        {\n            if (Vector3.Distance(transform.position, other.transform.position) <= _attackRange)\n            {\n                if (Time.time - _lastAttackTime >= _attackCooldown)\n                {\n                    _currentState = ScorpionState.Attacking;\n                    StartAttack();\n                }\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_initialPosition, _wanderRadius);\n    }\n\n    [System.Serializable]\n    public class PoisonEffect : MonoBehaviour\n    {\n        private float _damagePerSecond;\n        private float _duration;\n        private float _startTime;\n        private bool _isActive;\n\n        public void ApplyPoison(float damage, float duration)\n        {\n            _damagePerSecond = damage / duration;\n            _duration = duration;\n            _startTime = Time.time;\n            _isActive = true;\n        }\n\n        private void Update()\n        {\n            if (!_isActive) return;\n\n            if (Time.time - _startTime >= _duration)\n            {\n                _isActive = false;\n                Destroy(this);\n                return;\n            }\n\n            // Apply poison damage (you would typically reduce player health here)\n            // Since we can't reference PlayerHealth, this is a placeholder\n            Debug.Log($\"Poison damage applied: {_damagePerSecond * Time.deltaTime}\");\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "crab that moves sideways",
      "ideal_ir": {
        "class_name": "SidewaysCrab",
        "components": [
          "Transform",
          "Rigidbody2D",
          "Collider2D",
          "SpriteRenderer"
        ],
        "fields": [
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "changeDirectionTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "movingRight",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "sideways_movement",
            "trigger": "continuously during gameplay",
            "actions": [
              {
                "action": "move horizontally in current direction at move speed"
              },
              {
                "action": "face the direction of movement"
              }
            ]
          },
          {
            "name": "change_direction",
            "trigger": "when change direction timer expires",
            "actions": [
              {
                "action": "reverse horizontal movement direction"
              },
              {
                "action": "reset change direction timer"
              }
            ]
          },
          {
            "name": "wall_collision",
            "trigger": "when colliding with wall or obstacle",
            "actions": [
              {
                "action": "immediately reverse horizontal movement direction"
              },
              {
                "action": "reset change direction timer"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SidewaysCrab : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _changeDirectionTime = 3f;\n    [SerializeField] private bool _startMovingRight = true;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Wall Detection\")]\n    [SerializeField] private Transform _wallCheckPoint;\n    [SerializeField] private float _wallCheckDistance = 0.5f;\n    [SerializeField] private LayerMask _wallLayerMask = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    private Rigidbody2D _rigidbody2D;\n    private SpriteRenderer _spriteRenderer;\n    private bool _movingRight;\n    private float _directionTimer;\n    private bool _isGrounded;\n    private bool _wallDetected;\n    \n    private void Start()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        _movingRight = _startMovingRight;\n        _directionTimer = _changeDirectionTime;\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheck = new GameObject(\"GroundCheck\");\n            groundCheck.transform.SetParent(transform);\n            groundCheck.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheckPoint = groundCheck.transform;\n        }\n        \n        if (_wallCheckPoint == null)\n        {\n            GameObject wallCheck = new GameObject(\"WallCheck\");\n            wallCheck.transform.SetParent(transform);\n            wallCheck.transform.localPosition = new Vector3(0.5f, 0, 0);\n            _wallCheckPoint = wallCheck.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        _directionTimer -= Time.deltaTime;\n        \n        if (_directionTimer <= 0f)\n        {\n            ChangeDirection();\n            _directionTimer = _changeDirectionTime;\n        }\n        \n        CheckGround();\n        CheckWall();\n        \n        if (!_isGrounded || _wallDetected)\n        {\n            ChangeDirection();\n        }\n        \n        UpdateAnimation();\n    }\n    \n    private void FixedUpdate()\n    {\n        MoveCrab();\n    }\n    \n    private void MoveCrab()\n    {\n        if (_rigidbody2D == null) return;\n        \n        float horizontalMovement = _movingRight ? _moveSpeed : -_moveSpeed;\n        _rigidbody2D.velocity = new Vector2(horizontalMovement, _rigidbody2D.velocity.y);\n        \n        UpdateSpriteDirection();\n    }\n    \n    private void CheckGround()\n    {\n        if (_groundCheckPoint == null) return;\n        \n        Vector3 checkPosition = _groundCheckPoint.position;\n        if (_movingRight)\n            checkPosition += Vector3.right * 0.3f;\n        else\n            checkPosition += Vector3.left * 0.3f;\n            \n        _isGrounded = Physics2D.Raycast(checkPosition, Vector2.down, _groundCheckDistance, _groundLayerMask);\n        \n        Debug.DrawRay(checkPosition, Vector2.down * _groundCheckDistance, _isGrounded ? Color.green : Color.red);\n    }\n    \n    private void CheckWall()\n    {\n        if (_wallCheckPoint == null) return;\n        \n        Vector2 direction = _movingRight ? Vector2.right : Vector2.left;\n        _wallDetected = Physics2D.Raycast(_wallCheckPoint.position, direction, _wallCheckDistance, _wallLayerMask);\n        \n        Debug.DrawRay(_wallCheckPoint.position, direction * _wallCheckDistance, _wallDetected ? Color.red : Color.green);\n    }\n    \n    private void ChangeDirection()\n    {\n        _movingRight = !_movingRight;\n        _directionTimer = _changeDirectionTime;\n        \n        if (_wallCheckPoint != null)\n        {\n            Vector3 wallCheckPos = _wallCheckPoint.localPosition;\n            wallCheckPos.x = Mathf.Abs(wallCheckPos.x) * (_movingRight ? 1 : -1);\n            _wallCheckPoint.localPosition = wallCheckPos;\n        }\n    }\n    \n    private void UpdateSpriteDirection()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.flipX = !_movingRight;\n        }\n    }\n    \n    private void UpdateAnimation()\n    {\n        if (_animator != null)\n        {\n            bool isMoving = Mathf.Abs(_rigidbody2D.velocity.x) > 0.1f;\n            _animator.SetBool(\"IsMoving\", isMoving);\n            _animator.SetBool(\"MovingRight\", _movingRight);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ChangeDirection();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Vector3 groundPos = _groundCheckPoint.position;\n            if (_movingRight)\n                groundPos += Vector3.right * 0.3f;\n            else\n                groundPos += Vector3.left * 0.3f;\n            Gizmos.DrawLine(groundPos, groundPos + Vector3.down * _groundCheckDistance);\n        }\n        \n        if (_wallCheckPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Vector3 direction = _movingRight ? Vector3.right : Vector3.left;\n            Gizmos.DrawLine(_wallCheckPoint.position, _wallCheckPoint.position + direction * _wallCheckDistance);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "fish that jumps from water",
      "ideal_ir": {
        "class_name": "JumpingFish",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "jumpForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "jumpCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "swimSpeed",
            "type": "float",
            "default": 5
          },
          {
            "name": "waterLevel",
            "type": "float",
            "default": 0
          },
          {
            "name": "isInWater",
            "type": "bool",
            "default": true
          },
          {
            "name": "lastJumpTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "swim_underwater",
            "trigger": "when fish is below water level",
            "actions": [
              {
                "action": "move randomly in horizontal directions at swim speed"
              },
              {
                "action": "apply slight upward movement toward water surface"
              }
            ]
          },
          {
            "name": "jump_from_water",
            "trigger": "when fish reaches water surface and jump cooldown has elapsed",
            "actions": [
              {
                "action": "apply strong upward force to launch fish into air"
              },
              {
                "action": "record current time as last jump time"
              },
              {
                "action": "mark fish as no longer in water"
              }
            ]
          },
          {
            "name": "arc_through_air",
            "trigger": "when fish is above water level",
            "actions": [
              {
                "action": "allow gravity to pull fish downward"
              },
              {
                "action": "maintain forward momentum from jump"
              }
            ]
          },
          {
            "name": "splash_back_into_water",
            "trigger": "when fish falls back below water level",
            "actions": [
              {
                "action": "mark fish as back in water"
              },
              {
                "action": "reduce vertical velocity to simulate water resistance"
              },
              {
                "action": "resume swimming behavior"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class JumpingFish : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _jumpInterval = 3f;\n    [SerializeField] private float _jumpVariation = 1f;\n    [SerializeField] private float _waterLevel = 0f;\n    [SerializeField] private AnimationCurve _jumpCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _swimSpeed = 2f;\n    [SerializeField] private float _swimRadius = 5f;\n    [SerializeField] private bool _randomSwimming = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _rotationSpeed = 180f;\n    [SerializeField] private float _splashEffectDuration = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _startPosition;\n    private Vector3 _swimTarget;\n    private float _nextJumpTime;\n    private bool _isJumping;\n    private bool _isInWater;\n    private float _jumpStartTime;\n    private Vector3 _jumpStartPosition;\n    private Vector3 _jumpTargetPosition;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _startPosition = transform.position;\n        _swimTarget = _startPosition;\n        _nextJumpTime = Time.time + Random.Range(_jumpInterval - _jumpVariation, _jumpInterval + _jumpVariation);\n        _isInWater = transform.position.y <= _waterLevel;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupRigidbody();\n        GenerateNewSwimTarget();\n    }\n    \n    private void SetupRigidbody()\n    {\n        _rigidbody.drag = _isInWater ? 5f : 0.5f;\n        _rigidbody.angularDrag = 3f;\n        _rigidbody.useGravity = !_isInWater;\n    }\n    \n    private void Update()\n    {\n        CheckWaterState();\n        HandleJumping();\n        HandleSwimming();\n        HandleRotation();\n    }\n    \n    private void CheckWaterState()\n    {\n        bool wasInWater = _isInWater;\n        _isInWater = transform.position.y <= _waterLevel;\n        \n        if (wasInWater != _isInWater)\n        {\n            SetupRigidbody();\n            \n            if (_isInWater)\n            {\n                OnEnterWater();\n            }\n            else\n            {\n                OnExitWater();\n            }\n        }\n    }\n    \n    private void OnEnterWater()\n    {\n        PlaySplashEffect();\n        PlaySound(_splashSound);\n        _isJumping = false;\n        GenerateNewSwimTarget();\n    }\n    \n    private void OnExitWater()\n    {\n        PlaySplashEffect();\n        PlaySound(_jumpSound);\n    }\n    \n    private void HandleJumping()\n    {\n        if (_isInWater && !_isJumping && Time.time >= _nextJumpTime)\n        {\n            StartJump();\n        }\n    }\n    \n    private void StartJump()\n    {\n        _isJumping = true;\n        _jumpStartTime = Time.time;\n        _jumpStartPosition = transform.position;\n        \n        Vector3 jumpDirection = Vector3.up + Random.insideUnitSphere * 0.3f;\n        jumpDirection.y = Mathf.Abs(jumpDirection.y);\n        jumpDirection.Normalize();\n        \n        _rigidbody.velocity = jumpDirection * _jumpForce;\n        \n        _nextJumpTime = Time.time + Random.Range(_jumpInterval - _jumpVariation, _jumpInterval + _jumpVariation);\n    }\n    \n    private void HandleSwimming()\n    {\n        if (!_isInWater || _isJumping) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _swimTarget);\n        \n        if (distanceToTarget < 0.5f)\n        {\n            GenerateNewSwimTarget();\n        }\n        \n        Vector3 direction = (_swimTarget - transform.position).normalized;\n        direction.y = 0f;\n        \n        _rigidbody.AddForce(direction * _swimSpeed, ForceMode.Force);\n        \n        Vector3 velocity = _rigidbody.velocity;\n        velocity.y = Mathf.Lerp(velocity.y, 0f, Time.deltaTime * 2f);\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void GenerateNewSwimTarget()\n    {\n        if (_randomSwimming)\n        {\n            Vector2 randomCircle = Random.insideUnitCircle * _swimRadius;\n            _swimTarget = _startPosition + new Vector3(randomCircle.x, 0f, randomCircle.y);\n        }\n        else\n        {\n            float angle = Time.time * 0.5f;\n            _swimTarget = _startPosition + new Vector3(\n                Mathf.Cos(angle) * _swimRadius,\n                0f,\n                Mathf.Sin(angle) * _swimRadius\n            );\n        }\n        \n        _swimTarget.y = _waterLevel - 0.5f;\n    }\n    \n    private void HandleRotation()\n    {\n        Vector3 targetDirection;\n        \n        if (_isInWater && !_isJumping)\n        {\n            targetDirection = (_swimTarget - transform.position).normalized;\n            if (targetDirection.magnitude < 0.1f)\n            {\n                targetDirection = transform.forward;\n            }\n        }\n        else\n        {\n            targetDirection = _rigidbody.velocity.normalized;\n            if (targetDirection.magnitude < 0.1f)\n            {\n                targetDirection = transform.forward;\n            }\n        }\n        \n        if (targetDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n            transform.rotation = Quaternion.RotateTowards(\n                transform.rotation,\n                targetRotation,\n                _rotationSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void PlaySplashEffect()\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = new Vector3(transform.position.x, _waterLevel, transform.position.z);\n            _splashEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_startPosition, _swimRadius);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawLine(new Vector3(-10f, _waterLevel, -10f), new Vector3(10f, _waterLevel, 10f));\n        \n        if (_isInWater)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _swimTarget);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "torch that lights up area",
      "ideal_ir": {
        "class_name": "Torch",
        "components": [
          "Light"
        ],
        "fields": [
          {
            "name": "lightIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "lightRange",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "flickerSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isLit",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "illuminate_area",
            "trigger": "when torch is lit",
            "actions": [
              {
                "action": "emit light with specified intensity and range"
              },
              {
                "action": "cast warm orange colored light"
              }
            ]
          },
          {
            "name": "flicker_effect",
            "trigger": "continuously while lit",
            "actions": [
              {
                "action": "randomly vary light intensity slightly"
              },
              {
                "action": "create flickering flame effect"
              }
            ]
          },
          {
            "name": "toggle_torch",
            "trigger": "when player interacts with torch",
            "actions": [
              {
                "action": "switch between lit and unlit states"
              },
              {
                "action": "turn light on or off based on current state"
              }
            ]
          },
          {
            "name": "extinguish_torch",
            "trigger": "when torch becomes unlit",
            "actions": [
              {
                "action": "turn off light component"
              },
              {
                "action": "stop flickering effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Torch : MonoBehaviour\n{\n    [Header(\"Light Settings\")]\n    [SerializeField] private Light torchLight;\n    [SerializeField] private float lightIntensity = 2f;\n    [SerializeField] private float lightRange = 10f;\n    [SerializeField] private Color lightColor = Color.orange;\n    \n    [Header(\"Flame Effect\")]\n    [SerializeField] private ParticleSystem flameParticles;\n    [SerializeField] private AudioSource fireAudioSource;\n    [SerializeField] private AudioClip fireSound;\n    \n    [Header(\"Flickering\")]\n    [SerializeField] private bool enableFlickering = true;\n    [SerializeField] private float flickerSpeed = 5f;\n    [SerializeField] private float flickerIntensity = 0.3f;\n    [SerializeField] private AnimationCurve flickerCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool canBeToggled = true;\n    [SerializeField] private KeyCode toggleKey = KeyCode.E;\n    [SerializeField] private float interactionRange = 3f;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private bool useFuelSystem = false;\n    [SerializeField] private float maxFuelTime = 300f;\n    [SerializeField] private float currentFuel = 300f;\n    \n    private bool _isLit = true;\n    private float _baseIntensity;\n    private float _flickerTime;\n    private Transform _playerTransform;\n    private bool _playerInRange;\n    \n    private void Start()\n    {\n        SetupTorchLight();\n        SetupAudio();\n        SetupParticles();\n        FindPlayer();\n        \n        _baseIntensity = lightIntensity;\n        currentFuel = maxFuelTime;\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        UpdateFlickering();\n        UpdateFuelSystem();\n    }\n    \n    private void SetupTorchLight()\n    {\n        if (torchLight == null)\n        {\n            torchLight = GetComponentInChildren<Light>();\n            if (torchLight == null)\n            {\n                GameObject lightObject = new GameObject(\"TorchLight\");\n                lightObject.transform.SetParent(transform);\n                lightObject.transform.localPosition = Vector3.up * 0.5f;\n                torchLight = lightObject.AddComponent<Light>();\n            }\n        }\n        \n        torchLight.type = LightType.Point;\n        torchLight.intensity = lightIntensity;\n        torchLight.range = lightRange;\n        torchLight.color = lightColor;\n        torchLight.shadows = LightShadows.Soft;\n    }\n    \n    private void SetupAudio()\n    {\n        if (fireAudioSource == null)\n        {\n            fireAudioSource = GetComponent<AudioSource>();\n            if (fireAudioSource == null)\n            {\n                fireAudioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        fireAudioSource.clip = fireSound;\n        fireAudioSource.loop = true;\n        fireAudioSource.volume = 0.3f;\n        fireAudioSource.spatialBlend = 1f;\n        \n        if (_isLit && fireSound != null)\n        {\n            fireAudioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (flameParticles == null)\n        {\n            flameParticles = GetComponentInChildren<ParticleSystem>();\n        }\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = _isLit;\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (!canBeToggled || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        _playerInRange = distanceToPlayer <= interactionRange;\n        \n        if (_playerInRange && Input.GetKeyDown(toggleKey))\n        {\n            ToggleTorch();\n        }\n    }\n    \n    private void UpdateFlickering()\n    {\n        if (!enableFlickering || !_isLit) return;\n        \n        _flickerTime += Time.deltaTime * flickerSpeed;\n        float flickerValue = flickerCurve.Evaluate(Mathf.PingPong(_flickerTime, 1f));\n        float flickerOffset = (flickerValue - 0.5f) * flickerIntensity;\n        \n        torchLight.intensity = _baseIntensity + flickerOffset;\n        \n        if (flameParticles != null)\n        {\n            var velocityOverLifetime = flameParticles.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;\n            velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(2f + flickerOffset * 0.5f);\n        }\n    }\n    \n    private void UpdateFuelSystem()\n    {\n        if (!useFuelSystem || !_isLit) return;\n        \n        currentFuel -= Time.deltaTime;\n        \n        if (currentFuel <= 0f)\n        {\n            currentFuel = 0f;\n            ExtinguishTorch();\n        }\n        else if (currentFuel < maxFuelTime * 0.1f)\n        {\n            // Torch is running low on fuel, increase flickering\n            flickerIntensity = Mathf.Lerp(0.3f, 0.8f, 1f - (currentFuel / (maxFuelTime * 0.1f)));\n        }\n    }\n    \n    public void ToggleTorch()\n    {\n        if (_isLit)\n        {\n            ExtinguishTorch();\n        }\n        else\n        {\n            LightTorch();\n        }\n    }\n    \n    public void LightTorch()\n    {\n        if (useFuelSystem && currentFuel <= 0f) return;\n        \n        _isLit = true;\n        torchLight.enabled = true;\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = true;\n            flameParticles.Play();\n        }\n        \n        if (fireAudioSource != null && fireSound != null)\n        {\n            fireAudioSource.Play();\n        }\n    }\n    \n    public void ExtinguishTorch()\n    {\n        _isLit = false;\n        torchLight.enabled = false;\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = false;\n            flameParticles.Stop();\n        }\n        \n        if (fireAudioSource != null)\n        {\n            fireAudioSource.Stop();\n        }\n    }\n    \n    public void AddFuel(float fuelAmount)\n    {\n        if (!useFuelSystem) return;\n        \n        currentFuel = Mathf.Min(currentFuel + fuelAmount, maxFuelTime);\n    }\n    \n    public bool IsLit()\n    {\n        return _isLit;\n    }\n    \n    public float GetFuelPercentage()\n    {\n        if (!useFuelSystem) return 1f;\n        return currentFuel / maxFuelTime;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw light range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, lightRange);\n        \n        // Draw interaction range\n        if (canBeToggled)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, interactionRange);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "water current that pushes player",
      "ideal_ir": {
        "class_name": "WaterCurrent",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "currentStrength",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "currentDirection",
            "type": "Vector3",
            "default": "Vector3.right"
          }
        ],
        "behaviors": [
          {
            "name": "push_player",
            "trigger": "when player enters water current area",
            "actions": [
              {
                "action": "apply continuous force to player in current direction with current strength"
              }
            ]
          },
          {
            "name": "stop_pushing",
            "trigger": "when player exits water current area",
            "actions": [
              {
                "action": "stop applying current force to player"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class WaterCurrent : MonoBehaviour\n{\n    [Header(\"Current Settings\")]\n    [SerializeField] private Vector3 _currentDirection = Vector3.forward;\n    [SerializeField] private float _currentStrength = 5f;\n    [SerializeField] private bool _useLocalDirection = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _particleEffect;\n    [SerializeField] private bool _showGizmos = true;\n    [SerializeField] private Color _gizmoColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _waterFlowClip;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Force Settings\")]\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    [SerializeField] private float _maxVelocity = 10f;\n    [SerializeField] private bool _limitVelocity = true;\n    \n    private Collider _currentCollider;\n    \n    private void Start()\n    {\n        _currentCollider = GetComponent<Collider>();\n        if (_currentCollider == null)\n        {\n            Debug.LogWarning(\"WaterCurrent requires a Collider component to function properly.\");\n        }\n        \n        if (_currentCollider != null && !_currentCollider.isTrigger)\n        {\n            _currentCollider.isTrigger = true;\n        }\n        \n        SetupAudio();\n        SetupParticles();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _waterFlowClip != null)\n        {\n            _audioSource.clip = _waterFlowClip;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            main.loop = true;\n            \n            var velocityOverLifetime = _particleEffect.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            \n            Vector3 particleDirection = _useLocalDirection ? transform.TransformDirection(_currentDirection) : _currentDirection;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            velocityOverLifetime.x = particleDirection.x * _currentStrength * 0.5f;\n            velocityOverLifetime.y = particleDirection.y * _currentStrength * 0.5f;\n            velocityOverLifetime.z = particleDirection.z * _currentStrength * 0.5f;\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyCurrentForce(other);\n        }\n    }\n    \n    private void ApplyCurrentForce(Collider target)\n    {\n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        if (targetRigidbody == null) return;\n        \n        Vector3 forceDirection = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        Vector3 force = forceDirection * _currentStrength;\n        \n        if (_limitVelocity)\n        {\n            Vector3 currentVelocity = targetRigidbody.velocity;\n            Vector3 projectedVelocity = Vector3.Project(currentVelocity, forceDirection);\n            \n            if (projectedVelocity.magnitude < _maxVelocity)\n            {\n                targetRigidbody.AddForce(force, _forceMode);\n            }\n        }\n        else\n        {\n            targetRigidbody.AddForce(force, _forceMode);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_currentStrength < 0f)\n            _currentStrength = 0f;\n            \n        if (_maxVelocity < 0f)\n            _maxVelocity = 0f;\n            \n        if (_audioVolume < 0f)\n            _audioVolume = 0f;\n        else if (_audioVolume > 1f)\n            _audioVolume = 1f;\n            \n        if (Application.isPlaying)\n        {\n            SetupParticles();\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = _gizmoColor;\n        \n        Vector3 center = transform.position;\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        \n        Gizmos.DrawRay(center, direction * _currentStrength);\n        \n        Gizmos.color = new Color(_gizmoColor.r, _gizmoColor.g, _gizmoColor.b, 0.3f);\n        if (_currentCollider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            if (_currentCollider is BoxCollider box)\n            {\n                Gizmos.DrawCube(box.center, box.size);\n            }\n            else if (_currentCollider is SphereCollider sphere)\n            {\n                Gizmos.DrawSphere(sphere.center, sphere.radius);\n            }\n        }\n        \n        Gizmos.matrix = Matrix4x4.identity;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = Color.white;\n        Vector3 center = transform.position;\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        \n        for (int i = 0; i < 5; i++)\n        {\n            float offset = i * 0.5f;\n            Gizmos.DrawRay(center + direction * offset, direction * 0.3f);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "quicksand that slows movement",
      "ideal_ir": {
        "class_name": "Quicksand",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "slowdownFactor",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "sinkingSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "maxSinkDepth",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "slow_player_movement",
            "trigger": "when player enters quicksand area",
            "actions": [
              {
                "action": "reduce player movement speed by slowdown factor"
              },
              {
                "action": "apply visual effect to show player is in quicksand"
              }
            ]
          },
          {
            "name": "sink_player",
            "trigger": "while player remains in quicksand",
            "actions": [
              {
                "action": "gradually lower player position at sinking speed"
              },
              {
                "action": "stop sinking when maximum depth is reached"
              }
            ]
          },
          {
            "name": "restore_normal_movement",
            "trigger": "when player exits quicksand area",
            "actions": [
              {
                "action": "restore player movement speed to normal"
              },
              {
                "action": "remove quicksand visual effects"
              }
            ]
          },
          {
            "name": "create_struggle_effect",
            "trigger": "when player tries to move while in quicksand",
            "actions": [
              {
                "action": "play struggling animation"
              },
              {
                "action": "create particle effects around player"
              },
              {
                "action": "play quicksand sound effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Quicksand : MonoBehaviour\n{\n    [Header(\"Quicksand Settings\")]\n    [SerializeField] private float _slowdownFactor = 0.3f;\n    [SerializeField] private float _sinkDepth = 0.5f;\n    [SerializeField] private float _sinkSpeed = 1f;\n    [SerializeField] private float _exitSpeed = 2f;\n    [SerializeField] private bool _affectsJumping = true;\n    [SerializeField] private float _jumpReduction = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    [SerializeField] private AudioClip _strugglingSound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private string[] _affectedTags = { \"Player\", \"Enemy\", \"NPC\" };\n    \n    private Dictionary<GameObject, QuicksandData> _affectedObjects = new Dictionary<GameObject, QuicksandData>();\n    private Collider _collider;\n    \n    private class QuicksandData\n    {\n        public Vector3 originalPosition;\n        public float originalSpeed;\n        public float originalJumpForce;\n        public bool isCharacterController;\n        public CharacterController characterController;\n        public Rigidbody rigidBody;\n        public float timeInQuicksand;\n        public bool hasModifiedMovement;\n    }\n    \n    private void Start()\n    {\n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            Debug.LogError(\"Quicksand requires a Collider component!\");\n            return;\n        }\n        \n        if (!_collider.isTrigger)\n        {\n            _collider.isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateAffectedObjects();\n    }\n    \n    private void UpdateAffectedObjects()\n    {\n        var objectsToRemove = new List<GameObject>();\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            var obj = kvp.Key;\n            var data = kvp.Value;\n            \n            if (obj == null)\n            {\n                objectsToRemove.Add(obj);\n                continue;\n            }\n            \n            data.timeInQuicksand += Time.deltaTime;\n            \n            // Sink the object\n            Vector3 targetPosition = data.originalPosition - Vector3.up * _sinkDepth;\n            obj.transform.position = Vector3.MoveTowards(obj.transform.position, targetPosition, _sinkSpeed * Time.deltaTime);\n            \n            // Apply movement slowdown\n            ApplyMovementSlowdown(obj, data);\n        }\n        \n        // Remove null objects\n        foreach (var obj in objectsToRemove)\n        {\n            _affectedObjects.Remove(obj);\n        }\n    }\n    \n    private void ApplyMovementSlowdown(GameObject obj, QuicksandData data)\n    {\n        if (data.hasModifiedMovement) return;\n        \n        // Try to modify CharacterController\n        if (data.characterController != null)\n        {\n            // CharacterController speed modification would need to be handled by the movement script\n            // We'll use a different approach - modify the object's scale or add a component\n            var slowdownComponent = obj.GetComponent<QuicksandSlowdown>();\n            if (slowdownComponent == null)\n            {\n                slowdownComponent = obj.AddComponent<QuicksandSlowdown>();\n            }\n            slowdownComponent.SetSlowdownFactor(_slowdownFactor);\n            data.hasModifiedMovement = true;\n        }\n        \n        // Modify Rigidbody drag\n        if (data.rigidBody != null)\n        {\n            data.rigidBody.drag = Mathf.Max(data.rigidBody.drag, 10f * (1f - _slowdownFactor));\n            data.rigidBody.angularDrag = Mathf.Max(data.rigidBody.angularDrag, 5f * (1f - _slowdownFactor));\n            data.hasModifiedMovement = true;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!ShouldAffectObject(other.gameObject)) return;\n        \n        if (_affectedObjects.ContainsKey(other.gameObject)) return;\n        \n        var data = new QuicksandData\n        {\n            originalPosition = other.transform.position,\n            timeInQuicksand = 0f,\n            hasModifiedMovement = false\n        };\n        \n        // Store original movement data\n        data.characterController = other.GetComponent<CharacterController>();\n        data.rigidBody = other.GetComponent<Rigidbody>();\n        data.isCharacterController = data.characterController != null;\n        \n        _affectedObjects[other.gameObject] = data;\n        \n        // Play enter effects\n        PlayEnterEffects();\n        \n        // Notify the object it entered quicksand\n        other.SendMessage(\"OnEnterQuicksand\", _slowdownFactor, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_affectedObjects.ContainsKey(other.gameObject)) return;\n        \n        var data = _affectedObjects[other.gameObject];\n        \n        // Restore original position gradually\n        StartCoroutine(RestoreObjectPosition(other.gameObject, data));\n        \n        // Remove slowdown effects\n        RemoveSlowdownEffects(other.gameObject, data);\n        \n        _affectedObjects.Remove(other.gameObject);\n        \n        // Play exit effects\n        PlayExitEffects();\n        \n        // Notify the object it exited quicksand\n        other.SendMessage(\"OnExitQuicksand\", SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private System.Collections.IEnumerator RestoreObjectPosition(GameObject obj, QuicksandData data)\n    {\n        if (obj == null) yield break;\n        \n        Vector3 startPos = obj.transform.position;\n        Vector3 targetPos = data.originalPosition;\n        float journey = 0f;\n        \n        while (journey <= 1f && obj != null)\n        {\n            journey += Time.deltaTime * _exitSpeed;\n            obj.transform.position = Vector3.Lerp(startPos, targetPos, journey);\n            yield return null;\n        }\n    }\n    \n    private void RemoveSlowdownEffects(GameObject obj, QuicksandData data)\n    {\n        if (obj == null) return;\n        \n        // Remove slowdown component\n        var slowdownComponent = obj.GetComponent<QuicksandSlowdown>();\n        if (slowdownComponent != null)\n        {\n            Destroy(slowdownComponent);\n        }\n        \n        // Restore Rigidbody properties\n        if (data.rigidBody != null)\n        {\n            data.rigidBody.drag = 0f;\n            data.rigidBody.angularDrag = 0.05f;\n        }\n    }\n    \n    private bool ShouldAffectObject(GameObject obj)\n    {\n        // Check layer\n        if ((_affectedLayers.value & (1 << obj.layer)) == 0) return false;\n        \n        // Check tags\n        foreach (string tag in _affectedTags)\n        {\n            if (obj.CompareTag(tag)) return true;\n        }\n        \n        return false;\n    }\n    \n    private void PlayEnterEffects()\n    {\n        if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Play();\n        }\n        \n        if (_audioSource != null && _enterSound != null)\n        {\n            _audioSource.PlayOneShot(_enterSound);\n        }\n    }\n    \n    private void PlayExitEffects()\n    {\n        if (_audioSource != null && _exitSound != null)\n        {\n            _audioSource.PlayOneShot(_exitSound);\n        }\n        \n        if (_affectedObjects.Count == 0 && _bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = new Color(0.8f, 0.6f, 0.2f, 0.3f);\n        if (_collider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            if (_collider is BoxCollider box)\n            {\n                Gizmos.DrawCube(box.center, box.size);\n            }\n            else if (_collider is SphereCollider sphere)\n            {\n                Gizmos.DrawSphere(sphere.center, sphere.radius);\n            }\n        }\n        \n        // Draw sink depth\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position - Vector3.up * _sinkDepth, transform.localScale);\n    }\n}\n\npublic class QuicksandSlowdown : MonoBehaviour\n{\n    private float _slowdownFactor = 1f;\n    \n    public void SetSlowdownFactor(float factor)\n    {\n        _slowdownFactor = factor;\n    }\n    \n    public float GetSlowdownFactor()\n    {\n        return _slowdownFactor;\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "bounce pad that launches player",
      "ideal_ir": {
        "class_name": "BouncePad",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "launchForce",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "bounceSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "launch_player",
            "trigger": "when player enters the bounce pad area",
            "actions": [
              {
                "action": "apply upward launch force to the player"
              },
              {
                "action": "play bounce sound effect"
              },
              {
                "action": "briefly animate the pad compressing and expanding"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class BouncePad : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _bounceForce = 20f;\n    [SerializeField] private Vector3 _bounceDirection = Vector3.up;\n    [SerializeField] private bool _useLocalDirection = true;\n    [SerializeField] private bool _overrideVelocity = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _animationDuration = 0.3f;\n    [SerializeField] private float _compressionAmount = 0.2f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _bounceSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bounceEffect;\n    [SerializeField] private GameObject _bounceEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerBounce;\n    \n    private Vector3 _originalScale;\n    private bool _isAnimating = false;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _originalScale = transform.localScale;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _bounceSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _bounceDirection = _bounceDirection.normalized;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            LaunchPlayer(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            LaunchPlayer(collision.collider);\n        }\n    }\n    \n    private void LaunchPlayer(Collider player)\n    {\n        Rigidbody playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (playerRigidbody == null)\n        {\n            playerRigidbody = player.GetComponentInParent<Rigidbody>();\n        }\n        \n        if (playerRigidbody != null)\n        {\n            Vector3 launchDirection = _useLocalDirection ? transform.TransformDirection(_bounceDirection) : _bounceDirection;\n            \n            if (_overrideVelocity)\n            {\n                playerRigidbody.velocity = Vector3.zero;\n            }\n            \n            playerRigidbody.AddForce(launchDirection * _bounceForce, ForceMode.VelocityChange);\n            \n            PlayBounceEffects();\n            OnPlayerBounce?.Invoke();\n        }\n    }\n    \n    private void PlayBounceEffects()\n    {\n        if (!_isAnimating)\n        {\n            StartCoroutine(PlayBounceAnimation());\n        }\n        \n        if (_audioSource != null && _bounceSound != null)\n        {\n            _audioSource.PlayOneShot(_bounceSound, _volume);\n        }\n        \n        if (_bounceEffect != null)\n        {\n            _bounceEffect.Play();\n        }\n        \n        if (_bounceEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_bounceEffectPrefab, transform.position, transform.rotation);\n            Destroy(effect, 5f);\n        }\n    }\n    \n    private System.Collections.IEnumerator PlayBounceAnimation()\n    {\n        _isAnimating = true;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            float normalizedTime = elapsedTime / _animationDuration;\n            float curveValue = _animationCurve.Evaluate(normalizedTime);\n            \n            float compressionScale = 1f - (_compressionAmount * curveValue);\n            Vector3 newScale = new Vector3(\n                _originalScale.x * (1f + (1f - compressionScale) * 0.5f),\n                _originalScale.y * compressionScale,\n                _originalScale.z * (1f + (1f - compressionScale) * 0.5f)\n            );\n            \n            transform.localScale = newScale;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n        _isAnimating = false;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_bounceDirection) : _bounceDirection;\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + direction * (_bounceForce * 0.1f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(startPos, endPos);\n        Gizmos.DrawSphere(endPos, 0.2f);\n        \n        Gizmos.color = Color.green;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "zipline for fast travel",
      "ideal_ir": {
        "class_name": "Zipline",
        "components": [
          "LineRenderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "startPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "endPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "travelSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          },
          {
            "name": "ziplineSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "arrivalSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initialize_zipline",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "draw line between start point and end point"
              },
              {
                "action": "position zipline cable visually"
              }
            ]
          },
          {
            "name": "activate_zipline",
            "trigger": "when player interacts with zipline and zipline is active",
            "actions": [
              {
                "action": "attach player to zipline"
              },
              {
                "action": "disable player movement controls"
              },
              {
                "action": "play zipline sound effect"
              },
              {
                "action": "start moving player toward end point at travel speed"
              }
            ]
          },
          {
            "name": "travel_along_zipline",
            "trigger": "while player is attached to zipline",
            "actions": [
              {
                "action": "move player smoothly along zipline path"
              },
              {
                "action": "maintain player orientation facing forward"
              },
              {
                "action": "continue playing zipline sound"
              }
            ]
          },
          {
            "name": "complete_zipline_travel",
            "trigger": "when player reaches end point of zipline",
            "actions": [
              {
                "action": "detach player from zipline"
              },
              {
                "action": "restore player movement controls"
              },
              {
                "action": "stop zipline sound effect"
              },
              {
                "action": "play arrival sound effect"
              },
              {
                "action": "position player at end point"
              }
            ]
          },
          {
            "name": "show_interaction_prompt",
            "trigger": "when player is near start point and zipline is active",
            "actions": [
              {
                "action": "display use zipline prompt to player"
              }
            ]
          },
          {
            "name": "hide_interaction_prompt",
            "trigger": "when player moves away from start point",
            "actions": [
              {
                "action": "hide use zipline prompt"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Zipline : MonoBehaviour\n{\n    [System.Serializable]\n    public class ZiplineEvents\n    {\n        public UnityEvent OnPlayerAttach;\n        public UnityEvent OnPlayerDetach;\n        public UnityEvent OnZiplineComplete;\n    }\n\n    [Header(\"Zipline Configuration\")]\n    [SerializeField] private Transform _startPoint;\n    [SerializeField] private Transform _endPoint;\n    [SerializeField] private float _travelSpeed = 10f;\n    [SerializeField] private float _attachDistance = 2f;\n    [SerializeField] private bool _autoDetach = true;\n    [SerializeField] private float _detachDistance = 1f;\n\n    [Header(\"Player Control\")]\n    [SerializeField] private KeyCode _attachKey = KeyCode.E;\n    [SerializeField] private KeyCode _detachKey = KeyCode.Space;\n    [SerializeField] private bool _requireKeyToAttach = true;\n    [SerializeField] private bool _allowEarlyDetach = true;\n\n    [Header(\"Physics\")]\n    [SerializeField] private bool _disablePlayerGravity = true;\n    [SerializeField] private bool _disablePlayerMovement = true;\n    [SerializeField] private Vector3 _playerOffset = Vector3.zero;\n\n    [Header(\"Visual\")]\n    [SerializeField] private LineRenderer _ziplineRenderer;\n    [SerializeField] private GameObject _handlePrefab;\n    [SerializeField] private bool _createVisualHandle = true;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attachSound;\n    [SerializeField] private AudioClip _travelSound;\n    [SerializeField] private AudioClip _detachSound;\n\n    [Header(\"Events\")]\n    [SerializeField] private ZiplineEvents _events;\n\n    private Transform _attachedPlayer;\n    private Rigidbody _playerRigidbody;\n    private CharacterController _playerController;\n    private bool _isPlayerAttached;\n    private float _travelProgress;\n    private Vector3 _originalGravity;\n    private bool _wasKinematic;\n    private GameObject _visualHandle;\n    private Transform _nearbyPlayer;\n\n    private void Start()\n    {\n        InitializeZipline();\n    }\n\n    private void InitializeZipline()\n    {\n        if (_startPoint == null)\n        {\n            GameObject startObj = new GameObject(\"ZiplineStart\");\n            startObj.transform.SetParent(transform);\n            startObj.transform.localPosition = Vector3.zero;\n            _startPoint = startObj.transform;\n        }\n\n        if (_endPoint == null)\n        {\n            GameObject endObj = new GameObject(\"ZiplineEnd\");\n            endObj.transform.SetParent(transform);\n            endObj.transform.localPosition = new Vector3(10f, -5f, 0f);\n            _endPoint = endObj.transform;\n        }\n\n        SetupVisuals();\n        SetupAudio();\n    }\n\n    private void SetupVisuals()\n    {\n        if (_ziplineRenderer == null)\n        {\n            _ziplineRenderer = GetComponent<LineRenderer>();\n            if (_ziplineRenderer == null)\n            {\n                _ziplineRenderer = gameObject.AddComponent<LineRenderer>();\n            }\n        }\n\n        if (_ziplineRenderer != null)\n        {\n            _ziplineRenderer.positionCount = 2;\n            _ziplineRenderer.startWidth = 0.05f;\n            _ziplineRenderer.endWidth = 0.05f;\n            _ziplineRenderer.material = Resources.Load<Material>(\"Default-Material\");\n            UpdateZiplineVisual();\n        }\n\n        if (_createVisualHandle && _handlePrefab != null && _visualHandle == null)\n        {\n            _visualHandle = Instantiate(_handlePrefab, _startPoint.position, Quaternion.identity);\n            _visualHandle.transform.SetParent(transform);\n        }\n    }\n\n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n\n        if (_audioSource != null)\n        {\n            _audioSource.playOnAwake = false;\n            _audioSource.spatialBlend = 1f;\n        }\n    }\n\n    private void Update()\n    {\n        UpdateZiplineVisual();\n        CheckForNearbyPlayer();\n        HandlePlayerInput();\n        \n        if (_isPlayerAttached)\n        {\n            UpdatePlayerMovement();\n        }\n    }\n\n    private void UpdateZiplineVisual()\n    {\n        if (_ziplineRenderer != null && _startPoint != null && _endPoint != null)\n        {\n            _ziplineRenderer.SetPosition(0, _startPoint.position);\n            _ziplineRenderer.SetPosition(1, _endPoint.position);\n        }\n    }\n\n    private void CheckForNearbyPlayer()\n    {\n        if (_isPlayerAttached) return;\n\n        Collider[] nearbyColliders = Physics.OverlapSphere(_startPoint.position, _attachDistance);\n        _nearbyPlayer = null;\n\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _nearbyPlayer = col.transform;\n                break;\n            }\n        }\n    }\n\n    private void HandlePlayerInput()\n    {\n        if (_nearbyPlayer != null && !_isPlayerAttached)\n        {\n            if (!_requireKeyToAttach || Input.GetKeyDown(_attachKey))\n            {\n                AttachPlayer(_nearbyPlayer);\n            }\n        }\n        else if (_isPlayerAttached && _allowEarlyDetach && Input.GetKeyDown(_detachKey))\n        {\n            DetachPlayer();\n        }\n    }\n\n    private void AttachPlayer(Transform player)\n    {\n        _attachedPlayer = player;\n        _playerRigidbody = player.GetComponent<Rigidbody>();\n        _playerController = player.GetComponent<CharacterController>();\n        _isPlayerAttached = true;\n        _travelProgress = 0f;\n\n        if (_playerRigidbody != null)\n        {\n            _wasKinematic = _playerRigidbody.isKinematic;\n            if (_disablePlayerGravity)\n            {\n                _playerRigidbody.useGravity = false;\n            }\n            if (_disablePlayerMovement)\n            {\n                _playerRigidbody.isKinematic = true;\n            }\n        }\n\n        if (_playerController != null && _disablePlayerMovement)\n        {\n            _playerController.enabled = false;\n        }\n\n        PlaySound(_attachSound);\n        _events?.OnPlayerAttach?.Invoke();\n\n        if (_travelSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _travelSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void UpdatePlayerMovement()\n    {\n        if (_attachedPlayer == null) return;\n\n        _travelProgress += _travelSpeed * Time.deltaTime / Vector3.Distance(_startPoint.position, _endPoint.position);\n        _travelProgress = Mathf.Clamp01(_travelProgress);\n\n        Vector3 targetPosition = Vector3.Lerp(_startPoint.position, _endPoint.position, _travelProgress) + _playerOffset;\n        \n        if (_playerController != null && !_playerController.enabled)\n        {\n            _attachedPlayer.position = targetPosition;\n        }\n        else if (_playerRigidbody != null)\n        {\n            _playerRigidbody.MovePosition(targetPosition);\n        }\n        else\n        {\n            _attachedPlayer.position = targetPosition;\n        }\n\n        Vector3 direction = (_endPoint.position - _startPoint.position).normalized;\n        if (direction != Vector3.zero)\n        {\n            _attachedPlayer.rotation = Quaternion.LookRotation(direction);\n        }\n\n        if (_visualHandle != null)\n        {\n            _visualHandle.transform.position = targetPosition;\n        }\n\n        if (_autoDetach && Vector3.Distance(_attachedPlayer.position, _endPoint.position) <= _detachDistance)\n        {\n            DetachPlayer();\n            _events?.OnZiplineComplete?.Invoke();\n        }\n    }\n\n    private void DetachPlayer()\n    {\n        if (!_isPlayerAttached || _attachedPlayer == null) return;\n\n        if (_playerRigidbody != null)\n        {\n            _playerRigidbody.isKinematic = _wasKinematic;\n            if (_disablePlayerGravity)\n            {\n                _playerRigidbody.useGravity = true;\n            }\n        }\n\n        if (_playerController != null && !_playerController.enabled)\n        {\n            _playerController.enabled = true;\n        }\n\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n\n        PlaySound(_detachSound);\n        _events?.OnPlayerDetach?.Invoke();\n\n        _attachedPlayer = null;\n        _playerRigidbody = null;\n        _playerController = null;\n        _isPlayerAttached = false;\n        _travelProgress = 0f;\n\n        if (_visualHandle != null)\n        {\n            _visualHandle.transform.position = _startPoint.position;\n        }\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_requireKeyToAttach && other.CompareTag(\"Player\") && !_isPlayerAttached)\n        {\n            AttachPlayer(other.transform);\n        }\n    }\n\n    private void OnDrawGizmos()\n    {\n        if (_startPoint != null && _endPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(_startPoint.position, _endPoint.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_startPoint.position, _attachDistance);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_endPoint.position, _detachDistance);\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_startPoint != null)\n        {\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawWireCube(_startPoint.position, Vector3.one * 0.5f);\n        }\n        \n        if (_endPoint != null)\n        {\n            Gizmos.color = Color.magenta;\n            Gizmos.DrawWireCube(_endPoint.position, Vector3.one * 0.5f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ladder for climbing",
      "ideal_ir": {
        "class_name": "ClimbableLadder",
        "components": [
          "BoxCollider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "climbSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "ladderHeight",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isPlayerClimbing",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_climbing",
            "trigger": "when player enters ladder trigger area and presses climb input",
            "actions": [
              {
                "action": "disable player gravity"
              },
              {
                "action": "set player climbing state to true"
              },
              {
                "action": "align player position to ladder center"
              }
            ]
          },
          {
            "name": "climb_up",
            "trigger": "when player is climbing and presses up input",
            "actions": [
              {
                "action": "move player upward at climb speed"
              },
              {
                "action": "play climbing animation"
              }
            ]
          },
          {
            "name": "climb_down",
            "trigger": "when player is climbing and presses down input",
            "actions": [
              {
                "action": "move player downward at climb speed"
              },
              {
                "action": "play climbing animation"
              }
            ]
          },
          {
            "name": "stop_climbing",
            "trigger": "when player is climbing and presses jump input or reaches ladder top or bottom",
            "actions": [
              {
                "action": "enable player gravity"
              },
              {
                "action": "set player climbing state to false"
              },
              {
                "action": "restore normal player movement"
              }
            ]
          },
          {
            "name": "exit_ladder_area",
            "trigger": "when player leaves ladder trigger area while climbing",
            "actions": [
              {
                "action": "enable player gravity"
              },
              {
                "action": "set player climbing state to false"
              },
              {
                "action": "restore normal player movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Ladder : MonoBehaviour\n{\n    [Header(\"Ladder Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private bool _requireInputToClimb = true;\n    [SerializeField] private string _climbInputAxis = \"Vertical\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _climbSound;\n    [SerializeField] private float _climbSoundVolume = 0.5f;\n    \n    private Collider _ladderCollider;\n    private AudioSource _audioSource;\n    private GameObject _currentPlayer;\n    private Rigidbody _playerRigidbody;\n    private bool _isPlayerOnLadder = false;\n    private float _originalGravityScale;\n    private bool _wasKinematic;\n\n    private void Start()\n    {\n        _ladderCollider = GetComponent<Collider>();\n        if (_ladderCollider == null)\n        {\n            Debug.LogError(\"Ladder requires a Collider component!\");\n            return;\n        }\n        \n        if (!_ladderCollider.isTrigger)\n        {\n            _ladderCollider.isTrigger = true;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _climbSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.clip = _climbSound;\n            _audioSource.volume = _climbSoundVolume;\n            _audioSource.loop = true;\n            _audioSource.playOnAwake = false;\n        }\n    }\n\n    private void Update()\n    {\n        if (_isPlayerOnLadder && _currentPlayer != null)\n        {\n            HandleClimbing();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && IsInLayerMask(other.gameObject.layer, _playerLayer))\n        {\n            _currentPlayer = other.gameObject;\n            _playerRigidbody = other.GetComponent<Rigidbody>();\n            \n            if (_playerRigidbody != null)\n            {\n                _isPlayerOnLadder = true;\n                _wasKinematic = _playerRigidbody.isKinematic;\n                _playerRigidbody.useGravity = false;\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            ExitLadder();\n        }\n    }\n\n    private void HandleClimbing()\n    {\n        if (_playerRigidbody == null) return;\n\n        float climbInput = _requireInputToClimb ? Input.GetAxis(_climbInputAxis) : 0f;\n        \n        if (!_requireInputToClimb)\n        {\n            if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n                climbInput = 1f;\n            else if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n                climbInput = -1f;\n        }\n\n        Vector3 climbVelocity = new Vector3(\n            _playerRigidbody.velocity.x,\n            climbInput * _climbSpeed,\n            _playerRigidbody.velocity.z\n        );\n\n        _playerRigidbody.velocity = climbVelocity;\n\n        HandleClimbingAudio(climbInput);\n    }\n\n    private void HandleClimbingAudio(float climbInput)\n    {\n        if (_audioSource == null || _climbSound == null) return;\n\n        bool shouldPlaySound = Mathf.Abs(climbInput) > 0.1f;\n        \n        if (shouldPlaySound && !_audioSource.isPlaying)\n        {\n            _audioSource.Play();\n        }\n        else if (!shouldPlaySound && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n\n    private void ExitLadder()\n    {\n        if (_playerRigidbody != null)\n        {\n            _playerRigidbody.useGravity = true;\n            _playerRigidbody.isKinematic = _wasKinematic;\n        }\n\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n\n        _isPlayerOnLadder = false;\n        _currentPlayer = null;\n        _playerRigidbody = null;\n    }\n\n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n\n    private void OnDisable()\n    {\n        if (_isPlayerOnLadder)\n        {\n            ExitLadder();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(transform.position + col.bounds.center, col.bounds.size);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rope swing",
      "ideal_ir": {
        "class_name": "RopeSwing",
        "components": [
          "Rigidbody",
          "HingeJoint",
          "LineRenderer"
        ],
        "fields": [
          {
            "name": "ropeLength",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "swingForce",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "maxSwingAngle",
            "type": "float",
            "default": 45.0
          },
          {
            "name": "dampingFactor",
            "type": "float",
            "default": 0.98
          },
          {
            "name": "isPlayerAttached",
            "type": "bool",
            "default": false
          },
          {
            "name": "attachPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "ropeSegments",
            "type": "int",
            "default": 20
          }
        ],
        "behaviors": [
          {
            "name": "attach_player",
            "trigger": "when player presses interact key while near rope",
            "actions": [
              {
                "action": "connect player to rope at current position"
              },
              {
                "action": "disable player ground movement"
              },
              {
                "action": "set player as attached to rope"
              }
            ]
          },
          {
            "name": "detach_player",
            "trigger": "when player releases interact key while attached",
            "actions": [
              {
                "action": "disconnect player from rope"
              },
              {
                "action": "restore player normal movement"
              },
              {
                "action": "apply current swing momentum to player"
              }
            ]
          },
          {
            "name": "swing_physics",
            "trigger": "when player is attached and provides input",
            "actions": [
              {
                "action": "apply pendulum physics to rope movement"
              },
              {
                "action": "add player input force to swing direction"
              },
              {
                "action": "limit swing angle to maximum range"
              }
            ]
          },
          {
            "name": "rope_visual",
            "trigger": "continuously while rope exists",
            "actions": [
              {
                "action": "draw rope line from anchor point to player"
              },
              {
                "action": "update rope curve based on physics simulation"
              },
              {
                "action": "show rope segments with realistic sag"
              }
            ]
          },
          {
            "name": "dampen_swing",
            "trigger": "continuously while swinging",
            "actions": [
              {
                "action": "gradually reduce swing momentum over time"
              },
              {
                "action": "apply air resistance to rope movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class RopeSwing : MonoBehaviour\n{\n    [Header(\"Rope Settings\")]\n    [SerializeField] private Transform _anchorPoint;\n    [SerializeField] private LineRenderer _ropeRenderer;\n    [SerializeField] private int _ropeSegments = 20;\n    [SerializeField] private float _ropeLength = 5f;\n    [SerializeField] private float _ropeWidth = 0.1f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _swingForce = 10f;\n    [SerializeField] private float _dampening = 0.98f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Player Interaction\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Space;\n    [SerializeField] private float _grabDistance = 2f;\n    [SerializeField] private Transform _grabPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _swingSound;\n    \n    private bool _isPlayerGrabbing = false;\n    private GameObject _currentPlayer;\n    private Rigidbody _playerRigidbody;\n    private Vector3 _ropeDirection;\n    private float _currentAngle = 0f;\n    private float _angularVelocity = 0f;\n    private Vector3[] _ropePositions;\n    private bool _isSwinging = false;\n    private Vector3 _lastPlayerPosition;\n    private bool _canGrab = true;\n    \n    private void Start()\n    {\n        InitializeRope();\n        SetupAudio();\n    }\n    \n    private void InitializeRope()\n    {\n        if (_anchorPoint == null)\n            _anchorPoint = transform;\n            \n        if (_grabPoint == null)\n        {\n            GameObject grabPointObj = new GameObject(\"GrabPoint\");\n            grabPointObj.transform.SetParent(transform);\n            _grabPoint = grabPointObj.transform;\n        }\n        \n        _ropePositions = new Vector3[_ropeSegments + 1];\n        \n        if (_ropeRenderer == null)\n        {\n            _ropeRenderer = GetComponent<LineRenderer>();\n            if (_ropeRenderer == null)\n                _ropeRenderer = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _ropeRenderer.positionCount = _ropeSegments + 1;\n        _ropeRenderer.startWidth = _ropeWidth;\n        _ropeRenderer.endWidth = _ropeWidth;\n        _ropeRenderer.useWorldSpace = true;\n        \n        UpdateRopeVisual();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n                _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInput();\n        UpdateRopePhysics();\n        UpdateRopeVisual();\n        CheckGroundCollision();\n    }\n    \n    private void HandlePlayerInput()\n    {\n        if (!_isPlayerGrabbing && _canGrab)\n        {\n            CheckForPlayerGrab();\n        }\n        \n        if (_isPlayerGrabbing && _currentPlayer != null)\n        {\n            HandleSwingInput();\n            \n            if (Input.GetKeyDown(_releaseKey))\n            {\n                ReleasePlayer();\n            }\n        }\n    }\n    \n    private void CheckForPlayerGrab()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(_grabPoint.position, _grabDistance);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\") && Input.GetKeyDown(_grabKey))\n            {\n                GrabPlayer(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void GrabPlayer(GameObject player)\n    {\n        _currentPlayer = player;\n        _playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (_playerRigidbody == null)\n            return;\n            \n        _isPlayerGrabbing = true;\n        _isSwinging = true;\n        \n        // Calculate initial angle based on player position relative to anchor\n        Vector3 toPlayer = player.transform.position - _anchorPoint.position;\n        _currentAngle = Mathf.Atan2(toPlayer.x, -toPlayer.y);\n        _angularVelocity = 0f;\n        \n        // Disable player's gravity temporarily\n        _playerRigidbody.useGravity = false;\n        _playerRigidbody.velocity = Vector3.zero;\n        \n        _lastPlayerPosition = player.transform.position;\n        \n        PlaySound(_grabSound);\n    }\n    \n    private void HandleSwingInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            _angularVelocity += horizontal * _swingForce * Time.deltaTime;\n            \n            if (!_audioSource.isPlaying && _swingSound != null)\n            {\n                PlaySound(_swingSound);\n            }\n        }\n    }\n    \n    private void UpdateRopePhysics()\n    {\n        if (_isPlayerGrabbing && _currentPlayer != null && _playerRigidbody != null)\n        {\n            // Apply gravity to angular velocity\n            float gravityForce = _gravity * Mathf.Sin(_currentAngle) / _ropeLength;\n            _angularVelocity += gravityForce * Time.deltaTime;\n            \n            // Apply dampening\n            _angularVelocity *= _dampening;\n            \n            // Update angle\n            _currentAngle += _angularVelocity * Time.deltaTime;\n            \n            // Calculate new player position\n            Vector3 newPosition = _anchorPoint.position + new Vector3(\n                Mathf.Sin(_currentAngle) * _ropeLength,\n                -Mathf.Cos(_currentAngle) * _ropeLength,\n                0f\n            );\n            \n            // Move player\n            _currentPlayer.transform.position = newPosition;\n            \n            // Calculate velocity for when player releases\n            Vector3 velocity = (newPosition - _lastPlayerPosition) / Time.deltaTime;\n            _playerRigidbody.velocity = velocity;\n            \n            _lastPlayerPosition = newPosition;\n        }\n        \n        // Update grab point position\n        if (_grabPoint != null)\n        {\n            _grabPoint.position = _anchorPoint.position + new Vector3(\n                Mathf.Sin(_currentAngle) * _ropeLength,\n                -Mathf.Cos(_currentAngle) * _ropeLength,\n                0f\n            );\n        }\n    }\n    \n    private void UpdateRopeVisual()\n    {\n        if (_ropeRenderer == null || _anchorPoint == null)\n            return;\n            \n        Vector3 ropeEnd = _grabPoint != null ? _grabPoint.position : \n            _anchorPoint.position + Vector3.down * _ropeLength;\n        \n        for (int i = 0; i <= _ropeSegments; i++)\n        {\n            float t = (float)i / _ropeSegments;\n            Vector3 position = Vector3.Lerp(_anchorPoint.position, ropeEnd, t);\n            \n            // Add slight curve to rope\n            float curve = Mathf.Sin(t * Mathf.PI) * 0.5f;\n            position.x += curve * Mathf.Sign(ropeEnd.x - _anchorPoint.position.x);\n            \n            _ropePositions[i] = position;\n        }\n        \n        _ropeRenderer.SetPositions(_ropePositions);\n    }\n    \n    private void CheckGroundCollision()\n    {\n        if (_isPlayerGrabbing && _currentPlayer != null)\n        {\n            Bounds playerBounds = _currentPlayer.GetComponent<Collider>().bounds;\n            \n            if (Physics.CheckBox(playerBounds.center, playerBounds.extents, \n                _currentPlayer.transform.rotation, _groundLayer))\n            {\n                ReleasePlayer();\n            }\n        }\n    }\n    \n    private void ReleasePlayer()\n    {\n        if (_currentPlayer != null && _playerRigidbody != null)\n        {\n            _playerRigidbody.useGravity = true;\n            \n            // Add release velocity\n            Vector3 releaseVelocity = new Vector3(\n                Mathf.Cos(_currentAngle) * _angularVelocity * _ropeLength,\n                Mathf.Sin(_currentAngle) * _angularVelocity * _ropeLength,\n                0f\n            );\n            \n            _playerRigidbody.velocity += releaseVelocity;\n        }\n        \n        _isPlayerGrabbing = false;\n        _isSwinging = false;\n        _currentPlayer = null;\n        _playerRigidbody = null;\n        _angularVelocity = 0f;\n        \n        PlaySound(_releaseSound);\n        \n        // Prevent immediate re-grab\n        _canGrab = false;\n        Invoke(nameof(EnableGrab), 0.5f);\n    }\n    \n    private void EnableGrab()\n    {\n        _canGrab = true;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_anchorPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_anchorPoint.position, 0.2f);\n            \n            Vector3 ropeEnd = _anchorPoint.position + Vector3.down * _ropeLength;\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_anchorPoint.position, ropeEnd);\n            \n            if (_grabPoint != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawWireSphere(_grabPoint.position, _grabDistance);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "destructible barrel",
      "ideal_ir": {
        "class_name": "DestructibleBarrel",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 50
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 50
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "fragmentCount",
            "type": "int",
            "default": 8
          },
          {
            "name": "isDestroyed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when hit by projectile or explosion",
            "actions": [
              {
                "action": "reduce current health by damage amount"
              },
              {
                "action": "play impact sound effect"
              },
              {
                "action": "show damage visual effect at hit point"
              }
            ]
          },
          {
            "name": "destroy_barrel",
            "trigger": "when current health reaches zero or below",
            "actions": [
              {
                "action": "mark barrel as destroyed"
              },
              {
                "action": "play explosion sound effect"
              },
              {
                "action": "create explosion visual effect"
              },
              {
                "action": "apply explosive force to nearby objects within explosion radius"
              },
              {
                "action": "spawn fragment pieces that scatter outward"
              },
              {
                "action": "deal damage to nearby destructible objects"
              },
              {
                "action": "destroy the barrel game object after brief delay"
              }
            ]
          },
          {
            "name": "chain_reaction",
            "trigger": "when explosion force is applied from nearby explosion",
            "actions": [
              {
                "action": "reduce current health by explosion damage amount"
              },
              {
                "action": "apply physics force in direction away from explosion source"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when current health is below half of maximum health",
            "actions": [
              {
                "action": "show cracks or damage on barrel surface"
              },
              {
                "action": "emit smoke particles from damaged areas"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DestructibleBarrel : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private int _currentHealth;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private string[] _damageableTags = { \"Bullet\", \"Explosion\", \"Weapon\" };\n    [SerializeField] private int _explosionDamage = 50;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private LayerMask _explosionLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _destructionParticles;\n    [SerializeField] private GameObject _damageParticles;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _destructionSound;\n    [SerializeField] private Material _damagedMaterial;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private bool _explodeOnDestruction = true;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private GameObject[] _debrisPrefabs;\n    [SerializeField] private int _debrisCount = 5;\n    [SerializeField] private float _debrisLifetime = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDamaged;\n    public UnityEvent OnDestroyed;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Material _originalMaterial;\n    private bool _isDestroyed = false;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isDestroyed) return;\n        \n        foreach (string tag in _damageableTags)\n        {\n            if (other.CompareTag(tag))\n            {\n                int damage = GetDamageFromCollider(other);\n                TakeDamage(damage);\n                break;\n            }\n        }\n    }\n    \n    void OnCollisionEnter(Collision collision)\n    {\n        if (_isDestroyed) return;\n        \n        foreach (string tag in _damageableTags)\n        {\n            if (collision.gameObject.CompareTag(tag))\n            {\n                int damage = GetDamageFromCollider(collision.collider);\n                TakeDamage(damage);\n                break;\n            }\n        }\n    }\n    \n    private int GetDamageFromCollider(Collider other)\n    {\n        if (other.CompareTag(\"Bullet\"))\n            return 25;\n        else if (other.CompareTag(\"Explosion\"))\n            return 75;\n        else if (other.CompareTag(\"Weapon\"))\n            return 40;\n        \n        return 10;\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDestroyed) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        PlayHitEffect();\n        OnDamaged?.Invoke();\n        \n        UpdateVisualDamage();\n        \n        if (_currentHealth <= 0)\n        {\n            DestroyBarrel();\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_damageParticles != null)\n        {\n            GameObject particles = Instantiate(_damageParticles, transform.position, transform.rotation);\n            Destroy(particles, 2f);\n        }\n        \n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void UpdateVisualDamage()\n    {\n        if (_renderer == null || _damagedMaterial == null) return;\n        \n        float healthPercentage = (float)_currentHealth / _maxHealth;\n        \n        if (healthPercentage < 0.5f && _renderer.material != _damagedMaterial)\n        {\n            _renderer.material = _damagedMaterial;\n        }\n    }\n    \n    private void DestroyBarrel()\n    {\n        if (_isDestroyed) return;\n        _isDestroyed = true;\n        \n        OnDestroyed?.Invoke();\n        \n        if (_explodeOnDestruction)\n        {\n            CreateExplosion();\n        }\n        \n        CreateDestructionEffects();\n        SpawnDebris();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        Destroy(gameObject, 1f);\n    }\n    \n    private void CreateExplosion()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _explosionLayerMask);\n        \n        foreach (Collider nearbyObject in colliders)\n        {\n            if (nearbyObject == _collider) continue;\n            \n            Rigidbody rb = nearbyObject.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            DestructibleBarrel otherBarrel = nearbyObject.GetComponent<DestructibleBarrel>();\n            if (otherBarrel != null && !otherBarrel._isDestroyed)\n            {\n                float distance = Vector3.Distance(transform.position, otherBarrel.transform.position);\n                int damage = Mathf.RoundToInt(_explosionDamage * (1f - distance / _explosionRadius));\n                otherBarrel.TakeDamage(damage);\n            }\n            \n            if (nearbyObject.CompareTag(\"Player\"))\n            {\n                // Apply damage to player if they have a method to receive damage\n                nearbyObject.SendMessage(\"TakeDamage\", _explosionDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void CreateDestructionEffects()\n    {\n        if (_destructionParticles != null)\n        {\n            GameObject particles = Instantiate(_destructionParticles, transform.position, transform.rotation);\n            Destroy(particles, 5f);\n        }\n        \n        if (_destructionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_destructionSound);\n        }\n    }\n    \n    private void SpawnDebris()\n    {\n        if (_debrisPrefabs == null || _debrisPrefabs.Length == 0) return;\n        \n        for (int i = 0; i < _debrisCount; i++)\n        {\n            GameObject debrisPrefab = _debrisPrefabs[Random.Range(0, _debrisPrefabs.Length)];\n            if (debrisPrefab == null) continue;\n            \n            Vector3 spawnPosition = transform.position + Random.insideUnitSphere * 0.5f;\n            Quaternion spawnRotation = Random.rotation;\n            \n            GameObject debris = Instantiate(debrisPrefab, spawnPosition, spawnRotation);\n            \n            Rigidbody debrisRb = debris.GetComponent<Rigidbody>();\n            if (debrisRb == null)\n            {\n                debrisRb = debris.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 explosionDirection = Random.insideUnitSphere;\n            explosionDirection.y = Mathf.Abs(explosionDirection.y);\n            debrisRb.AddForce(explosionDirection * _explosionForce * 0.5f);\n            debrisRb.AddTorque(Random.insideUnitSphere * _explosionForce * 0.1f);\n            \n            Destroy(debris, _debrisLifetime);\n        }\n    }\n    \n    public void SetHealth(int health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0, _maxHealth);\n        UpdateVisualDamage();\n    }\n    \n    public int GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return (float)_currentHealth / _maxHealth;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_explodeOnDestruction)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "explosive crate",
      "ideal_ir": {
        "class_name": "ExplosiveCrate",
        "components": [
          "Rigidbody",
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 1000.0
          },
          {
            "name": "health",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "fuseTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "explosionDamage",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "isArmed",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "take_damage",
            "trigger": "when hit by projectile or explosion",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play impact sound effect"
              },
              {
                "action": "show damage visual effects"
              }
            ]
          },
          {
            "name": "arm_explosive",
            "trigger": "when health drops to zero or below",
            "actions": [
              {
                "action": "set armed state to true"
              },
              {
                "action": "play arming beep sound"
              },
              {
                "action": "start flashing warning light"
              },
              {
                "action": "begin countdown timer"
              }
            ]
          },
          {
            "name": "explode",
            "trigger": "when countdown timer reaches zero",
            "actions": [
              {
                "action": "create explosion visual effect at crate position"
              },
              {
                "action": "play loud explosion sound"
              },
              {
                "action": "apply explosive force to all nearby rigidbodies"
              },
              {
                "action": "deal damage to all objects within explosion radius"
              },
              {
                "action": "destroy the crate object"
              },
              {
                "action": "spawn debris particles"
              }
            ]
          },
          {
            "name": "chain_reaction",
            "trigger": "when caught in another explosion",
            "actions": [
              {
                "action": "immediately set health to zero"
              },
              {
                "action": "trigger armed state without delay"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplosiveCrate : MonoBehaviour\n{\n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _upwardModifier = 3f;\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private LayerMask _explosionLayers = -1;\n    \n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private bool _explodeOnDestroy = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 0.3f;\n    \n    [Header(\"Chain Reaction\")]\n    [SerializeField] private bool _canChainReact = true;\n    [SerializeField] private float _chainReactionDelay = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnExplode;\n    public UnityEvent<float> OnDamaged;\n    \n    private float _currentHealth;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasExploded) return;\n        \n        if (other.CompareTag(\"Player\") || other.name.Contains(\"Projectile\") || other.name.Contains(\"Bullet\"))\n        {\n            TakeDamage(_maxHealth);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded) return;\n        \n        float impactForce = collision.relativeVelocity.magnitude;\n        if (impactForce > 10f)\n        {\n            TakeDamage(impactForce * 2f);\n        }\n    }\n    \n    public void TakeDamage(float damageAmount)\n    {\n        if (_hasExploded) return;\n        \n        _currentHealth -= damageAmount;\n        OnDamaged?.Invoke(damageAmount);\n        \n        if (_currentHealth <= 0f)\n        {\n            Explode();\n        }\n        else\n        {\n            StartCoroutine(DamageFlash());\n        }\n    }\n    \n    public void Explode()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        \n        // Create explosion effect\n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n        \n        // Play explosion sound\n        if (_explosionSound != null && _audioSource != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n        \n        // Apply explosion force and damage\n        ApplyExplosionEffects();\n        \n        // Trigger camera shake\n        StartCoroutine(CameraShake());\n        \n        // Invoke event\n        OnExplode?.Invoke();\n        \n        // Hide visual components\n        if (_renderer != null) _renderer.enabled = false;\n        if (_collider != null) _collider.enabled = false;\n        \n        // Destroy after a short delay to allow effects to play\n        Destroy(gameObject, 2f);\n    }\n    \n    private void ApplyExplosionEffects()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _explosionLayers);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit == _collider) continue;\n            \n            // Apply force to rigidbodies\n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, _upwardModifier);\n            }\n            \n            // Damage other explosive crates for chain reactions\n            if (_canChainReact)\n            {\n                ExplosiveCrate otherCrate = hit.GetComponent<ExplosiveCrate>();\n                if (otherCrate != null && !otherCrate._hasExploded)\n                {\n                    StartCoroutine(ChainReactionDelay(otherCrate));\n                }\n            }\n            \n            // Apply damage to objects with health\n            IDamageable damageable = hit.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                float damageMultiplier = Mathf.Clamp01(1f - (distance / _explosionRadius));\n                damageable.TakeDamage(_damage * damageMultiplier);\n            }\n            \n            // Damage player if hit\n            if (hit.CompareTag(\"Player\"))\n            {\n                // Send damage message to player\n                hit.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ChainReactionDelay(ExplosiveCrate otherCrate)\n    {\n        yield return new WaitForSeconds(_chainReactionDelay);\n        if (otherCrate != null)\n        {\n            otherCrate.Explode();\n        }\n    }\n    \n    private System.Collections.IEnumerator DamageFlash()\n    {\n        if (_renderer == null) yield break;\n        \n        Color originalColor = _renderer.material.color;\n        _renderer.material.color = Color.red;\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = originalColor;\n        }\n    }\n    \n    private System.Collections.IEnumerator CameraShake()\n    {\n        Camera mainCamera = Camera.main;\n        if (mainCamera == null) yield break;\n        \n        Vector3 originalPosition = mainCamera.transform.position;\n        float elapsed = 0f;\n        \n        while (elapsed < _shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _shakeIntensity;\n            float y = Random.Range(-1f, 1f) * _shakeIntensity;\n            \n            mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        mainCamera.transform.position = originalPosition;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rolling boulder trap",
      "ideal_ir": {
        "class_name": "RollingBoulderTrap",
        "components": [
          "Rigidbody",
          "SphereCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rollSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 8
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 50
          },
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "rollDirection",
            "type": "Vector3",
            "default": "Vector3.forward"
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_approach",
            "trigger": "when player enters detection range and trap is not already activated",
            "actions": [
              {
                "action": "set trap to activated state"
              },
              {
                "action": "play boulder rolling sound effect"
              }
            ]
          },
          {
            "name": "roll_boulder",
            "trigger": "when trap is activated",
            "actions": [
              {
                "action": "apply rolling force in specified direction at roll speed"
              },
              {
                "action": "enable physics simulation for realistic rolling motion"
              }
            ]
          },
          {
            "name": "damage_on_collision",
            "trigger": "when boulder collides with player",
            "actions": [
              {
                "action": "deal damage amount to player"
              },
              {
                "action": "play impact sound effect"
              },
              {
                "action": "apply knockback force to player"
              }
            ]
          },
          {
            "name": "destroy_on_obstacle",
            "trigger": "when boulder hits wall or large obstacle",
            "actions": [
              {
                "action": "play destruction sound effect"
              },
              {
                "action": "create debris particle effects"
              },
              {
                "action": "destroy boulder object after short delay"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RollingBoulderTrap : MonoBehaviour\n{\n    [Header(\"Boulder Settings\")]\n    [SerializeField] private GameObject boulderPrefab;\n    [SerializeField] private Transform spawnPoint;\n    [SerializeField] private float boulderSpeed = 10f;\n    [SerializeField] private float boulderMass = 100f;\n    [SerializeField] private float boulderLifetime = 15f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool triggerOnPlayerEnter = true;\n    [SerializeField] private bool triggerOnce = true;\n    [SerializeField] private float triggerDelay = 0.5f;\n    [SerializeField] private string playerTag = \"Player\";\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float gravity = -9.81f;\n    [SerializeField] private LayerMask groundLayer = 1;\n    [SerializeField] private float bounceForce = 5f;\n    [SerializeField] private float rollingResistance = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip boulderRollSound;\n    [SerializeField] private AudioClip boulderCrashSound;\n    [SerializeField] private float audioVolume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem dustEffect;\n    [SerializeField] private GameObject impactEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTrapTriggered;\n    public UnityEvent OnBoulderSpawned;\n    public UnityEvent OnBoulderDestroyed;\n    \n    private bool _hasTriggered = false;\n    private AudioSource _audioSource;\n    private Collider _triggerCollider;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider != null)\n        {\n            _triggerCollider.isTrigger = true;\n        }\n        \n        if (spawnPoint == null)\n        {\n            spawnPoint = transform;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!triggerOnPlayerEnter) return;\n        if (triggerOnce && _hasTriggered) return;\n        if (!other.CompareTag(playerTag)) return;\n        \n        TriggerTrap();\n    }\n    \n    public void TriggerTrap()\n    {\n        if (triggerOnce && _hasTriggered) return;\n        \n        _hasTriggered = true;\n        OnTrapTriggered?.Invoke();\n        \n        if (triggerDelay > 0)\n        {\n            Invoke(nameof(SpawnBoulder), triggerDelay);\n        }\n        else\n        {\n            SpawnBoulder();\n        }\n    }\n    \n    private void SpawnBoulder()\n    {\n        if (boulderPrefab == null || spawnPoint == null) return;\n        \n        GameObject boulder = Instantiate(boulderPrefab, spawnPoint.position, spawnPoint.rotation);\n        \n        BoulderController boulderController = boulder.GetComponent<BoulderController>();\n        if (boulderController == null)\n        {\n            boulderController = boulder.AddComponent<BoulderController>();\n        }\n        \n        boulderController.Initialize(this, boulderSpeed, boulderMass, boulderLifetime, gravity, \n                                   groundLayer, bounceForce, rollingResistance);\n        \n        OnBoulderSpawned?.Invoke();\n        \n        if (boulderRollSound != null && _audioSource != null)\n        {\n            _audioSource.clip = boulderRollSound;\n            _audioSource.volume = audioVolume;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        if (dustEffect != null)\n        {\n            dustEffect.Play();\n        }\n    }\n    \n    public void OnBoulderImpact(Vector3 position)\n    {\n        if (impactEffectPrefab != null)\n        {\n            Instantiate(impactEffectPrefab, position, Quaternion.identity);\n        }\n        \n        if (boulderCrashSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(boulderCrashSound, audioVolume);\n        }\n    }\n    \n    public void OnBoulderDestroyedCallback()\n    {\n        OnBoulderDestroyed?.Invoke();\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (dustEffect != null && dustEffect.isPlaying)\n        {\n            dustEffect.Stop();\n        }\n    }\n    \n    public void ResetTrap()\n    {\n        _hasTriggered = false;\n    }\n}\n\npublic class BoulderController : MonoBehaviour\n{\n    private RollingBoulderTrap _parentTrap;\n    private float _speed;\n    private float _mass;\n    private float _lifetime;\n    private float _gravity;\n    private LayerMask _groundLayer;\n    private float _bounceForce;\n    private float _rollingResistance;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private float _currentLifetime;\n    private Vector3 _velocity;\n    \n    public void Initialize(RollingBoulderTrap parentTrap, float speed, float mass, float lifetime, \n                          float gravity, LayerMask groundLayer, float bounceForce, float rollingResistance)\n    {\n        _parentTrap = parentTrap;\n        _speed = speed;\n        _mass = mass;\n        _lifetime = lifetime;\n        _gravity = gravity;\n        _groundLayer = groundLayer;\n        _bounceForce = bounceForce;\n        _rollingResistance = rollingResistance;\n        \n        SetupRigidbody();\n        _velocity = transform.forward * _speed;\n        _currentLifetime = _lifetime;\n    }\n    \n    private void SetupRigidbody()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        _rigidbody.drag = _rollingResistance;\n        _rigidbody.angularDrag = 0.5f;\n        \n        if (GetComponent<Collider>() == null)\n        {\n            gameObject.AddComponent<SphereCollider>();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        CheckGrounded();\n        ApplyMovement();\n        UpdateLifetime();\n    }\n    \n    private void CheckGrounded()\n    {\n        float radius = GetComponent<Collider>().bounds.size.y * 0.5f;\n        _isGrounded = Physics.CheckSphere(transform.position, radius + 0.1f, _groundLayer);\n    }\n    \n    private void ApplyMovement()\n    {\n        if (!_isGrounded)\n        {\n            _velocity.y += _gravity * Time.fixedDeltaTime;\n        }\n        else\n        {\n            if (_velocity.y < 0)\n            {\n                _velocity.y = 0;\n            }\n        }\n        \n        _rigidbody.velocity = _velocity;\n        \n        if (_isGrounded && _velocity.magnitude > 0.1f)\n        {\n            float rotationSpeed = _velocity.magnitude / (GetComponent<Collider>().bounds.size.x * 0.5f);\n            transform.Rotate(Vector3.right, rotationSpeed * Time.fixedDeltaTime * Mathf.Rad2Deg);\n        }\n    }\n    \n    private void UpdateLifetime()\n    {\n        _currentLifetime -= Time.fixedDeltaTime;\n        if (_currentLifetime <= 0)\n        {\n            DestroyBoulder();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            Rigidbody playerRb = collision.gameObject.GetComponent<Rigidbody>();\n            if (playerRb != null)\n            {\n                Vector3 pushDirection = (collision.transform.position - transform.position).normalized;\n                playerRb.AddForce(pushDirection * _bounceForce, ForceMode.Impulse);\n            }\n        }\n        \n        if ((_groundLayer.value & (1 << collision.gameObject.layer)) != 0)\n        {\n            Vector3 bounceDirection = Vector3.Reflect(_velocity.normalized, collision.contacts[0].normal);\n            _velocity = bounceDirection * _velocity.magnitude * 0.7f;\n            \n            if (_parentTrap != null)\n            {\n                _parentTrap.OnBoulderImpact(collision.contacts[0].point);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"BoulderDestroyer\") || other.CompareTag(\"DeathZone\"))\n        {\n            DestroyBoulder();\n        }\n    }\n    \n    private void DestroyBoulder()\n    {\n        if (_parentTrap != null)\n        {\n            _parentTrap.OnBoulderDestroyedCallback();\n        }\n        \n        Destroy(gameObject);\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "arrow trap that shoots from wall",
      "ideal_ir": {
        "class_name": "ArrowTrap",
        "components": [
          "Transform",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "shootForce",
            "type": "float",
            "default": 20.0
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "arrowPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "shootPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isOnCooldown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range",
            "actions": [
              {
                "action": "check if trap is not on cooldown"
              },
              {
                "action": "if not on cooldown then shoot arrow"
              }
            ]
          },
          {
            "name": "shoot_arrow",
            "trigger": "when shooting arrow",
            "actions": [
              {
                "action": "instantiate arrow at shoot point"
              },
              {
                "action": "launch arrow forward with shoot force"
              },
              {
                "action": "play shooting sound effect"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "cooldown_timer",
            "trigger": "when cooldown timer expires",
            "actions": [
              {
                "action": "set trap ready to shoot again"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class ArrowTrap : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private Transform _detectionPoint;\n    \n    [Header(\"Arrow Settings\")]\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _shootPoint;\n    [SerializeField] private float _arrowSpeed = 20f;\n    [SerializeField] private float _arrowLifetime = 5f;\n    [SerializeField] private int _arrowDamage = 25;\n    \n    [Header(\"Timing Settings\")]\n    [SerializeField] private float _shootDelay = 0.5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _continuousFiring = false;\n    [SerializeField] private float _continuousFireRate = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _reloadSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private GameObject _warningIndicator;\n    \n    private bool _isOnCooldown = false;\n    private bool _isFiring = false;\n    private Coroutine _firingCoroutine;\n    \n    private void Start()\n    {\n        if (_detectionPoint == null)\n            _detectionPoint = transform;\n            \n        if (_shootPoint == null)\n            _shootPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_isOnCooldown || _isFiring)\n            return;\n            \n        DetectTargets();\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(_detectionPoint.position, _detectionRange, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(_targetTag))\n            {\n                Vector3 directionToTarget = (target.transform.position - _detectionPoint.position).normalized;\n                \n                if (Physics.Raycast(_detectionPoint.position, directionToTarget, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider == target)\n                    {\n                        StartFiring();\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void StartFiring()\n    {\n        if (_isFiring)\n            return;\n            \n        _isFiring = true;\n        \n        if (_continuousFiring)\n        {\n            _firingCoroutine = StartCoroutine(ContinuousFire());\n        }\n        else\n        {\n            StartCoroutine(SingleShot());\n        }\n    }\n    \n    private IEnumerator SingleShot()\n    {\n        ShowWarning();\n        yield return new WaitForSeconds(_shootDelay);\n        \n        ShootArrow();\n        HideWarning();\n        \n        _isFiring = false;\n        StartCoroutine(Cooldown());\n    }\n    \n    private IEnumerator ContinuousFire()\n    {\n        ShowWarning();\n        yield return new WaitForSeconds(_shootDelay);\n        \n        while (_isFiring && HasTargetsInRange())\n        {\n            ShootArrow();\n            yield return new WaitForSeconds(1f / _continuousFireRate);\n        }\n        \n        HideWarning();\n        _isFiring = false;\n        StartCoroutine(Cooldown());\n    }\n    \n    private bool HasTargetsInRange()\n    {\n        Collider[] targets = Physics.OverlapSphere(_detectionPoint.position, _detectionRange, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(_targetTag))\n            {\n                Vector3 directionToTarget = (target.transform.position - _detectionPoint.position).normalized;\n                \n                if (Physics.Raycast(_detectionPoint.position, directionToTarget, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider == target)\n                        return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private void ShootArrow()\n    {\n        if (_arrowPrefab == null || _shootPoint == null)\n            return;\n            \n        GameObject arrow = Instantiate(_arrowPrefab, _shootPoint.position, _shootPoint.rotation);\n        \n        TrapArrow arrowScript = arrow.GetComponent<TrapArrow>();\n        if (arrowScript == null)\n            arrowScript = arrow.AddComponent<TrapArrow>();\n            \n        arrowScript.Initialize(_shootPoint.forward, _arrowSpeed, _arrowDamage, _arrowLifetime);\n        \n        PlayShootEffects();\n    }\n    \n    private void PlayShootEffects()\n    {\n        if (_audioSource != null && _shootSound != null)\n            _audioSource.PlayOneShot(_shootSound);\n            \n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n    }\n    \n    private void ShowWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(true);\n    }\n    \n    private void HideWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private IEnumerator Cooldown()\n    {\n        _isOnCooldown = true;\n        \n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n            \n        yield return new WaitForSeconds(_cooldownTime);\n        _isOnCooldown = false;\n    }\n    \n    public void StopFiring()\n    {\n        if (_firingCoroutine != null)\n        {\n            StopCoroutine(_firingCoroutine);\n            _firingCoroutine = null;\n        }\n        \n        _isFiring = false;\n        HideWarning();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_detectionPoint == null)\n            _detectionPoint = transform;\n            \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_detectionPoint.position, _detectionRange);\n        \n        if (_shootPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(_shootPoint.position, _shootPoint.forward * 3f);\n        }\n    }\n}\n\npublic class TrapArrow : MonoBehaviour\n{\n    private Vector3 _direction;\n    private float _speed;\n    private int _damage;\n    private float _lifetime;\n    private Rigidbody _rigidbody;\n    private bool _hasHit = false;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _rigidbody.useGravity = false;\n    }\n    \n    public void Initialize(Vector3 direction, float speed, int damage, float lifetime)\n    {\n        _direction = direction.normalized;\n        _speed = speed;\n        _damage = damage;\n        _lifetime = lifetime;\n        \n        _rigidbody.velocity = _direction * _speed;\n        transform.rotation = Quaternion.LookRotation(_direction);\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit)\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n        {\n            _hasHit = true;\n            \n            // Try to find health component on player\n            var healthComponent = other.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Use reflection to try calling common health methods\n                var healthType = healthComponent.GetType();\n                var takeDamageMethod = healthType.GetMethod(\"TakeDamage\");\n                if (takeDamageMethod != null)\n                {\n                    takeDamageMethod.Invoke(healthComponent, new object[] { _damage });\n                }\n            }\n            \n            StickToTarget(other.transform);\n        }\n        else if (!other.isTrigger)\n        {\n            _hasHit = true;\n            StickToSurface();\n        }\n    }\n    \n    private void StickToTarget(Transform target)\n    {\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        transform.SetParent(target);\n        \n        Destroy(gameObject, 2f);\n    }\n    \n    private void StickToSurface()\n    {\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        Destroy(gameObject, 5f);\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "flame jet trap",
      "ideal_ir": {
        "class_name": "FlameJetTrap",
        "components": [
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "activationDelay",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "flameDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 25
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "isOnCooldown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection range and trap is not on cooldown",
            "actions": [
              {
                "action": "start activation delay timer"
              },
              {
                "action": "play warning sound effect"
              }
            ]
          },
          {
            "name": "activate_flames",
            "trigger": "when activation delay timer expires",
            "actions": [
              {
                "action": "enable flame particle system"
              },
              {
                "action": "set trap to active state"
              },
              {
                "action": "play flame ignition sound"
              },
              {
                "action": "start flame duration timer"
              }
            ]
          },
          {
            "name": "damage_player",
            "trigger": "when player touches flame area while trap is active",
            "actions": [
              {
                "action": "deal damage to player"
              },
              {
                "action": "apply burning effect to player"
              }
            ]
          },
          {
            "name": "deactivate_flames",
            "trigger": "when flame duration timer expires",
            "actions": [
              {
                "action": "disable flame particle system"
              },
              {
                "action": "set trap to inactive state"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "set trap to cooldown state"
              }
            ]
          },
          {
            "name": "reset_trap",
            "trigger": "when cooldown timer expires",
            "actions": [
              {
                "action": "set trap to ready state"
              },
              {
                "action": "remove cooldown state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FlameJetTrap : MonoBehaviour\n{\n    [Header(\"Flame Settings\")]\n    [SerializeField] private float _flameDuration = 2f;\n    [SerializeField] private float _cooldownDuration = 3f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private bool _autoActivate = true;\n    [SerializeField] private float _activationDelay = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private Light _flameLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _igniteSound;\n    [SerializeField] private AudioClip _flameLoopSound;\n    [SerializeField] private AudioClip _extinguishSound;\n    \n    [Header(\"Warning System\")]\n    [SerializeField] private GameObject _warningIndicator;\n    [SerializeField] private float _warningDuration = 1f;\n    [SerializeField] private AudioClip _warningSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFlameActivated;\n    public UnityEvent OnFlameDeactivated;\n    public UnityEvent OnTargetDamaged;\n    \n    private enum TrapState\n    {\n        Idle,\n        Warning,\n        Active,\n        Cooldown\n    }\n    \n    private TrapState _currentState = TrapState.Idle;\n    private float _stateTimer;\n    private float _damageTimer;\n    private bool _playerInRange;\n    private Collider _trapCollider;\n    \n    private void Start()\n    {\n        _trapCollider = GetComponent<Collider>();\n        if (_trapCollider == null)\n        {\n            _trapCollider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_trapCollider).radius = _detectionRadius;\n            _trapCollider.isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        InitializeComponents();\n        SetState(TrapState.Idle);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_flameParticles != null)\n        {\n            var main = _flameParticles.main;\n            main.loop = true;\n            _flameParticles.Stop();\n        }\n        \n        if (_flameLight != null)\n            _flameLight.enabled = false;\n        \n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        UpdateStateMachine();\n        \n        if (_currentState == TrapState.Active)\n        {\n            UpdateDamage();\n        }\n    }\n    \n    private void UpdateStateMachine()\n    {\n        _stateTimer -= Time.deltaTime;\n        \n        switch (_currentState)\n        {\n            case TrapState.Idle:\n                if (_autoActivate && _playerInRange)\n                {\n                    SetState(TrapState.Warning);\n                }\n                break;\n                \n            case TrapState.Warning:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Active);\n                }\n                break;\n                \n            case TrapState.Active:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Cooldown);\n                }\n                break;\n                \n            case TrapState.Cooldown:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Idle);\n                }\n                break;\n        }\n    }\n    \n    private void SetState(TrapState newState)\n    {\n        _currentState = newState;\n        \n        switch (newState)\n        {\n            case TrapState.Idle:\n                _stateTimer = 0f;\n                DeactivateFlame();\n                DeactivateWarning();\n                break;\n                \n            case TrapState.Warning:\n                _stateTimer = _warningDuration;\n                ActivateWarning();\n                break;\n                \n            case TrapState.Active:\n                _stateTimer = _flameDuration;\n                _damageTimer = 0f;\n                ActivateFlame();\n                DeactivateWarning();\n                break;\n                \n            case TrapState.Cooldown:\n                _stateTimer = _cooldownDuration;\n                DeactivateFlame();\n                break;\n        }\n    }\n    \n    private void ActivateWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(true);\n        \n        if (_audioSource != null && _warningSound != null)\n            _audioSource.PlayOneShot(_warningSound);\n    }\n    \n    private void DeactivateWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void ActivateFlame()\n    {\n        if (_flameParticles != null)\n            _flameParticles.Play();\n        \n        if (_flameLight != null)\n            _flameLight.enabled = true;\n        \n        if (_audioSource != null)\n        {\n            if (_igniteSound != null)\n                _audioSource.PlayOneShot(_igniteSound);\n            \n            if (_flameLoopSound != null)\n            {\n                _audioSource.clip = _flameLoopSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        \n        OnFlameActivated?.Invoke();\n    }\n    \n    private void DeactivateFlame()\n    {\n        if (_flameParticles != null)\n            _flameParticles.Stop();\n        \n        if (_flameLight != null)\n            _flameLight.enabled = false;\n        \n        if (_audioSource != null)\n        {\n            if (_audioSource.isPlaying && _audioSource.clip == _flameLoopSound)\n                _audioSource.Stop();\n            \n            if (_extinguishSound != null)\n                _audioSource.PlayOneShot(_extinguishSound);\n        }\n        \n        OnFlameDeactivated?.Invoke();\n    }\n    \n    private void UpdateDamage()\n    {\n        _damageTimer -= Time.deltaTime;\n        \n        if (_damageTimer <= 0f)\n        {\n            _damageTimer = _damageInterval;\n            DamageTargetsInRange();\n        }\n    }\n    \n    private void DamageTargetsInRange()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(\"Player\"))\n            {\n                // Apply damage to player\n                var playerHealth = target.GetComponent<MonoBehaviour>();\n                if (playerHealth != null)\n                {\n                    // Send damage message\n                    target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n                }\n                \n                OnTargetDamaged?.Invoke();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _targetLayerMask) != 0)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _targetLayerMask) != 0)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                _playerInRange = false;\n            }\n        }\n    }\n    \n    public void ManualActivate()\n    {\n        if (_currentState == TrapState.Idle)\n        {\n            SetState(TrapState.Warning);\n        }\n    }\n    \n    public void ForceActivate()\n    {\n        SetState(TrapState.Active);\n    }\n    \n    public void ForceDeactivate()\n    {\n        SetState(TrapState.Idle);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_currentState == TrapState.Active)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawSphere(transform.position, 0.5f);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "pit fall trap with spikes",
      "ideal_ir": {
        "class_name": "PitfallTrap",
        "components": [
          "Collider",
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isTriggered",
            "type": "bool",
            "default": false
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "damageAmount",
            "type": "int",
            "default": 50
          },
          {
            "name": "resetTime",
            "type": "float",
            "default": 10.0
          }
        ],
        "behaviors": [
          {
            "name": "trigger_trap",
            "trigger": "when player steps on trap surface",
            "actions": [
              {
                "action": "mark trap as triggered"
              },
              {
                "action": "play trap activation sound"
              },
              {
                "action": "make trap surface disappear or become transparent"
              }
            ]
          },
          {
            "name": "player_falls",
            "trigger": "when trap is triggered and player is above pit",
            "actions": [
              {
                "action": "make player fall downward at fall speed"
              },
              {
                "action": "disable player movement controls"
              },
              {
                "action": "play falling sound effect"
              }
            ]
          },
          {
            "name": "spike_damage",
            "trigger": "when player reaches bottom of pit",
            "actions": [
              {
                "action": "deal damage to player equal to damage amount"
              },
              {
                "action": "play spike impact sound"
              },
              {
                "action": "show damage visual effects"
              },
              {
                "action": "make spikes briefly glow or animate"
              }
            ]
          },
          {
            "name": "reset_trap",
            "trigger": "when reset time has elapsed after triggering",
            "actions": [
              {
                "action": "mark trap as not triggered"
              },
              {
                "action": "restore trap surface visibility"
              },
              {
                "action": "reset player position to safe location"
              },
              {
                "action": "restore player movement controls"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PitfallTrap : MonoBehaviour\n{\n    [Header(\"Trap Settings\")]\n    [SerializeField] private float _fallDepth = 5f;\n    [SerializeField] private float _fallSpeed = 10f;\n    [SerializeField] private float _resetDelay = 3f;\n    [SerializeField] private bool _resetAfterFall = true;\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    \n    [Header(\"Spike Settings\")]\n    [SerializeField] private GameObject[] _spikes;\n    [SerializeField] private float _spikeRiseSpeed = 8f;\n    [SerializeField] private float _spikeRiseDelay = 0.5f;\n    [SerializeField] private int _spikeDamage = 50;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fallSound;\n    [SerializeField] private AudioClip _spikeSound;\n    [SerializeField] private AudioClip _resetSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private ParticleSystem _bloodEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTrapTriggered;\n    public UnityEvent OnPlayerDamaged;\n    public UnityEvent OnTrapReset;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _targetPosition;\n    private bool _isTriggered = false;\n    private bool _isResetting = false;\n    private bool _spikesRaised = false;\n    private Vector3[] _originalSpikePositions;\n    private Vector3[] _targetSpikePositions;\n    private Collider _trapCollider;\n    private Rigidbody _trapRigidbody;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _targetPosition = _originalPosition + Vector3.down * _fallDepth;\n        _trapCollider = GetComponent<Collider>();\n        _trapRigidbody = GetComponent<Rigidbody>();\n        \n        if (_trapRigidbody != null)\n        {\n            _trapRigidbody.isKinematic = true;\n        }\n        \n        InitializeSpikes();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void InitializeSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) return;\n        \n        _originalSpikePositions = new Vector3[_spikes.Length];\n        _targetSpikePositions = new Vector3[_spikes.Length];\n        \n        for (int i = 0; i < _spikes.Length; i++)\n        {\n            if (_spikes[i] != null)\n            {\n                _originalSpikePositions[i] = _spikes[i].transform.localPosition;\n                _targetSpikePositions[i] = _originalSpikePositions[i] + Vector3.up * 2f;\n                \n                // Hide spikes initially\n                _spikes[i].transform.localPosition = _originalSpikePositions[i] - Vector3.up * 1f;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isTriggered || _isResetting) return;\n        \n        if (IsValidTarget(other))\n        {\n            TriggerTrap(other);\n        }\n    }\n    \n    private bool IsValidTarget(Collider other)\n    {\n        return (_triggerLayers.value & (1 << other.gameObject.layer)) > 0;\n    }\n    \n    private void TriggerTrap(Collider target)\n    {\n        _isTriggered = true;\n        OnTrapTriggered?.Invoke();\n        \n        PlaySound(_fallSound);\n        PlayEffect(_dustEffect);\n        \n        StartCoroutine(FallSequence(target));\n    }\n    \n    private System.Collections.IEnumerator FallSequence(Collider target)\n    {\n        // Fall animation\n        float fallTime = 0f;\n        float fallDuration = _fallDepth / _fallSpeed;\n        \n        while (fallTime < fallDuration)\n        {\n            fallTime += Time.deltaTime;\n            float progress = fallTime / fallDuration;\n            transform.position = Vector3.Lerp(_originalPosition, _targetPosition, progress);\n            yield return null;\n        }\n        \n        transform.position = _targetPosition;\n        \n        // Wait before raising spikes\n        yield return new WaitForSeconds(_spikeRiseDelay);\n        \n        // Raise spikes\n        yield return StartCoroutine(RaiseSpikes());\n        \n        // Check for damage\n        CheckForDamage(target);\n        \n        // Reset if enabled\n        if (_resetAfterFall)\n        {\n            yield return new WaitForSeconds(_resetDelay);\n            yield return StartCoroutine(ResetTrap());\n        }\n    }\n    \n    private System.Collections.IEnumerator RaiseSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) yield break;\n        \n        PlaySound(_spikeSound);\n        _spikesRaised = true;\n        \n        float riseTime = 0f;\n        float riseDuration = 2f / _spikeRiseSpeed;\n        \n        while (riseTime < riseDuration)\n        {\n            riseTime += Time.deltaTime;\n            float progress = riseTime / riseDuration;\n            \n            for (int i = 0; i < _spikes.Length; i++)\n            {\n                if (_spikes[i] != null)\n                {\n                    Vector3 startPos = _originalSpikePositions[i] - Vector3.up * 1f;\n                    _spikes[i].transform.localPosition = Vector3.Lerp(startPos, _targetSpikePositions[i], progress);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        // Ensure final positions\n        for (int i = 0; i < _spikes.Length; i++)\n        {\n            if (_spikes[i] != null)\n            {\n                _spikes[i].transform.localPosition = _targetSpikePositions[i];\n            }\n        }\n    }\n    \n    private void CheckForDamage(Collider target)\n    {\n        if (target == null) return;\n        \n        // Check if target is still in trap area\n        Bounds trapBounds = _trapCollider.bounds;\n        if (trapBounds.Contains(target.transform.position))\n        {\n            DamageTarget(target);\n        }\n    }\n    \n    private void DamageTarget(Collider target)\n    {\n        // Try to find a component that can take damage\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage for generic damage handling\n            target.SendMessage(\"TakeDamage\", _spikeDamage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"OnDamaged\", _spikeDamage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Apply physics damage if rigidbody exists\n        var targetRigidbody = target.GetComponent<Rigidbody>();\n        if (targetRigidbody != null)\n        {\n            targetRigidbody.AddForce(Vector3.down * 500f, ForceMode.Impulse);\n        }\n        \n        PlayEffect(_bloodEffect);\n        OnPlayerDamaged?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator ResetTrap()\n    {\n        _isResetting = true;\n        PlaySound(_resetSound);\n        \n        // Lower spikes first\n        if (_spikesRaised)\n        {\n            yield return StartCoroutine(LowerSpikes());\n        }\n        \n        // Raise platform\n        float resetTime = 0f;\n        float resetDuration = _fallDepth / _fallSpeed;\n        \n        while (resetTime < resetDuration)\n        {\n            resetTime += Time.deltaTime;\n            float progress = resetTime / resetDuration;\n            transform.position = Vector3.Lerp(_targetPosition, _originalPosition, progress);\n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n        \n        _isTriggered = false;\n        _isResetting = false;\n        _spikesRaised = false;\n        \n        OnTrapReset?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator LowerSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) yield break;\n        \n        float lowerTime = 0f;\n        float lowerDuration = 2f / _spikeRiseSpeed;\n        \n        while (lowerTime < lowerDuration)\n        {\n            lowerTime += Time.deltaTime;\n            float progress = lowerTime / lowerDuration;\n            \n            for (int i = 0; i < _spikes.Length; i++)\n            {\n                if (_spikes[i] != null)\n                {\n                    Vector3 endPos = _originalSpikePositions[i] - Vector3.up * 1f;\n                    _spikes[i].transform.localPosition = Vector3.Lerp(_targetSpikePositions[i], endPos, progress);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    public void ManualTrigger()\n    {\n        if (!_isTriggered && !_isResetting)\n        {\n            TriggerTrap(null);\n        }\n    }\n    \n    public void ManualReset()\n    {\n        if (_isTriggered && !_isResetting)\n        {\n            StartCoroutine(ResetTrap());\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 fallPosition = transform.position + Vector3.down * _fallDepth;\n        Gizmos.DrawWireCube(fallPosition, transform.localScale);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(transform.position, fallPosition);\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "swinging axe pendulum",
      "ideal_ir": {
        "class_name": "SwingingAxePendulum",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "swingForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "maxSwingAngle",
            "type": "float",
            "default": 45
          },
          {
            "name": "damping",
            "type": "float",
            "default": 0.98
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          }
        ],
        "behaviors": [
          {
            "name": "initialize_pendulum",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "apply initial swing force to start pendulum motion"
              },
              {
                "action": "set pivot point for swinging motion"
              }
            ]
          },
          {
            "name": "maintain_swing",
            "trigger": "every frame while swinging",
            "actions": [
              {
                "action": "apply gravitational force to maintain pendulum motion"
              },
              {
                "action": "limit swing angle to maximum swing angle"
              },
              {
                "action": "apply damping to gradually reduce swing over time"
              }
            ]
          },
          {
            "name": "damage_player",
            "trigger": "when axe blade collides with player",
            "actions": [
              {
                "action": "deal damage to player"
              },
              {
                "action": "apply knockback force to player in swing direction"
              }
            ]
          },
          {
            "name": "environmental_collision",
            "trigger": "when axe hits wall or obstacle",
            "actions": [
              {
                "action": "reduce swing momentum"
              },
              {
                "action": "create impact sound effect"
              },
              {
                "action": "bounce back slightly from collision point"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SwingingAxePendulum : MonoBehaviour\n{\n    [Header(\"Pendulum Settings\")]\n    [SerializeField] private float _swingAngle = 45f;\n    [SerializeField] private float _swingSpeed = 2f;\n    [SerializeField] private bool _startSwingingOnAwake = true;\n    [SerializeField] private float _delayBeforeStart = 0f;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 50;\n    [SerializeField] private float _damageForce = 10f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hitParticles;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    \n    private bool _isSwinging = false;\n    private float _currentAngle = 0f;\n    private float _swingDirection = 1f;\n    private AudioSource _audioSource;\n    private Vector3 _initialRotation;\n    private float _startDelay;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _initialRotation = transform.eulerAngles;\n        _startDelay = _delayBeforeStart;\n    }\n    \n    private void Start()\n    {\n        if (_startSwingingOnAwake && _delayBeforeStart <= 0f)\n        {\n            StartSwinging();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_startSwingingOnAwake && _startDelay > 0f)\n        {\n            _startDelay -= Time.deltaTime;\n            if (_startDelay <= 0f)\n            {\n                StartSwinging();\n            }\n        }\n        \n        if (_isSwinging)\n        {\n            UpdateSwing();\n        }\n    }\n    \n    private void UpdateSwing()\n    {\n        _currentAngle += _swingSpeed * _swingDirection * Time.deltaTime * 90f;\n        \n        if (_currentAngle >= _swingAngle)\n        {\n            _currentAngle = _swingAngle;\n            _swingDirection = -1f;\n            PlaySwingSound();\n        }\n        else if (_currentAngle <= -_swingAngle)\n        {\n            _currentAngle = -_swingAngle;\n            _swingDirection = 1f;\n            PlaySwingSound();\n        }\n        \n        Vector3 rotation = _initialRotation;\n        rotation.z += _currentAngle;\n        transform.eulerAngles = rotation;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsInLayerMask(other.gameObject.layer, _damageableLayers))\n        {\n            DealDamage(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsInLayerMask(collision.gameObject.layer, _damageableLayers))\n        {\n            DealDamage(collision.collider);\n            \n            if (_hitParticles != null)\n            {\n                _hitParticles.transform.position = collision.contacts[0].point;\n                _hitParticles.Play();\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            Rigidbody targetRb = target.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n                targetRb.AddForce(forceDirection * _damageForce, ForceMode.Impulse);\n            }\n            \n            PlayHitSound();\n        }\n        \n        IDamageable damageable = target.GetComponent<IDamageable>();\n        if (damageable != null)\n        {\n            damageable.TakeDamage(_damage);\n        }\n    }\n    \n    private void PlaySwingSound()\n    {\n        if (_swingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_swingSound, _audioVolume);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound, _audioVolume);\n        }\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    public void StartSwinging()\n    {\n        _isSwinging = true;\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n    }\n    \n    public void StopSwinging()\n    {\n        _isSwinging = false;\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    public void SetSwingSpeed(float speed)\n    {\n        _swingSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetSwingAngle(float angle)\n    {\n        _swingAngle = Mathf.Clamp(angle, 0f, 90f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 leftSwing = Quaternion.Euler(0, 0, -_swingAngle) * Vector3.down;\n        Vector3 rightSwing = Quaternion.Euler(0, 0, _swingAngle) * Vector3.down;\n        \n        Gizmos.DrawRay(transform.position, leftSwing * 2f);\n        Gizmos.DrawRay(transform.position, rightSwing * 2f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.1f);\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(int damage);\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rising water level",
      "ideal_ir": {
        "class_name": "RisingWater",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "riseSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "maxHeight",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "currentHeight",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "rise_water_level",
            "trigger": "every frame while water height is below maximum height",
            "actions": [
              {
                "action": "increase water height by rise speed over time"
              },
              {
                "action": "move water surface upward to match current height"
              }
            ]
          },
          {
            "name": "stop_rising",
            "trigger": "when water height reaches maximum height",
            "actions": [
              {
                "action": "stop increasing water height"
              },
              {
                "action": "maintain water at maximum level"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RisingWater : MonoBehaviour\n{\n    [Header(\"Water Level Settings\")]\n    [SerializeField] private float _riseSpeed = 1f;\n    [SerializeField] private float _maxHeight = 50f;\n    [SerializeField] private float _startDelay = 0f;\n    [SerializeField] private bool _startRisingOnAwake = true;\n    \n    [Header(\"Water Behavior\")]\n    [SerializeField] private AnimationCurve _riseSpeedCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);\n    [SerializeField] private bool _pauseOnPlayerContact = false;\n    [SerializeField] private float _pauseDuration = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _risingSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWaterStartRising;\n    public UnityEvent OnWaterReachMaxHeight;\n    public UnityEvent<GameObject> OnObjectSubmerged;\n    public UnityEvent<GameObject> OnPlayerContact;\n    \n    private float _currentHeight;\n    private float _initialHeight;\n    private bool _isRising = false;\n    private float _startTime;\n    private float _pauseEndTime;\n    private bool _isPaused = false;\n    private bool _hasReachedMax = false;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    private void Awake()\n    {\n        _initialHeight = transform.position.y;\n        _currentHeight = _initialHeight;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        if (_startRisingOnAwake)\n        {\n            StartRising();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isRising || _hasReachedMax)\n            return;\n            \n        if (_isPaused && Time.time < _pauseEndTime)\n            return;\n            \n        if (_isPaused && Time.time >= _pauseEndTime)\n        {\n            _isPaused = false;\n        }\n        \n        if (Time.time < _startTime + _startDelay)\n            return;\n            \n        float progress = (_currentHeight - _initialHeight) / (_maxHeight - _initialHeight);\n        float speedMultiplier = _riseSpeedCurve.Evaluate(progress);\n        \n        _currentHeight += _riseSpeed * speedMultiplier * Time.deltaTime;\n        \n        if (_currentHeight >= _maxHeight)\n        {\n            _currentHeight = _maxHeight;\n            _hasReachedMax = true;\n            OnWaterReachMaxHeight?.Invoke();\n            \n            if (_audioSource != null && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _currentHeight;\n        transform.position = newPosition;\n    }\n    \n    public void StartRising()\n    {\n        _isRising = true;\n        _startTime = Time.time;\n        OnWaterStartRising?.Invoke();\n        \n        if (_audioSource != null && _risingSound != null)\n        {\n            _audioSource.clip = _risingSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    public void StopRising()\n    {\n        _isRising = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n    \n    public void PauseRising()\n    {\n        if (!_isRising)\n            return;\n            \n        _isPaused = true;\n        _pauseEndTime = Time.time + _pauseDuration;\n    }\n    \n    public void ResetWaterLevel()\n    {\n        _currentHeight = _initialHeight;\n        _hasReachedMax = false;\n        _isRising = false;\n        _isPaused = false;\n        _lastDamageTime.Clear();\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _currentHeight;\n        transform.position = newPosition;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n    \n    public void SetRiseSpeed(float newSpeed)\n    {\n        _riseSpeed = Mathf.Max(0f, newSpeed);\n    }\n    \n    public void SetMaxHeight(float newMaxHeight)\n    {\n        _maxHeight = newMaxHeight;\n    }\n    \n    public float GetWaterLevel()\n    {\n        return _currentHeight;\n    }\n    \n    public float GetWaterProgress()\n    {\n        if (_maxHeight <= _initialHeight)\n            return 0f;\n            \n        return Mathf.Clamp01((_currentHeight - _initialHeight) / (_maxHeight - _initialHeight));\n    }\n    \n    public bool IsRising()\n    {\n        return _isRising && !_hasReachedMax;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            OnPlayerContact?.Invoke(other.gameObject);\n            \n            if (_pauseOnPlayerContact)\n            {\n                PauseRising();\n            }\n            \n            PlaySplashEffect(other.transform.position);\n        }\n        \n        OnObjectSubmerged?.Invoke(other.gameObject);\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (ShouldDamageObject(other))\n        {\n            DealDamage(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_lastDamageTime.ContainsKey(other.gameObject))\n        {\n            _lastDamageTime.Remove(other.gameObject);\n        }\n    }\n    \n    private bool ShouldDamageObject(Collider other)\n    {\n        if (_damageAmount <= 0f)\n            return false;\n            \n        if ((_damageableLayers.value & (1 << other.gameObject.layer)) == 0)\n            return false;\n            \n        if (!_lastDamageTime.ContainsKey(other.gameObject))\n            return true;\n            \n        return Time.time >= _lastDamageTime[other.gameObject] + _damageInterval;\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        _lastDamageTime[target] = Time.time;\n        \n        // Try to find health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to call TakeDamage if it exists\n            var takeDamageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Alternative: Send message (safer approach)\n        target.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void PlaySplashEffect(Vector3 position)\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = position;\n            _splashEffect.Play();\n        }\n        \n        if (_audioSource != null && _splashSound != null)\n        {\n            _audioSource.PlayOneShot(_splashSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        \n        Vector3 currentPos = transform.position;\n        Vector3 maxPos = new Vector3(currentPos.x, _maxHeight, currentPos.z);\n        \n        // Draw current water level\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(currentPos, new Vector3(10f, 0.1f, 10f));\n        \n        // Draw max water level\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(maxPos, new Vector3(10f, 0.1f, 10f));\n        \n        // Draw rise direction\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(currentPos, maxPos);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "collapsing bridge",
      "ideal_ir": {
        "class_name": "CollapsingBridge",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "collapseDelay",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "shakeIntensity",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "hasCollapsed",
            "type": "bool",
            "default": false
          },
          {
            "name": "isShaking",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "trigger_collapse",
            "trigger": "when player steps onto the bridge",
            "actions": [
              {
                "action": "start shaking the bridge"
              },
              {
                "action": "play creaking sound effect"
              },
              {
                "action": "wait for collapse delay duration"
              }
            ]
          },
          {
            "name": "shake_bridge",
            "trigger": "when bridge is shaking",
            "actions": [
              {
                "action": "randomly move bridge position slightly up and down"
              },
              {
                "action": "randomly rotate bridge slightly left and right"
              }
            ]
          },
          {
            "name": "collapse_bridge",
            "trigger": "when collapse delay time has passed",
            "actions": [
              {
                "action": "stop shaking"
              },
              {
                "action": "enable physics on bridge"
              },
              {
                "action": "apply downward force to make bridge fall"
              },
              {
                "action": "play collapse sound effect"
              },
              {
                "action": "mark bridge as collapsed"
              }
            ]
          },
          {
            "name": "prevent_reuse",
            "trigger": "when bridge has already collapsed",
            "actions": [
              {
                "action": "ignore any further player interactions"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class CollapsingBridge : MonoBehaviour\n{\n    [Header(\"Bridge Settings\")]\n    [SerializeField] private float _collapseDelay = 2f;\n    [SerializeField] private float _collapseSpeed = 5f;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 1.5f;\n    [SerializeField] private bool _resetAfterCollapse = true;\n    [SerializeField] private float _resetDelay = 5f;\n    \n    [Header(\"Bridge Segments\")]\n    [SerializeField] private Transform[] _bridgeSegments;\n    [SerializeField] private float _segmentCollapseInterval = 0.2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _crackingSound;\n    [SerializeField] private AudioClip _collapseSound;\n    \n    [Header(\"Particles\")]\n    [SerializeField] private ParticleSystem _dustParticles;\n    [SerializeField] private ParticleSystem _debrisParticles;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBridgeTriggered;\n    public UnityEvent OnBridgeCollapsed;\n    public UnityEvent OnBridgeReset;\n    \n    private bool _isCollapsing = false;\n    private bool _hasCollapsed = false;\n    private Vector3[] _originalPositions;\n    private Quaternion[] _originalRotations;\n    private Rigidbody[] _segmentRigidbodies;\n    private Collider _triggerCollider;\n    private List<GameObject> _playersOnBridge = new List<GameObject>();\n    \n    private void Start()\n    {\n        InitializeBridge();\n    }\n    \n    private void InitializeBridge()\n    {\n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider != null)\n        {\n            _triggerCollider.isTrigger = true;\n        }\n        \n        if (_bridgeSegments == null || _bridgeSegments.Length == 0)\n        {\n            _bridgeSegments = new Transform[transform.childCount];\n            for (int i = 0; i < transform.childCount; i++)\n            {\n                _bridgeSegments[i] = transform.GetChild(i);\n            }\n        }\n        \n        _originalPositions = new Vector3[_bridgeSegments.Length];\n        _originalRotations = new Quaternion[_bridgeSegments.Length];\n        _segmentRigidbodies = new Rigidbody[_bridgeSegments.Length];\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null)\n            {\n                _originalPositions[i] = _bridgeSegments[i].position;\n                _originalRotations[i] = _bridgeSegments[i].rotation;\n                \n                _segmentRigidbodies[i] = _bridgeSegments[i].GetComponent<Rigidbody>();\n                if (_segmentRigidbodies[i] == null)\n                {\n                    _segmentRigidbodies[i] = _bridgeSegments[i].gameObject.AddComponent<Rigidbody>();\n                }\n                _segmentRigidbodies[i].isKinematic = true;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isCollapsing && !_hasCollapsed)\n        {\n            if (!_playersOnBridge.Contains(other.gameObject))\n            {\n                _playersOnBridge.Add(other.gameObject);\n                \n                if (_playersOnBridge.Count == 1)\n                {\n                    StartCoroutine(TriggerCollapse());\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playersOnBridge.Remove(other.gameObject);\n        }\n    }\n    \n    private IEnumerator TriggerCollapse()\n    {\n        _isCollapsing = true;\n        OnBridgeTriggered.Invoke();\n        \n        if (_crackingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_crackingSound);\n        }\n        \n        StartCoroutine(ShakeBridge());\n        \n        yield return new WaitForSeconds(_collapseDelay);\n        \n        StartCoroutine(CollapseBridge());\n    }\n    \n    private IEnumerator ShakeBridge()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _shakeDuration)\n        {\n            for (int i = 0; i < _bridgeSegments.Length; i++)\n            {\n                if (_bridgeSegments[i] != null)\n                {\n                    Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n                    randomOffset.y = Mathf.Abs(randomOffset.y);\n                    _bridgeSegments[i].position = _originalPositions[i] + randomOffset;\n                }\n            }\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null)\n            {\n                _bridgeSegments[i].position = _originalPositions[i];\n            }\n        }\n    }\n    \n    private IEnumerator CollapseBridge()\n    {\n        if (_collapseSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collapseSound);\n        }\n        \n        if (_dustParticles != null)\n        {\n            _dustParticles.Play();\n        }\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = false;\n                _segmentRigidbodies[i].AddForce(Vector3.down * _collapseSpeed, ForceMode.VelocityChange);\n                _segmentRigidbodies[i].AddTorque(Random.insideUnitSphere * _collapseSpeed * 0.5f, ForceMode.VelocityChange);\n                \n                if (_debrisParticles != null)\n                {\n                    ParticleSystem debris = Instantiate(_debrisParticles, _bridgeSegments[i].position, Quaternion.identity);\n                    debris.Play();\n                    Destroy(debris.gameObject, 3f);\n                }\n                \n                yield return new WaitForSeconds(_segmentCollapseInterval);\n            }\n        }\n        \n        _hasCollapsed = true;\n        OnBridgeCollapsed.Invoke();\n        \n        if (_resetAfterCollapse)\n        {\n            StartCoroutine(ResetBridge());\n        }\n    }\n    \n    private IEnumerator ResetBridge()\n    {\n        yield return new WaitForSeconds(_resetDelay);\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = true;\n                _segmentRigidbodies[i].velocity = Vector3.zero;\n                _segmentRigidbodies[i].angularVelocity = Vector3.zero;\n                \n                _bridgeSegments[i].position = _originalPositions[i];\n                _bridgeSegments[i].rotation = _originalRotations[i];\n            }\n        }\n        \n        _isCollapsing = false;\n        _hasCollapsed = false;\n        _playersOnBridge.Clear();\n        \n        OnBridgeReset.Invoke();\n    }\n    \n    public void ForceCollapse()\n    {\n        if (!_isCollapsing && !_hasCollapsed)\n        {\n            StartCoroutine(TriggerCollapse());\n        }\n    }\n    \n    public void ResetBridgeImmediate()\n    {\n        StopAllCoroutines();\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = true;\n                _segmentRigidbodies[i].velocity = Vector3.zero;\n                _segmentRigidbodies[i].angularVelocity = Vector3.zero;\n                \n                _bridgeSegments[i].position = _originalPositions[i];\n                _bridgeSegments[i].rotation = _originalRotations[i];\n            }\n        }\n        \n        _isCollapsing = false;\n        _hasCollapsed = false;\n        _playersOnBridge.Clear();\n        \n        OnBridgeReset.Invoke();\n    }\n    \n    public bool IsCollapsed => _hasCollapsed;\n    public bool IsCollapsing => _isCollapsing;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rotating blade obstacle",
      "ideal_ir": {
        "class_name": "RotatingBlade",
        "components": [
          "Transform",
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 180
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "rotationAxis",
            "type": "Vector3",
            "default": "Vector3.forward"
          }
        ],
        "behaviors": [
          {
            "name": "continuous_rotation",
            "trigger": "every frame",
            "actions": [
              {
                "action": "rotate around specified axis at rotation speed"
              }
            ]
          },
          {
            "name": "damage_player",
            "trigger": "when player collides with blade",
            "actions": [
              {
                "action": "deal damage to player"
              },
              {
                "action": "play metal clang sound effect"
              },
              {
                "action": "create spark particle effect at collision point"
              }
            ]
          },
          {
            "name": "damage_objects",
            "trigger": "when destructible object touches blade",
            "actions": [
              {
                "action": "destroy the object"
              },
              {
                "action": "create debris particle effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class RotatingBlade : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 360f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 1;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotationSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private bool _playRotationSound = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private float _hitFlashDuration = 0.1f;\n    [SerializeField] private Color _hitFlashColor = Color.red;\n    \n    private Renderer _renderer;\n    private Color _originalColor;\n    private bool _isFlashing = false;\n    private float _flashTimer = 0f;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _rotationSound != null && _playRotationSound)\n        {\n            _audioSource.clip = _rotationSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void Update()\n    {\n        RotateBlade();\n        HandleFlashEffect();\n    }\n\n    private void RotateBlade()\n    {\n        float rotationDirection = _clockwise ? 1f : -1f;\n        Vector3 rotation = _rotationAxis * _rotationSpeed * rotationDirection * Time.deltaTime;\n        transform.Rotate(rotation, Space.Self);\n    }\n\n    private void HandleFlashEffect()\n    {\n        if (_isFlashing)\n        {\n            _flashTimer -= Time.deltaTime;\n            if (_flashTimer <= 0f)\n            {\n                _isFlashing = false;\n                if (_renderer != null && _renderer.material != null)\n                {\n                    _renderer.material.color = _originalColor;\n                }\n            }\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other.gameObject);\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        HandleCollision(other.gameObject);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.gameObject);\n    }\n\n    private void OnCollisionStay(Collision collision)\n    {\n        HandleCollision(collision.gameObject);\n    }\n\n    private void HandleCollision(GameObject target)\n    {\n        if (target == null) return;\n        \n        if (!IsInDamageableLayer(target)) return;\n        \n        if (!CanDamageTarget(target)) return;\n        \n        DealDamage(target);\n        PlayHitEffects(target);\n        UpdateLastDamageTime(target);\n    }\n\n    private bool IsInDamageableLayer(GameObject target)\n    {\n        return (_damageableLayers.value & (1 << target.layer)) != 0;\n    }\n\n    private bool CanDamageTarget(GameObject target)\n    {\n        if (!_lastDamageTime.ContainsKey(target))\n        {\n            return true;\n        }\n        \n        return Time.time - _lastDamageTime[target] >= _damageInterval;\n    }\n\n    private void DealDamage(GameObject target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            var playerScript = target.GetComponent<MonoBehaviour>();\n            if (playerScript != null)\n            {\n                playerScript.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n        else\n        {\n            var healthComponent = target.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                healthComponent.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n\n    private void PlayHitEffects(GameObject target)\n    {\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n        \n        if (_sparkParticles != null)\n        {\n            _sparkParticles.transform.position = GetClosestPoint(target.transform.position);\n            _sparkParticles.Play();\n        }\n        \n        TriggerFlashEffect();\n    }\n\n    private void TriggerFlashEffect()\n    {\n        if (_renderer != null && _renderer.material != null)\n        {\n            _renderer.material.color = _hitFlashColor;\n            _isFlashing = true;\n            _flashTimer = _hitFlashDuration;\n        }\n    }\n\n    private Vector3 GetClosestPoint(Vector3 targetPosition)\n    {\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            return col.ClosestPoint(targetPosition);\n        }\n        return transform.position;\n    }\n\n    private void UpdateLastDamageTime(GameObject target)\n    {\n        _lastDamageTime[target] = Time.time;\n    }\n\n    private void OnDisable()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        _lastDamageTime.Clear();\n    }\n\n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = speed;\n    }\n\n    public void SetClockwise(bool clockwise)\n    {\n        _clockwise = clockwise;\n    }\n\n    public void SetDamage(int damage)\n    {\n        _damage = Mathf.Max(0, damage);\n    }\n\n    public void ToggleRotation()\n    {\n        enabled = !enabled;\n        \n        if (_audioSource != null)\n        {\n            if (enabled && _playRotationSound)\n            {\n                _audioSource.Play();\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "steam vent that damages",
      "ideal_ir": {
        "class_name": "SteamVent",
        "components": [
          "Collider",
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "damageAmount",
            "type": "float",
            "default": 10
          },
          {
            "name": "damageInterval",
            "type": "float",
            "default": 1
          },
          {
            "name": "ventDuration",
            "type": "float",
            "default": 3
          },
          {
            "name": "cooldownDuration",
            "type": "float",
            "default": 5
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_steam_vent",
            "trigger": "when cooldown period ends",
            "actions": [
              {
                "action": "set vent to active state"
              },
              {
                "action": "start steam particle effects"
              },
              {
                "action": "play steam hissing sound"
              },
              {
                "action": "begin vent duration timer"
              }
            ]
          },
          {
            "name": "deactivate_steam_vent",
            "trigger": "when vent duration expires",
            "actions": [
              {
                "action": "set vent to inactive state"
              },
              {
                "action": "stop steam particle effects"
              },
              {
                "action": "stop steam sound"
              },
              {
                "action": "begin cooldown timer"
              }
            ]
          },
          {
            "name": "damage_player",
            "trigger": "when player enters vent area while active",
            "actions": [
              {
                "action": "apply damage to player health"
              },
              {
                "action": "start continuous damage timer"
              }
            ]
          },
          {
            "name": "continuous_damage",
            "trigger": "when damage interval timer expires while player in vent area",
            "actions": [
              {
                "action": "apply damage to player health"
              },
              {
                "action": "reset damage interval timer"
              }
            ]
          },
          {
            "name": "stop_damage",
            "trigger": "when player exits vent area",
            "actions": [
              {
                "action": "stop continuous damage timer"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SteamVent : MonoBehaviour\n{\n    [Header(\"Steam Settings\")]\n    [SerializeField] private float _steamDuration = 3f;\n    [SerializeField] private float _cooldownDuration = 5f;\n    [SerializeField] private bool _startActive = false;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _steamParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _steamSound;\n    \n    [Header(\"Warning System\")]\n    [SerializeField] private float _warningDuration = 1f;\n    [SerializeField] private GameObject _warningIndicator;\n    [SerializeField] private Light _warningLight;\n    [SerializeField] private Color _warningColor = Color.red;\n    \n    private bool _isActive = false;\n    private bool _isWarning = false;\n    private Collider _ventCollider;\n    private Color _originalLightColor;\n    private System.Collections.Generic.List<GameObject> _playersInRange = new System.Collections.Generic.List<GameObject>();\n    \n    private void Start()\n    {\n        _ventCollider = GetComponent<Collider>();\n        if (_ventCollider == null)\n        {\n            _ventCollider = gameObject.AddComponent<BoxCollider>();\n            _ventCollider.isTrigger = true;\n        }\n        \n        if (_warningLight != null)\n        {\n            _originalLightColor = _warningLight.color;\n            _warningLight.enabled = false;\n        }\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(false);\n        }\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Stop();\n        }\n        \n        if (_startActive)\n        {\n            StartCoroutine(SteamCycle());\n        }\n        else\n        {\n            StartCoroutine(SteamCycleWithDelay());\n        }\n    }\n    \n    private IEnumerator SteamCycleWithDelay()\n    {\n        yield return new WaitForSeconds(_cooldownDuration);\n        StartCoroutine(SteamCycle());\n    }\n    \n    private IEnumerator SteamCycle()\n    {\n        while (true)\n        {\n            yield return StartCoroutine(ShowWarning());\n            yield return StartCoroutine(ActivateSteam());\n            yield return new WaitForSeconds(_cooldownDuration);\n        }\n    }\n    \n    private IEnumerator ShowWarning()\n    {\n        _isWarning = true;\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(true);\n        }\n        \n        if (_warningLight != null)\n        {\n            _warningLight.enabled = true;\n            _warningLight.color = _warningColor;\n        }\n        \n        float elapsed = 0f;\n        while (elapsed < _warningDuration)\n        {\n            if (_warningLight != null)\n            {\n                _warningLight.intensity = Mathf.PingPong(Time.time * 3f, 1f) + 0.5f;\n            }\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _isWarning = false;\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(false);\n        }\n        \n        if (_warningLight != null)\n        {\n            _warningLight.enabled = false;\n            _warningLight.color = _originalLightColor;\n            _warningLight.intensity = 1f;\n        }\n    }\n    \n    private IEnumerator ActivateSteam()\n    {\n        _isActive = true;\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Play();\n        }\n        \n        if (_audioSource != null && _steamSound != null)\n        {\n            _audioSource.clip = _steamSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        StartCoroutine(DamagePlayersInRange());\n        \n        yield return new WaitForSeconds(_steamDuration);\n        \n        _isActive = false;\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private IEnumerator DamagePlayersInRange()\n    {\n        while (_isActive)\n        {\n            foreach (GameObject player in _playersInRange)\n            {\n                if (player != null)\n                {\n                    DamagePlayer(player);\n                }\n            }\n            yield return new WaitForSeconds(_damageInterval);\n        }\n    }\n    \n    private void DamagePlayer(GameObject player)\n    {\n        var playerScript = player.GetComponent<MonoBehaviour>();\n        if (playerScript != null)\n        {\n            player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        var rigidbody = player.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            Vector3 knockbackDirection = (player.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.5f;\n            rigidbody.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            if (!_playersInRange.Contains(other.gameObject))\n            {\n                _playersInRange.Add(other.gameObject);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playersInRange.Remove(other.gameObject);\n        }\n    }\n    \n    public void TriggerSteam()\n    {\n        if (!_isActive && !_isWarning)\n        {\n            StopAllCoroutines();\n            StartCoroutine(SteamCycle());\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        if (active && !_isActive && !_isWarning)\n        {\n            StopAllCoroutines();\n            StartCoroutine(SteamCycle());\n        }\n        else if (!active)\n        {\n            StopAllCoroutines();\n            _isActive = false;\n            _isWarning = false;\n            \n            if (_steamParticles != null)\n            {\n                _steamParticles.Stop();\n            }\n            \n            if (_audioSource != null)\n            {\n                _audioSource.Stop();\n            }\n            \n            if (_warningIndicator != null)\n            {\n                _warningIndicator.SetActive(false);\n            }\n            \n            if (_warningLight != null)\n            {\n                _warningLight.enabled = false;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActive ? Color.red : (_isWarning ? Color.yellow : Color.blue);\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "acid pool hazard",
      "ideal_ir": {
        "class_name": "AcidPoolHazard",
        "components": [
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "damageAmount",
            "type": "float",
            "default": 25
          },
          {
            "name": "damageInterval",
            "type": "float",
            "default": 1
          },
          {
            "name": "bubbleEffectIntensity",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "acidSizzleVolume",
            "type": "float",
            "default": 0.3
          }
        ],
        "behaviors": [
          {
            "name": "damage_player_on_contact",
            "trigger": "when player enters acid pool area",
            "actions": [
              {
                "action": "start continuous damage to player"
              },
              {
                "action": "play acid sizzling sound effect"
              },
              {
                "action": "increase bubble particle effects"
              }
            ]
          },
          {
            "name": "continuous_damage_while_in_pool",
            "trigger": "while player remains in acid pool",
            "actions": [
              {
                "action": "apply damage to player at regular intervals"
              },
              {
                "action": "maintain sizzling audio loop"
              },
              {
                "action": "keep bubble effects active"
              }
            ]
          },
          {
            "name": "stop_damage_on_exit",
            "trigger": "when player exits acid pool area",
            "actions": [
              {
                "action": "stop applying damage to player"
              },
              {
                "action": "fade out sizzling sound effect"
              },
              {
                "action": "reduce bubble particle effects to normal level"
              }
            ]
          },
          {
            "name": "ambient_bubbling",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "play subtle bubbling particle effects"
              },
              {
                "action": "emit low ambient acid pool sounds"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AcidPoolHazard : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private bool _continuousDamage = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private Color _acidColor = Color.green;\n    [SerializeField] private float _dissolveSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _damageSound;\n    [SerializeField] private AudioClip _bubbleSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _waveAmplitude = 0.1f;\n    [SerializeField] private float _waveFrequency = 1f;\n    [SerializeField] private Transform _surfaceTransform;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectEnterAcid;\n    public UnityEvent<GameObject> OnObjectExitAcid;\n    public UnityEvent<GameObject, float> OnDamageDealt;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _acidMaterial;\n    private Vector3 _originalSurfacePosition;\n    private float _waveTimer;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _objectsInAcid = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    [System.Serializable]\n    private class DissolvableObject\n    {\n        public GameObject gameObject;\n        public Renderer renderer;\n        public Material originalMaterial;\n        public float dissolveProgress;\n        public bool isDissolving;\n        \n        public DissolvableObject(GameObject obj)\n        {\n            gameObject = obj;\n            renderer = obj.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                originalMaterial = renderer.material;\n            }\n            dissolveProgress = 0f;\n            isDissolving = false;\n        }\n    }\n    \n    private System.Collections.Generic.List<DissolvableObject> _dissolvingObjects = \n        new System.Collections.Generic.List<DissolvableObject>();\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupAcidMaterial();\n        StartBubbleEffects();\n        \n        if (_surfaceTransform != null)\n        {\n            _originalSurfacePosition = _surfaceTransform.localPosition;\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.spatialBlend = 1f;\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_bubbleEffect == null)\n        {\n            _bubbleEffect = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void SetupAcidMaterial()\n    {\n        if (_renderer != null)\n        {\n            _acidMaterial = _renderer.material;\n            _acidMaterial.color = _acidColor;\n            \n            if (_acidMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _acidMaterial.SetColor(\"_EmissionColor\", _acidColor * 0.3f);\n                _acidMaterial.EnableKeyword(\"_EMISSION\");\n            }\n        }\n    }\n    \n    private void StartBubbleEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            _bubbleEffect.Play();\n        }\n        \n        if (_bubbleSound != null)\n        {\n            _audioSource.clip = _bubbleSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateWaveAnimation();\n        ProcessContinuousDamage();\n        UpdateDissolvingObjects();\n    }\n    \n    private void UpdateWaveAnimation()\n    {\n        if (_surfaceTransform == null) return;\n        \n        _waveTimer += Time.deltaTime * _waveFrequency;\n        float waveOffset = Mathf.Sin(_waveTimer) * _waveAmplitude;\n        \n        _surfaceTransform.localPosition = _originalSurfacePosition + Vector3.up * waveOffset;\n    }\n    \n    private void ProcessContinuousDamage()\n    {\n        if (!_continuousDamage) return;\n        \n        var objectsToRemove = new System.Collections.Generic.List<GameObject>();\n        var objectsToUpdate = new System.Collections.Generic.List<GameObject>(_objectsInAcid.Keys);\n        \n        foreach (var obj in objectsToUpdate)\n        {\n            if (obj == null)\n            {\n                objectsToRemove.Add(obj);\n                continue;\n            }\n            \n            _objectsInAcid[obj] += Time.deltaTime;\n            \n            if (_objectsInAcid[obj] >= _damageInterval)\n            {\n                DealDamage(obj);\n                _objectsInAcid[obj] = 0f;\n            }\n        }\n        \n        foreach (var obj in objectsToRemove)\n        {\n            _objectsInAcid.Remove(obj);\n        }\n    }\n    \n    private void UpdateDissolvingObjects()\n    {\n        for (int i = _dissolvingObjects.Count - 1; i >= 0; i--)\n        {\n            var dissolvable = _dissolvingObjects[i];\n            \n            if (dissolvable.gameObject == null)\n            {\n                _dissolvingObjects.RemoveAt(i);\n                continue;\n            }\n            \n            if (dissolvable.isDissolving)\n            {\n                dissolvable.dissolveProgress += Time.deltaTime * _dissolveSpeed;\n                \n                if (dissolvable.renderer != null && dissolvable.renderer.material.HasProperty(\"_Cutoff\"))\n                {\n                    dissolvable.renderer.material.SetFloat(\"_Cutoff\", dissolvable.dissolveProgress);\n                }\n                else if (dissolvable.renderer != null)\n                {\n                    Color color = dissolvable.renderer.material.color;\n                    color.a = Mathf.Lerp(1f, 0f, dissolvable.dissolveProgress);\n                    dissolvable.renderer.material.color = color;\n                }\n                \n                if (dissolvable.dissolveProgress >= 1f)\n                {\n                    if (dissolvable.gameObject != null)\n                    {\n                        Destroy(dissolvable.gameObject);\n                    }\n                    _dissolvingObjects.RemoveAt(i);\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other == null) return;\n        \n        PlaySplashEffect(other.transform.position);\n        PlayEnterSound();\n        \n        if (!_objectsInAcid.ContainsKey(other.gameObject))\n        {\n            _objectsInAcid.Add(other.gameObject, 0f);\n            OnObjectEnterAcid?.Invoke(other.gameObject);\n            \n            if (!_continuousDamage)\n            {\n                DealDamage(other.gameObject);\n            }\n            \n            StartDissolving(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other == null) return;\n        \n        if (_objectsInAcid.ContainsKey(other.gameObject))\n        {\n            _objectsInAcid.Remove(other.gameObject);\n            OnObjectExitAcid?.Invoke(other.gameObject);\n        }\n    }\n    \n    private void PlaySplashEffect(Vector3 position)\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = position;\n            _splashEffect.Play();\n        }\n    }\n    \n    private void PlayEnterSound()\n    {\n        if (_enterSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_enterSound, _audioVolume);\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try to find and damage player\n        if (target.CompareTag(\"Player\"))\n        {\n            var characterController = target.GetComponent<CharacterController>();\n            if (characterController != null)\n            {\n                // Apply knockback\n                Vector3 knockback = (target.transform.position - transform.position).normalized * 2f;\n                knockback.y = 1f;\n                characterController.Move(knockback * Time.deltaTime);\n            }\n        }\n        \n        // Try to damage any object with health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to try to call TakeDamage method if it exists\n            var takeDamageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Destroy non-player objects after some time\n        if (!target.CompareTag(\"Player\"))\n        {\n            var rigidbody = target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                rigidbody.AddForce(Vector3.down * 5f, ForceMode.Impulse);\n            }\n        }\n        \n        PlayDamageSound();\n        OnDamageDealt?.Invoke(target, _damageAmount);\n    }\n    \n    private void PlayDamageSound()\n    {\n        if (_damageSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_damageSound, _audioVolume);\n        }\n    }\n    \n    private void StartDissolving(GameObject target)\n    {\n        if (target.CompareTag(\"Player\")) return;\n        \n        var existingDissolvable = _dissolvingObjects.Find(d => d.gameObject == target);\n        if (existingDissolvable == null)\n        {\n            var newDissolvable = new DissolvableObject(target);\n            newDissolvable.isDissolving = true;\n            _dissolvingObjects.Add(newDissolvable);\n        }\n    }\n    \n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = Mathf.Max(0f, damage);\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = Mathf.Max(0.1f, interval);\n    }\n    \n    public void EnableContinuousDamage(bool enable)\n    {\n        _continuousDamage = enable;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_acidMaterial != null)\n        {\n            Destroy(_acidMaterial);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "magnetic field zone",
      "ideal_ir": {
        "class_name": "MagneticFieldZone",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "fieldStrength",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "attractionRadius",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "affectMetalObjects",
            "type": "bool",
            "default": true
          },
          {
            "name": "affectElectronicDevices",
            "type": "bool",
            "default": false
          },
          {
            "name": "pulseEffect",
            "type": "bool",
            "default": false
          },
          {
            "name": "pulseFrequency",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "attract_metal_objects",
            "trigger": "when metal objects are within attraction radius",
            "actions": [
              {
                "action": "pull metal objects toward the center of the magnetic field"
              },
              {
                "action": "apply force proportional to field strength and object mass"
              }
            ]
          },
          {
            "name": "disrupt_electronics",
            "trigger": "when electronic devices enter the magnetic field and affect electronics is enabled",
            "actions": [
              {
                "action": "cause electronic devices to malfunction temporarily"
              },
              {
                "action": "create visual static or interference effects on screens"
              }
            ]
          },
          {
            "name": "pulse_magnetic_field",
            "trigger": "when pulse effect is enabled and pulse timer reaches frequency interval",
            "actions": [
              {
                "action": "temporarily increase field strength"
              },
              {
                "action": "create expanding visual pulse effect"
              },
              {
                "action": "reset pulse timer"
              }
            ]
          },
          {
            "name": "repel_objects",
            "trigger": "when field strength is set to negative value",
            "actions": [
              {
                "action": "push metal objects away from the center"
              },
              {
                "action": "apply repulsive force based on absolute field strength"
              }
            ]
          },
          {
            "name": "visual_field_indicator",
            "trigger": "continuously while magnetic field is active",
            "actions": [
              {
                "action": "display particle effects showing magnetic field lines"
              },
              {
                "action": "animate field visualization based on current strength"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MagneticFieldZone : MonoBehaviour\n{\n    [Header(\"Magnetic Field Settings\")]\n    [SerializeField] private float _magneticStrength = 10f;\n    [SerializeField] private float _maxRange = 15f;\n    [SerializeField] private AnimationCurve _strengthFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Magnetic Behavior\")]\n    [SerializeField] private bool _attractMetalObjects = true;\n    [SerializeField] private bool _repelMetalObjects = false;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectCharacterControllers = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _magneticParticles;\n    [SerializeField] private LineRenderer _fieldLines;\n    [SerializeField] private Material _fieldLineMaterial;\n    [SerializeField] private int _fieldLineCount = 8;\n    [SerializeField] private float _fieldLineLength = 10f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _magneticHumSound;\n    [SerializeField] private float _baseVolume = 0.5f;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.02f;\n    [SerializeField] private int _maxAffectedObjects = 50;\n    \n    private List<MagneticObject> _affectedObjects = new List<MagneticObject>();\n    private SphereCollider _detectionCollider;\n    private float _lastUpdateTime;\n    private bool _isActive = true;\n    \n    [System.Serializable]\n    private class MagneticObject\n    {\n        public Transform transform;\n        public Rigidbody rigidbody;\n        public CharacterController characterController;\n        public float metallic = 1f;\n        public Vector3 originalVelocity;\n        \n        public MagneticObject(Transform t, Rigidbody rb, CharacterController cc, float metalValue)\n        {\n            transform = t;\n            rigidbody = rb;\n            characterController = cc;\n            metallic = metalValue;\n        }\n    }\n    \n    private void Start()\n    {\n        SetupDetectionCollider();\n        SetupVisualEffects();\n        SetupAudio();\n    }\n    \n    private void SetupDetectionCollider()\n    {\n        _detectionCollider = GetComponent<SphereCollider>();\n        if (_detectionCollider == null)\n        {\n            _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _maxRange;\n    }\n    \n    private void SetupVisualEffects()\n    {\n        if (_fieldLines == null)\n        {\n            GameObject fieldLinesObj = new GameObject(\"FieldLines\");\n            fieldLinesObj.transform.SetParent(transform);\n            fieldLinesObj.transform.localPosition = Vector3.zero;\n            _fieldLines = fieldLinesObj.AddComponent<LineRenderer>();\n        }\n        \n        if (_fieldLines != null && _fieldLineMaterial != null)\n        {\n            _fieldLines.material = _fieldLineMaterial;\n            _fieldLines.startWidth = 0.1f;\n            _fieldLines.endWidth = 0.05f;\n            _fieldLines.positionCount = _fieldLineCount * 2;\n            _fieldLines.useWorldSpace = true;\n        }\n        \n        UpdateFieldLines();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_audioSource != null && _magneticHumSound != null)\n        {\n            _audioSource.clip = _magneticHumSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _baseVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isActive) return;\n        \n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            ApplyMagneticForces();\n            UpdateVisualEffects();\n            UpdateAudio();\n            _lastUpdateTime = Time.time;\n        }\n    }\n    \n    private void ApplyMagneticForces()\n    {\n        for (int i = _affectedObjects.Count - 1; i >= 0; i--)\n        {\n            if (_affectedObjects[i].transform == null)\n            {\n                _affectedObjects.RemoveAt(i);\n                continue;\n            }\n            \n            ApplyForceToObject(_affectedObjects[i]);\n        }\n    }\n    \n    private void ApplyForceToObject(MagneticObject magneticObj)\n    {\n        Vector3 direction = transform.position - magneticObj.transform.position;\n        float distance = direction.magnitude;\n        \n        if (distance > _maxRange)\n        {\n            _affectedObjects.Remove(magneticObj);\n            return;\n        }\n        \n        if (distance < 0.1f) return;\n        \n        direction.Normalize();\n        \n        float normalizedDistance = distance / _maxRange;\n        float strengthMultiplier = _strengthFalloff.Evaluate(1f - normalizedDistance);\n        float force = _magneticStrength * strengthMultiplier * magneticObj.metallic;\n        \n        if (_repelMetalObjects)\n        {\n            direction = -direction;\n        }\n        \n        Vector3 magneticForce = direction * force;\n        \n        if (_affectRigidbodies && magneticObj.rigidbody != null)\n        {\n            magneticObj.rigidbody.AddForce(magneticForce, ForceMode.Force);\n        }\n        else if (_affectCharacterControllers && magneticObj.characterController != null)\n        {\n            Vector3 movement = magneticForce * Time.deltaTime / magneticObj.characterController.mass;\n            magneticObj.characterController.Move(movement);\n        }\n        else\n        {\n            magneticObj.transform.position += magneticForce * Time.deltaTime * 0.1f;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_magneticParticles != null)\n        {\n            var emission = _magneticParticles.emission;\n            emission.rateOverTime = _affectedObjects.Count * 10f;\n        }\n        \n        UpdateFieldLines();\n    }\n    \n    private void UpdateFieldLines()\n    {\n        if (_fieldLines == null) return;\n        \n        Vector3[] positions = new Vector3[_fieldLineCount * 2];\n        \n        for (int i = 0; i < _fieldLineCount; i++)\n        {\n            float angle = (360f / _fieldLineCount) * i;\n            Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.forward;\n            \n            positions[i * 2] = transform.position;\n            positions[i * 2 + 1] = transform.position + direction * _fieldLineLength;\n        }\n        \n        _fieldLines.positionCount = positions.Length;\n        _fieldLines.SetPositions(positions);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float volumeMultiplier = Mathf.Clamp01(_affectedObjects.Count / 10f);\n            _audioSource.volume = _baseVolume * volumeMultiplier;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive) return;\n        if (_affectedObjects.Count >= _maxAffectedObjects) return;\n        if (((1 << other.gameObject.layer) & _affectedLayers) == 0) return;\n        \n        float metallicValue = GetMetallicValue(other);\n        if (metallicValue <= 0f) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        CharacterController cc = other.GetComponent<CharacterController>();\n        \n        if (rb != null || cc != null || other.CompareTag(\"Player\"))\n        {\n            MagneticObject magneticObj = new MagneticObject(other.transform, rb, cc, metallicValue);\n            _affectedObjects.Add(magneticObj);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        for (int i = _affectedObjects.Count - 1; i >= 0; i--)\n        {\n            if (_affectedObjects[i].transform == other.transform)\n            {\n                _affectedObjects.RemoveAt(i);\n                break;\n            }\n        }\n    }\n    \n    private float GetMetallicValue(Collider other)\n    {\n        if (other.CompareTag(\"Metal\")) return 1f;\n        if (other.CompareTag(\"Player\")) return 0.3f;\n        if (other.name.ToLower().Contains(\"metal\")) return 0.8f;\n        if (other.name.ToLower().Contains(\"iron\")) return 1f;\n        if (other.name.ToLower().Contains(\"steel\")) return 0.9f;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && rb.mass > 1f) return 0.5f;\n        \n        return 0.2f;\n    }\n    \n    public void SetMagneticStrength(float strength)\n    {\n        _magneticStrength = Mathf.Max(0f, strength);\n    }\n    \n    public void SetMaxRange(float range)\n    {\n        _maxRange = Mathf.Max(0.1f, range);\n        if (_detectionCollider != null)\n        {\n            _detectionCollider.radius = _maxRange;\n        }\n    }\n    \n    public void ToggleAttraction()\n    {\n        _attractMetalObjects = !_attractMetalObjects;\n        _repelMetalObjects = !_attractMetalObjects;\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (!active)\n        {\n            _affectedObjects.Clear();\n        }\n        \n        if (_magneticParticles != null)\n        {\n            if (active)\n                _magneticParticles.Play();\n            else\n                _magneticParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (active && !_audioSource.isPlaying)\n                _audioSource.Play();\n            else if (!active && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n    }\n    \n    public int GetAffectedObjectCount()\n    {\n        return _affectedObjects.Count;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _maxRange);\n        \n        Gizmos.color = Color.cyan;\n        for (int i = 0; i < _affectedObjects.Count; i++)\n        {\n            if (_affectedObjects[i].transform != null)\n            {\n                Gizmos.DrawLine(transform.position, _affectedObjects[i].transform.position);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "gravity flip zone",
      "ideal_ir": {
        "class_name": "GravityFlipZone",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "flipDirection",
            "type": "Vector3",
            "default": "0, 1, 0"
          },
          {
            "name": "flipForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "affectDuration",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "flip_gravity_on_enter",
            "trigger": "when object with rigidbody enters trigger zone",
            "actions": [
              {
                "action": "reverse the gravity direction for the entering object"
              },
              {
                "action": "apply upward force in the flip direction"
              },
              {
                "action": "play gravity flip sound effect"
              },
              {
                "action": "create visual particle effect at flip location"
              }
            ]
          },
          {
            "name": "maintain_flipped_gravity",
            "trigger": "while object remains in flip zone",
            "actions": [
              {
                "action": "continuously apply gravity in flipped direction"
              },
              {
                "action": "prevent normal gravity from affecting the object"
              }
            ]
          },
          {
            "name": "restore_gravity_on_exit",
            "trigger": "when object leaves the trigger zone",
            "actions": [
              {
                "action": "restore normal gravity direction for the object"
              },
              {
                "action": "gradually transition back to standard physics"
              },
              {
                "action": "fade out any lingering flip effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GravityFlipZone : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private Vector3 _newGravityDirection = Vector3.up;\n    [SerializeField] private float _gravityStrength = 9.81f;\n    [SerializeField] private bool _useGlobalGravity = false;\n    \n    [Header(\"Zone Behavior\")]\n    [SerializeField] private bool _flipOnEnter = true;\n    [SerializeField] private bool _revertOnExit = true;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectCharacterControllers = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private ParticleSystem _enterEffect;\n    [SerializeField] private ParticleSystem _exitEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectEnterZone;\n    public UnityEvent<GameObject> OnObjectExitZone;\n    \n    private Vector3 _originalGravity;\n    private System.Collections.Generic.Dictionary<GameObject, GravityData> _affectedObjects;\n    \n    private class GravityData\n    {\n        public Vector3 originalGravity;\n        public Rigidbody rigidbody;\n        public CharacterController characterController;\n        public bool wasUsingGravity;\n        \n        public GravityData(Rigidbody rb, CharacterController cc)\n        {\n            rigidbody = rb;\n            characterController = cc;\n            originalGravity = Physics.gravity;\n            wasUsingGravity = rb != null ? rb.useGravity : false;\n        }\n    }\n    \n    private void Start()\n    {\n        _originalGravity = Physics.gravity;\n        _affectedObjects = new System.Collections.Generic.Dictionary<GameObject, GravityData>();\n        \n        if (GetComponent<Collider>() == null)\n        {\n            Debug.LogWarning(\"GravityFlipZone requires a Collider component set as trigger!\");\n        }\n        else\n        {\n            GetComponent<Collider>().isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_flipOnEnter) return;\n        \n        GameObject obj = other.gameObject;\n        \n        if (_affectedObjects.ContainsKey(obj)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        CharacterController cc = other.GetComponent<CharacterController>();\n        \n        if ((!_affectRigidbodies || rb == null) && (!_affectCharacterControllers || cc == null))\n            return;\n        \n        GravityData gravityData = new GravityData(rb, cc);\n        _affectedObjects[obj] = gravityData;\n        \n        ApplyGravityFlip(obj, gravityData);\n        \n        PlayEffect(_enterEffect);\n        PlaySound(_enterSound);\n        \n        OnObjectEnterZone?.Invoke(obj);\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_revertOnExit) return;\n        \n        GameObject obj = other.gameObject;\n        \n        if (!_affectedObjects.ContainsKey(obj)) return;\n        \n        GravityData gravityData = _affectedObjects[obj];\n        RevertGravity(obj, gravityData);\n        \n        _affectedObjects.Remove(obj);\n        \n        PlayEffect(_exitEffect);\n        PlaySound(_exitSound);\n        \n        OnObjectExitZone?.Invoke(obj);\n    }\n    \n    private void ApplyGravityFlip(GameObject obj, GravityData gravityData)\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = _newGravityDirection.normalized * _gravityStrength;\n        }\n        else\n        {\n            if (gravityData.rigidbody != null && _affectRigidbodies)\n            {\n                gravityData.rigidbody.useGravity = false;\n                ApplyCustomGravityToRigidbody(gravityData.rigidbody);\n            }\n        }\n        \n        if (gravityData.characterController != null && _affectCharacterControllers)\n        {\n            CustomCharacterGravity customGravity = obj.GetComponent<CustomCharacterGravity>();\n            if (customGravity == null)\n            {\n                customGravity = obj.AddComponent<CustomCharacterGravity>();\n            }\n            customGravity.SetGravity(_newGravityDirection.normalized * _gravityStrength);\n        }\n    }\n    \n    private void RevertGravity(GameObject obj, GravityData gravityData)\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = gravityData.originalGravity;\n        }\n        else\n        {\n            if (gravityData.rigidbody != null && _affectRigidbodies)\n            {\n                gravityData.rigidbody.useGravity = gravityData.wasUsingGravity;\n            }\n        }\n        \n        if (gravityData.characterController != null && _affectCharacterControllers)\n        {\n            CustomCharacterGravity customGravity = obj.GetComponent<CustomCharacterGravity>();\n            if (customGravity != null)\n            {\n                customGravity.RevertToOriginalGravity();\n            }\n        }\n    }\n    \n    private void ApplyCustomGravityToRigidbody(Rigidbody rb)\n    {\n        if (rb != null)\n        {\n            rb.AddForce(_newGravityDirection.normalized * _gravityStrength * rb.mass, ForceMode.Acceleration);\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_useGlobalGravity)\n        {\n            foreach (var kvp in _affectedObjects)\n            {\n                GravityData gravityData = kvp.Value;\n                if (gravityData.rigidbody != null && _affectRigidbodies)\n                {\n                    ApplyCustomGravityToRigidbody(gravityData.rigidbody);\n                }\n            }\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        Gizmos.color = Color.red;\n        Vector3 arrowStart = transform.position;\n        Vector3 arrowEnd = arrowStart + _newGravityDirection.normalized * 2f;\n        Gizmos.DrawLine(arrowStart, arrowEnd);\n        Gizmos.DrawSphere(arrowEnd, 0.1f);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = _originalGravity;\n        }\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            RevertGravity(kvp.Key, kvp.Value);\n        }\n    }\n}\n\npublic class CustomCharacterGravity : MonoBehaviour\n{\n    private CharacterController _characterController;\n    private Vector3 _customGravity;\n    private Vector3 _originalGravity;\n    private Vector3 _velocity;\n    private bool _isUsingCustomGravity;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _originalGravity = Vector3.down * 9.81f;\n        _customGravity = _originalGravity;\n    }\n    \n    public void SetGravity(Vector3 gravity)\n    {\n        _customGravity = gravity;\n        _isUsingCustomGravity = true;\n        _velocity = Vector3.zero;\n    }\n    \n    public void RevertToOriginalGravity()\n    {\n        _customGravity = _originalGravity;\n        _isUsingCustomGravity = false;\n        _velocity = Vector3.zero;\n    }\n    \n    private void Update()\n    {\n        if (_characterController != null && _isUsingCustomGravity)\n        {\n            if (_characterController.isGrounded)\n            {\n                _velocity.y = 0f;\n            }\n            \n            _velocity += _customGravity * Time.deltaTime;\n            _characterController.Move(_velocity * Time.deltaTime);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "time slow zone",
      "ideal_ir": {
        "class_name": "TimeSlowZone",
        "components": [
          "Collider"
        ],
        "fields": [
          {
            "name": "slowFactor",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "affectPlayer",
            "type": "bool",
            "default": true
          },
          {
            "name": "affectEnemies",
            "type": "bool",
            "default": true
          },
          {
            "name": "affectProjectiles",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "apply_time_slow_on_enter",
            "trigger": "when object enters the zone trigger area",
            "actions": [
              {
                "action": "check if object should be affected by time slow"
              },
              {
                "action": "apply slow time effect to the object using slow factor"
              },
              {
                "action": "add object to list of affected objects"
              }
            ]
          },
          {
            "name": "remove_time_slow_on_exit",
            "trigger": "when object exits the zone trigger area",
            "actions": [
              {
                "action": "restore normal time scale to the object"
              },
              {
                "action": "remove object from list of affected objects"
              }
            ]
          },
          {
            "name": "maintain_slow_effect",
            "trigger": "every frame while zone is active",
            "actions": [
              {
                "action": "ensure all objects in affected list maintain slow time effect"
              },
              {
                "action": "remove any destroyed objects from affected list"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeSlowZone : MonoBehaviour\n{\n    [Header(\"Time Control\")]\n    [SerializeField] private float _slowTimeScale = 0.3f;\n    [SerializeField] private float _transitionDuration = 0.5f;\n    [SerializeField] private bool _affectFixedTimeScale = true;\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _triggerOnEnter = true;\n    [SerializeField] private bool _resetOnExit = true;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _slowEffectParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    \n    [Header(\"Zone Indicator\")]\n    [SerializeField] private GameObject _zoneVisual;\n    [SerializeField] private Color _zoneColor = Color.cyan;\n    [SerializeField] private bool _pulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    \n    private float _originalTimeScale;\n    private float _originalFixedTimeScale;\n    private bool _isSlowActive = false;\n    private Coroutine _transitionCoroutine;\n    private Renderer _zoneRenderer;\n    private Material _zoneMaterial;\n    private Color _originalZoneColor;\n    \n    private void Start()\n    {\n        _originalTimeScale = Time.timeScale;\n        _originalFixedTimeScale = Time.fixedDeltaTime;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupZoneVisual();\n        \n        if (_slowEffectParticles != null)\n        {\n            _slowEffectParticles.Stop();\n        }\n    }\n    \n    private void SetupZoneVisual()\n    {\n        if (_zoneVisual != null)\n        {\n            _zoneRenderer = _zoneVisual.GetComponent<Renderer>();\n            if (_zoneRenderer != null)\n            {\n                _zoneMaterial = _zoneRenderer.material;\n                _originalZoneColor = _zoneMaterial.color;\n                _zoneMaterial.color = _zoneColor;\n            }\n        }\n        else\n        {\n            _zoneRenderer = GetComponent<Renderer>();\n            if (_zoneRenderer != null)\n            {\n                _zoneMaterial = _zoneRenderer.material;\n                _originalZoneColor = _zoneMaterial.color;\n                _zoneMaterial.color = _zoneColor;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (_pulseEffect && _zoneMaterial != null)\n        {\n            float alpha = Mathf.Lerp(0.3f, 0.8f, (Mathf.Sin(Time.unscaledTime * _pulseSpeed) + 1f) * 0.5f);\n            Color currentColor = _zoneMaterial.color;\n            currentColor.a = alpha;\n            _zoneMaterial.color = currentColor;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerOnEnter) return;\n        \n        if (string.IsNullOrEmpty(_targetTag) || other.CompareTag(_targetTag))\n        {\n            ActivateSlowTime();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_resetOnExit) return;\n        \n        if (string.IsNullOrEmpty(_targetTag) || other.CompareTag(_targetTag))\n        {\n            DeactivateSlowTime();\n        }\n    }\n    \n    public void ActivateSlowTime()\n    {\n        if (_isSlowActive) return;\n        \n        _isSlowActive = true;\n        \n        if (_transitionCoroutine != null)\n            StopCoroutine(_transitionCoroutine);\n            \n        _transitionCoroutine = StartCoroutine(TransitionTimeScale(_slowTimeScale));\n        \n        if (_slowEffectParticles != null)\n            _slowEffectParticles.Play();\n            \n        PlaySound(_enterSound);\n    }\n    \n    public void DeactivateSlowTime()\n    {\n        if (!_isSlowActive) return;\n        \n        _isSlowActive = false;\n        \n        if (_transitionCoroutine != null)\n            StopCoroutine(_transitionCoroutine);\n            \n        _transitionCoroutine = StartCoroutine(TransitionTimeScale(_originalTimeScale));\n        \n        if (_slowEffectParticles != null)\n            _slowEffectParticles.Stop();\n            \n        PlaySound(_exitSound);\n    }\n    \n    private IEnumerator TransitionTimeScale(float targetScale)\n    {\n        float startTimeScale = Time.timeScale;\n        float startFixedTimeScale = Time.fixedDeltaTime;\n        float targetFixedTimeScale = _originalFixedTimeScale * targetScale;\n        \n        float elapsed = 0f;\n        \n        while (elapsed < _transitionDuration)\n        {\n            elapsed += Time.unscaledDeltaTime;\n            float t = elapsed / _transitionDuration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            Time.timeScale = Mathf.Lerp(startTimeScale, targetScale, t);\n            \n            if (_affectFixedTimeScale)\n            {\n                Time.fixedDeltaTime = Mathf.Lerp(startFixedTimeScale, targetFixedTimeScale, t);\n            }\n            \n            yield return null;\n        }\n        \n        Time.timeScale = targetScale;\n        if (_affectFixedTimeScale)\n        {\n            Time.fixedDeltaTime = targetFixedTimeScale;\n        }\n        \n        _transitionCoroutine = null;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.pitch = Time.timeScale;\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void ToggleSlowTime()\n    {\n        if (_isSlowActive)\n            DeactivateSlowTime();\n        else\n            ActivateSlowTime();\n    }\n    \n    public void SetSlowTimeScale(float newScale)\n    {\n        _slowTimeScale = Mathf.Clamp(newScale, 0.01f, 1f);\n        \n        if (_isSlowActive)\n        {\n            if (_transitionCoroutine != null)\n                StopCoroutine(_transitionCoroutine);\n            _transitionCoroutine = StartCoroutine(TransitionTimeScale(_slowTimeScale));\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_isSlowActive)\n        {\n            Time.timeScale = _originalTimeScale;\n            if (_affectFixedTimeScale)\n            {\n                Time.fixedDeltaTime = _originalFixedTimeScale;\n            }\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_zoneMaterial != null && _originalZoneColor != Color.clear)\n        {\n            _zoneMaterial.color = _originalZoneColor;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "darkness zone that limits vision",
      "ideal_ir": {
        "class_name": "DarknessZone",
        "components": [
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "visionReduction",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "darknessIntensity",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "player_enters_darkness",
            "trigger": "when player enters the darkness zone",
            "actions": [
              {
                "action": "reduce player vision range by vision reduction amount"
              },
              {
                "action": "gradually darken the screen based on darkness intensity"
              },
              {
                "action": "apply dark visual overlay effect"
              }
            ]
          },
          {
            "name": "player_exits_darkness",
            "trigger": "when player exits the darkness zone",
            "actions": [
              {
                "action": "restore player vision range to normal"
              },
              {
                "action": "gradually brighten the screen back to normal"
              },
              {
                "action": "remove dark visual overlay effect"
              }
            ]
          },
          {
            "name": "continuous_darkness_effect",
            "trigger": "while player remains inside the darkness zone",
            "actions": [
              {
                "action": "maintain reduced vision range"
              },
              {
                "action": "keep dark visual effects active"
              },
              {
                "action": "limit visibility of distant objects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\npublic class DarknessZone : MonoBehaviour\n{\n    [Header(\"Darkness Settings\")]\n    [SerializeField] private float _darknessIntensity = 0.8f;\n    [SerializeField] private float _transitionSpeed = 2f;\n    [SerializeField] private float _visionRadius = 5f;\n    [SerializeField] private bool _useGlobalVolumeProfile = true;\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _playerLight;\n    [SerializeField] private float _originalLightIntensity = 1f;\n    [SerializeField] private float _darknessLightIntensity = 0.2f;\n    \n    [Header(\"Fog Settings\")]\n    [SerializeField] private bool _enableFog = true;\n    [SerializeField] private Color _fogColor = Color.black;\n    [SerializeField] private float _fogDensity = 0.1f;\n    [SerializeField] private FogMode _fogMode = FogMode.ExponentialSquared;\n    \n    [Header(\"Post Processing\")]\n    [SerializeField] private Volume _darknessVolume;\n    [SerializeField] private AnimationCurve _darknessTransition = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    private bool _playerInZone = false;\n    private float _currentDarknessLevel = 0f;\n    private Camera _playerCamera;\n    private GameObject _playerObject;\n    \n    // Original environment settings\n    private float _originalAmbientIntensity;\n    private Color _originalAmbientColor;\n    private bool _originalFogEnabled;\n    private Color _originalFogColor;\n    private float _originalFogDensity;\n    private FogMode _originalFogMode;\n    private float _originalCameraFarClip;\n    \n    // Vision limitation components\n    private GameObject _visionMask;\n    private SphereCollider _visionCollider;\n    \n    private void Start()\n    {\n        InitializeDarknessZone();\n        StoreOriginalSettings();\n        CreateVisionMask();\n    }\n    \n    private void Update()\n    {\n        UpdateDarknessEffect();\n        UpdateVisionLimitation();\n    }\n    \n    private void InitializeDarknessZone()\n    {\n        if (GetComponent<Collider>() == null)\n        {\n            BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();\n            boxCollider.isTrigger = true;\n        }\n        \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n        {\n            _playerCamera = FindObjectOfType<Camera>();\n        }\n        \n        if (_darknessVolume == null)\n        {\n            _darknessVolume = FindObjectOfType<Volume>();\n        }\n    }\n    \n    private void StoreOriginalSettings()\n    {\n        _originalAmbientIntensity = RenderSettings.ambientIntensity;\n        _originalAmbientColor = RenderSettings.ambientLight;\n        _originalFogEnabled = RenderSettings.fog;\n        _originalFogColor = RenderSettings.fogColor;\n        _originalFogDensity = RenderSettings.fogDensity;\n        _originalFogMode = RenderSettings.fogMode;\n        \n        if (_playerCamera != null)\n        {\n            _originalCameraFarClip = _playerCamera.farClipPlane;\n        }\n        \n        if (_playerLight == null)\n        {\n            GameObject lightObject = GameObject.FindWithTag(\"Player\");\n            if (lightObject != null)\n            {\n                _playerLight = lightObject.GetComponentInChildren<Light>();\n            }\n        }\n        \n        if (_playerLight != null)\n        {\n            _originalLightIntensity = _playerLight.intensity;\n        }\n    }\n    \n    private void CreateVisionMask()\n    {\n        _visionMask = new GameObject(\"VisionMask\");\n        _visionMask.transform.SetParent(transform);\n        _visionMask.SetActive(false);\n        \n        _visionCollider = _visionMask.AddComponent<SphereCollider>();\n        _visionCollider.isTrigger = true;\n        _visionCollider.radius = _visionRadius;\n        \n        Rigidbody rb = _visionMask.AddComponent<Rigidbody>();\n        rb.isKinematic = true;\n        rb.useGravity = false;\n    }\n    \n    private void UpdateDarknessEffect()\n    {\n        float targetDarkness = _playerInZone ? _darknessIntensity : 0f;\n        _currentDarknessLevel = Mathf.MoveTowards(_currentDarknessLevel, targetDarkness, _transitionSpeed * Time.deltaTime);\n        \n        float transitionValue = _darknessTransition.Evaluate(_currentDarknessLevel / _darknessIntensity);\n        \n        ApplyAmbientLighting(transitionValue);\n        ApplyFogEffect(transitionValue);\n        ApplyLightIntensity(transitionValue);\n        ApplyCameraSettings(transitionValue);\n        ApplyPostProcessing(transitionValue);\n    }\n    \n    private void ApplyAmbientLighting(float intensity)\n    {\n        RenderSettings.ambientIntensity = Mathf.Lerp(_originalAmbientIntensity, _originalAmbientIntensity * (1f - intensity), intensity);\n        RenderSettings.ambientLight = Color.Lerp(_originalAmbientColor, Color.black, intensity * 0.5f);\n    }\n    \n    private void ApplyFogEffect(float intensity)\n    {\n        if (_enableFog)\n        {\n            RenderSettings.fog = true;\n            RenderSettings.fogColor = Color.Lerp(_originalFogColor, _fogColor, intensity);\n            RenderSettings.fogDensity = Mathf.Lerp(_originalFogDensity, _fogDensity, intensity);\n            RenderSettings.fogMode = _fogMode;\n        }\n    }\n    \n    private void ApplyLightIntensity(float intensity)\n    {\n        if (_playerLight != null)\n        {\n            _playerLight.intensity = Mathf.Lerp(_originalLightIntensity, _darknessLightIntensity, intensity);\n        }\n    }\n    \n    private void ApplyCameraSettings(float intensity)\n    {\n        if (_playerCamera != null)\n        {\n            float reducedFarClip = _originalCameraFarClip * (1f - intensity * 0.7f);\n            _playerCamera.farClipPlane = Mathf.Max(reducedFarClip, 10f);\n        }\n    }\n    \n    private void ApplyPostProcessing(float intensity)\n    {\n        if (_darknessVolume != null)\n        {\n            _darknessVolume.weight = intensity;\n        }\n    }\n    \n    private void UpdateVisionLimitation()\n    {\n        if (_playerInZone && _playerObject != null && _visionMask != null)\n        {\n            _visionMask.transform.position = _playerObject.transform.position;\n            _visionMask.SetActive(true);\n        }\n        else if (_visionMask != null)\n        {\n            _visionMask.SetActive(false);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInZone = true;\n            _playerObject = other.gameObject;\n            \n            if (_playerCamera == null)\n            {\n                _playerCamera = other.GetComponentInChildren<Camera>();\n            }\n            \n            if (_playerLight == null)\n            {\n                _playerLight = other.GetComponentInChildren<Light>();\n                if (_playerLight != null)\n                {\n                    _originalLightIntensity = _playerLight.intensity;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInZone = false;\n            _playerObject = null;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        RestoreOriginalSettings();\n    }\n    \n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus)\n        {\n            RestoreOriginalSettings();\n        }\n    }\n    \n    private void RestoreOriginalSettings()\n    {\n        RenderSettings.ambientIntensity = _originalAmbientIntensity;\n        RenderSettings.ambientLight = _originalAmbientColor;\n        RenderSettings.fog = _originalFogEnabled;\n        RenderSettings.fogColor = _originalFogColor;\n        RenderSettings.fogDensity = _originalFogDensity;\n        RenderSettings.fogMode = _originalFogMode;\n        \n        if (_playerCamera != null)\n        {\n            _playerCamera.farClipPlane = _originalCameraFarClip;\n        }\n        \n        if (_playerLight != null)\n        {\n            _playerLight.intensity = _originalLightIntensity;\n        }\n        \n        if (_darknessVolume != null)\n        {\n            _darknessVolume.weight = 0f;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.black;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        if (_playerInZone && _playerObject != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_playerObject.transform.position, _visionRadius);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "slippery slope",
      "ideal_ir": {
        "class_name": "SlipperySlope",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "slipperiness",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "slopeAngle",
            "type": "float",
            "default": 30
          },
          {
            "name": "slideForce",
            "type": "float",
            "default": 15
          }
        ],
        "behaviors": [
          {
            "name": "apply_slippery_physics",
            "trigger": "when object with rigidbody touches this surface",
            "actions": [
              {
                "action": "reduce friction between touching object and slope surface"
              },
              {
                "action": "apply downward sliding force along slope direction"
              },
              {
                "action": "prevent object from gripping or stopping on slope"
              }
            ]
          },
          {
            "name": "increase_slide_over_time",
            "trigger": "while object remains on slippery slope",
            "actions": [
              {
                "action": "gradually increase sliding speed"
              },
              {
                "action": "make object harder to control while sliding"
              }
            ]
          },
          {
            "name": "stop_slipping_effect",
            "trigger": "when object leaves the slope surface",
            "actions": [
              {
                "action": "restore normal friction to the object"
              },
              {
                "action": "stop applying sliding forces"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SlipperySlope : MonoBehaviour\n{\n    [Header(\"Slippery Surface Settings\")]\n    [SerializeField] private float _slipperiness = 0.95f;\n    [SerializeField] private float _slopeForce = 10f;\n    [SerializeField] private float _maxSlideSpeed = 15f;\n    [SerializeField] private bool _affectsPlayer = true;\n    [SerializeField] private bool _affectsObjects = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _slideParticles;\n    [SerializeField] private AudioSource _slideAudioSource;\n    [SerializeField] private AudioClip _slideSound;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private PhysicMaterial _slipperyMaterial;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    private Collider _surfaceCollider;\n    private Vector3 _slopeDirection;\n    private float _slopeAngle;\n    \n    private void Start()\n    {\n        _surfaceCollider = GetComponent<Collider>();\n        if (_surfaceCollider == null)\n        {\n            Debug.LogError(\"SlipperySlope requires a Collider component!\");\n            return;\n        }\n        \n        CalculateSlopeDirection();\n        SetupSlipperyMaterial();\n        \n        if (_slideAudioSource == null)\n        {\n            _slideAudioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void CalculateSlopeDirection()\n    {\n        Vector3 forward = transform.forward;\n        Vector3 up = transform.up;\n        \n        _slopeDirection = Vector3.ProjectOnPlane(forward, Vector3.up).normalized;\n        _slopeAngle = Vector3.Angle(up, Vector3.up);\n        \n        if (_slopeAngle < 1f)\n        {\n            _slopeDirection = -transform.up;\n        }\n    }\n    \n    private void SetupSlipperyMaterial()\n    {\n        if (_slipperyMaterial == null)\n        {\n            _slipperyMaterial = new PhysicMaterial(\"SlipperyMaterial\");\n            _slipperyMaterial.dynamicFriction = 0.1f;\n            _slipperyMaterial.staticFriction = 0.1f;\n            _slipperyMaterial.frictionCombine = PhysicMaterialCombine.Minimum;\n        }\n        \n        if (_surfaceCollider != null)\n        {\n            _surfaceCollider.material = _slipperyMaterial;\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (!IsAffectedObject(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        ApplySlipperyEffect(rb, other);\n    }\n    \n    private void OnCollisionStay(Collision collision)\n    {\n        if (!IsAffectedObject(collision.collider)) return;\n        \n        Rigidbody rb = collision.rigidbody;\n        if (rb == null) return;\n        \n        ApplySlipperyEffect(rb, collision.collider);\n    }\n    \n    private bool IsAffectedObject(Collider other)\n    {\n        if ((_affectedLayers.value & (1 << other.gameObject.layer)) == 0)\n            return false;\n        \n        if (other.CompareTag(\"Player\") && !_affectsPlayer)\n            return false;\n        \n        if (!other.CompareTag(\"Player\") && !_affectsObjects)\n            return false;\n        \n        return true;\n    }\n    \n    private void ApplySlipperyEffect(Rigidbody rb, Collider other)\n    {\n        Vector3 slopeForceVector = _slopeDirection * _slopeForce;\n        Vector3 currentVelocity = rb.velocity;\n        \n        Vector3 slideVelocity = Vector3.Lerp(currentVelocity, \n            currentVelocity + slopeForceVector, _slipperiness * Time.fixedDeltaTime);\n        \n        slideVelocity = Vector3.ClampMagnitude(slideVelocity, _maxSlideSpeed);\n        \n        rb.velocity = slideVelocity;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            DisablePlayerControl(other);\n        }\n        \n        PlaySlideEffects(other.transform.position);\n    }\n    \n    private void DisablePlayerControl(Collider playerCollider)\n    {\n        CharacterController characterController = playerCollider.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            StartCoroutine(ReenableCharacterController(characterController));\n        }\n    }\n    \n    private System.Collections.IEnumerator ReenableCharacterController(CharacterController controller)\n    {\n        yield return new WaitForSeconds(0.1f);\n        if (controller != null)\n        {\n            controller.enabled = true;\n        }\n    }\n    \n    private void PlaySlideEffects(Vector3 position)\n    {\n        if (_slideParticles != null && !_slideParticles.isPlaying)\n        {\n            _slideParticles.transform.position = position;\n            _slideParticles.Play();\n        }\n        \n        if (_slideAudioSource != null && _slideSound != null && !_slideAudioSource.isPlaying)\n        {\n            _slideAudioSource.clip = _slideSound;\n            _slideAudioSource.Play();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            RestorePlayerControl(other);\n        }\n        \n        StopSlideEffects();\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        if (collision.collider.CompareTag(\"Player\"))\n        {\n            RestorePlayerControl(collision.collider);\n        }\n        \n        StopSlideEffects();\n    }\n    \n    private void RestorePlayerControl(Collider playerCollider)\n    {\n        CharacterController characterController = playerCollider.GetComponent<CharacterController>();\n        if (characterController != null && !characterController.enabled)\n        {\n            characterController.enabled = true;\n        }\n    }\n    \n    private void StopSlideEffects()\n    {\n        if (_slideParticles != null && _slideParticles.isPlaying)\n        {\n            _slideParticles.Stop();\n        }\n        \n        if (_slideAudioSource != null && _slideAudioSource.isPlaying)\n        {\n            _slideAudioSource.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawRay(transform.position, _slopeDirection * 3f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n    }\n    \n    public void SetSlipperiness(float value)\n    {\n        _slipperiness = Mathf.Clamp01(value);\n    }\n    \n    public void SetSlopeForce(float value)\n    {\n        _slopeForce = Mathf.Max(0f, value);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "wind tunnel",
      "ideal_ir": {
        "class_name": "WindTunnel",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "windForce",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "windDirection",
            "type": "Vector3",
            "default": "Vector3.forward"
          },
          {
            "name": "turbulenceIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "windSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "particleEffect",
            "type": "ParticleSystem",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "apply_wind_force",
            "trigger": "when object with rigidbody enters wind tunnel area",
            "actions": [
              {
                "action": "apply continuous force in wind direction to the rigidbody"
              },
              {
                "action": "add random turbulence variations to the force"
              }
            ]
          },
          {
            "name": "stop_wind_force",
            "trigger": "when object with rigidbody exits wind tunnel area",
            "actions": [
              {
                "action": "stop applying wind force to the rigidbody"
              }
            ]
          },
          {
            "name": "play_wind_effects",
            "trigger": "when any object enters wind tunnel area",
            "actions": [
              {
                "action": "play wind sound effect"
              },
              {
                "action": "activate particle system showing wind flow"
              }
            ]
          },
          {
            "name": "stop_wind_effects",
            "trigger": "when no objects remain in wind tunnel area",
            "actions": [
              {
                "action": "stop wind sound effect"
              },
              {
                "action": "deactivate particle system"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WindTunnel : MonoBehaviour\n{\n    [Header(\"Wind Settings\")]\n    [SerializeField] private float _windForce = 10f;\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private bool _useLocalDirection = true;\n    [SerializeField] private float _maxWindDistance = 20f;\n    [SerializeField] private AnimationCurve _forceFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    [Header(\"Affected Objects\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private string[] _affectedTags = { \"Player\", \"Debris\", \"Projectile\" };\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectParticles = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _windParticles;\n    [SerializeField] private bool _createWindParticles = true;\n    [SerializeField] private int _particleCount = 100;\n    [SerializeField] private float _particleSpeed = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _windSound;\n    [SerializeField] private float _baseVolume = 0.5f;\n    [SerializeField] private float _basePitch = 1f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private float _updateFrequency = 0.1f;\n    \n    private List<Rigidbody> _affectedRigidbodies = new List<Rigidbody>();\n    private List<ParticleSystem> _affectedParticleSystems = new List<ParticleSystem>();\n    private float _lastUpdateTime;\n    private Vector3 _worldWindDirection;\n    \n    private void Start()\n    {\n        SetupAudio();\n        SetupParticles();\n        UpdateWindDirection();\n    }\n    \n    private void Update()\n    {\n        UpdateWindDirection();\n        \n        if (Time.time - _lastUpdateTime >= _updateFrequency)\n        {\n            DetectAffectedObjects();\n            _lastUpdateTime = Time.time;\n        }\n        \n        ApplyWindForces();\n        UpdateAudioEffects();\n    }\n    \n    private void UpdateWindDirection()\n    {\n        _worldWindDirection = _useLocalDirection ? transform.TransformDirection(_windDirection.normalized) : _windDirection.normalized;\n    }\n    \n    private void DetectAffectedObjects()\n    {\n        _affectedRigidbodies.Clear();\n        _affectedParticleSystems.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _affectedLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!IsValidTarget(col.gameObject))\n                continue;\n                \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance > _maxWindDistance)\n                continue;\n            \n            if (_affectRigidbodies)\n            {\n                Rigidbody rb = col.GetComponent<Rigidbody>();\n                if (rb != null && !_affectedRigidbodies.Contains(rb))\n                {\n                    _affectedRigidbodies.Add(rb);\n                }\n            }\n            \n            if (_affectParticles)\n            {\n                ParticleSystem ps = col.GetComponent<ParticleSystem>();\n                if (ps != null && !_affectedParticleSystems.Contains(ps))\n                {\n                    _affectedParticleSystems.Add(ps);\n                }\n            }\n        }\n    }\n    \n    private bool IsValidTarget(GameObject target)\n    {\n        if (_affectedTags.Length > 0)\n        {\n            foreach (string tag in _affectedTags)\n            {\n                if (target.CompareTag(tag))\n                    return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    \n    private void ApplyWindForces()\n    {\n        foreach (Rigidbody rb in _affectedRigidbodies)\n        {\n            if (rb == null) continue;\n            \n            Vector3 directionToObject = rb.transform.position - transform.position;\n            float distance = directionToObject.magnitude;\n            \n            if (distance > _maxWindDistance) continue;\n            \n            float normalizedDistance = distance / _maxWindDistance;\n            float forceMultiplier = _forceFalloff.Evaluate(normalizedDistance);\n            \n            Vector3 windForceVector = _worldWindDirection * _windForce * forceMultiplier;\n            \n            // Apply drag factor based on object's velocity opposing wind\n            float dragFactor = Mathf.Clamp01(1f - Vector3.Dot(rb.velocity.normalized, _worldWindDirection));\n            windForceVector *= (0.5f + dragFactor * 0.5f);\n            \n            rb.AddForce(windForceVector, ForceMode.Force);\n        }\n        \n        foreach (ParticleSystem ps in _affectedParticleSystems)\n        {\n            if (ps == null) continue;\n            \n            var velocityOverLifetime = ps.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            \n            float distance = Vector3.Distance(transform.position, ps.transform.position);\n            float normalizedDistance = distance / _maxWindDistance;\n            float forceMultiplier = _forceFalloff.Evaluate(normalizedDistance);\n            \n            Vector3 particleWind = _worldWindDirection * _windForce * forceMultiplier * 0.1f;\n            velocityOverLifetime.x = particleWind.x;\n            velocityOverLifetime.y = particleWind.y;\n            velocityOverLifetime.z = particleWind.z;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_windSound != null)\n        {\n            _audioSource.clip = _windSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _baseVolume;\n            _audioSource.pitch = _basePitch;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (_createWindParticles && _windParticles == null)\n        {\n            GameObject particleObject = new GameObject(\"WindParticles\");\n            particleObject.transform.SetParent(transform);\n            particleObject.transform.localPosition = Vector3.zero;\n            \n            _windParticles = particleObject.AddComponent<ParticleSystem>();\n            \n            var main = _windParticles.main;\n            main.startLifetime = 2f;\n            main.startSpeed = _particleSpeed;\n            main.maxParticles = _particleCount;\n            main.startSize = 0.1f;\n            main.startColor = new Color(1f, 1f, 1f, 0.3f);\n            \n            var emission = _windParticles.emission;\n            emission.rateOverTime = _particleCount * 0.5f;\n            \n            var shape = _windParticles.shape;\n            shape.enabled = true;\n            shape.shapeType = ParticleSystemShapeType.Box;\n            shape.scale = new Vector3(_detectionRadius, _detectionRadius, 1f);\n            \n            var velocityOverLifetime = _windParticles.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        }\n        \n        if (_windParticles != null)\n        {\n            var velocityOverLifetime = _windParticles.velocityOverLifetime;\n            Vector3 particleVelocity = _worldWindDirection * _particleSpeed;\n            velocityOverLifetime.x = particleVelocity.x;\n            velocityOverLifetime.y = particleVelocity.y;\n            velocityOverLifetime.z = particleVelocity.z;\n        }\n    }\n    \n    private void UpdateAudioEffects()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float intensity = Mathf.Clamp01(_affectedRigidbodies.Count / 10f);\n            _audioSource.volume = _baseVolume * (0.5f + intensity * 0.5f);\n            _audioSource.pitch = _basePitch * (0.8f + intensity * 0.4f);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxWindDistance);\n        \n        Gizmos.color = Color.red;\n        Vector3 windDir = _useLocalDirection ? transform.TransformDirection(_windDirection.normalized) : _windDirection.normalized;\n        Gizmos.DrawRay(transform.position, windDir * _maxWindDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n    }\n    \n    public void SetWindForce(float force)\n    {\n        _windForce = force;\n    }\n    \n    public void SetWindDirection(Vector3 direction)\n    {\n        _windDirection = direction.normalized;\n        UpdateWindDirection();\n    }\n    \n    public void ToggleWind(bool enabled)\n    {\n        this.enabled = enabled;\n        \n        if (_windParticles != null)\n        {\n            if (enabled)\n                _windParticles.Play();\n            else\n                _windParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (enabled)\n                _audioSource.Play();\n            else\n                _audioSource.Stop();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "crossbow with bolt travel time",
      "ideal_ir": {
        "class_name": "Crossbow",
        "components": [
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "boltPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "firePoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "boltSpeed",
            "type": "float",
            "default": 25
          },
          {
            "name": "reloadTime",
            "type": "float",
            "default": 2
          },
          {
            "name": "maxRange",
            "type": "float",
            "default": 50
          },
          {
            "name": "isLoaded",
            "type": "bool",
            "default": true
          },
          {
            "name": "isReloading",
            "type": "bool",
            "default": false
          },
          {
            "name": "fireSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "reloadSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "fire_bolt",
            "trigger": "when fire input is pressed and crossbow is loaded and not reloading",
            "actions": [
              {
                "action": "play fire sound"
              },
              {
                "action": "instantiate bolt at fire point position and rotation"
              },
              {
                "action": "apply forward velocity to bolt based on bolt speed"
              },
              {
                "action": "set crossbow as not loaded"
              },
              {
                "action": "start reload timer"
              }
            ]
          },
          {
            "name": "reload_crossbow",
            "trigger": "when reload time has elapsed and crossbow is not loaded",
            "actions": [
              {
                "action": "play reload sound"
              },
              {
                "action": "set crossbow as loaded"
              },
              {
                "action": "set reloading state to false"
              }
            ]
          },
          {
            "name": "start_reload",
            "trigger": "when crossbow becomes not loaded",
            "actions": [
              {
                "action": "set reloading state to true"
              },
              {
                "action": "begin countdown for reload duration"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Crossbow : MonoBehaviour\n{\n    [Header(\"Crossbow Settings\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _boltPrefab;\n    [SerializeField] private float _boltSpeed = 20f;\n    [SerializeField] private float _reloadTime = 2f;\n    [SerializeField] private bool _autoReload = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _fireAnimationTrigger = \"Fire\";\n    [SerializeField] private string _reloadAnimationTrigger = \"Reload\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFire;\n    public UnityEvent OnReloadStart;\n    public UnityEvent OnReloadComplete;\n    \n    private bool _isLoaded = true;\n    private bool _isReloading = false;\n    private float _reloadTimer = 0f;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleReloading();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            StartReload();\n        }\n    }\n    \n    private void HandleReloading()\n    {\n        if (_isReloading)\n        {\n            _reloadTimer += Time.deltaTime;\n            \n            if (_reloadTimer >= _reloadTime)\n            {\n                CompleteReload();\n            }\n        }\n    }\n    \n    public void TryFire()\n    {\n        if (!_isLoaded || _isReloading)\n            return;\n            \n        Fire();\n    }\n    \n    private void Fire()\n    {\n        if (_boltPrefab != null)\n        {\n            GameObject bolt = Instantiate(_boltPrefab, _firePoint.position, _firePoint.rotation);\n            CrossbowBolt boltScript = bolt.GetComponent<CrossbowBolt>();\n            \n            if (boltScript == null)\n                boltScript = bolt.AddComponent<CrossbowBolt>();\n                \n            boltScript.Initialize(_boltSpeed);\n        }\n        \n        _isLoaded = false;\n        \n        PlayFireEffects();\n        OnFire?.Invoke();\n        \n        if (_autoReload)\n        {\n            StartReload();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.PlayOneShot(_fireSound);\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_fireAnimationTrigger))\n        {\n            _animator.SetTrigger(_fireAnimationTrigger);\n        }\n    }\n    \n    public void StartReload()\n    {\n        if (_isLoaded || _isReloading)\n            return;\n            \n        _isReloading = true;\n        _reloadTimer = 0f;\n        \n        if (_audioSource != null && _reloadSound != null)\n        {\n            _audioSource.PlayOneShot(_reloadSound);\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_reloadAnimationTrigger))\n        {\n            _animator.SetTrigger(_reloadAnimationTrigger);\n        }\n        \n        OnReloadStart?.Invoke();\n    }\n    \n    private void CompleteReload()\n    {\n        _isReloading = false;\n        _isLoaded = true;\n        _reloadTimer = 0f;\n        \n        OnReloadComplete?.Invoke();\n    }\n    \n    public bool IsLoaded => _isLoaded;\n    public bool IsReloading => _isReloading;\n    public float ReloadProgress => _isReloading ? _reloadTimer / _reloadTime : 0f;\n}\n\npublic class CrossbowBolt : MonoBehaviour\n{\n    [Header(\"Bolt Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _lifetime = 10f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private bool _useGravity = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private TrailRenderer _trail;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _hasHit = false;\n    private float _speed;\n    private Vector3 _velocity;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_collider == null)\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n    }\n    \n    private void Start()\n    {\n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_hasHit && _useGravity)\n        {\n            _rigidbody.AddForce(Physics.gravity * _gravityScale, ForceMode.Acceleration);\n        }\n        \n        if (!_hasHit)\n        {\n            AlignWithVelocity();\n        }\n    }\n    \n    public void Initialize(float speed)\n    {\n        _speed = speed;\n        _velocity = transform.forward * speed;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = _velocity;\n            _rigidbody.useGravity = _useGravity;\n        }\n    }\n    \n    private void AlignWithVelocity()\n    {\n        if (_rigidbody != null && _rigidbody.velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_rigidbody.velocity);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleHit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleHit(collision.collider);\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        if (_hasHit)\n            return;\n            \n        if ((_hitLayers.value & (1 << hitCollider.gameObject.layer)) == 0)\n            return;\n            \n        _hasHit = true;\n        \n        // Deal damage to player\n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            // Send damage message\n            hitCollider.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Stick to surface\n        if (_stickToSurfaces)\n        {\n            StickToSurface(hitCollider);\n        }\n        \n        // Play effects\n        PlayHitEffects();\n        \n        // Destroy after sticking\n        if (_stickToSurfaces)\n        {\n            Destroy(gameObject, 5f);\n        }\n        else\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        // Parent to hit object if it's not static\n        if (surface.attachedRigidbody != null)\n        {\n            transform.SetParent(surface.transform);\n        }\n        \n        if (_trail != null)\n        {\n            _trail.enabled = false;\n        }\n    }\n    \n    private void PlayHitEffects()\n    {\n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n        \n        if (_hitSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_hitSound, transform.position);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "throwing knife with arc",
      "ideal_ir": {
        "class_name": "ThrowingKnife",
        "components": [
          "Rigidbody",
          "Collider",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "throwForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "arcHeight",
            "type": "float",
            "default": 3
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 720
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "lifeTime",
            "type": "float",
            "default": 5
          },
          {
            "name": "hasBeenThrown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "throw_knife",
            "trigger": "when throw method is called with target position",
            "actions": [
              {
                "action": "calculate arc trajectory toward target position with specified arc height"
              },
              {
                "action": "apply throwing force in calculated direction"
              },
              {
                "action": "start spinning knife around forward axis at rotation speed"
              },
              {
                "action": "mark knife as thrown"
              },
              {
                "action": "start lifetime countdown"
              }
            ]
          },
          {
            "name": "spin_while_flying",
            "trigger": "when knife has been thrown and is in the air",
            "actions": [
              {
                "action": "continuously rotate knife around its forward axis at rotation speed"
              }
            ]
          },
          {
            "name": "handle_collision",
            "trigger": "when knife collides with any object",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "stop spinning"
              },
              {
                "action": "stick to the surface at collision point"
              },
              {
                "action": "if collided object can take damage then apply damage amount"
              }
            ]
          },
          {
            "name": "destroy_after_lifetime",
            "trigger": "when lifetime countdown reaches zero",
            "actions": [
              {
                "action": "destroy the knife object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class ThrowingKnife : MonoBehaviour\n{\n    [Header(\"Throwing Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _arcHeight = 3f;\n    [SerializeField] private float _rotationSpeed = 720f;\n    [SerializeField] private float _maxThrowDistance = 20f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffectPrefab;\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    \n    [Header(\"Damage\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private bool _destroyOnHit = true;\n    [SerializeField] private float _lifeTime = 5f;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private AudioSource _audioSource;\n    private bool _hasBeenThrown = false;\n    private bool _hasHit = false;\n    private Vector3 _initialPosition;\n    private float _timeAlive = 0f;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _collider.isTrigger = true;\n        _initialPosition = transform.position;\n    }\n    \n    private void Start()\n    {\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasBeenThrown && !_hasHit)\n        {\n            _timeAlive += Time.deltaTime;\n            \n            if (_timeAlive >= _lifeTime)\n            {\n                DestroyKnife();\n                return;\n            }\n            \n            transform.Rotate(Vector3.forward * _rotationSpeed * Time.deltaTime);\n            \n            Vector3 currentVelocity = _rigidbody.velocity;\n            currentVelocity.y -= Physics.gravity.y * _gravityScale * Time.deltaTime;\n            _rigidbody.velocity = currentVelocity;\n            \n            if (Vector3.Distance(_initialPosition, transform.position) > _maxThrowDistance)\n            {\n                DestroyKnife();\n            }\n        }\n    }\n    \n    public void ThrowKnife(Vector3 targetPosition)\n    {\n        if (_hasBeenThrown) return;\n        \n        _hasBeenThrown = true;\n        _initialPosition = transform.position;\n        \n        Vector3 direction = (targetPosition - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetPosition);\n        \n        Vector3 velocity = CalculateArcVelocity(transform.position, targetPosition, _arcHeight);\n        \n        _rigidbody.velocity = velocity;\n        transform.LookAt(targetPosition);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        PlaySound(_throwSound);\n    }\n    \n    public void ThrowKnife(Vector3 direction, float force)\n    {\n        if (_hasBeenThrown) return;\n        \n        _hasBeenThrown = true;\n        _initialPosition = transform.position;\n        \n        Vector3 throwDirection = direction.normalized;\n        throwDirection.y += 0.3f;\n        \n        _rigidbody.velocity = throwDirection * force;\n        transform.LookAt(transform.position + throwDirection);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        PlaySound(_throwSound);\n    }\n    \n    private Vector3 CalculateArcVelocity(Vector3 startPos, Vector3 endPos, float arcHeight)\n    {\n        Vector3 direction = endPos - startPos;\n        Vector3 directionXZ = new Vector3(direction.x, 0, direction.z);\n        \n        float time = directionXZ.magnitude / _throwForce;\n        \n        Vector3 velocityXZ = directionXZ / time;\n        float velocityY = (direction.y + 0.5f * Physics.gravity.y * time * time) / time;\n        velocityY += Mathf.Sqrt(2 * Physics.gravity.y * arcHeight);\n        \n        return new Vector3(velocityXZ.x, velocityY, velocityXZ.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_hasBeenThrown || _hasHit) return;\n        \n        if (((1 << other.gameObject.layer) & _hitLayers) == 0) return;\n        \n        _hasHit = true;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n        \n        HandleHit(other);\n        PlaySound(_hitSound);\n        \n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, transform.position, transform.rotation);\n        }\n        \n        if (_destroyOnHit)\n        {\n            Invoke(nameof(DestroyKnife), 0.1f);\n        }\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            ApplyDamageToPlayer(hitCollider.gameObject);\n        }\n        else if (hitCollider.CompareTag(\"Enemy\"))\n        {\n            ApplyDamageToEnemy(hitCollider.gameObject);\n        }\n        \n        StickToSurface(hitCollider);\n    }\n    \n    private void ApplyDamageToPlayer(GameObject player)\n    {\n        var playerRigidbody = player.GetComponent<Rigidbody>();\n        if (playerRigidbody != null)\n        {\n            Vector3 knockback = transform.forward * 5f;\n            playerRigidbody.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n    \n    private void ApplyDamageToEnemy(GameObject enemy)\n    {\n        var enemyRigidbody = enemy.GetComponent<Rigidbody>();\n        if (enemyRigidbody != null)\n        {\n            Vector3 knockback = transform.forward * 3f;\n            enemyRigidbody.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        transform.SetParent(surface.transform);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, transform.forward, out hit, 1f))\n        {\n            transform.position = hit.point;\n            transform.rotation = Quaternion.LookRotation(hit.normal);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void DestroyKnife()\n    {\n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, transform.position, transform.rotation);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    public void ResetKnife()\n    {\n        _hasBeenThrown = false;\n        _hasHit = false;\n        _timeAlive = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = false;\n        _collider.isTrigger = true;\n        transform.SetParent(null);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    public bool HasBeenThrown => _hasBeenThrown;\n    public bool HasHit => _hasHit;\n    public float Damage => _damage;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "whip with long range",
      "ideal_ir": {
        "class_name": "Whip",
        "components": [
          "LineRenderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxRange",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "damage",
            "type": "float",
            "default": 25.0
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "whipSpeed",
            "type": "float",
            "default": 15.0
          }
        ],
        "behaviors": [
          {
            "name": "attack_with_whip",
            "trigger": "when attack input is pressed and cooldown has finished",
            "actions": [
              {
                "action": "cast ray from player position toward mouse cursor direction up to maximum range"
              },
              {
                "action": "create visual whip line that extends rapidly to target point"
              },
              {
                "action": "play whip crack sound effect"
              },
              {
                "action": "deal damage to first enemy hit along whip path"
              },
              {
                "action": "apply knockback force to hit enemy away from player"
              },
              {
                "action": "start cooldown timer before next attack"
              }
            ]
          },
          {
            "name": "animate_whip_visual",
            "trigger": "when whip attack is performed",
            "actions": [
              {
                "action": "show line renderer extending from player to target point"
              },
              {
                "action": "animate line thickness from thick to thin over short duration"
              },
              {
                "action": "fade out whip visual after brief display time"
              }
            ]
          },
          {
            "name": "handle_multiple_enemies",
            "trigger": "when whip path intersects multiple enemies",
            "actions": [
              {
                "action": "damage all enemies along the whip path"
              },
              {
                "action": "apply knockback to each hit enemy"
              },
              {
                "action": "create hit effect at each enemy position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Whip : MonoBehaviour\n{\n    [Header(\"Whip Settings\")]\n    [SerializeField] private float _whipRange = 8f;\n    [SerializeField] private float _whipDamage = 25f;\n    [SerializeField] private float _whipCooldown = 1.5f;\n    [SerializeField] private float _whipDuration = 0.3f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _whipRenderer;\n    [SerializeField] private Transform _whipOrigin;\n    [SerializeField] private AnimationCurve _whipCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _whipWidth = 0.1f;\n    [SerializeField] private Color _whipColor = Color.brown;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whipCrackSound;\n    [SerializeField] private AudioClip _whipHitSound;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _whipKey = KeyCode.Mouse0;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnWhipHit;\n    public UnityEvent OnWhipCrack;\n    \n    private Camera _playerCamera;\n    private bool _isWhipping;\n    private float _lastWhipTime;\n    private Vector3 _whipTargetPosition;\n    private float _whipAnimationTime;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_whipRenderer == null)\n            _whipRenderer = GetComponent<LineRenderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_whipOrigin == null)\n            _whipOrigin = transform;\n            \n        SetupWhipRenderer();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWhipAnimation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_whipKey) && CanWhip())\n        {\n            PerformWhip();\n        }\n    }\n    \n    private bool CanWhip()\n    {\n        return !_isWhipping && Time.time >= _lastWhipTime + _whipCooldown;\n    }\n    \n    private void PerformWhip()\n    {\n        _isWhipping = true;\n        _lastWhipTime = Time.time;\n        _whipAnimationTime = 0f;\n        \n        Vector3 whipDirection = GetWhipDirection();\n        _whipTargetPosition = _whipOrigin.position + whipDirection * _whipRange;\n        \n        CheckWhipHit(whipDirection);\n        PlayWhipSound();\n        OnWhipCrack?.Invoke();\n    }\n    \n    private Vector3 GetWhipDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            return ray.direction;\n        }\n        else\n        {\n            return transform.forward;\n        }\n    }\n    \n    private void CheckWhipHit(Vector3 direction)\n    {\n        RaycastHit[] hits = Physics.RaycastAll(_whipOrigin.position, direction, _whipRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject != gameObject)\n            {\n                ProcessHit(hit.collider.gameObject, hit.point);\n            }\n        }\n    }\n    \n    private void ProcessHit(GameObject hitObject, Vector3 hitPoint)\n    {\n        // Apply damage if target has health component\n        var healthComponent = hitObject.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_whipDamage);\n        }\n        \n        // Apply knockback if target has rigidbody\n        var rb = hitObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 knockbackDirection = (hitPoint - _whipOrigin.position).normalized;\n            rb.AddForce(knockbackDirection * 500f, ForceMode.Impulse);\n        }\n        \n        PlayHitSound();\n        OnWhipHit?.Invoke(hitObject);\n    }\n    \n    private void UpdateWhipAnimation()\n    {\n        if (!_isWhipping)\n        {\n            _whipRenderer.enabled = false;\n            return;\n        }\n        \n        _whipRenderer.enabled = true;\n        _whipAnimationTime += Time.deltaTime;\n        \n        float progress = _whipAnimationTime / _whipDuration;\n        \n        if (progress >= 1f)\n        {\n            _isWhipping = false;\n            _whipRenderer.enabled = false;\n            return;\n        }\n        \n        UpdateWhipVisual(progress);\n    }\n    \n    private void UpdateWhipVisual(float progress)\n    {\n        float curveValue = _whipCurve.Evaluate(progress);\n        Vector3 currentTarget = Vector3.Lerp(_whipOrigin.position, _whipTargetPosition, curveValue);\n        \n        int segments = 20;\n        _whipRenderer.positionCount = segments + 1;\n        \n        for (int i = 0; i <= segments; i++)\n        {\n            float t = (float)i / segments;\n            Vector3 point = Vector3.Lerp(_whipOrigin.position, currentTarget, t);\n            \n            // Add some curve to make it look more whip-like\n            float height = Mathf.Sin(t * Mathf.PI) * 0.5f * curveValue;\n            point += Vector3.up * height;\n            \n            _whipRenderer.SetPosition(i, point);\n        }\n    }\n    \n    private void SetupWhipRenderer()\n    {\n        if (_whipRenderer != null)\n        {\n            _whipRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n            _whipRenderer.color = _whipColor;\n            _whipRenderer.startWidth = _whipWidth;\n            _whipRenderer.endWidth = _whipWidth * 0.3f;\n            _whipRenderer.useWorldSpace = true;\n            _whipRenderer.enabled = false;\n        }\n    }\n    \n    private void PlayWhipSound()\n    {\n        if (_audioSource != null && _whipCrackSound != null)\n        {\n            _audioSource.PlayOneShot(_whipCrackSound);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _whipHitSound != null)\n        {\n            _audioSource.PlayOneShot(_whipHitSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_whipOrigin != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_whipOrigin.position, _whipRange);\n            \n            if (_isWhipping)\n            {\n                Gizmos.color = Color.red;\n                Gizmos.DrawLine(_whipOrigin.position, _whipTargetPosition);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + amount);\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "hammer with ground slam",
      "ideal_ir": {
        "class_name": "GroundSlamHammer",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "slamForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "slamRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "slamDamage",
            "type": "float",
            "default": 50
          },
          {
            "name": "slamCooldown",
            "type": "float",
            "default": 2
          },
          {
            "name": "isSlammingDown",
            "type": "bool",
            "default": false
          },
          {
            "name": "canSlam",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "initiate_ground_slam",
            "trigger": "when player presses slam input button and hammer can slam",
            "actions": [
              {
                "action": "set hammer to slamming down state"
              },
              {
                "action": "disable further slam inputs"
              },
              {
                "action": "apply strong downward force to hammer"
              },
              {
                "action": "play slam charging sound effect"
              }
            ]
          },
          {
            "name": "impact_ground",
            "trigger": "when hammer collides with ground while slamming down",
            "actions": [
              {
                "action": "create shockwave effect at impact point"
              },
              {
                "action": "deal damage to all enemies within slam radius"
              },
              {
                "action": "knock back all objects within slam radius"
              },
              {
                "action": "create screen shake effect"
              },
              {
                "action": "play loud impact sound effect"
              },
              {
                "action": "spawn dust and debris particles"
              },
              {
                "action": "stop slamming down state"
              },
              {
                "action": "start slam cooldown timer"
              }
            ]
          },
          {
            "name": "reset_slam_ability",
            "trigger": "when slam cooldown timer expires",
            "actions": [
              {
                "action": "enable slam input again"
              },
              {
                "action": "reset hammer to ready state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Hammer : MonoBehaviour\n{\n    [Header(\"Hammer Settings\")]\n    [SerializeField] private float _slamForce = 20f;\n    [SerializeField] private float _slamRadius = 5f;\n    [SerializeField] private float _slamDamage = 50f;\n    [SerializeField] private float _slamCooldown = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _raiseHeight = 2f;\n    [SerializeField] private float _raiseSpeed = 5f;\n    [SerializeField] private float _slamSpeed = 15f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _slamEffectPrefab;\n    [SerializeField] private AudioClip _slamSound;\n    [SerializeField] private float _cameraShakeIntensity = 0.5f;\n    [SerializeField] private float _cameraShakeDuration = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSlamStart;\n    public UnityEvent OnSlamHit;\n    public UnityEvent<float> OnCooldownChanged;\n    \n    private Vector3 _originalPosition;\n    private bool _isSlaming = false;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private AudioSource _audioSource;\n    private Camera _mainCamera;\n    \n    private enum HammerState\n    {\n        Idle,\n        Raising,\n        Slamming,\n        Cooldown\n    }\n    \n    private HammerState _currentState = HammerState.Idle;\n    \n    void Start()\n    {\n        _originalPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n    }\n    \n    void Update()\n    {\n        HandleCooldown();\n        HandleInput();\n        UpdateHammerMovement();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            OnCooldownChanged?.Invoke(_cooldownTimer / _slamCooldown);\n            \n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                _currentState = HammerState.Idle;\n            }\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && CanSlam())\n        {\n            StartSlam();\n        }\n    }\n    \n    private bool CanSlam()\n    {\n        return _currentState == HammerState.Idle && !_isOnCooldown;\n    }\n    \n    private void StartSlam()\n    {\n        _currentState = HammerState.Raising;\n        _isSlaming = true;\n        OnSlamStart?.Invoke();\n    }\n    \n    private void UpdateHammerMovement()\n    {\n        switch (_currentState)\n        {\n            case HammerState.Raising:\n                HandleRaising();\n                break;\n            case HammerState.Slamming:\n                HandleSlamming();\n                break;\n        }\n    }\n    \n    private void HandleRaising()\n    {\n        Vector3 targetPosition = _originalPosition + Vector3.up * _raiseHeight;\n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _raiseSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.1f)\n        {\n            _currentState = HammerState.Slamming;\n        }\n    }\n    \n    private void HandleSlamming()\n    {\n        transform.position = Vector3.MoveTowards(transform.position, _originalPosition, _slamSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, _originalPosition) < 0.1f)\n        {\n            ExecuteSlam();\n            transform.position = _originalPosition;\n            _currentState = HammerState.Cooldown;\n            _isSlaming = false;\n            _isOnCooldown = true;\n            _cooldownTimer = _slamCooldown;\n        }\n    }\n    \n    private void ExecuteSlam()\n    {\n        // Create slam effect\n        if (_slamEffectPrefab != null)\n        {\n            Instantiate(_slamEffectPrefab, _originalPosition, Quaternion.identity);\n        }\n        \n        // Play slam sound\n        if (_slamSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_slamSound);\n        }\n        \n        // Camera shake\n        if (_mainCamera != null)\n        {\n            StartCoroutine(CameraShake());\n        }\n        \n        // Find and damage targets\n        Collider[] hitColliders = Physics.OverlapSphere(_originalPosition, _slamRadius, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Apply damage to objects with health\n            var healthComponent = hitCollider.GetComponent<IDamageable>();\n            if (healthComponent != null)\n            {\n                healthComponent.TakeDamage(_slamDamage);\n            }\n            \n            // Apply knockback force\n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 forceDirection = (hitCollider.transform.position - _originalPosition).normalized;\n                forceDirection.y = 0.5f; // Add upward force\n                rb.AddForce(forceDirection * _slamForce, ForceMode.Impulse);\n            }\n            \n            // Trigger player-specific effects\n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                // Additional player effects can be added here\n                OnSlamHit?.Invoke();\n            }\n        }\n        \n        OnSlamHit?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator CameraShake()\n    {\n        Vector3 originalPosition = _mainCamera.transform.position;\n        float elapsed = 0f;\n        \n        while (elapsed < _cameraShakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _cameraShakeIntensity;\n            float y = Random.Range(-1f, 1f) * _cameraShakeIntensity;\n            \n            _mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.position = originalPosition;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw slam radius\n        Gizmos.color = Color.red;\n        Vector3 center = Application.isPlaying ? _originalPosition : transform.position;\n        Gizmos.DrawWireSphere(center, _slamRadius);\n        \n        // Draw raise height\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(center, center + Vector3.up * _raiseHeight);\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n    \n    public bool IsOnCooldown => _isOnCooldown;\n    public float CooldownProgress => _isOnCooldown ? _cooldownTimer / _slamCooldown : 0f;\n    public bool IsSlaming => _isSlaming;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "spear with thrust attack",
      "ideal_ir": {
        "class_name": "Spear",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "thrustForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "thrustRange",
            "type": "float",
            "default": 3
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isThrusting",
            "type": "bool",
            "default": false
          },
          {
            "name": "canThrust",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "thrust_attack",
            "trigger": "when player presses attack button and can thrust",
            "actions": [
              {
                "action": "set is thrusting to true"
              },
              {
                "action": "set can thrust to false"
              },
              {
                "action": "thrust spear forward with thrust force"
              },
              {
                "action": "play thrust sound effect"
              }
            ]
          },
          {
            "name": "deal_damage_on_hit",
            "trigger": "when spear collides with enemy during thrust",
            "actions": [
              {
                "action": "deal damage to enemy"
              },
              {
                "action": "apply knockback force to enemy"
              },
              {
                "action": "play hit impact sound"
              },
              {
                "action": "stop thrust movement"
              }
            ]
          },
          {
            "name": "end_thrust",
            "trigger": "when thrust reaches maximum range or hits obstacle",
            "actions": [
              {
                "action": "set is thrusting to false"
              },
              {
                "action": "return spear to original position"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "reset_cooldown",
            "trigger": "when cooldown time has elapsed",
            "actions": [
              {
                "action": "set can thrust to true"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Spear : MonoBehaviour\n{\n    [Header(\"Spear Settings\")]\n    [SerializeField] private float _thrustDistance = 2f;\n    [SerializeField] private float _thrustSpeed = 10f;\n    [SerializeField] private float _thrustDuration = 0.3f;\n    [SerializeField] private float _retractSpeed = 8f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private int _damage = 25;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.Mouse0;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _thrustSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _thrustEffect;\n    [SerializeField] private GameObject _hitEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnThrustStart;\n    public UnityEvent OnThrustHit;\n    public UnityEvent OnThrustComplete;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _thrustTargetPosition;\n    private bool _isThrusting = false;\n    private bool _isRetracting = false;\n    private bool _canThrust = true;\n    private float _thrustTimer = 0f;\n    private float _cooldownTimer = 0f;\n    \n    private AudioSource _audioSource;\n    private Collider _spearCollider;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _originalPosition = transform.localPosition;\n        _audioSource = GetComponent<AudioSource>();\n        _spearCollider = GetComponent<Collider>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_spearCollider == null)\n        {\n            _spearCollider = gameObject.AddComponent<CapsuleCollider>();\n            _spearCollider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateThrustMovement();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_thrustKey) && _canThrust && !_isThrusting && !_isRetracting)\n        {\n            StartThrust();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canThrust)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canThrust = true;\n            }\n        }\n    }\n    \n    private void UpdateThrustMovement()\n    {\n        if (_isThrusting)\n        {\n            _thrustTimer += Time.deltaTime;\n            \n            float progress = _thrustTimer / _thrustDuration;\n            transform.localPosition = Vector3.Lerp(_originalPosition, _thrustTargetPosition, progress);\n            \n            if (progress >= 1f)\n            {\n                _isThrusting = false;\n                _isRetracting = true;\n                _thrustTimer = 0f;\n            }\n        }\n        else if (_isRetracting)\n        {\n            float retractProgress = _retractSpeed * Time.deltaTime;\n            transform.localPosition = Vector3.MoveTowards(transform.localPosition, _originalPosition, retractProgress);\n            \n            if (Vector3.Distance(transform.localPosition, _originalPosition) < 0.01f)\n            {\n                transform.localPosition = _originalPosition;\n                _isRetracting = false;\n                StartCooldown();\n                OnThrustComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void StartThrust()\n    {\n        _isThrusting = true;\n        _thrustTimer = 0f;\n        _thrustTargetPosition = _originalPosition + transform.forward * _thrustDistance;\n        \n        PlaySound(_thrustSound);\n        PlayThrustEffect();\n        OnThrustStart?.Invoke();\n    }\n    \n    private void StartCooldown()\n    {\n        _canThrust = false;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayThrustEffect()\n    {\n        if (_thrustEffect != null)\n        {\n            _thrustEffect.Play();\n        }\n    }\n    \n    private void PlayHitEffect(Vector3 hitPoint)\n    {\n        if (_hitEffect != null)\n        {\n            GameObject effect = Instantiate(_hitEffect, hitPoint, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isThrusting && other != null)\n        {\n            if (other.CompareTag(\"Enemy\"))\n            {\n                DealDamage(other.gameObject);\n                PlaySound(_hitSound);\n                PlayHitEffect(other.ClosestPoint(transform.position));\n                OnThrustHit?.Invoke();\n            }\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try different common health component patterns\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a fallback for damage dealing\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Alternative: Destroy enemies with specific tags\n        if (target.CompareTag(\"Enemy\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    public void SetDamage(int newDamage)\n    {\n        _damage = Mathf.Max(0, newDamage);\n    }\n    \n    public void SetThrustDistance(float newDistance)\n    {\n        _thrustDistance = Mathf.Max(0.1f, newDistance);\n    }\n    \n    public void SetCooldownTime(float newCooldown)\n    {\n        _cooldownTime = Mathf.Max(0f, newCooldown);\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    public bool CanThrust()\n    {\n        return _canThrust && !_isThrusting && !_isRetracting;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (_canThrust) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "axe with spin attack",
      "ideal_ir": {
        "class_name": "SpinAxe",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "spinSpeed",
            "type": "float",
            "default": 360
          },
          {
            "name": "spinDuration",
            "type": "float",
            "default": 2
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "isSpinning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_spin_attack",
            "trigger": "when attack input is pressed",
            "actions": [
              {
                "action": "set spinning state to true"
              },
              {
                "action": "start rotating around vertical axis at spin speed"
              },
              {
                "action": "play spinning sound effect"
              }
            ]
          },
          {
            "name": "damage_enemies_while_spinning",
            "trigger": "when spinning and colliding with enemy",
            "actions": [
              {
                "action": "deal damage to enemy"
              },
              {
                "action": "apply knockback force to enemy"
              },
              {
                "action": "play impact sound effect"
              }
            ]
          },
          {
            "name": "stop_spin_attack",
            "trigger": "when spin duration time has elapsed",
            "actions": [
              {
                "action": "set spinning state to false"
              },
              {
                "action": "stop rotation gradually"
              },
              {
                "action": "stop spinning sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpinAxe : MonoBehaviour\n{\n    [Header(\"Axe Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _spinDuration = 1.5f;\n    [SerializeField] private float _spinSpeed = 720f;\n    [SerializeField] private float _cooldownTime = 3f;\n    [SerializeField] private float _attackRadius = 2f;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _spinEffect;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _spinSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSpinStart;\n    public UnityEvent OnSpinEnd;\n    public UnityEvent<GameObject> OnEnemyHit;\n    \n    private bool _isSpinning = false;\n    private bool _canSpin = true;\n    private float _spinTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Transform _axeTransform;\n    private Vector3 _originalRotation;\n    private System.Collections.Generic.HashSet<Collider> _hitEnemies = new System.Collections.Generic.HashSet<Collider>();\n    \n    private void Start()\n    {\n        _axeTransform = transform;\n        _originalRotation = _axeTransform.eulerAngles;\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        HandleSpinInput();\n        HandleSpinRotation();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (!_canSpin)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canSpin = true;\n            }\n        }\n    }\n    \n    private void HandleSpinInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && _canSpin && !_isSpinning)\n        {\n            StartSpinAttack();\n        }\n    }\n    \n    private void HandleSpinRotation()\n    {\n        if (_isSpinning)\n        {\n            _spinTimer -= Time.deltaTime;\n            \n            float rotationAmount = _spinSpeed * Time.deltaTime;\n            _axeTransform.Rotate(0, 0, rotationAmount);\n            \n            CheckForEnemiesInRange();\n            \n            if (_spinTimer <= 0f)\n            {\n                EndSpinAttack();\n            }\n        }\n    }\n    \n    private void StartSpinAttack()\n    {\n        _isSpinning = true;\n        _canSpin = false;\n        _spinTimer = _spinDuration;\n        _cooldownTimer = _cooldownTime;\n        _hitEnemies.Clear();\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = true;\n            \n        if (_spinEffect != null)\n            _spinEffect.Play();\n            \n        if (_audioSource != null && _spinSound != null)\n            _audioSource.PlayOneShot(_spinSound);\n            \n        OnSpinStart?.Invoke();\n    }\n    \n    private void EndSpinAttack()\n    {\n        _isSpinning = false;\n        _axeTransform.eulerAngles = _originalRotation;\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        if (_spinEffect != null)\n            _spinEffect.Stop();\n            \n        OnSpinEnd?.Invoke();\n    }\n    \n    private void CheckForEnemiesInRange()\n    {\n        Collider[] enemiesInRange = Physics.OverlapSphere(_axeTransform.position, _attackRadius, _enemyLayers);\n        \n        foreach (Collider enemy in enemiesInRange)\n        {\n            if (!_hitEnemies.Contains(enemy) && !enemy.CompareTag(\"Player\"))\n            {\n                HitEnemy(enemy);\n                _hitEnemies.Add(enemy);\n            }\n        }\n    }\n    \n    private void HitEnemy(Collider enemy)\n    {\n        // Apply damage through various methods\n        var healthComponent = enemy.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_damage);\n        }\n        \n        // Try alternative damage methods\n        enemy.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        enemy.SendMessage(\"OnHit\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Apply knockback\n        Rigidbody enemyRb = enemy.GetComponent<Rigidbody>();\n        if (enemyRb != null)\n        {\n            Vector3 knockbackDirection = (enemy.transform.position - _axeTransform.position).normalized;\n            enemyRb.AddForce(knockbackDirection * 500f);\n        }\n        \n        // Play hit sound\n        if (_audioSource != null && _hitSound != null)\n            _audioSource.PlayOneShot(_hitSound);\n            \n        OnEnemyHit?.Invoke(enemy.gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isSpinning ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRadius);\n    }\n    \n    [System.Serializable]\n    public class Health : MonoBehaviour\n    {\n        [SerializeField] private float _maxHealth = 100f;\n        private float _currentHealth;\n        \n        private void Start()\n        {\n            _currentHealth = _maxHealth;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            _currentHealth -= damage;\n            if (_currentHealth <= 0f)\n            {\n                Die();\n            }\n        }\n        \n        private void Die()\n        {\n            Destroy(gameObject);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "staff with magic projectile",
      "ideal_ir": {
        "class_name": "MagicStaff",
        "components": [
          "Transform",
          "Renderer",
          "Collider"
        ],
        "fields": [
          {
            "name": "projectilePrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "firePoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "projectileSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "fireRate",
            "type": "float",
            "default": 1
          },
          {
            "name": "manaCost",
            "type": "int",
            "default": 10
          },
          {
            "name": "lastFireTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "cast_magic_projectile",
            "trigger": "when fire input is pressed and enough time has passed since last cast and player has sufficient mana",
            "actions": [
              {
                "action": "create magic projectile at fire point position"
              },
              {
                "action": "launch projectile forward at projectile speed"
              },
              {
                "action": "reduce player mana by mana cost"
              },
              {
                "action": "record current time as last fire time"
              },
              {
                "action": "play casting sound effect"
              },
              {
                "action": "show casting particle effect"
              }
            ]
          },
          {
            "name": "staff_idle_glow",
            "trigger": "when staff is equipped and not casting",
            "actions": [
              {
                "action": "emit soft magical glow from staff tip"
              },
              {
                "action": "play subtle magical humming sound"
              }
            ]
          },
          {
            "name": "insufficient_mana_feedback",
            "trigger": "when fire input is pressed but player has insufficient mana",
            "actions": [
              {
                "action": "play error sound"
              },
              {
                "action": "flash staff briefly in red color"
              },
              {
                "action": "display low mana warning message"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MagicStaff : MonoBehaviour\n{\n    [Header(\"Staff Settings\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private int _maxAmmo = 30;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _emptySound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _fireAnimationTrigger = \"Fire\";\n    [SerializeField] private string _reloadAnimationTrigger = \"Reload\";\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnReloadStarted;\n    public UnityEvent OnReloadCompleted;\n    public UnityEvent OnProjectileFired;\n    \n    private float _lastFireTime;\n    private int _currentAmmo;\n    private bool _isReloading;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        _playerCamera = Camera.main;\n        \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isReloading)\n            return;\n            \n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            StartReload();\n        }\n    }\n    \n    private void TryFire()\n    {\n        if (Time.time - _lastFireTime < 1f / _fireRate)\n            return;\n            \n        if (_currentAmmo <= 0)\n        {\n            PlayEmptySound();\n            return;\n        }\n        \n        Fire();\n    }\n    \n    private void Fire()\n    {\n        _lastFireTime = Time.time;\n        _currentAmmo--;\n        \n        Vector3 fireDirection = GetFireDirection();\n        CreateProjectile(fireDirection);\n        \n        PlayFireEffects();\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnProjectileFired?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            StartReload();\n        }\n    }\n    \n    private Vector3 GetFireDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n            return ray.direction;\n        }\n        \n        return _firePoint.forward;\n    }\n    \n    private void CreateProjectile(Vector3 direction)\n    {\n        if (_projectilePrefab == null)\n            return;\n            \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, Quaternion.LookRotation(direction));\n        \n        Rigidbody rb = projectile.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.velocity = direction * _projectileSpeed;\n        }\n        \n        MagicProjectile projectileScript = projectile.GetComponent<MagicProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<MagicProjectile>();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n            \n        if (_audioSource != null && _fireSound != null)\n            _audioSource.PlayOneShot(_fireSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(_fireAnimationTrigger);\n    }\n    \n    private void PlayEmptySound()\n    {\n        if (_audioSource != null && _emptySound != null)\n            _audioSource.PlayOneShot(_emptySound);\n    }\n    \n    private void StartReload()\n    {\n        if (_isReloading || _currentAmmo >= _maxAmmo)\n            return;\n            \n        _isReloading = true;\n        OnReloadStarted?.Invoke();\n        \n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(_reloadAnimationTrigger);\n            \n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnReloadCompleted?.Invoke();\n    }\n    \n    public bool CanFire()\n    {\n        return !_isReloading && _currentAmmo > 0 && Time.time - _lastFireTime >= 1f / _fireRate;\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n}\n\npublic class MagicProjectile : MonoBehaviour\n{\n    [Header(\"Projectile Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _lifetime = 5f;\n    [SerializeField] private float _explosionRadius = 3f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffectPrefab;\n    [SerializeField] private GameObject _explosionEffectPrefab;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private TrailRenderer _trail;\n    \n    private bool _hasHit;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit)\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n            return;\n            \n        Hit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit)\n            return;\n            \n        if (collision.gameObject.CompareTag(\"Player\"))\n            return;\n            \n        Hit(collision.collider);\n    }\n    \n    private void Hit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        Vector3 hitPoint = transform.position;\n        \n        if (_explosionRadius > 0)\n        {\n            ExplodeAtPoint(hitPoint);\n        }\n        else\n        {\n            DealDamageToTarget(hitCollider.gameObject);\n        }\n        \n        CreateHitEffects(hitPoint);\n        DestroyProjectile();\n    }\n    \n    private void ExplodeAtPoint(Vector3 explosionPoint)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(explosionPoint, _explosionRadius, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.CompareTag(\"Player\"))\n                continue;\n                \n            DealDamageToTarget(hitCollider.gameObject);\n            \n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - explosionPoint).normalized;\n                float distance = Vector3.Distance(explosionPoint, hitCollider.transform.position);\n                float force = Mathf.Lerp(500f, 100f, distance / _explosionRadius);\n                rb.AddForce(direction * force);\n            }\n        }\n        \n        if (_explosionEffectPrefab != null)\n        {\n            Instantiate(_explosionEffectPrefab, explosionPoint, Quaternion.identity);\n        }\n        \n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n    }\n    \n    private void DealDamageToTarget(GameObject target)\n    {\n        if (target.CompareTag(\"Enemy\"))\n        {\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        if (target.GetComponent<Rigidbody>() != null)\n        {\n            Vector3 force = transform.forward * 300f;\n            target.GetComponent<Rigidbody>().AddForce(force);\n        }\n    }\n    \n    private void CreateHitEffects(Vector3 position)\n    {\n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, position, Quaternion.identity);\n        }\n        \n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void DestroyProjectile()\n    {\n        if (_trail != null)\n            _trail.enabled = false;\n            \n        GetComponent<Collider>().enabled = false;\n        \n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n            rb.velocity = Vector3.zero;\n            \n        Destroy(gameObject, 2f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_explosionRadius > 0)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "scythe with sweeping attack",
      "ideal_ir": {
        "class_name": "Scythe",
        "components": [
          "Transform",
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "sweepDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "sweepRange",
            "type": "float",
            "default": 3
          },
          {
            "name": "sweepDuration",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "isSwinging",
            "type": "bool",
            "default": false
          },
          {
            "name": "onCooldown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initiate_sweep_attack",
            "trigger": "when attack input is pressed and not currently swinging and not on cooldown",
            "actions": [
              {
                "action": "set swinging state to true"
              },
              {
                "action": "begin sweeping animation"
              },
              {
                "action": "rotate scythe in wide arc motion"
              }
            ]
          },
          {
            "name": "damage_enemies_in_range",
            "trigger": "while sweeping and enemy enters sweep range",
            "actions": [
              {
                "action": "deal sweep damage to enemy"
              },
              {
                "action": "apply knockback force to enemy"
              },
              {
                "action": "play impact sound effect"
              }
            ]
          },
          {
            "name": "complete_sweep_attack",
            "trigger": "when sweep duration time has elapsed",
            "actions": [
              {
                "action": "set swinging state to false"
              },
              {
                "action": "return scythe to idle position"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "set cooldown state to true"
              }
            ]
          },
          {
            "name": "end_cooldown",
            "trigger": "when cooldown time has elapsed",
            "actions": [
              {
                "action": "set cooldown state to false"
              },
              {
                "action": "enable attack input detection"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ScytheWeapon : MonoBehaviour\n{\n    [Header(\"Attack Settings\")]\n    [SerializeField] private float _attackDamage = 50f;\n    [SerializeField] private float _attackRange = 3f;\n    [SerializeField] private float _sweepAngle = 120f;\n    [SerializeField] private float _attackDuration = 0.5f;\n    [SerializeField] private float _attackCooldown = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Transform _scytheModel;\n    [SerializeField] private float _sweepSpeed = 360f;\n    [SerializeField] private AnimationCurve _sweepCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swooshSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent OnAttackStarted;\n    public UnityEvent OnAttackCompleted;\n    \n    private bool _isAttacking = false;\n    private bool _canAttack = true;\n    private float _lastAttackTime;\n    private Vector3 _originalRotation;\n    private HashSet<Collider> _hitTargets = new HashSet<Collider>();\n    \n    private void Start()\n    {\n        if (_scytheModel == null)\n            _scytheModel = transform;\n            \n        _originalRotation = _scytheModel.localEulerAngles;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            StartAttack();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canAttack && Time.time >= _lastAttackTime + _attackCooldown)\n        {\n            _canAttack = true;\n        }\n    }\n    \n    public void StartAttack()\n    {\n        if (_isAttacking || !_canAttack) return;\n        \n        StartCoroutine(PerformSweepAttack());\n    }\n    \n    private IEnumerator PerformSweepAttack()\n    {\n        _isAttacking = true;\n        _canAttack = false;\n        _lastAttackTime = Time.time;\n        _hitTargets.Clear();\n        \n        OnAttackStarted?.Invoke();\n        \n        if (_audioSource != null && _swooshSound != null)\n            _audioSource.PlayOneShot(_swooshSound);\n            \n        if (_slashEffect != null)\n            _slashEffect.Play();\n        \n        float elapsedTime = 0f;\n        float startAngle = -_sweepAngle * 0.5f;\n        float endAngle = _sweepAngle * 0.5f;\n        \n        while (elapsedTime < _attackDuration)\n        {\n            float progress = elapsedTime / _attackDuration;\n            float curveValue = _sweepCurve.Evaluate(progress);\n            float currentAngle = Mathf.Lerp(startAngle, endAngle, curveValue);\n            \n            _scytheModel.localEulerAngles = _originalRotation + new Vector3(0, 0, currentAngle);\n            \n            CheckForTargets(currentAngle);\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        _scytheModel.localEulerAngles = _originalRotation;\n        _isAttacking = false;\n        \n        OnAttackCompleted?.Invoke();\n    }\n    \n    private void CheckForTargets(float currentAngle)\n    {\n        Vector3 attackDirection = Quaternion.Euler(0, 0, currentAngle) * transform.right;\n        Vector3 attackOrigin = transform.position;\n        \n        Collider[] hitColliders = Physics.OverlapSphere(attackOrigin, _attackRange, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (_hitTargets.Contains(hitCollider) || hitCollider.transform == transform)\n                continue;\n                \n            Vector3 directionToTarget = (hitCollider.transform.position - attackOrigin).normalized;\n            float angleToTarget = Vector3.Angle(transform.right, directionToTarget);\n            \n            if (angleToTarget <= _sweepAngle * 0.5f)\n            {\n                DealDamage(hitCollider);\n                _hitTargets.Add(hitCollider);\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        if (_audioSource != null && _hitSound != null)\n            _audioSource.PlayOneShot(_hitSound);\n        \n        // Try to damage using common health interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to call common damage methods\n            var damageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (damageMethod != null)\n            {\n                damageMethod.Invoke(healthComponent, new object[] { _attackDamage });\n            }\n            else\n            {\n                // Try alternative method names\n                var altMethod = healthComponent.GetType().GetMethod(\"Damage\");\n                if (altMethod != null)\n                {\n                    altMethod.Invoke(healthComponent, new object[] { _attackDamage });\n                }\n            }\n        }\n        \n        // Apply knockback\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * 10f, ForceMode.Impulse);\n        }\n        \n        OnDamageDealt?.Invoke(_attackDamage);\n        \n        // Destroy objects tagged as destructible\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target.gameObject);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        // Draw sweep arc\n        Vector3 leftBound = Quaternion.Euler(0, 0, -_sweepAngle * 0.5f) * transform.right * _attackRange;\n        Vector3 rightBound = Quaternion.Euler(0, 0, _sweepAngle * 0.5f) * transform.right * _attackRange;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(transform.position, transform.position + leftBound);\n        Gizmos.DrawLine(transform.position, transform.position + rightBound);\n        \n        // Draw arc\n        for (int i = 0; i < 20; i++)\n        {\n            float angle1 = Mathf.Lerp(-_sweepAngle * 0.5f, _sweepAngle * 0.5f, i / 19f);\n            float angle2 = Mathf.Lerp(-_sweepAngle * 0.5f, _sweepAngle * 0.5f, (i + 1) / 19f);\n            \n            Vector3 point1 = transform.position + Quaternion.Euler(0, 0, angle1) * transform.right * _attackRange;\n            Vector3 point2 = transform.position + Quaternion.Euler(0, 0, angle2) * transform.right * _attackRange;\n            \n            Gizmos.DrawLine(point1, point2);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "dual daggers with fast combo",
      "ideal_ir": {
        "class_name": "DualDaggers",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "attackDamage",
            "type": "float",
            "default": 15
          },
          {
            "name": "attackSpeed",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "comboWindow",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "comboMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "maxComboCount",
            "type": "int",
            "default": 4
          },
          {
            "name": "currentComboCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "lastAttackTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isAttacking",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "primary_attack",
            "trigger": "when primary attack input is pressed",
            "actions": [
              {
                "action": "perform quick dagger slash animation"
              },
              {
                "action": "deal base attack damage to enemies in front"
              },
              {
                "action": "play metal slash sound effect"
              },
              {
                "action": "record current time as last attack time"
              },
              {
                "action": "set attacking state to true"
              }
            ]
          },
          {
            "name": "combo_attack",
            "trigger": "when primary attack input is pressed and previous attack was within combo window",
            "actions": [
              {
                "action": "increase combo count by one"
              },
              {
                "action": "perform faster alternating dagger strike animation"
              },
              {
                "action": "deal attack damage multiplied by combo multiplier"
              },
              {
                "action": "play higher pitched slash sound"
              },
              {
                "action": "create visual combo effect"
              },
              {
                "action": "reset combo window timer"
              }
            ]
          },
          {
            "name": "combo_finisher",
            "trigger": "when combo count reaches maximum and attack input is pressed",
            "actions": [
              {
                "action": "perform spinning dual dagger finisher animation"
              },
              {
                "action": "deal double damage in wider area"
              },
              {
                "action": "create dramatic visual effect"
              },
              {
                "action": "play powerful impact sound"
              },
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "add brief cooldown period"
              }
            ]
          },
          {
            "name": "combo_reset",
            "trigger": "when combo window time expires without new attack",
            "actions": [
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "set attacking state to false"
              },
              {
                "action": "return to idle weapon stance"
              }
            ]
          },
          {
            "name": "dual_strike",
            "trigger": "when secondary attack input is pressed",
            "actions": [
              {
                "action": "perform simultaneous dual dagger thrust animation"
              },
              {
                "action": "deal increased damage with both daggers"
              },
              {
                "action": "create piercing attack that hits multiple enemies"
              },
              {
                "action": "play double impact sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class DualDaggerWeapon : MonoBehaviour\n{\n    [Header(\"Weapon Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _comboWindow = 0.8f;\n    [SerializeField] private int _maxComboCount = 4;\n    [SerializeField] private float _comboDamageMultiplier = 1.2f;\n    \n    [Header(\"Attack Timing\")]\n    [SerializeField] private float _leftDaggerDelay = 0f;\n    [SerializeField] private float _rightDaggerDelay = 0.15f;\n    [SerializeField] private float _attackCooldown = 0.3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _leftDagger;\n    [SerializeField] private Transform _rightDagger;\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private TrailRenderer _leftTrail;\n    [SerializeField] private TrailRenderer _rightTrail;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _attackSounds;\n    [SerializeField] private AudioClip _comboFinishSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _weaponAnimator;\n    [SerializeField] private string _leftAttackTrigger = \"LeftAttack\";\n    [SerializeField] private string _rightAttackTrigger = \"RightAttack\";\n    [SerializeField] private string _comboTrigger = \"ComboAttack\";\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent<int> OnComboChanged;\n    public UnityEvent OnComboFinished;\n    \n    private int _currentCombo = 0;\n    private float _lastAttackTime = 0f;\n    private bool _canAttack = true;\n    private bool _isAttacking = false;\n    private Camera _playerCamera;\n    private LayerMask _enemyLayerMask = -1;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_weaponAnimator == null)\n            _weaponAnimator = GetComponent<Animator>();\n            \n        _enemyLayerMask = ~(1 << gameObject.layer);\n        \n        SetupTrails();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateComboTimer();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack && !_isAttacking)\n        {\n            PerformAttack();\n        }\n    }\n    \n    private void UpdateComboTimer()\n    {\n        if (_currentCombo > 0 && Time.time - _lastAttackTime > _comboWindow)\n        {\n            ResetCombo();\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (!_canAttack) return;\n        \n        _isAttacking = true;\n        _canAttack = false;\n        _lastAttackTime = Time.time;\n        \n        _currentCombo = Mathf.Min(_currentCombo + 1, _maxComboCount);\n        OnComboChanged?.Invoke(_currentCombo);\n        \n        bool useLeftDagger = (_currentCombo % 2 == 1);\n        \n        if (_weaponAnimator != null)\n        {\n            if (_currentCombo >= _maxComboCount)\n            {\n                _weaponAnimator.SetTrigger(_comboTrigger);\n                StartCoroutine(ExecuteComboFinisher());\n            }\n            else\n            {\n                string trigger = useLeftDagger ? _leftAttackTrigger : _rightAttackTrigger;\n                _weaponAnimator.SetTrigger(trigger);\n                StartCoroutine(ExecuteSingleAttack(useLeftDagger));\n            }\n        }\n        else\n        {\n            if (_currentCombo >= _maxComboCount)\n            {\n                StartCoroutine(ExecuteComboFinisher());\n            }\n            else\n            {\n                StartCoroutine(ExecuteSingleAttack(useLeftDagger));\n            }\n        }\n    }\n    \n    private IEnumerator ExecuteSingleAttack(bool useLeftDagger)\n    {\n        float delay = useLeftDagger ? _leftDaggerDelay : _rightDaggerDelay;\n        yield return new WaitForSeconds(delay);\n        \n        Transform activeDagger = useLeftDagger ? _leftDagger : _rightDagger;\n        TrailRenderer activeTrail = useLeftDagger ? _leftTrail : _rightTrail;\n        \n        if (activeTrail != null)\n        {\n            activeTrail.enabled = true;\n            activeTrail.Clear();\n        }\n        \n        PlayAttackSound();\n        PerformDamageCheck(activeDagger, false);\n        \n        if (_slashEffect != null && activeDagger != null)\n        {\n            _slashEffect.transform.position = activeDagger.position;\n            _slashEffect.Play();\n        }\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        if (activeTrail != null)\n            activeTrail.enabled = false;\n            \n        yield return new WaitForSeconds(_attackCooldown - 0.2f);\n        \n        _canAttack = true;\n        _isAttacking = false;\n    }\n    \n    private IEnumerator ExecuteComboFinisher()\n    {\n        yield return new WaitForSeconds(_leftDaggerDelay);\n        \n        if (_leftTrail != null)\n        {\n            _leftTrail.enabled = true;\n            _leftTrail.Clear();\n        }\n        if (_rightTrail != null)\n        {\n            _rightTrail.enabled = true;\n            _rightTrail.Clear();\n        }\n        \n        PlayComboSound();\n        \n        PerformDamageCheck(_leftDagger, true);\n        yield return new WaitForSeconds(0.1f);\n        PerformDamageCheck(_rightDagger, true);\n        \n        if (_slashEffect != null)\n        {\n            if (_leftDagger != null)\n            {\n                _slashEffect.transform.position = _leftDagger.position;\n                _slashEffect.Play();\n            }\n            yield return new WaitForSeconds(0.1f);\n            if (_rightDagger != null)\n            {\n                _slashEffect.transform.position = _rightDagger.position;\n                _slashEffect.Play();\n            }\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        if (_leftTrail != null) _leftTrail.enabled = false;\n        if (_rightTrail != null) _rightTrail.enabled = false;\n        \n        OnComboFinished?.Invoke();\n        ResetCombo();\n        \n        yield return new WaitForSeconds(_attackCooldown);\n        \n        _canAttack = true;\n        _isAttacking = false;\n    }\n    \n    private void PerformDamageCheck(Transform dagger, bool isComboFinisher)\n    {\n        if (dagger == null) return;\n        \n        Vector3 attackOrigin = dagger.position;\n        Vector3 attackDirection = dagger.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.5f, attackDirection, _attackRange, _enemyLayerMask);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            float finalDamage = _attackDamage;\n            \n            if (isComboFinisher)\n            {\n                finalDamage *= _comboDamageMultiplier * _maxComboCount;\n            }\n            else if (_currentCombo > 1)\n            {\n                finalDamage *= Mathf.Pow(_comboDamageMultiplier, _currentCombo - 1);\n            }\n            \n            IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(finalDamage);\n            }\n            else\n            {\n                Rigidbody rb = hit.collider.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 forceDirection = (hit.point - attackOrigin).normalized;\n                    rb.AddForce(forceDirection * finalDamage * 10f, ForceMode.Impulse);\n                }\n            }\n            \n            OnDamageDealt?.Invoke(finalDamage);\n        }\n    }\n    \n    private void PlayAttackSound()\n    {\n        if (_audioSource != null && _attackSounds != null && _attackSounds.Length > 0)\n        {\n            AudioClip clip = _attackSounds[Random.Range(0, _attackSounds.Length)];\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayComboSound()\n    {\n        if (_audioSource != null && _comboFinishSound != null)\n        {\n            _audioSource.PlayOneShot(_comboFinishSound);\n        }\n    }\n    \n    private void ResetCombo()\n    {\n        _currentCombo = 0;\n        OnComboChanged?.Invoke(_currentCombo);\n    }\n    \n    private void SetupTrails()\n    {\n        if (_leftTrail != null)\n        {\n            _leftTrail.enabled = false;\n            _leftTrail.time = 0.3f;\n        }\n        if (_rightTrail != null)\n        {\n            _rightTrail.enabled = false;\n            _rightTrail.time = 0.3f;\n        }\n    }\n    \n    public int GetCurrentCombo()\n    {\n        return _currentCombo;\n    }\n    \n    public bool IsAttacking()\n    {\n        return _isAttacking;\n    }\n    \n    public void SetAttackDamage(float damage)\n    {\n        _attackDamage = damage;\n    }\n    \n    public void SetComboMultiplier(float multiplier)\n    {\n        _comboDamageMultiplier = multiplier;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_leftDagger != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_leftDagger.position, 0.5f);\n            Gizmos.DrawRay(_leftDagger.position, _leftDagger.forward * _attackRange);\n        }\n        \n        if (_rightDagger != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_rightDagger.position, 0.5f);\n            Gizmos.DrawRay(_rightDagger.position, _rightDagger.forward * _attackRange);\n        }\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "katana with quick draw",
      "ideal_ir": {
        "class_name": "QuickDrawKatana",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "drawSpeed",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "sheatheSpeed",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "slashDamage",
            "type": "int",
            "default": 75
          },
          {
            "name": "isSheathed",
            "type": "bool",
            "default": true
          },
          {
            "name": "isDrawing",
            "type": "bool",
            "default": false
          },
          {
            "name": "drawRange",
            "type": "float",
            "default": 3.0
          }
        ],
        "behaviors": [
          {
            "name": "quick_draw_attack",
            "trigger": "when player presses attack button and katana is sheathed",
            "actions": [
              {
                "action": "play quick draw sound effect"
              },
              {
                "action": "set drawing state to true"
              },
              {
                "action": "rapidly move katana from sheathed to drawn position"
              },
              {
                "action": "create slash effect in front of player"
              },
              {
                "action": "deal damage to enemies within draw range"
              },
              {
                "action": "set sheathed state to false"
              }
            ]
          },
          {
            "name": "sheathe_katana",
            "trigger": "when player presses sheathe button and katana is drawn",
            "actions": [
              {
                "action": "play sheathing sound effect"
              },
              {
                "action": "smoothly move katana to sheathed position"
              },
              {
                "action": "set sheathed state to true"
              },
              {
                "action": "reset drawing state to false"
              }
            ]
          },
          {
            "name": "normal_slash",
            "trigger": "when player presses attack button and katana is already drawn",
            "actions": [
              {
                "action": "play slash sound effect"
              },
              {
                "action": "create sword swing animation"
              },
              {
                "action": "deal damage to enemies in slash arc"
              },
              {
                "action": "apply brief screen shake effect"
              }
            ]
          },
          {
            "name": "draw_stance_ready",
            "trigger": "when katana is sheathed and enemy is nearby",
            "actions": [
              {
                "action": "highlight katana with subtle glow effect"
              },
              {
                "action": "increase player movement speed slightly"
              },
              {
                "action": "show quick draw prompt to player"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Katana : MonoBehaviour\n{\n    [Header(\"Katana Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Quick Draw\")]\n    [SerializeField] private float _quickDrawWindow = 0.3f;\n    [SerializeField] private float _quickDrawDamageMultiplier = 2f;\n    [SerializeField] private float _quickDrawRange = 3f;\n    [SerializeField] private KeyCode _quickDrawKey = KeyCode.Q;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _drawSpeed = 2f;\n    [SerializeField] private float _sheatheSpeed = 1.5f;\n    [SerializeField] private Transform _katanaModel;\n    [SerializeField] private Transform _sheathedPosition;\n    [SerializeField] private Transform _drawnPosition;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private ParticleSystem _quickDrawEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drawSound;\n    [SerializeField] private AudioClip _sheatheSound;\n    [SerializeField] private AudioClip _slashSound;\n    [SerializeField] private AudioClip _quickDrawSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnAttack;\n    public UnityEvent OnQuickDraw;\n    public UnityEvent OnDraw;\n    public UnityEvent OnSheathe;\n    \n    private bool _isDrawn = false;\n    private bool _isQuickDrawReady = true;\n    private bool _isAnimating = false;\n    private float _lastDrawTime;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class HitInfo\n    {\n        public GameObject target;\n        public float damage;\n        public Vector3 hitPoint;\n        public Vector3 hitDirection;\n    }\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_katanaModel == null)\n            _katanaModel = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_sheathedPosition == null)\n        {\n            GameObject sheathed = new GameObject(\"SheathedPosition\");\n            sheathed.transform.SetParent(transform.parent);\n            sheathed.transform.localPosition = new Vector3(0.5f, -0.5f, 0.5f);\n            sheathed.transform.localRotation = Quaternion.Euler(0, 0, 45);\n            _sheathedPosition = sheathed.transform;\n        }\n        \n        if (_drawnPosition == null)\n        {\n            GameObject drawn = new GameObject(\"DrawnPosition\");\n            drawn.transform.SetParent(transform.parent);\n            drawn.transform.localPosition = new Vector3(0.3f, 0, 0.8f);\n            drawn.transform.localRotation = Quaternion.identity;\n            _drawnPosition = drawn.transform;\n        }\n        \n        SetKatanaPosition(_sheathedPosition);\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateQuickDrawWindow();\n    }\n    \n    void HandleInput()\n    {\n        if (_isAnimating) return;\n        \n        if (Input.GetKeyDown(_quickDrawKey))\n        {\n            if (!_isDrawn && _isQuickDrawReady)\n            {\n                PerformQuickDraw();\n            }\n            else if (!_isDrawn)\n            {\n                DrawKatana();\n            }\n            else\n            {\n                SheatheKatana();\n            }\n        }\n        \n        if (_isDrawn && Input.GetMouseButtonDown(0))\n        {\n            PerformAttack();\n        }\n    }\n    \n    void UpdateQuickDrawWindow()\n    {\n        if (!_isQuickDrawReady && Time.time - _lastDrawTime > _quickDrawWindow)\n        {\n            _isQuickDrawReady = true;\n        }\n    }\n    \n    void PerformQuickDraw()\n    {\n        if (_isAnimating) return;\n        \n        _isQuickDrawReady = false;\n        _lastDrawTime = Time.time;\n        \n        StartCoroutine(QuickDrawSequence());\n    }\n    \n    System.Collections.IEnumerator QuickDrawSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_quickDrawSound);\n        OnQuickDraw?.Invoke();\n        \n        if (_quickDrawEffect != null)\n            _quickDrawEffect.Play();\n        \n        float drawTime = 1f / (_drawSpeed * 2f);\n        yield return StartCoroutine(AnimateToPosition(_drawnPosition, drawTime));\n        \n        PerformQuickDrawAttack();\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        float sheatheTime = 1f / (_sheatheSpeed * 2f);\n        yield return StartCoroutine(AnimateToPosition(_sheathedPosition, sheatheTime));\n        \n        _isDrawn = false;\n        _isAnimating = false;\n        \n        PlaySound(_sheatheSound);\n        OnSheathe?.Invoke();\n    }\n    \n    void PerformQuickDrawAttack()\n    {\n        float damage = _damage * _quickDrawDamageMultiplier;\n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.5f, attackDirection, _quickDrawRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            ProcessHit(hit.collider.gameObject, damage, hit.point, attackDirection);\n        }\n        \n        if (_slashEffect != null)\n        {\n            _slashEffect.transform.position = attackOrigin + attackDirection * (_quickDrawRange * 0.5f);\n            _slashEffect.Play();\n        }\n        \n        OnAttack?.Invoke(damage);\n    }\n    \n    void DrawKatana()\n    {\n        if (_isDrawn || _isAnimating) return;\n        \n        StartCoroutine(DrawSequence());\n    }\n    \n    System.Collections.IEnumerator DrawSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_drawSound);\n        OnDraw?.Invoke();\n        \n        float drawTime = 1f / _drawSpeed;\n        yield return StartCoroutine(AnimateToPosition(_drawnPosition, drawTime));\n        \n        _isDrawn = true;\n        _isAnimating = false;\n    }\n    \n    void SheatheKatana()\n    {\n        if (!_isDrawn || _isAnimating) return;\n        \n        StartCoroutine(SheatheSequence());\n    }\n    \n    System.Collections.IEnumerator SheatheSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_sheatheSound);\n        \n        float sheatheTime = 1f / _sheatheSpeed;\n        yield return StartCoroutine(AnimateToPosition(_sheathedPosition, sheatheTime));\n        \n        _isDrawn = false;\n        _isAnimating = false;\n        \n        OnSheathe?.Invoke();\n    }\n    \n    System.Collections.IEnumerator AnimateToPosition(Transform targetTransform, float duration)\n    {\n        Vector3 startPos = _katanaModel.position;\n        Quaternion startRot = _katanaModel.rotation;\n        Vector3 targetPos = targetTransform.position;\n        Quaternion targetRot = targetTransform.rotation;\n        \n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            _katanaModel.position = Vector3.Lerp(startPos, targetPos, t);\n            _katanaModel.rotation = Quaternion.Lerp(startRot, targetRot, t);\n            \n            yield return null;\n        }\n        \n        _katanaModel.position = targetPos;\n        _katanaModel.rotation = targetRot;\n    }\n    \n    void SetKatanaPosition(Transform targetTransform)\n    {\n        _katanaModel.position = targetTransform.position;\n        _katanaModel.rotation = targetTransform.rotation;\n    }\n    \n    void PerformAttack()\n    {\n        if (!_isDrawn || _isAnimating) return;\n        \n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.3f, attackDirection, _attackRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            ProcessHit(hit.collider.gameObject, _damage, hit.point, attackDirection);\n        }\n        \n        PlaySound(_slashSound);\n        \n        if (_slashEffect != null)\n        {\n            _slashEffect.transform.position = attackOrigin + attackDirection * (_attackRange * 0.5f);\n            _slashEffect.Play();\n        }\n        \n        OnAttack?.Invoke(_damage);\n    }\n    \n    void ProcessHit(GameObject target, float damage, Vector3 hitPoint, Vector3 hitDirection)\n    {\n        if (target.CompareTag(\"Player\")) return;\n        \n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            targetRb.AddForce(hitDirection * 10f, ForceMode.Impulse);\n        }\n        \n        HitInfo hitInfo = new HitInfo\n        {\n            target = target,\n            damage = damage,\n            hitPoint = hitPoint,\n            hitDirection = hitDirection\n        };\n        \n        target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        target.SendMessage(\"OnKatanaHit\", hitInfo, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_katanaModel == null) return;\n        \n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(attackOrigin + attackDirection * _attackRange, 0.3f);\n        Gizmos.DrawLine(attackOrigin, attackOrigin + attackDirection * _attackRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(attackOrigin + attackDirection * _quickDrawRange, 0.5f);\n        Gizmos.DrawLine(attackOrigin, attackOrigin + attackDirection * _quickDrawRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mace with stun effect",
      "ideal_ir": {
        "class_name": "StunMace",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "stunDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "stunChance",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "damage",
            "type": "int",
            "default": 25
          },
          {
            "name": "swingForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "isSwinging",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "swing_mace",
            "trigger": "when player presses attack button",
            "actions": [
              {
                "action": "play swing sound effect"
              },
              {
                "action": "apply forward force to mace"
              },
              {
                "action": "set swinging state to true"
              },
              {
                "action": "start swing animation"
              }
            ]
          },
          {
            "name": "hit_target",
            "trigger": "when mace collides with enemy during swing",
            "actions": [
              {
                "action": "deal damage to enemy"
              },
              {
                "action": "play impact sound effect"
              },
              {
                "action": "create impact particle effect"
              },
              {
                "action": "check if stun effect should trigger based on chance"
              }
            ]
          },
          {
            "name": "apply_stun",
            "trigger": "when stun effect is triggered on enemy hit",
            "actions": [
              {
                "action": "disable enemy movement for stun duration"
              },
              {
                "action": "disable enemy attacks for stun duration"
              },
              {
                "action": "play stun visual effect on enemy"
              },
              {
                "action": "play stun sound effect"
              }
            ]
          },
          {
            "name": "end_swing",
            "trigger": "when swing animation completes",
            "actions": [
              {
                "action": "set swinging state to false"
              },
              {
                "action": "reset mace position to ready stance"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class Mace : MonoBehaviour\n{\n    [Header(\"Mace Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Stun Effect\")]\n    [SerializeField] private float _stunDuration = 2f;\n    [SerializeField] private float _stunChance = 0.3f;\n    [SerializeField] private GameObject _stunEffectPrefab;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _stunSound;\n    [SerializeField] private Transform _attackPoint;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _attackTrigger = \"Attack\";\n    \n    private AudioSource _audioSource;\n    private bool _canAttack = true;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class StunnedTarget\n    {\n        public GameObject target;\n        public float stunEndTime;\n        public GameObject stunEffect;\n        public Vector3 originalVelocity;\n        public bool wasKinematic;\n    }\n    \n    private System.Collections.Generic.List<StunnedTarget> _stunnedTargets = new System.Collections.Generic.List<StunnedTarget>();\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_attackPoint == null)\n            _attackPoint = transform;\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateStunnedTargets();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            Attack();\n        }\n    }\n    \n    void Attack()\n    {\n        if (!_canAttack) return;\n        \n        _canAttack = false;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_attackTrigger);\n            \n        StartCoroutine(PerformAttack());\n        StartCoroutine(AttackCooldown());\n    }\n    \n    IEnumerator PerformAttack()\n    {\n        yield return new WaitForSeconds(0.3f);\n        \n        Collider[] hitTargets = Physics.OverlapSphere(_attackPoint.position, _attackRange, _targetLayers);\n        \n        foreach (Collider target in hitTargets)\n        {\n            if (target.gameObject == gameObject) continue;\n            \n            ProcessHit(target.gameObject);\n        }\n    }\n    \n    void ProcessHit(GameObject target)\n    {\n        // Apply damage\n        var healthComponent = target.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_damage);\n        }\n        \n        // Check for stun\n        bool shouldStun = Random.Range(0f, 1f) <= _stunChance;\n        if (shouldStun)\n        {\n            ApplyStun(target);\n        }\n        \n        // Visual and audio effects\n        PlayHitEffects(target.transform.position, shouldStun);\n    }\n    \n    void ApplyStun(GameObject target)\n    {\n        // Remove existing stun if present\n        RemoveStun(target);\n        \n        StunnedTarget stunnedTarget = new StunnedTarget\n        {\n            target = target,\n            stunEndTime = Time.time + _stunDuration\n        };\n        \n        // Handle different target types\n        var rigidbody = target.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            stunnedTarget.originalVelocity = rigidbody.velocity;\n            stunnedTarget.wasKinematic = rigidbody.isKinematic;\n            rigidbody.velocity = Vector3.zero;\n            rigidbody.isKinematic = true;\n        }\n        \n        var navMeshAgent = target.GetComponent<UnityEngine.AI.NavMeshAgent>();\n        if (navMeshAgent != null)\n        {\n            navMeshAgent.isStopped = true;\n        }\n        \n        var characterController = target.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n        }\n        \n        // Spawn stun effect\n        if (_stunEffectPrefab != null)\n        {\n            stunnedTarget.stunEffect = Instantiate(_stunEffectPrefab, target.transform.position + Vector3.up, Quaternion.identity);\n            stunnedTarget.stunEffect.transform.SetParent(target.transform);\n        }\n        \n        _stunnedTargets.Add(stunnedTarget);\n    }\n    \n    void UpdateStunnedTargets()\n    {\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            if (_stunnedTargets[i].target == null || Time.time >= _stunnedTargets[i].stunEndTime)\n            {\n                RemoveStunAtIndex(i);\n            }\n        }\n    }\n    \n    void RemoveStun(GameObject target)\n    {\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            if (_stunnedTargets[i].target == target)\n            {\n                RemoveStunAtIndex(i);\n                break;\n            }\n        }\n    }\n    \n    void RemoveStunAtIndex(int index)\n    {\n        if (index < 0 || index >= _stunnedTargets.Count) return;\n        \n        StunnedTarget stunnedTarget = _stunnedTargets[index];\n        \n        if (stunnedTarget.target != null)\n        {\n            // Restore movement\n            var rigidbody = stunnedTarget.target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                rigidbody.isKinematic = stunnedTarget.wasKinematic;\n                if (!stunnedTarget.wasKinematic)\n                    rigidbody.velocity = stunnedTarget.originalVelocity;\n            }\n            \n            var navMeshAgent = stunnedTarget.target.GetComponent<UnityEngine.AI.NavMeshAgent>();\n            if (navMeshAgent != null)\n            {\n                navMeshAgent.isStopped = false;\n            }\n            \n            var characterController = stunnedTarget.target.GetComponent<CharacterController>();\n            if (characterController != null)\n            {\n                characterController.enabled = true;\n            }\n        }\n        \n        // Remove stun effect\n        if (stunnedTarget.stunEffect != null)\n        {\n            Destroy(stunnedTarget.stunEffect);\n        }\n        \n        _stunnedTargets.RemoveAt(index);\n    }\n    \n    void PlayHitEffects(Vector3 position, bool wasStunned)\n    {\n        if (_hitEffect != null)\n        {\n            _hitEffect.transform.position = position;\n            _hitEffect.Play();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (wasStunned && _stunSound != null)\n                _audioSource.PlayOneShot(_stunSound);\n            else if (_hitSound != null)\n                _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    IEnumerator AttackCooldown()\n    {\n        yield return new WaitForSeconds(_attackCooldown);\n        _canAttack = true;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_attackPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_attackPoint.position, _attackRange);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        // Clean up all stuns when mace is destroyed\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            RemoveStunAtIndex(i);\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "trident with water affinity",
      "ideal_ir": {
        "class_name": "WaterTrident",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "waterDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "throwForce",
            "type": "float",
            "default": 800
          },
          {
            "name": "returnSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "waterBurstRadius",
            "type": "float",
            "default": 3
          },
          {
            "name": "isThrown",
            "type": "bool",
            "default": false
          },
          {
            "name": "owner",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "throw_trident",
            "trigger": "when player performs throw input while holding trident",
            "actions": [
              {
                "action": "launch trident forward with throw force"
              },
              {
                "action": "set is thrown to true"
              },
              {
                "action": "play water splash sound effect"
              },
              {
                "action": "create water trail particles behind trident"
              }
            ]
          },
          {
            "name": "water_impact",
            "trigger": "when trident collides with enemy or surface",
            "actions": [
              {
                "action": "deal water damage to target"
              },
              {
                "action": "create water burst explosion at impact point"
              },
              {
                "action": "apply knockback effect in burst radius"
              },
              {
                "action": "play water impact sound"
              },
              {
                "action": "stop forward movement"
              }
            ]
          },
          {
            "name": "return_to_owner",
            "trigger": "when trident has been thrown and impact occurred",
            "actions": [
              {
                "action": "fly back toward owner at return speed"
              },
              {
                "action": "create water stream particles during return"
              },
              {
                "action": "ignore collision with enemies during return"
              }
            ]
          },
          {
            "name": "catch_trident",
            "trigger": "when returning trident reaches close proximity to owner",
            "actions": [
              {
                "action": "attach trident back to owner hand"
              },
              {
                "action": "set is thrown to false"
              },
              {
                "action": "stop all particle effects"
              },
              {
                "action": "play catch sound effect"
              }
            ]
          },
          {
            "name": "water_enhancement",
            "trigger": "when trident is near water source",
            "actions": [
              {
                "action": "increase water damage by fifty percent"
              },
              {
                "action": "enhance water particle effects"
              },
              {
                "action": "create ripple effects on nearby water surface"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class WaterTrident : MonoBehaviour\n{\n    [Header(\"Trident Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _range = 10f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Water Affinity\")]\n    [SerializeField] private float _waterDamageMultiplier = 2f;\n    [SerializeField] private float _underwaterSpeedBonus = 1.5f;\n    [SerializeField] private float _waterHealingRate = 5f;\n    [SerializeField] private ParticleSystem _waterEffectPrefab;\n    [SerializeField] private AudioClip _waterAttackSound;\n    [SerializeField] private AudioClip _waterSplashSound;\n    \n    [Header(\"Special Abilities\")]\n    [SerializeField] private float _waterBoltSpeed = 20f;\n    [SerializeField] private GameObject _waterBoltPrefab;\n    [SerializeField] private float _tidalWaveForce = 1000f;\n    [SerializeField] private float _tidalWaveRadius = 15f;\n    [SerializeField] private float _specialAbilityCooldown = 10f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _waterMaterial;\n    [SerializeField] private Light _tridentGlow;\n    [SerializeField] private Transform _projectileSpawnPoint;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent OnWaterAbilityUsed;\n    public UnityEvent OnTridentEquipped;\n    \n    private bool _isEquipped = false;\n    private float _lastAttackTime;\n    private float _lastSpecialAbilityTime;\n    private bool _isInWater = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Transform _wielder;\n    private Rigidbody _wielderRigidbody;\n    private ParticleSystem _currentWaterEffect;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        \n        if (_tridentGlow != null)\n            _tridentGlow.enabled = false;\n            \n        SetupWaterDetection();\n    }\n    \n    private void Update()\n    {\n        if (_isEquipped && _wielder != null)\n        {\n            HandleInput();\n            UpdateWaterEffects();\n            HandleWaterHealing();\n        }\n        \n        UpdateVisualEffects();\n    }\n    \n    private void SetupWaterDetection()\n    {\n        SphereCollider waterDetector = gameObject.AddComponent<SphereCollider>();\n        waterDetector.isTrigger = true;\n        waterDetector.radius = 2f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Water\") || other.name.ToLower().Contains(\"water\"))\n        {\n            _isInWater = true;\n            OnWaterAbilityUsed?.Invoke();\n            PlayWaterEffect();\n        }\n        \n        if (other.CompareTag(\"Player\") && !_isEquipped)\n        {\n            EquipTrident(other.transform);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Water\") || other.name.ToLower().Contains(\"water\"))\n        {\n            _isInWater = false;\n            StopWaterEffect();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && CanAttack())\n        {\n            PerformAttack();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.Q) && CanUseSpecialAbility())\n        {\n            UseWaterBolt();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.E) && CanUseSpecialAbility())\n        {\n            UseTidalWave();\n        }\n    }\n    \n    private void EquipTrident(Transform player)\n    {\n        _wielder = player;\n        _wielderRigidbody = player.GetComponent<Rigidbody>();\n        _isEquipped = true;\n        \n        transform.SetParent(player);\n        transform.localPosition = new Vector3(0.5f, 0f, 1f);\n        transform.localRotation = Quaternion.identity;\n        \n        if (_tridentGlow != null)\n            _tridentGlow.enabled = true;\n            \n        OnTridentEquipped?.Invoke();\n    }\n    \n    private bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    private bool CanUseSpecialAbility()\n    {\n        return Time.time >= _lastSpecialAbilityTime + _specialAbilityCooldown;\n    }\n    \n    private void PerformAttack()\n    {\n        _lastAttackTime = Time.time;\n        \n        RaycastHit hit;\n        Vector3 attackDirection = _wielder.forward;\n        \n        if (Physics.Raycast(_wielder.position, attackDirection, out hit, _range, _targetLayers))\n        {\n            float finalDamage = _damage;\n            \n            if (_isInWater)\n                finalDamage *= _waterDamageMultiplier;\n                \n            DealDamage(hit.collider.gameObject, finalDamage);\n            CreateWaterImpactEffect(hit.point);\n        }\n        \n        PlayAttackSound();\n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void UseWaterBolt()\n    {\n        _lastSpecialAbilityTime = Time.time;\n        \n        if (_waterBoltPrefab != null && _projectileSpawnPoint != null)\n        {\n            GameObject waterBolt = Instantiate(_waterBoltPrefab, _projectileSpawnPoint.position, _projectileSpawnPoint.rotation);\n            \n            WaterBolt boltScript = waterBolt.GetComponent<WaterBolt>();\n            if (boltScript == null)\n                boltScript = waterBolt.AddComponent<WaterBolt>();\n                \n            boltScript.Initialize(_damage * 1.5f, _waterBoltSpeed, _wielder);\n        }\n        \n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void UseTidalWave()\n    {\n        _lastSpecialAbilityTime = Time.time;\n        \n        Collider[] affectedObjects = Physics.OverlapSphere(_wielder.position, _tidalWaveRadius);\n        \n        foreach (Collider obj in affectedObjects)\n        {\n            if (obj.gameObject != _wielder.gameObject)\n            {\n                Rigidbody rb = obj.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 forceDirection = (obj.transform.position - _wielder.position).normalized;\n                    rb.AddForce(forceDirection * _tidalWaveForce, ForceMode.Impulse);\n                }\n                \n                if (!obj.CompareTag(\"Player\"))\n                {\n                    DealDamage(obj.gameObject, _damage * 0.8f);\n                }\n            }\n        }\n        \n        CreateTidalWaveEffect();\n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void DealDamage(GameObject target, float damage)\n    {\n        if (target.CompareTag(\"Enemy\") || target.name.ToLower().Contains(\"enemy\"))\n        {\n            Destroy(target);\n        }\n        \n        OnDamageDealt?.Invoke(damage);\n    }\n    \n    private void HandleWaterHealing()\n    {\n        if (_isInWater && _wielder != null)\n        {\n            // Simulate healing by triggering event\n            OnDamageDealt?.Invoke(-_waterHealingRate * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateWaterEffects()\n    {\n        if (_isInWater && _wielderRigidbody != null)\n        {\n            // Apply underwater speed bonus\n            Vector3 velocity = _wielderRigidbody.velocity;\n            velocity *= _underwaterSpeedBonus;\n            _wielderRigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_renderer != null && _waterMaterial != null && _isInWater)\n        {\n            _renderer.material = _waterMaterial;\n        }\n        \n        if (_tridentGlow != null)\n        {\n            _tridentGlow.intensity = _isInWater ? 2f : 1f;\n            _tridentGlow.color = _isInWater ? Color.cyan : Color.blue;\n        }\n    }\n    \n    private void PlayWaterEffect()\n    {\n        if (_waterEffectPrefab != null)\n        {\n            _currentWaterEffect = Instantiate(_waterEffectPrefab, transform.position, Quaternion.identity);\n            _currentWaterEffect.transform.SetParent(transform);\n        }\n        \n        if (_audioSource != null && _waterSplashSound != null)\n        {\n            _audioSource.PlayOneShot(_waterSplashSound);\n        }\n    }\n    \n    private void StopWaterEffect()\n    {\n        if (_currentWaterEffect != null)\n        {\n            _currentWaterEffect.Stop();\n            Destroy(_currentWaterEffect.gameObject, 2f);\n        }\n    }\n    \n    private void CreateWaterImpactEffect(Vector3 position)\n    {\n        if (_waterEffectPrefab != null)\n        {\n            ParticleSystem impact = Instantiate(_waterEffectPrefab, position, Quaternion.identity);\n            Destroy(impact.gameObject, 3f);\n        }\n    }\n    \n    private void CreateTidalWaveEffect()\n    {\n        if (_waterEffectPrefab != null)\n        {\n            ParticleSystem tidalWave = Instantiate(_waterEffectPrefab, _wielder.position, Quaternion.identity);\n            var main = tidalWave.main;\n            main.startSize = _tidalWaveRadius;\n            Destroy(tidalWave.gameObject, 5f);\n        }\n    }\n    \n    private void PlayAttackSound()\n    {\n        if (_audioSource != null && _waterAttackSound != null)\n        {\n            _audioSource.PlayOneShot(_waterAttackSound);\n        }\n    }\n}\n\npublic class WaterBolt : MonoBehaviour\n{\n    private float _damage;\n    private float _speed;\n    private Transform _owner;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _rigidbody.useGravity = false;\n        \n        Destroy(gameObject, 5f);\n    }\n    \n    public void Initialize(float damage, float speed, Transform owner)\n    {\n        _damage = damage;\n        _speed = speed;\n        _owner = owner;\n        \n        if (_rigidbody != null)\n            _rigidbody.velocity = transform.forward * _speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.transform != _owner && !other.CompareTag(\"Player\"))\n        {\n            if (other.CompareTag(\"Enemy\") || other.name.ToLower().Contains(\"enemy\"))\n            {\n                Destroy(other.gameObject);\n            }\n            \n            Destroy(gameObject);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "chakram that returns",
      "ideal_ir": {
        "class_name": "ReturningChakram",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "throwForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "returnSpeed",
            "type": "float",
            "default": 10
          },
          {
            "name": "maxDistance",
            "type": "float",
            "default": 20
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 720
          },
          {
            "name": "thrower",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isReturning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "throw_chakram",
            "trigger": "when chakram is thrown",
            "actions": [
              {
                "action": "apply forward force based on throw force"
              },
              {
                "action": "start spinning continuously at rotation speed"
              },
              {
                "action": "record the thrower position"
              }
            ]
          },
          {
            "name": "check_return_condition",
            "trigger": "when chakram has traveled maximum distance or hits obstacle",
            "actions": [
              {
                "action": "set returning state to true"
              },
              {
                "action": "stop forward momentum"
              }
            ]
          },
          {
            "name": "return_to_thrower",
            "trigger": "when chakram is in returning state",
            "actions": [
              {
                "action": "move toward thrower position at return speed"
              },
              {
                "action": "continue spinning during return flight"
              }
            ]
          },
          {
            "name": "catch_chakram",
            "trigger": "when chakram reaches thrower position while returning",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "stop spinning"
              },
              {
                "action": "reset returning state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class ReturningChakram : MonoBehaviour\n{\n    [Header(\"Chakram Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _returnSpeed = 10f;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _rotationSpeed = 720f;\n    [SerializeField] private float _returnDelay = 0.5f;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _returnSound;\n    \n    private enum ChakramState\n    {\n        Idle,\n        Thrown,\n        Returning,\n        Caught\n    }\n    \n    private ChakramState _currentState = ChakramState.Idle;\n    private Transform _thrower;\n    private Vector3 _throwDirection;\n    private Vector3 _startPosition;\n    private float _distanceTraveled;\n    private float _returnTimer;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private bool _hasHitTarget;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.useGravity = false;\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        HandleRotation();\n        HandleMovement();\n        CheckReturnConditions();\n    }\n    \n    private void HandleRotation()\n    {\n        if (_currentState != ChakramState.Idle && _currentState != ChakramState.Caught)\n        {\n            transform.Rotate(Vector3.forward * _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        switch (_currentState)\n        {\n            case ChakramState.Thrown:\n                HandleThrownMovement();\n                break;\n            case ChakramState.Returning:\n                HandleReturningMovement();\n                break;\n        }\n    }\n    \n    private void HandleThrownMovement()\n    {\n        _distanceTraveled += _rigidbody.velocity.magnitude * Time.deltaTime;\n        \n        if (_returnTimer > 0f)\n        {\n            _returnTimer -= Time.deltaTime;\n        }\n    }\n    \n    private void HandleReturningMovement()\n    {\n        if (_thrower != null)\n        {\n            Vector3 directionToThrower = (_thrower.position - transform.position).normalized;\n            _rigidbody.velocity = directionToThrower * _returnSpeed;\n            \n            float distanceToThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceToThrower < 1f)\n            {\n                CatchChakram();\n            }\n        }\n        else\n        {\n            Vector3 directionToStart = (_startPosition - transform.position).normalized;\n            _rigidbody.velocity = directionToStart * _returnSpeed;\n            \n            float distanceToStart = Vector3.Distance(transform.position, _startPosition);\n            if (distanceToStart < 1f)\n            {\n                ResetChakram();\n            }\n        }\n    }\n    \n    private void CheckReturnConditions()\n    {\n        if (_currentState == ChakramState.Thrown)\n        {\n            bool shouldReturn = _distanceTraveled >= _maxDistance || \n                              _returnTimer <= 0f || \n                              _hasHitTarget;\n            \n            if (shouldReturn)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    public void ThrowChakram(Transform thrower, Vector3 direction)\n    {\n        if (_currentState != ChakramState.Idle) return;\n        \n        _thrower = thrower;\n        _throwDirection = direction.normalized;\n        _currentState = ChakramState.Thrown;\n        _distanceTraveled = 0f;\n        _returnTimer = _returnDelay;\n        _hasHitTarget = false;\n        \n        _rigidbody.velocity = _throwDirection * _throwForce;\n        \n        PlaySound(_throwSound);\n    }\n    \n    private void StartReturning()\n    {\n        if (_currentState != ChakramState.Thrown) return;\n        \n        _currentState = ChakramState.Returning;\n        PlaySound(_returnSound);\n    }\n    \n    private void CatchChakram()\n    {\n        _currentState = ChakramState.Caught;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_thrower != null)\n        {\n            transform.SetParent(_thrower);\n            transform.localPosition = Vector3.zero;\n        }\n        \n        ResetChakram();\n    }\n    \n    private void ResetChakram()\n    {\n        _currentState = ChakramState.Idle;\n        _rigidbody.velocity = Vector3.zero;\n        _distanceTraveled = 0f;\n        _returnTimer = 0f;\n        _hasHitTarget = false;\n        _thrower = null;\n        \n        transform.SetParent(null);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_currentState != ChakramState.Thrown && _currentState != ChakramState.Returning) return;\n        \n        if (other.CompareTag(\"Player\") && _currentState == ChakramState.Returning)\n        {\n            CatchChakram();\n            return;\n        }\n        \n        if (_thrower != null && other.transform == _thrower) return;\n        \n        if (IsInLayerMask(other.gameObject.layer, _enemyLayers))\n        {\n            DealDamage(other);\n            _hasHitTarget = true;\n            \n            if (_currentState == ChakramState.Thrown)\n            {\n                StartReturning();\n            }\n        }\n        else if (other.CompareTag(\"Wall\") || other.CompareTag(\"Obstacle\"))\n        {\n            _hasHitTarget = true;\n            \n            if (_currentState == ChakramState.Thrown)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        var targetHealth = target.GetComponent<Health>();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(_damage);\n        }\n        \n        PlaySound(_hitSound);\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsAvailable()\n    {\n        return _currentState == ChakramState.Idle;\n    }\n    \n    public void ForceReturn()\n    {\n        if (_currentState == ChakramState.Thrown)\n        {\n            StartReturning();\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "slingshot with stones",
      "ideal_ir": {
        "class_name": "Slingshot",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "launchForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "maxPullDistance",
            "type": "float",
            "default": 3
          },
          {
            "name": "stonePrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "launchPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isPulledBack",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentPullDistance",
            "type": "float",
            "default": 0
          },
          {
            "name": "aimDirection",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "pull_back_slingshot",
            "trigger": "when player holds down fire button while aiming at slingshot",
            "actions": [
              {
                "action": "set slingshot to pulled back state"
              },
              {
                "action": "calculate pull distance based on mouse or controller input"
              },
              {
                "action": "clamp pull distance to maximum allowed value"
              },
              {
                "action": "update visual representation of slingshot tension"
              },
              {
                "action": "play stretching sound effect"
              }
            ]
          },
          {
            "name": "aim_slingshot",
            "trigger": "while slingshot is pulled back and player moves input",
            "actions": [
              {
                "action": "calculate aim direction from input"
              },
              {
                "action": "update visual aim indicator or trajectory preview"
              },
              {
                "action": "rotate slingshot to face aim direction"
              }
            ]
          },
          {
            "name": "launch_stone",
            "trigger": "when player releases fire button while slingshot is pulled back",
            "actions": [
              {
                "action": "spawn stone projectile at launch point"
              },
              {
                "action": "apply launch force to stone in aim direction"
              },
              {
                "action": "scale launch force by current pull distance"
              },
              {
                "action": "reset slingshot to normal position"
              },
              {
                "action": "set pulled back state to false"
              },
              {
                "action": "play launch sound effect"
              },
              {
                "action": "add screen shake effect"
              }
            ]
          },
          {
            "name": "reset_slingshot",
            "trigger": "when player cancels aiming or moves away from slingshot",
            "actions": [
              {
                "action": "return slingshot to rest position"
              },
              {
                "action": "set pulled back state to false"
              },
              {
                "action": "reset pull distance to zero"
              },
              {
                "action": "hide aim indicators"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Slingshot : MonoBehaviour\n{\n    [Header(\"Slingshot Settings\")]\n    [SerializeField] private Transform _leftAnchor;\n    [SerializeField] private Transform _rightAnchor;\n    [SerializeField] private Transform _projectileSpawnPoint;\n    [SerializeField] private LineRenderer _leftBand;\n    [SerializeField] private LineRenderer _rightBand;\n    [SerializeField] private float _maxPullDistance = 3f;\n    [SerializeField] private float _forceMultiplier = 10f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Projectile Settings\")]\n    [SerializeField] private GameObject _stonePrefab;\n    [SerializeField] private int _maxStones = 10;\n    [SerializeField] private float _stoneLifetime = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pullSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Vector3> OnStoneReleased;\n    public UnityEvent OnOutOfStones;\n    \n    private Camera _camera;\n    private bool _isPulling = false;\n    private Vector3 _pullPosition;\n    private GameObject _currentStone;\n    private int _remainingStones;\n    private Vector3 _initialSpawnPosition;\n    \n    private void Start()\n    {\n        _camera = Camera.main;\n        if (_camera == null)\n            _camera = FindObjectOfType<Camera>();\n            \n        _remainingStones = _maxStones;\n        _initialSpawnPosition = _projectileSpawnPoint.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupBands();\n        ResetSlingshot();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _remainingStones > 0)\n        {\n            StartPull();\n        }\n        else if (Input.GetMouseButton(0) && _isPulling)\n        {\n            UpdatePull();\n        }\n        else if (Input.GetMouseButtonUp(0) && _isPulling)\n        {\n            ReleaseSlingshot();\n        }\n    }\n    \n    private void StartPull()\n    {\n        Vector3 mouseWorldPos = GetMouseWorldPosition();\n        float distanceToSlingshot = Vector3.Distance(mouseWorldPos, _projectileSpawnPoint.position);\n        \n        if (distanceToSlingshot <= _maxPullDistance)\n        {\n            _isPulling = true;\n            _pullPosition = _initialSpawnPosition;\n            CreateStone();\n            \n            if (_audioSource && _pullSound)\n                _audioSource.PlayOneShot(_pullSound);\n        }\n    }\n    \n    private void UpdatePull()\n    {\n        Vector3 mouseWorldPos = GetMouseWorldPosition();\n        Vector3 pullDirection = mouseWorldPos - _initialSpawnPosition;\n        \n        float pullDistance = Mathf.Clamp(pullDirection.magnitude, 0f, _maxPullDistance);\n        _pullPosition = _initialSpawnPosition + pullDirection.normalized * pullDistance;\n        \n        if (_currentStone != null)\n        {\n            _currentStone.transform.position = _pullPosition;\n        }\n    }\n    \n    private void ReleaseSlingshot()\n    {\n        if (_currentStone != null)\n        {\n            Vector3 launchDirection = (_initialSpawnPosition - _pullPosition).normalized;\n            float pullDistance = Vector3.Distance(_pullPosition, _initialSpawnPosition);\n            float launchForce = pullDistance * _forceMultiplier;\n            \n            Rigidbody stoneRb = _currentStone.GetComponent<Rigidbody>();\n            if (stoneRb != null)\n            {\n                stoneRb.isKinematic = false;\n                stoneRb.AddForce(launchDirection * launchForce, ForceMode.Impulse);\n            }\n            \n            Destroy(_currentStone, _stoneLifetime);\n            _currentStone = null;\n            _remainingStones--;\n            \n            if (_audioSource && _releaseSound)\n                _audioSource.PlayOneShot(_releaseSound);\n                \n            OnStoneReleased?.Invoke(launchDirection * launchForce);\n            \n            if (_remainingStones <= 0)\n                OnOutOfStones?.Invoke();\n        }\n        \n        _isPulling = false;\n        ResetSlingshot();\n    }\n    \n    private void CreateStone()\n    {\n        if (_stonePrefab != null)\n        {\n            _currentStone = Instantiate(_stonePrefab, _pullPosition, Quaternion.identity);\n            \n            Rigidbody rb = _currentStone.GetComponent<Rigidbody>();\n            if (rb == null)\n                rb = _currentStone.AddComponent<Rigidbody>();\n                \n            rb.isKinematic = true;\n            rb.mass = 0.1f;\n            \n            Collider col = _currentStone.GetComponent<Collider>();\n            if (col == null)\n            {\n                SphereCollider sphereCol = _currentStone.AddComponent<SphereCollider>();\n                sphereCol.radius = 0.05f;\n            }\n            \n            StoneProjectile stoneScript = _currentStone.GetComponent<StoneProjectile>();\n            if (stoneScript == null)\n                _currentStone.AddComponent<StoneProjectile>();\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_leftBand != null && _rightBand != null)\n        {\n            Vector3 bandPosition = _isPulling ? _pullPosition : _initialSpawnPosition;\n            \n            _leftBand.SetPosition(0, _leftAnchor.position);\n            _leftBand.SetPosition(1, bandPosition);\n            \n            _rightBand.SetPosition(0, _rightAnchor.position);\n            _rightBand.SetPosition(1, bandPosition);\n        }\n    }\n    \n    private void SetupBands()\n    {\n        if (_leftBand != null)\n        {\n            _leftBand.positionCount = 2;\n            _leftBand.startWidth = 0.02f;\n            _leftBand.endWidth = 0.02f;\n        }\n        \n        if (_rightBand != null)\n        {\n            _rightBand.positionCount = 2;\n            _rightBand.startWidth = 0.02f;\n            _rightBand.endWidth = 0.02f;\n        }\n    }\n    \n    private void ResetSlingshot()\n    {\n        _pullPosition = _initialSpawnPosition;\n        UpdateVisuals();\n    }\n    \n    private Vector3 GetMouseWorldPosition()\n    {\n        if (_camera == null) return Vector3.zero;\n        \n        Vector3 mouseScreenPos = Input.mousePosition;\n        mouseScreenPos.z = Vector3.Distance(_camera.transform.position, transform.position);\n        return _camera.ScreenToWorldPoint(mouseScreenPos);\n    }\n    \n    public void AddStones(int amount)\n    {\n        _remainingStones += amount;\n        _remainingStones = Mathf.Clamp(_remainingStones, 0, _maxStones);\n    }\n    \n    public int GetRemainingStones()\n    {\n        return _remainingStones;\n    }\n    \n    public void ResetAmmo()\n    {\n        _remainingStones = _maxStones;\n    }\n}\n\npublic class StoneProjectile : MonoBehaviour\n{\n    [Header(\"Impact Settings\")]\n    [SerializeField] private float _impactForce = 5f;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private AudioClip _impactSound;\n    \n    private AudioSource _audioSource;\n    private bool _hasImpacted = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasImpacted) return;\n        \n        _hasImpacted = true;\n        \n        if (_impactEffect != null)\n        {\n            GameObject effect = Instantiate(_impactEffect, transform.position, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n        \n        if (_audioSource && _impactSound)\n            _audioSource.PlayOneShot(_impactSound);\n            \n        Rigidbody hitRb = collision.rigidbody;\n        if (hitRb != null)\n        {\n            Vector3 impactDirection = collision.contacts[0].normal * -1f;\n            hitRb.AddForceAtPosition(impactDirection * _impactForce, collision.contacts[0].point, ForceMode.Impulse);\n        }\n        \n        if (collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            collision.gameObject.SendMessage(\"TakeDamage\", 1, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "blowgun with darts",
      "ideal_ir": {
        "class_name": "Blowgun",
        "components": [
          "Transform",
          "AudioSource",
          "Animator"
        ],
        "fields": [
          {
            "name": "dartPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "firePoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "dartSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "maxRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "reloadTime",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "ammoCount",
            "type": "int",
            "default": 10
          },
          {
            "name": "maxAmmo",
            "type": "int",
            "default": 10
          },
          {
            "name": "isLoaded",
            "type": "bool",
            "default": true
          },
          {
            "name": "canFire",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "fire_dart",
            "trigger": "when fire input is pressed and weapon is loaded and can fire",
            "actions": [
              {
                "action": "instantiate dart at fire point position"
              },
              {
                "action": "launch dart forward at dart speed"
              },
              {
                "action": "play blowgun firing sound"
              },
              {
                "action": "trigger firing animation"
              },
              {
                "action": "decrease ammo count by one"
              },
              {
                "action": "set is loaded to false"
              },
              {
                "action": "set can fire to false"
              }
            ]
          },
          {
            "name": "reload_dart",
            "trigger": "when weapon is not loaded and ammo count is greater than zero and can fire",
            "actions": [
              {
                "action": "play dart loading sound"
              },
              {
                "action": "trigger reload animation"
              },
              {
                "action": "wait for reload time duration"
              },
              {
                "action": "set is loaded to true"
              },
              {
                "action": "set can fire to true"
              }
            ]
          },
          {
            "name": "auto_reload",
            "trigger": "when fire input is pressed and weapon is not loaded and ammo count is greater than zero",
            "actions": [
              {
                "action": "start reload sequence"
              }
            ]
          },
          {
            "name": "empty_fire_attempt",
            "trigger": "when fire input is pressed and ammo count is zero",
            "actions": [
              {
                "action": "play empty click sound"
              },
              {
                "action": "trigger empty fire animation"
              }
            ]
          },
          {
            "name": "refill_ammo",
            "trigger": "when reload input is held and ammo count is less than maximum",
            "actions": [
              {
                "action": "play ammo refill sound"
              },
              {
                "action": "set ammo count to maximum"
              },
              {
                "action": "set is loaded to true if ammo available"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Blowgun : MonoBehaviour\n{\n    [Header(\"Blowgun Settings\")]\n    [SerializeField] private GameObject _dartPrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _dartSpeed = 20f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private int _maxAmmo = 10;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _emptySound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private Transform _blowgunModel;\n    [SerializeField] private float _recoilForce = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnShoot;\n    public UnityEvent OnReload;\n    public UnityEvent OnAmmoEmpty;\n    \n    private int _currentAmmo;\n    private float _lastFireTime;\n    private bool _isReloading;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_blowgunModel != null)\n            _originalPosition = _blowgunModel.localPosition;\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleRecoil();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && CanShoot())\n        {\n            Shoot();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && !_isReloading && _currentAmmo < _maxAmmo)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n    \n    private bool CanShoot()\n    {\n        return !_isReloading && \n               _currentAmmo > 0 && \n               Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n    \n    private void Shoot()\n    {\n        if (_dartPrefab == null) return;\n        \n        _currentAmmo--;\n        _lastFireTime = Time.time;\n        \n        GameObject dart = Instantiate(_dartPrefab, _firePoint.position, _firePoint.rotation);\n        Dart dartComponent = dart.GetComponent<Dart>();\n        if (dartComponent == null)\n            dartComponent = dart.AddComponent<Dart>();\n            \n        dartComponent.Initialize(_dartSpeed);\n        \n        PlaySound(_shootSound);\n        \n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n            \n        ApplyRecoil();\n        OnShoot?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            OnAmmoEmpty?.Invoke();\n        }\n    }\n    \n    private void ApplyRecoil()\n    {\n        if (_blowgunModel != null)\n        {\n            _blowgunModel.localPosition = _originalPosition - transform.forward * _recoilForce;\n        }\n    }\n    \n    private void HandleRecoil()\n    {\n        if (_blowgunModel != null)\n        {\n            _blowgunModel.localPosition = Vector3.Lerp(_blowgunModel.localPosition, _originalPosition, Time.deltaTime * 10f);\n        }\n    }\n    \n    private IEnumerator Reload()\n    {\n        _isReloading = true;\n        PlaySound(_reloadSound);\n        OnReload?.Invoke();\n        \n        yield return new WaitForSeconds(_reloadTime);\n        \n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void TryShoot()\n    {\n        if (CanShoot())\n        {\n            Shoot();\n        }\n        else if (_currentAmmo <= 0)\n        {\n            PlaySound(_emptySound);\n        }\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n}\n\npublic class Dart : MonoBehaviour\n{\n    [Header(\"Dart Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _lifetime = 5f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private Rigidbody _rigidbody;\n    private bool _hasHit;\n    private AudioSource _audioSource;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    public void Initialize(float speed)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = transform.forward * speed;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (((1 << other.gameObject.layer) & _hitLayers) != 0)\n        {\n            HandleHit(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit) return;\n        \n        if (((1 << collision.gameObject.layer) & _hitLayers) != 0)\n        {\n            HandleHit(collision.collider);\n        }\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            DealDamageToPlayer(hitCollider.gameObject);\n        }\n        else\n        {\n            DealDamageToTarget(hitCollider.gameObject);\n        }\n        \n        if (_stickToSurfaces)\n        {\n            StickToSurface(hitCollider);\n        }\n        \n        SpawnHitEffect();\n        PlayHitSound();\n        \n        if (!_stickToSurfaces)\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void DealDamageToPlayer(GameObject player)\n    {\n        // Send damage message to player\n        player.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void DealDamageToTarget(GameObject target)\n    {\n        // Try to find health component or send damage message\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n        \n        transform.SetParent(surface.transform);\n        \n        Destroy(gameObject, _lifetime - 1f);\n    }\n    \n    private void SpawnHitEffect()\n    {\n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "net launcher for capturing",
      "ideal_ir": {
        "class_name": "NetLauncher",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "launchForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "netPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "launchPoint",
            "type": "Transform",
            "default": null
          },
          {
            "name": "maxRange",
            "type": "float",
            "default": 20
          },
          {
            "name": "reloadTime",
            "type": "float",
            "default": 3
          },
          {
            "name": "isReloaded",
            "type": "bool",
            "default": true
          },
          {
            "name": "launchSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "launch_net",
            "trigger": "when fire input is pressed and launcher is reloaded",
            "actions": [
              {
                "action": "play launch sound effect"
              },
              {
                "action": "instantiate net prefab at launch point"
              },
              {
                "action": "apply launch force to net in forward direction"
              },
              {
                "action": "set launcher to not reloaded state"
              },
              {
                "action": "start reload timer"
              }
            ]
          },
          {
            "name": "reload_launcher",
            "trigger": "when reload time has elapsed",
            "actions": [
              {
                "action": "set launcher to reloaded state"
              },
              {
                "action": "play reload complete sound"
              }
            ]
          },
          {
            "name": "aim_launcher",
            "trigger": "when aiming input is active",
            "actions": [
              {
                "action": "rotate launcher to follow crosshair or mouse position"
              },
              {
                "action": "show trajectory preview line"
              },
              {
                "action": "highlight potential targets within range"
              }
            ]
          },
          {
            "name": "show_ready_indicator",
            "trigger": "when launcher is reloaded",
            "actions": [
              {
                "action": "display ready indicator light or UI element"
              },
              {
                "action": "enable aiming assistance"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class NetLauncher : MonoBehaviour\n{\n    [Header(\"Net Projectile\")]\n    [SerializeField] private GameObject _netPrefab;\n    [SerializeField] private Transform _launchPoint;\n    [SerializeField] private float _launchForce = 15f;\n    [SerializeField] private float _launchAngle = 45f;\n    \n    [Header(\"Capture Settings\")]\n    [SerializeField] private LayerMask _capturableLayers = -1;\n    [SerializeField] private float _captureRadius = 3f;\n    [SerializeField] private float _captureDuration = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _launchKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseAiming = true;\n    \n    [Header(\"Cooldown\")]\n    [SerializeField] private float _cooldownTime = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _launchSound;\n    [SerializeField] private AudioClip _captureSound;\n    \n    private Camera _playerCamera;\n    private AudioSource _audioSource;\n    private float _lastLaunchTime;\n    private bool _canLaunch = true;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_launchPoint == null)\n            _launchPoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_launchKey) && _canLaunch)\n        {\n            LaunchNet();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canLaunch && Time.time >= _lastLaunchTime + _cooldownTime)\n        {\n            _canLaunch = true;\n        }\n    }\n    \n    private void LaunchNet()\n    {\n        if (_netPrefab == null) return;\n        \n        Vector3 launchDirection = GetLaunchDirection();\n        GameObject netInstance = Instantiate(_netPrefab, _launchPoint.position, Quaternion.LookRotation(launchDirection));\n        \n        NetProjectile netProjectile = netInstance.GetComponent<NetProjectile>();\n        if (netProjectile == null)\n            netProjectile = netInstance.AddComponent<NetProjectile>();\n            \n        netProjectile.Initialize(launchDirection, _launchForce, _capturableLayers, _captureRadius, _captureDuration, _captureSound);\n        \n        PlayLaunchSound();\n        \n        _canLaunch = false;\n        _lastLaunchTime = Time.time;\n    }\n    \n    private Vector3 GetLaunchDirection()\n    {\n        Vector3 direction;\n        \n        if (_useMouseAiming && _playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            direction = ray.direction;\n        }\n        else\n        {\n            direction = transform.forward;\n        }\n        \n        float angleInRadians = _launchAngle * Mathf.Deg2Rad;\n        Vector3 horizontalDirection = new Vector3(direction.x, 0, direction.z).normalized;\n        direction = horizontalDirection + Vector3.up * Mathf.Tan(angleInRadians);\n        \n        return direction.normalized;\n    }\n    \n    private void PlayLaunchSound()\n    {\n        if (_audioSource != null && _launchSound != null)\n        {\n            _audioSource.PlayOneShot(_launchSound);\n        }\n    }\n}\n\npublic class NetProjectile : MonoBehaviour\n{\n    private Vector3 _velocity;\n    private LayerMask _capturableLayers;\n    private float _captureRadius;\n    private float _captureDuration;\n    private AudioClip _captureSound;\n    private bool _hasLanded;\n    private List<GameObject> _capturedObjects = new List<GameObject>();\n    private AudioSource _audioSource;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _drag = 0.1f;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private GameObject _netMesh;\n    [SerializeField] private ParticleSystem _captureEffect;\n    \n    public void Initialize(Vector3 direction, float force, LayerMask capturableLayers, float captureRadius, float captureDuration, AudioClip captureSound)\n    {\n        _velocity = direction * force;\n        _capturableLayers = capturableLayers;\n        _captureRadius = captureRadius;\n        _captureDuration = captureDuration;\n        _captureSound = captureSound;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, 10f);\n    }\n    \n    private void Update()\n    {\n        if (!_hasLanded)\n        {\n            UpdateProjectileMovement();\n            CheckGroundHit();\n        }\n    }\n    \n    private void UpdateProjectileMovement()\n    {\n        _velocity.y -= _gravity * Time.deltaTime;\n        _velocity *= (1f - _drag * Time.deltaTime);\n        transform.position += _velocity * Time.deltaTime;\n        \n        if (_velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_velocity);\n        }\n    }\n    \n    private void CheckGroundHit()\n    {\n        if (transform.position.y <= 0.1f || _velocity.y < 0 && Physics.Raycast(transform.position, Vector3.down, 0.5f))\n        {\n            LandNet();\n        }\n    }\n    \n    private void LandNet()\n    {\n        _hasLanded = true;\n        _velocity = Vector3.zero;\n        \n        if (_netMesh != null)\n        {\n            _netMesh.SetActive(true);\n            _netMesh.transform.localScale = Vector3.one * _captureRadius;\n        }\n        \n        CaptureNearbyObjects();\n        StartCoroutine(ReleaseAfterDuration());\n    }\n    \n    private void CaptureNearbyObjects()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _captureRadius, _capturableLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject != gameObject)\n            {\n                CaptureObject(col.gameObject);\n            }\n        }\n        \n        if (_capturedObjects.Count > 0)\n        {\n            PlayCaptureSound();\n            PlayCaptureEffect();\n        }\n    }\n    \n    private void CaptureObject(GameObject target)\n    {\n        if (_capturedObjects.Contains(target)) return;\n        \n        _capturedObjects.Add(target);\n        \n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.isKinematic = true;\n        }\n        \n        CapturedObject capturedComponent = target.GetComponent<CapturedObject>();\n        if (capturedComponent == null)\n            capturedComponent = target.AddComponent<CapturedObject>();\n            \n        capturedComponent.SetCaptured(true, transform.position);\n    }\n    \n    private void PlayCaptureSound()\n    {\n        if (_audioSource != null && _captureSound != null)\n        {\n            _audioSource.PlayOneShot(_captureSound);\n        }\n    }\n    \n    private void PlayCaptureEffect()\n    {\n        if (_captureEffect != null)\n        {\n            _captureEffect.Play();\n        }\n    }\n    \n    private IEnumerator ReleaseAfterDuration()\n    {\n        yield return new WaitForSeconds(_captureDuration);\n        ReleaseAllObjects();\n        Destroy(gameObject);\n    }\n    \n    private void ReleaseAllObjects()\n    {\n        foreach (GameObject capturedObj in _capturedObjects)\n        {\n            if (capturedObj != null)\n            {\n                Rigidbody rb = capturedObj.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    rb.isKinematic = false;\n                }\n                \n                CapturedObject capturedComponent = capturedObj.GetComponent<CapturedObject>();\n                if (capturedComponent != null)\n                {\n                    capturedComponent.SetCaptured(false, Vector3.zero);\n                }\n            }\n        }\n        _capturedObjects.Clear();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_hasLanded)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, _captureRadius);\n        }\n    }\n}\n\npublic class CapturedObject : MonoBehaviour\n{\n    private bool _isCaptured;\n    private Vector3 _captureCenter;\n    private Vector3 _originalPosition;\n    private Rigidbody _rigidbody;\n    \n    [Header(\"Capture Behavior\")]\n    [SerializeField] private float _pullStrength = 5f;\n    [SerializeField] private float _maxDistanceFromCenter = 2f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _originalPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        if (_isCaptured)\n        {\n            ApplyCaptureForces();\n        }\n    }\n    \n    public void SetCaptured(bool captured, Vector3 captureCenter)\n    {\n        _isCaptured = captured;\n        _captureCenter = captureCenter;\n        \n        if (!captured && _rigidbody != null)\n        {\n            _rigidbody.AddForce(Vector3.up * 2f, ForceMode.Impulse);\n        }\n    }\n    \n    private void ApplyCaptureForces()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector3 directionToCenter = (_captureCenter - transform.position);\n        float distanceToCenter = directionToCenter.magnitude;\n        \n        if (distanceToCenter > _maxDistanceFromCenter)\n        {\n            Vector3 pullForce = directionToCenter.normalized * _pullStrength;\n            _rigidbody.AddForce(pullForce, ForceMode.Force);\n        }\n        \n        _rigidbody.drag = 5f;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.drag = 0f;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "ice wand that freezes",
      "ideal_ir": {
        "class_name": "IceWand",
        "components": [
          "Transform",
          "Renderer",
          "Collider"
        ],
        "fields": [
          {
            "name": "freezeRange",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "freezeDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isOnCooldown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "cast_freeze_spell",
            "trigger": "when player presses fire button and wand is not on cooldown",
            "actions": [
              {
                "action": "create ice particle effect at wand tip"
              },
              {
                "action": "find all enemies within freeze range"
              },
              {
                "action": "freeze all found enemies for freeze duration"
              },
              {
                "action": "play ice casting sound effect"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "end_cooldown",
            "trigger": "when cooldown timer reaches cooldown time",
            "actions": [
              {
                "action": "set wand as ready to use again"
              },
              {
                "action": "play ready chime sound"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when wand is on cooldown",
            "actions": [
              {
                "action": "dim wand glow effect"
              },
              {
                "action": "show cooldown indicator"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class IceWand : MonoBehaviour\n{\n    [Header(\"Wand Settings\")]\n    [SerializeField] private float _freezeRange = 10f;\n    [SerializeField] private float _freezeDuration = 3f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private LayerMask _freezableLayer = -1;\n    [SerializeField] private KeyCode _useKey = KeyCode.Mouse0;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _freezeEffectPrefab;\n    [SerializeField] private ParticleSystem _castParticles;\n    [SerializeField] private LineRenderer _iceBeam;\n    [SerializeField] private float _beamDuration = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _freezeSound;\n    [SerializeField] private AudioClip _cooldownSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnTargetFrozen;\n    public UnityEvent OnWandUsed;\n    public UnityEvent OnCooldownComplete;\n    \n    private bool _isOnCooldown;\n    private float _cooldownTimer;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class FreezableObject\n    {\n        public Rigidbody rigidBody;\n        public Collider objectCollider;\n        public Renderer objectRenderer;\n        public Material originalMaterial;\n        public Material frozenMaterial;\n        public bool isCurrentlyFrozen;\n        public float freezeEndTime;\n        public Vector3 originalVelocity;\n        public Vector3 originalAngularVelocity;\n        public bool wasKinematic;\n        \n        public FreezableObject(GameObject obj)\n        {\n            rigidBody = obj.GetComponent<Rigidbody>();\n            objectCollider = obj.GetComponent<Collider>();\n            objectRenderer = obj.GetComponent<Renderer>();\n            \n            if (objectRenderer != null)\n            {\n                originalMaterial = objectRenderer.material;\n            }\n            \n            if (rigidBody != null)\n            {\n                wasKinematic = rigidBody.isKinematic;\n            }\n        }\n    }\n    \n    private System.Collections.Generic.List<FreezableObject> _frozenObjects = new System.Collections.Generic.List<FreezableObject>();\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_iceBeam != null)\n        {\n            _iceBeam.enabled = false;\n            _iceBeam.startWidth = 0.1f;\n            _iceBeam.endWidth = 0.05f;\n        }\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateFrozenObjects();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_useKey) && !_isOnCooldown)\n        {\n            UseWand();\n        }\n    }\n    \n    void UpdateCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownComplete?.Invoke();\n                \n                if (_audioSource != null && _cooldownSound != null)\n                    _audioSource.PlayOneShot(_cooldownSound);\n            }\n        }\n    }\n    \n    void UpdateFrozenObjects()\n    {\n        for (int i = _frozenObjects.Count - 1; i >= 0; i--)\n        {\n            var frozenObj = _frozenObjects[i];\n            \n            if (frozenObj.rigidBody == null)\n            {\n                _frozenObjects.RemoveAt(i);\n                continue;\n            }\n            \n            if (Time.time >= frozenObj.freezeEndTime)\n            {\n                UnfreezeObject(frozenObj);\n                _frozenObjects.RemoveAt(i);\n            }\n        }\n    }\n    \n    void UseWand()\n    {\n        if (_playerCamera == null) return;\n        \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _freezeRange, _freezableLayer))\n        {\n            FreezeTarget(hit.collider.gameObject, hit.point);\n            \n            if (_iceBeam != null)\n                StartCoroutine(ShowIceBeam(transform.position, hit.point));\n        }\n        \n        StartCooldown();\n        OnWandUsed?.Invoke();\n        \n        if (_castParticles != null)\n            _castParticles.Play();\n            \n        if (_audioSource != null && _freezeSound != null)\n            _audioSource.PlayOneShot(_freezeSound);\n    }\n    \n    void FreezeTarget(GameObject target, Vector3 hitPoint)\n    {\n        if (target == null) return;\n        \n        // Check if already frozen\n        foreach (var frozen in _frozenObjects)\n        {\n            if (frozen.rigidBody != null && frozen.rigidBody.gameObject == target)\n            {\n                // Extend freeze duration\n                frozen.freezeEndTime = Time.time + _freezeDuration;\n                return;\n            }\n        }\n        \n        FreezableObject freezableObj = new FreezableObject(target);\n        \n        if (freezableObj.rigidBody != null)\n        {\n            // Store current physics state\n            freezableObj.originalVelocity = freezableObj.rigidBody.velocity;\n            freezableObj.originalAngularVelocity = freezableObj.rigidBody.angularVelocity;\n            \n            // Freeze physics\n            freezableObj.rigidBody.velocity = Vector3.zero;\n            freezableObj.rigidBody.angularVelocity = Vector3.zero;\n            freezableObj.rigidBody.isKinematic = true;\n        }\n        \n        // Visual freeze effect\n        if (freezableObj.objectRenderer != null && freezableObj.frozenMaterial != null)\n        {\n            freezableObj.objectRenderer.material = freezableObj.frozenMaterial;\n        }\n        \n        // Add ice effect\n        if (_freezeEffectPrefab != null)\n        {\n            GameObject iceEffect = Instantiate(_freezeEffectPrefab, hitPoint, Quaternion.identity);\n            iceEffect.transform.SetParent(target.transform);\n            Destroy(iceEffect, _freezeDuration);\n        }\n        \n        freezableObj.isCurrentlyFrozen = true;\n        freezableObj.freezeEndTime = Time.time + _freezeDuration;\n        \n        _frozenObjects.Add(freezableObj);\n        OnTargetFrozen?.Invoke(target);\n    }\n    \n    void UnfreezeObject(FreezableObject frozenObj)\n    {\n        if (frozenObj.rigidBody == null) return;\n        \n        // Restore physics\n        frozenObj.rigidBody.isKinematic = frozenObj.wasKinematic;\n        \n        if (!frozenObj.wasKinematic)\n        {\n            frozenObj.rigidBody.velocity = frozenObj.originalVelocity * 0.5f; // Reduced momentum\n            frozenObj.rigidBody.angularVelocity = frozenObj.originalAngularVelocity * 0.5f;\n        }\n        \n        // Restore visual\n        if (frozenObj.objectRenderer != null && frozenObj.originalMaterial != null)\n        {\n            frozenObj.objectRenderer.material = frozenObj.originalMaterial;\n        }\n        \n        frozenObj.isCurrentlyFrozen = false;\n    }\n    \n    void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    System.Collections.IEnumerator ShowIceBeam(Vector3 start, Vector3 end)\n    {\n        if (_iceBeam == null) yield break;\n        \n        _iceBeam.enabled = true;\n        _iceBeam.positionCount = 2;\n        _iceBeam.SetPosition(0, start);\n        _iceBeam.SetPosition(1, end);\n        \n        yield return new WaitForSeconds(_beamDuration);\n        \n        _iceBeam.enabled = false;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (!_isOnCooldown) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n    \n    public void SetFrozenMaterial(Material frozenMat)\n    {\n        foreach (var frozen in _frozenObjects)\n        {\n            frozen.frozenMaterial = frozenMat;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera != null)\n        {\n            Gizmos.color = Color.cyan;\n            Vector3 forward = _playerCamera.transform.forward;\n            Gizmos.DrawRay(_playerCamera.transform.position, forward * _freezeRange);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fire staff that burns",
      "ideal_ir": {
        "class_name": "FireStaff",
        "components": [
          "ParticleSystem",
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "burnDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "burnDuration",
            "type": "float",
            "default": 3
          },
          {
            "name": "fireRange",
            "type": "float",
            "default": 8
          },
          {
            "name": "manaCost",
            "type": "int",
            "default": 15
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "cast_fire_spell",
            "trigger": "when player presses fire button and has enough mana and staff is not on cooldown",
            "actions": [
              {
                "action": "consume mana from player"
              },
              {
                "action": "play fire casting sound effect"
              },
              {
                "action": "create flame projectile that travels forward"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "show fire particle effects from staff tip"
              }
            ]
          },
          {
            "name": "burn_target",
            "trigger": "when flame projectile hits enemy or flammable object",
            "actions": [
              {
                "action": "apply burn damage over time to target"
              },
              {
                "action": "create burning visual effects on target"
              },
              {
                "action": "play burning sound effect"
              },
              {
                "action": "set target on fire for burn duration"
              }
            ]
          },
          {
            "name": "spread_fire",
            "trigger": "when burning target is near other flammable objects",
            "actions": [
              {
                "action": "ignite nearby flammable objects"
              },
              {
                "action": "create fire spread particle effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class FireStaff : MonoBehaviour\n{\n    [Header(\"Fire Staff Settings\")]\n    [SerializeField] private float _fireRange = 10f;\n    [SerializeField] private float _fireDamage = 25f;\n    [SerializeField] private float _burnDuration = 3f;\n    [SerializeField] private float _burnDamagePerSecond = 5f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private ParticleSystem _castEffect;\n    [SerializeField] private LineRenderer _fireBeam;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private Transform _firePoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private bool _canCast = true;\n    private Camera _playerCamera;\n    private Dictionary<GameObject, BurnEffect> _burningTargets = new Dictionary<GameObject, BurnEffect>();\n    \n    [System.Serializable]\n    public class BurnEffect\n    {\n        public float remainingTime;\n        public Coroutine burnCoroutine;\n        public ParticleSystem burnParticles;\n        \n        public BurnEffect(float duration)\n        {\n            remainingTime = duration;\n        }\n    }\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_fireBeam != null)\n        {\n            _fireBeam.enabled = false;\n            _fireBeam.startWidth = 0.1f;\n            _fireBeam.endWidth = 0.05f;\n        }\n        \n        if (_fireLight != null)\n        {\n            _fireLight.enabled = false;\n            _fireLight.color = Color.red;\n            _fireLight.intensity = 2f;\n        }\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateVisualEffects();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && _canCast)\n        {\n            CastFire();\n        }\n    }\n    \n    void CastFire()\n    {\n        if (_playerCamera == null) return;\n        \n        _canCast = false;\n        \n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        if (_firePoint != null)\n        {\n            rayOrigin = _firePoint.position;\n            rayDirection = (_playerCamera.transform.position + _playerCamera.transform.forward * _fireRange - _firePoint.position).normalized;\n        }\n        \n        RaycastHit hit;\n        Vector3 targetPoint;\n        \n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _fireRange, _targetLayers))\n        {\n            targetPoint = hit.point;\n            ProcessFireHit(hit);\n        }\n        else\n        {\n            targetPoint = rayOrigin + rayDirection * _fireRange;\n        }\n        \n        StartCoroutine(FireEffectCoroutine(rayOrigin, targetPoint));\n        StartCoroutine(CooldownCoroutine());\n        \n        PlayCastSound();\n    }\n    \n    void ProcessFireHit(RaycastHit hit)\n    {\n        GameObject target = hit.collider.gameObject;\n        \n        // Apply immediate damage\n        ApplyDamage(target, _fireDamage);\n        \n        // Apply burn effect\n        ApplyBurnEffect(target);\n        \n        PlayHitSound();\n    }\n    \n    void ApplyDamage(GameObject target, float damage)\n    {\n        // Try different common health component patterns\n        var health = target.GetComponent<MonoBehaviour>();\n        if (health != null)\n        {\n            // Use SendMessage as a fallback for unknown health systems\n            target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // If target has Rigidbody, add force\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * damage * 0.1f, ForceMode.Impulse);\n        }\n    }\n    \n    void ApplyBurnEffect(GameObject target)\n    {\n        if (_burningTargets.ContainsKey(target))\n        {\n            // Refresh burn duration\n            _burningTargets[target].remainingTime = _burnDuration;\n            return;\n        }\n        \n        BurnEffect burnEffect = new BurnEffect(_burnDuration);\n        \n        // Create burn particles\n        if (_fireParticles != null)\n        {\n            GameObject burnParticleObj = Instantiate(_fireParticles.gameObject, target.transform.position, Quaternion.identity);\n            burnEffect.burnParticles = burnParticleObj.GetComponent<ParticleSystem>();\n            burnParticleObj.transform.SetParent(target.transform);\n        }\n        \n        burnEffect.burnCoroutine = StartCoroutine(BurnCoroutine(target, burnEffect));\n        _burningTargets[target] = burnEffect;\n    }\n    \n    IEnumerator BurnCoroutine(GameObject target, BurnEffect burnEffect)\n    {\n        while (burnEffect.remainingTime > 0 && target != null)\n        {\n            ApplyDamage(target, _burnDamagePerSecond);\n            burnEffect.remainingTime -= 1f;\n            yield return new WaitForSeconds(1f);\n        }\n        \n        // Clean up\n        if (_burningTargets.ContainsKey(target))\n        {\n            if (burnEffect.burnParticles != null)\n                Destroy(burnEffect.burnParticles.gameObject);\n            _burningTargets.Remove(target);\n        }\n    }\n    \n    IEnumerator FireEffectCoroutine(Vector3 startPoint, Vector3 endPoint)\n    {\n        // Enable visual effects\n        if (_fireBeam != null)\n        {\n            _fireBeam.enabled = true;\n            _fireBeam.SetPosition(0, startPoint);\n            _fireBeam.SetPosition(1, endPoint);\n        }\n        \n        if (_fireLight != null)\n        {\n            _fireLight.enabled = true;\n        }\n        \n        if (_castEffect != null)\n        {\n            _castEffect.Play();\n        }\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        // Disable visual effects\n        if (_fireBeam != null)\n            _fireBeam.enabled = false;\n            \n        if (_fireLight != null)\n            _fireLight.enabled = false;\n    }\n    \n    IEnumerator CooldownCoroutine()\n    {\n        yield return new WaitForSeconds(_cooldownTime);\n        _canCast = true;\n    }\n    \n    void UpdateVisualEffects()\n    {\n        if (_fireParticles != null)\n        {\n            if (_canCast)\n            {\n                if (!_fireParticles.isPlaying)\n                    _fireParticles.Play();\n            }\n            else\n            {\n                if (_fireParticles.isPlaying)\n                    _fireParticles.Stop();\n            }\n        }\n    }\n    \n    void PlayCastSound()\n    {\n        if (_audioSource != null && _castSound != null)\n        {\n            _audioSource.PlayOneShot(_castSound);\n        }\n    }\n    \n    void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        // Clean up all burning effects\n        foreach (var kvp in _burningTargets)\n        {\n            if (kvp.Value.burnCoroutine != null)\n                StopCoroutine(kvp.Value.burnCoroutine);\n            if (kvp.Value.burnParticles != null)\n                Destroy(kvp.Value.burnParticles.gameObject);\n        }\n        _burningTargets.Clear();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 origin = _firePoint != null ? _firePoint.position : transform.position;\n        Vector3 direction = transform.forward;\n        \n        if (_playerCamera != null)\n            direction = _playerCamera.transform.forward;\n            \n        Gizmos.DrawRay(origin, direction * _fireRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "lightning rod that chains",
      "ideal_ir": {
        "class_name": "ChainLightningRod",
        "components": [
          "Transform",
          "Collider",
          "LineRenderer"
        ],
        "fields": [
          {
            "name": "chainRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "maxChainTargets",
            "type": "int",
            "default": 5
          },
          {
            "name": "lightningDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "chainDelay",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "activationCooldown",
            "type": "float",
            "default": 3
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentCooldown",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "detect_lightning_trigger",
            "trigger": "when enemy enters trigger area and cooldown is finished",
            "actions": [
              {
                "action": "activate lightning rod"
              },
              {
                "action": "find nearest enemy as first target"
              },
              {
                "action": "start chain lightning sequence"
              }
            ]
          },
          {
            "name": "chain_to_next_target",
            "trigger": "when lightning hits current target and chain count is below maximum",
            "actions": [
              {
                "action": "deal damage to current target"
              },
              {
                "action": "create lightning visual effect to current target"
              },
              {
                "action": "find nearest unchained enemy within chain range"
              },
              {
                "action": "wait for chain delay duration"
              },
              {
                "action": "jump lightning to next target"
              }
            ]
          },
          {
            "name": "end_chain_sequence",
            "trigger": "when no more valid targets found or maximum chains reached",
            "actions": [
              {
                "action": "deal damage to final target"
              },
              {
                "action": "clear all lightning visual effects"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "deactivate lightning rod"
              }
            ]
          },
          {
            "name": "update_cooldown",
            "trigger": "every frame when cooldown is active",
            "actions": [
              {
                "action": "reduce cooldown timer"
              },
              {
                "action": "mark as ready when cooldown reaches zero"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class LightningRod : MonoBehaviour\n{\n    [Header(\"Lightning Settings\")]\n    [SerializeField] private float _detectionRadius = 15f;\n    [SerializeField] private float _chainRadius = 8f;\n    [SerializeField] private int _maxChainTargets = 5;\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string[] _targetTags = { \"Enemy\", \"Player\" };\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _lightningPrefab;\n    [SerializeField] private ParticleSystem _strikeEffect;\n    [SerializeField] private ParticleSystem _chainEffect;\n    [SerializeField] private float _lightningDuration = 0.3f;\n    [SerializeField] private Color _lightningColor = Color.cyan;\n    [SerializeField] private AnimationCurve _lightningWidth = AnimationCurve.Linear(0f, 0.2f, 1f, 0.05f);\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _lightningSound;\n    [SerializeField] private AudioClip _chainSound;\n\n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _autoTrigger = true;\n    [SerializeField] private float _autoTriggerInterval = 3f;\n    [SerializeField] private bool _triggerOnPlayerEnter = true;\n\n    private float _lastStrikeTime;\n    private List<GameObject> _activeTargets = new List<GameObject>();\n    private List<LineRenderer> _activeLightning = new List<LineRenderer>();\n    private Coroutine _lightningCoroutine;\n\n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_autoTrigger)\n            InvokeRepeating(nameof(TriggerLightning), _autoTriggerInterval, _autoTriggerInterval);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerOnPlayerEnter) return;\n        \n        if (other.CompareTag(\"Player\") && CanStrike())\n        {\n            TriggerLightning();\n        }\n    }\n\n    public void TriggerLightning()\n    {\n        if (!CanStrike()) return;\n\n        GameObject primaryTarget = FindPrimaryTarget();\n        if (primaryTarget == null) return;\n\n        _lastStrikeTime = Time.time;\n        \n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        _lightningCoroutine = StartCoroutine(ExecuteLightningChain(primaryTarget));\n    }\n\n    private bool CanStrike()\n    {\n        return Time.time >= _lastStrikeTime + _cooldownTime;\n    }\n\n    private GameObject FindPrimaryTarget()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayers);\n        GameObject closestTarget = null;\n        float closestDistance = float.MaxValue;\n\n        foreach (Collider col in colliders)\n        {\n            if (IsValidTarget(col.gameObject))\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = col.gameObject;\n                }\n            }\n        }\n\n        return closestTarget;\n    }\n\n    private bool IsValidTarget(GameObject target)\n    {\n        if (target == gameObject) return false;\n\n        foreach (string tag in _targetTags)\n        {\n            if (target.CompareTag(tag))\n                return true;\n        }\n        return false;\n    }\n\n    private IEnumerator ExecuteLightningChain(GameObject primaryTarget)\n    {\n        ClearActiveLightning();\n        _activeTargets.Clear();\n\n        List<GameObject> chainTargets = new List<GameObject> { primaryTarget };\n        GameObject currentTarget = primaryTarget;\n\n        // Build chain\n        for (int i = 0; i < _maxChainTargets - 1; i++)\n        {\n            GameObject nextTarget = FindNextChainTarget(currentTarget, chainTargets);\n            if (nextTarget == null) break;\n            \n            chainTargets.Add(nextTarget);\n            currentTarget = nextTarget;\n        }\n\n        // Create lightning visuals\n        Vector3 startPos = transform.position;\n        for (int i = 0; i < chainTargets.Count; i++)\n        {\n            Vector3 endPos = chainTargets[i].transform.position;\n            CreateLightningBolt(startPos, endPos, i == 0);\n            \n            if (i < chainTargets.Count - 1)\n            {\n                startPos = endPos;\n            }\n        }\n\n        // Apply damage and effects\n        foreach (GameObject target in chainTargets)\n        {\n            ApplyLightningDamage(target);\n            CreateStrikeEffect(target.transform.position);\n        }\n\n        // Play audio\n        PlayLightningAudio();\n\n        // Wait for lightning duration\n        yield WaitForSeconds(_lightningDuration);\n\n        // Clean up\n        ClearActiveLightning();\n    }\n\n    private GameObject FindNextChainTarget(GameObject currentTarget, List<GameObject> excludeTargets)\n    {\n        Collider[] colliders = Physics.OverlapSphere(currentTarget.transform.position, _chainRadius, _targetLayers);\n        GameObject bestTarget = null;\n        float closestDistance = float.MaxValue;\n\n        foreach (Collider col in colliders)\n        {\n            GameObject target = col.gameObject;\n            \n            if (!IsValidTarget(target) || excludeTargets.Contains(target))\n                continue;\n\n            float distance = Vector3.Distance(currentTarget.transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                bestTarget = target;\n            }\n        }\n\n        return bestTarget;\n    }\n\n    private void CreateLightningBolt(Vector3 startPos, Vector3 endPos, bool isPrimary)\n    {\n        if (_lightningPrefab == null) return;\n\n        LineRenderer lightning = Instantiate(_lightningPrefab);\n        lightning.positionCount = 2;\n        lightning.SetPosition(0, startPos);\n        lightning.SetPosition(1, endPos);\n        lightning.color = _lightningColor;\n        lightning.widthCurve = _lightningWidth;\n        lightning.material.color = _lightningColor;\n\n        _activeLightning.Add(lightning);\n    }\n\n    private void ApplyLightningDamage(GameObject target)\n    {\n        // Try different damage interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - common Unity pattern\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"OnLightningStrike\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n\n        // Alternative: Use Rigidbody for physics impact\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * _damage * 10f, ForceMode.Impulse);\n        }\n    }\n\n    private void CreateStrikeEffect(Vector3 position)\n    {\n        if (_strikeEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_strikeEffect);\n            effect.transform.position = position;\n            effect.Play();\n            Destroy(effect.gameObject, effect.main.duration + effect.main.startLifetime.constantMax);\n        }\n\n        if (_chainEffect != null)\n        {\n            ParticleSystem chain = Instantiate(_chainEffect);\n            chain.transform.position = position;\n            chain.Play();\n            Destroy(chain.gameObject, chain.main.duration + chain.main.startLifetime.constantMax);\n        }\n    }\n\n    private void PlayLightningAudio()\n    {\n        if (_audioSource != null && _lightningSound != null)\n        {\n            _audioSource.PlayOneShot(_lightningSound);\n        }\n\n        if (_audioSource != null && _chainSound != null && _activeTargets.Count > 1)\n        {\n            _audioSource.PlayOneShot(_chainSound);\n        }\n    }\n\n    private void ClearActiveLightning()\n    {\n        foreach (LineRenderer lightning in _activeLightning)\n        {\n            if (lightning != null)\n                Destroy(lightning.gameObject);\n        }\n        _activeLightning.Clear();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _chainRadius);\n    }\n\n    private void OnDestroy()\n    {\n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        ClearActiveLightning();\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "gravity gun that pulls objects",
      "ideal_ir": {
        "class_name": "GravityGun",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "pullForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "maxRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "holdDistance",
            "type": "float",
            "default": 3
          },
          {
            "name": "targetObject",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isHolding",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "grab_object",
            "trigger": "when fire button is pressed and no object is being held",
            "actions": [
              {
                "action": "cast ray forward from gun position"
              },
              {
                "action": "find nearest grabbable object within max range"
              },
              {
                "action": "set that object as target object"
              },
              {
                "action": "mark as holding object"
              }
            ]
          },
          {
            "name": "pull_object",
            "trigger": "when holding an object and object is far from hold position",
            "actions": [
              {
                "action": "apply pull force toward hold position in front of gun"
              },
              {
                "action": "reduce object gravity while being pulled"
              }
            ]
          },
          {
            "name": "maintain_hold",
            "trigger": "when holding an object and object is at hold position",
            "actions": [
              {
                "action": "keep object floating at hold distance from gun"
              },
              {
                "action": "rotate object to face same direction as gun"
              }
            ]
          },
          {
            "name": "release_object",
            "trigger": "when fire button is released while holding object",
            "actions": [
              {
                "action": "restore normal gravity to held object"
              },
              {
                "action": "clear target object reference"
              },
              {
                "action": "mark as not holding object"
              }
            ]
          },
          {
            "name": "launch_object",
            "trigger": "when secondary fire button is pressed while holding object",
            "actions": [
              {
                "action": "apply strong forward force to held object"
              },
              {
                "action": "restore normal gravity to object"
              },
              {
                "action": "clear target object reference"
              },
              {
                "action": "mark as not holding object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GravityGun : MonoBehaviour\n{\n    [Header(\"Gravity Gun Settings\")]\n    [SerializeField] private float _pullForce = 10f;\n    [SerializeField] private float _maxRange = 15f;\n    [SerializeField] private float _holdDistance = 3f;\n    [SerializeField] private LayerMask _pullableLayers = -1;\n    [SerializeField] private float _pullSpeed = 5f;\n    [SerializeField] private float _rotationDamping = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _pullKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Mouse1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _beamRenderer;\n    [SerializeField] private Transform _holdPoint;\n    [SerializeField] private ParticleSystem _pullEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pullSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectGrabbed;\n    public UnityEvent<GameObject> OnObjectReleased;\n    \n    private Camera _playerCamera;\n    private Rigidbody _heldObject;\n    private Transform _heldTransform;\n    private bool _isPulling;\n    private Vector3 _originalGravity;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    private bool _wasKinematic;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_holdPoint == null)\n        {\n            GameObject holdPointObj = new GameObject(\"HoldPoint\");\n            holdPointObj.transform.SetParent(transform);\n            holdPointObj.transform.localPosition = Vector3.forward * _holdDistance;\n            _holdPoint = holdPointObj.transform;\n        }\n        \n        if (_beamRenderer != null)\n        {\n            _beamRenderer.enabled = false;\n            _beamRenderer.positionCount = 2;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateHeldObject();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_pullKey))\n        {\n            if (_heldObject == null)\n                TryGrabObject();\n        }\n        \n        if (Input.GetKeyUp(_pullKey) || Input.GetKeyDown(_releaseKey))\n        {\n            if (_heldObject != null)\n                ReleaseObject();\n        }\n    }\n    \n    private void TryGrabObject()\n    {\n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        \n        if (Physics.Raycast(ray, out RaycastHit hit, _maxRange, _pullableLayers))\n        {\n            Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n            \n            if (targetRb != null && !targetRb.isKinematic)\n            {\n                GrabObject(targetRb);\n            }\n        }\n    }\n    \n    private void GrabObject(Rigidbody target)\n    {\n        _heldObject = target;\n        _heldTransform = target.transform;\n        _isPulling = true;\n        \n        // Store original physics properties\n        _originalDrag = _heldObject.drag;\n        _originalAngularDrag = _heldObject.angularDrag;\n        _wasKinematic = _heldObject.isKinematic;\n        \n        // Modify physics for better control\n        _heldObject.drag = 10f;\n        _heldObject.angularDrag = 10f;\n        _heldObject.useGravity = false;\n        \n        // Play effects\n        PlaySound(_pullSound);\n        if (_pullEffect != null)\n            _pullEffect.Play();\n            \n        OnObjectGrabbed?.Invoke(_heldObject.gameObject);\n    }\n    \n    private void ReleaseObject()\n    {\n        if (_heldObject != null)\n        {\n            // Restore original physics properties\n            _heldObject.drag = _originalDrag;\n            _heldObject.angularDrag = _originalAngularDrag;\n            _heldObject.useGravity = true;\n            _heldObject.isKinematic = _wasKinematic;\n            \n            GameObject releasedObject = _heldObject.gameObject;\n            \n            _heldObject = null;\n            _heldTransform = null;\n            _isPulling = false;\n            \n            // Play effects\n            PlaySound(_releaseSound);\n            if (_pullEffect != null)\n                _pullEffect.Stop();\n                \n            OnObjectReleased?.Invoke(releasedObject);\n        }\n    }\n    \n    private void UpdateHeldObject()\n    {\n        if (_heldObject == null || _holdPoint == null) return;\n        \n        Vector3 targetPosition = _holdPoint.position;\n        Vector3 direction = targetPosition - _heldTransform.position;\n        float distance = direction.magnitude;\n        \n        // Apply force to move object to hold position\n        if (distance > 0.1f)\n        {\n            Vector3 force = direction.normalized * _pullForce * distance;\n            _heldObject.AddForce(force, ForceMode.Force);\n        }\n        \n        // Dampen rotation for stability\n        if (_heldObject.angularVelocity.magnitude > 0.1f)\n        {\n            _heldObject.angularVelocity = Vector3.Lerp(_heldObject.angularVelocity, Vector3.zero, Time.deltaTime * _rotationDamping);\n        }\n        \n        // Limit velocity to prevent objects from flying away\n        if (_heldObject.velocity.magnitude > 20f)\n        {\n            _heldObject.velocity = _heldObject.velocity.normalized * 20f;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_beamRenderer != null)\n        {\n            if (_isPulling && _heldObject != null)\n            {\n                _beamRenderer.enabled = true;\n                _beamRenderer.SetPosition(0, transform.position);\n                _beamRenderer.SetPosition(1, _heldTransform.position);\n            }\n            else\n            {\n                _beamRenderer.enabled = false;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw max range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxRange);\n        \n        // Draw hold point\n        if (_holdPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPoint.position, 0.2f);\n        }\n        \n        // Draw line to held object\n        if (_heldObject != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _heldObject.transform.position);\n        }\n    }\n    \n    public void SetPullForce(float force)\n    {\n        _pullForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetMaxRange(float range)\n    {\n        _maxRange = Mathf.Max(0f, range);\n    }\n    \n    public bool IsHoldingObject()\n    {\n        return _heldObject != null;\n    }\n    \n    public GameObject GetHeldObject()\n    {\n        return _heldObject != null ? _heldObject.gameObject : null;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "roll dodge with invincibility frames",
      "ideal_ir": {
        "class_name": "RollDodge",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "rollSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "rollDuration",
            "type": "float",
            "default": 0.6
          },
          {
            "name": "invincibilityDuration",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "rollCooldown",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isRolling",
            "type": "bool",
            "default": false
          },
          {
            "name": "isInvincible",
            "type": "bool",
            "default": false
          },
          {
            "name": "canRoll",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "initiate_roll",
            "trigger": "when dodge input is pressed and can roll and not currently rolling",
            "actions": [
              {
                "action": "set rolling state to true"
              },
              {
                "action": "set can roll to false"
              },
              {
                "action": "get movement input direction"
              },
              {
                "action": "if no input direction use forward direction"
              },
              {
                "action": "play roll animation"
              },
              {
                "action": "start roll movement in chosen direction at roll speed"
              }
            ]
          },
          {
            "name": "roll_movement",
            "trigger": "while rolling state is active",
            "actions": [
              {
                "action": "continue moving in roll direction at roll speed"
              },
              {
                "action": "ignore normal movement input"
              },
              {
                "action": "maintain roll animation"
              }
            ]
          },
          {
            "name": "start_invincibility",
            "trigger": "when roll begins",
            "actions": [
              {
                "action": "set invincible state to true"
              },
              {
                "action": "make character visually flash or transparent"
              },
              {
                "action": "ignore all damage and collision effects"
              }
            ]
          },
          {
            "name": "maintain_invincibility",
            "trigger": "while invincible state is active",
            "actions": [
              {
                "action": "block all incoming damage"
              },
              {
                "action": "continue visual invincibility effect"
              },
              {
                "action": "pass through enemy attacks"
              }
            ]
          },
          {
            "name": "end_roll",
            "trigger": "when roll duration time has elapsed",
            "actions": [
              {
                "action": "set rolling state to false"
              },
              {
                "action": "stop roll movement"
              },
              {
                "action": "return to idle or movement animation"
              },
              {
                "action": "restore normal movement control"
              }
            ]
          },
          {
            "name": "end_invincibility",
            "trigger": "when invincibility duration time has elapsed",
            "actions": [
              {
                "action": "set invincible state to false"
              },
              {
                "action": "stop visual invincibility effect"
              },
              {
                "action": "restore normal damage reception"
              },
              {
                "action": "restore normal collision behavior"
              }
            ]
          },
          {
            "name": "reset_cooldown",
            "trigger": "when roll cooldown time has elapsed",
            "actions": [
              {
                "action": "set can roll to true"
              },
              {
                "action": "allow dodge input to trigger new roll"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RollDodge : MonoBehaviour\n{\n    [Header(\"Roll Settings\")]\n    [SerializeField] private float _rollDistance = 5f;\n    [SerializeField] private float _rollDuration = 0.5f;\n    [SerializeField] private float _rollCooldown = 1f;\n    [SerializeField] private KeyCode _rollKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseDirection = false;\n    \n    [Header(\"Invincibility Settings\")]\n    [SerializeField] private float _invincibilityDuration = 0.6f;\n    [SerializeField] private int _flashCount = 6;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private float _capsuleRadius = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRollStart;\n    public UnityEvent OnRollEnd;\n    public UnityEvent OnInvincibilityStart;\n    public UnityEvent OnInvincibilityEnd;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Renderer _renderer;\n    private Camera _camera;\n    \n    private bool _isRolling = false;\n    private bool _isInvincible = false;\n    private bool _canRoll = true;\n    private float _rollTimer = 0f;\n    private float _invincibilityTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Vector3 _rollDirection;\n    private Vector3 _startPosition;\n    private Vector3 _targetPosition;\n    private Color _originalColor;\n    private bool _flashVisible = true;\n    private float _flashTimer = 0f;\n    private float _flashInterval;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _camera = Camera.main;\n        \n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        _flashInterval = _invincibilityDuration / (_flashCount * 2);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateRoll();\n        UpdateInvincibility();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_rollKey) && _canRoll && !_isRolling)\n        {\n            StartRoll();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canRoll)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canRoll = true;\n            }\n        }\n    }\n    \n    private void UpdateRoll()\n    {\n        if (!_isRolling) return;\n        \n        _rollTimer += Time.deltaTime;\n        float progress = _rollTimer / _rollDuration;\n        \n        if (progress >= 1f)\n        {\n            EndRoll();\n            return;\n        }\n        \n        Vector3 currentPosition = Vector3.Lerp(_startPosition, _targetPosition, progress);\n        transform.position = currentPosition;\n    }\n    \n    private void UpdateInvincibility()\n    {\n        if (!_isInvincible) return;\n        \n        _invincibilityTimer -= Time.deltaTime;\n        if (_invincibilityTimer <= 0f)\n        {\n            EndInvincibility();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (!_isInvincible || _renderer == null) return;\n        \n        _flashTimer += Time.deltaTime;\n        if (_flashTimer >= _flashInterval)\n        {\n            _flashTimer = 0f;\n            _flashVisible = !_flashVisible;\n            \n            Color targetColor = _flashVisible ? _originalColor : new Color(_originalColor.r, _originalColor.g, _originalColor.b, 0.3f);\n            _renderer.material.color = targetColor;\n        }\n    }\n    \n    private void StartRoll()\n    {\n        _rollDirection = GetRollDirection();\n        if (_rollDirection == Vector3.zero) return;\n        \n        Vector3 targetPos = transform.position + _rollDirection * _rollDistance;\n        \n        if (IsPathBlocked(transform.position, targetPos))\n        {\n            targetPos = GetSafeRollPosition(transform.position, _rollDirection);\n        }\n        \n        _startPosition = transform.position;\n        _targetPosition = targetPos;\n        _rollTimer = 0f;\n        _isRolling = true;\n        _canRoll = false;\n        _cooldownTimer = _rollCooldown;\n        \n        StartInvincibility();\n        OnRollStart?.Invoke();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n        }\n    }\n    \n    private void EndRoll()\n    {\n        _isRolling = false;\n        transform.position = _targetPosition;\n        OnRollEnd?.Invoke();\n    }\n    \n    private void StartInvincibility()\n    {\n        _isInvincible = true;\n        _invincibilityTimer = _invincibilityDuration;\n        _flashTimer = 0f;\n        _flashVisible = true;\n        OnInvincibilityStart?.Invoke();\n        \n        if (_collider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), true);\n        }\n    }\n    \n    private void EndInvincibility()\n    {\n        _isInvincible = false;\n        OnInvincibilityEnd?.Invoke();\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = _originalColor;\n        }\n        \n        if (_collider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), false);\n        }\n    }\n    \n    private Vector3 GetRollDirection()\n    {\n        Vector3 direction = Vector3.zero;\n        \n        if (_useMouseDirection && _camera != null)\n        {\n            Vector3 mousePos = Input.mousePosition;\n            mousePos.z = _camera.WorldToScreenPoint(transform.position).z;\n            Vector3 worldMousePos = _camera.ScreenToWorldPoint(mousePos);\n            direction = (worldMousePos - transform.position).normalized;\n            direction.y = 0f;\n        }\n        else\n        {\n            float horizontal = Input.GetAxisRaw(\"Horizontal\");\n            float vertical = Input.GetAxisRaw(\"Vertical\");\n            direction = new Vector3(horizontal, 0f, vertical).normalized;\n            \n            if (direction == Vector3.zero)\n            {\n                direction = transform.forward;\n            }\n        }\n        \n        return direction;\n    }\n    \n    private bool IsPathBlocked(Vector3 start, Vector3 end)\n    {\n        Vector3 direction = (end - start).normalized;\n        float distance = Vector3.Distance(start, end);\n        \n        return Physics.CapsuleCast(\n            start + Vector3.up * _capsuleRadius,\n            start + Vector3.up * (GetComponent<Collider>().bounds.size.y - _capsuleRadius),\n            _capsuleRadius,\n            direction,\n            distance,\n            _obstacleLayer\n        );\n    }\n    \n    private Vector3 GetSafeRollPosition(Vector3 start, Vector3 direction)\n    {\n        float maxDistance = _rollDistance;\n        float stepSize = 0.5f;\n        \n        for (float distance = maxDistance; distance > stepSize; distance -= stepSize)\n        {\n            Vector3 testPosition = start + direction * distance;\n            \n            if (!IsPathBlocked(start, testPosition))\n            {\n                return testPosition;\n            }\n        }\n        \n        return start;\n    }\n    \n    public bool IsInvincible()\n    {\n        return _isInvincible;\n    }\n    \n    public bool IsRolling()\n    {\n        return _isRolling;\n    }\n    \n    public bool CanRoll()\n    {\n        return _canRoll && !_isRolling;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInvincible && other.CompareTag(\"Enemy\"))\n        {\n            return;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isInvincible && collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            Physics.IgnoreCollision(_collider, collision.collider, true);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "parry that reflects attacks",
      "ideal_ir": {
        "class_name": "ParryReflector",
        "components": [
          "Collider",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "parryWindow",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "reflectionForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "parryActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_parry",
            "trigger": "when parry input is pressed",
            "actions": [
              {
                "action": "set parry state to active"
              },
              {
                "action": "start parry window timer"
              }
            ]
          },
          {
            "name": "deactivate_parry",
            "trigger": "when parry window timer expires",
            "actions": [
              {
                "action": "set parry state to inactive"
              }
            ]
          },
          {
            "name": "reflect_attack",
            "trigger": "when attack collides during active parry window",
            "actions": [
              {
                "action": "reverse attack direction"
              },
              {
                "action": "apply reflection force to attacking object"
              },
              {
                "action": "redirect attack back toward attacker"
              },
              {
                "action": "deactivate parry state"
              }
            ]
          },
          {
            "name": "parry_feedback",
            "trigger": "when attack is successfully reflected",
            "actions": [
              {
                "action": "play parry sound effect"
              },
              {
                "action": "show visual parry effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ParrySystem : MonoBehaviour\n{\n    [Header(\"Parry Settings\")]\n    [SerializeField] private float _parryWindow = 0.5f;\n    [SerializeField] private float _parryCooldown = 1f;\n    [SerializeField] private KeyCode _parryKey = KeyCode.Q;\n    [SerializeField] private float _reflectionForce = 20f;\n    [SerializeField] private LayerMask _projectileLayer = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _parryEffectPrefab;\n    [SerializeField] private float _effectDuration = 0.3f;\n    [SerializeField] private Color _parryColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _parrySound;\n    [SerializeField] private AudioClip _reflectSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnParryActivated;\n    public UnityEvent OnSuccessfulParry;\n    public UnityEvent OnParryFailed;\n    \n    private bool _isParrying = false;\n    private bool _canParry = true;\n    private float _parryTimer = 0f;\n    private AudioSource _audioSource;\n    private SpriteRenderer _spriteRenderer;\n    private Color _originalColor;\n    private Collider2D _collider;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        if (_spriteRenderer != null)\n            _originalColor = _spriteRenderer.color;\n            \n        _collider = GetComponent<Collider2D>();\n        if (_collider == null)\n            _collider = gameObject.AddComponent<CircleCollider2D>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateParryState();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_parryKey) && _canParry)\n        {\n            StartParry();\n        }\n    }\n    \n    private void UpdateParryState()\n    {\n        if (_isParrying)\n        {\n            _parryTimer -= Time.deltaTime;\n            if (_parryTimer <= 0f)\n            {\n                EndParry();\n            }\n        }\n    }\n    \n    private void StartParry()\n    {\n        _isParrying = true;\n        _parryTimer = _parryWindow;\n        \n        if (_spriteRenderer != null)\n            _spriteRenderer.color = _parryColor;\n            \n        if (_parryEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_parryEffectPrefab, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n        \n        if (_parrySound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_parrySound);\n            \n        OnParryActivated?.Invoke();\n        \n        StartCoroutine(ParryCooldownCoroutine());\n    }\n    \n    private void EndParry()\n    {\n        _isParrying = false;\n        \n        if (_spriteRenderer != null)\n            _spriteRenderer.color = _originalColor;\n    }\n    \n    private IEnumerator ParryCooldownCoroutine()\n    {\n        _canParry = false;\n        yield return new WaitForSeconds(_parryCooldown);\n        _canParry = true;\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (_isParrying && IsProjectile(other))\n        {\n            ReflectProjectile(other);\n        }\n    }\n    \n    private bool IsProjectile(Collider2D other)\n    {\n        return (_projectileLayer.value & (1 << other.gameObject.layer)) > 0 ||\n               other.CompareTag(\"Projectile\") ||\n               other.GetComponent<Rigidbody2D>() != null;\n    }\n    \n    private void ReflectProjectile(Collider2D projectile)\n    {\n        Rigidbody2D projectileRb = projectile.GetComponent<Rigidbody2D>();\n        if (projectileRb == null)\n            projectileRb = projectile.gameObject.AddComponent<Rigidbody2D>();\n            \n        Vector2 reflectionDirection = CalculateReflectionDirection(projectile.transform.position);\n        projectileRb.velocity = reflectionDirection * _reflectionForce;\n        \n        // Change projectile ownership/layer to avoid hitting player\n        if (projectile.gameObject.layer != LayerMask.NameToLayer(\"PlayerProjectile\"))\n        {\n            projectile.gameObject.layer = LayerMask.NameToLayer(\"PlayerProjectile\");\n        }\n        \n        // Flip projectile tag if it exists\n        if (projectile.CompareTag(\"EnemyProjectile\"))\n            projectile.tag = \"PlayerProjectile\";\n            \n        if (_reflectSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_reflectSound);\n            \n        OnSuccessfulParry?.Invoke();\n        \n        // Add visual effect at reflection point\n        if (_parryEffectPrefab != null)\n        {\n            GameObject reflectEffect = Instantiate(_parryEffectPrefab, projectile.transform.position, Quaternion.identity);\n            Destroy(reflectEffect, _effectDuration);\n        }\n    }\n    \n    private Vector2 CalculateReflectionDirection(Vector3 projectilePosition)\n    {\n        Vector2 incomingDirection = (projectilePosition - transform.position).normalized;\n        Vector2 normal = -incomingDirection;\n        Vector2 reflectedDirection = Vector2.Reflect(incomingDirection, normal);\n        \n        return reflectedDirection;\n    }\n    \n    public bool IsCurrentlyParrying()\n    {\n        return _isParrying;\n    }\n    \n    public bool CanParry()\n    {\n        return _canParry;\n    }\n    \n    public float GetParryTimeRemaining()\n    {\n        return _isParrying ? _parryTimer : 0f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_isParrying)\n        {\n            Gizmos.color = _parryColor;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "block with shield",
      "ideal_ir": {
        "class_name": "ShieldBlock",
        "components": [
          "Rigidbody",
          "Collider",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "shieldHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "maxShieldHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "shieldRegenRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "shieldRegenDelay",
            "type": "float",
            "default": 3
          },
          {
            "name": "isShieldActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "absorb_damage",
            "trigger": "when projectile or attack hits this block",
            "actions": [
              {
                "action": "reduce shield health by damage amount"
              },
              {
                "action": "create shield impact visual effect at hit point"
              },
              {
                "action": "play shield hit sound"
              },
              {
                "action": "prevent damage from passing through to block"
              }
            ]
          },
          {
            "name": "shield_break",
            "trigger": "when shield health reaches zero",
            "actions": [
              {
                "action": "deactivate shield protection"
              },
              {
                "action": "change block material to damaged appearance"
              },
              {
                "action": "play shield break sound and particle effect"
              },
              {
                "action": "start shield regeneration timer"
              }
            ]
          },
          {
            "name": "regenerate_shield",
            "trigger": "when shield regeneration delay time has passed and shield is broken",
            "actions": [
              {
                "action": "gradually restore shield health over time"
              },
              {
                "action": "play shield charging sound"
              },
              {
                "action": "show shield regeneration visual effect"
              }
            ]
          },
          {
            "name": "reactivate_shield",
            "trigger": "when shield health is fully restored",
            "actions": [
              {
                "action": "activate shield protection"
              },
              {
                "action": "restore block material to normal appearance"
              },
              {
                "action": "play shield activation sound"
              },
              {
                "action": "show shield reactivation glow effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ShieldBlock : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _shieldHealth = 100f;\n    [SerializeField] private float _maxShieldHealth = 100f;\n    [SerializeField] private float _regenRate = 10f;\n    [SerializeField] private float _regenDelay = 2f;\n    [SerializeField] private bool _canRegenerate = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldEffect;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _damagedMaterial;\n    [SerializeField] private Color _shieldColor = Color.blue;\n    [SerializeField] private AnimationCurve _damageFeedbackCurve = AnimationCurve.EaseInOut(0f, 1f, 0.3f, 0f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private AudioClip _regenSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnShieldHit;\n    public UnityEvent OnShieldBroken;\n    public UnityEvent OnShieldRestored;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private float _lastDamageTime;\n    private bool _isShieldActive = true;\n    private float _damageEffectTime;\n    private Color _originalColor;\n    private bool _isRegenerating;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupShield();\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n    }\n    \n    private void SetupShield()\n    {\n        _shieldHealth = _maxShieldHealth;\n        UpdateShieldVisuals();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(_isShieldActive);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleShieldRegeneration();\n        HandleDamageEffect();\n    }\n    \n    private void HandleShieldRegeneration()\n    {\n        if (!_canRegenerate || _isShieldActive) return;\n        \n        if (Time.time - _lastDamageTime >= _regenDelay)\n        {\n            if (!_isRegenerating)\n            {\n                _isRegenerating = true;\n                PlaySound(_regenSound);\n            }\n            \n            _shieldHealth += _regenRate * Time.deltaTime;\n            _shieldHealth = Mathf.Clamp(_shieldHealth, 0f, _maxShieldHealth);\n            \n            if (_shieldHealth >= _maxShieldHealth)\n            {\n                RestoreShield();\n            }\n            \n            UpdateShieldVisuals();\n        }\n    }\n    \n    private void HandleDamageEffect()\n    {\n        if (_damageEffectTime > 0f)\n        {\n            _damageEffectTime -= Time.deltaTime;\n            \n            if (_renderer != null && _damagedMaterial != null)\n            {\n                float effectStrength = _damageFeedbackCurve.Evaluate(1f - (_damageEffectTime / 0.3f));\n                Color currentColor = Color.Lerp(_originalColor, Color.red, effectStrength);\n                _renderer.material.color = currentColor;\n            }\n            \n            if (_damageEffectTime <= 0f)\n            {\n                ResetVisualEffects();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.collider);\n    }\n    \n    private void HandleCollision(Collider other)\n    {\n        if (!_isShieldActive) return;\n        \n        float damage = CalculateDamage(other);\n        if (damage > 0f)\n        {\n            TakeDamage(damage);\n        }\n    }\n    \n    private float CalculateDamage(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            return 0f; // Don't damage shield from player contact\n        }\n        \n        if (other.CompareTag(\"Enemy\"))\n        {\n            return 25f;\n        }\n        \n        // Check for projectiles or other damaging objects\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            float velocity = rb.velocity.magnitude;\n            return Mathf.Clamp(velocity * 2f, 5f, 50f);\n        }\n        \n        return 10f; // Default damage\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (!_isShieldActive) return;\n        \n        _shieldHealth -= damage;\n        _shieldHealth = Mathf.Max(_shieldHealth, 0f);\n        _lastDamageTime = Time.time;\n        _isRegenerating = false;\n        \n        TriggerDamageEffect();\n        PlaySound(_hitSound);\n        OnShieldHit?.Invoke();\n        \n        if (_shieldHealth <= 0f)\n        {\n            BreakShield();\n        }\n        else\n        {\n            UpdateShieldVisuals();\n        }\n    }\n    \n    private void TriggerDamageEffect()\n    {\n        _damageEffectTime = 0.3f;\n    }\n    \n    private void BreakShield()\n    {\n        _isShieldActive = false;\n        _isRegenerating = false;\n        \n        UpdateShieldVisuals();\n        PlaySound(_breakSound);\n        OnShieldBroken?.Invoke();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(false);\n        }\n        \n        // Disable collision while shield is down\n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void RestoreShield()\n    {\n        _isShieldActive = true;\n        _isRegenerating = false;\n        _shieldHealth = _maxShieldHealth;\n        \n        UpdateShieldVisuals();\n        OnShieldRestored?.Invoke();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(true);\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void UpdateShieldVisuals()\n    {\n        if (_renderer == null) return;\n        \n        if (_isShieldActive)\n        {\n            float healthPercent = _shieldHealth / _maxShieldHealth;\n            Color shieldColor = Color.Lerp(Color.red, _shieldColor, healthPercent);\n            shieldColor.a = Mathf.Lerp(0.3f, 0.8f, healthPercent);\n            \n            if (_normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n                _renderer.material.color = shieldColor;\n            }\n        }\n        else\n        {\n            if (_damagedMaterial != null)\n            {\n                _renderer.material = _damagedMaterial;\n            }\n            else if (_renderer.material != null)\n            {\n                Color brokenColor = _originalColor;\n                brokenColor.a = 0.2f;\n                _renderer.material.color = brokenColor;\n            }\n        }\n    }\n    \n    private void ResetVisualEffects()\n    {\n        if (_renderer != null)\n        {\n            if (_isShieldActive && _normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n                UpdateShieldVisuals();\n            }\n            else\n            {\n                _renderer.material.color = _originalColor;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    public void SetShieldHealth(float health)\n    {\n        _shieldHealth = Mathf.Clamp(health, 0f, _maxShieldHealth);\n        \n        if (_shieldHealth > 0f && !_isShieldActive)\n        {\n            RestoreShield();\n        }\n        else if (_shieldHealth <= 0f && _isShieldActive)\n        {\n            BreakShield();\n        }\n        else\n        {\n            UpdateShieldVisuals();\n        }\n    }\n    \n    public float GetShieldHealth()\n    {\n        return _shieldHealth;\n    }\n    \n    public float GetShieldHealthPercent()\n    {\n        return _shieldHealth / _maxShieldHealth;\n    }\n    \n    public bool IsShieldActive()\n    {\n        return _isShieldActive;\n    }\n    \n    public void ForceBreakShield()\n    {\n        _shieldHealth = 0f;\n        BreakShield();\n    }\n    \n    public void ForceRestoreShield()\n    {\n        RestoreShield();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "charge attack with hold",
      "ideal_ir": {
        "class_name": "ChargeAttack",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "chargeSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "chargeDamage",
            "type": "float",
            "default": 50
          },
          {
            "name": "chargeDistance",
            "type": "float",
            "default": 10
          },
          {
            "name": "chargeTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isCharging",
            "type": "bool",
            "default": false
          },
          {
            "name": "chargeDirection",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "start_charge_hold",
            "trigger": "when attack button is pressed and held",
            "actions": [
              {
                "action": "set charging state to true"
              },
              {
                "action": "record current forward direction as charge direction"
              },
              {
                "action": "reset charge time to zero"
              }
            ]
          },
          {
            "name": "build_charge_power",
            "trigger": "while attack button is held and charging",
            "actions": [
              {
                "action": "increase charge time"
              },
              {
                "action": "play charging sound effect"
              },
              {
                "action": "show charging visual effects that intensify over time"
              }
            ]
          },
          {
            "name": "execute_charge_attack",
            "trigger": "when attack button is released after charging",
            "actions": [
              {
                "action": "launch forward in charge direction at charge speed"
              },
              {
                "action": "set charging state to false"
              },
              {
                "action": "play charge attack sound"
              },
              {
                "action": "show charge attack visual trail"
              }
            ]
          },
          {
            "name": "deal_charge_damage",
            "trigger": "when colliding with enemy during charge attack",
            "actions": [
              {
                "action": "deal damage to enemy based on charge time"
              },
              {
                "action": "apply knockback force to enemy"
              },
              {
                "action": "stop charging movement"
              },
              {
                "action": "play impact effects"
              }
            ]
          },
          {
            "name": "stop_charge_on_obstacle",
            "trigger": "when colliding with wall or obstacle during charge",
            "actions": [
              {
                "action": "stop charging movement immediately"
              },
              {
                "action": "set charging state to false"
              },
              {
                "action": "play collision sound"
              },
              {
                "action": "show impact particles"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ChargeAttack : MonoBehaviour\n{\n    [Header(\"Charge Settings\")]\n    [SerializeField] private KeyCode _chargeKey = KeyCode.Mouse0;\n    [SerializeField] private float _minChargeTime = 0.5f;\n    [SerializeField] private float _maxChargeTime = 3.0f;\n    [SerializeField] private float _minDamage = 10f;\n    [SerializeField] private float _maxDamage = 50f;\n    [SerializeField] private float _minRange = 2f;\n    [SerializeField] private float _maxRange = 8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _chargingEffect;\n    [SerializeField] private GameObject _attackEffect;\n    [SerializeField] private LineRenderer _rangeIndicator;\n    [SerializeField] private Transform _attackPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeStarted;\n    public UnityEvent<float> OnChargeUpdated;\n    public UnityEvent<float, float> OnAttackReleased;\n    \n    private bool _isCharging = false;\n    private float _chargeStartTime;\n    private float _currentChargeTime;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rangeIndicator != null)\n        {\n            _rangeIndicator.enabled = false;\n            _rangeIndicator.positionCount = 2;\n        }\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (_isCharging)\n        {\n            UpdateCharge();\n            UpdateVisualEffects();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_chargeKey))\n        {\n            StartCharge();\n        }\n        else if (Input.GetKeyUp(_chargeKey) && _isCharging)\n        {\n            ReleaseAttack();\n        }\n    }\n    \n    private void StartCharge()\n    {\n        _isCharging = true;\n        _chargeStartTime = Time.time;\n        _currentChargeTime = 0f;\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(true);\n            \n        if (_audioSource != null && _chargeSound != null)\n            _audioSource.PlayOneShot(_chargeSound);\n            \n        OnChargeStarted.Invoke(0f);\n    }\n    \n    private void UpdateCharge()\n    {\n        _currentChargeTime = Time.time - _chargeStartTime;\n        _currentChargeTime = Mathf.Clamp(_currentChargeTime, 0f, _maxChargeTime);\n        \n        float chargePercent = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        OnChargeUpdated.Invoke(chargePercent);\n        \n        if (_currentChargeTime >= _maxChargeTime)\n        {\n            ReleaseAttack();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_rangeIndicator != null && _attackPoint != null)\n        {\n            _rangeIndicator.enabled = true;\n            float currentRange = Mathf.Lerp(_minRange, _maxRange, _currentChargeTime / _maxChargeTime);\n            \n            Vector3 startPos = _attackPoint.position;\n            Vector3 endPos = startPos + _attackPoint.forward * currentRange;\n            \n            _rangeIndicator.SetPosition(0, startPos);\n            _rangeIndicator.SetPosition(1, endPos);\n        }\n    }\n    \n    private void ReleaseAttack()\n    {\n        if (!_isCharging) return;\n        \n        _isCharging = false;\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(false);\n            \n        if (_rangeIndicator != null)\n            _rangeIndicator.enabled = false;\n        \n        if (_currentChargeTime >= _minChargeTime)\n        {\n            ExecuteAttack();\n        }\n    }\n    \n    private void ExecuteAttack()\n    {\n        float chargePercent = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        float damage = Mathf.Lerp(_minDamage, _maxDamage, chargePercent);\n        float range = Mathf.Lerp(_minRange, _maxRange, chargePercent);\n        \n        if (_attackEffect != null)\n        {\n            GameObject effect = Instantiate(_attackEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(effect, 2f);\n        }\n        \n        if (_audioSource != null && _releaseSound != null)\n            _audioSource.PlayOneShot(_releaseSound);\n        \n        PerformAttack(damage, range);\n        OnAttackReleased.Invoke(damage, range);\n    }\n    \n    private void PerformAttack(float damage, float range)\n    {\n        Vector3 attackOrigin = _attackPoint != null ? _attackPoint.position : transform.position;\n        Vector3 attackDirection = _attackPoint != null ? _attackPoint.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 1f, attackDirection, range);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(damage);\n            }\n            \n            Rigidbody rb = hit.collider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 knockbackDirection = (hit.point - attackOrigin).normalized;\n                rb.AddForce(knockbackDirection * damage * 10f, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public float GetChargePercent()\n    {\n        if (!_isCharging) return 0f;\n        return Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n    \n    public void CancelCharge()\n    {\n        if (_isCharging)\n        {\n            _isCharging = false;\n            \n            if (_chargingEffect != null)\n                _chargingEffect.SetActive(false);\n                \n            if (_rangeIndicator != null)\n                _rangeIndicator.enabled = false;\n        }\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "aerial combo attacks",
      "ideal_ir": {
        "class_name": "AerialComboAttacker",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "comboCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "maxComboHits",
            "type": "int",
            "default": 3
          },
          {
            "name": "comboTimeWindow",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "lastAttackTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "attackDamage",
            "type": "float",
            "default": 25
          },
          {
            "name": "comboMultiplier",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "launchForce",
            "type": "float",
            "default": 8
          },
          {
            "name": "isAirborne",
            "type": "bool",
            "default": false
          },
          {
            "name": "canPerformAerialCombo",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initiate_aerial_combo",
            "trigger": "when attack input is pressed and character is airborne and not already in combo",
            "actions": [
              {
                "action": "start first aerial attack animation"
              },
              {
                "action": "set combo count to one"
              },
              {
                "action": "record current time as last attack time"
              },
              {
                "action": "enable aerial combo state"
              }
            ]
          },
          {
            "name": "continue_aerial_combo",
            "trigger": "when attack input is pressed and already in aerial combo and within combo time window and combo count is less than maximum",
            "actions": [
              {
                "action": "play next combo attack animation"
              },
              {
                "action": "increase combo count by one"
              },
              {
                "action": "update last attack time to current time"
              },
              {
                "action": "apply increased damage based on combo multiplier"
              }
            ]
          },
          {
            "name": "finish_aerial_combo",
            "trigger": "when combo count reaches maximum hits or combo time window expires",
            "actions": [
              {
                "action": "play finishing aerial attack animation"
              },
              {
                "action": "apply powerful downward strike"
              },
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "disable aerial combo state"
              }
            ]
          },
          {
            "name": "launch_enemy_upward",
            "trigger": "when first aerial combo hit connects with enemy",
            "actions": [
              {
                "action": "apply upward force to enemy"
              },
              {
                "action": "temporarily suspend enemy gravity"
              },
              {
                "action": "match character height with enemy for combo continuation"
              }
            ]
          },
          {
            "name": "reset_combo_on_landing",
            "trigger": "when character touches ground while in aerial combo",
            "actions": [
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "disable aerial combo state"
              },
              {
                "action": "return to ground combat state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AerialComboSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class ComboAttack\n    {\n        public string name;\n        public KeyCode inputKey;\n        public float damage;\n        public float knockbackForce;\n        public Vector3 attackOffset;\n        public float attackRadius;\n        public AnimationClip animationClip;\n        public ParticleSystem effectPrefab;\n        public AudioClip soundEffect;\n        public float cooldown;\n        [HideInInspector] public float lastUsedTime;\n    }\n\n    [System.Serializable]\n    public class ComboSequence\n    {\n        public string sequenceName;\n        public List<int> attackIndices;\n        public float maxTimeBetweenAttacks;\n        public float bonusDamageMultiplier;\n        public ParticleSystem finisherEffect;\n        public AudioClip finisherSound;\n    }\n\n    [Header(\"Aerial Combat Settings\")]\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private float _airborneThreshold = 0.5f;\n    [SerializeField] private float _maxAirTime = 5f;\n    [SerializeField] private bool _requireAirborne = true;\n\n    [Header(\"Combo Attacks\")]\n    [SerializeField] private List<ComboAttack> _comboAttacks = new List<ComboAttack>();\n\n    [Header(\"Combo Sequences\")]\n    [SerializeField] private List<ComboSequence> _comboSequences = new List<ComboSequence>();\n    [SerializeField] private float _comboResetTime = 2f;\n\n    [Header(\"Physics\")]\n    [SerializeField] private float _airControlForce = 10f;\n    [SerializeField] private float _attackMomentum = 5f;\n    [SerializeField] private bool _pauseGravityDuringAttack = true;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private ParticleSystem _comboBuilderEffect;\n    [SerializeField] private TrailRenderer _weaponTrail;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _comboStartSound;\n    [SerializeField] private AudioClip _comboBreakSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnComboCountChanged;\n    public UnityEvent<string> OnComboSequenceCompleted;\n    public UnityEvent<float> OnAttackHit;\n    public UnityEvent OnAerialCombatStart;\n    public UnityEvent OnAerialCombatEnd;\n\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private Collider _collider;\n    private bool _isAirborne;\n    private float _airTime;\n    private bool _isAttacking;\n    private int _currentComboCount;\n    private List<int> _currentComboSequence = new List<int>();\n    private float _lastAttackTime;\n    private Vector3 _originalGravityScale;\n    private bool _gravityPaused;\n    private Dictionary<GameObject, float> _hitTargets = new Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_attackPoint == null)\n            _attackPoint = transform;\n\n        _originalGravityScale = Physics.gravity;\n        \n        ValidateComboAttacks();\n    }\n\n    private void Update()\n    {\n        CheckAirborneStatus();\n        HandleComboInput();\n        UpdateComboTimer();\n        UpdateAirTime();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isAirborne && !_isAttacking)\n        {\n            HandleAirMovement();\n        }\n    }\n\n    private void CheckAirborneStatus()\n    {\n        bool wasAirborne = _isAirborne;\n        _isAirborne = !IsGrounded();\n\n        if (_isAirborne && !wasAirborne)\n        {\n            OnAerialCombatStart?.Invoke();\n            _airTime = 0f;\n        }\n        else if (!_isAirborne && wasAirborne)\n        {\n            OnAerialCombatEnd?.Invoke();\n            ResetCombo();\n            RestoreGravity();\n        }\n    }\n\n    private bool IsGrounded()\n    {\n        if (_collider == null) return false;\n        \n        Vector3 center = _collider.bounds.center;\n        Vector3 size = _collider.bounds.size;\n        \n        return Physics.CheckBox(\n            center - Vector3.up * (size.y * 0.5f + _airborneThreshold),\n            new Vector3(size.x * 0.4f, 0.1f, size.z * 0.4f),\n            transform.rotation,\n            _targetLayers\n        );\n    }\n\n    private void HandleComboInput()\n    {\n        if (_requireAirborne && !_isAirborne) return;\n        if (_isAttacking) return;\n\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            if (Input.GetKeyDown(_comboAttacks[i].inputKey))\n            {\n                if (CanPerformAttack(i))\n                {\n                    StartCoroutine(PerformAttack(i));\n                    break;\n                }\n            }\n        }\n    }\n\n    private bool CanPerformAttack(int attackIndex)\n    {\n        if (attackIndex < 0 || attackIndex >= _comboAttacks.Count) return false;\n        \n        ComboAttack attack = _comboAttacks[attackIndex];\n        return Time.time >= attack.lastUsedTime + attack.cooldown;\n    }\n\n    private IEnumerator PerformAttack(int attackIndex)\n    {\n        _isAttacking = true;\n        ComboAttack attack = _comboAttacks[attackIndex];\n        attack.lastUsedTime = Time.time;\n\n        // Add to combo sequence\n        _currentComboSequence.Add(attackIndex);\n        _currentComboCount++;\n        _lastAttackTime = Time.time;\n        OnComboCountChanged?.Invoke(_currentComboCount);\n\n        // Pause gravity if enabled\n        if (_pauseGravityDuringAttack && _isAirborne)\n        {\n            PauseGravity();\n        }\n\n        // Play animation\n        if (_animator != null && attack.animationClip != null)\n        {\n            _animator.Play(attack.animationClip.name);\n        }\n\n        // Apply attack momentum\n        if (_rigidbody != null)\n        {\n            Vector3 attackDirection = transform.forward;\n            _rigidbody.AddForce(attackDirection * _attackMomentum, ForceMode.Impulse);\n        }\n\n        // Enable weapon trail\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = true;\n        }\n\n        // Play sound effect\n        if (_audioSource != null && attack.soundEffect != null)\n        {\n            _audioSource.PlayOneShot(attack.soundEffect);\n        }\n\n        // Wait for attack timing\n        float attackDuration = attack.animationClip != null ? attack.animationClip.length : 0.5f;\n        yield return new WaitForSeconds(attackDuration * 0.3f);\n\n        // Perform hit detection\n        PerformHitDetection(attack);\n\n        // Spawn effect\n        if (attack.effectPrefab != null)\n        {\n            Vector3 effectPosition = _attackPoint.position + attack.attackOffset;\n            ParticleSystem effect = Instantiate(attack.effectPrefab, effectPosition, _attackPoint.rotation);\n            Destroy(effect.gameObject, 3f);\n        }\n\n        yield return new WaitForSeconds(attackDuration * 0.7f);\n\n        // Disable weapon trail\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = false;\n        }\n\n        // Check for combo sequences\n        CheckComboSequences();\n\n        // Restore gravity\n        if (_pauseGravityDuringAttack)\n        {\n            RestoreGravity();\n        }\n\n        _isAttacking = false;\n    }\n\n    private void PerformHitDetection(ComboAttack attack)\n    {\n        Vector3 attackPosition = _attackPoint.position + _attackPoint.TransformDirection(attack.attackOffset);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attack.attackRadius, _targetLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject == gameObject) continue;\n\n            GameObject target = hitCollider.gameObject;\n            \n            // Prevent multiple hits on same target in short time\n            if (_hitTargets.ContainsKey(target) && Time.time - _hitTargets[target] < 0.5f)\n                continue;\n\n            _hitTargets[target] = Time.time;\n\n            // Apply damage and knockback\n            ApplyDamage(target, attack);\n            ApplyKnockback(target, attack);\n\n            OnAttackHit?.Invoke(attack.damage);\n        }\n\n        // Clean up old hit records\n        List<GameObject> keysToRemove = new List<GameObject>();\n        foreach (var kvp in _hitTargets)\n        {\n            if (kvp.Key == null || Time.time - kvp.Value > 2f)\n                keysToRemove.Add(kvp.Key);\n        }\n        foreach (var key in keysToRemove)\n        {\n            _hitTargets.Remove(key);\n        }\n    }\n\n    private void ApplyDamage(GameObject target, ComboAttack attack)\n    {\n        float finalDamage = attack.damage;\n\n        // Apply combo bonus\n        ComboSequence activeSequence = GetActiveComboSequence();\n        if (activeSequence != null)\n        {\n            finalDamage *= activeSequence.bonusDamageMultiplier;\n        }\n\n        // Try to find health component or send message\n        if (target.CompareTag(\"Player\") || target.CompareTag(\"Enemy\"))\n        {\n            target.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n\n    private void ApplyKnockback(GameObject target, ComboAttack attack)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.3f; // Add upward component\n            targetRb.AddForce(knockbackDirection * attack.knockbackForce, ForceMode.Impulse);\n        }\n    }\n\n    private void CheckComboSequences()\n    {\n        foreach (ComboSequence sequence in _comboSequences)\n        {\n            if (IsSequenceMatching(sequence))\n            {\n                CompleteComboSequence(sequence);\n                break;\n            }\n        }\n    }\n\n    private bool IsSequenceMatching(ComboSequence sequence)\n    {\n        if (_currentComboSequence.Count < sequence.attackIndices.Count) return false;\n\n        int startIndex = _currentComboSequence.Count - sequence.attackIndices.Count;\n        for (int i = 0; i < sequence.attackIndices.Count; i++)\n        {\n            if (_currentComboSequence[startIndex + i] != sequence.attackIndices[i])\n                return false;\n        }\n\n        return true;\n    }\n\n    private void CompleteComboSequence(ComboSequence sequence)\n    {\n        OnComboSequenceCompleted?.Invoke(sequence.sequenceName);\n\n        // Play finisher effects\n        if (sequence.finisherEffect != null)\n        {\n            ParticleSystem finisher = Instantiate(sequence.finisherEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(finisher.gameObject, 5f);\n        }\n\n        if (_audioSource != null && sequence.finisherSound != null)\n        {\n            _audioSource.PlayOneShot(sequence.finisherSound);\n        }\n\n        // Reset combo after sequence completion\n        StartCoroutine(DelayedComboReset(1f));\n    }\n\n    private ComboSequence GetActiveComboSequence()\n    {\n        foreach (ComboSequence sequence in _comboSequences)\n        {\n            if (IsSequenceMatching(sequence))\n                return sequence;\n        }\n        return null;\n    }\n\n    private void UpdateComboTimer()\n    {\n        if (_currentComboCount > 0 && Time.time - _lastAttackTime > _comboResetTime)\n        {\n            ResetCombo();\n        }\n    }\n\n    private void UpdateAirTime()\n    {\n        if (_isAirborne)\n        {\n            _airTime += Time.deltaTime;\n            if (_airTime > _maxAirTime)\n            {\n                // Force landing or reset\n                ResetCombo();\n            }\n        }\n    }\n\n    private void HandleAirMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Vector3 movement = new Vector3(horizontal, 0, vertical) * _airControlForce;\n        movement = transform.TransformDirection(movement);\n        \n        _rigidbody.AddForce(movement, ForceMode.Force);\n    }\n\n    private void PauseGravity()\n    {\n        if (!_gravityPaused && _rigidbody != null)\n        {\n            _rigidbody.useGravity = false;\n            _gravityPaused = true;\n        }\n    }\n\n    private void RestoreGravity()\n    {\n        if (_gravityPaused && _rigidbody != null)\n        {\n            _rigidbody.useGravity = true;\n            _gravityPaused = false;\n        }\n    }\n\n    private void ResetCombo()\n    {\n        if (_currentComboCount > 0)\n        {\n            if (_audioSource != null && _comboBreakSound != null)\n            {\n                _audioSource.PlayOneShot(_comboBreakSound);\n            }\n        }\n\n        _currentComboCount = 0;\n        _currentComboSequence.Clear();\n        OnComboCountChanged?.Invoke(0);\n\n        if (_comboBuilderEffect != null)\n        {\n            _comboBuilderEffect.Stop();\n        }\n    }\n\n    private IEnumerator DelayedComboReset(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        ResetCombo();\n    }\n\n    private void ValidateComboAttacks()\n    {\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            if (_comboAttacks[i].attackRadius <= 0)\n                _comboAttacks[i].attackRadius = 1f;\n            if (_comboAttacks[i].damage <= 0)\n                _comboAttacks[i].damage = 10f;\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_attackPoint == null) return;\n\n        Gizmos.color = Color.red;\n        foreach (",
      "behavior_type": "combat"
    },
    {
      "prompt": "grab and throw enemy",
      "ideal_ir": {
        "class_name": "GrabThrowEnemy",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "grabRange",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "throwForce",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "holdDistance",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "grab_enemy",
            "trigger": "when grab input is pressed and enemy is within grab range",
            "actions": [
              {
                "action": "disable enemy movement and physics"
              },
              {
                "action": "position enemy at hold distance in front of player"
              },
              {
                "action": "set enemy as grabbed state"
              }
            ]
          },
          {
            "name": "hold_enemy",
            "trigger": "while enemy is in grabbed state",
            "actions": [
              {
                "action": "keep enemy positioned at hold distance from player"
              },
              {
                "action": "rotate enemy to face same direction as player"
              }
            ]
          },
          {
            "name": "throw_enemy",
            "trigger": "when throw input is pressed and enemy is grabbed",
            "actions": [
              {
                "action": "release enemy from grabbed state"
              },
              {
                "action": "enable enemy physics"
              },
              {
                "action": "apply throw force to enemy in forward direction"
              },
              {
                "action": "clear grabbed enemy reference"
              }
            ]
          },
          {
            "name": "release_on_distance",
            "trigger": "when grabbed enemy gets too far from player",
            "actions": [
              {
                "action": "automatically release enemy"
              },
              {
                "action": "enable enemy physics and movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GrabThrowEnemy : MonoBehaviour\n{\n    [Header(\"Grab Settings\")]\n    [SerializeField] private float _grabRange = 2f;\n    [SerializeField] private LayerMask _enemyLayer = -1;\n    [SerializeField] private Transform _holdPosition;\n    [SerializeField] private float _grabForce = 10f;\n    \n    [Header(\"Throw Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _throwUpwardForce = 5f;\n    [SerializeField] private float _maxThrowDistance = 20f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _throwKey = KeyCode.Mouse0;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnEnemyGrabbed;\n    public UnityEvent<GameObject> OnEnemyThrown;\n    public UnityEvent<GameObject> OnEnemyReleased;\n    \n    private Camera _playerCamera;\n    private GameObject _grabbedEnemy;\n    private Rigidbody _grabbedRigidbody;\n    private Collider _grabbedCollider;\n    private bool _isGrabbing;\n    private Vector3 _originalGravity;\n    \n    [System.Serializable]\n    private class EnemyState\n    {\n        public bool wasKinematic;\n        public float originalDrag;\n        public float originalAngularDrag;\n        public RigidbodyConstraints originalConstraints;\n    }\n    \n    private EnemyState _enemyState = new EnemyState();\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_holdPosition == null)\n        {\n            GameObject holdPoint = new GameObject(\"HoldPosition\");\n            holdPoint.transform.SetParent(transform);\n            holdPoint.transform.localPosition = Vector3.forward * 2f;\n            _holdPosition = holdPoint.transform;\n        }\n        \n        _originalGravity = Physics.gravity;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        \n        if (_isGrabbing && _grabbedEnemy != null)\n        {\n            UpdateGrabbedEnemy();\n        }\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (!_isGrabbing)\n                TryGrabEnemy();\n            else\n                ReleaseEnemy();\n        }\n        \n        if (Input.GetKeyDown(_throwKey) && _isGrabbing)\n        {\n            ThrowEnemy();\n        }\n    }\n    \n    void TryGrabEnemy()\n    {\n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        if (Physics.Raycast(rayOrigin, rayDirection, out RaycastHit hit, _grabRange, _enemyLayer))\n        {\n            GameObject enemy = hit.collider.gameObject;\n            \n            if (enemy.CompareTag(\"Enemy\"))\n            {\n                GrabEnemy(enemy);\n            }\n        }\n    }\n    \n    void GrabEnemy(GameObject enemy)\n    {\n        _grabbedEnemy = enemy;\n        _grabbedRigidbody = enemy.GetComponent<Rigidbody>();\n        _grabbedCollider = enemy.GetComponent<Collider>();\n        \n        if (_grabbedRigidbody == null)\n        {\n            _grabbedRigidbody = enemy.AddComponent<Rigidbody>();\n        }\n        \n        // Store original state\n        _enemyState.wasKinematic = _grabbedRigidbody.isKinematic;\n        _enemyState.originalDrag = _grabbedRigidbody.drag;\n        _enemyState.originalAngularDrag = _grabbedRigidbody.angularDrag;\n        _enemyState.originalConstraints = _grabbedRigidbody.constraints;\n        \n        // Configure for grabbing\n        _grabbedRigidbody.isKinematic = false;\n        _grabbedRigidbody.drag = 10f;\n        _grabbedRigidbody.angularDrag = 5f;\n        _grabbedRigidbody.constraints = RigidbodyConstraints.FreezeRotation;\n        \n        // Disable enemy AI/movement components\n        MonoBehaviour[] enemyScripts = enemy.GetComponents<MonoBehaviour>();\n        foreach (MonoBehaviour script in enemyScripts)\n        {\n            if (script != this && script.enabled)\n            {\n                script.enabled = false;\n            }\n        }\n        \n        _isGrabbing = true;\n        OnEnemyGrabbed?.Invoke(_grabbedEnemy);\n    }\n    \n    void UpdateGrabbedEnemy()\n    {\n        if (_grabbedEnemy == null || _grabbedRigidbody == null)\n        {\n            ReleaseEnemy();\n            return;\n        }\n        \n        Vector3 targetPosition = _holdPosition.position;\n        Vector3 direction = targetPosition - _grabbedEnemy.transform.position;\n        \n        _grabbedRigidbody.velocity = direction * _grabForce;\n        \n        // Keep enemy at reasonable distance\n        float distance = Vector3.Distance(transform.position, _grabbedEnemy.transform.position);\n        if (distance > _maxThrowDistance)\n        {\n            ReleaseEnemy();\n        }\n    }\n    \n    void ThrowEnemy()\n    {\n        if (_grabbedEnemy == null || _grabbedRigidbody == null)\n            return;\n            \n        Vector3 throwDirection = _playerCamera.transform.forward;\n        Vector3 throwVelocity = throwDirection * _throwForce + Vector3.up * _throwUpwardForce;\n        \n        // Restore original state\n        _grabbedRigidbody.isKinematic = _enemyState.wasKinematic;\n        _grabbedRigidbody.drag = _enemyState.originalDrag;\n        _grabbedRigidbody.angularDrag = _enemyState.originalAngularDrag;\n        _grabbedRigidbody.constraints = _enemyState.originalConstraints;\n        \n        // Apply throw force\n        _grabbedRigidbody.velocity = throwVelocity;\n        \n        // Re-enable enemy scripts after a delay\n        StartCoroutine(ReenableEnemyScripts(_grabbedEnemy, 1f));\n        \n        OnEnemyThrown?.Invoke(_grabbedEnemy);\n        \n        _grabbedEnemy = null;\n        _grabbedRigidbody = null;\n        _grabbedCollider = null;\n        _isGrabbing = false;\n    }\n    \n    void ReleaseEnemy()\n    {\n        if (_grabbedEnemy == null)\n            return;\n            \n        if (_grabbedRigidbody != null)\n        {\n            // Restore original state\n            _grabbedRigidbody.isKinematic = _enemyState.wasKinematic;\n            _grabbedRigidbody.drag = _enemyState.originalDrag;\n            _grabbedRigidbody.angularDrag = _enemyState.originalAngularDrag;\n            _grabbedRigidbody.constraints = _enemyState.originalConstraints;\n            _grabbedRigidbody.velocity = Vector3.zero;\n        }\n        \n        // Re-enable enemy scripts\n        MonoBehaviour[] enemyScripts = _grabbedEnemy.GetComponents<MonoBehaviour>();\n        foreach (MonoBehaviour script in enemyScripts)\n        {\n            if (script != this)\n            {\n                script.enabled = true;\n            }\n        }\n        \n        OnEnemyReleased?.Invoke(_grabbedEnemy);\n        \n        _grabbedEnemy = null;\n        _grabbedRigidbody = null;\n        _grabbedCollider = null;\n        _isGrabbing = false;\n    }\n    \n    System.Collections.IEnumerator ReenableEnemyScripts(GameObject enemy, float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        \n        if (enemy != null)\n        {\n            MonoBehaviour[] enemyScripts = enemy.GetComponents<MonoBehaviour>();\n            foreach (MonoBehaviour script in enemyScripts)\n            {\n                if (script != this)\n                {\n                    script.enabled = true;\n                }\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(_playerCamera.transform.position, _playerCamera.transform.forward * _grabRange);\n        }\n        \n        if (_holdPosition != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPosition.position, 0.5f);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "stealth crouch with visibility meter",
      "ideal_ir": {
        "class_name": "StealthCrouch",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "crouchSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "standSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "visibilityLevel",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "maxVisibility",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "visibilityDecreaseRate",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "visibilityIncreaseRate",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "isCrouching",
            "type": "bool",
            "default": false
          },
          {
            "name": "crouchHeight",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "standHeight",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "enter_crouch",
            "trigger": "when crouch input is pressed",
            "actions": [
              {
                "action": "set crouching state to true"
              },
              {
                "action": "reduce character height to crouch height"
              },
              {
                "action": "change movement speed to crouch speed"
              },
              {
                "action": "play crouch animation"
              }
            ]
          },
          {
            "name": "exit_crouch",
            "trigger": "when crouch input is released",
            "actions": [
              {
                "action": "set crouching state to false"
              },
              {
                "action": "restore character height to stand height"
              },
              {
                "action": "change movement speed to stand speed"
              },
              {
                "action": "play stand animation"
              }
            ]
          },
          {
            "name": "decrease_visibility_while_crouching",
            "trigger": "when crouching and moving slowly",
            "actions": [
              {
                "action": "decrease visibility level over time"
              },
              {
                "action": "clamp visibility level to minimum zero"
              }
            ]
          },
          {
            "name": "increase_visibility_while_standing",
            "trigger": "when standing or moving quickly",
            "actions": [
              {
                "action": "increase visibility level over time"
              },
              {
                "action": "clamp visibility level to maximum value"
              }
            ]
          },
          {
            "name": "update_visibility_meter",
            "trigger": "every frame",
            "actions": [
              {
                "action": "update visibility meter display based on current visibility level"
              },
              {
                "action": "change meter color based on visibility threshold"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class StealthCrouchSystem : MonoBehaviour\n{\n    [Header(\"Crouch Settings\")]\n    [SerializeField] private KeyCode _crouchKey = KeyCode.LeftControl;\n    [SerializeField] private float _crouchHeight = 1f;\n    [SerializeField] private float _standHeight = 2f;\n    [SerializeField] private float _crouchSpeed = 2f;\n    [SerializeField] private float _standSpeed = 5f;\n    [SerializeField] private float _heightTransitionSpeed = 8f;\n    \n    [Header(\"Visibility Settings\")]\n    [SerializeField] private float _maxVisibility = 100f;\n    [SerializeField] private float _visibilityDecreaseRate = 20f;\n    [SerializeField] private float _visibilityIncreaseRate = 30f;\n    [SerializeField] private float _crouchVisibilityMultiplier = 0.3f;\n    [SerializeField] private float _movementVisibilityMultiplier = 1.5f;\n    [SerializeField] private float _detectionRange = 10f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Slider _visibilityMeter;\n    [SerializeField] private Image _visibilityFill;\n    [SerializeField] private Color _lowVisibilityColor = Color.green;\n    [SerializeField] private Color _highVisibilityColor = Color.red;\n    [SerializeField] private Canvas _stealthUI;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _crouchSound;\n    [SerializeField] private AudioClip _standSound;\n    \n    private CharacterController _characterController;\n    private Camera _playerCamera;\n    private bool _isCrouching;\n    private float _currentVisibility;\n    private float _targetHeight;\n    private Vector3 _lastPosition;\n    private List<Transform> _nearbyEnemies = new List<Transform>();\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _playerCamera = GetComponentInChildren<Camera>();\n        \n        if (_characterController == null)\n        {\n            _characterController = gameObject.AddComponent<CharacterController>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _targetHeight = _standHeight;\n        _characterController.height = _standHeight;\n        _currentVisibility = 0f;\n        _lastPosition = transform.position;\n        \n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        HandleCrouchInput();\n        UpdateHeight();\n        UpdateVisibility();\n        UpdateUI();\n        FindNearbyEnemies();\n    }\n    \n    private void HandleCrouchInput()\n    {\n        bool crouchPressed = Input.GetKey(_crouchKey);\n        \n        if (crouchPressed && !_isCrouching)\n        {\n            StartCrouch();\n        }\n        else if (!crouchPressed && _isCrouching)\n        {\n            StopCrouch();\n        }\n    }\n    \n    private void StartCrouch()\n    {\n        _isCrouching = true;\n        _targetHeight = _crouchHeight;\n        \n        if (_audioSource && _crouchSound)\n        {\n            _audioSource.PlayOneShot(_crouchSound);\n        }\n    }\n    \n    private void StopCrouch()\n    {\n        if (CanStandUp())\n        {\n            _isCrouching = false;\n            _targetHeight = _standHeight;\n            \n            if (_audioSource && _standSound)\n            {\n                _audioSource.PlayOneShot(_standSound);\n            }\n        }\n    }\n    \n    private bool CanStandUp()\n    {\n        float checkHeight = _standHeight - _crouchHeight;\n        Vector3 checkStart = transform.position + Vector3.up * _crouchHeight;\n        \n        return !Physics.SphereCast(checkStart, _characterController.radius, Vector3.up, out RaycastHit hit, checkHeight);\n    }\n    \n    private void UpdateHeight()\n    {\n        float currentHeight = _characterController.height;\n        float newHeight = Mathf.MoveTowards(currentHeight, _targetHeight, _heightTransitionSpeed * Time.deltaTime);\n        \n        if (Mathf.Abs(newHeight - currentHeight) > 0.01f)\n        {\n            Vector3 centerOffset = Vector3.up * (newHeight - currentHeight) * 0.5f;\n            _characterController.height = newHeight;\n            _characterController.center = Vector3.up * newHeight * 0.5f;\n            \n            if (_playerCamera)\n            {\n                Vector3 cameraPos = _playerCamera.transform.localPosition;\n                cameraPos.y += (newHeight - currentHeight) * 0.8f;\n                _playerCamera.transform.localPosition = cameraPos;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        float visibilityChange = 0f;\n        bool isMoving = Vector3.Distance(transform.position, _lastPosition) > 0.01f;\n        bool isInEnemySight = IsInEnemySight();\n        \n        if (isInEnemySight)\n        {\n            visibilityChange = _visibilityIncreaseRate;\n            \n            if (_isCrouching)\n            {\n                visibilityChange *= _crouchVisibilityMultiplier;\n            }\n            \n            if (isMoving)\n            {\n                visibilityChange *= _movementVisibilityMultiplier;\n            }\n        }\n        else\n        {\n            visibilityChange = -_visibilityDecreaseRate;\n        }\n        \n        _currentVisibility = Mathf.Clamp(_currentVisibility + visibilityChange * Time.deltaTime, 0f, _maxVisibility);\n        _lastPosition = transform.position;\n    }\n    \n    private bool IsInEnemySight()\n    {\n        foreach (Transform enemy in _nearbyEnemies)\n        {\n            if (enemy == null) continue;\n            \n            Vector3 directionToPlayer = (transform.position - enemy.position).normalized;\n            float distanceToPlayer = Vector3.Distance(transform.position, enemy.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                if (Physics.Raycast(enemy.position, directionToPlayer, out RaycastHit hit, distanceToPlayer))\n                {\n                    if (hit.transform == transform)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private void FindNearbyEnemies()\n    {\n        _nearbyEnemies.Clear();\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _detectionRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Enemy\") && col.transform != transform)\n            {\n                _nearbyEnemies.Add(col.transform);\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_visibilityMeter)\n        {\n            _visibilityMeter.value = _currentVisibility / _maxVisibility;\n        }\n        \n        if (_visibilityFill)\n        {\n            float normalizedVisibility = _currentVisibility / _maxVisibility;\n            _visibilityFill.color = Color.Lerp(_lowVisibilityColor, _highVisibilityColor, normalizedVisibility);\n        }\n        \n        if (_stealthUI)\n        {\n            _stealthUI.gameObject.SetActive(_nearbyEnemies.Count > 0);\n        }\n    }\n    \n    private void SetupUI()\n    {\n        if (_visibilityMeter == null && _stealthUI != null)\n        {\n            _visibilityMeter = _stealthUI.GetComponentInChildren<Slider>();\n        }\n        \n        if (_visibilityFill == null && _visibilityMeter != null)\n        {\n            _visibilityFill = _visibilityMeter.fillRect.GetComponent<Image>();\n        }\n    }\n    \n    public bool IsCrouching()\n    {\n        return _isCrouching;\n    }\n    \n    public float GetVisibilityPercentage()\n    {\n        return _currentVisibility / _maxVisibility;\n    }\n    \n    public bool IsDetected()\n    {\n        return _currentVisibility >= _maxVisibility;\n    }\n    \n    public float GetMovementSpeed()\n    {\n        return _isCrouching ? _crouchSpeed : _standSpeed;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_isCrouching)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position + Vector3.up * _crouchHeight * 0.5f, \n                new Vector3(1f, _crouchHeight, 1f));\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "lock-on targeting system",
      "ideal_ir": {
        "class_name": "LockOnTargeting",
        "components": [
          "Transform",
          "Camera"
        ],
        "fields": [
          {
            "name": "lockOnRange",
            "type": "float",
            "default": 50
          },
          {
            "name": "lockOnAngle",
            "type": "float",
            "default": 45
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 5
          },
          {
            "name": "currentTarget",
            "type": "Transform",
            "default": null
          },
          {
            "name": "isLocked",
            "type": "bool",
            "default": false
          },
          {
            "name": "targetLayer",
            "type": "LayerMask",
            "default": -1
          }
        ],
        "behaviors": [
          {
            "name": "initiate_lock_on",
            "trigger": "when lock on input is pressed",
            "actions": [
              {
                "action": "find closest enemy within lock on range and angle"
              },
              {
                "action": "set current target to closest valid enemy"
              },
              {
                "action": "enable locked on state"
              }
            ]
          },
          {
            "name": "maintain_lock_on",
            "trigger": "when locked on to target and target exists",
            "actions": [
              {
                "action": "smoothly rotate camera to face current target"
              },
              {
                "action": "keep target centered in view"
              }
            ]
          },
          {
            "name": "break_lock_on_input",
            "trigger": "when lock on input is pressed while already locked on",
            "actions": [
              {
                "action": "clear current target"
              },
              {
                "action": "disable locked on state"
              },
              {
                "action": "return camera control to player"
              }
            ]
          },
          {
            "name": "break_lock_on_distance",
            "trigger": "when current target moves beyond lock on range",
            "actions": [
              {
                "action": "clear current target"
              },
              {
                "action": "disable locked on state"
              },
              {
                "action": "return camera control to player"
              }
            ]
          },
          {
            "name": "break_lock_on_destroyed",
            "trigger": "when current target is destroyed or becomes inactive",
            "actions": [
              {
                "action": "clear current target"
              },
              {
                "action": "disable locked on state"
              },
              {
                "action": "return camera control to player"
              }
            ]
          },
          {
            "name": "switch_targets",
            "trigger": "when switch target input is pressed while locked on",
            "actions": [
              {
                "action": "find next closest enemy within lock on range"
              },
              {
                "action": "switch current target to next valid enemy"
              },
              {
                "action": "maintain locked on state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class LockOnTargetingSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class TargetData\n    {\n        public Transform target;\n        public float distance;\n        public float angle;\n        public bool isVisible;\n        \n        public TargetData(Transform t, float d, float a, bool v)\n        {\n            target = t;\n            distance = d;\n            angle = a;\n            isVisible = v;\n        }\n    }\n\n    [Header(\"Targeting Settings\")]\n    [SerializeField] private float _maxLockOnDistance = 50f;\n    [SerializeField] private float _maxLockOnAngle = 60f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private string[] _targetTags = { \"Enemy\" };\n    \n    [Header(\"Camera Settings\")]\n    [SerializeField] private Transform _cameraTransform;\n    [SerializeField] private float _lockOnSmoothTime = 0.3f;\n    [SerializeField] private Vector3 _targetOffset = Vector3.up;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _lockOnKey = KeyCode.Tab;\n    [SerializeField] private KeyCode _switchTargetKey = KeyCode.R;\n    [SerializeField] private bool _useMouseForSwitching = true;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _lockOnIndicatorPrefab;\n    [SerializeField] private Canvas _uiCanvas;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnTargetLocked;\n    public UnityEvent OnTargetUnlocked;\n    public UnityEvent<Transform> OnTargetSwitched;\n\n    private Transform _currentTarget;\n    private List<TargetData> _availableTargets = new List<TargetData>();\n    private GameObject _lockOnIndicator;\n    private Vector3 _cameraVelocity;\n    private bool _isLockingOn = false;\n    private int _currentTargetIndex = 0;\n    private Camera _mainCamera;\n\n    public Transform CurrentTarget => _currentTarget;\n    public bool IsLockingOn => _isLockingOn;\n\n    private void Start()\n    {\n        if (_cameraTransform == null)\n            _cameraTransform = Camera.main?.transform;\n            \n        _mainCamera = _cameraTransform?.GetComponent<Camera>();\n        \n        if (_uiCanvas == null)\n            _uiCanvas = FindObjectOfType<Canvas>();\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        UpdateTargetList();\n        UpdateLockOn();\n        UpdateUI();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_lockOnKey))\n        {\n            if (_isLockingOn)\n                UnlockTarget();\n            else\n                LockOnToNearestTarget();\n        }\n\n        if (Input.GetKeyDown(_switchTargetKey) && _isLockingOn)\n        {\n            SwitchToNextTarget();\n        }\n\n        if (_useMouseForSwitching && _isLockingOn)\n        {\n            float mouseX = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(mouseX) > 0.5f)\n            {\n                if (mouseX > 0)\n                    SwitchToNextTarget();\n                else\n                    SwitchToPreviousTarget();\n            }\n        }\n    }\n\n    private void UpdateTargetList()\n    {\n        _availableTargets.Clear();\n\n        if (_cameraTransform == null) return;\n\n        Collider[] potentialTargets = Physics.OverlapSphere(transform.position, _maxLockOnDistance, _targetLayers);\n\n        foreach (Collider col in potentialTargets)\n        {\n            if (col.transform == transform) continue;\n\n            bool isValidTag = false;\n            foreach (string tag in _targetTags)\n            {\n                if (col.CompareTag(tag))\n                {\n                    isValidTag = true;\n                    break;\n                }\n            }\n\n            if (!isValidTag) continue;\n\n            Vector3 directionToTarget = (col.transform.position - _cameraTransform.position).normalized;\n            float angle = Vector3.Angle(_cameraTransform.forward, directionToTarget);\n\n            if (angle <= _maxLockOnAngle)\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                bool isVisible = IsTargetVisible(col.transform);\n\n                _availableTargets.Add(new TargetData(col.transform, distance, angle, isVisible));\n            }\n        }\n\n        _availableTargets = _availableTargets.OrderBy(t => t.distance).ToList();\n\n        if (_isLockingOn && _currentTarget != null)\n        {\n            bool currentTargetStillValid = _availableTargets.Any(t => t.target == _currentTarget);\n            if (!currentTargetStillValid)\n            {\n                UnlockTarget();\n            }\n        }\n    }\n\n    private bool IsTargetVisible(Transform target)\n    {\n        if (_cameraTransform == null || target == null) return false;\n\n        Vector3 directionToTarget = (target.position + _targetOffset - _cameraTransform.position);\n        float distanceToTarget = directionToTarget.magnitude;\n\n        if (Physics.Raycast(_cameraTransform.position, directionToTarget.normalized, out RaycastHit hit, distanceToTarget, _obstacleLayer))\n        {\n            return hit.transform == target;\n        }\n\n        return true;\n    }\n\n    public void LockOnToNearestTarget()\n    {\n        if (_availableTargets.Count == 0) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count == 0) return;\n\n        _currentTarget = visibleTargets[0].target;\n        _currentTargetIndex = 0;\n        _isLockingOn = true;\n\n        CreateLockOnIndicator();\n        OnTargetLocked?.Invoke(_currentTarget);\n    }\n\n    public void LockOnToTarget(Transform target)\n    {\n        if (target == null) return;\n\n        var targetData = _availableTargets.FirstOrDefault(t => t.target == target);\n        if (targetData == null) return;\n\n        _currentTarget = target;\n        _currentTargetIndex = _availableTargets.IndexOf(targetData);\n        _isLockingOn = true;\n\n        CreateLockOnIndicator();\n        OnTargetLocked?.Invoke(_currentTarget);\n    }\n\n    public void UnlockTarget()\n    {\n        _currentTarget = null;\n        _isLockingOn = false;\n        _currentTargetIndex = 0;\n\n        DestroyLockOnIndicator();\n        OnTargetUnlocked?.Invoke();\n    }\n\n    public void SwitchToNextTarget()\n    {\n        if (_availableTargets.Count <= 1) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count <= 1) return;\n\n        int currentVisibleIndex = visibleTargets.FindIndex(t => t.target == _currentTarget);\n        currentVisibleIndex = (currentVisibleIndex + 1) % visibleTargets.Count;\n\n        Transform previousTarget = _currentTarget;\n        _currentTarget = visibleTargets[currentVisibleIndex].target;\n        _currentTargetIndex = _availableTargets.FindIndex(t => t.target == _currentTarget);\n\n        OnTargetSwitched?.Invoke(_currentTarget);\n    }\n\n    public void SwitchToPreviousTarget()\n    {\n        if (_availableTargets.Count <= 1) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count <= 1) return;\n\n        int currentVisibleIndex = visibleTargets.FindIndex(t => t.target == _currentTarget);\n        currentVisibleIndex = (currentVisibleIndex - 1 + visibleTargets.Count) % visibleTargets.Count;\n\n        Transform previousTarget = _currentTarget;\n        _currentTarget = visibleTargets[currentVisibleIndex].target;\n        _currentTargetIndex = _availableTargets.FindIndex(t => t.target == _currentTarget);\n\n        OnTargetSwitched?.Invoke(_currentTarget);\n    }\n\n    private void UpdateLockOn()\n    {\n        if (!_isLockingOn || _currentTarget == null || _cameraTransform == null) return;\n\n        Vector3 targetPosition = _currentTarget.position + _targetOffset;\n        Vector3 desiredPosition = Vector3.SmoothDamp(_cameraTransform.position, targetPosition, ref _cameraVelocity, _lockOnSmoothTime);\n        \n        Vector3 direction = (targetPosition - _cameraTransform.position).normalized;\n        Quaternion targetRotation = Quaternion.LookRotation(direction);\n        _cameraTransform.rotation = Quaternion.Slerp(_cameraTransform.rotation, targetRotation, Time.deltaTime / _lockOnSmoothTime);\n    }\n\n    private void CreateLockOnIndicator()\n    {\n        if (_lockOnIndicatorPrefab == null || _uiCanvas == null) return;\n\n        DestroyLockOnIndicator();\n        _lockOnIndicator = Instantiate(_lockOnIndicatorPrefab, _uiCanvas.transform);\n    }\n\n    private void DestroyLockOnIndicator()\n    {\n        if (_lockOnIndicator != null)\n        {\n            Destroy(_lockOnIndicator);\n            _lockOnIndicator = null;\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_lockOnIndicator == null || _currentTarget == null || _mainCamera == null) return;\n\n        Vector3 screenPosition = _mainCamera.WorldToScreenPoint(_currentTarget.position + _targetOffset);\n        \n        if (screenPosition.z > 0)\n        {\n            _lockOnIndicator.transform.position = screenPosition;\n            _lockOnIndicator.SetActive(true);\n        }\n        else\n        {\n            _lockOnIndicator.SetActive(false);\n        }\n    }\n\n    public List<Transform> GetAvailableTargets()\n    {\n        return _availableTargets.Select(t => t.target).ToList();\n    }\n\n    public float GetDistanceToCurrentTarget()\n    {\n        if (_currentTarget == null) return 0f;\n        return Vector3.Distance(transform.position, _currentTarget.position);\n    }\n\n    public Vector3 GetDirectionToCurrentTarget()\n    {\n        if (_currentTarget == null) return Vector3.zero;\n        return (_currentTarget.position - transform.position).normalized;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxLockOnDistance);\n\n        if (_cameraTransform != null)\n        {\n            Gizmos.color = Color.red;\n            Vector3 leftBoundary = Quaternion.AngleAxis(-_maxLockOnAngle, _cameraTransform.up) * _cameraTransform.forward;\n            Vector3 rightBoundary = Quaternion.AngleAxis(_maxLockOnAngle, _cameraTransform.up) * _cameraTransform.forward;\n            \n            Gizmos.DrawRay(_cameraTransform.position, leftBoundary * _maxLockOnDistance);\n            Gizmos.DrawRay(_cameraTransform.position, rightBoundary * _maxLockOnDistance);\n        }\n\n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n            Gizmos.DrawWireSphere(_currentTarget.position, 1f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "quick turn around",
      "ideal_ir": {
        "class_name": "QuickTurnAround",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 540
          },
          {
            "name": "isQuickTurning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "execute_quick_turn",
            "trigger": "when quick turn is requested",
            "actions": [
              {
                "action": "set quick turning flag to true"
              },
              {
                "action": "rotate object one hundred eighty degrees around vertical axis at turn speed"
              },
              {
                "action": "set quick turning flag to false when rotation is complete"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class QuickTurnAround : MonoBehaviour\n{\n    [Header(\"Turn Settings\")]\n    [SerializeField] private float _turnSpeed = 720f;\n    [SerializeField] private KeyCode _turnKey = KeyCode.Q;\n    [SerializeField] private bool _useMouseInput = false;\n    [SerializeField] private float _mouseSensitivity = 2f;\n    \n    [Header(\"Turn Direction\")]\n    [SerializeField] private bool _turnLeft = true;\n    [SerializeField] private float _turnAngle = 180f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private AnimationCurve _turnCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private bool _useSmoothing = true;\n    \n    [Header(\"Cooldown\")]\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private bool _allowContinuousTurn = false;\n    \n    private bool _isTurning = false;\n    private float _currentTurnTime = 0f;\n    private float _startRotationY;\n    private float _targetRotationY;\n    private float _lastTurnTime = 0f;\n    private Vector3 _originalRotation;\n    \n    private void Start()\n    {\n        _originalRotation = transform.eulerAngles;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        ProcessTurn();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isTurning && !_allowContinuousTurn) return;\n        if (Time.time - _lastTurnTime < _cooldownTime) return;\n        \n        bool shouldTurn = false;\n        \n        if (_useMouseInput)\n        {\n            float mouseX = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(mouseX) > _mouseSensitivity)\n            {\n                _turnLeft = mouseX < 0;\n                shouldTurn = true;\n            }\n        }\n        \n        if (Input.GetKeyDown(_turnKey))\n        {\n            shouldTurn = true;\n        }\n        \n        if (shouldTurn)\n        {\n            StartTurn();\n        }\n    }\n    \n    private void StartTurn()\n    {\n        if (!_allowContinuousTurn && _isTurning) return;\n        \n        _isTurning = true;\n        _currentTurnTime = 0f;\n        _startRotationY = transform.eulerAngles.y;\n        \n        float turnDirection = _turnLeft ? -1f : 1f;\n        _targetRotationY = _startRotationY + (_turnAngle * turnDirection);\n        \n        _lastTurnTime = Time.time;\n    }\n    \n    private void ProcessTurn()\n    {\n        if (!_isTurning) return;\n        \n        _currentTurnTime += Time.deltaTime;\n        float turnDuration = _turnAngle / _turnSpeed;\n        float normalizedTime = _currentTurnTime / turnDuration;\n        \n        if (normalizedTime >= 1f)\n        {\n            CompleteTurn();\n            return;\n        }\n        \n        float rotationY;\n        if (_useSmoothing)\n        {\n            float curveValue = _turnCurve.Evaluate(normalizedTime);\n            rotationY = Mathf.LerpAngle(_startRotationY, _targetRotationY, curveValue);\n        }\n        else\n        {\n            rotationY = Mathf.LerpAngle(_startRotationY, _targetRotationY, normalizedTime);\n        }\n        \n        Vector3 newRotation = transform.eulerAngles;\n        newRotation.y = rotationY;\n        transform.eulerAngles = newRotation;\n    }\n    \n    private void CompleteTurn()\n    {\n        Vector3 finalRotation = transform.eulerAngles;\n        finalRotation.y = _targetRotationY;\n        transform.eulerAngles = finalRotation;\n        \n        _isTurning = false;\n        _currentTurnTime = 0f;\n    }\n    \n    public void TurnAround()\n    {\n        StartTurn();\n    }\n    \n    public void TurnLeft()\n    {\n        _turnLeft = true;\n        StartTurn();\n    }\n    \n    public void TurnRight()\n    {\n        _turnLeft = false;\n        StartTurn();\n    }\n    \n    public void SetTurnSpeed(float speed)\n    {\n        _turnSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void SetTurnAngle(float angle)\n    {\n        _turnAngle = Mathf.Clamp(angle, 1f, 360f);\n    }\n    \n    public bool IsTurning()\n    {\n        return _isTurning;\n    }\n    \n    private void OnValidate()\n    {\n        _turnSpeed = Mathf.Max(0.1f, _turnSpeed);\n        _turnAngle = Mathf.Clamp(_turnAngle, 1f, 360f);\n        _cooldownTime = Mathf.Max(0f, _cooldownTime);\n        _mouseSensitivity = Mathf.Max(0.1f, _mouseSensitivity);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "slide under obstacles",
      "ideal_ir": {
        "class_name": "ObstacleSlider",
        "components": [
          "Rigidbody",
          "CapsuleCollider"
        ],
        "fields": [
          {
            "name": "slideSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "slideDuration",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "obstacleDetectionDistance",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "slideHeight",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "normalHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isSliding",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_obstacle_ahead",
            "trigger": "when moving forward and obstacle is detected ahead within detection distance",
            "actions": [
              {
                "action": "check if obstacle can be slid under by examining its height"
              }
            ]
          },
          {
            "name": "initiate_slide",
            "trigger": "when slide input is pressed and obstacle ahead can be slid under",
            "actions": [
              {
                "action": "set sliding state to true"
              },
              {
                "action": "reduce character height to slide height"
              },
              {
                "action": "increase forward movement speed to slide speed"
              },
              {
                "action": "start slide duration timer"
              }
            ]
          },
          {
            "name": "maintain_slide_movement",
            "trigger": "while sliding state is active",
            "actions": [
              {
                "action": "move forward at slide speed"
              },
              {
                "action": "keep character at reduced height"
              },
              {
                "action": "prevent jumping or standing actions"
              }
            ]
          },
          {
            "name": "end_slide",
            "trigger": "when slide duration timer expires or obstacle is cleared",
            "actions": [
              {
                "action": "set sliding state to false"
              },
              {
                "action": "restore character height to normal height"
              },
              {
                "action": "return movement speed to normal"
              },
              {
                "action": "allow normal movement actions"
              }
            ]
          },
          {
            "name": "slide_collision_handling",
            "trigger": "while sliding and collision occurs with obstacle sides",
            "actions": [
              {
                "action": "maintain slide momentum"
              },
              {
                "action": "prevent getting stuck on obstacle edges"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SlideController : MonoBehaviour\n{\n    [Header(\"Slide Settings\")]\n    [SerializeField] private float _slideDuration = 1f;\n    [SerializeField] private float _slideSpeed = 8f;\n    [SerializeField] private float _slideHeight = 0.5f;\n    [SerializeField] private KeyCode _slideKey = KeyCode.S;\n    [SerializeField] private KeyCode _slideKeyAlt = KeyCode.LeftControl;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _normalHeight = 2f;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _slideSound;\n    [SerializeField] private AudioClip _slideEndSound;\n    \n    private Rigidbody _rigidbody;\n    private CapsuleCollider _capsuleCollider;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    \n    private bool _isSliding = false;\n    private bool _isGrounded = false;\n    private float _slideTimer = 0f;\n    private float _originalHeight;\n    private Vector3 _originalCenter;\n    private Vector3 _slideDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _capsuleCollider = GetComponent<CapsuleCollider>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_capsuleCollider != null)\n        {\n            _originalHeight = _capsuleCollider.height;\n            _originalCenter = _capsuleCollider.center;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleSlideInput();\n        UpdateSlide();\n    }\n    \n    private void CheckGrounded()\n    {\n        if (Physics.Raycast(transform.position, Vector3.down, _groundCheckDistance + 0.1f, _obstacleLayer))\n        {\n            _isGrounded = true;\n        }\n        else\n        {\n            _isGrounded = false;\n        }\n    }\n    \n    private void HandleSlideInput()\n    {\n        if (!_isSliding && _isGrounded && (Input.GetKeyDown(_slideKey) || Input.GetKeyDown(_slideKeyAlt)))\n        {\n            StartSlide();\n        }\n        \n        if (_isSliding && (Input.GetKeyUp(_slideKey) && Input.GetKeyUp(_slideKeyAlt)))\n        {\n            EndSlide();\n        }\n    }\n    \n    private void UpdateSlide()\n    {\n        if (_isSliding)\n        {\n            _slideTimer += Time.deltaTime;\n            \n            if (_slideTimer >= _slideDuration)\n            {\n                EndSlide();\n            }\n            else\n            {\n                ApplySlideMovement();\n            }\n        }\n    }\n    \n    private void StartSlide()\n    {\n        _isSliding = true;\n        _slideTimer = 0f;\n        _slideDirection = transform.forward;\n        \n        if (_capsuleCollider != null)\n        {\n            _capsuleCollider.height = _slideHeight;\n            _capsuleCollider.center = new Vector3(_originalCenter.x, _slideHeight * 0.5f, _originalCenter.z);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsSliding\", true);\n        }\n        \n        if (_audioSource != null && _slideSound != null)\n        {\n            _audioSource.PlayOneShot(_slideSound);\n        }\n    }\n    \n    private void EndSlide()\n    {\n        if (!CanStandUp())\n        {\n            return;\n        }\n        \n        _isSliding = false;\n        _slideTimer = 0f;\n        \n        if (_capsuleCollider != null)\n        {\n            _capsuleCollider.height = _originalHeight;\n            _capsuleCollider.center = _originalCenter;\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsSliding\", false);\n        }\n        \n        if (_audioSource != null && _slideEndSound != null)\n        {\n            _audioSource.PlayOneShot(_slideEndSound);\n        }\n    }\n    \n    private bool CanStandUp()\n    {\n        Vector3 checkPosition = transform.position + Vector3.up * (_normalHeight - _slideHeight);\n        return !Physics.CheckSphere(checkPosition, 0.4f, _obstacleLayer);\n    }\n    \n    private void ApplySlideMovement()\n    {\n        if (_rigidbody != null && _isGrounded)\n        {\n            Vector3 slideVelocity = _slideDirection * _slideSpeed;\n            slideVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = slideVelocity;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Obstacle\") && _isSliding)\n        {\n            Debug.Log(\"Successfully slid under obstacle!\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.down * _groundCheckDistance, 0.1f);\n        \n        if (_isSliding)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(transform.position, new Vector3(1f, _slideHeight, 1f));\n        }\n        else\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, new Vector3(1f, _normalHeight, 1f));\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "pole vault jump",
      "ideal_ir": {
        "class_name": "PoleVaultJump",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "runSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "plantDistance",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "vaultHeight",
            "type": "float",
            "default": 4.0
          },
          {
            "name": "poleLength",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isRunning",
            "type": "bool",
            "default": false
          },
          {
            "name": "hasPlantedPole",
            "type": "bool",
            "default": false
          },
          {
            "name": "isVaulting",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_run_up",
            "trigger": "when jump input is pressed and player is on ground",
            "actions": [
              {
                "action": "set running state to true"
              },
              {
                "action": "begin running forward at run speed"
              },
              {
                "action": "play running animation"
              }
            ]
          },
          {
            "name": "plant_pole",
            "trigger": "when running and within plant distance of target",
            "actions": [
              {
                "action": "set pole planted state to true"
              },
              {
                "action": "stop forward movement"
              },
              {
                "action": "plant pole vertically into ground"
              },
              {
                "action": "play pole plant animation"
              }
            ]
          },
          {
            "name": "begin_vault",
            "trigger": "when pole is planted and player contacts pole",
            "actions": [
              {
                "action": "set vaulting state to true"
              },
              {
                "action": "attach player to pole"
              },
              {
                "action": "begin upward swing motion around pole"
              },
              {
                "action": "play vault swing animation"
              }
            ]
          },
          {
            "name": "release_and_clear",
            "trigger": "when vaulting and reached maximum height",
            "actions": [
              {
                "action": "release from pole"
              },
              {
                "action": "apply forward momentum over bar"
              },
              {
                "action": "enter falling state"
              },
              {
                "action": "play release animation"
              }
            ]
          },
          {
            "name": "land_after_vault",
            "trigger": "when falling and contacts landing surface",
            "actions": [
              {
                "action": "reset all vault states to false"
              },
              {
                "action": "play landing animation"
              },
              {
                "action": "apply landing impact"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PoleVaultJump : MonoBehaviour\n{\n    [Header(\"Pole Vault Settings\")]\n    [SerializeField] private float _runSpeed = 8f;\n    [SerializeField] private float _poleLength = 4f;\n    [SerializeField] private float _vaultForce = 15f;\n    [SerializeField] private float _minRunDistance = 5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravity = -9.81f;\n    [SerializeField] private float _airDrag = 0.98f;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _runKey = KeyCode.W;\n    [SerializeField] private KeyCode _plantPoleKey = KeyCode.Space;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Space;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private Transform _poleTransform;\n    [SerializeField] private LineRenderer _poleRenderer;\n    [SerializeField] private Transform _playerModel;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRunStart;\n    public UnityEvent OnPoleVault;\n    public UnityEvent OnLanding;\n    \n    private Rigidbody _rigidbody;\n    private CapsuleCollider _collider;\n    private Vector3 _velocity;\n    private Vector3 _runStartPosition;\n    private Vector3 _poleContactPoint;\n    private bool _isRunning;\n    private bool _isPoleVaulting;\n    private bool _isPoleInGround;\n    private bool _isGrounded;\n    private float _runDistance;\n    private float _vaultAngle;\n    private VaultState _currentState;\n    \n    private enum VaultState\n    {\n        Idle,\n        Running,\n        PoleContact,\n        Vaulting,\n        Airborne,\n        Landing\n    }\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<CapsuleCollider>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _currentState = VaultState.Idle;\n        \n        SetupPoleVisual();\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateGroundCheck();\n        UpdateState();\n        UpdatePoleVisual();\n    }\n    \n    void FixedUpdate()\n    {\n        ApplyPhysics();\n        UpdateMovement();\n    }\n    \n    void HandleInput()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Idle:\n                if (Input.GetKeyDown(_runKey))\n                {\n                    StartRun();\n                }\n                break;\n                \n            case VaultState.Running:\n                if (Input.GetKeyUp(_runKey))\n                {\n                    StopRun();\n                }\n                else if (Input.GetKeyDown(_plantPoleKey) && _runDistance >= _minRunDistance)\n                {\n                    PlantPole();\n                }\n                break;\n                \n            case VaultState.PoleContact:\n            case VaultState.Vaulting:\n                if (Input.GetKeyDown(_releaseKey))\n                {\n                    ReleasePole();\n                }\n                break;\n        }\n    }\n    \n    void UpdateGroundCheck()\n    {\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        _isGrounded = Physics.Raycast(rayStart, Vector3.down, _groundCheckDistance + 0.1f, _groundLayer);\n    }\n    \n    void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Running:\n                _runDistance = Vector3.Distance(_runStartPosition, transform.position);\n                if (!_isRunning)\n                {\n                    _currentState = VaultState.Idle;\n                }\n                break;\n                \n            case VaultState.Vaulting:\n                if (!_isPoleInGround)\n                {\n                    _currentState = VaultState.Airborne;\n                }\n                break;\n                \n            case VaultState.Airborne:\n                if (_isGrounded && _velocity.y <= 0)\n                {\n                    _currentState = VaultState.Landing;\n                    OnLanding?.Invoke();\n                }\n                break;\n                \n            case VaultState.Landing:\n                if (_velocity.magnitude < 0.5f)\n                {\n                    _currentState = VaultState.Idle;\n                }\n                break;\n        }\n    }\n    \n    void ApplyPhysics()\n    {\n        if (!_isGrounded || _currentState == VaultState.Vaulting || _currentState == VaultState.Airborne)\n        {\n            _velocity.y += _gravity * Time.fixedDeltaTime;\n            _velocity *= _airDrag;\n        }\n        else if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = 0;\n        }\n    }\n    \n    void UpdateMovement()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Running:\n                Vector3 runDirection = transform.forward;\n                _velocity = runDirection * _runSpeed;\n                break;\n                \n            case VaultState.PoleContact:\n                CalculateVaultTrajectory();\n                break;\n                \n            case VaultState.Vaulting:\n                PerformVault();\n                break;\n        }\n        \n        if (_velocity.magnitude > 0.01f)\n        {\n            _rigidbody.velocity = _velocity;\n        }\n    }\n    \n    void StartRun()\n    {\n        _isRunning = true;\n        _currentState = VaultState.Running;\n        _runStartPosition = transform.position;\n        _runDistance = 0f;\n        OnRunStart?.Invoke();\n    }\n    \n    void StopRun()\n    {\n        _isRunning = false;\n        _velocity = Vector3.zero;\n    }\n    \n    void PlantPole()\n    {\n        Vector3 poleDirection = transform.forward;\n        Vector3 poleEndPosition = transform.position + poleDirection * _poleLength;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, poleDirection, out hit, _poleLength, _groundLayer))\n        {\n            _poleContactPoint = hit.point;\n            _isPoleInGround = true;\n            _currentState = VaultState.PoleContact;\n            \n            float distanceToContact = Vector3.Distance(transform.position, _poleContactPoint);\n            _vaultAngle = Mathf.Atan2(distanceToContact, transform.position.y - _poleContactPoint.y) * Mathf.Rad2Deg;\n        }\n    }\n    \n    void CalculateVaultTrajectory()\n    {\n        Vector3 directionToPole = (_poleContactPoint - transform.position).normalized;\n        float currentSpeed = _velocity.magnitude;\n        \n        Vector3 vaultDirection = Vector3.up + directionToPole;\n        vaultDirection.Normalize();\n        \n        _velocity = vaultDirection * (currentSpeed + _vaultForce * 0.5f);\n        _currentState = VaultState.Vaulting;\n        OnPoleVault?.Invoke();\n    }\n    \n    void PerformVault()\n    {\n        Vector3 toPole = _poleContactPoint - transform.position;\n        float distanceToPole = toPole.magnitude;\n        \n        if (distanceToPole > _poleLength * 1.2f)\n        {\n            ReleasePole();\n            return;\n        }\n        \n        Vector3 centripetal = toPole.normalized * (_velocity.magnitude * _velocity.magnitude / distanceToPole);\n        _velocity += centripetal * Time.fixedDeltaTime * 0.1f;\n        \n        Vector3 upwardForce = Vector3.up * _vaultForce * Time.fixedDeltaTime;\n        _velocity += upwardForce;\n    }\n    \n    void ReleasePole()\n    {\n        _isPoleInGround = false;\n        _currentState = VaultState.Airborne;\n        \n        Vector3 releaseBoost = Vector3.up * _vaultForce * 0.3f;\n        _velocity += releaseBoost;\n    }\n    \n    void SetupPoleVisual()\n    {\n        if (_poleRenderer == null && _poleTransform != null)\n        {\n            _poleRenderer = _poleTransform.GetComponent<LineRenderer>();\n            if (_poleRenderer == null)\n            {\n                _poleRenderer = _poleTransform.gameObject.AddComponent<LineRenderer>();\n            }\n        }\n        \n        if (_poleRenderer != null)\n        {\n            _poleRenderer.positionCount = 2;\n            _poleRenderer.startWidth = 0.05f;\n            _poleRenderer.endWidth = 0.02f;\n            _poleRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n            _poleRenderer.color = Color.brown;\n        }\n    }\n    \n    void UpdatePoleVisual()\n    {\n        if (_poleRenderer == null) return;\n        \n        bool showPole = _currentState == VaultState.PoleContact || _currentState == VaultState.Vaulting;\n        _poleRenderer.enabled = showPole;\n        \n        if (showPole && _isPoleInGround)\n        {\n            Vector3 handPosition = transform.position + Vector3.up * 1.8f;\n            _poleRenderer.SetPosition(0, handPosition);\n            _poleRenderer.SetPosition(1, _poleContactPoint);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _minRunDistance);\n        \n        if (_isPoleInGround)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawSphere(_poleContactPoint, 0.2f);\n            Gizmos.DrawLine(transform.position, _poleContactPoint);\n        }\n        \n        Gizmos.color = Color.blue;\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        Gizmos.DrawRay(rayStart, Vector3.down * (_groundCheckDistance + 0.1f));\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "rope climbing",
      "ideal_ir": {
        "class_name": "RopeClimbing",
        "components": [
          "Rigidbody",
          "CapsuleCollider",
          "Animator"
        ],
        "fields": [
          {
            "name": "climbSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "grabRange",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isClimbing",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentRope",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "grab_rope",
            "trigger": "when player presses grab button and is near a rope",
            "actions": [
              {
                "action": "attach player to the rope"
              },
              {
                "action": "disable gravity on player"
              },
              {
                "action": "set climbing state to true"
              },
              {
                "action": "play grab animation"
              }
            ]
          },
          {
            "name": "climb_up",
            "trigger": "when climbing and player holds up input",
            "actions": [
              {
                "action": "move player upward along rope at climb speed"
              },
              {
                "action": "play climbing up animation"
              },
              {
                "action": "rotate player to face rope direction"
              }
            ]
          },
          {
            "name": "climb_down",
            "trigger": "when climbing and player holds down input",
            "actions": [
              {
                "action": "move player downward along rope at climb speed"
              },
              {
                "action": "play climbing down animation"
              },
              {
                "action": "rotate player to face rope direction"
              }
            ]
          },
          {
            "name": "release_rope",
            "trigger": "when climbing and player presses jump or grab button",
            "actions": [
              {
                "action": "detach player from rope"
              },
              {
                "action": "enable gravity on player"
              },
              {
                "action": "set climbing state to false"
              },
              {
                "action": "apply small outward force to player"
              },
              {
                "action": "play release animation"
              }
            ]
          },
          {
            "name": "rope_idle",
            "trigger": "when climbing and no movement input is pressed",
            "actions": [
              {
                "action": "keep player attached to current rope position"
              },
              {
                "action": "play idle hanging animation"
              },
              {
                "action": "maintain rope grip"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RopeClimbing : MonoBehaviour\n{\n    [Header(\"Rope Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private float _slideSpeed = 1f;\n    [SerializeField] private float _grabDistance = 1.5f;\n    [SerializeField] private LayerMask _ropeLayer = 1;\n    [SerializeField] private string _ropeTag = \"Rope\";\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private string _verticalAxis = \"Vertical\";\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private float _swayForce = 2f;\n    [SerializeField] private float _maxSwayAngle = 30f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _climbSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRopeGrabbed;\n    public UnityEvent OnRopeReleased;\n    public UnityEvent OnReachedTop;\n    public UnityEvent OnReachedBottom;\n    \n    private Rigidbody2D _rigidbody;\n    private Collider2D _collider;\n    private AudioSource _audioSource;\n    private Transform _currentRope;\n    private bool _isClimbing;\n    private bool _wasGrounded;\n    private float _originalGravityScale;\n    private Vector2 _ropeGrabPoint;\n    private float _ropeLength;\n    private float _currentRopePosition;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _collider = GetComponent<Collider2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"RopeClimbing requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalGravityScale = _rigidbody.gravityScale;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (_isClimbing)\n        {\n            HandleClimbing();\n            HandleSwaying();\n            CheckRopeBounds();\n        }\n        else\n        {\n            CheckForNearbyRope();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (_isClimbing)\n            {\n                ReleaseRope();\n            }\n            else\n            {\n                TryGrabRope();\n            }\n        }\n    }\n    \n    private void CheckForNearbyRope()\n    {\n        Collider2D[] nearbyRopes = Physics2D.OverlapCircleAll(transform.position, _grabDistance, _ropeLayer);\n        \n        foreach (var rope in nearbyRopes)\n        {\n            if (rope.CompareTag(_ropeTag))\n            {\n                // Visual feedback could be added here\n                break;\n            }\n        }\n    }\n    \n    private void TryGrabRope()\n    {\n        Collider2D[] nearbyRopes = Physics2D.OverlapCircleAll(transform.position, _grabDistance, _ropeLayer);\n        \n        foreach (var rope in nearbyRopes)\n        {\n            if (rope.CompareTag(_ropeTag))\n            {\n                GrabRope(rope.transform);\n                break;\n            }\n        }\n    }\n    \n    private void GrabRope(Transform rope)\n    {\n        _currentRope = rope;\n        _isClimbing = true;\n        _rigidbody.gravityScale = 0f;\n        _rigidbody.velocity = Vector2.zero;\n        \n        // Calculate rope grab point and length\n        _ropeGrabPoint = _currentRope.position;\n        _ropeLength = _currentRope.localScale.y;\n        \n        // Calculate current position on rope (0 = bottom, 1 = top)\n        float distanceFromBottom = Vector2.Distance(transform.position, _ropeGrabPoint - Vector3.up * _ropeLength * 0.5f);\n        _currentRopePosition = Mathf.Clamp01(distanceFromBottom / _ropeLength);\n        \n        // Position player on rope\n        Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n        transform.position = new Vector3(ropePosition.x, transform.position.y, transform.position.z);\n        \n        PlaySound(_grabSound);\n        OnRopeGrabbed?.Invoke();\n    }\n    \n    private void ReleaseRope()\n    {\n        _currentRope = null;\n        _isClimbing = false;\n        _rigidbody.gravityScale = _originalGravityScale;\n        \n        PlaySound(_releaseSound);\n        OnRopeReleased?.Invoke();\n    }\n    \n    private void HandleClimbing()\n    {\n        if (_currentRope == null)\n        {\n            ReleaseRope();\n            return;\n        }\n        \n        float verticalInput = Input.GetAxis(_verticalAxis);\n        \n        if (Mathf.Abs(verticalInput) > 0.1f)\n        {\n            // Move along rope\n            float moveSpeed = verticalInput > 0 ? _climbSpeed : _slideSpeed;\n            _currentRopePosition += verticalInput * moveSpeed * Time.deltaTime / _ropeLength;\n            _currentRopePosition = Mathf.Clamp01(_currentRopePosition);\n            \n            // Update position\n            Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n            transform.position = new Vector3(ropePosition.x, ropePosition.y, transform.position.z);\n            \n            // Play climbing sound\n            if (_audioSource != null && _climbSound != null && !_audioSource.isPlaying)\n            {\n                PlaySound(_climbSound);\n            }\n        }\n    }\n    \n    private void HandleSwaying()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(horizontalInput) > 0.1f)\n        {\n            // Apply sway force to the rope (if it has physics)\n            Rigidbody2D ropeRb = _currentRope.GetComponent<Rigidbody2D>();\n            if (ropeRb != null)\n            {\n                Vector2 swayForce = Vector2.right * horizontalInput * _swayForce;\n                ropeRb.AddForceAtPosition(swayForce, transform.position);\n            }\n            else\n            {\n                // Simple sway animation for static ropes\n                float swayAmount = Mathf.Sin(Time.time * 3f) * horizontalInput * 0.5f;\n                swayAmount = Mathf.Clamp(swayAmount, -_maxSwayAngle, _maxSwayAngle);\n                \n                Vector3 swayOffset = Vector3.right * swayAmount * 0.1f;\n                Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n                transform.position = new Vector3(ropePosition.x + swayOffset.x, ropePosition.y, transform.position.z);\n            }\n        }\n    }\n    \n    private void CheckRopeBounds()\n    {\n        if (_currentRopePosition >= 0.95f)\n        {\n            OnReachedTop?.Invoke();\n        }\n        else if (_currentRopePosition <= 0.05f)\n        {\n            OnReachedBottom?.Invoke();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerExit2D(Collider2D other)\n    {\n        if (_isClimbing && other.transform == _currentRope)\n        {\n            ReleaseRope();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw grab distance\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _grabDistance);\n        \n        // Draw rope connection when climbing\n        if (_isClimbing && _currentRope != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentRope.position);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "swimming dive",
      "ideal_ir": {
        "class_name": "SwimmingDive",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "diveSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "surfaceSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "maxDiveDepth",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "oxygenCapacity",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "oxygenDrainRate",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isUnderwater",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentOxygen",
            "type": "float",
            "default": 100.0
          }
        ],
        "behaviors": [
          {
            "name": "initiate_dive",
            "trigger": "when dive input is pressed and character is at water surface",
            "actions": [
              {
                "action": "play diving animation"
              },
              {
                "action": "set underwater state to true"
              },
              {
                "action": "apply downward diving force"
              },
              {
                "action": "start oxygen consumption"
              }
            ]
          },
          {
            "name": "underwater_movement",
            "trigger": "when character is underwater and movement input is detected",
            "actions": [
              {
                "action": "move in input direction at dive speed"
              },
              {
                "action": "apply water resistance to movement"
              },
              {
                "action": "play swimming animation"
              }
            ]
          },
          {
            "name": "surface_ascent",
            "trigger": "when surface input is pressed or oxygen is low",
            "actions": [
              {
                "action": "apply upward buoyancy force"
              },
              {
                "action": "move toward water surface at surface speed"
              },
              {
                "action": "play ascending animation"
              }
            ]
          },
          {
            "name": "reach_surface",
            "trigger": "when character reaches water surface level",
            "actions": [
              {
                "action": "set underwater state to false"
              },
              {
                "action": "stop oxygen consumption"
              },
              {
                "action": "restore oxygen to full capacity"
              },
              {
                "action": "play surface breach animation"
              }
            ]
          },
          {
            "name": "oxygen_depletion",
            "trigger": "when underwater and oxygen reaches zero",
            "actions": [
              {
                "action": "force immediate surface ascent"
              },
              {
                "action": "apply health damage over time"
              },
              {
                "action": "play drowning effects"
              }
            ]
          },
          {
            "name": "depth_limit_check",
            "trigger": "when diving depth exceeds maximum dive depth",
            "actions": [
              {
                "action": "prevent further downward movement"
              },
              {
                "action": "apply pressure damage"
              },
              {
                "action": "increase oxygen drain rate"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SwimmingDive : MonoBehaviour\n{\n    [Header(\"Dive Settings\")]\n    [SerializeField] private float _diveForce = 15f;\n    [SerializeField] private float _diveAngle = 45f;\n    [SerializeField] private float _underwaterDrag = 5f;\n    [SerializeField] private float _surfaceDrag = 1f;\n    [SerializeField] private float _buoyancyForce = 10f;\n    [SerializeField] private float _maxDiveDepth = 20f;\n    \n    [Header(\"Water Detection\")]\n    [SerializeField] private LayerMask _waterLayer = 1;\n    [SerializeField] private Transform _waterCheckPoint;\n    [SerializeField] private float _waterCheckRadius = 0.5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _diveKey = KeyCode.Space;\n    [SerializeField] private KeyCode _surfaceKey = KeyCode.LeftShift;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _diveAnimationTrigger = \"Dive\";\n    [SerializeField] private string _swimAnimationBool = \"IsSwimming\";\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _underwaterSound;\n    \n    private Rigidbody _rigidbody;\n    private bool _isUnderwater;\n    private bool _canDive = true;\n    private float _originalDrag;\n    private float _waterSurfaceY;\n    private Vector3 _diveStartPosition;\n    private float _currentDepth;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"SwimmingDive requires a Rigidbody component!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        \n        if (_waterCheckPoint == null)\n            _waterCheckPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        CheckWaterStatus();\n        HandleInput();\n        UpdateAnimations();\n        ApplyBuoyancy();\n        UpdateDepth();\n    }\n    \n    private void CheckWaterStatus()\n    {\n        bool wasUnderwater = _isUnderwater;\n        _isUnderwater = Physics.CheckSphere(_waterCheckPoint.position, _waterCheckRadius, _waterLayer);\n        \n        if (_isUnderwater != wasUnderwater)\n        {\n            OnWaterStatusChanged(_isUnderwater);\n        }\n        \n        if (_isUnderwater)\n        {\n            _rigidbody.drag = _underwaterDrag;\n            \n            Collider waterCollider = Physics.OverlapSphere(_waterCheckPoint.position, _waterCheckRadius, _waterLayer)[0];\n            if (waterCollider != null)\n            {\n                _waterSurfaceY = waterCollider.bounds.max.y;\n            }\n        }\n        else\n        {\n            _rigidbody.drag = _originalDrag;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_diveKey) && _canDive)\n        {\n            if (_isUnderwater)\n            {\n                PerformUnderwaterDive();\n            }\n            else\n            {\n                PerformSurfaceDive();\n            }\n        }\n        \n        if (Input.GetKey(_surfaceKey) && _isUnderwater)\n        {\n            SwimToSurface();\n        }\n    }\n    \n    private void PerformSurfaceDive()\n    {\n        Vector3 diveDirection = Quaternion.AngleAxis(-_diveAngle, transform.right) * transform.forward;\n        _rigidbody.AddForce(diveDirection * _diveForce, ForceMode.Impulse);\n        \n        _diveStartPosition = transform.position;\n        _canDive = false;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_diveAnimationTrigger);\n            \n        if (_splashEffect != null && !_isUnderwater)\n            _splashEffect.Play();\n            \n        PlaySound(_splashSound);\n        \n        Invoke(nameof(ResetDiveAbility), 1f);\n    }\n    \n    private void PerformUnderwaterDive()\n    {\n        Vector3 diveDirection = -transform.up;\n        _rigidbody.AddForce(diveDirection * _diveForce * 0.7f, ForceMode.Impulse);\n        \n        _canDive = false;\n        Invoke(nameof(ResetDiveAbility), 0.5f);\n    }\n    \n    private void SwimToSurface()\n    {\n        Vector3 surfaceDirection = Vector3.up;\n        _rigidbody.AddForce(surfaceDirection * _buoyancyForce * 1.5f, ForceMode.Force);\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isUnderwater)\n        {\n            float buoyancyMultiplier = Mathf.Clamp01(_currentDepth / _maxDiveDepth);\n            Vector3 buoyancyForceVector = Vector3.up * _buoyancyForce * buoyancyMultiplier;\n            _rigidbody.AddForce(buoyancyForceVector, ForceMode.Force);\n            \n            if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n                _bubbleEffect.Play();\n        }\n        else\n        {\n            if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n                _bubbleEffect.Stop();\n        }\n    }\n    \n    private void UpdateDepth()\n    {\n        if (_isUnderwater)\n        {\n            _currentDepth = Mathf.Max(0, _waterSurfaceY - transform.position.y);\n            \n            if (_currentDepth > _maxDiveDepth)\n            {\n                Vector3 position = transform.position;\n                position.y = _waterSurfaceY - _maxDiveDepth;\n                transform.position = position;\n                _currentDepth = _maxDiveDepth;\n            }\n        }\n        else\n        {\n            _currentDepth = 0f;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(_swimAnimationBool, _isUnderwater);\n        }\n    }\n    \n    private void OnWaterStatusChanged(bool enteredWater)\n    {\n        if (enteredWater)\n        {\n            PlaySound(_underwaterSound);\n            if (_splashEffect != null)\n                _splashEffect.Play();\n        }\n        else\n        {\n            if (_audioSource != null && _audioSource.clip == _underwaterSound)\n                _audioSource.Stop();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    private void ResetDiveAbility()\n    {\n        _canDive = true;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_waterCheckPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_waterCheckPoint.position, _waterCheckRadius);\n        }\n        \n        Gizmos.color = Color.red;\n        Vector3 diveDirection = Quaternion.AngleAxis(-_diveAngle, transform.right) * transform.forward;\n        Gizmos.DrawRay(transform.position, diveDirection * 3f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "underwater breath timer",
      "ideal_ir": {
        "class_name": "UnderwaterBreathTimer",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "maxBreathTime",
            "type": "float",
            "default": 30
          },
          {
            "name": "currentBreathTime",
            "type": "float",
            "default": 30
          },
          {
            "name": "breathDepletionRate",
            "type": "float",
            "default": 1
          },
          {
            "name": "breathRecoveryRate",
            "type": "float",
            "default": 2
          },
          {
            "name": "isUnderwater",
            "type": "bool",
            "default": false
          },
          {
            "name": "lowBreathThreshold",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "deplete_breath_underwater",
            "trigger": "when player is underwater",
            "actions": [
              {
                "action": "decrease current breath time over time"
              },
              {
                "action": "prevent breath time from going below zero"
              }
            ]
          },
          {
            "name": "recover_breath_above_water",
            "trigger": "when player is above water",
            "actions": [
              {
                "action": "increase current breath time over time"
              },
              {
                "action": "prevent breath time from exceeding maximum breath time"
              }
            ]
          },
          {
            "name": "trigger_low_breath_warning",
            "trigger": "when current breath time is below low breath threshold",
            "actions": [
              {
                "action": "display low breath warning indicator"
              }
            ]
          },
          {
            "name": "trigger_drowning",
            "trigger": "when current breath time reaches zero",
            "actions": [
              {
                "action": "start drowning damage over time"
              },
              {
                "action": "display critical breath warning"
              }
            ]
          },
          {
            "name": "stop_drowning",
            "trigger": "when player surfaces and breath time is above zero",
            "actions": [
              {
                "action": "stop drowning damage"
              },
              {
                "action": "hide breath warning indicators"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class UnderwaterBreathTimer : MonoBehaviour\n{\n    [Header(\"Breath Settings\")]\n    [SerializeField] private float _maxBreathTime = 30f;\n    [SerializeField] private float _breathRecoveryRate = 2f;\n    [SerializeField] private float _breathDrainRate = 1f;\n    [SerializeField] private float _lowBreathThreshold = 0.3f;\n    \n    [Header(\"Water Detection\")]\n    [SerializeField] private string _waterTag = \"Water\";\n    [SerializeField] private Transform _breathCheckPoint;\n    [SerializeField] private LayerMask _waterLayerMask = -1;\n    [SerializeField] private float _checkRadius = 0.1f;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private Slider _breathBar;\n    [SerializeField] private Image _breathBarFill;\n    [SerializeField] private GameObject _breathUI;\n    [SerializeField] private Color _normalBreathColor = Color.blue;\n    [SerializeField] private Color _lowBreathColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _drowningSound;\n    [SerializeField] private AudioClip _gasping Sound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBreathDepleted;\n    public UnityEvent OnStartDrowning;\n    public UnityEvent OnStopDrowning;\n    public UnityEvent OnSurfaced;\n    public UnityEvent OnSubmerged;\n    \n    private float _currentBreathTime;\n    private bool _isUnderwater = false;\n    private bool _isDrowning = false;\n    private float _lastDamageTime;\n    private bool _wasUnderwater = false;\n    private Coroutine _breathingCoroutine;\n    \n    private void Start()\n    {\n        _currentBreathTime = _maxBreathTime;\n        \n        if (_breathCheckPoint == null)\n            _breathCheckPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        InitializeUI();\n    }\n    \n    private void Update()\n    {\n        CheckWaterStatus();\n        UpdateBreathTimer();\n        UpdateUI();\n        HandleAudio();\n    }\n    \n    private void CheckWaterStatus()\n    {\n        bool currentlyUnderwater = IsUnderwater();\n        \n        if (currentlyUnderwater != _wasUnderwater)\n        {\n            if (currentlyUnderwater)\n            {\n                OnSubmerged?.Invoke();\n                StartBreathing();\n            }\n            else\n            {\n                OnSurfaced?.Invoke();\n                StopBreathing();\n            }\n        }\n        \n        _isUnderwater = currentlyUnderwater;\n        _wasUnderwater = currentlyUnderwater;\n    }\n    \n    private bool IsUnderwater()\n    {\n        Collider[] waterColliders = Physics.OverlapSphere(_breathCheckPoint.position, _checkRadius, _waterLayerMask);\n        \n        foreach (Collider collider in waterColliders)\n        {\n            if (collider.CompareTag(_waterTag))\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void UpdateBreathTimer()\n    {\n        if (_isUnderwater)\n        {\n            _currentBreathTime -= _breathDrainRate * Time.deltaTime;\n            _currentBreathTime = Mathf.Max(0f, _currentBreathTime);\n            \n            if (_currentBreathTime <= 0f && !_isDrowning)\n            {\n                StartDrowning();\n            }\n        }\n        else\n        {\n            if (_isDrowning)\n            {\n                StopDrowning();\n            }\n            \n            _currentBreathTime += _breathRecoveryRate * Time.deltaTime;\n            _currentBreathTime = Mathf.Min(_maxBreathTime, _currentBreathTime);\n        }\n    }\n    \n    private void StartBreathing()\n    {\n        if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Play();\n        }\n    }\n    \n    private void StopBreathing()\n    {\n        if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_gaspingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_gaspingSound);\n        }\n    }\n    \n    private void StartDrowning()\n    {\n        _isDrowning = true;\n        _lastDamageTime = Time.time;\n        OnStartDrowning?.Invoke();\n        OnBreathDepleted?.Invoke();\n    }\n    \n    private void StopDrowning()\n    {\n        _isDrowning = false;\n        OnStopDrowning?.Invoke();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isDrowning && Time.time >= _lastDamageTime + _damageInterval)\n        {\n            ApplyDrowningDamage();\n            _lastDamageTime = Time.time;\n        }\n    }\n    \n    private void ApplyDrowningDamage()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            // Try to find health component\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send damage message that can be received by any health system\n                player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void InitializeUI()\n    {\n        if (_breathBar != null)\n        {\n            _breathBar.maxValue = _maxBreathTime;\n            _breathBar.value = _currentBreathTime;\n        }\n        \n        if (_breathUI != null)\n        {\n            _breathUI.SetActive(false);\n        }\n        \n        UpdateBreathBarColor();\n    }\n    \n    private void UpdateUI()\n    {\n        if (_breathUI != null)\n        {\n            _breathUI.SetActive(_isUnderwater || _currentBreathTime < _maxBreathTime);\n        }\n        \n        if (_breathBar != null)\n        {\n            _breathBar.value = _currentBreathTime;\n        }\n        \n        UpdateBreathBarColor();\n    }\n    \n    private void UpdateBreathBarColor()\n    {\n        if (_breathBarFill != null)\n        {\n            float breathPercentage = _currentBreathTime / _maxBreathTime;\n            \n            if (breathPercentage <= _lowBreathThreshold)\n            {\n                _breathBarFill.color = Color.Lerp(_lowBreathColor, _normalBreathColor, \n                    breathPercentage / _lowBreathThreshold);\n            }\n            else\n            {\n                _breathBarFill.color = _normalBreathColor;\n            }\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null) return;\n        \n        if (_isDrowning && _drowningSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _drowningSound)\n            {\n                _audioSource.clip = _drowningSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        else if (_isUnderwater && _breathingSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _breathingSound)\n            {\n                _audioSource.clip = _breathingSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        else if (!_isUnderwater && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public void AddBreathTime(float amount)\n    {\n        _currentBreathTime += amount;\n        _currentBreathTime = Mathf.Min(_maxBreathTime, _currentBreathTime);\n        \n        if (_isDrowning && _currentBreathTime > 0f)\n        {\n            StopDrowning();\n        }\n    }\n    \n    public void SetMaxBreathTime(float newMaxTime)\n    {\n        float ratio = _currentBreathTime / _maxBreathTime;\n        _maxBreathTime = newMaxTime;\n        _currentBreathTime = _maxBreathTime * ratio;\n        \n        if (_breathBar != null)\n        {\n            _breathBar.maxValue = _maxBreathTime;\n        }\n    }\n    \n    public float GetBreathPercentage()\n    {\n        return _currentBreathTime / _maxBreathTime;\n    }\n    \n    public bool IsCurrentlyDrowning()\n    {\n        return _isDrowning;\n    }\n    \n    public bool IsCurrentlyUnderwater()\n    {\n        return _isUnderwater;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_breathCheckPoint != null)\n        {\n            Gizmos.color = _isUnderwater ? Color.blue : Color.green;\n            Gizmos.DrawWireSphere(_breathCheckPoint.position, _checkRadius);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "jetpack flight",
      "ideal_ir": {
        "class_name": "JetpackFlight",
        "components": [
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "thrustForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "fuelCapacity",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentFuel",
            "type": "float",
            "default": 100
          },
          {
            "name": "fuelConsumptionRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "maxFlightSpeed",
            "type": "float",
            "default": 10
          },
          {
            "name": "isFlying",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_jetpack",
            "trigger": "when jump input is held and current fuel is greater than zero",
            "actions": [
              {
                "action": "set flying state to true"
              },
              {
                "action": "apply upward thrust force"
              },
              {
                "action": "play jetpack engine sound"
              },
              {
                "action": "consume fuel over time"
              }
            ]
          },
          {
            "name": "deactivate_jetpack",
            "trigger": "when jump input is released or fuel runs out",
            "actions": [
              {
                "action": "set flying state to false"
              },
              {
                "action": "stop applying thrust force"
              },
              {
                "action": "stop jetpack engine sound"
              }
            ]
          },
          {
            "name": "limit_flight_speed",
            "trigger": "when flying and velocity exceeds maximum flight speed",
            "actions": [
              {
                "action": "clamp velocity to maximum flight speed"
              }
            ]
          },
          {
            "name": "regenerate_fuel",
            "trigger": "when not flying and current fuel is below capacity",
            "actions": [
              {
                "action": "slowly restore fuel over time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class JetpackFlight : MonoBehaviour\n{\n    [Header(\"Jetpack Settings\")]\n    [SerializeField] private float _thrustForce = 15f;\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _fuelConsumptionRate = 20f;\n    [SerializeField] private float _fuelRegenRate = 10f;\n    [SerializeField] private float _maxSpeed = 20f;\n    [SerializeField] private bool _requiresFuel = true;\n    \n    [Header(\"Controls\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseInput = false;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _drag = 2f;\n    [SerializeField] private float _angularDrag = 5f;\n    [SerializeField] private bool _stabilizeRotation = true;\n    [SerializeField] private float _stabilizationForce = 50f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _thrustParticles;\n    [SerializeField] private AudioSource _thrustAudio;\n    [SerializeField] private Transform _thrustPoint;\n    [SerializeField] private float _screenShakeIntensity = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnJetpackStart;\n    public UnityEvent OnJetpackStop;\n    public UnityEvent OnFuelEmpty;\n    public UnityEvent<float> OnFuelChanged;\n    \n    private Rigidbody _rigidbody;\n    private float _currentFuel;\n    private bool _isThrusting;\n    private Vector3 _thrustDirection;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n    }\n    \n    private void Start()\n    {\n        _currentFuel = _maxFuel;\n        _rigidbody.drag = _drag;\n        _rigidbody.angularDrag = _angularDrag;\n        \n        if (_thrustPoint == null)\n        {\n            _thrustPoint = transform;\n        }\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateFuel();\n        UpdateEffects();\n        UpdateScreenShake();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isThrusting && CanThrust())\n        {\n            ApplyThrust();\n        }\n        \n        if (_stabilizeRotation && !_isThrusting)\n        {\n            StabilizeRotation();\n        }\n        \n        LimitSpeed();\n    }\n    \n    private void HandleInput()\n    {\n        bool thrustInput = false;\n        \n        if (_useMouseInput)\n        {\n            thrustInput = Input.GetMouseButton(0);\n            \n            Vector3 mousePosition = Input.mousePosition;\n            Vector3 worldPosition = _mainCamera.ScreenToWorldPoint(new Vector3(mousePosition.x, mousePosition.y, 10f));\n            _thrustDirection = (worldPosition - transform.position).normalized;\n        }\n        else\n        {\n            thrustInput = Input.GetKey(_thrustKey);\n            \n            float horizontal = Input.GetAxis(\"Horizontal\");\n            float vertical = Input.GetAxis(\"Vertical\");\n            _thrustDirection = new Vector3(horizontal, vertical, 0f).normalized;\n            \n            if (_thrustDirection == Vector3.zero)\n            {\n                _thrustDirection = transform.up;\n            }\n        }\n        \n        if (thrustInput && CanThrust() && !_isThrusting)\n        {\n            StartThrust();\n        }\n        else if (!thrustInput && _isThrusting)\n        {\n            StopThrust();\n        }\n    }\n    \n    private bool CanThrust()\n    {\n        return !_requiresFuel || _currentFuel > 0f;\n    }\n    \n    private void StartThrust()\n    {\n        _isThrusting = true;\n        OnJetpackStart?.Invoke();\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Play();\n        }\n        \n        if (_thrustAudio != null && !_thrustAudio.isPlaying)\n        {\n            _thrustAudio.Play();\n        }\n    }\n    \n    private void StopThrust()\n    {\n        _isThrusting = false;\n        OnJetpackStop?.Invoke();\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Stop();\n        }\n        \n        if (_thrustAudio != null)\n        {\n            _thrustAudio.Stop();\n        }\n    }\n    \n    private void ApplyThrust()\n    {\n        Vector3 force = _thrustDirection * _thrustForce;\n        _rigidbody.AddForce(force, ForceMode.Acceleration);\n        \n        if (_thrustPoint != null)\n        {\n            _rigidbody.AddForceAtPosition(force, _thrustPoint.position, ForceMode.Acceleration);\n        }\n    }\n    \n    private void UpdateFuel()\n    {\n        if (!_requiresFuel) return;\n        \n        if (_isThrusting && _currentFuel > 0f)\n        {\n            _currentFuel -= _fuelConsumptionRate * Time.deltaTime;\n            _currentFuel = Mathf.Max(0f, _currentFuel);\n            \n            if (_currentFuel <= 0f)\n            {\n                StopThrust();\n                OnFuelEmpty?.Invoke();\n            }\n        }\n        else if (!_isThrusting && _currentFuel < _maxFuel)\n        {\n            _currentFuel += _fuelRegenRate * Time.deltaTime;\n            _currentFuel = Mathf.Min(_maxFuel, _currentFuel);\n        }\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_thrustParticles != null)\n        {\n            if (_isThrusting && CanThrust())\n            {\n                if (!_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Play();\n                }\n                \n                var main = _thrustParticles.main;\n                main.startSpeed = _thrustForce * 0.5f;\n            }\n            else if (_thrustParticles.isPlaying)\n            {\n                _thrustParticles.Stop();\n            }\n        }\n        \n        if (_thrustAudio != null)\n        {\n            if (_isThrusting && CanThrust())\n            {\n                if (!_thrustAudio.isPlaying)\n                {\n                    _thrustAudio.Play();\n                }\n                _thrustAudio.volume = Mathf.Lerp(0.1f, 1f, _rigidbody.velocity.magnitude / _maxSpeed);\n            }\n            else if (_thrustAudio.isPlaying)\n            {\n                _thrustAudio.Stop();\n            }\n        }\n    }\n    \n    private void UpdateScreenShake()\n    {\n        if (_mainCamera == null || _screenShakeIntensity <= 0f) return;\n        \n        if (_isThrusting && CanThrust())\n        {\n            Vector3 shake = Random.insideUnitSphere * _screenShakeIntensity;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shake;\n        }\n        else\n        {\n            _mainCamera.transform.localPosition = Vector3.Lerp(_mainCamera.transform.localPosition, _originalCameraPosition, Time.deltaTime * 10f);\n        }\n    }\n    \n    private void StabilizeRotation()\n    {\n        Vector3 targetUp = Vector3.up;\n        Vector3 currentUp = transform.up;\n        Vector3 torque = Vector3.Cross(currentUp, targetUp) * _stabilizationForce;\n        _rigidbody.AddTorque(torque, ForceMode.Acceleration);\n    }\n    \n    private void LimitSpeed()\n    {\n        if (_rigidbody.velocity.magnitude > _maxSpeed)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n        }\n    }\n    \n    public void RefillFuel()\n    {\n        _currentFuel = _maxFuel;\n        OnFuelChanged?.Invoke(1f);\n    }\n    \n    public void SetFuel(float amount)\n    {\n        _currentFuel = Mathf.Clamp(amount, 0f, _maxFuel);\n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return _currentFuel / _maxFuel;\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    public void SetThrustForce(float force)\n    {\n        _thrustForce = Mathf.Max(0f, force);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_thrustPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_thrustPoint.position, 0.5f);\n            \n            if (_isThrusting)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawRay(_thrustPoint.position, -_thrustDirection * 2f);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "wing glide",
      "ideal_ir": {
        "class_name": "WingGlide",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "glideSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "liftForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "dragCoefficient",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "minGlideHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "wingSpread",
            "type": "float",
            "default": 1.5
          }
        ],
        "behaviors": [
          {
            "name": "start_gliding",
            "trigger": "when jump input is held while in air",
            "actions": [
              {
                "action": "spread wings and enter glide mode"
              },
              {
                "action": "reduce falling speed significantly"
              },
              {
                "action": "apply forward momentum in facing direction"
              }
            ]
          },
          {
            "name": "maintain_glide",
            "trigger": "while gliding and above minimum height",
            "actions": [
              {
                "action": "apply upward lift force to counteract gravity"
              },
              {
                "action": "maintain forward gliding motion"
              },
              {
                "action": "apply air resistance to control speed"
              }
            ]
          },
          {
            "name": "steer_while_gliding",
            "trigger": "when horizontal input is received during glide",
            "actions": [
              {
                "action": "tilt wings in input direction"
              },
              {
                "action": "gradually turn glide direction"
              },
              {
                "action": "adjust lift distribution between wings"
              }
            ]
          },
          {
            "name": "end_glide",
            "trigger": "when jump input is released or ground is reached",
            "actions": [
              {
                "action": "fold wings back to normal position"
              },
              {
                "action": "restore normal falling physics"
              },
              {
                "action": "exit glide mode"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class WingGlide : MonoBehaviour\n{\n    [Header(\"Glide Settings\")]\n    [SerializeField] private float _glideSpeed = 8f;\n    [SerializeField] private float _glideGravity = 2f;\n    [SerializeField] private float _normalGravity = 9.81f;\n    [SerializeField] private float _maxGlideTime = 10f;\n    [SerializeField] private KeyCode _glideKey = KeyCode.Space;\n    \n    [Header(\"Wing Animation\")]\n    [SerializeField] private Transform _leftWing;\n    [SerializeField] private Transform _rightWing;\n    [SerializeField] private float _wingFlapSpeed = 2f;\n    [SerializeField] private float _wingFlapAmount = 15f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _glideStartSound;\n    [SerializeField] private AudioClip _glideLoopSound;\n    [SerializeField] private AudioClip _glideEndSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _windTrailEffect;\n    [SerializeField] private Transform _cameraTransform;\n    [SerializeField] private float _cameraShakeAmount = 0.1f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGliding = false;\n    private float _currentGlideTime = 0f;\n    private Vector3 _originalCameraPosition;\n    private float _wingFlapTimer = 0f;\n    private bool _canGlide = true;\n    private float _glideStamina = 100f;\n    private float _maxGlideStamina = 100f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_cameraTransform == null)\n        {\n            Camera mainCamera = Camera.main;\n            if (mainCamera != null)\n            {\n                _cameraTransform = mainCamera.transform;\n            }\n        }\n        \n        if (_cameraTransform != null)\n        {\n            _originalCameraPosition = _cameraTransform.localPosition;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _glideStamina = _maxGlideStamina;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWingAnimation();\n        UpdateStamina();\n        \n        if (_isGliding)\n        {\n            _currentGlideTime += Time.deltaTime;\n            \n            if (_currentGlideTime >= _maxGlideTime || _glideStamina <= 0f || !Input.GetKey(_glideKey))\n            {\n                StopGliding();\n            }\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGliding)\n        {\n            ApplyGlidePhysics();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_glideKey) && _canGlide && _glideStamina > 10f && !_isGliding)\n        {\n            StartGliding();\n        }\n        \n        if (Input.GetKeyUp(_glideKey) && _isGliding)\n        {\n            StopGliding();\n        }\n    }\n    \n    private void StartGliding()\n    {\n        _isGliding = true;\n        _currentGlideTime = 0f;\n        _canGlide = true;\n        \n        // Reduce gravity for gliding effect\n        _rigidbody.drag = 1f;\n        \n        // Play start sound\n        if (_audioSource != null && _glideStartSound != null)\n        {\n            _audioSource.PlayOneShot(_glideStartSound);\n        }\n        \n        // Start loop sound\n        if (_audioSource != null && _glideLoopSound != null)\n        {\n            _audioSource.clip = _glideLoopSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        // Start particle effect\n        if (_windTrailEffect != null)\n        {\n            _windTrailEffect.Play();\n        }\n        \n        // Extend wings\n        AnimateWingsOpen();\n    }\n    \n    private void StopGliding()\n    {\n        _isGliding = false;\n        _currentGlideTime = 0f;\n        \n        // Restore normal physics\n        _rigidbody.drag = 0f;\n        \n        // Stop loop sound and play end sound\n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n            if (_glideEndSound != null)\n            {\n                _audioSource.PlayOneShot(_glideEndSound);\n            }\n        }\n        \n        // Stop particle effect\n        if (_windTrailEffect != null)\n        {\n            _windTrailEffect.Stop();\n        }\n        \n        // Fold wings\n        AnimateWingsClose();\n        \n        // Reset camera\n        if (_cameraTransform != null)\n        {\n            _cameraTransform.localPosition = _originalCameraPosition;\n        }\n    }\n    \n    private void ApplyGlidePhysics()\n    {\n        Vector3 velocity = _rigidbody.velocity;\n        \n        // Apply reduced gravity\n        Vector3 gravityForce = Vector3.up * (-_glideGravity * _rigidbody.mass);\n        _rigidbody.AddForce(gravityForce, ForceMode.Force);\n        \n        // Apply forward glide force\n        Vector3 forwardDirection = transform.forward;\n        Vector3 glideForce = forwardDirection * _glideSpeed;\n        _rigidbody.AddForce(glideForce, ForceMode.Force);\n        \n        // Limit vertical fall speed\n        if (velocity.y < -5f)\n        {\n            velocity.y = -5f;\n            _rigidbody.velocity = velocity;\n        }\n        \n        // Add slight camera shake for immersion\n        if (_cameraTransform != null)\n        {\n            Vector3 shakeOffset = new Vector3(\n                Random.Range(-_cameraShakeAmount, _cameraShakeAmount),\n                Random.Range(-_cameraShakeAmount, _cameraShakeAmount),\n                0f\n            );\n            _cameraTransform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n    }\n    \n    private void UpdateWingAnimation()\n    {\n        if (_isGliding)\n        {\n            _wingFlapTimer += Time.deltaTime * _wingFlapSpeed;\n            float flapOffset = Mathf.Sin(_wingFlapTimer) * _wingFlapAmount;\n            \n            if (_leftWing != null)\n            {\n                _leftWing.localRotation = Quaternion.Euler(0f, 0f, flapOffset);\n            }\n            \n            if (_rightWing != null)\n            {\n                _rightWing.localRotation = Quaternion.Euler(0f, 0f, -flapOffset);\n            }\n        }\n    }\n    \n    private void AnimateWingsOpen()\n    {\n        if (_leftWing != null)\n        {\n            _leftWing.localRotation = Quaternion.Euler(0f, 0f, 45f);\n        }\n        \n        if (_rightWing != null)\n        {\n            _rightWing.localRotation = Quaternion.Euler(0f, 0f, -45f);\n        }\n    }\n    \n    private void AnimateWingsClose()\n    {\n        if (_leftWing != null)\n        {\n            _leftWing.localRotation = Quaternion.Euler(0f, 0f, 0f);\n        }\n        \n        if (_rightWing != null)\n        {\n            _rightWing.localRotation = Quaternion.Euler(0f, 0f, 0f);\n        }\n    }\n    \n    private void UpdateStamina()\n    {\n        if (_isGliding)\n        {\n            _glideStamina -= 20f * Time.deltaTime;\n            _glideStamina = Mathf.Max(0f, _glideStamina);\n        }\n        else\n        {\n            _glideStamina += 10f * Time.deltaTime;\n            _glideStamina = Mathf.Min(_maxGlideStamina, _glideStamina);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isGliding)\n        {\n            StopGliding();\n        }\n    }\n    \n    public bool IsGliding()\n    {\n        return _isGliding;\n    }\n    \n    public float GetGlideStamina()\n    {\n        return _glideStamina;\n    }\n    \n    public float GetGlideStaminaPercentage()\n    {\n        return _glideStamina / _maxGlideStamina;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "telekinesis grab",
      "ideal_ir": {
        "class_name": "TelekinesisGrab",
        "components": [
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "grabRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "grabForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "holdDistance",
            "type": "float",
            "default": 3
          },
          {
            "name": "isGrabbing",
            "type": "bool",
            "default": false
          },
          {
            "name": "grabbedObject",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initiate_grab",
            "trigger": "when grab input is pressed and not currently grabbing",
            "actions": [
              {
                "action": "cast ray forward from player position"
              },
              {
                "action": "find first object with rigidbody within grab range"
              },
              {
                "action": "set grabbed object to the found object"
              },
              {
                "action": "set is grabbing to true"
              },
              {
                "action": "disable gravity on grabbed object"
              }
            ]
          },
          {
            "name": "maintain_grab",
            "trigger": "when currently grabbing an object",
            "actions": [
              {
                "action": "calculate position in front of player at hold distance"
              },
              {
                "action": "apply force to move grabbed object toward target position"
              },
              {
                "action": "apply damping to reduce grabbed object velocity"
              }
            ]
          },
          {
            "name": "release_grab",
            "trigger": "when grab input is released or grab input is pressed while grabbing",
            "actions": [
              {
                "action": "enable gravity on grabbed object"
              },
              {
                "action": "set grabbed object to null"
              },
              {
                "action": "set is grabbing to false"
              }
            ]
          },
          {
            "name": "auto_release_on_distance",
            "trigger": "when grabbed object is too far from player",
            "actions": [
              {
                "action": "enable gravity on grabbed object"
              },
              {
                "action": "set grabbed object to null"
              },
              {
                "action": "set is grabbing to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class TelekinesisGrab : MonoBehaviour\n{\n    [Header(\"Telekinesis Settings\")]\n    [SerializeField] private float _maxGrabDistance = 10f;\n    [SerializeField] private float _grabForce = 500f;\n    [SerializeField] private float _holdDistance = 3f;\n    [SerializeField] private float _rotationSpeed = 100f;\n    [SerializeField] private LayerMask _grabbableLayerMask = -1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Q;\n    [SerializeField] private KeyCode _rotateLeftKey = KeyCode.Z;\n    [SerializeField] private KeyCode _rotateRightKey = KeyCode.X;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _telekinesisBeam;\n    [SerializeField] private ParticleSystem _grabEffect;\n    [SerializeField] private Color _beamColor = Color.cyan;\n    [SerializeField] private float _beamWidth = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _holdLoopSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectGrabbed;\n    public UnityEvent<GameObject> OnObjectReleased;\n    \n    private Camera _playerCamera;\n    private GameObject _grabbedObject;\n    private Rigidbody _grabbedRigidbody;\n    private Vector3 _originalGravityScale;\n    private bool _wasKinematic;\n    private Transform _holdPoint;\n    private List<Collider> _grabbedColliders = new List<Collider>();\n    \n    [System.Serializable]\n    public class GrabbableObject\n    {\n        public Rigidbody rigidbody;\n        public Vector3 originalPosition;\n        public Quaternion originalRotation;\n        public bool wasKinematic;\n        public float originalMass;\n    }\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        CreateHoldPoint();\n        SetupLineRenderer();\n    }\n    \n    private void CreateHoldPoint()\n    {\n        GameObject holdPointObj = new GameObject(\"TelekinesisHoldPoint\");\n        _holdPoint = holdPointObj.transform;\n        _holdPoint.SetParent(transform);\n        _holdPoint.localPosition = Vector3.forward * _holdDistance;\n    }\n    \n    private void SetupLineRenderer()\n    {\n        if (_telekinesisBeam == null)\n        {\n            _telekinesisBeam = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _telekinesisBeam.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _telekinesisBeam.color = _beamColor;\n        _telekinesisBeam.startWidth = _beamWidth;\n        _telekinesisBeam.endWidth = _beamWidth;\n        _telekinesisBeam.positionCount = 2;\n        _telekinesisBeam.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateGrabbedObject();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (_grabbedObject == null)\n                TryGrabObject();\n            else\n                ReleaseObject();\n        }\n        \n        if (Input.GetKeyDown(_releaseKey) && _grabbedObject != null)\n        {\n            ReleaseObject();\n        }\n        \n        if (_grabbedObject != null)\n        {\n            HandleRotationInput();\n            HandleDistanceAdjustment();\n        }\n    }\n    \n    private void HandleRotationInput()\n    {\n        if (Input.GetKey(_rotateLeftKey))\n        {\n            _grabbedObject.transform.Rotate(Vector3.up, -_rotationSpeed * Time.deltaTime, Space.World);\n        }\n        \n        if (Input.GetKey(_rotateRightKey))\n        {\n            _grabbedObject.transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime, Space.World);\n        }\n    }\n    \n    private void HandleDistanceAdjustment()\n    {\n        float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scroll) > 0.01f)\n        {\n            _holdDistance = Mathf.Clamp(_holdDistance + scroll * 2f, 1f, _maxGrabDistance);\n            _holdPoint.localPosition = Vector3.forward * _holdDistance;\n        }\n    }\n    \n    private void TryGrabObject()\n    {\n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _maxGrabDistance, _grabbableLayerMask))\n        {\n            GameObject target = hit.collider.gameObject;\n            Rigidbody targetRb = target.GetComponent<Rigidbody>();\n            \n            if (targetRb != null && CanGrabObject(target))\n            {\n                GrabObject(target, targetRb);\n            }\n        }\n    }\n    \n    private bool CanGrabObject(GameObject obj)\n    {\n        if (obj.CompareTag(\"Player\"))\n            return false;\n            \n        TelekinesisGrab otherGrabber = obj.GetComponent<TelekinesisGrab>();\n        if (otherGrabber != null)\n            return false;\n            \n        return true;\n    }\n    \n    private void GrabObject(GameObject obj, Rigidbody rb)\n    {\n        _grabbedObject = obj;\n        _grabbedRigidbody = rb;\n        \n        _wasKinematic = rb.isKinematic;\n        rb.isKinematic = false;\n        rb.useGravity = false;\n        \n        _grabbedColliders.Clear();\n        Collider[] colliders = obj.GetComponentsInChildren<Collider>();\n        foreach (Collider col in colliders)\n        {\n            _grabbedColliders.Add(col);\n        }\n        \n        PlaySound(_grabSound);\n        \n        if (_grabEffect != null)\n        {\n            _grabEffect.transform.position = obj.transform.position;\n            _grabEffect.Play();\n        }\n        \n        OnObjectGrabbed?.Invoke(obj);\n    }\n    \n    private void UpdateGrabbedObject()\n    {\n        if (_grabbedObject == null || _grabbedRigidbody == null)\n            return;\n            \n        Vector3 targetPosition = _holdPoint.position;\n        Vector3 direction = targetPosition - _grabbedObject.transform.position;\n        \n        float distance = direction.magnitude;\n        if (distance > 0.1f)\n        {\n            Vector3 force = direction.normalized * _grabForce * distance;\n            _grabbedRigidbody.AddForce(force);\n        }\n        \n        _grabbedRigidbody.velocity *= 0.95f;\n        _grabbedRigidbody.angularVelocity *= 0.9f;\n        \n        if (Vector3.Distance(_grabbedObject.transform.position, transform.position) > _maxGrabDistance * 1.5f)\n        {\n            ReleaseObject();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_grabbedObject != null && _telekinesisBeam != null)\n        {\n            _telekinesisBeam.enabled = true;\n            _telekinesisBeam.SetPosition(0, transform.position);\n            _telekinesisBeam.SetPosition(1, _grabbedObject.transform.position);\n        }\n        else if (_telekinesisBeam != null)\n        {\n            _telekinesisBeam.enabled = false;\n        }\n    }\n    \n    private void ReleaseObject()\n    {\n        if (_grabbedObject == null)\n            return;\n            \n        if (_grabbedRigidbody != null)\n        {\n            _grabbedRigidbody.isKinematic = _wasKinematic;\n            _grabbedRigidbody.useGravity = true;\n        }\n        \n        PlaySound(_releaseSound);\n        \n        OnObjectReleased?.Invoke(_grabbedObject);\n        \n        _grabbedObject = null;\n        _grabbedRigidbody = null;\n        _grabbedColliders.Clear();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxGrabDistance);\n        \n        if (_holdPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPoint.position, 0.2f);\n            Gizmos.DrawLine(transform.position, _holdPoint.position);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_grabbedObject != null)\n        {\n            ReleaseObject();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "time rewind ability",
      "ideal_ir": {
        "class_name": "TimeRewindAbility",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "rewindDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "recordInterval",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "maxRecordedStates",
            "type": "int",
            "default": 100
          },
          {
            "name": "isRewinding",
            "type": "bool",
            "default": false
          },
          {
            "name": "canRewind",
            "type": "bool",
            "default": true
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "record_state",
            "trigger": "every record interval while not rewinding",
            "actions": [
              {
                "action": "store current position in history list"
              },
              {
                "action": "store current rotation in history list"
              },
              {
                "action": "store current velocity in history list"
              },
              {
                "action": "remove oldest state if history exceeds maximum recorded states"
              }
            ]
          },
          {
            "name": "start_rewind",
            "trigger": "when rewind input is pressed and can rewind and not currently rewinding",
            "actions": [
              {
                "action": "set rewinding state to true"
              },
              {
                "action": "set can rewind to false"
              },
              {
                "action": "disable player input"
              },
              {
                "action": "start rewind visual effects"
              }
            ]
          },
          {
            "name": "perform_rewind",
            "trigger": "while rewinding and have recorded states",
            "actions": [
              {
                "action": "get most recent recorded state from history"
              },
              {
                "action": "set object position to recorded position"
              },
              {
                "action": "set object rotation to recorded rotation"
              },
              {
                "action": "set object velocity to recorded velocity"
              },
              {
                "action": "remove used state from history"
              }
            ]
          },
          {
            "name": "end_rewind",
            "trigger": "when rewind duration expires or no more recorded states",
            "actions": [
              {
                "action": "set rewinding state to false"
              },
              {
                "action": "enable player input"
              },
              {
                "action": "stop rewind visual effects"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "handle_cooldown",
            "trigger": "when cooldown timer reaches cooldown time",
            "actions": [
              {
                "action": "set can rewind to true"
              },
              {
                "action": "reset cooldown timer"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class TimeRewindAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class TransformSnapshot\n    {\n        public Vector3 position;\n        public Quaternion rotation;\n        public Vector3 scale;\n        public float timestamp;\n        \n        public TransformSnapshot(Transform transform, float time)\n        {\n            position = transform.position;\n            rotation = transform.rotation;\n            scale = transform.localScale;\n            timestamp = time;\n        }\n    }\n    \n    [System.Serializable]\n    public class RigidbodySnapshot\n    {\n        public Vector3 velocity;\n        public Vector3 angularVelocity;\n        public float timestamp;\n        \n        public RigidbodySnapshot(Rigidbody rb, float time)\n        {\n            velocity = rb.velocity;\n            angularVelocity = rb.angularVelocity;\n            timestamp = time;\n        }\n    }\n    \n    [Header(\"Rewind Settings\")]\n    [SerializeField] private KeyCode _rewindKey = KeyCode.R;\n    [SerializeField] private float _maxRewindTime = 10f;\n    [SerializeField] private float _snapshotInterval = 0.1f;\n    [SerializeField] private float _rewindSpeed = 2f;\n    [SerializeField] private bool _pauseTimeWhileRewinding = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _rewindEffect;\n    [SerializeField] private Material _rewindMaterial;\n    [SerializeField] private Color _rewindTint = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rewindStartSound;\n    [SerializeField] private AudioClip _rewindLoopSound;\n    [SerializeField] private AudioClip _rewindEndSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRewindStart;\n    public UnityEvent OnRewindEnd;\n    public UnityEvent<float> OnRewindProgress;\n    \n    private List<TransformSnapshot> _transformSnapshots = new List<TransformSnapshot>();\n    private List<RigidbodySnapshot> _rigidbodySnapshots = new List<RigidbodySnapshot>();\n    private Dictionary<Renderer, Material[]> _originalMaterials = new Dictionary<Renderer, Material[]>();\n    \n    private bool _isRewinding = false;\n    private float _lastSnapshotTime = 0f;\n    private float _rewindStartTime = 0f;\n    private float _originalTimeScale = 1f;\n    private int _currentSnapshotIndex = 0;\n    \n    private Rigidbody _rigidbody;\n    private Renderer[] _renderers;\n    private Collider[] _colliders;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderers = GetComponentsInChildren<Renderer>();\n        _colliders = GetComponentsInChildren<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        StoreOriginalMaterials();\n        _originalTimeScale = Time.timeScale;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (!_isRewinding)\n        {\n            RecordSnapshot();\n            CleanupOldSnapshots();\n        }\n        else\n        {\n            ProcessRewind();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_rewindKey) && !_isRewinding && _transformSnapshots.Count > 0)\n        {\n            StartRewind();\n        }\n        else if (Input.GetKeyUp(_rewindKey) && _isRewinding)\n        {\n            StopRewind();\n        }\n    }\n    \n    private void RecordSnapshot()\n    {\n        if (Time.time - _lastSnapshotTime >= _snapshotInterval)\n        {\n            _transformSnapshots.Add(new TransformSnapshot(transform, Time.time));\n            \n            if (_rigidbody != null)\n            {\n                _rigidbodySnapshots.Add(new RigidbodySnapshot(_rigidbody, Time.time));\n            }\n            \n            _lastSnapshotTime = Time.time;\n        }\n    }\n    \n    private void CleanupOldSnapshots()\n    {\n        float cutoffTime = Time.time - _maxRewindTime;\n        \n        _transformSnapshots.RemoveAll(snapshot => snapshot.timestamp < cutoffTime);\n        _rigidbodySnapshots.RemoveAll(snapshot => snapshot.timestamp < cutoffTime);\n    }\n    \n    private void StartRewind()\n    {\n        if (_transformSnapshots.Count == 0) return;\n        \n        _isRewinding = true;\n        _rewindStartTime = Time.time;\n        _currentSnapshotIndex = _transformSnapshots.Count - 1;\n        \n        if (_pauseTimeWhileRewinding)\n        {\n            Time.timeScale = 0f;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        SetCollidersEnabled(false);\n        ApplyRewindVisuals();\n        PlayRewindAudio(_rewindStartSound);\n        \n        if (_rewindEffect != null)\n            _rewindEffect.Play();\n        \n        OnRewindStart?.Invoke();\n    }\n    \n    private void ProcessRewind()\n    {\n        if (_currentSnapshotIndex < 0)\n        {\n            StopRewind();\n            return;\n        }\n        \n        float rewindProgress = 1f - (_currentSnapshotIndex / (float)_transformSnapshots.Count);\n        OnRewindProgress?.Invoke(rewindProgress);\n        \n        TransformSnapshot targetSnapshot = _transformSnapshots[_currentSnapshotIndex];\n        \n        transform.position = targetSnapshot.position;\n        transform.rotation = targetSnapshot.rotation;\n        transform.localScale = targetSnapshot.scale;\n        \n        _currentSnapshotIndex -= Mathf.RoundToInt(_rewindSpeed);\n        _currentSnapshotIndex = Mathf.Max(_currentSnapshotIndex, 0);\n    }\n    \n    private void StopRewind()\n    {\n        if (!_isRewinding) return;\n        \n        _isRewinding = false;\n        \n        if (_pauseTimeWhileRewinding)\n        {\n            Time.timeScale = _originalTimeScale;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            RestoreRigidbodyState();\n        }\n        \n        SetCollidersEnabled(true);\n        RestoreOriginalVisuals();\n        PlayRewindAudio(_rewindEndSound);\n        \n        if (_rewindEffect != null)\n            _rewindEffect.Stop();\n        \n        ClearSnapshotsAfterRewind();\n        OnRewindEnd?.Invoke();\n    }\n    \n    private void RestoreRigidbodyState()\n    {\n        if (_rigidbody == null || _rigidbodySnapshots.Count == 0) return;\n        \n        int targetIndex = Mathf.Clamp(_currentSnapshotIndex, 0, _rigidbodySnapshots.Count - 1);\n        RigidbodySnapshot targetState = _rigidbodySnapshots[targetIndex];\n        \n        _rigidbody.velocity = targetState.velocity;\n        _rigidbody.angularVelocity = targetState.angularVelocity;\n    }\n    \n    private void ClearSnapshotsAfterRewind()\n    {\n        if (_currentSnapshotIndex >= 0 && _currentSnapshotIndex < _transformSnapshots.Count)\n        {\n            _transformSnapshots.RemoveRange(_currentSnapshotIndex, _transformSnapshots.Count - _currentSnapshotIndex);\n            \n            if (_rigidbodySnapshots.Count > _currentSnapshotIndex)\n            {\n                _rigidbodySnapshots.RemoveRange(_currentSnapshotIndex, _rigidbodySnapshots.Count - _currentSnapshotIndex);\n            }\n        }\n    }\n    \n    private void SetCollidersEnabled(bool enabled)\n    {\n        foreach (Collider col in _colliders)\n        {\n            if (col != null)\n                col.enabled = enabled;\n        }\n    }\n    \n    private void StoreOriginalMaterials()\n    {\n        foreach (Renderer renderer in _renderers)\n        {\n            if (renderer != null)\n            {\n                _originalMaterials[renderer] = renderer.materials;\n            }\n        }\n    }\n    \n    private void ApplyRewindVisuals()\n    {\n        if (_rewindMaterial == null) return;\n        \n        foreach (Renderer renderer in _renderers)\n        {\n            if (renderer != null)\n            {\n                Material[] rewindMaterials = new Material[renderer.materials.Length];\n                for (int i = 0; i < rewindMaterials.Length; i++)\n                {\n                    rewindMaterials[i] = _rewindMaterial;\n                }\n                renderer.materials = rewindMaterials;\n                renderer.material.color = _rewindTint;\n            }\n        }\n    }\n    \n    private void RestoreOriginalVisuals()\n    {\n        foreach (var kvp in _originalMaterials)\n        {\n            if (kvp.Key != null)\n            {\n                kvp.Key.materials = kvp.Value;\n            }\n        }\n    }\n    \n    private void PlayRewindAudio(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void TriggerRewind()\n    {\n        if (!_isRewinding && _transformSnapshots.Count > 0)\n        {\n            StartRewind();\n        }\n    }\n    \n    public void StopRewindManually()\n    {\n        if (_isRewinding)\n        {\n            StopRewind();\n        }\n    }\n    \n    public bool IsRewinding()\n    {\n        return _isRewinding;\n    }\n    \n    public float GetRewindProgress()\n    {\n        if (!_isRewinding || _transformSnapshots.Count == 0) return 0f;\n        return 1f - (_currentSnapshotIndex / (float)_transformSnapshots.Count);\n    }\n    \n    public void ClearAllSnapshots()\n    {\n        _transformSnapshots.Clear();\n        _rigidbodySnapshots.Clear();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_pauseTimeWhileRewinding && _isRewinding)\n        {\n            Time.timeScale = _originalTimeScale;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "clone ability",
      "ideal_ir": {
        "class_name": "CloneAbility",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "cloneDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "cloneCount",
            "type": "int",
            "default": 2
          },
          {
            "name": "spawnDistance",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "cloneHealthPercentage",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "cloneDamagePercentage",
            "type": "float",
            "default": 0.75
          }
        ],
        "behaviors": [
          {
            "name": "activate_clone_ability",
            "trigger": "when clone ability key is pressed and ability is not on cooldown",
            "actions": [
              {
                "action": "create specified number of clones around the player"
              },
              {
                "action": "position clones at spawn distance from player"
              },
              {
                "action": "copy player appearance and equipment to clones"
              },
              {
                "action": "set clone health to percentage of player health"
              },
              {
                "action": "set clone damage to percentage of player damage"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "clone_combat_behavior",
            "trigger": "when clone is created and enemies are nearby",
            "actions": [
              {
                "action": "target nearest enemy to the clone"
              },
              {
                "action": "move toward targeted enemy"
              },
              {
                "action": "attack enemy using copied abilities"
              },
              {
                "action": "take damage when hit by enemies"
              }
            ]
          },
          {
            "name": "clone_expiration",
            "trigger": "when clone duration timer expires",
            "actions": [
              {
                "action": "play disappearing visual effect"
              },
              {
                "action": "destroy clone object"
              },
              {
                "action": "remove clone from active clone list"
              }
            ]
          },
          {
            "name": "clone_death",
            "trigger": "when clone health reaches zero",
            "actions": [
              {
                "action": "play clone death animation"
              },
              {
                "action": "create small explosion effect"
              },
              {
                "action": "destroy clone object immediately"
              }
            ]
          },
          {
            "name": "cooldown_management",
            "trigger": "when cooldown timer is active",
            "actions": [
              {
                "action": "decrease cooldown timer"
              },
              {
                "action": "disable clone ability activation"
              },
              {
                "action": "show cooldown progress on UI"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class CloneAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class CloneData\n    {\n        public GameObject clonePrefab;\n        public float lifetime = 5f;\n        public float health = 100f;\n        public bool canAttack = true;\n        public bool followsPlayer = false;\n        public float followDistance = 3f;\n    }\n\n    [Header(\"Clone Settings\")]\n    [SerializeField] private CloneData _cloneData;\n    [SerializeField] private int _maxClones = 3;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private float _spawnRadius = 2f;\n    [SerializeField] private LayerMask _spawnLayerMask = -1;\n\n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _cloneKey = KeyCode.C;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _spawnEffect;\n    [SerializeField] private GameObject _despawnEffect;\n    [SerializeField] private AudioClip _spawnSound;\n    [SerializeField] private AudioClip _despawnSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnCloneSpawned;\n    public UnityEvent<GameObject> OnCloneDespawned;\n    public UnityEvent OnCooldownStarted;\n    public UnityEvent OnCooldownEnded;\n\n    private List<GameObject> _activeClones = new List<GameObject>();\n    private float _lastCloneTime;\n    private AudioSource _audioSource;\n    private Transform _playerTransform;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _playerTransform = transform;\n        \n        if (_cloneData.clonePrefab == null)\n        {\n            Debug.LogWarning(\"Clone prefab not assigned to CloneAbility on \" + gameObject.name);\n        }\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        CleanupDestroyedClones();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_cloneKey))\n        {\n            TrySpawnClone();\n        }\n    }\n\n    public void TrySpawnClone()\n    {\n        if (!CanSpawnClone())\n            return;\n\n        Vector3 spawnPosition = GetValidSpawnPosition();\n        if (spawnPosition != Vector3.zero)\n        {\n            SpawnClone(spawnPosition);\n        }\n    }\n\n    private bool CanSpawnClone()\n    {\n        if (_cloneData.clonePrefab == null)\n            return false;\n\n        if (_activeClones.Count >= _maxClones)\n            return false;\n\n        if (Time.time - _lastCloneTime < _cooldownTime)\n            return false;\n\n        return true;\n    }\n\n    private Vector3 GetValidSpawnPosition()\n    {\n        for (int attempts = 0; attempts < 10; attempts++)\n        {\n            Vector2 randomCircle = Random.insideUnitCircle * _spawnRadius;\n            Vector3 testPosition = _playerTransform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n            \n            if (Physics.CheckSphere(testPosition, 0.5f, _spawnLayerMask))\n                continue;\n\n            return testPosition;\n        }\n\n        return _playerTransform.position + _playerTransform.forward * 2f;\n    }\n\n    private void SpawnClone(Vector3 position)\n    {\n        GameObject clone = Instantiate(_cloneData.clonePrefab, position, _playerTransform.rotation);\n        \n        CloneController cloneController = clone.GetComponent<CloneController>();\n        if (cloneController == null)\n            cloneController = clone.AddComponent<CloneController>();\n\n        cloneController.Initialize(_cloneData, _playerTransform);\n        \n        _activeClones.Add(clone);\n        _lastCloneTime = Time.time;\n\n        StartCoroutine(DestroyCloneAfterTime(clone, _cloneData.lifetime));\n\n        if (_spawnEffect != null)\n            Instantiate(_spawnEffect, position, Quaternion.identity);\n\n        if (_spawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_spawnSound);\n\n        OnCloneSpawned?.Invoke(clone);\n        OnCooldownStarted?.Invoke();\n        \n        StartCoroutine(CooldownTimer());\n    }\n\n    private IEnumerator DestroyCloneAfterTime(GameObject clone, float time)\n    {\n        yield return new WaitForSeconds(time);\n        \n        if (clone != null)\n        {\n            DestroyClone(clone);\n        }\n    }\n\n    private IEnumerator CooldownTimer()\n    {\n        yield return new WaitForSeconds(_cooldownTime);\n        OnCooldownEnded?.Invoke();\n    }\n\n    public void DestroyClone(GameObject clone)\n    {\n        if (clone == null)\n            return;\n\n        _activeClones.Remove(clone);\n\n        if (_despawnEffect != null)\n            Instantiate(_despawnEffect, clone.transform.position, Quaternion.identity);\n\n        if (_despawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_despawnSound);\n\n        OnCloneDespawned?.Invoke(clone);\n        Destroy(clone);\n    }\n\n    public void DestroyAllClones()\n    {\n        for (int i = _activeClones.Count - 1; i >= 0; i--)\n        {\n            if (_activeClones[i] != null)\n                DestroyClone(_activeClones[i]);\n        }\n        _activeClones.Clear();\n    }\n\n    private void CleanupDestroyedClones()\n    {\n        for (int i = _activeClones.Count - 1; i >= 0; i--)\n        {\n            if (_activeClones[i] == null)\n            {\n                _activeClones.RemoveAt(i);\n            }\n        }\n    }\n\n    public bool IsOnCooldown()\n    {\n        return Time.time - _lastCloneTime < _cooldownTime;\n    }\n\n    public float GetCooldownProgress()\n    {\n        return Mathf.Clamp01((Time.time - _lastCloneTime) / _cooldownTime);\n    }\n\n    public int GetActiveCloneCount()\n    {\n        CleanupDestroyedClones();\n        return _activeClones.Count;\n    }\n\n    public List<GameObject> GetActiveClones()\n    {\n        CleanupDestroyedClones();\n        return new List<GameObject>(_activeClones);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n    }\n}\n\npublic class CloneController : MonoBehaviour\n{\n    private CloneAbility.CloneData _data;\n    private Transform _playerTransform;\n    private float _currentHealth;\n    private bool _isInitialized;\n\n    public void Initialize(CloneAbility.CloneData data, Transform playerTransform)\n    {\n        _data = data;\n        _playerTransform = playerTransform;\n        _currentHealth = data.health;\n        _isInitialized = true;\n    }\n\n    private void Update()\n    {\n        if (!_isInitialized || _playerTransform == null)\n            return;\n\n        if (_data.followsPlayer)\n        {\n            FollowPlayer();\n        }\n    }\n\n    private void FollowPlayer()\n    {\n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distance > _data.followDistance)\n        {\n            Vector3 direction = (_playerTransform.position - transform.position).normalized;\n            transform.position += direction * Time.deltaTime * 5f;\n            transform.LookAt(_playerTransform);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        CloneAbility cloneAbility = _playerTransform.GetComponent<CloneAbility>();\n        if (cloneAbility != null)\n        {\n            cloneAbility.DestroyClone(gameObject);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Enemy\") && _data.canAttack)\n        {\n            // Clone can interact with enemies\n            Debug.Log(\"Clone interacting with enemy: \" + other.name);\n        }\n    }\n\n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _data.health;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "size change ability",
      "ideal_ir": {
        "class_name": "SizeChanger",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "minScale",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "maxScale",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "scaleSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "currentTargetScale",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "increase_size",
            "trigger": "when increase size input is pressed",
            "actions": [
              {
                "action": "set target scale to maximum scale value"
              },
              {
                "action": "gradually scale object up to target scale at scale speed"
              }
            ]
          },
          {
            "name": "decrease_size",
            "trigger": "when decrease size input is pressed",
            "actions": [
              {
                "action": "set target scale to minimum scale value"
              },
              {
                "action": "gradually scale object down to target scale at scale speed"
              }
            ]
          },
          {
            "name": "reset_size",
            "trigger": "when reset size input is pressed",
            "actions": [
              {
                "action": "set target scale to normal size"
              },
              {
                "action": "gradually scale object to normal size at scale speed"
              }
            ]
          },
          {
            "name": "smooth_scaling",
            "trigger": "when current scale is different from target scale",
            "actions": [
              {
                "action": "smoothly interpolate current scale toward target scale"
              },
              {
                "action": "apply the interpolated scale to the transform"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SizeChangeAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class SizeChangeEvent : UnityEvent<float> { }\n    \n    [Header(\"Size Settings\")]\n    [SerializeField] private float _minSize = 0.5f;\n    [SerializeField] private float _maxSize = 3.0f;\n    [SerializeField] private float _defaultSize = 1.0f;\n    [SerializeField] private float _sizeChangeSpeed = 2.0f;\n    [SerializeField] private AnimationCurve _sizeTransitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _growKey = KeyCode.E;\n    [SerializeField] private KeyCode _shrinkKey = KeyCode.Q;\n    [SerializeField] private KeyCode _resetKey = KeyCode.R;\n    [SerializeField] private bool _useMouseWheel = true;\n    [SerializeField] private float _mouseWheelSensitivity = 0.5f;\n    \n    [Header(\"Energy System\")]\n    [SerializeField] private bool _useEnergySystem = true;\n    [SerializeField] private float _maxEnergy = 100f;\n    [SerializeField] private float _energyDrainRate = 10f;\n    [SerializeField] private float _energyRegenRate = 5f;\n    [SerializeField] private float _minEnergyToActivate = 10f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private bool _adjustMass = true;\n    [SerializeField] private float _baseMass = 1f;\n    [SerializeField] private bool _adjustCollider = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _sizeChangeEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _growSound;\n    [SerializeField] private AudioClip _shrinkSound;\n    [SerializeField] private AudioClip _resetSound;\n    \n    [Header(\"Events\")]\n    public SizeChangeEvent OnSizeChanged;\n    public UnityEvent OnGrow;\n    public UnityEvent OnShrink;\n    public UnityEvent OnReset;\n    public UnityEvent OnEnergyDepleted;\n    \n    private float _currentSize;\n    private float _targetSize;\n    private Vector3 _originalScale;\n    private float _currentEnergy;\n    private bool _isChangingSize;\n    private float _sizeChangeTimer;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Vector3 _originalColliderSize;\n    private Vector3 _originalColliderCenter;\n    \n    private void Start()\n    {\n        _originalScale = transform.localScale;\n        _currentSize = _defaultSize;\n        _targetSize = _defaultSize;\n        _currentEnergy = _maxEnergy;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n        {\n            if (_collider is BoxCollider boxCollider)\n            {\n                _originalColliderSize = boxCollider.size;\n                _originalColliderCenter = boxCollider.center;\n            }\n            else if (_collider is SphereCollider sphereCollider)\n            {\n                _originalColliderSize = Vector3.one * sphereCollider.radius;\n                _originalColliderCenter = sphereCollider.center;\n            }\n            else if (_collider is CapsuleCollider capsuleCollider)\n            {\n                _originalColliderSize = new Vector3(capsuleCollider.radius, capsuleCollider.height, capsuleCollider.radius);\n                _originalColliderCenter = capsuleCollider.center;\n            }\n        }\n        \n        ApplySize(_currentSize);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateEnergy();\n        UpdateSizeTransition();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_useEnergySystem || _currentEnergy >= _minEnergyToActivate)\n        {\n            if (Input.GetKeyDown(_growKey))\n            {\n                Grow();\n            }\n            else if (Input.GetKeyDown(_shrinkKey))\n            {\n                Shrink();\n            }\n            \n            if (_useMouseWheel)\n            {\n                float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n                if (Mathf.Abs(scroll) > 0.01f)\n                {\n                    ChangeSize(scroll * _mouseWheelSensitivity);\n                }\n            }\n        }\n        \n        if (Input.GetKeyDown(_resetKey))\n        {\n            ResetSize();\n        }\n    }\n    \n    private void UpdateEnergy()\n    {\n        if (!_useEnergySystem) return;\n        \n        if (_isChangingSize && _currentSize != _defaultSize)\n        {\n            _currentEnergy -= _energyDrainRate * Time.deltaTime;\n            _currentEnergy = Mathf.Max(0, _currentEnergy);\n            \n            if (_currentEnergy <= 0)\n            {\n                OnEnergyDepleted?.Invoke();\n                ResetSize();\n            }\n        }\n        else if (!_isChangingSize || _currentSize == _defaultSize)\n        {\n            _currentEnergy += _energyRegenRate * Time.deltaTime;\n            _currentEnergy = Mathf.Min(_maxEnergy, _currentEnergy);\n        }\n    }\n    \n    private void UpdateSizeTransition()\n    {\n        if (_isChangingSize)\n        {\n            _sizeChangeTimer += Time.deltaTime * _sizeChangeSpeed;\n            float progress = _sizeChangeTimer;\n            \n            if (progress >= 1f)\n            {\n                progress = 1f;\n                _isChangingSize = false;\n            }\n            \n            float curveValue = _sizeTransitionCurve.Evaluate(progress);\n            float newSize = Mathf.Lerp(_currentSize, _targetSize, curveValue);\n            \n            ApplySize(newSize);\n            \n            if (!_isChangingSize)\n            {\n                _currentSize = _targetSize;\n            }\n        }\n    }\n    \n    public void Grow()\n    {\n        ChangeSize(0.5f);\n        OnGrow?.Invoke();\n        PlaySound(_growSound);\n    }\n    \n    public void Shrink()\n    {\n        ChangeSize(-0.5f);\n        OnShrink?.Invoke();\n        PlaySound(_shrinkSound);\n    }\n    \n    public void ChangeSize(float amount)\n    {\n        if (_useEnergySystem && _currentEnergy < _minEnergyToActivate && amount != 0) return;\n        \n        float newTargetSize = _targetSize + amount;\n        newTargetSize = Mathf.Clamp(newTargetSize, _minSize, _maxSize);\n        \n        if (Mathf.Abs(newTargetSize - _targetSize) > 0.01f)\n        {\n            _targetSize = newTargetSize;\n            _isChangingSize = true;\n            _sizeChangeTimer = 0f;\n            \n            PlayEffect();\n        }\n    }\n    \n    public void SetSize(float size)\n    {\n        size = Mathf.Clamp(size, _minSize, _maxSize);\n        _targetSize = size;\n        _isChangingSize = true;\n        _sizeChangeTimer = 0f;\n        \n        PlayEffect();\n    }\n    \n    public void ResetSize()\n    {\n        _targetSize = _defaultSize;\n        _isChangingSize = true;\n        _sizeChangeTimer = 0f;\n        \n        OnReset?.Invoke();\n        PlaySound(_resetSound);\n        PlayEffect();\n    }\n    \n    private void ApplySize(float size)\n    {\n        Vector3 newScale = _originalScale * size;\n        transform.localScale = newScale;\n        \n        if (_adjustMass && _rigidbody != null)\n        {\n            _rigidbody.mass = _baseMass * (size * size * size);\n        }\n        \n        if (_adjustCollider && _collider != null)\n        {\n            if (_collider is BoxCollider boxCollider)\n            {\n                boxCollider.size = _originalColliderSize * size;\n                boxCollider.center = _originalColliderCenter * size;\n            }\n            else if (_collider is SphereCollider sphereCollider)\n            {\n                sphereCollider.radius = _originalColliderSize.x * size;\n                sphereCollider.center = _originalColliderCenter * size;\n            }\n            else if (_collider is CapsuleCollider capsuleCollider)\n            {\n                capsuleCollider.radius = _originalColliderSize.x * size;\n                capsuleCollider.height = _originalColliderSize.y * size;\n                capsuleCollider.center = _originalColliderCenter * size;\n            }\n        }\n        \n        OnSizeChanged?.Invoke(size);\n    }\n    \n    private void PlayEffect()\n    {\n        if (_sizeChangeEffect != null)\n        {\n            _sizeChangeEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetCurrentSize()\n    {\n        return _currentSize;\n    }\n    \n    public float GetTargetSize()\n    {\n        return _targetSize;\n    }\n    \n    public float GetCurrentEnergy()\n    {\n        return _currentEnergy;\n    }\n    \n    public float GetEnergyPercentage()\n    {\n        return _useEnergySystem ? _currentEnergy / _maxEnergy : 1f;\n    }\n    \n    public bool IsChangingSize()\n    {\n        return _isChangingSize;\n    }\n    \n    public bool CanChangeSize()\n    {\n        return !_useEnergySystem || _currentEnergy >= _minEnergyToActivate;\n    }\n    \n    public void SetEnergy(float energy)\n    {\n        _currentEnergy = Mathf.Clamp(energy, 0, _maxEnergy);\n    }\n    \n    public void AddEnergy(float amount)\n    {\n        _currentEnergy = Mathf.Clamp(_currentEnergy + amount, 0, _maxEnergy);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "invisibility toggle",
      "ideal_ir": {
        "class_name": "InvisibilityToggle",
        "components": [
          "Renderer",
          "Collider"
        ],
        "fields": [
          {
            "name": "isInvisible",
            "type": "bool",
            "default": false
          },
          {
            "name": "toggleKey",
            "type": "KeyCode",
            "default": "KeyCode.I"
          }
        ],
        "behaviors": [
          {
            "name": "toggle_invisibility",
            "trigger": "when toggle key is pressed",
            "actions": [
              {
                "action": "switch invisibility state to opposite of current state"
              },
              {
                "action": "if becoming invisible then hide renderer and disable collider"
              },
              {
                "action": "if becoming visible then show renderer and enable collider"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class InvisibilityToggle : MonoBehaviour\n{\n    [Header(\"Invisibility Settings\")]\n    [SerializeField] private KeyCode _toggleKey = KeyCode.I;\n    [SerializeField] private float _invisibilityDuration = 5f;\n    [SerializeField] private bool _hasLimitedDuration = true;\n    [SerializeField] private float _cooldownTime = 3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _visibleAlpha = 1f;\n    [SerializeField] private float _invisibleAlpha = 0.1f;\n    [SerializeField] private float _fadeSpeed = 5f;\n    [SerializeField] private bool _disableColliders = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _activateSound;\n    [SerializeField] private AudioClip _deactivateSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnInvisibilityActivated;\n    public UnityEvent OnInvisibilityDeactivated;\n    public UnityEvent OnCooldownStarted;\n    public UnityEvent OnCooldownEnded;\n    \n    private bool _isInvisible = false;\n    private bool _isOnCooldown = false;\n    private float _invisibilityTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private float _currentAlpha;\n    \n    private Renderer[] _renderers;\n    private Collider[] _colliders;\n    private AudioSource _audioSource;\n    private Material[] _originalMaterials;\n    private Material[] _transparentMaterials;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupMaterials();\n        _currentAlpha = _visibleAlpha;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateTimers();\n        UpdateVisualEffects();\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderers = GetComponentsInChildren<Renderer>();\n        _colliders = GetComponentsInChildren<Collider>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.playOnAwake = false;\n        _audioSource.volume = _audioVolume;\n    }\n    \n    private void SetupMaterials()\n    {\n        if (_renderers == null || _renderers.Length == 0) return;\n        \n        _originalMaterials = new Material[_renderers.Length];\n        _transparentMaterials = new Material[_renderers.Length];\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _renderers[i].material != null)\n            {\n                _originalMaterials[i] = _renderers[i].material;\n                _transparentMaterials[i] = new Material(_originalMaterials[i]);\n                \n                // Enable transparency\n                _transparentMaterials[i].SetFloat(\"_Mode\", 3);\n                _transparentMaterials[i].SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n                _transparentMaterials[i].SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n                _transparentMaterials[i].SetInt(\"_ZWrite\", 0);\n                _transparentMaterials[i].DisableKeyword(\"_ALPHATEST_ON\");\n                _transparentMaterials[i].EnableKeyword(\"_ALPHABLEND_ON\");\n                _transparentMaterials[i].DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n                _transparentMaterials[i].renderQueue = 3000;\n            }\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_toggleKey) && !_isOnCooldown)\n        {\n            ToggleInvisibility();\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_isInvisible && _hasLimitedDuration)\n        {\n            _invisibilityTimer -= Time.deltaTime;\n            if (_invisibilityTimer <= 0f)\n            {\n                DeactivateInvisibility();\n            }\n        }\n        \n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownEnded?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        float targetAlpha = _isInvisible ? _invisibleAlpha : _visibleAlpha;\n        _currentAlpha = Mathf.Lerp(_currentAlpha, targetAlpha, _fadeSpeed * Time.deltaTime);\n        \n        ApplyAlphaToMaterials(_currentAlpha);\n    }\n    \n    private void ApplyAlphaToMaterials(float alpha)\n    {\n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _transparentMaterials[i] != null)\n            {\n                Color color = _transparentMaterials[i].color;\n                color.a = alpha;\n                _transparentMaterials[i].color = color;\n                \n                if (_renderers[i].material != _transparentMaterials[i])\n                {\n                    _renderers[i].material = _transparentMaterials[i];\n                }\n            }\n        }\n    }\n    \n    public void ToggleInvisibility()\n    {\n        if (_isInvisible)\n        {\n            DeactivateInvisibility();\n        }\n        else\n        {\n            ActivateInvisibility();\n        }\n    }\n    \n    public void ActivateInvisibility()\n    {\n        if (_isOnCooldown) return;\n        \n        _isInvisible = true;\n        \n        if (_hasLimitedDuration)\n        {\n            _invisibilityTimer = _invisibilityDuration;\n        }\n        \n        if (_disableColliders)\n        {\n            SetCollidersEnabled(false);\n        }\n        \n        PlaySound(_activateSound);\n        OnInvisibilityActivated?.Invoke();\n    }\n    \n    public void DeactivateInvisibility()\n    {\n        _isInvisible = false;\n        _invisibilityTimer = 0f;\n        \n        if (_disableColliders)\n        {\n            SetCollidersEnabled(true);\n        }\n        \n        if (_cooldownTime > 0f)\n        {\n            StartCooldown();\n        }\n        \n        PlaySound(_deactivateSound);\n        OnInvisibilityDeactivated?.Invoke();\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        OnCooldownStarted?.Invoke();\n    }\n    \n    private void SetCollidersEnabled(bool enabled)\n    {\n        foreach (Collider col in _colliders)\n        {\n            if (col != null)\n            {\n                col.enabled = enabled;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        // Clean up transparent materials\n        if (_transparentMaterials != null)\n        {\n            for (int i = 0; i < _transparentMaterials.Length; i++)\n            {\n                if (_transparentMaterials[i] != null)\n                {\n                    DestroyImmediate(_transparentMaterials[i]);\n                }\n            }\n        }\n        \n        // Restore original materials\n        if (_originalMaterials != null && _renderers != null)\n        {\n            for (int i = 0; i < _renderers.Length; i++)\n            {\n                if (_renderers[i] != null && _originalMaterials[i] != null)\n                {\n                    _renderers[i].material = _originalMaterials[i];\n                }\n            }\n        }\n    }\n    \n    public bool IsInvisible => _isInvisible;\n    public bool IsOnCooldown => _isOnCooldown;\n    public float RemainingInvisibilityTime => _invisibilityTimer;\n    public float RemainingCooldownTime => _cooldownTimer;\n    public float InvisibilityProgress => _hasLimitedDuration ? (_invisibilityDuration - _invisibilityTimer) / _invisibilityDuration : 0f;\n    public float CooldownProgress => _cooldownTime > 0f ? (_cooldownTime - _cooldownTimer) / _cooldownTime : 1f;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "super speed burst",
      "ideal_ir": {
        "class_name": "SuperSpeedBurst",
        "components": [
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "burstSpeed",
            "type": "float",
            "default": 50
          },
          {
            "name": "burstDuration",
            "type": "float",
            "default": 2
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 5
          },
          {
            "name": "normalSpeed",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "activate_speed_burst",
            "trigger": "when space key is pressed and cooldown is finished",
            "actions": [
              {
                "action": "set movement speed to burst speed value"
              },
              {
                "action": "start burst duration timer"
              },
              {
                "action": "play speed boost visual effect"
              },
              {
                "action": "play speed boost sound effect"
              }
            ]
          },
          {
            "name": "end_speed_burst",
            "trigger": "when burst duration timer expires",
            "actions": [
              {
                "action": "restore movement speed to normal speed value"
              },
              {
                "action": "start cooldown timer"
              },
              {
                "action": "stop speed boost visual effect"
              }
            ]
          },
          {
            "name": "prevent_activation_during_cooldown",
            "trigger": "when space key is pressed and cooldown is active",
            "actions": [
              {
                "action": "ignore input and display cooldown indicator"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SuperSpeedBurst : MonoBehaviour\n{\n    [Header(\"Speed Settings\")]\n    [SerializeField] private float _speedMultiplier = 3f;\n    [SerializeField] private float _burstDuration = 2f;\n    [SerializeField] private float _cooldownTime = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _activationKey = KeyCode.LeftShift;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _speedTrailEffect;\n    [SerializeField] private GameObject _speedAura;\n    [SerializeField] private Color _speedTintColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSpeedBurstActivated;\n    public UnityEvent OnSpeedBurstDeactivated;\n    public UnityEvent OnCooldownComplete;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _originalSpeed;\n    private bool _isSpeedActive = false;\n    private bool _isOnCooldown = false;\n    private float _burstTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Renderer _renderer;\n    private Color _originalColor;\n    private Camera _playerCamera;\n    private float _originalFOV;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponent<Renderer>();\n        _playerCamera = Camera.main;\n        \n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer != null)\n            _originalColor = _renderer.material.color;\n        \n        if (_playerCamera != null)\n            _originalFOV = _playerCamera.fieldOfView;\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateTimers();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_activationKey) && !_isSpeedActive && !_isOnCooldown)\n        {\n            ActivateSpeedBurst();\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_isSpeedActive)\n        {\n            _burstTimer -= Time.deltaTime;\n            if (_burstTimer <= 0f)\n            {\n                DeactivateSpeedBurst();\n            }\n        }\n        \n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_isSpeedActive && _renderer != null)\n        {\n            float lerpValue = Mathf.PingPong(Time.time * 2f, 1f);\n            _renderer.material.color = Color.Lerp(_originalColor, _speedTintColor, lerpValue * 0.5f);\n        }\n    }\n    \n    public void ActivateSpeedBurst()\n    {\n        if (_isSpeedActive || _isOnCooldown) return;\n        \n        _isSpeedActive = true;\n        _burstTimer = _burstDuration;\n        \n        ApplySpeedBoost();\n        ActivateVisualEffects();\n        PlayActivationSound();\n        \n        OnSpeedBurstActivated?.Invoke();\n    }\n    \n    private void DeactivateSpeedBurst()\n    {\n        if (!_isSpeedActive) return;\n        \n        _isSpeedActive = false;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        RemoveSpeedBoost();\n        DeactivateVisualEffects();\n        PlayDeactivationSound();\n        \n        OnSpeedBurstDeactivated?.Invoke();\n    }\n    \n    private void ApplySpeedBoost()\n    {\n        if (_characterController != null)\n        {\n            // For CharacterController, we'll modify movement in a separate movement script\n            // This component will provide the speed multiplier\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.drag *= 0.5f; // Reduce drag for smoother movement\n        }\n        \n        // Increase camera FOV for speed effect\n        if (_playerCamera != null)\n        {\n            StartCoroutine(LerpCameraFOV(_originalFOV + 10f, 0.2f));\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.drag /= 0.5f; // Restore original drag\n        }\n        \n        // Restore camera FOV\n        if (_playerCamera != null)\n        {\n            StartCoroutine(LerpCameraFOV(_originalFOV, 0.3f));\n        }\n    }\n    \n    private void ActivateVisualEffects()\n    {\n        if (_speedTrailEffect != null)\n            _speedTrailEffect.Play();\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(true);\n    }\n    \n    private void DeactivateVisualEffects()\n    {\n        if (_speedTrailEffect != null)\n            _speedTrailEffect.Stop();\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(false);\n        \n        if (_renderer != null)\n            _renderer.material.color = _originalColor;\n    }\n    \n    private void PlayActivationSound()\n    {\n        if (_audioSource != null && _activationSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.9f, 1.1f);\n            _audioSource.PlayOneShot(_activationSound);\n        }\n    }\n    \n    private void PlayDeactivationSound()\n    {\n        if (_audioSource != null && _deactivationSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_deactivationSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator LerpCameraFOV(float targetFOV, float duration)\n    {\n        if (_playerCamera == null) yield break;\n        \n        float startFOV = _playerCamera.fieldOfView;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            _playerCamera.fieldOfView = Mathf.Lerp(startFOV, targetFOV, t);\n            yield return null;\n        }\n        \n        _playerCamera.fieldOfView = targetFOV;\n    }\n    \n    public float GetSpeedMultiplier()\n    {\n        return _isSpeedActive ? _speedMultiplier : 1f;\n    }\n    \n    public bool IsSpeedActive()\n    {\n        return _isSpeedActive;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (!_isOnCooldown) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n    \n    public float GetBurstProgress()\n    {\n        if (!_isSpeedActive) return 0f;\n        return _burstTimer / _burstDuration;\n    }\n    \n    private void OnDisable()\n    {\n        if (_isSpeedActive)\n        {\n            DeactivateSpeedBurst();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "power punch charge",
      "ideal_ir": {
        "class_name": "PowerPunchCharge",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "chargeTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "maxPunchForce",
            "type": "float",
            "default": 1000.0
          },
          {
            "name": "chargeEffectPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isCharging",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentChargeLevel",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "start_charge",
            "trigger": "when punch button is pressed and held",
            "actions": [
              {
                "action": "set charging state to true"
              },
              {
                "action": "reset charge level to zero"
              },
              {
                "action": "spawn charging visual effect"
              },
              {
                "action": "play charging sound effect"
              }
            ]
          },
          {
            "name": "build_charge",
            "trigger": "while charging and punch button is held",
            "actions": [
              {
                "action": "increase charge level over time"
              },
              {
                "action": "intensify visual charging effects"
              },
              {
                "action": "increase charging sound pitch"
              },
              {
                "action": "clamp charge level to maximum value"
              }
            ]
          },
          {
            "name": "release_punch",
            "trigger": "when punch button is released while charging",
            "actions": [
              {
                "action": "set charging state to false"
              },
              {
                "action": "calculate punch force based on charge level"
              },
              {
                "action": "apply forward force to rigidbody"
              },
              {
                "action": "destroy charging visual effects"
              },
              {
                "action": "play punch release sound"
              },
              {
                "action": "reset charge level to zero"
              }
            ]
          },
          {
            "name": "cancel_charge",
            "trigger": "when movement input is detected while charging",
            "actions": [
              {
                "action": "set charging state to false"
              },
              {
                "action": "destroy charging visual effects"
              },
              {
                "action": "stop charging sound"
              },
              {
                "action": "reset charge level to zero"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PowerPunchCharge : MonoBehaviour\n{\n    [Header(\"Charge Settings\")]\n    [SerializeField] private float _maxChargeTime = 3f;\n    [SerializeField] private float _minChargeTime = 0.5f;\n    [SerializeField] private AnimationCurve _chargeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _chargeKey = KeyCode.Mouse0;\n    [SerializeField] private bool _holdToCharge = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _chargeEffect;\n    [SerializeField] private Transform _chargePoint;\n    [SerializeField] private GameObject _chargeIndicator;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Feedback\")]\n    [SerializeField] private float _cameraShakeIntensity = 0.1f;\n    [SerializeField] private Color _minChargeColor = Color.yellow;\n    [SerializeField] private Color _maxChargeColor = Color.red;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeStarted;\n    public UnityEvent<float> OnChargeUpdated;\n    public UnityEvent<float> OnPunchReleased;\n    public UnityEvent OnChargeCancelled;\n    \n    private float _currentChargeTime;\n    private float _chargePercentage;\n    private bool _isCharging;\n    private bool _canCharge = true;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private Renderer _indicatorRenderer;\n    private Light _chargeLight;\n    \n    [System.Serializable]\n    public class ChargeLevel\n    {\n        public float threshold;\n        public float damageMultiplier;\n        public float forceMultiplier;\n        public Color effectColor;\n        public string levelName;\n    }\n    \n    [Header(\"Charge Levels\")]\n    [SerializeField] private ChargeLevel[] _chargeLevels = new ChargeLevel[]\n    {\n        new ChargeLevel { threshold = 0.33f, damageMultiplier = 1.5f, forceMultiplier = 1.2f, effectColor = Color.yellow, levelName = \"Light\" },\n        new ChargeLevel { threshold = 0.66f, damageMultiplier = 2f, forceMultiplier = 1.5f, effectColor = Color.orange, levelName = \"Medium\" },\n        new ChargeLevel { threshold = 1f, damageMultiplier = 3f, forceMultiplier = 2f, effectColor = Color.red, levelName = \"Heavy\" }\n    };\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n            \n        if (_chargeIndicator != null)\n        {\n            _indicatorRenderer = _chargeIndicator.GetComponent<Renderer>();\n            _chargeLight = _chargeIndicator.GetComponent<Light>();\n            _chargeIndicator.SetActive(false);\n        }\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharge();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_canCharge) return;\n        \n        bool inputPressed = Input.GetKeyDown(_chargeKey);\n        bool inputHeld = Input.GetKey(_chargeKey);\n        bool inputReleased = Input.GetKeyUp(_chargeKey);\n        \n        if (inputPressed && !_isCharging)\n        {\n            StartCharge();\n        }\n        else if (_holdToCharge && inputHeld && _isCharging)\n        {\n            ContinueCharge();\n        }\n        else if (inputReleased && _isCharging)\n        {\n            ReleasePunch();\n        }\n        else if (!_holdToCharge && inputPressed && _isCharging)\n        {\n            ReleasePunch();\n        }\n    }\n    \n    private void StartCharge()\n    {\n        _isCharging = true;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n        \n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(true);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Play();\n            \n        if (_audioSource != null && _chargeSound != null)\n            _audioSource.PlayOneShot(_chargeSound);\n            \n        OnChargeStarted?.Invoke(_chargePercentage);\n    }\n    \n    private void ContinueCharge()\n    {\n        _currentChargeTime += Time.deltaTime;\n        _chargePercentage = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        \n        OnChargeUpdated?.Invoke(_chargePercentage);\n    }\n    \n    private void UpdateCharge()\n    {\n        if (!_isCharging) return;\n        \n        if (!_holdToCharge)\n        {\n            _currentChargeTime += Time.deltaTime;\n            _chargePercentage = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n            OnChargeUpdated?.Invoke(_chargePercentage);\n        }\n        \n        // Apply charge curve\n        float curvedCharge = _chargeCurve.Evaluate(_chargePercentage);\n        \n        // Camera shake based on charge level\n        if (_mainCamera != null && _chargePercentage > 0.3f)\n        {\n            float shakeAmount = curvedCharge * _cameraShakeIntensity;\n            Vector3 shakeOffset = Random.insideUnitSphere * shakeAmount;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (!_isCharging) return;\n        \n        // Update indicator color\n        if (_indicatorRenderer != null)\n        {\n            Color currentColor = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n            _indicatorRenderer.material.color = currentColor;\n        }\n        \n        // Update light intensity\n        if (_chargeLight != null)\n        {\n            _chargeLight.intensity = _chargePercentage * 2f;\n            _chargeLight.color = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n        }\n        \n        // Update particle effect\n        if (_chargeEffect != null)\n        {\n            var main = _chargeEffect.main;\n            main.startColor = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n            \n            var emission = _chargeEffect.emission;\n            emission.rateOverTime = _chargePercentage * 50f;\n        }\n    }\n    \n    private void ReleasePunch()\n    {\n        if (_currentChargeTime < _minChargeTime)\n        {\n            CancelCharge();\n            return;\n        }\n        \n        float finalChargePercentage = _chargePercentage;\n        ChargeLevel currentLevel = GetChargeLevel(finalChargePercentage);\n        \n        // Reset camera position\n        if (_mainCamera != null)\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n            \n        // Stop effects\n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(false);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource != null && _releaseSound != null)\n            _audioSource.PlayOneShot(_releaseSound);\n            \n        // Perform punch logic\n        PerformPunch(currentLevel, finalChargePercentage);\n        \n        OnPunchReleased?.Invoke(finalChargePercentage);\n        \n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n    }\n    \n    private void CancelCharge()\n    {\n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n        \n        if (_mainCamera != null)\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n            \n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(false);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        OnChargeCancelled?.Invoke();\n    }\n    \n    private ChargeLevel GetChargeLevel(float chargePercentage)\n    {\n        ChargeLevel selectedLevel = _chargeLevels[0];\n        \n        for (int i = 0; i < _chargeLevels.Length; i++)\n        {\n            if (chargePercentage >= _chargeLevels[i].threshold)\n                selectedLevel = _chargeLevels[i];\n        }\n        \n        return selectedLevel;\n    }\n    \n    private void PerformPunch(ChargeLevel level, float chargePercentage)\n    {\n        // Raycast or sphere cast to detect targets\n        Vector3 punchDirection = transform.forward;\n        Vector3 punchOrigin = _chargePoint != null ? _chargePoint.position : transform.position;\n        \n        float punchRange = 2f + (chargePercentage * 3f);\n        RaycastHit[] hits = Physics.SphereCastAll(punchOrigin, 0.5f, punchDirection, punchRange);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            // Apply force to rigidbodies\n            Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 forceDirection = (hit.point - punchOrigin).normalized;\n                float force = level.forceMultiplier * chargePercentage * 1000f;\n                targetRb.AddForce(forceDirection * force, ForceMode.Impulse);\n            }\n            \n            // Damage destructible objects\n            if (hit.collider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hit.collider.gameObject);\n            }\n        }\n    }\n    \n    public void SetCanCharge(bool canCharge)\n    {\n        _canCharge = canCharge;\n        if (!canCharge && _isCharging)\n            CancelCharge();\n    }\n    \n    public float GetCurrentChargePercentage()\n    {\n        return _chargePercentage;\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n    \n    public ChargeLevel GetCurrentChargeLevel()\n    {\n        return GetChargeLevel(_chargePercentage);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 origin = _chargePoint != null ? _chargePoint.position : transform.position;\n        Vector3 direction = transform.forward;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(origin, direction * (2f + (_chargePercentage * 3f)));\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(origin, 0.5f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "healing meditation",
      "ideal_ir": {
        "class_name": "HealingMeditation",
        "components": [
          "Transform",
          "Renderer",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "healingAmount",
            "type": "float",
            "default": 25.0
          },
          {
            "name": "meditationDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "healingRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentMeditationTime",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "start_meditation",
            "trigger": "when player presses meditation key",
            "actions": [
              {
                "action": "set meditation state to active"
              },
              {
                "action": "play calming meditation sound"
              },
              {
                "action": "start healing particle effects"
              },
              {
                "action": "begin glowing aura around character"
              },
              {
                "action": "reset meditation timer to zero"
              }
            ]
          },
          {
            "name": "meditation_healing",
            "trigger": "while meditation is active and duration not exceeded",
            "actions": [
              {
                "action": "increase meditation timer"
              },
              {
                "action": "gradually restore player health"
              },
              {
                "action": "emit healing energy particles"
              },
              {
                "action": "pulse healing aura brightness"
              }
            ]
          },
          {
            "name": "complete_meditation",
            "trigger": "when meditation duration is reached",
            "actions": [
              {
                "action": "apply full healing amount to player"
              },
              {
                "action": "stop meditation sound"
              },
              {
                "action": "fade out particle effects"
              },
              {
                "action": "disable healing aura"
              },
              {
                "action": "set meditation state to inactive"
              }
            ]
          },
          {
            "name": "interrupt_meditation",
            "trigger": "when player moves or takes damage during meditation",
            "actions": [
              {
                "action": "cancel meditation immediately"
              },
              {
                "action": "stop all healing effects"
              },
              {
                "action": "fade out meditation sound"
              },
              {
                "action": "disable particle systems"
              },
              {
                "action": "set meditation state to inactive"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class HealingMeditation : MonoBehaviour\n{\n    [System.Serializable]\n    public class HealingEvent : UnityEvent<float> { }\n    \n    [Header(\"Meditation Settings\")]\n    [SerializeField] private float _healingAmount = 25f;\n    [SerializeField] private float _meditationDuration = 5f;\n    [SerializeField] private float _cooldownTime = 10f;\n    [SerializeField] private float _detectionRadius = 2f;\n    [SerializeField] private KeyCode _meditationKey = KeyCode.E;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _healingParticles;\n    [SerializeField] private Light _meditationLight;\n    [SerializeField] private Color _healingColor = Color.green;\n    [SerializeField] private AnimationCurve _healingCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _meditationStartSound;\n    [SerializeField] private AudioClip _healingCompleteSound;\n    [SerializeField] private AudioClip _ambientMeditationLoop;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _meditationUI;\n    [SerializeField] private UnityEngine.UI.Slider _progressSlider;\n    [SerializeField] private UnityEngine.UI.Text _instructionText;\n    [SerializeField] private UnityEngine.UI.Text _cooldownText;\n    \n    [Header(\"Events\")]\n    public HealingEvent OnHealingComplete;\n    public UnityEvent OnMeditationStart;\n    public UnityEvent OnMeditationInterrupted;\n    \n    private bool _isMeditating = false;\n    private bool _isOnCooldown = false;\n    private float _meditationProgress = 0f;\n    private float _cooldownTimer = 0f;\n    private GameObject _currentPlayer;\n    private Coroutine _meditationCoroutine;\n    private Vector3 _originalLightIntensity;\n    private Color _originalLightColor;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupInitialState();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_meditationLight != null)\n        {\n            _originalLightIntensity = new Vector3(_meditationLight.intensity, 0, 0);\n            _originalLightColor = _meditationLight.color;\n        }\n        \n        if (OnHealingComplete == null)\n            OnHealingComplete = new HealingEvent();\n    }\n    \n    private void SetupInitialState()\n    {\n        if (_meditationUI != null)\n            _meditationUI.gameObject.SetActive(false);\n            \n        if (_healingParticles != null)\n            _healingParticles.SetActive(false);\n            \n        if (_meditationLight != null)\n            _meditationLight.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        HandlePlayerInput();\n        UpdateUI();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                _cooldownTimer = 0f;\n            }\n        }\n    }\n    \n    private void HandlePlayerInput()\n    {\n        if (_currentPlayer != null && !_isOnCooldown)\n        {\n            if (Input.GetKeyDown(_meditationKey) && !_isMeditating)\n            {\n                StartMeditation();\n            }\n            else if (Input.GetKeyUp(_meditationKey) && _isMeditating)\n            {\n                InterruptMeditation();\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_meditationUI != null)\n        {\n            bool shouldShowUI = _currentPlayer != null && !_isOnCooldown;\n            _meditationUI.gameObject.SetActive(shouldShowUI);\n            \n            if (shouldShowUI)\n            {\n                if (_progressSlider != null)\n                    _progressSlider.value = _meditationProgress;\n                    \n                if (_instructionText != null)\n                {\n                    if (_isMeditating)\n                        _instructionText.text = \"Hold \" + _meditationKey + \" to meditate...\";\n                    else\n                        _instructionText.text = \"Press \" + _meditationKey + \" to start meditation\";\n                }\n            }\n        }\n        \n        if (_cooldownText != null)\n        {\n            if (_isOnCooldown)\n            {\n                _cooldownText.gameObject.SetActive(true);\n                _cooldownText.text = \"Cooldown: \" + Mathf.Ceil(_cooldownTimer).ToString() + \"s\";\n            }\n            else\n            {\n                _cooldownText.gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _currentPlayer = other.gameObject;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            _currentPlayer = null;\n            if (_isMeditating)\n                InterruptMeditation();\n        }\n    }\n    \n    private void StartMeditation()\n    {\n        if (_isMeditating || _isOnCooldown || _currentPlayer == null)\n            return;\n            \n        _isMeditating = true;\n        _meditationProgress = 0f;\n        \n        OnMeditationStart?.Invoke();\n        \n        if (_audioSource != null && _meditationStartSound != null)\n            _audioSource.PlayOneShot(_meditationStartSound);\n            \n        if (_healingParticles != null)\n            _healingParticles.SetActive(true);\n            \n        if (_meditationLight != null)\n        {\n            _meditationLight.enabled = true;\n            _meditationLight.color = _healingColor;\n        }\n        \n        _meditationCoroutine = StartCoroutine(MeditationProcess());\n        \n        if (_audioSource != null && _ambientMeditationLoop != null)\n        {\n            _audioSource.clip = _ambientMeditationLoop;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void InterruptMeditation()\n    {\n        if (!_isMeditating)\n            return;\n            \n        _isMeditating = false;\n        \n        if (_meditationCoroutine != null)\n        {\n            StopCoroutine(_meditationCoroutine);\n            _meditationCoroutine = null;\n        }\n        \n        OnMeditationInterrupted?.Invoke();\n        ResetMeditationEffects();\n    }\n    \n    private IEnumerator MeditationProcess()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _meditationDuration)\n        {\n            if (!Input.GetKey(_meditationKey))\n            {\n                InterruptMeditation();\n                yield break;\n            }\n            \n            elapsedTime += Time.deltaTime;\n            _meditationProgress = elapsedTime / _meditationDuration;\n            \n            UpdateMeditationEffects(_meditationProgress);\n            \n            yield return null;\n        }\n        \n        CompleteMeditation();\n    }\n    \n    private void UpdateMeditationEffects(float progress)\n    {\n        float curveValue = _healingCurve.Evaluate(progress);\n        \n        if (_meditationLight != null)\n        {\n            _meditationLight.intensity = _originalLightIntensity.x * curveValue;\n        }\n    }\n    \n    private void CompleteMeditation()\n    {\n        _isMeditating = false;\n        _meditationProgress = 1f;\n        \n        if (_audioSource != null && _healingCompleteSound != null)\n            _audioSource.PlayOneShot(_healingCompleteSound);\n            \n        OnHealingComplete?.Invoke(_healingAmount);\n        \n        StartCooldown();\n        ResetMeditationEffects();\n    }\n    \n    private void ResetMeditationEffects()\n    {\n        if (_healingParticles != null)\n            _healingParticles.SetActive(false);\n            \n        if (_meditationLight != null)\n        {\n            _meditationLight.enabled = false;\n            _meditationLight.color = _originalLightColor;\n            _meditationLight.intensity = _originalLightIntensity.x;\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.loop = false;\n            _audioSource.Stop();\n        }\n        \n        _meditationProgress = 0f;\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _healingColor;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n    }\n    \n    private void OnValidate()\n    {\n        if (_healingAmount < 0f)\n            _healingAmount = 0f;\n            \n        if (_meditationDuration < 0.1f)\n            _meditationDuration = 0.1f;\n            \n        if (_cooldownTime < 0f)\n            _cooldownTime = 0f;\n            \n        if (_detectionRadius < 0.1f)\n            _detectionRadius = 0.1f;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rage mode transformation",
      "ideal_ir": {
        "class_name": "RageModeTransformation",
        "components": [
          "Transform",
          "Renderer",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "rageThreshold",
            "type": "float",
            "default": 25
          },
          {
            "name": "transformationDuration",
            "type": "float",
            "default": 2
          },
          {
            "name": "rageDamageMultiplier",
            "type": "float",
            "default": 2
          },
          {
            "name": "rageSpeedMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "isInRageMode",
            "type": "bool",
            "default": false
          },
          {
            "name": "originalScale",
            "type": "Vector3",
            "default": "1,1,1"
          },
          {
            "name": "rageScale",
            "type": "Vector3",
            "default": "1.3,1.3,1.3"
          },
          {
            "name": "originalColor",
            "type": "Color",
            "default": "white"
          },
          {
            "name": "rageColor",
            "type": "Color",
            "default": "red"
          }
        ],
        "behaviors": [
          {
            "name": "trigger_rage_transformation",
            "trigger": "when current health drops below rage threshold",
            "actions": [
              {
                "action": "set rage mode to active"
              },
              {
                "action": "play transformation sound effect"
              },
              {
                "action": "start particle effect for transformation"
              },
              {
                "action": "begin scaling up to rage size over transformation duration"
              },
              {
                "action": "gradually change color from original to rage color"
              }
            ]
          },
          {
            "name": "maintain_rage_effects",
            "trigger": "while in rage mode",
            "actions": [
              {
                "action": "apply damage multiplier to all attacks"
              },
              {
                "action": "apply speed multiplier to movement"
              },
              {
                "action": "emit continuous rage particles"
              },
              {
                "action": "play looping rage audio"
              },
              {
                "action": "pulse red glow effect"
              }
            ]
          },
          {
            "name": "exit_rage_mode",
            "trigger": "when health is restored above rage threshold",
            "actions": [
              {
                "action": "set rage mode to inactive"
              },
              {
                "action": "stop rage particle effects"
              },
              {
                "action": "stop rage audio loop"
              },
              {
                "action": "gradually scale back to original size"
              },
              {
                "action": "fade color back to original over time"
              },
              {
                "action": "reset damage multiplier to normal"
              },
              {
                "action": "reset speed multiplier to normal"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RageModeTransformation : MonoBehaviour\n{\n    [Header(\"Rage Mode Settings\")]\n    [SerializeField] private float _rageDuration = 10f;\n    [SerializeField] private float _rageActivationThreshold = 0.3f;\n    [SerializeField] private bool _autoActivateOnLowHealth = true;\n    [SerializeField] private KeyCode _manualActivationKey = KeyCode.R;\n    \n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth = 100f;\n    \n    [Header(\"Transformation Effects\")]\n    [SerializeField] private float _damageMultiplier = 2f;\n    [SerializeField] private float _speedMultiplier = 1.5f;\n    [SerializeField] private float _sizeMultiplier = 1.2f;\n    [SerializeField] private Color _rageColor = Color.red;\n    [SerializeField] private float _colorIntensity = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _rageParticles;\n    [SerializeField] private GameObject _rageAura;\n    [SerializeField] private Light _rageLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _transformationSound;\n    [SerializeField] private AudioClip _rageLoopSound;\n    \n    [Header(\"Screen Effects\")]\n    [SerializeField] private bool _enableScreenShake = true;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRageModeActivated;\n    public UnityEvent OnRageModeDeactivated;\n    public UnityEvent<float> OnHealthChanged;\n    \n    private bool _isInRageMode = false;\n    private float _rageTimer = 0f;\n    private Vector3 _originalScale;\n    private Color _originalColor;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Material _rageMaterial;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private Coroutine _shakeCoroutine;\n    \n    // Cached components\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    // Original values for restoration\n    private float _originalMass;\n    private float _originalDrag;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupMaterials();\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _mainCamera = Camera.main;\n        \n        _originalScale = transform.localScale;\n        \n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _originalMass = _rigidbody.mass;\n            _originalDrag = _rigidbody.drag;\n        }\n        \n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n    }\n    \n    private void SetupMaterials()\n    {\n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _rageMaterial = new Material(_originalMaterial);\n            _rageMaterial.color = _rageColor;\n            _rageMaterial.EnableKeyword(\"_EMISSION\");\n            _rageMaterial.SetColor(\"_EmissionColor\", _rageColor * _colorIntensity);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateRageMode();\n        CheckAutoActivation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_manualActivationKey) && !_isInRageMode)\n        {\n            ActivateRageMode();\n        }\n    }\n    \n    private void UpdateRageMode()\n    {\n        if (_isInRageMode)\n        {\n            _rageTimer -= Time.deltaTime;\n            \n            if (_rageTimer <= 0f)\n            {\n                DeactivateRageMode();\n            }\n        }\n    }\n    \n    private void CheckAutoActivation()\n    {\n        if (_autoActivateOnLowHealth && !_isInRageMode)\n        {\n            float healthPercentage = _currentHealth / _maxHealth;\n            if (healthPercentage <= _rageActivationThreshold)\n            {\n                ActivateRageMode();\n            }\n        }\n    }\n    \n    public void ActivateRageMode()\n    {\n        if (_isInRageMode) return;\n        \n        _isInRageMode = true;\n        _rageTimer = _rageDuration;\n        \n        ApplyTransformationEffects();\n        PlayTransformationEffects();\n        \n        OnRageModeActivated?.Invoke();\n    }\n    \n    public void DeactivateRageMode()\n    {\n        if (!_isInRageMode) return;\n        \n        _isInRageMode = false;\n        _rageTimer = 0f;\n        \n        RemoveTransformationEffects();\n        StopTransformationEffects();\n        \n        OnRageModeDeactivated?.Invoke();\n    }\n    \n    private void ApplyTransformationEffects()\n    {\n        // Scale transformation\n        transform.localScale = _originalScale * _sizeMultiplier;\n        \n        // Material transformation\n        if (_renderer != null && _rageMaterial != null)\n        {\n            _renderer.material = _rageMaterial;\n        }\n        \n        // Physics modifications\n        if (_rigidbody != null)\n        {\n            _rigidbody.mass = _originalMass * _damageMultiplier;\n            _rigidbody.drag = _originalDrag * 0.5f;\n        }\n        \n        // Light effects\n        if (_rageLight != null)\n        {\n            _rageLight.enabled = true;\n            _rageLight.color = _rageColor;\n            _rageLight.intensity = _colorIntensity;\n        }\n    }\n    \n    private void RemoveTransformationEffects()\n    {\n        // Restore scale\n        transform.localScale = _originalScale;\n        \n        // Restore material\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _renderer.material = _originalMaterial;\n        }\n        \n        // Restore physics\n        if (_rigidbody != null)\n        {\n            _rigidbody.mass = _originalMass;\n            _rigidbody.drag = _originalDrag;\n        }\n        \n        // Disable light\n        if (_rageLight != null)\n        {\n            _rageLight.enabled = false;\n        }\n    }\n    \n    private void PlayTransformationEffects()\n    {\n        // Particle effects\n        if (_rageParticles != null)\n        {\n            _rageParticles.Play();\n        }\n        \n        // Aura effects\n        if (_rageAura != null)\n        {\n            _rageAura.SetActive(true);\n        }\n        \n        // Sound effects\n        if (_audioSource != null)\n        {\n            if (_transformationSound != null)\n            {\n                _audioSource.PlayOneShot(_transformationSound);\n            }\n            \n            if (_rageLoopSound != null)\n            {\n                _audioSource.clip = _rageLoopSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        \n        // Screen shake\n        if (_enableScreenShake && _mainCamera != null)\n        {\n            if (_shakeCoroutine != null)\n            {\n                StopCoroutine(_shakeCoroutine);\n            }\n            _shakeCoroutine = StartCoroutine(ScreenShake());\n        }\n    }\n    \n    private void StopTransformationEffects()\n    {\n        // Stop particles\n        if (_rageParticles != null)\n        {\n            _rageParticles.Stop();\n        }\n        \n        // Disable aura\n        if (_rageAura != null)\n        {\n            _rageAura.SetActive(false);\n        }\n        \n        // Stop sounds\n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n        }\n        \n        // Stop screen shake\n        if (_shakeCoroutine != null)\n        {\n            StopCoroutine(_shakeCoroutine);\n            _shakeCoroutine = null;\n            \n            if (_mainCamera != null)\n            {\n                _mainCamera.transform.localPosition = _originalCameraPosition;\n            }\n        }\n    }\n    \n    private IEnumerator ScreenShake()\n    {\n        float elapsed = 0f;\n        \n        while (elapsed < _shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _shakeIntensity;\n            float y = Random.Range(-1f, 1f) * _shakeIntensity;\n            \n            _mainCamera.transform.localPosition = _originalCameraPosition + new Vector3(x, y, 0f);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.localPosition = _originalCameraPosition;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    public void Heal(float healAmount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    public float GetDamageMultiplier()\n    {\n        return _isInRageMode ? _damageMultiplier : 1f;\n    }\n    \n    public float GetSpeedMultiplier()\n    {\n        return _isInRageMode ? _speedMultiplier : 1f;\n    }\n    \n    public bool IsInRageMode()\n    {\n        return _isInRageMode;\n    }\n    \n    public float GetRageTimeRemaining()\n    {\n        return _rageTimer;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_rageMaterial != null)\n        {\n            DestroyImmediate(_rageMaterial);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInRageMode && other.CompareTag(\"Enemy\"))\n        {\n            // Apply rage damage to enemies\n            var enemyHealth = other.GetComponent<RageModeTransformation>();\n            if (enemyHealth != null)\n            {\n                enemyHealth.TakeDamage(10f * _damageMultiplier);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "inventory grid system",
      "ideal_ir": {
        "class_name": "InventoryGrid",
        "components": [
          "Canvas",
          "GridLayoutGroup"
        ],
        "fields": [
          {
            "name": "gridWidth",
            "type": "int",
            "default": 8
          },
          {
            "name": "gridHeight",
            "type": "int",
            "default": 6
          },
          {
            "name": "slotPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "itemDatabase",
            "type": "ScriptableObject",
            "default": null
          },
          {
            "name": "maxStackSize",
            "type": "int",
            "default": 99
          },
          {
            "name": "selectedSlot",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initialize_grid",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "create grid slots based on width and height"
              },
              {
                "action": "assign unique coordinates to each slot"
              },
              {
                "action": "setup visual layout with proper spacing"
              }
            ]
          },
          {
            "name": "add_item_to_inventory",
            "trigger": "when item is added to inventory",
            "actions": [
              {
                "action": "find first available slot that can hold the item"
              },
              {
                "action": "check if item can stack with existing items"
              },
              {
                "action": "place item in appropriate slot"
              },
              {
                "action": "update slot visual display"
              }
            ]
          },
          {
            "name": "remove_item_from_slot",
            "trigger": "when item is removed from slot",
            "actions": [
              {
                "action": "clear item data from slot"
              },
              {
                "action": "update slot visual to show empty state"
              },
              {
                "action": "return removed item data"
              }
            ]
          },
          {
            "name": "handle_slot_click",
            "trigger": "when player clicks on inventory slot",
            "actions": [
              {
                "action": "select the clicked slot"
              },
              {
                "action": "highlight selected slot visually"
              },
              {
                "action": "show item tooltip if slot contains item"
              }
            ]
          },
          {
            "name": "drag_item_between_slots",
            "trigger": "when player drags item from one slot to another",
            "actions": [
              {
                "action": "validate if target slot can accept the item"
              },
              {
                "action": "swap items between slots if both contain items"
              },
              {
                "action": "move item to empty target slot"
              },
              {
                "action": "update both slot visuals"
              }
            ]
          },
          {
            "name": "stack_items",
            "trigger": "when stackable items are combined",
            "actions": [
              {
                "action": "check if items are of same type"
              },
              {
                "action": "verify total quantity does not exceed stack limit"
              },
              {
                "action": "combine item quantities in target slot"
              },
              {
                "action": "clear source slot if fully transferred"
              }
            ]
          },
          {
            "name": "split_item_stack",
            "trigger": "when player right clicks on stacked item",
            "actions": [
              {
                "action": "divide item stack into two equal parts"
              },
              {
                "action": "keep half in original slot"
              },
              {
                "action": "place other half in cursor for placement"
              }
            ]
          },
          {
            "name": "sort_inventory",
            "trigger": "when sort button is pressed",
            "actions": [
              {
                "action": "group items by type and rarity"
              },
              {
                "action": "arrange items in organized grid pattern"
              },
              {
                "action": "stack similar items together when possible"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing System.Collections.Generic;\nusing System;\n\npublic class InventoryGridSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class InventoryItem\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public int stackSize = 1;\n        public int currentStack = 1;\n        public ItemType itemType;\n        \n        public InventoryItem(string name, Sprite icon, ItemType type, int stack = 1)\n        {\n            itemName = name;\n            itemIcon = icon;\n            itemType = type;\n            stackSize = stack;\n            currentStack = 1;\n        }\n    }\n    \n    public enum ItemType\n    {\n        Consumable,\n        Equipment,\n        Material,\n        Quest\n    }\n    \n    [System.Serializable]\n    public class GridSlot\n    {\n        public InventoryItem item;\n        public bool isEmpty = true;\n        public Vector2Int gridPosition;\n        \n        public void SetItem(InventoryItem newItem)\n        {\n            item = newItem;\n            isEmpty = false;\n        }\n        \n        public void ClearSlot()\n        {\n            item = null;\n            isEmpty = true;\n        }\n    }\n    \n    [Header(\"Grid Settings\")]\n    [SerializeField] private int _gridWidth = 8;\n    [SerializeField] private int _gridHeight = 6;\n    [SerializeField] private float _slotSize = 64f;\n    [SerializeField] private float _slotSpacing = 4f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _gridParent;\n    [SerializeField] private GameObject _slotPrefab;\n    [SerializeField] private Canvas _inventoryCanvas;\n    \n    [Header(\"Drag and Drop\")]\n    [SerializeField] private GameObject _dragPreviewPrefab;\n    [SerializeField] private LayerMask _slotLayerMask = -1;\n    \n    private GridSlot[,] _inventoryGrid;\n    private GameObject[,] _slotObjects;\n    private Camera _uiCamera;\n    private InventorySlotUI _draggedSlot;\n    private GameObject _dragPreview;\n    private bool _isDragging;\n    \n    public event Action<InventoryItem> OnItemAdded;\n    public event Action<InventoryItem> OnItemRemoved;\n    public event Action OnInventoryChanged;\n    \n    private void Start()\n    {\n        _uiCamera = _inventoryCanvas.worldCamera ?? Camera.main;\n        InitializeGrid();\n        CreateGridUI();\n    }\n    \n    private void Update()\n    {\n        HandleDragAndDrop();\n    }\n    \n    private void InitializeGrid()\n    {\n        _inventoryGrid = new GridSlot[_gridWidth, _gridHeight];\n        _slotObjects = new GameObject[_gridWidth, _gridHeight];\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                _inventoryGrid[x, y] = new GridSlot();\n                _inventoryGrid[x, y].gridPosition = new Vector2Int(x, y);\n            }\n        }\n    }\n    \n    private void CreateGridUI()\n    {\n        if (_gridParent == null || _slotPrefab == null) return;\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                GameObject slotObj = Instantiate(_slotPrefab, _gridParent);\n                RectTransform slotRect = slotObj.GetComponent<RectTransform>();\n                \n                float posX = x * (_slotSize + _slotSpacing);\n                float posY = -y * (_slotSize + _slotSpacing);\n                slotRect.anchoredPosition = new Vector2(posX, posY);\n                slotRect.sizeDelta = new Vector2(_slotSize, _slotSize);\n                \n                InventorySlotUI slotUI = slotObj.GetComponent<InventorySlotUI>();\n                if (slotUI == null)\n                    slotUI = slotObj.AddComponent<InventorySlotUI>();\n                \n                slotUI.Initialize(new Vector2Int(x, y), this);\n                _slotObjects[x, y] = slotObj;\n            }\n        }\n    }\n    \n    public bool AddItem(InventoryItem item)\n    {\n        if (item == null) return false;\n        \n        // Try to stack with existing items first\n        if (TryStackItem(item)) return true;\n        \n        // Find empty slot\n        Vector2Int emptySlot = FindEmptySlot();\n        if (emptySlot.x == -1) return false;\n        \n        _inventoryGrid[emptySlot.x, emptySlot.y].SetItem(item);\n        UpdateSlotUI(emptySlot.x, emptySlot.y);\n        \n        OnItemAdded?.Invoke(item);\n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    public bool RemoveItem(Vector2Int gridPos)\n    {\n        if (!IsValidPosition(gridPos) || _inventoryGrid[gridPos.x, gridPos.y].isEmpty)\n            return false;\n        \n        InventoryItem removedItem = _inventoryGrid[gridPos.x, gridPos.y].item;\n        _inventoryGrid[gridPos.x, gridPos.y].ClearSlot();\n        UpdateSlotUI(gridPos.x, gridPos.y);\n        \n        OnItemRemoved?.Invoke(removedItem);\n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    public bool MoveItem(Vector2Int fromPos, Vector2Int toPos)\n    {\n        if (!IsValidPosition(fromPos) || !IsValidPosition(toPos))\n            return false;\n        \n        if (_inventoryGrid[fromPos.x, fromPos.y].isEmpty)\n            return false;\n        \n        // Swap items\n        GridSlot fromSlot = _inventoryGrid[fromPos.x, fromPos.y];\n        GridSlot toSlot = _inventoryGrid[toPos.x, toPos.y];\n        \n        _inventoryGrid[toPos.x, toPos.y] = fromSlot;\n        _inventoryGrid[fromPos.x, fromPos.y] = toSlot;\n        \n        _inventoryGrid[toPos.x, toPos.y].gridPosition = toPos;\n        _inventoryGrid[fromPos.x, fromPos.y].gridPosition = fromPos;\n        \n        UpdateSlotUI(fromPos.x, fromPos.y);\n        UpdateSlotUI(toPos.x, toPos.y);\n        \n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    private bool TryStackItem(InventoryItem item)\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                GridSlot slot = _inventoryGrid[x, y];\n                if (!slot.isEmpty && slot.item.itemName == item.itemName)\n                {\n                    if (slot.item.currentStack < slot.item.stackSize)\n                    {\n                        int spaceLeft = slot.item.stackSize - slot.item.currentStack;\n                        int toAdd = Mathf.Min(spaceLeft, item.currentStack);\n                        slot.item.currentStack += toAdd;\n                        item.currentStack -= toAdd;\n                        \n                        UpdateSlotUI(x, y);\n                        \n                        if (item.currentStack <= 0)\n                            return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    private Vector2Int FindEmptySlot()\n    {\n        for (int y = 0; y < _gridHeight; y++)\n        {\n            for (int x = 0; x < _gridWidth; x++)\n            {\n                if (_inventoryGrid[x, y].isEmpty)\n                    return new Vector2Int(x, y);\n            }\n        }\n        return new Vector2Int(-1, -1);\n    }\n    \n    private bool IsValidPosition(Vector2Int pos)\n    {\n        return pos.x >= 0 && pos.x < _gridWidth && pos.y >= 0 && pos.y < _gridHeight;\n    }\n    \n    private void UpdateSlotUI(int x, int y)\n    {\n        if (_slotObjects[x, y] != null)\n        {\n            InventorySlotUI slotUI = _slotObjects[x, y].GetComponent<InventorySlotUI>();\n            if (slotUI != null)\n            {\n                slotUI.UpdateSlot(_inventoryGrid[x, y]);\n            }\n        }\n    }\n    \n    private void HandleDragAndDrop()\n    {\n        if (_isDragging && _dragPreview != null)\n        {\n            Vector3 mousePos = Input.mousePosition;\n            _dragPreview.transform.position = mousePos;\n        }\n    }\n    \n    public void StartDrag(InventorySlotUI slotUI)\n    {\n        if (slotUI.GridSlot.isEmpty) return;\n        \n        _draggedSlot = slotUI;\n        _isDragging = true;\n        \n        if (_dragPreviewPrefab != null)\n        {\n            _dragPreview = Instantiate(_dragPreviewPrefab, _inventoryCanvas.transform);\n            Image previewImage = _dragPreview.GetComponent<Image>();\n            if (previewImage != null)\n            {\n                previewImage.sprite = slotUI.GridSlot.item.itemIcon;\n            }\n        }\n    }\n    \n    public void EndDrag(InventorySlotUI targetSlot)\n    {\n        if (!_isDragging || _draggedSlot == null) return;\n        \n        if (targetSlot != null && targetSlot != _draggedSlot)\n        {\n            MoveItem(_draggedSlot.GridPosition, targetSlot.GridPosition);\n        }\n        \n        _isDragging = false;\n        _draggedSlot = null;\n        \n        if (_dragPreview != null)\n        {\n            Destroy(_dragPreview);\n            _dragPreview = null;\n        }\n    }\n    \n    public GridSlot GetSlot(Vector2Int position)\n    {\n        if (!IsValidPosition(position)) return null;\n        return _inventoryGrid[position.x, position.y];\n    }\n    \n    public List<InventoryItem> GetAllItems()\n    {\n        List<InventoryItem> items = new List<InventoryItem>();\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (!_inventoryGrid[x, y].isEmpty)\n                {\n                    items.Add(_inventoryGrid[x, y].item);\n                }\n            }\n        }\n        \n        return items;\n    }\n    \n    public void ClearInventory()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                _inventoryGrid[x, y].ClearSlot();\n                UpdateSlotUI(x, y);\n            }\n        }\n        \n        OnInventoryChanged?.Invoke();\n    }\n}\n\npublic class InventorySlotUI : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler\n{\n    [Header(\"UI Components\")]\n    [SerializeField] private Image _itemIcon;\n    [SerializeField] private Text _stackText;\n    [SerializeField] private Image _background;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    \n    private Vector2Int _gridPosition;\n    private InventoryGridSystem _inventorySystem;\n    private InventoryGridSystem.GridSlot _gridSlot;\n    \n    public Vector2Int GridPosition => _gridPosition;\n    public InventoryGridSystem.GridSlot GridSlot => _gridSlot;\n    \n    public void Initialize(Vector2Int position, InventoryGridSystem inventorySystem)\n    {\n        _gridPosition = position;\n        _inventorySystem = inventorySystem;\n        \n        if (_itemIcon == null) _itemIcon = GetComponentInChildren<Image>();\n        if (_stackText == null) _stackText = GetComponentInChildren<Text>();\n        if (_background == null) _background = GetComponent<Image>();\n        \n        UpdateSlot(_inventorySystem.GetSlot(_gridPosition));\n    }\n    \n    public void UpdateSlot(InventoryGridSystem.GridSlot slot)\n    {\n        _gridSlot = slot;\n        \n        if (slot == null || slot.isEmpty)\n        {\n            if (_itemIcon != null) _itemIcon.sprite = null;\n            if (_itemIcon != null) _itemIcon.color = Color.clear;\n            if (_stackText != null) _stackText.text = \"\";\n        }\n        else\n        {\n            if (_itemIcon != null)\n            {\n                _itemIcon.sprite = slot.item.itemIcon;\n                _itemIcon.color = Color.white;\n            }\n            \n            if (_stackText != null)\n            {\n                _stackText.text = slot.item.currentStack > 1 ? slot.item.currentStack.ToString() : \"\";\n            }\n        }\n    }\n    \n    public void OnPointerDown(PointerEventData eventData)\n    {\n        if (_inventorySystem != null && !_gridSlot.isEmpty)\n        {\n            _inventorySystem.StartDrag(this);\n        }\n    }\n    \n    public void OnPointerUp(PointerEventData eventData)\n    {\n        if (_inventorySystem != null)\n        {\n            _inventorySystem.EndDrag(this);\n        }\n    }\n    \n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        if (_background != null)\n        {\n            _background.color = _highlightColor;\n        }\n    }\n    \n    public void OnPointerExit(PointerEventData eventData)\n    {\n        if (_background != null)\n        {\n            _background.color = _normalColor;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "quest tracker display",
      "ideal_ir": {
        "class_name": "QuestTrackerDisplay",
        "components": [
          "Canvas",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "questTitleText",
            "type": "Text",
            "default": null
          },
          {
            "name": "questDescriptionText",
            "type": "Text",
            "default": null
          },
          {
            "name": "objectivesList",
            "type": "Transform",
            "default": null
          },
          {
            "name": "objectiveTextPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "displayPosition",
            "type": "Vector2",
            "default": {
              "x": 50,
              "y": -50
            }
          },
          {
            "name": "maxObjectivesToShow",
            "type": "int",
            "default": 5
          },
          {
            "name": "autoHideDelay",
            "type": "float",
            "default": 10
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_quest_tracker",
            "trigger": "when new quest is accepted or quest updates",
            "actions": [
              {
                "action": "fade in the quest tracker display"
              },
              {
                "action": "update quest title text with current quest name"
              },
              {
                "action": "update quest description text with current quest details"
              },
              {
                "action": "clear existing objective list items"
              },
              {
                "action": "create new objective text items for each active objective"
              },
              {
                "action": "mark incomplete objectives with bullet points"
              },
              {
                "action": "mark completed objectives with checkmarks"
              },
              {
                "action": "position tracker at designated screen location"
              },
              {
                "action": "set visibility flag to true"
              }
            ]
          },
          {
            "name": "hide_quest_tracker",
            "trigger": "when quest is completed or player requests to hide tracker",
            "actions": [
              {
                "action": "fade out the quest tracker display"
              },
              {
                "action": "set visibility flag to false"
              },
              {
                "action": "clear all quest text content"
              }
            ]
          },
          {
            "name": "update_objective_status",
            "trigger": "when quest objective progress changes",
            "actions": [
              {
                "action": "find the corresponding objective text item"
              },
              {
                "action": "update objective text with current progress"
              },
              {
                "action": "change visual indicator from bullet to checkmark if completed"
              },
              {
                "action": "apply strikethrough formatting to completed objectives"
              },
              {
                "action": "play subtle completion animation if objective finished"
              }
            ]
          },
          {
            "name": "auto_hide_tracker",
            "trigger": "when tracker has been visible for auto hide duration",
            "actions": [
              {
                "action": "gradually fade out the quest tracker"
              },
              {
                "action": "set visibility flag to false"
              }
            ]
          },
          {
            "name": "toggle_tracker_visibility",
            "trigger": "when player presses quest tracker toggle key",
            "actions": [
              {
                "action": "check current visibility state"
              },
              {
                "action": "show tracker if currently hidden"
              },
              {
                "action": "hide tracker if currently visible"
              }
            ]
          },
          {
            "name": "limit_objective_display",
            "trigger": "when quest has more objectives than maximum display limit",
            "actions": [
              {
                "action": "show only the most recent objectives up to maximum limit"
              },
              {
                "action": "add indicator text showing additional objectives exist"
              },
              {
                "action": "prioritize incomplete objectives over completed ones"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\nusing System;\n\npublic class QuestTrackerDisplay : MonoBehaviour\n{\n    [System.Serializable]\n    public class Quest\n    {\n        public string questId;\n        public string title;\n        public string description;\n        public List<QuestObjective> objectives;\n        public bool isCompleted;\n        public bool isActive;\n        \n        public Quest(string id, string questTitle, string questDescription)\n        {\n            questId = id;\n            title = questTitle;\n            description = questDescription;\n            objectives = new List<QuestObjective>();\n            isCompleted = false;\n            isActive = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class QuestObjective\n    {\n        public string description;\n        public int currentCount;\n        public int targetCount;\n        public bool isCompleted;\n        \n        public QuestObjective(string desc, int target)\n        {\n            description = desc;\n            currentCount = 0;\n            targetCount = target;\n            isCompleted = false;\n        }\n        \n        public void UpdateProgress(int amount)\n        {\n            currentCount = Mathf.Clamp(currentCount + amount, 0, targetCount);\n            isCompleted = currentCount >= targetCount;\n        }\n    }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _questTrackerPanel;\n    [SerializeField] private Transform _questContainer;\n    [SerializeField] private GameObject _questEntryPrefab;\n    [SerializeField] private Button _toggleButton;\n    [SerializeField] private Text _noQuestsText;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private int _maxDisplayedQuests = 5;\n    [SerializeField] private bool _showCompletedQuests = false;\n    [SerializeField] private bool _autoHideWhenEmpty = true;\n    [SerializeField] private Color _completedQuestColor = Color.green;\n    [SerializeField] private Color _activeQuestColor = Color.white;\n    [SerializeField] private Color _objectiveCompletedColor = Color.gray;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _useAnimations = true;\n    [SerializeField] private float _fadeSpeed = 2f;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private List<Quest> _allQuests = new List<Quest>();\n    private List<GameObject> _questEntryObjects = new List<GameObject>();\n    private bool _isVisible = true;\n    private CanvasGroup _canvasGroup;\n    \n    public static event Action<string> OnQuestCompleted;\n    public static event Action<string, int> OnObjectiveUpdated;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void Start()\n    {\n        InitializeUI();\n        RefreshDisplay();\n        \n        if (_toggleButton != null)\n            _toggleButton.onClick.AddListener(ToggleVisibility);\n    }\n    \n    private void InitializeUI()\n    {\n        if (_questTrackerPanel == null)\n            _questTrackerPanel = gameObject;\n            \n        if (_noQuestsText != null)\n            _noQuestsText.text = \"No active quests\";\n    }\n    \n    public void AddQuest(string questId, string title, string description)\n    {\n        if (GetQuestById(questId) != null)\n            return;\n            \n        Quest newQuest = new Quest(questId, title, description);\n        newQuest.isActive = true;\n        _allQuests.Add(newQuest);\n        RefreshDisplay();\n    }\n    \n    public void AddObjectiveToQuest(string questId, string objectiveDescription, int targetCount)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        QuestObjective objective = new QuestObjective(objectiveDescription, targetCount);\n        quest.objectives.Add(objective);\n        RefreshDisplay();\n    }\n    \n    public void UpdateObjective(string questId, int objectiveIndex, int progressAmount)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null || objectiveIndex < 0 || objectiveIndex >= quest.objectives.Count)\n            return;\n            \n        QuestObjective objective = quest.objectives[objectiveIndex];\n        objective.UpdateProgress(progressAmount);\n        \n        OnObjectiveUpdated?.Invoke(questId, objectiveIndex);\n        \n        CheckQuestCompletion(quest);\n        RefreshDisplay();\n    }\n    \n    public void CompleteQuest(string questId)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        quest.isCompleted = true;\n        quest.isActive = false;\n        \n        foreach (var objective in quest.objectives)\n        {\n            objective.isCompleted = true;\n            objective.currentCount = objective.targetCount;\n        }\n        \n        OnQuestCompleted?.Invoke(questId);\n        RefreshDisplay();\n        \n        if (_useAnimations)\n            StartCoroutine(AnimateQuestCompletion(questId));\n    }\n    \n    public void RemoveQuest(string questId)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        _allQuests.Remove(quest);\n        RefreshDisplay();\n    }\n    \n    private Quest GetQuestById(string questId)\n    {\n        return _allQuests.Find(q => q.questId == questId);\n    }\n    \n    private void CheckQuestCompletion(Quest quest)\n    {\n        if (quest.isCompleted)\n            return;\n            \n        bool allObjectivesComplete = true;\n        foreach (var objective in quest.objectives)\n        {\n            if (!objective.isCompleted)\n            {\n                allObjectivesComplete = false;\n                break;\n            }\n        }\n        \n        if (allObjectivesComplete && quest.objectives.Count > 0)\n        {\n            CompleteQuest(quest.questId);\n        }\n    }\n    \n    private void RefreshDisplay()\n    {\n        ClearQuestEntries();\n        \n        List<Quest> displayQuests = GetQuestsToDisplay();\n        \n        if (displayQuests.Count == 0)\n        {\n            ShowNoQuestsMessage();\n            if (_autoHideWhenEmpty)\n                SetVisibility(false);\n            return;\n        }\n        \n        HideNoQuestsMessage();\n        \n        foreach (Quest quest in displayQuests)\n        {\n            CreateQuestEntry(quest);\n        }\n        \n        if (_autoHideWhenEmpty)\n            SetVisibility(true);\n    }\n    \n    private List<Quest> GetQuestsToDisplay()\n    {\n        List<Quest> displayQuests = new List<Quest>();\n        \n        foreach (Quest quest in _allQuests)\n        {\n            if (quest.isActive || (_showCompletedQuests && quest.isCompleted))\n            {\n                displayQuests.Add(quest);\n            }\n        }\n        \n        if (displayQuests.Count > _maxDisplayedQuests)\n        {\n            displayQuests = displayQuests.GetRange(0, _maxDisplayedQuests);\n        }\n        \n        return displayQuests;\n    }\n    \n    private void CreateQuestEntry(Quest quest)\n    {\n        if (_questEntryPrefab == null || _questContainer == null)\n            return;\n            \n        GameObject entryObject = Instantiate(_questEntryPrefab, _questContainer);\n        _questEntryObjects.Add(entryObject);\n        \n        QuestEntryUI entryUI = entryObject.GetComponent<QuestEntryUI>();\n        if (entryUI == null)\n            entryUI = entryObject.AddComponent<QuestEntryUI>();\n            \n        entryUI.SetupQuestEntry(quest, _completedQuestColor, _activeQuestColor, _objectiveCompletedColor);\n        \n        if (_useAnimations)\n            StartCoroutine(AnimateEntryAppearance(entryObject));\n    }\n    \n    private void ClearQuestEntries()\n    {\n        foreach (GameObject entry in _questEntryObjects)\n        {\n            if (entry != null)\n                DestroyImmediate(entry);\n        }\n        _questEntryObjects.Clear();\n    }\n    \n    private void ShowNoQuestsMessage()\n    {\n        if (_noQuestsText != null)\n            _noQuestsText.gameObject.SetActive(true);\n    }\n    \n    private void HideNoQuestsMessage()\n    {\n        if (_noQuestsText != null)\n            _noQuestsText.gameObject.SetActive(false);\n    }\n    \n    public void ToggleVisibility()\n    {\n        SetVisibility(!_isVisible);\n    }\n    \n    public void SetVisibility(bool visible)\n    {\n        _isVisible = visible;\n        \n        if (_useAnimations)\n        {\n            StopAllCoroutines();\n            StartCoroutine(AnimateVisibility(visible));\n        }\n        else\n        {\n            _questTrackerPanel.SetActive(visible);\n        }\n    }\n    \n    private System.Collections.IEnumerator AnimateVisibility(bool show)\n    {\n        float targetAlpha = show ? 1f : 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        if (show)\n            _questTrackerPanel.SetActive(true);\n        \n        float elapsed = 0f;\n        while (elapsed < 1f / _fadeSpeed)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed * _fadeSpeed;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = targetAlpha;\n        \n        if (!show)\n            _questTrackerPanel.SetActive(false);\n    }\n    \n    private System.Collections.IEnumerator AnimateEntryAppearance(GameObject entry)\n    {\n        Transform entryTransform = entry.transform;\n        Vector3 originalScale = entryTransform.localScale;\n        entryTransform.localScale = Vector3.zero;\n        \n        float elapsed = 0f;\n        float duration = 0.3f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n            float scaleValue = _scaleCurve.Evaluate(progress);\n            entryTransform.localScale = originalScale * scaleValue;\n            yield return null;\n        }\n        \n        entryTransform.localScale = originalScale;\n    }\n    \n    private System.Collections.IEnumerator AnimateQuestCompletion(string questId)\n    {\n        yield return new WaitForSeconds(2f);\n        \n        if (!_showCompletedQuests)\n        {\n            RemoveQuest(questId);\n        }\n    }\n}\n\npublic class QuestEntryUI : MonoBehaviour\n{\n    private Text _titleText;\n    private Text _descriptionText;\n    private Transform _objectivesContainer;\n    private GameObject _objectivePrefab;\n    \n    private void Awake()\n    {\n        FindUIComponents();\n    }\n    \n    private void FindUIComponents()\n    {\n        _titleText = transform.Find(\"Title\")?.GetComponent<Text>();\n        _descriptionText = transform.Find(\"Description\")?.GetComponent<Text>();\n        _objectivesContainer = transform.Find(\"Objectives\");\n        \n        if (_objectivesContainer != null && _objectivesContainer.childCount > 0)\n        {\n            _objectivePrefab = _objectivesContainer.GetChild(0).gameObject;\n            _objectivePrefab.SetActive(false);\n        }\n    }\n    \n    public void SetupQuestEntry(QuestTrackerDisplay.Quest quest, Color completedColor, Color activeColor, Color objectiveCompletedColor)\n    {\n        if (_titleText != null)\n        {\n            _titleText.text = quest.title;\n            _titleText.color = quest.isCompleted ? completedColor : activeColor;\n        }\n        \n        if (_descriptionText != null)\n        {\n            _descriptionText.text = quest.description;\n            _descriptionText.color = quest.isCompleted ? completedColor : activeColor;\n        }\n        \n        SetupObjectives(quest.objectives, objectiveCompletedColor);\n    }\n    \n    private void SetupObjectives(List<QuestTrackerDisplay.QuestObjective> objectives, Color completedColor)\n    {\n        if (_objectivesContainer == null || _objectivePrefab == null)\n            return;\n            \n        foreach (Transform child in _objectivesContainer)\n        {\n            if (child.gameObject != _objectivePrefab)\n                DestroyImmediate(child.gameObject);\n        }\n        \n        foreach (var objective in objectives)\n        {\n            GameObject objEntry = Instantiate(_objectivePrefab, _objectivesContainer);\n            objEntry.SetActive(true);\n            \n            Text objText = objEntry.GetComponent<Text>();\n            if (objText != null)\n            {\n                string progressText = objective.targetCount > 1 ? \n                    $\" ({objective.currentCount}/{objective.targetCount})\" : \"\";\n                objText.text = \"\u2022 \" + objective.description + progressText;\n                objText.color = objective.isCompleted ? completedColor : Color.white;\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "enemy health bar above head",
      "ideal_ir": {
        "class_name": "EnemyHealthBar",
        "components": [
          "Canvas",
          "Image",
          "RectTransform"
        ],
        "fields": [
          {
            "name": "maxHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentHealth",
            "type": "float",
            "default": 100
          },
          {
            "name": "healthBarFill",
            "type": "Image",
            "default": null
          },
          {
            "name": "followTarget",
            "type": "Transform",
            "default": null
          },
          {
            "name": "heightOffset",
            "type": "float",
            "default": 2.5
          },
          {
            "name": "smoothSpeed",
            "type": "float",
            "default": 5
          }
        ],
        "behaviors": [
          {
            "name": "follow_enemy_head",
            "trigger": "every frame",
            "actions": [
              {
                "action": "position health bar above the enemy head with height offset"
              },
              {
                "action": "make health bar face the camera"
              },
              {
                "action": "smoothly interpolate position changes"
              }
            ]
          },
          {
            "name": "update_health_display",
            "trigger": "when enemy health changes",
            "actions": [
              {
                "action": "calculate health percentage from current and max health"
              },
              {
                "action": "update fill amount of health bar image to match percentage"
              },
              {
                "action": "change health bar color based on health percentage"
              }
            ]
          },
          {
            "name": "hide_when_full_health",
            "trigger": "when enemy is at full health",
            "actions": [
              {
                "action": "make health bar invisible"
              }
            ]
          },
          {
            "name": "show_when_damaged",
            "trigger": "when enemy takes damage",
            "actions": [
              {
                "action": "make health bar visible"
              },
              {
                "action": "briefly highlight or flash the health bar"
              }
            ]
          },
          {
            "name": "hide_when_dead",
            "trigger": "when enemy health reaches zero",
            "actions": [
              {
                "action": "fade out health bar"
              },
              {
                "action": "disable health bar after fade completes"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class EnemyHealthBar : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Canvas _healthBarCanvas;\n    [SerializeField] private Slider _healthSlider;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Vector3 _offset = new Vector3(0, 2f, 0);\n    [SerializeField] private Color _fullHealthColor = Color.green;\n    [SerializeField] private Color _lowHealthColor = Color.red;\n    [SerializeField] private float _lowHealthThreshold = 0.3f;\n    [SerializeField] private bool _hideWhenFull = true;\n    [SerializeField] private bool _alwaysFaceCamera = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _smoothTime = 0.1f;\n    [SerializeField] private AnimationCurve _damageCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Camera _mainCamera;\n    private float _targetHealthPercentage;\n    private float _displayHealthPercentage;\n    private float _velocity;\n    private bool _isAnimating;\n    \n    private void Awake()\n    {\n        _currentHealth = _maxHealth;\n        _targetHealthPercentage = 1f;\n        _displayHealthPercentage = 1f;\n        \n        CreateHealthBarUI();\n    }\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        UpdateHealthBar();\n    }\n    \n    private void Update()\n    {\n        if (_healthBarCanvas != null)\n        {\n            UpdatePosition();\n            UpdateRotation();\n            AnimateHealthBar();\n        }\n    }\n    \n    private void CreateHealthBarUI()\n    {\n        if (_healthBarCanvas != null) return;\n        \n        GameObject canvasGO = new GameObject(\"HealthBarCanvas\");\n        canvasGO.transform.SetParent(transform);\n        canvasGO.transform.localPosition = _offset;\n        \n        _healthBarCanvas = canvasGO.AddComponent<Canvas>();\n        _healthBarCanvas.renderMode = RenderMode.WorldSpace;\n        _healthBarCanvas.sortingOrder = 10;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ConstantWorldSize;\n        scaler.referencePixelsPerUnit = 100;\n        \n        RectTransform canvasRect = _healthBarCanvas.GetComponent<RectTransform>();\n        canvasRect.sizeDelta = new Vector2(2f, 0.3f);\n        \n        GameObject sliderGO = new GameObject(\"HealthSlider\");\n        sliderGO.transform.SetParent(canvasGO.transform, false);\n        \n        _healthSlider = sliderGO.AddComponent<Slider>();\n        _healthSlider.minValue = 0f;\n        _healthSlider.maxValue = 1f;\n        _healthSlider.value = 1f;\n        \n        RectTransform sliderRect = sliderGO.GetComponent<RectTransform>();\n        sliderRect.anchorMin = Vector2.zero;\n        sliderRect.anchorMax = Vector2.one;\n        sliderRect.sizeDelta = Vector2.zero;\n        sliderRect.anchoredPosition = Vector2.zero;\n        \n        GameObject backgroundGO = new GameObject(\"Background\");\n        backgroundGO.transform.SetParent(sliderGO.transform, false);\n        _backgroundImage = backgroundGO.AddComponent<Image>();\n        _backgroundImage.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);\n        \n        RectTransform bgRect = backgroundGO.GetComponent<RectTransform>();\n        bgRect.anchorMin = Vector2.zero;\n        bgRect.anchorMax = Vector2.one;\n        bgRect.sizeDelta = Vector2.zero;\n        bgRect.anchoredPosition = Vector2.zero;\n        \n        GameObject fillAreaGO = new GameObject(\"Fill Area\");\n        fillAreaGO.transform.SetParent(sliderGO.transform, false);\n        \n        RectTransform fillAreaRect = fillAreaGO.GetComponent<RectTransform>();\n        fillAreaRect.anchorMin = Vector2.zero;\n        fillAreaRect.anchorMax = Vector2.one;\n        fillAreaRect.sizeDelta = Vector2.zero;\n        fillAreaRect.anchoredPosition = Vector2.zero;\n        \n        GameObject fillGO = new GameObject(\"Fill\");\n        fillGO.transform.SetParent(fillAreaGO.transform, false);\n        _fillImage = fillGO.AddComponent<Image>();\n        _fillImage.color = _fullHealthColor;\n        _fillImage.type = Image.Type.Filled;\n        \n        RectTransform fillRect = fillGO.GetComponent<RectTransform>();\n        fillRect.anchorMin = Vector2.zero;\n        fillRect.anchorMax = Vector2.one;\n        fillRect.sizeDelta = Vector2.zero;\n        fillRect.anchoredPosition = Vector2.zero;\n        \n        _healthSlider.fillRect = fillRect;\n    }\n    \n    private void UpdatePosition()\n    {\n        if (_healthBarCanvas != null)\n        {\n            _healthBarCanvas.transform.position = transform.position + _offset;\n        }\n    }\n    \n    private void UpdateRotation()\n    {\n        if (_alwaysFaceCamera && _mainCamera != null && _healthBarCanvas != null)\n        {\n            Vector3 directionToCamera = _mainCamera.transform.position - _healthBarCanvas.transform.position;\n            _healthBarCanvas.transform.rotation = Quaternion.LookRotation(directionToCamera);\n        }\n    }\n    \n    private void AnimateHealthBar()\n    {\n        if (Mathf.Abs(_displayHealthPercentage - _targetHealthPercentage) > 0.01f)\n        {\n            _displayHealthPercentage = Mathf.SmoothDamp(_displayHealthPercentage, _targetHealthPercentage, ref _velocity, _smoothTime);\n            \n            if (_healthSlider != null)\n                _healthSlider.value = _displayHealthPercentage;\n                \n            UpdateHealthBarColor();\n        }\n    }\n    \n    private void UpdateHealthBar()\n    {\n        _targetHealthPercentage = _currentHealth / _maxHealth;\n        \n        UpdateHealthBarColor();\n        UpdateVisibility();\n    }\n    \n    private void UpdateHealthBarColor()\n    {\n        if (_fillImage != null)\n        {\n            float healthPercentage = _displayHealthPercentage;\n            \n            if (healthPercentage <= _lowHealthThreshold)\n            {\n                float t = healthPercentage / _lowHealthThreshold;\n                _fillImage.color = Color.Lerp(_lowHealthColor, _fullHealthColor, t);\n            }\n            else\n            {\n                _fillImage.color = _fullHealthColor;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_healthBarCanvas != null)\n        {\n            bool shouldShow = !_hideWhenFull || _currentHealth < _maxHealth;\n            _healthBarCanvas.gameObject.SetActive(shouldShow);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (damage <= 0) return;\n        \n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        UpdateHealthBar();\n        \n        if (_currentHealth <= 0)\n        {\n            OnDeath();\n        }\n    }\n    \n    public void Heal(float healAmount)\n    {\n        if (healAmount <= 0) return;\n        \n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        UpdateHealthBar();\n    }\n    \n    public void SetHealth(float newHealth)\n    {\n        _currentHealth = Mathf.Clamp(newHealth, 0, _maxHealth);\n        UpdateHealthBar();\n        \n        if (_currentHealth <= 0)\n        {\n            OnDeath();\n        }\n    }\n    \n    public void SetMaxHealth(float newMaxHealth)\n    {\n        float healthPercentage = _currentHealth / _maxHealth;\n        _maxHealth = Mathf.Max(1f, newMaxHealth);\n        _currentHealth = _maxHealth * healthPercentage;\n        UpdateHealthBar();\n    }\n    \n    private void OnDeath()\n    {\n        if (_healthBarCanvas != null)\n        {\n            _healthBarCanvas.gameObject.SetActive(false);\n        }\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    public bool IsAlive()\n    {\n        return _currentHealth > 0;\n    }\n    \n    private void OnValidate()\n    {\n        if (_maxHealth <= 0)\n            _maxHealth = 1f;\n            \n        _currentHealth = Mathf.Clamp(_currentHealth, 0, _maxHealth);\n        \n        if (Application.isPlaying)\n            UpdateHealthBar();\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "stamina bar with recovery",
      "ideal_ir": {
        "class_name": "StaminaBar",
        "components": [
          "UI.Slider"
        ],
        "fields": [
          {
            "name": "maxStamina",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentStamina",
            "type": "float",
            "default": 100
          },
          {
            "name": "recoveryRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "recoveryDelay",
            "type": "float",
            "default": 2
          },
          {
            "name": "isRecovering",
            "type": "bool",
            "default": false
          },
          {
            "name": "lastUsedTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "initialize_stamina_bar",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "set slider maximum value to max stamina"
              },
              {
                "action": "set slider current value to current stamina"
              }
            ]
          },
          {
            "name": "consume_stamina",
            "trigger": "when stamina is consumed",
            "actions": [
              {
                "action": "reduce current stamina by consumed amount"
              },
              {
                "action": "prevent stamina from going below zero"
              },
              {
                "action": "record current time as last used time"
              },
              {
                "action": "stop recovery process"
              },
              {
                "action": "update slider visual to show current stamina"
              }
            ]
          },
          {
            "name": "start_recovery",
            "trigger": "when enough time has passed since last stamina use",
            "actions": [
              {
                "action": "begin stamina recovery process"
              }
            ]
          },
          {
            "name": "recover_stamina",
            "trigger": "when recovering and stamina is not full",
            "actions": [
              {
                "action": "increase current stamina by recovery rate over time"
              },
              {
                "action": "prevent stamina from exceeding maximum"
              },
              {
                "action": "update slider visual to show current stamina"
              }
            ]
          },
          {
            "name": "stop_recovery_when_full",
            "trigger": "when stamina reaches maximum during recovery",
            "actions": [
              {
                "action": "stop recovery process"
              }
            ]
          },
          {
            "name": "update_visual",
            "trigger": "when stamina value changes",
            "actions": [
              {
                "action": "update slider fill to represent current stamina percentage"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class StaminaBar : MonoBehaviour\n{\n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _currentStamina;\n    [SerializeField] private float _staminaRecoveryRate = 20f;\n    [SerializeField] private float _staminaRecoveryDelay = 2f;\n    [SerializeField] private float _lowStaminaThreshold = 20f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Slider _staminaSlider;\n    [SerializeField] private Image _staminaFillImage;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.green;\n    [SerializeField] private Color _lowStaminaColor = Color.red;\n    [SerializeField] private Color _depletedColor = Color.gray;\n    [SerializeField] private bool _hideWhenFull = true;\n    [SerializeField] private float _fadeSpeed = 2f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStaminaDepleted;\n    public UnityEvent OnStaminaLow;\n    public UnityEvent OnStaminaRecovered;\n    \n    private float _lastStaminaUseTime;\n    private bool _isRecovering;\n    private bool _wasLowStamina;\n    private bool _wasDepleted;\n    private float _targetAlpha = 1f;\n    private float _pulseTimer;\n    \n    private void Start()\n    {\n        InitializeStamina();\n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        HandleStaminaRecovery();\n        UpdateUI();\n        HandleVisualEffects();\n    }\n    \n    private void InitializeStamina()\n    {\n        _currentStamina = _maxStamina;\n        _lastStaminaUseTime = Time.time;\n        _isRecovering = false;\n        _wasLowStamina = false;\n        _wasDepleted = false;\n    }\n    \n    private void SetupUI()\n    {\n        if (_staminaSlider != null)\n        {\n            _staminaSlider.maxValue = _maxStamina;\n            _staminaSlider.value = _currentStamina;\n        }\n        \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void HandleStaminaRecovery()\n    {\n        bool shouldRecover = Time.time - _lastStaminaUseTime >= _staminaRecoveryDelay;\n        \n        if (shouldRecover && _currentStamina < _maxStamina)\n        {\n            if (!_isRecovering)\n            {\n                _isRecovering = true;\n            }\n            \n            _currentStamina += _staminaRecoveryRate * Time.deltaTime;\n            _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n            \n            if (_currentStamina >= _maxStamina)\n            {\n                _currentStamina = _maxStamina;\n                _isRecovering = false;\n                OnStaminaRecovered?.Invoke();\n            }\n        }\n        else if (!shouldRecover)\n        {\n            _isRecovering = false;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_staminaSlider != null)\n        {\n            _staminaSlider.value = _currentStamina;\n        }\n        \n        UpdateStaminaColor();\n        UpdateVisibility();\n        CheckStaminaThresholds();\n    }\n    \n    private void UpdateStaminaColor()\n    {\n        if (_staminaFillImage == null) return;\n        \n        Color targetColor;\n        \n        if (_currentStamina <= 0f)\n        {\n            targetColor = _depletedColor;\n        }\n        else if (_currentStamina <= _lowStaminaThreshold)\n        {\n            targetColor = _lowStaminaColor;\n        }\n        else\n        {\n            targetColor = _normalColor;\n        }\n        \n        _staminaFillImage.color = targetColor;\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (!_hideWhenFull)\n        {\n            _targetAlpha = 1f;\n        }\n        else\n        {\n            _targetAlpha = (_currentStamina >= _maxStamina && !_isRecovering) ? 0f : 1f;\n        }\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha, _targetAlpha, _fadeSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        if (!_enablePulseEffect || _staminaFillImage == null) return;\n        \n        if (_currentStamina <= _lowStaminaThreshold && _currentStamina > 0f)\n        {\n            _pulseTimer += Time.deltaTime * _pulseSpeed;\n            float pulseValue = Mathf.Sin(_pulseTimer) * _pulseIntensity;\n            Color currentColor = _staminaFillImage.color;\n            currentColor.a = Mathf.Clamp01(1f + pulseValue);\n            _staminaFillImage.color = currentColor;\n        }\n        else\n        {\n            _pulseTimer = 0f;\n            if (_staminaFillImage.color.a != 1f)\n            {\n                Color currentColor = _staminaFillImage.color;\n                currentColor.a = 1f;\n                _staminaFillImage.color = currentColor;\n            }\n        }\n    }\n    \n    private void CheckStaminaThresholds()\n    {\n        bool isLowStamina = _currentStamina <= _lowStaminaThreshold && _currentStamina > 0f;\n        bool isDepleted = _currentStamina <= 0f;\n        \n        if (isDepleted && !_wasDepleted)\n        {\n            OnStaminaDepleted?.Invoke();\n            _wasDepleted = true;\n        }\n        else if (!isDepleted)\n        {\n            _wasDepleted = false;\n        }\n        \n        if (isLowStamina && !_wasLowStamina)\n        {\n            OnStaminaLow?.Invoke();\n            _wasLowStamina = true;\n        }\n        else if (!isLowStamina)\n        {\n            _wasLowStamina = false;\n        }\n    }\n    \n    public void UseStamina(float amount)\n    {\n        if (amount <= 0f) return;\n        \n        _currentStamina -= amount;\n        _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n        _lastStaminaUseTime = Time.time;\n        _isRecovering = false;\n    }\n    \n    public void RestoreStamina(float amount)\n    {\n        if (amount <= 0f) return;\n        \n        _currentStamina += amount;\n        _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n    }\n    \n    public void SetMaxStamina(float newMaxStamina)\n    {\n        if (newMaxStamina <= 0f) return;\n        \n        float ratio = _currentStamina / _maxStamina;\n        _maxStamina = newMaxStamina;\n        _currentStamina = _maxStamina * ratio;\n        \n        if (_staminaSlider != null)\n        {\n            _staminaSlider.maxValue = _maxStamina;\n        }\n    }\n    \n    public bool HasStamina(float amount)\n    {\n        return _currentStamina >= amount;\n    }\n    \n    public bool CanUseStamina(float amount)\n    {\n        return _currentStamina >= amount;\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _maxStamina > 0f ? _currentStamina / _maxStamina : 0f;\n    }\n    \n    public float GetCurrentStamina()\n    {\n        return _currentStamina;\n    }\n    \n    public float GetMaxStamina()\n    {\n        return _maxStamina;\n    }\n    \n    public bool IsRecovering()\n    {\n        return _isRecovering;\n    }\n    \n    public bool IsEmpty()\n    {\n        return _currentStamina <= 0f;\n    }\n    \n    public bool IsFull()\n    {\n        return _currentStamina >= _maxStamina;\n    }\n    \n    public bool IsLow()\n    {\n        return _currentStamina <= _lowStaminaThreshold;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mana bar for abilities",
      "ideal_ir": {
        "class_name": "ManaBar",
        "components": [
          "UI Image",
          "UI Slider"
        ],
        "fields": [
          {
            "name": "maxMana",
            "type": "float",
            "default": 100
          },
          {
            "name": "currentMana",
            "type": "float",
            "default": 100
          },
          {
            "name": "manaRegenRate",
            "type": "float",
            "default": 5
          },
          {
            "name": "manaBarSlider",
            "type": "Slider",
            "default": null
          },
          {
            "name": "manaBarFill",
            "type": "Image",
            "default": null
          },
          {
            "name": "lowManaThreshold",
            "type": "float",
            "default": 20
          }
        ],
        "behaviors": [
          {
            "name": "initialize_mana_bar",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "set current mana to maximum mana"
              },
              {
                "action": "update mana bar visual to full"
              }
            ]
          },
          {
            "name": "regenerate_mana",
            "trigger": "every frame when current mana is below maximum",
            "actions": [
              {
                "action": "increase current mana by regeneration rate over time"
              },
              {
                "action": "clamp current mana to not exceed maximum mana"
              },
              {
                "action": "update mana bar visual to match current mana percentage"
              }
            ]
          },
          {
            "name": "consume_mana",
            "trigger": "when ability is used",
            "actions": [
              {
                "action": "decrease current mana by ability cost"
              },
              {
                "action": "prevent current mana from going below zero"
              },
              {
                "action": "update mana bar visual to match current mana percentage"
              }
            ]
          },
          {
            "name": "change_bar_color_when_low",
            "trigger": "when current mana falls below low mana threshold",
            "actions": [
              {
                "action": "change mana bar fill color to red"
              }
            ]
          },
          {
            "name": "restore_normal_color",
            "trigger": "when current mana rises above low mana threshold",
            "actions": [
              {
                "action": "change mana bar fill color back to blue"
              }
            ]
          },
          {
            "name": "check_mana_availability",
            "trigger": "when player attempts to use ability",
            "actions": [
              {
                "action": "check if current mana is sufficient for ability cost"
              },
              {
                "action": "allow ability use if mana is sufficient"
              },
              {
                "action": "prevent ability use if mana is insufficient"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class ManaBar : MonoBehaviour\n{\n    [Header(\"Mana Settings\")]\n    [SerializeField] private float _maxMana = 100f;\n    [SerializeField] private float _currentMana = 100f;\n    [SerializeField] private float _manaRegenRate = 5f;\n    [SerializeField] private float _manaRegenDelay = 2f;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Slider _manaSlider;\n    [SerializeField] private Image _manaFillImage;\n    [SerializeField] private Text _manaText;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _fullManaColor = Color.blue;\n    [SerializeField] private Color _lowManaColor = Color.red;\n    [SerializeField] private Color _emptyManaColor = Color.gray;\n    [SerializeField] private float _lowManaThreshold = 0.25f;\n    [SerializeField] private bool _showManaText = true;\n    [SerializeField] private bool _hideWhenFull = false;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _smoothTransition = true;\n    [SerializeField] private float _transitionSpeed = 5f;\n    [SerializeField] private bool _pulseOnLowMana = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnManaEmpty;\n    public UnityEvent OnManaFull;\n    public UnityEvent<float> OnManaChanged;\n    \n    private float _targetManaValue;\n    private float _lastManaUseTime;\n    private bool _wasEmpty;\n    private bool _wasFull;\n    private CanvasGroup _canvasGroup;\n    \n    public float CurrentMana => _currentMana;\n    public float MaxMana => _maxMana;\n    public float ManaPercentage => _currentMana / _maxMana;\n    public bool HasMana => _currentMana > 0f;\n    public bool IsFullMana => _currentMana >= _maxMana;\n    \n    private void Awake()\n    {\n        InitializeComponents();\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = -_manaRegenDelay;\n    }\n    \n    private void Start()\n    {\n        UpdateManaDisplay();\n        UpdateVisibility();\n    }\n    \n    private void Update()\n    {\n        HandleManaRegeneration();\n        HandleSmoothTransition();\n        HandleLowManaPulse();\n        UpdateManaDisplay();\n        UpdateVisibility();\n        CheckManaEvents();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_manaSlider == null)\n            _manaSlider = GetComponentInChildren<Slider>();\n            \n        if (_manaFillImage == null && _manaSlider != null)\n            _manaFillImage = _manaSlider.fillRect?.GetComponent<Image>();\n            \n        if (_manaText == null)\n            _manaText = GetComponentInChildren<Text>();\n            \n        if (_backgroundImage == null)\n            _backgroundImage = GetComponent<Image>();\n            \n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null && _hideWhenFull)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n            \n        if (_manaSlider != null)\n        {\n            _manaSlider.minValue = 0f;\n            _manaSlider.maxValue = _maxMana;\n            _manaSlider.wholeNumbers = false;\n        }\n    }\n    \n    private void HandleManaRegeneration()\n    {\n        if (_currentMana < _maxMana && Time.time >= _lastManaUseTime + _manaRegenDelay)\n        {\n            _currentMana += _manaRegenRate * Time.deltaTime;\n            _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n            _targetManaValue = _currentMana;\n        }\n    }\n    \n    private void HandleSmoothTransition()\n    {\n        if (_smoothTransition && _manaSlider != null)\n        {\n            float currentSliderValue = _manaSlider.value;\n            float targetValue = _smoothTransition ? _targetManaValue : _currentMana;\n            \n            if (Mathf.Abs(currentSliderValue - targetValue) > 0.01f)\n            {\n                _manaSlider.value = Mathf.Lerp(currentSliderValue, targetValue, _transitionSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _manaSlider.value = targetValue;\n            }\n        }\n        else if (_manaSlider != null)\n        {\n            _manaSlider.value = _currentMana;\n        }\n    }\n    \n    private void HandleLowManaPulse()\n    {\n        if (_pulseOnLowMana && ManaPercentage <= _lowManaThreshold && _manaFillImage != null)\n        {\n            float alpha = 0.5f + 0.5f * Mathf.Sin(Time.time * _pulseSpeed);\n            Color currentColor = _manaFillImage.color;\n            currentColor.a = alpha;\n            _manaFillImage.color = currentColor;\n        }\n        else if (_manaFillImage != null)\n        {\n            Color currentColor = _manaFillImage.color;\n            currentColor.a = 1f;\n            _manaFillImage.color = currentColor;\n        }\n    }\n    \n    private void UpdateManaDisplay()\n    {\n        UpdateManaColor();\n        UpdateManaText();\n    }\n    \n    private void UpdateManaColor()\n    {\n        if (_manaFillImage == null) return;\n        \n        Color targetColor;\n        float percentage = ManaPercentage;\n        \n        if (percentage <= 0f)\n        {\n            targetColor = _emptyManaColor;\n        }\n        else if (percentage <= _lowManaThreshold)\n        {\n            targetColor = Color.Lerp(_emptyManaColor, _lowManaColor, percentage / _lowManaThreshold);\n        }\n        else\n        {\n            float normalizedHigh = (percentage - _lowManaThreshold) / (1f - _lowManaThreshold);\n            targetColor = Color.Lerp(_lowManaColor, _fullManaColor, normalizedHigh);\n        }\n        \n        if (!_pulseOnLowMana || percentage > _lowManaThreshold)\n        {\n            _manaFillImage.color = targetColor;\n        }\n        else\n        {\n            Color pulseColor = targetColor;\n            pulseColor.a = _manaFillImage.color.a;\n            _manaFillImage.color = pulseColor;\n        }\n    }\n    \n    private void UpdateManaText()\n    {\n        if (_manaText != null && _showManaText)\n        {\n            _manaText.text = $\"{Mathf.Ceil(_currentMana)}/{_maxMana}\";\n        }\n        else if (_manaText != null)\n        {\n            _manaText.text = \"\";\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_canvasGroup != null && _hideWhenFull)\n        {\n            float targetAlpha = IsFullMana ? 0f : 1f;\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, targetAlpha, Time.deltaTime * 3f);\n        }\n    }\n    \n    private void CheckManaEvents()\n    {\n        bool isEmpty = _currentMana <= 0f;\n        bool isFull = _currentMana >= _maxMana;\n        \n        if (isEmpty && !_wasEmpty)\n        {\n            OnManaEmpty?.Invoke();\n            _wasEmpty = true;\n        }\n        else if (!isEmpty)\n        {\n            _wasEmpty = false;\n        }\n        \n        if (isFull && !_wasFull)\n        {\n            OnManaFull?.Invoke();\n            _wasFull = true;\n        }\n        else if (!isFull)\n        {\n            _wasFull = false;\n        }\n        \n        OnManaChanged?.Invoke(_currentMana);\n    }\n    \n    public bool TryUseMana(float amount)\n    {\n        if (_currentMana >= amount)\n        {\n            UseMana(amount);\n            return true;\n        }\n        return false;\n    }\n    \n    public void UseMana(float amount)\n    {\n        _currentMana -= amount;\n        _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = Time.time;\n    }\n    \n    public void RestoreMana(float amount)\n    {\n        _currentMana += amount;\n        _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n    }\n    \n    public void SetMana(float amount)\n    {\n        _currentMana = Mathf.Clamp(amount, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n    }\n    \n    public void SetMaxMana(float newMaxMana)\n    {\n        float percentage = ManaPercentage;\n        _maxMana = Mathf.Max(1f, newMaxMana);\n        _currentMana = _maxMana * percentage;\n        _targetManaValue = _currentMana;\n        \n        if (_manaSlider != null)\n        {\n            _manaSlider.maxValue = _maxMana;\n        }\n    }\n    \n    public void RefillMana()\n    {\n        _currentMana = _maxMana;\n        _targetManaValue = _currentMana;\n    }\n    \n    public void EmptyMana()\n    {\n        _currentMana = 0f;\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = Time.time;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "experience bar with level up",
      "ideal_ir": {
        "class_name": "ExperienceBar",
        "components": [
          "UI.Slider",
          "UI.Text"
        ],
        "fields": [
          {
            "name": "currentExperience",
            "type": "int",
            "default": 0
          },
          {
            "name": "experienceToNextLevel",
            "type": "int",
            "default": 100
          },
          {
            "name": "currentLevel",
            "type": "int",
            "default": 1
          },
          {
            "name": "experienceMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "levelText",
            "type": "UI.Text",
            "default": null
          },
          {
            "name": "experienceBar",
            "type": "UI.Slider",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "gain_experience",
            "trigger": "when experience points are awarded",
            "actions": [
              {
                "action": "add experience points to current experience"
              },
              {
                "action": "update experience bar fill amount based on progress to next level"
              }
            ]
          },
          {
            "name": "check_level_up",
            "trigger": "when current experience reaches or exceeds experience needed for next level",
            "actions": [
              {
                "action": "increase current level by one"
              },
              {
                "action": "subtract experience needed for level up from current experience"
              },
              {
                "action": "calculate new experience requirement using multiplier"
              },
              {
                "action": "update level text display"
              },
              {
                "action": "reset experience bar to show remaining experience"
              },
              {
                "action": "trigger level up visual effects"
              }
            ]
          },
          {
            "name": "initialize_display",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "set experience bar maximum value to experience needed for next level"
              },
              {
                "action": "set experience bar current value to current experience"
              },
              {
                "action": "update level text to show current level"
              }
            ]
          },
          {
            "name": "update_bar_display",
            "trigger": "when experience values change",
            "actions": [
              {
                "action": "calculate experience progress as percentage of requirement"
              },
              {
                "action": "set slider value to match experience progress"
              },
              {
                "action": "update any experience text displays"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class ExperienceBar : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Slider _experienceSlider;\n    [SerializeField] private Text _levelText;\n    [SerializeField] private Text _experienceText;\n    [SerializeField] private GameObject _levelUpEffect;\n    \n    [Header(\"Experience Settings\")]\n    [SerializeField] private int _currentLevel = 1;\n    [SerializeField] private float _currentExperience = 0f;\n    [SerializeField] private float _baseExperienceRequired = 100f;\n    [SerializeField] private float _experienceMultiplier = 1.5f;\n    [SerializeField] private int _maxLevel = 99;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalBarColor = Color.blue;\n    [SerializeField] private Color _levelUpBarColor = Color.gold;\n    [SerializeField] private float _levelUpEffectDuration = 2f;\n    [SerializeField] private AnimationCurve _levelUpAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _levelUpSound;\n    [SerializeField] private AudioClip _experienceGainSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnLevelUp;\n    public UnityEvent<float> OnExperienceGained;\n    \n    private float _experienceRequiredForNextLevel;\n    private bool _isLevelingUp = false;\n    private float _levelUpTimer = 0f;\n    private Image _sliderFillImage;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        CalculateExperienceRequired();\n        UpdateUI();\n    }\n    \n    private void Update()\n    {\n        if (_isLevelingUp)\n        {\n            HandleLevelUpAnimation();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_experienceSlider == null)\n            _experienceSlider = GetComponentInChildren<Slider>();\n            \n        if (_experienceSlider != null)\n        {\n            _sliderFillImage = _experienceSlider.fillRect.GetComponent<Image>();\n            if (_sliderFillImage != null)\n                _sliderFillImage.color = _normalBarColor;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_levelUpEffect != null)\n            _levelUpEffect.SetActive(false);\n    }\n    \n    private void CalculateExperienceRequired()\n    {\n        _experienceRequiredForNextLevel = _baseExperienceRequired * Mathf.Pow(_experienceMultiplier, _currentLevel - 1);\n    }\n    \n    public void AddExperience(float amount)\n    {\n        if (_currentLevel >= _maxLevel) return;\n        \n        _currentExperience += amount;\n        \n        PlayExperienceGainSound();\n        OnExperienceGained?.Invoke(amount);\n        \n        CheckForLevelUp();\n        UpdateUI();\n    }\n    \n    private void CheckForLevelUp()\n    {\n        while (_currentExperience >= _experienceRequiredForNextLevel && _currentLevel < _maxLevel)\n        {\n            LevelUp();\n        }\n    }\n    \n    private void LevelUp()\n    {\n        _currentExperience -= _experienceRequiredForNextLevel;\n        _currentLevel++;\n        \n        CalculateExperienceRequired();\n        StartLevelUpEffect();\n        \n        PlayLevelUpSound();\n        OnLevelUp?.Invoke(_currentLevel);\n    }\n    \n    private void StartLevelUpEffect()\n    {\n        _isLevelingUp = true;\n        _levelUpTimer = 0f;\n        \n        if (_levelUpEffect != null)\n            _levelUpEffect.SetActive(true);\n            \n        if (_sliderFillImage != null)\n            _sliderFillImage.color = _levelUpBarColor;\n    }\n    \n    private void HandleLevelUpAnimation()\n    {\n        _levelUpTimer += Time.deltaTime;\n        float progress = _levelUpTimer / _levelUpEffectDuration;\n        \n        if (_sliderFillImage != null)\n        {\n            float animationValue = _levelUpAnimationCurve.Evaluate(progress);\n            _sliderFillImage.color = Color.Lerp(_levelUpBarColor, _normalBarColor, animationValue);\n        }\n        \n        if (progress >= 1f)\n        {\n            _isLevelingUp = false;\n            \n            if (_levelUpEffect != null)\n                _levelUpEffect.SetActive(false);\n                \n            if (_sliderFillImage != null)\n                _sliderFillImage.color = _normalBarColor;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_experienceSlider != null)\n        {\n            if (_currentLevel >= _maxLevel)\n            {\n                _experienceSlider.value = 1f;\n            }\n            else\n            {\n                _experienceSlider.value = _currentExperience / _experienceRequiredForNextLevel;\n            }\n        }\n        \n        if (_levelText != null)\n        {\n            _levelText.text = \"Level \" + _currentLevel.ToString();\n        }\n        \n        if (_experienceText != null)\n        {\n            if (_currentLevel >= _maxLevel)\n            {\n                _experienceText.text = \"MAX LEVEL\";\n            }\n            else\n            {\n                _experienceText.text = $\"{_currentExperience:F0} / {_experienceRequiredForNextLevel:F0}\";\n            }\n        }\n    }\n    \n    private void PlayLevelUpSound()\n    {\n        if (_audioSource != null && _levelUpSound != null)\n        {\n            _audioSource.PlayOneShot(_levelUpSound);\n        }\n    }\n    \n    private void PlayExperienceGainSound()\n    {\n        if (_audioSource != null && _experienceGainSound != null)\n        {\n            _audioSource.PlayOneShot(_experienceGainSound, 0.5f);\n        }\n    }\n    \n    public void SetLevel(int level)\n    {\n        _currentLevel = Mathf.Clamp(level, 1, _maxLevel);\n        _currentExperience = 0f;\n        CalculateExperienceRequired();\n        UpdateUI();\n    }\n    \n    public void SetExperience(float experience)\n    {\n        _currentExperience = Mathf.Max(0f, experience);\n        CheckForLevelUp();\n        UpdateUI();\n    }\n    \n    public int GetCurrentLevel()\n    {\n        return _currentLevel;\n    }\n    \n    public float GetCurrentExperience()\n    {\n        return _currentExperience;\n    }\n    \n    public float GetExperienceRequiredForNextLevel()\n    {\n        return _experienceRequiredForNextLevel;\n    }\n    \n    public float GetExperienceProgress()\n    {\n        if (_currentLevel >= _maxLevel) return 1f;\n        return _currentExperience / _experienceRequiredForNextLevel;\n    }\n    \n    public bool IsMaxLevel()\n    {\n        return _currentLevel >= _maxLevel;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "notification popup",
      "ideal_ir": {
        "class_name": "NotificationPopup",
        "components": [
          "Canvas",
          "CanvasGroup",
          "Image",
          "Text"
        ],
        "fields": [
          {
            "name": "displayDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "fadeInSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeOutSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "slideDistance",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "notificationText",
            "type": "string",
            "default": "Notification"
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_notification",
            "trigger": "when show notification is requested with message text",
            "actions": [
              {
                "action": "set notification text to provided message"
              },
              {
                "action": "make popup visible"
              },
              {
                "action": "slide popup in from top of screen"
              },
              {
                "action": "fade popup in smoothly"
              },
              {
                "action": "mark popup as currently visible"
              }
            ]
          },
          {
            "name": "auto_hide_after_duration",
            "trigger": "when popup has been visible for display duration time",
            "actions": [
              {
                "action": "start hiding the popup"
              }
            ]
          },
          {
            "name": "hide_notification",
            "trigger": "when hide notification is requested",
            "actions": [
              {
                "action": "fade popup out smoothly"
              },
              {
                "action": "slide popup up off screen"
              },
              {
                "action": "make popup invisible when animation completes"
              },
              {
                "action": "mark popup as no longer visible"
              }
            ]
          },
          {
            "name": "dismiss_on_click",
            "trigger": "when popup is clicked by user",
            "actions": [
              {
                "action": "immediately hide the notification"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\n\npublic class NotificationPopup : MonoBehaviour\n{\n    [System.Serializable]\n    public class NotificationData\n    {\n        public string title;\n        public string message;\n        public Sprite icon;\n        public Color backgroundColor = Color.white;\n        public float duration = 3f;\n        public NotificationType type = NotificationType.Info;\n    }\n\n    [System.Serializable]\n    public enum NotificationType\n    {\n        Info,\n        Warning,\n        Error,\n        Success\n    }\n\n    [System.Serializable]\n    public class NotificationTypeSettings\n    {\n        public NotificationType type;\n        public Color backgroundColor;\n        public Color textColor;\n        public Sprite defaultIcon;\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _notificationPrefab;\n    [SerializeField] private Transform _notificationContainer;\n    [SerializeField] private Canvas _canvas;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private AnimationCurve _slideInCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private AnimationCurve _slideOutCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private float _animationDuration = 0.5f;\n    [SerializeField] private Vector2 _slideOffset = new Vector2(300f, 0f);\n\n    [Header(\"Notification Settings\")]\n    [SerializeField] private int _maxNotifications = 5;\n    [SerializeField] private float _defaultDuration = 3f;\n    [SerializeField] private float _notificationSpacing = 10f;\n    [SerializeField] private NotificationTypeSettings[] _typeSettings;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _notificationSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<string> OnNotificationShown;\n    public UnityEvent<string> OnNotificationClosed;\n\n    private Queue<NotificationData> _notificationQueue = new Queue<NotificationData>();\n    private List<GameObject> _activeNotifications = new List<GameObject>();\n    private Dictionary<NotificationType, NotificationTypeSettings> _typeSettingsDict;\n    private bool _isProcessingQueue = false;\n\n    private void Awake()\n    {\n        InitializeTypeSettings();\n        SetupCanvas();\n    }\n\n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n\n    private void InitializeTypeSettings()\n    {\n        _typeSettingsDict = new Dictionary<NotificationType, NotificationTypeSettings>();\n        \n        if (_typeSettings != null)\n        {\n            foreach (var setting in _typeSettings)\n            {\n                _typeSettingsDict[setting.type] = setting;\n            }\n        }\n\n        // Add default settings if not provided\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Info))\n            _typeSettingsDict[NotificationType.Info] = new NotificationTypeSettings \n            { \n                type = NotificationType.Info, \n                backgroundColor = new Color(0.2f, 0.6f, 1f, 0.9f), \n                textColor = Color.white \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Warning))\n            _typeSettingsDict[NotificationType.Warning] = new NotificationTypeSettings \n            { \n                type = NotificationType.Warning, \n                backgroundColor = new Color(1f, 0.8f, 0f, 0.9f), \n                textColor = Color.black \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Error))\n            _typeSettingsDict[NotificationType.Error] = new NotificationTypeSettings \n            { \n                type = NotificationType.Error, \n                backgroundColor = new Color(1f, 0.3f, 0.3f, 0.9f), \n                textColor = Color.white \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Success))\n            _typeSettingsDict[NotificationType.Success] = new NotificationTypeSettings \n            { \n                type = NotificationType.Success, \n                backgroundColor = new Color(0.3f, 0.8f, 0.3f, 0.9f), \n                textColor = Color.white \n            };\n    }\n\n    private void SetupCanvas()\n    {\n        if (_canvas == null)\n            _canvas = GetComponentInParent<Canvas>();\n\n        if (_canvas == null)\n        {\n            GameObject canvasGO = new GameObject(\"NotificationCanvas\");\n            canvasGO.transform.SetParent(transform);\n            _canvas = canvasGO.AddComponent<Canvas>();\n            _canvas.renderMode = RenderMode.ScreenSpaceOverlay;\n            _canvas.sortingOrder = 1000;\n            canvasGO.AddComponent<CanvasScaler>();\n            canvasGO.AddComponent<GraphicRaycaster>();\n        }\n\n        if (_notificationContainer == null)\n        {\n            GameObject containerGO = new GameObject(\"NotificationContainer\");\n            containerGO.transform.SetParent(_canvas.transform);\n            _notificationContainer = containerGO.transform;\n            \n            RectTransform containerRect = containerGO.AddComponent<RectTransform>();\n            containerRect.anchorMin = new Vector2(1f, 1f);\n            containerRect.anchorMax = new Vector2(1f, 1f);\n            containerRect.pivot = new Vector2(1f, 1f);\n            containerRect.anchoredPosition = new Vector2(-20f, -20f);\n            containerRect.sizeDelta = new Vector2(400f, 600f);\n\n            VerticalLayoutGroup layoutGroup = containerGO.AddComponent<VerticalLayoutGroup>();\n            layoutGroup.childAlignment = TextAnchor.UpperRight;\n            layoutGroup.spacing = _notificationSpacing;\n            layoutGroup.childControlHeight = false;\n            layoutGroup.childControlWidth = false;\n            layoutGroup.childForceExpandHeight = false;\n            layoutGroup.childForceExpandWidth = false;\n\n            ContentSizeFitter sizeFitter = containerGO.AddComponent<ContentSizeFitter>();\n            sizeFitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;\n        }\n    }\n\n    public void ShowNotification(string message)\n    {\n        ShowNotification(\"\", message, null, NotificationType.Info, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message)\n    {\n        ShowNotification(title, message, null, NotificationType.Info, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message, NotificationType type)\n    {\n        ShowNotification(title, message, null, type, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message, Sprite icon, NotificationType type, float duration = -1f)\n    {\n        if (duration < 0f)\n            duration = _defaultDuration;\n\n        NotificationData data = new NotificationData\n        {\n            title = title,\n            message = message,\n            icon = icon,\n            type = type,\n            duration = duration\n        };\n\n        if (_typeSettingsDict.ContainsKey(type))\n        {\n            data.backgroundColor = _typeSettingsDict[type].backgroundColor;\n            if (icon == null)\n                data.icon = _typeSettingsDict[type].defaultIcon;\n        }\n\n        _notificationQueue.Enqueue(data);\n        \n        if (!_isProcessingQueue)\n            StartCoroutine(ProcessNotificationQueue());\n    }\n\n    private IEnumerator ProcessNotificationQueue()\n    {\n        _isProcessingQueue = true;\n\n        while (_notificationQueue.Count > 0)\n        {\n            if (_activeNotifications.Count >= _maxNotifications)\n            {\n                yield return new WaitForSeconds(0.1f);\n                continue;\n            }\n\n            NotificationData data = _notificationQueue.Dequeue();\n            yield return StartCoroutine(DisplayNotification(data));\n        }\n\n        _isProcessingQueue = false;\n    }\n\n    private IEnumerator DisplayNotification(NotificationData data)\n    {\n        GameObject notification = CreateNotificationObject(data);\n        if (notification == null)\n            yield break;\n\n        _activeNotifications.Add(notification);\n        \n        PlayNotificationSound();\n        OnNotificationShown?.Invoke(data.message);\n\n        // Animate in\n        yield return StartCoroutine(AnimateNotificationIn(notification));\n\n        // Wait for duration\n        yield return new WaitForSeconds(data.duration);\n\n        // Animate out and destroy\n        yield return StartCoroutine(AnimateNotificationOut(notification));\n        \n        _activeNotifications.Remove(notification);\n        OnNotificationClosed?.Invoke(data.message);\n        \n        if (notification != null)\n            Destroy(notification);\n    }\n\n    private GameObject CreateNotificationObject(NotificationData data)\n    {\n        GameObject notification;\n\n        if (_notificationPrefab != null)\n        {\n            notification = Instantiate(_notificationPrefab, _notificationContainer);\n        }\n        else\n        {\n            notification = CreateDefaultNotification();\n        }\n\n        SetupNotificationContent(notification, data);\n        return notification;\n    }\n\n    private GameObject CreateDefaultNotification()\n    {\n        GameObject notification = new GameObject(\"Notification\");\n        notification.transform.SetParent(_notificationContainer);\n\n        RectTransform rect = notification.AddComponent<RectTransform>();\n        rect.sizeDelta = new Vector2(350f, 80f);\n\n        Image background = notification.AddComponent<Image>();\n        background.color = Color.white;\n\n        // Title\n        GameObject titleGO = new GameObject(\"Title\");\n        titleGO.transform.SetParent(notification.transform);\n        RectTransform titleRect = titleGO.AddComponent<RectTransform>();\n        titleRect.anchorMin = new Vector2(0.1f, 0.6f);\n        titleRect.anchorMax = new Vector2(0.9f, 0.9f);\n        titleRect.offsetMin = Vector2.zero;\n        titleRect.offsetMax = Vector2.zero;\n\n        TextMeshProUGUI titleText = titleGO.AddComponent<TextMeshProUGUI>();\n        titleText.text = \"\";\n        titleText.fontSize = 14f;\n        titleText.fontStyle = FontStyles.Bold;\n        titleText.color = Color.black;\n\n        // Message\n        GameObject messageGO = new GameObject(\"Message\");\n        messageGO.transform.SetParent(notification.transform);\n        RectTransform messageRect = messageGO.AddComponent<RectTransform>();\n        messageRect.anchorMin = new Vector2(0.1f, 0.1f);\n        messageRect.anchorMax = new Vector2(0.9f, 0.6f);\n        messageRect.offsetMin = Vector2.zero;\n        messageRect.offsetMax = Vector2.zero;\n\n        TextMeshProUGUI messageText = messageGO.AddComponent<TextMeshProUGUI>();\n        messageText.text = \"\";\n        messageText.fontSize = 12f;\n        messageText.color = Color.black;\n\n        // Icon\n        GameObject iconGO = new GameObject(\"Icon\");\n        iconGO.transform.SetParent(notification.transform);\n        RectTransform iconRect = iconGO.AddComponent<RectTransform>();\n        iconRect.anchorMin = new Vector2(0.02f, 0.2f);\n        iconRect.anchorMax = new Vector2(0.08f, 0.8f);\n        iconRect.offsetMin = Vector2.zero;\n        iconRect.offsetMax = Vector2.zero;\n\n        Image iconImage = iconGO.AddComponent<Image>();\n        iconImage.color = Color.white;\n\n        // Close button\n        GameObject closeGO = new GameObject(\"CloseButton\");\n        closeGO.transform.SetParent(notification.transform);\n        RectTransform closeRect = closeGO.AddComponent<RectTransform>();\n        closeRect.anchorMin = new Vector2(0.92f, 0.7f);\n        closeRect.anchorMax = new Vector2(0.98f, 0.9f);\n        closeRect.offsetMin = Vector2.zero;\n        closeRect.offsetMax = Vector2.zero;\n\n        Button closeButton = closeGO.AddComponent<Button>();\n        Image closeImage = closeGO.AddComponent<Image>();\n        closeImage.color = new Color(0.8f, 0.2f, 0.2f, 0.8f);\n\n        closeButton.onClick.AddListener(() => StartCoroutine(CloseNotification(notification)));\n\n        return notification;\n    }\n\n    private void SetupNotificationContent(GameObject notification, NotificationData data)\n    {\n        // Set background color\n        Image background = notification.GetComponent<Image>();\n        if (background != null)\n            background.color = data.backgroundColor;\n\n        // Set title\n        TextMeshProUGUI titleText = notification.transform.Find(\"Title\")?.GetComponent<TextMeshProUGUI>();\n        if (titleText != null)\n        {\n            titleText.text = data.title;\n            if (_typeSettingsDict.ContainsKey(data.type))\n                titleText.color = _typeSettingsDict[data.type].textColor;\n        }\n\n        // Set message\n        TextMeshProUGUI messageText = notification.transform.Find(\"Message\")?.GetComponent<TextMeshProUGUI>();\n        if (messageText != null)\n        {\n            messageText.text = data.message;\n            if (_typeSettingsDict.ContainsKey(data.type))\n                messageText.color = _typeSettingsDict[data.type].textColor;\n        }\n\n        // Set icon\n        Image iconImage = notification.transform.Find(\"Icon\")?.GetComponent<Image>();\n        if (iconImage != null)\n        {\n            if (data.icon != null)\n            {\n                iconImage.sprite = data.icon;\n                iconImage.gameObject.SetActive(true);\n            }\n            else\n            {\n                iconImage.gameObject.SetActive(false);\n            }\n        }\n    }\n\n    private IEnumerator AnimateNotificationIn(GameObject notification)\n    {\n        RectTransform rect = notification.GetComponent<RectTransform>();\n        Vector2 targetPosition = rect.anchoredPosition;\n        Vector2 startPosition = targetPosition + _slideOffset;\n        \n        rect.anchoredPosition = startPosition;\n        \n        float elapsed = 0f;\n        while (elapsed < _animationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _animationDuration;\n            float curveValue = _slideInCurve.Evaluate(progress);\n            \n            rect.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, curveValue);\n            \n            yield return null;\n        }\n        \n        rect.anchoredPosition = targetPosition;\n    }\n\n    private IEnumerator AnimateNotificationOut(GameObject notification)\n    {\n        if (notification == null)\n            yield break;\n\n        RectTransform rect = notification.GetComponent<RectTransform>();\n        Vector2 startPosition = rect.anchoredPosition;\n        Vector2 targetPosition = startPosition + _slideOffset;\n        \n        float elapsed = 0f;\n        while (elapsed < _animationDuration && notification != null)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _animationDuration;\n            float curveValue = _slideOutCurve.Evaluate(progress);",
      "behavior_type": "general"
    },
    {
      "prompt": "achievement unlock banner",
      "ideal_ir": {
        "class_name": "AchievementBanner",
        "components": [
          "Canvas",
          "Image",
          "Text",
          "Animator"
        ],
        "fields": [
          {
            "name": "displayDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "slideInSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeOutSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "achievementTitle",
            "type": "string",
            "default": "Achievement Unlocked!"
          },
          {
            "name": "achievementDescription",
            "type": "string",
            "default": ""
          },
          {
            "name": "achievementIcon",
            "type": "Sprite",
            "default": null
          },
          {
            "name": "bannerColor",
            "type": "Color",
            "default": "gold"
          },
          {
            "name": "soundEffect",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "show_achievement",
            "trigger": "when achievement unlock event is received",
            "actions": [
              {
                "action": "update banner text with achievement title and description"
              },
              {
                "action": "set banner icon to achievement icon"
              },
              {
                "action": "play achievement unlock sound effect"
              },
              {
                "action": "slide banner in from top of screen"
              },
              {
                "action": "make banner fully visible"
              }
            ]
          },
          {
            "name": "auto_hide_banner",
            "trigger": "when banner has been displayed for full duration",
            "actions": [
              {
                "action": "fade out banner opacity"
              },
              {
                "action": "slide banner up off screen"
              },
              {
                "action": "hide banner completely"
              }
            ]
          },
          {
            "name": "manual_dismiss",
            "trigger": "when player clicks on banner",
            "actions": [
              {
                "action": "immediately start fade out animation"
              },
              {
                "action": "slide banner up off screen faster than normal"
              },
              {
                "action": "hide banner completely"
              }
            ]
          },
          {
            "name": "animate_entrance",
            "trigger": "when banner starts showing",
            "actions": [
              {
                "action": "start banner above visible screen area"
              },
              {
                "action": "smoothly slide banner down to display position"
              },
              {
                "action": "add slight bounce effect when reaching final position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AchievementBanner : MonoBehaviour\n{\n    [System.Serializable]\n    public class Achievement\n    {\n        public string title;\n        public string description;\n        public Sprite icon;\n        public Color backgroundColor = Color.white;\n        public AudioClip unlockSound;\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _bannerPanel;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Image _iconImage;\n    [SerializeField] private TextMeshProUGUI _titleText;\n    [SerializeField] private TextMeshProUGUI _descriptionText;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _slideInDuration = 0.5f;\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _slideOutDuration = 0.5f;\n    [SerializeField] private AnimationCurve _slideInCurve = AnimationCurve.EaseOut(0, 0, 1, 1);\n    [SerializeField] private AnimationCurve _slideOutCurve = AnimationCurve.EaseIn(0, 0, 1, 1);\n\n    [Header(\"Position Settings\")]\n    [SerializeField] private Vector2 _hiddenPosition = new Vector2(0, 100);\n    [SerializeField] private Vector2 _visiblePosition = Vector2.zero;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _defaultUnlockSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _celebrationParticles;\n    [SerializeField] private bool _useScreenShake = true;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 0.2f;\n\n    private RectTransform _bannerRect;\n    private Queue<Achievement> _achievementQueue = new Queue<Achievement>();\n    private bool _isDisplaying = false;\n    private Coroutine _displayCoroutine;\n    private Vector3 _originalCameraPosition;\n    private Camera _mainCamera;\n\n    private void Awake()\n    {\n        _bannerRect = _bannerPanel.GetComponent<RectTransform>();\n        _mainCamera = Camera.main;\n        \n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(DismissBanner);\n    }\n\n    private void Start()\n    {\n        if (_bannerPanel != null)\n        {\n            _bannerPanel.SetActive(false);\n            _bannerRect.anchoredPosition = _hiddenPosition;\n        }\n    }\n\n    public void UnlockAchievement(Achievement achievement)\n    {\n        if (achievement == null) return;\n\n        _achievementQueue.Enqueue(achievement);\n        \n        if (!_isDisplaying)\n        {\n            ProcessNextAchievement();\n        }\n    }\n\n    public void UnlockAchievement(string title, string description, Sprite icon = null, Color? backgroundColor = null, AudioClip unlockSound = null)\n    {\n        Achievement achievement = new Achievement\n        {\n            title = title,\n            description = description,\n            icon = icon,\n            backgroundColor = backgroundColor ?? Color.white,\n            unlockSound = unlockSound\n        };\n\n        UnlockAchievement(achievement);\n    }\n\n    private void ProcessNextAchievement()\n    {\n        if (_achievementQueue.Count == 0) return;\n\n        Achievement achievement = _achievementQueue.Dequeue();\n        _displayCoroutine = StartCoroutine(DisplayAchievementCoroutine(achievement));\n    }\n\n    private IEnumerator DisplayAchievementCoroutine(Achievement achievement)\n    {\n        _isDisplaying = true;\n\n        SetupBannerContent(achievement);\n        _bannerPanel.SetActive(true);\n\n        // Play unlock sound\n        PlayUnlockSound(achievement.unlockSound);\n\n        // Screen shake effect\n        if (_useScreenShake && _mainCamera != null)\n        {\n            StartCoroutine(ScreenShakeCoroutine());\n        }\n\n        // Slide in animation\n        yield return StartCoroutine(SlideBannerCoroutine(_hiddenPosition, _visiblePosition, _slideInDuration, _slideInCurve));\n\n        // Trigger celebration particles\n        if (_celebrationParticles != null)\n        {\n            _celebrationParticles.Play();\n        }\n\n        // Display duration\n        yield return new WaitForSeconds(_displayDuration);\n\n        // Slide out animation\n        yield return StartCoroutine(SlideBannerCoroutine(_visiblePosition, _hiddenPosition, _slideOutDuration, _slideOutCurve));\n\n        _bannerPanel.SetActive(false);\n        _isDisplaying = false;\n\n        // Process next achievement if any\n        if (_achievementQueue.Count > 0)\n        {\n            yield return new WaitForSeconds(0.2f);\n            ProcessNextAchievement();\n        }\n    }\n\n    private void SetupBannerContent(Achievement achievement)\n    {\n        if (_titleText != null)\n            _titleText.text = achievement.title;\n\n        if (_descriptionText != null)\n            _descriptionText.text = achievement.description;\n\n        if (_iconImage != null)\n        {\n            _iconImage.sprite = achievement.icon;\n            _iconImage.gameObject.SetActive(achievement.icon != null);\n        }\n\n        if (_backgroundImage != null)\n            _backgroundImage.color = achievement.backgroundColor;\n    }\n\n    private IEnumerator SlideBannerCoroutine(Vector2 startPos, Vector2 endPos, float duration, AnimationCurve curve)\n    {\n        float elapsed = 0f;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            float curveValue = curve.Evaluate(t);\n            \n            _bannerRect.anchoredPosition = Vector2.Lerp(startPos, endPos, curveValue);\n            \n            yield return null;\n        }\n\n        _bannerRect.anchoredPosition = endPos;\n    }\n\n    private IEnumerator ScreenShakeCoroutine()\n    {\n        if (_mainCamera == null) yield break;\n\n        float elapsed = 0f;\n\n        while (elapsed < _shakeDuration)\n        {\n            elapsed += Time.deltaTime;\n            \n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.z = 0f;\n            \n            _mainCamera.transform.position = _originalCameraPosition + randomOffset;\n            \n            yield return null;\n        }\n\n        _mainCamera.transform.position = _originalCameraPosition;\n    }\n\n    private void PlayUnlockSound(AudioClip customSound)\n    {\n        if (_audioSource == null) return;\n\n        AudioClip soundToPlay = customSound != null ? customSound : _defaultUnlockSound;\n        \n        if (soundToPlay != null)\n        {\n            _audioSource.PlayOneShot(soundToPlay);\n        }\n    }\n\n    public void DismissBanner()\n    {\n        if (_displayCoroutine != null)\n        {\n            StopCoroutine(_displayCoroutine);\n        }\n\n        StartCoroutine(DismissBannerCoroutine());\n    }\n\n    private IEnumerator DismissBannerCoroutine()\n    {\n        yield return StartCoroutine(SlideBannerCoroutine(_bannerRect.anchoredPosition, _hiddenPosition, _slideOutDuration * 0.5f, _slideOutCurve));\n        \n        _bannerPanel.SetActive(false);\n        _isDisplaying = false;\n\n        if (_achievementQueue.Count > 0)\n        {\n            yield return new WaitForSeconds(0.2f);\n            ProcessNextAchievement();\n        }\n    }\n\n    public void ClearQueue()\n    {\n        _achievementQueue.Clear();\n        \n        if (_isDisplaying)\n        {\n            DismissBanner();\n        }\n    }\n\n    public int GetQueueCount()\n    {\n        return _achievementQueue.Count;\n    }\n\n    public bool IsDisplaying()\n    {\n        return _isDisplaying;\n    }\n\n    private void OnDestroy()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.RemoveListener(DismissBanner);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "countdown timer display",
      "ideal_ir": {
        "class_name": "CountdownTimerDisplay",
        "components": [
          "Text"
        ],
        "fields": [
          {
            "name": "countdownDuration",
            "type": "float",
            "default": 60
          },
          {
            "name": "currentTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "timeFormat",
            "type": "string",
            "default": "mm:ss"
          }
        ],
        "behaviors": [
          {
            "name": "start_countdown",
            "trigger": "when countdown is started",
            "actions": [
              {
                "action": "set current time to countdown duration"
              },
              {
                "action": "activate the timer"
              },
              {
                "action": "update display text with formatted time"
              }
            ]
          },
          {
            "name": "update_timer",
            "trigger": "every frame while timer is active",
            "actions": [
              {
                "action": "decrease current time by frame time"
              },
              {
                "action": "update display text with formatted current time"
              }
            ]
          },
          {
            "name": "timer_finished",
            "trigger": "when current time reaches zero or below",
            "actions": [
              {
                "action": "set current time to zero"
              },
              {
                "action": "deactivate the timer"
              },
              {
                "action": "display zero time on text"
              }
            ]
          },
          {
            "name": "pause_timer",
            "trigger": "when pause is requested",
            "actions": [
              {
                "action": "deactivate the timer"
              }
            ]
          },
          {
            "name": "resume_timer",
            "trigger": "when resume is requested",
            "actions": [
              {
                "action": "activate the timer"
              }
            ]
          },
          {
            "name": "reset_timer",
            "trigger": "when reset is requested",
            "actions": [
              {
                "action": "set current time to countdown duration"
              },
              {
                "action": "deactivate the timer"
              },
              {
                "action": "update display text with formatted time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing TMPro;\n\npublic class CountdownTimer : MonoBehaviour\n{\n    [Header(\"Timer Settings\")]\n    [SerializeField] private float _startTime = 60f;\n    [SerializeField] private bool _startOnAwake = true;\n    [SerializeField] private bool _destroyOnComplete = false;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private TextMeshProUGUI _timerText;\n    [SerializeField] private Text _legacyTimerText;\n    [SerializeField] private string _timeFormat = \"mm:ss\";\n    [SerializeField] private string _completedText = \"TIME'S UP!\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private bool _enableWarningEffect = true;\n    [SerializeField] private float _warningThreshold = 10f;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _warningColor = Color.red;\n    [SerializeField] private float _blinkSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _tickSound;\n    [SerializeField] private AudioClip _warningSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private bool _playTickEverySecond = false;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTimerStart;\n    public UnityEvent OnTimerComplete;\n    public UnityEvent OnWarningThreshold;\n    public UnityEvent<float> OnTimerUpdate;\n    \n    private float _currentTime;\n    private bool _isRunning = false;\n    private bool _isCompleted = false;\n    private bool _warningTriggered = false;\n    private float _lastSecond = -1f;\n    private bool _blinkState = false;\n    private float _blinkTimer = 0f;\n    \n    public float CurrentTime => _currentTime;\n    public float StartTime => _startTime;\n    public bool IsRunning => _isRunning;\n    public bool IsCompleted => _isCompleted;\n    public float Progress => _startTime > 0 ? 1f - (_currentTime / _startTime) : 1f;\n    \n    private void Awake()\n    {\n        _currentTime = _startTime;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_timerText == null)\n            _timerText = GetComponent<TextMeshProUGUI>();\n            \n        if (_legacyTimerText == null)\n            _legacyTimerText = GetComponent<Text>();\n    }\n    \n    private void Start()\n    {\n        UpdateDisplay();\n        \n        if (_startOnAwake)\n            StartTimer();\n    }\n    \n    private void Update()\n    {\n        if (!_isRunning || _isCompleted)\n            return;\n            \n        _currentTime -= Time.deltaTime;\n        \n        if (_currentTime <= 0f)\n        {\n            _currentTime = 0f;\n            CompleteTimer();\n        }\n        else\n        {\n            CheckWarningThreshold();\n            CheckTickSound();\n            UpdateBlinkEffect();\n        }\n        \n        UpdateDisplay();\n        OnTimerUpdate?.Invoke(_currentTime);\n    }\n    \n    public void StartTimer()\n    {\n        if (_isCompleted)\n            return;\n            \n        _isRunning = true;\n        OnTimerStart?.Invoke();\n    }\n    \n    public void PauseTimer()\n    {\n        _isRunning = false;\n    }\n    \n    public void ResumeTimer()\n    {\n        if (!_isCompleted)\n            _isRunning = true;\n    }\n    \n    public void StopTimer()\n    {\n        _isRunning = false;\n        _currentTime = _startTime;\n        _isCompleted = false;\n        _warningTriggered = false;\n        _lastSecond = -1f;\n        UpdateDisplay();\n        ResetVisualEffects();\n    }\n    \n    public void ResetTimer()\n    {\n        StopTimer();\n    }\n    \n    public void SetTime(float newTime)\n    {\n        _startTime = newTime;\n        if (!_isRunning)\n        {\n            _currentTime = _startTime;\n            UpdateDisplay();\n        }\n    }\n    \n    public void AddTime(float additionalTime)\n    {\n        _currentTime += additionalTime;\n        if (_currentTime > _startTime)\n            _currentTime = _startTime;\n    }\n    \n    private void CompleteTimer()\n    {\n        _isRunning = false;\n        _isCompleted = true;\n        \n        PlaySound(_completeSound);\n        OnTimerComplete?.Invoke();\n        \n        if (_destroyOnComplete)\n            Destroy(gameObject);\n    }\n    \n    private void CheckWarningThreshold()\n    {\n        if (!_warningTriggered && _currentTime <= _warningThreshold)\n        {\n            _warningTriggered = true;\n            PlaySound(_warningSound);\n            OnWarningThreshold?.Invoke();\n        }\n    }\n    \n    private void CheckTickSound()\n    {\n        if (!_playTickEverySecond)\n            return;\n            \n        float currentSecond = Mathf.Floor(_currentTime);\n        if (currentSecond != _lastSecond && currentSecond >= 0)\n        {\n            _lastSecond = currentSecond;\n            PlaySound(_tickSound);\n        }\n    }\n    \n    private void UpdateBlinkEffect()\n    {\n        if (!_enableWarningEffect || !_warningTriggered)\n            return;\n            \n        _blinkTimer += Time.deltaTime;\n        if (_blinkTimer >= 1f / _blinkSpeed)\n        {\n            _blinkState = !_blinkState;\n            _blinkTimer = 0f;\n        }\n    }\n    \n    private void UpdateDisplay()\n    {\n        string timeString = FormatTime(_currentTime);\n        \n        if (_isCompleted)\n            timeString = _completedText;\n            \n        if (_timerText != null)\n        {\n            _timerText.text = timeString;\n            _timerText.color = GetCurrentColor();\n        }\n        \n        if (_legacyTimerText != null)\n        {\n            _legacyTimerText.text = timeString;\n            _legacyTimerText.color = GetCurrentColor();\n        }\n    }\n    \n    private Color GetCurrentColor()\n    {\n        if (!_enableWarningEffect || !_warningTriggered)\n            return _normalColor;\n            \n        return _blinkState ? _warningColor : _normalColor;\n    }\n    \n    private void ResetVisualEffects()\n    {\n        _blinkState = false;\n        _blinkTimer = 0f;\n        \n        if (_timerText != null)\n            _timerText.color = _normalColor;\n            \n        if (_legacyTimerText != null)\n            _legacyTimerText.color = _normalColor;\n    }\n    \n    private string FormatTime(float timeInSeconds)\n    {\n        int minutes = Mathf.FloorToInt(timeInSeconds / 60f);\n        int seconds = Mathf.FloorToInt(timeInSeconds % 60f);\n        int milliseconds = Mathf.FloorToInt((timeInSeconds * 100f) % 100f);\n        \n        switch (_timeFormat.ToLower())\n        {\n            case \"mm:ss\":\n                return string.Format(\"{0:00}:{1:00}\", minutes, seconds);\n            case \"mm:ss.ff\":\n                return string.Format(\"{0:00}:{1:00}.{2:00}\", minutes, seconds, milliseconds);\n            case \"ss\":\n                return string.Format(\"{0:00}\", Mathf.FloorToInt(timeInSeconds));\n            case \"ss.ff\":\n                return string.Format(\"{0:00}.{1:00}\", Mathf.FloorToInt(timeInSeconds), milliseconds);\n            case \"m:ss\":\n                return string.Format(\"{0}:{1:00}\", minutes, seconds);\n            default:\n                return string.Format(\"{0:00}:{1:00}\", minutes, seconds);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n    \n    private void OnValidate()\n    {\n        if (_startTime < 0f)\n            _startTime = 0f;\n            \n        if (_warningThreshold < 0f)\n            _warningThreshold = 0f;\n            \n        if (_blinkSpeed <= 0f)\n            _blinkSpeed = 1f;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "score multiplier indicator",
      "ideal_ir": {
        "class_name": "ScoreMultiplierIndicator",
        "components": [
          "TextMeshProUGUI",
          "Animator"
        ],
        "fields": [
          {
            "name": "baseMultiplier",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "currentMultiplier",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "maxMultiplier",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "multiplierDecayRate",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "multiplierIncrement",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "displayFormat",
            "type": "string",
            "default": "x{0:F1}"
          },
          {
            "name": "pulseOnChange",
            "type": "bool",
            "default": true
          },
          {
            "name": "colorGradient",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "initialize_multiplier",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "set current multiplier to base multiplier value"
              },
              {
                "action": "update display text with current multiplier"
              },
              {
                "action": "set text color to default multiplier color"
              }
            ]
          },
          {
            "name": "increase_multiplier",
            "trigger": "when score multiplier increase event is received",
            "actions": [
              {
                "action": "increase current multiplier by increment amount"
              },
              {
                "action": "clamp current multiplier to maximum allowed value"
              },
              {
                "action": "update display text with new multiplier value"
              },
              {
                "action": "trigger pulse animation if enabled"
              },
              {
                "action": "update text color based on multiplier level if gradient enabled"
              }
            ]
          },
          {
            "name": "decay_multiplier",
            "trigger": "when multiplier decay timer expires",
            "actions": [
              {
                "action": "decrease current multiplier by decay rate"
              },
              {
                "action": "clamp current multiplier to minimum base value"
              },
              {
                "action": "update display text with decayed multiplier value"
              },
              {
                "action": "update text color based on new multiplier level if gradient enabled"
              }
            ]
          },
          {
            "name": "reset_multiplier",
            "trigger": "when multiplier reset event is received",
            "actions": [
              {
                "action": "set current multiplier back to base value"
              },
              {
                "action": "update display text to show base multiplier"
              },
              {
                "action": "reset text color to default"
              },
              {
                "action": "stop any active pulse animations"
              }
            ]
          },
          {
            "name": "update_display",
            "trigger": "when multiplier value changes",
            "actions": [
              {
                "action": "format multiplier value using display format string"
              },
              {
                "action": "update text component with formatted multiplier text"
              }
            ]
          },
          {
            "name": "animate_pulse",
            "trigger": "when pulse animation should play",
            "actions": [
              {
                "action": "trigger scale up animation on text"
              },
              {
                "action": "trigger scale down animation after brief delay"
              },
              {
                "action": "add glow effect during pulse if available"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\n\npublic class ScoreMultiplierIndicator : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private TextMeshProUGUI _multiplierText;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Multiplier Settings\")]\n    [SerializeField] private float _baseMultiplier = 1.0f;\n    [SerializeField] private float _maxMultiplier = 10.0f;\n    [SerializeField] private float _multiplierDecayRate = 0.5f;\n    [SerializeField] private float _multiplierIncrement = 0.5f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _lowMultiplierColor = Color.white;\n    [SerializeField] private Color _highMultiplierColor = Color.red;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0, 1, 1, 1.2f);\n    [SerializeField] private float _pulseDuration = 0.3f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.5f;\n    [SerializeField] private float _fadeOutDuration = 1.0f;\n    [SerializeField] private float _hideDelay = 2.0f;\n    \n    private float _currentMultiplier;\n    private float _multiplierTimer;\n    private bool _isVisible;\n    private Coroutine _hideCoroutine;\n    private Coroutine _pulseCoroutine;\n    private Vector3 _originalScale;\n    \n    public float CurrentMultiplier => _currentMultiplier;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _currentMultiplier = _baseMultiplier;\n        _originalScale = transform.localScale;\n        UpdateDisplay();\n        SetVisibility(false, true);\n    }\n    \n    private void Update()\n    {\n        UpdateMultiplierDecay();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_multiplierText == null)\n            _multiplierText = GetComponentInChildren<TextMeshProUGUI>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void UpdateMultiplierDecay()\n    {\n        if (_currentMultiplier > _baseMultiplier)\n        {\n            _multiplierTimer += Time.deltaTime;\n            \n            if (_multiplierTimer >= 1.0f)\n            {\n                _multiplierTimer = 0f;\n                _currentMultiplier = Mathf.Max(_baseMultiplier, _currentMultiplier - _multiplierDecayRate);\n                UpdateDisplay();\n                \n                if (_currentMultiplier <= _baseMultiplier)\n                {\n                    HideIndicator();\n                }\n            }\n        }\n    }\n    \n    public void AddMultiplier()\n    {\n        AddMultiplier(_multiplierIncrement);\n    }\n    \n    public void AddMultiplier(float amount)\n    {\n        _currentMultiplier = Mathf.Min(_maxMultiplier, _currentMultiplier + amount);\n        _multiplierTimer = 0f;\n        \n        UpdateDisplay();\n        ShowIndicator();\n        TriggerPulseEffect();\n    }\n    \n    public void ResetMultiplier()\n    {\n        _currentMultiplier = _baseMultiplier;\n        _multiplierTimer = 0f;\n        UpdateDisplay();\n        HideIndicator();\n    }\n    \n    private void UpdateDisplay()\n    {\n        if (_multiplierText != null)\n        {\n            _multiplierText.text = $\"x{_currentMultiplier:F1}\";\n        }\n        \n        UpdateColors();\n        UpdateFillAmount();\n    }\n    \n    private void UpdateColors()\n    {\n        float normalizedMultiplier = (_currentMultiplier - _baseMultiplier) / (_maxMultiplier - _baseMultiplier);\n        Color currentColor = Color.Lerp(_lowMultiplierColor, _highMultiplierColor, normalizedMultiplier);\n        \n        if (_multiplierText != null)\n            _multiplierText.color = currentColor;\n            \n        if (_backgroundImage != null)\n            _backgroundImage.color = new Color(currentColor.r, currentColor.g, currentColor.b, 0.3f);\n    }\n    \n    private void UpdateFillAmount()\n    {\n        if (_fillImage != null)\n        {\n            float fillAmount = (_currentMultiplier - _baseMultiplier) / (_maxMultiplier - _baseMultiplier);\n            _fillImage.fillAmount = fillAmount;\n        }\n    }\n    \n    private void ShowIndicator()\n    {\n        if (_hideCoroutine != null)\n        {\n            StopCoroutine(_hideCoroutine);\n            _hideCoroutine = null;\n        }\n        \n        if (!_isVisible)\n        {\n            StartCoroutine(FadeIn());\n        }\n        \n        _hideCoroutine = StartCoroutine(HideAfterDelay());\n    }\n    \n    private void HideIndicator()\n    {\n        if (_hideCoroutine != null)\n        {\n            StopCoroutine(_hideCoroutine);\n            _hideCoroutine = null;\n        }\n        \n        if (_isVisible)\n        {\n            StartCoroutine(FadeOut());\n        }\n    }\n    \n    private IEnumerator FadeIn()\n    {\n        _isVisible = true;\n        float elapsedTime = 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeInDuration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator FadeOut()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        while (elapsedTime < _fadeOutDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeOutDuration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 0f;\n        _isVisible = false;\n    }\n    \n    private IEnumerator HideAfterDelay()\n    {\n        yield return new WaitForSeconds(_hideDelay);\n        \n        if (_currentMultiplier <= _baseMultiplier)\n        {\n            HideIndicator();\n        }\n    }\n    \n    private void SetVisibility(bool visible, bool immediate = false)\n    {\n        _isVisible = visible;\n        \n        if (immediate)\n        {\n            _canvasGroup.alpha = visible ? 1f : 0f;\n        }\n    }\n    \n    private void TriggerPulseEffect()\n    {\n        if (_pulseCoroutine != null)\n        {\n            StopCoroutine(_pulseCoroutine);\n        }\n        \n        _pulseCoroutine = StartCoroutine(PulseAnimation());\n    }\n    \n    private IEnumerator PulseAnimation()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _pulseDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _pulseDuration;\n            float scaleMultiplier = _pulseCurve.Evaluate(progress);\n            transform.localScale = _originalScale * scaleMultiplier;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n        _pulseCoroutine = null;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            AddMultiplier();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_hideCoroutine != null)\n            StopCoroutine(_hideCoroutine);\n            \n        if (_pulseCoroutine != null)\n            StopCoroutine(_pulseCoroutine);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "combo counter",
      "ideal_ir": {
        "class_name": "ComboCounter",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "currentCombo",
            "type": "int",
            "default": 0
          },
          {
            "name": "maxCombo",
            "type": "int",
            "default": 0
          },
          {
            "name": "comboTimeWindow",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "timeSinceLastHit",
            "type": "float",
            "default": 0
          },
          {
            "name": "comboMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isComboActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "increment_combo",
            "trigger": "when player successfully hits target",
            "actions": [
              {
                "action": "increase current combo count by one"
              },
              {
                "action": "reset time since last hit to zero"
              },
              {
                "action": "set combo as active"
              },
              {
                "action": "update max combo if current combo exceeds it"
              }
            ]
          },
          {
            "name": "reset_combo_on_timeout",
            "trigger": "when time since last hit exceeds combo time window",
            "actions": [
              {
                "action": "reset current combo to zero"
              },
              {
                "action": "set combo as inactive"
              }
            ]
          },
          {
            "name": "reset_combo_on_miss",
            "trigger": "when player misses or takes damage",
            "actions": [
              {
                "action": "reset current combo to zero"
              },
              {
                "action": "set combo as inactive"
              }
            ]
          },
          {
            "name": "update_timer",
            "trigger": "every frame when combo is active",
            "actions": [
              {
                "action": "increase time since last hit by frame time"
              }
            ]
          },
          {
            "name": "calculate_combo_bonus",
            "trigger": "when calculating score or damage",
            "actions": [
              {
                "action": "multiply base value by combo multiplier based on current combo count"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ComboCounter : MonoBehaviour\n{\n    [Header(\"Combo Settings\")]\n    [SerializeField] private int _maxCombo = 999;\n    [SerializeField] private float _comboTimeWindow = 2f;\n    [SerializeField] private int _minComboToDisplay = 2;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _comboText;\n    [SerializeField] private GameObject _comboPanel;\n    [SerializeField] private Animator _comboAnimator;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _comboParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _comboSound;\n    [SerializeField] private AudioClip _comboBreakSound;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _highComboColor = Color.yellow;\n    [SerializeField] private Color _maxComboColor = Color.red;\n    [SerializeField] private int _highComboThreshold = 10;\n    [SerializeField] private int _maxComboThreshold = 50;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnComboChanged;\n    public UnityEvent<int> OnComboBreak;\n    public UnityEvent<int> OnHighCombo;\n    \n    private int _currentCombo = 0;\n    private float _lastComboTime;\n    private Coroutine _comboTimerCoroutine;\n    private bool _isComboActive = false;\n    \n    public int CurrentCombo => _currentCombo;\n    public bool IsComboActive => _isComboActive;\n    \n    private void Start()\n    {\n        InitializeCombo();\n    }\n    \n    private void InitializeCombo()\n    {\n        _currentCombo = 0;\n        _isComboActive = false;\n        \n        if (_comboPanel != null)\n            _comboPanel.SetActive(false);\n            \n        UpdateComboDisplay();\n    }\n    \n    public void AddCombo()\n    {\n        AddCombo(1);\n    }\n    \n    public void AddCombo(int amount)\n    {\n        if (amount <= 0) return;\n        \n        _currentCombo = Mathf.Min(_currentCombo + amount, _maxCombo);\n        _lastComboTime = Time.time;\n        \n        if (_currentCombo >= _minComboToDisplay && !_isComboActive)\n        {\n            _isComboActive = true;\n            ShowComboUI();\n        }\n        \n        UpdateComboDisplay();\n        PlayComboEffects();\n        \n        OnComboChanged?.Invoke(_currentCombo);\n        \n        if (_currentCombo >= _highComboThreshold)\n        {\n            OnHighCombo?.Invoke(_currentCombo);\n        }\n        \n        RestartComboTimer();\n    }\n    \n    public void BreakCombo()\n    {\n        if (_currentCombo > 0)\n        {\n            int brokenCombo = _currentCombo;\n            _currentCombo = 0;\n            _isComboActive = false;\n            \n            HideComboUI();\n            PlayComboBreakEffects();\n            \n            OnComboBreak?.Invoke(brokenCombo);\n            OnComboChanged?.Invoke(_currentCombo);\n        }\n        \n        StopComboTimer();\n    }\n    \n    private void RestartComboTimer()\n    {\n        StopComboTimer();\n        _comboTimerCoroutine = StartCoroutine(ComboTimerCoroutine());\n    }\n    \n    private void StopComboTimer()\n    {\n        if (_comboTimerCoroutine != null)\n        {\n            StopCoroutine(_comboTimerCoroutine);\n            _comboTimerCoroutine = null;\n        }\n    }\n    \n    private IEnumerator ComboTimerCoroutine()\n    {\n        while (Time.time - _lastComboTime < _comboTimeWindow)\n        {\n            yield return null;\n        }\n        \n        BreakCombo();\n    }\n    \n    private void UpdateComboDisplay()\n    {\n        if (_comboText != null)\n        {\n            _comboText.text = _currentCombo.ToString();\n            _comboText.color = GetComboColor();\n        }\n    }\n    \n    private Color GetComboColor()\n    {\n        if (_currentCombo >= _maxComboThreshold)\n            return _maxComboColor;\n        else if (_currentCombo >= _highComboThreshold)\n            return _highComboColor;\n        else\n            return _normalColor;\n    }\n    \n    private void ShowComboUI()\n    {\n        if (_comboPanel != null)\n        {\n            _comboPanel.SetActive(true);\n        }\n        \n        if (_comboAnimator != null)\n        {\n            _comboAnimator.SetTrigger(\"Show\");\n        }\n    }\n    \n    private void HideComboUI()\n    {\n        if (_comboAnimator != null)\n        {\n            _comboAnimator.SetTrigger(\"Hide\");\n        }\n        else if (_comboPanel != null)\n        {\n            _comboPanel.SetActive(false);\n        }\n    }\n    \n    private void PlayComboEffects()\n    {\n        if (_comboParticles != null && _currentCombo % 5 == 0)\n        {\n            _comboParticles.Play();\n        }\n        \n        if (_audioSource != null && _comboSound != null)\n        {\n            float pitch = 1f + (_currentCombo * 0.02f);\n            _audioSource.pitch = Mathf.Clamp(pitch, 0.8f, 2f);\n            _audioSource.PlayOneShot(_comboSound);\n        }\n    }\n    \n    private void PlayComboBreakEffects()\n    {\n        if (_audioSource != null && _comboBreakSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_comboBreakSound);\n        }\n    }\n    \n    public void ResetCombo()\n    {\n        _currentCombo = 0;\n        _isComboActive = false;\n        StopComboTimer();\n        HideComboUI();\n        UpdateComboDisplay();\n        OnComboChanged?.Invoke(_currentCombo);\n    }\n    \n    public void SetComboTimeWindow(float timeWindow)\n    {\n        _comboTimeWindow = Mathf.Max(0.1f, timeWindow);\n    }\n    \n    public float GetRemainingTime()\n    {\n        if (!_isComboActive) return 0f;\n        return Mathf.Max(0f, _comboTimeWindow - (Time.time - _lastComboTime));\n    }\n    \n    public float GetComboTimeProgress()\n    {\n        if (!_isComboActive) return 0f;\n        return GetRemainingTime() / _comboTimeWindow;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            AddCombo();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        StopComboTimer();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "directional damage indicator",
      "ideal_ir": {
        "class_name": "DirectionalDamageIndicator",
        "components": [
          "Canvas",
          "Image"
        ],
        "fields": [
          {
            "name": "indicatorPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "displayDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeOutTime",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "indicatorDistance",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "damageColor",
            "type": "Color",
            "default": "red"
          },
          {
            "name": "activeIndicators",
            "type": "List<GameObject>",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "show_damage_indicator",
            "trigger": "when damage is received from a source",
            "actions": [
              {
                "action": "calculate direction from player to damage source"
              },
              {
                "action": "create damage indicator UI element"
              },
              {
                "action": "position indicator on screen edge pointing toward damage source"
              },
              {
                "action": "set indicator color to damage color"
              },
              {
                "action": "add indicator to active indicators list"
              }
            ]
          },
          {
            "name": "update_indicator_positions",
            "trigger": "every frame while indicators are active",
            "actions": [
              {
                "action": "update each indicator position based on damage source location"
              },
              {
                "action": "keep indicators positioned on screen edge"
              },
              {
                "action": "rotate indicators to point toward damage sources"
              }
            ]
          },
          {
            "name": "fade_out_indicator",
            "trigger": "when indicator has been displayed for full duration",
            "actions": [
              {
                "action": "gradually reduce indicator opacity over fade out time"
              },
              {
                "action": "remove indicator when completely faded"
              },
              {
                "action": "remove indicator from active indicators list"
              }
            ]
          },
          {
            "name": "cleanup_expired_indicators",
            "trigger": "every frame",
            "actions": [
              {
                "action": "check each active indicator for expiration"
              },
              {
                "action": "remove indicators that have exceeded display duration"
              },
              {
                "action": "destroy expired indicator game objects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class DirectionalDamageIndicator : MonoBehaviour\n{\n    [Header(\"Damage Indicator Settings\")]\n    [SerializeField] private GameObject _damageIndicatorPrefab;\n    [SerializeField] private Transform _indicatorParent;\n    [SerializeField] private float _indicatorDistance = 100f;\n    [SerializeField] private float _indicatorDuration = 2f;\n    [SerializeField] private float _fadeOutDuration = 0.5f;\n    [SerializeField] private Color _damageColor = Color.red;\n    [SerializeField] private Vector2 _indicatorSize = new Vector2(50f, 50f);\n    \n    [Header(\"Player Reference\")]\n    [SerializeField] private Transform _playerTransform;\n    [SerializeField] private Camera _playerCamera;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _damageSound;\n    \n    private List<DamageIndicatorInstance> _activeIndicators = new List<DamageIndicatorInstance>();\n    private Canvas _canvas;\n    \n    [System.Serializable]\n    private class DamageIndicatorInstance\n    {\n        public GameObject indicatorObject;\n        public Image indicatorImage;\n        public Vector3 damageSourcePosition;\n        public float creationTime;\n        public Coroutine fadeCoroutine;\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        CreateIndicatorPrefabIfNeeded();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_playerTransform == null)\n            _playerTransform = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_indicatorParent == null)\n        {\n            _canvas = FindObjectOfType<Canvas>();\n            if (_canvas == null)\n            {\n                GameObject canvasGO = new GameObject(\"DamageIndicatorCanvas\");\n                _canvas = canvasGO.AddComponent<Canvas>();\n                _canvas.renderMode = RenderMode.ScreenSpaceOverlay;\n                canvasGO.AddComponent<CanvasScaler>();\n                canvasGO.AddComponent<GraphicRaycaster>();\n            }\n            _indicatorParent = _canvas.transform;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void CreateIndicatorPrefabIfNeeded()\n    {\n        if (_damageIndicatorPrefab == null)\n        {\n            _damageIndicatorPrefab = new GameObject(\"DamageIndicator\");\n            Image image = _damageIndicatorPrefab.AddComponent<Image>();\n            \n            Texture2D texture = new Texture2D(32, 32);\n            Color[] pixels = new Color[32 * 32];\n            for (int i = 0; i < pixels.Length; i++)\n            {\n                int x = i % 32;\n                int y = i / 32;\n                float distance = Vector2.Distance(new Vector2(x, y), new Vector2(16, 16));\n                if (distance < 12f)\n                    pixels[i] = _damageColor;\n                else\n                    pixels[i] = Color.clear;\n            }\n            texture.SetPixels(pixels);\n            texture.Apply();\n            \n            Sprite sprite = Sprite.Create(texture, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f));\n            image.sprite = sprite;\n            image.color = _damageColor;\n            \n            RectTransform rectTransform = _damageIndicatorPrefab.GetComponent<RectTransform>();\n            rectTransform.sizeDelta = _indicatorSize;\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateIndicatorPositions();\n        CleanupExpiredIndicators();\n    }\n    \n    private void UpdateIndicatorPositions()\n    {\n        if (_playerTransform == null || _playerCamera == null) return;\n        \n        for (int i = _activeIndicators.Count - 1; i >= 0; i--)\n        {\n            var indicator = _activeIndicators[i];\n            if (indicator.indicatorObject == null) continue;\n            \n            Vector3 directionToDamage = (indicator.damageSourcePosition - _playerTransform.position).normalized;\n            Vector3 screenCenter = new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f);\n            \n            Vector3 forward = _playerCamera.transform.forward;\n            Vector3 right = _playerCamera.transform.right;\n            \n            float angle = Mathf.Atan2(Vector3.Dot(directionToDamage, right), Vector3.Dot(directionToDamage, forward)) * Mathf.Rad2Deg;\n            \n            Vector3 indicatorPosition = screenCenter + new Vector3(\n                Mathf.Sin(angle * Mathf.Deg2Rad) * _indicatorDistance,\n                Mathf.Cos(angle * Mathf.Deg2Rad) * _indicatorDistance,\n                0f\n            );\n            \n            RectTransform rectTransform = indicator.indicatorObject.GetComponent<RectTransform>();\n            rectTransform.position = indicatorPosition;\n            rectTransform.rotation = Quaternion.Euler(0f, 0f, -angle);\n        }\n    }\n    \n    private void CleanupExpiredIndicators()\n    {\n        for (int i = _activeIndicators.Count - 1; i >= 0; i--)\n        {\n            var indicator = _activeIndicators[i];\n            if (Time.time - indicator.creationTime > _indicatorDuration)\n            {\n                if (indicator.indicatorObject != null)\n                    Destroy(indicator.indicatorObject);\n                _activeIndicators.RemoveAt(i);\n            }\n        }\n    }\n    \n    public void ShowDamageIndicator(Vector3 damageSourcePosition)\n    {\n        if (_indicatorParent == null || _damageIndicatorPrefab == null) return;\n        \n        GameObject indicatorInstance = Instantiate(_damageIndicatorPrefab, _indicatorParent);\n        Image indicatorImage = indicatorInstance.GetComponent<Image>();\n        \n        DamageIndicatorInstance newIndicator = new DamageIndicatorInstance\n        {\n            indicatorObject = indicatorInstance,\n            indicatorImage = indicatorImage,\n            damageSourcePosition = damageSourcePosition,\n            creationTime = Time.time\n        };\n        \n        _activeIndicators.Add(newIndicator);\n        \n        newIndicator.fadeCoroutine = StartCoroutine(FadeOutIndicator(newIndicator));\n        \n        PlayDamageSound();\n    }\n    \n    private IEnumerator FadeOutIndicator(DamageIndicatorInstance indicator)\n    {\n        float fadeStartTime = _indicatorDuration - _fadeOutDuration;\n        \n        yield return new WaitForSeconds(fadeStartTime);\n        \n        if (indicator.indicatorImage != null)\n        {\n            Color originalColor = indicator.indicatorImage.color;\n            float fadeTimer = 0f;\n            \n            while (fadeTimer < _fadeOutDuration && indicator.indicatorImage != null)\n            {\n                fadeTimer += Time.deltaTime;\n                float alpha = Mathf.Lerp(originalColor.a, 0f, fadeTimer / _fadeOutDuration);\n                indicator.indicatorImage.color = new Color(originalColor.r, originalColor.g, originalColor.b, alpha);\n                yield return null;\n            }\n        }\n    }\n    \n    private void PlayDamageSound()\n    {\n        if (_audioSource != null && _damageSound != null)\n        {\n            _audioSource.PlayOneShot(_damageSound);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Projectile\") || other.CompareTag(\"Enemy\"))\n        {\n            ShowDamageIndicator(other.transform.position);\n        }\n    }\n    \n    public void OnPlayerDamaged(Vector3 damageSourcePosition)\n    {\n        ShowDamageIndicator(damageSourcePosition);\n    }\n    \n    private void OnDestroy()\n    {\n        foreach (var indicator in _activeIndicators)\n        {\n            if (indicator.indicatorObject != null)\n                Destroy(indicator.indicatorObject);\n        }\n        _activeIndicators.Clear();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "low health warning flash",
      "ideal_ir": {
        "class_name": "LowHealthWarning",
        "components": [
          "Image"
        ],
        "fields": [
          {
            "name": "healthThreshold",
            "type": "float",
            "default": 25
          },
          {
            "name": "flashSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "warningColor",
            "type": "Color",
            "default": "red"
          }
        ],
        "behaviors": [
          {
            "name": "monitor_health",
            "trigger": "when player health drops below threshold",
            "actions": [
              {
                "action": "start flashing the warning overlay"
              }
            ]
          },
          {
            "name": "flash_warning",
            "trigger": "while health is below threshold",
            "actions": [
              {
                "action": "fade warning color in and out at flash speed"
              },
              {
                "action": "alternate between transparent and warning color"
              }
            ]
          },
          {
            "name": "stop_warning",
            "trigger": "when player health rises above threshold",
            "actions": [
              {
                "action": "stop flashing"
              },
              {
                "action": "hide warning overlay"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class LowHealthWarning : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth = 100f;\n    [SerializeField] private float _lowHealthThreshold = 25f;\n    \n    [Header(\"Flash Settings\")]\n    [SerializeField] private Image _warningOverlay;\n    [SerializeField] private Color _flashColor = new Color(1f, 0f, 0f, 0.3f);\n    [SerializeField] private float _flashSpeed = 2f;\n    [SerializeField] private AnimationCurve _flashCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _warningSound;\n    [SerializeField] private float _soundInterval = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLowHealthStart;\n    public UnityEvent OnLowHealthEnd;\n    public UnityEvent OnHealthChanged;\n    \n    private bool _isLowHealth = false;\n    private float _flashTimer = 0f;\n    private float _soundTimer = 0f;\n    private Color _originalColor;\n    private Canvas _warningCanvas;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        UpdateHealthState();\n    }\n    \n    private void Update()\n    {\n        if (_isLowHealth)\n        {\n            UpdateFlashEffect();\n            UpdateWarningSound();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_warningOverlay == null)\n        {\n            CreateWarningOverlay();\n        }\n        \n        _originalColor = _warningOverlay.color;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.loop = false;\n    }\n    \n    private void CreateWarningOverlay()\n    {\n        GameObject canvasGO = new GameObject(\"LowHealthWarningCanvas\");\n        canvasGO.transform.SetParent(transform);\n        \n        _warningCanvas = canvasGO.AddComponent<Canvas>();\n        _warningCanvas.renderMode = RenderMode.ScreenSpaceOverlay;\n        _warningCanvas.sortingOrder = 100;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;\n        scaler.referenceResolution = new Vector2(1920, 1080);\n        \n        canvasGO.AddComponent<GraphicRaycaster>();\n        \n        GameObject overlayGO = new GameObject(\"WarningOverlay\");\n        overlayGO.transform.SetParent(canvasGO.transform, false);\n        \n        _warningOverlay = overlayGO.AddComponent<Image>();\n        _warningOverlay.color = Color.clear;\n        \n        RectTransform rectTransform = _warningOverlay.rectTransform;\n        rectTransform.anchorMin = Vector2.zero;\n        rectTransform.anchorMax = Vector2.one;\n        rectTransform.offsetMin = Vector2.zero;\n        rectTransform.offsetMax = Vector2.zero;\n    }\n    \n    private void UpdateFlashEffect()\n    {\n        _flashTimer += Time.deltaTime * _flashSpeed;\n        \n        float curveValue = _flashCurve.Evaluate(Mathf.PingPong(_flashTimer, 1f));\n        Color targetColor = Color.Lerp(Color.clear, _flashColor, curveValue);\n        \n        _warningOverlay.color = targetColor;\n    }\n    \n    private void UpdateWarningSound()\n    {\n        if (_warningSound == null || _audioSource == null) return;\n        \n        _soundTimer += Time.deltaTime;\n        \n        if (_soundTimer >= _soundInterval)\n        {\n            _audioSource.PlayOneShot(_warningSound);\n            _soundTimer = 0f;\n        }\n    }\n    \n    private void UpdateHealthState()\n    {\n        bool shouldShowWarning = _currentHealth <= _lowHealthThreshold && _currentHealth > 0f;\n        \n        if (shouldShowWarning && !_isLowHealth)\n        {\n            StartLowHealthWarning();\n        }\n        else if (!shouldShowWarning && _isLowHealth)\n        {\n            StopLowHealthWarning();\n        }\n        \n        OnHealthChanged?.Invoke();\n    }\n    \n    private void StartLowHealthWarning()\n    {\n        _isLowHealth = true;\n        _flashTimer = 0f;\n        _soundTimer = 0f;\n        \n        if (_warningCanvas != null)\n        {\n            _warningCanvas.gameObject.SetActive(true);\n        }\n        \n        OnLowHealthStart?.Invoke();\n    }\n    \n    private void StopLowHealthWarning()\n    {\n        _isLowHealth = false;\n        \n        if (_warningOverlay != null)\n        {\n            _warningOverlay.color = Color.clear;\n        }\n        \n        if (_warningCanvas != null)\n        {\n            _warningCanvas.gameObject.SetActive(false);\n        }\n        \n        OnLowHealthEnd?.Invoke();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (damage < 0f) return;\n        \n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        UpdateHealthState();\n    }\n    \n    public void Heal(float healAmount)\n    {\n        if (healAmount < 0f) return;\n        \n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        UpdateHealthState();\n    }\n    \n    public void SetHealth(float health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        UpdateHealthState();\n    }\n    \n    public void SetMaxHealth(float maxHealth)\n    {\n        if (maxHealth <= 0f) return;\n        \n        float healthPercentage = _currentHealth / _maxHealth;\n        _maxHealth = maxHealth;\n        _currentHealth = _maxHealth * healthPercentage;\n        UpdateHealthState();\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _maxHealth > 0f ? _currentHealth / _maxHealth : 0f;\n    }\n    \n    public bool IsLowHealth()\n    {\n        return _isLowHealth;\n    }\n    \n    private void OnValidate()\n    {\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _lowHealthThreshold = Mathf.Clamp(_lowHealthThreshold, 0f, _maxHealth);\n        _flashSpeed = Mathf.Max(0.1f, _flashSpeed);\n        _soundInterval = Mathf.Max(0.1f, _soundInterval);\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "item pickup notification",
      "ideal_ir": {
        "class_name": "ItemPickupNotification",
        "components": [
          "Canvas",
          "Text",
          "Image"
        ],
        "fields": [
          {
            "name": "displayDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "slideDistance",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "notificationText",
            "type": "string",
            "default": "Item Collected!"
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_pickup_notification",
            "trigger": "when item is collected by player",
            "actions": [
              {
                "action": "display notification text with item name"
              },
              {
                "action": "make notification visible on screen"
              },
              {
                "action": "slide notification in from top of screen"
              },
              {
                "action": "set notification as currently visible"
              }
            ]
          },
          {
            "name": "fade_out_notification",
            "trigger": "when display duration time has elapsed",
            "actions": [
              {
                "action": "gradually fade out notification opacity"
              },
              {
                "action": "slide notification upward while fading"
              },
              {
                "action": "hide notification when fully transparent"
              },
              {
                "action": "set notification as not visible"
              }
            ]
          },
          {
            "name": "update_notification_text",
            "trigger": "when new item pickup occurs while notification is visible",
            "actions": [
              {
                "action": "update text to show new item name"
              },
              {
                "action": "reset display timer to full duration"
              },
              {
                "action": "briefly pulse notification size for emphasis"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ItemPickupNotification : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _notificationCanvas;\n    [SerializeField] private GameObject _notificationPrefab;\n    [SerializeField] private Transform _notificationParent;\n    \n    [Header(\"Notification Settings\")]\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _fadeOutDuration = 0.5f;\n    [SerializeField] private Vector3 _slideOffset = new Vector3(0, 50f, 0);\n    [SerializeField] private int _maxNotifications = 5;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pickupSound;\n    \n    private Queue<NotificationData> _notificationQueue = new Queue<NotificationData>();\n    private List<GameObject> _activeNotifications = new List<GameObject>();\n    \n    [System.Serializable]\n    public class NotificationData\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public Color backgroundColor = Color.white;\n        public string description;\n        \n        public NotificationData(string name, Sprite icon, string desc = \"\")\n        {\n            itemName = name;\n            itemIcon = icon;\n            description = desc;\n        }\n    }\n    \n    private void Start()\n    {\n        if (_notificationCanvas == null)\n            _notificationCanvas = FindObjectOfType<Canvas>();\n            \n        if (_notificationParent == null && _notificationCanvas != null)\n            _notificationParent = _notificationCanvas.transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        CreateNotificationPrefab();\n    }\n    \n    private void CreateNotificationPrefab()\n    {\n        if (_notificationPrefab != null) return;\n        \n        _notificationPrefab = new GameObject(\"NotificationPrefab\");\n        _notificationPrefab.transform.SetParent(_notificationParent, false);\n        \n        RectTransform rectTransform = _notificationPrefab.AddComponent<RectTransform>();\n        rectTransform.sizeDelta = new Vector2(300f, 80f);\n        \n        Image background = _notificationPrefab.AddComponent<Image>();\n        background.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);\n        \n        GameObject iconObject = new GameObject(\"Icon\");\n        iconObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform iconRect = iconObject.AddComponent<RectTransform>();\n        iconRect.sizeDelta = new Vector2(60f, 60f);\n        iconRect.anchoredPosition = new Vector2(-100f, 0f);\n        Image iconImage = iconObject.AddComponent<Image>();\n        \n        GameObject textObject = new GameObject(\"Text\");\n        textObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform textRect = textObject.AddComponent<RectTransform>();\n        textRect.sizeDelta = new Vector2(200f, 60f);\n        textRect.anchoredPosition = new Vector2(50f, 10f);\n        Text itemText = textObject.AddComponent<Text>();\n        itemText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        itemText.fontSize = 16;\n        itemText.color = Color.white;\n        itemText.alignment = TextAnchor.MiddleLeft;\n        \n        GameObject descObject = new GameObject(\"Description\");\n        descObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform descRect = descObject.AddComponent<RectTransform>();\n        descRect.sizeDelta = new Vector2(200f, 30f);\n        descRect.anchoredPosition = new Vector2(50f, -15f);\n        Text descText = descObject.AddComponent<Text>();\n        descText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        descText.fontSize = 12;\n        descText.color = new Color(0.8f, 0.8f, 0.8f, 1f);\n        descText.alignment = TextAnchor.MiddleLeft;\n        \n        CanvasGroup canvasGroup = _notificationPrefab.AddComponent<CanvasGroup>();\n        canvasGroup.alpha = 0f;\n        \n        _notificationPrefab.SetActive(false);\n    }\n    \n    public void ShowNotification(string itemName, Sprite itemIcon = null, string description = \"\")\n    {\n        NotificationData data = new NotificationData(itemName, itemIcon, description);\n        _notificationQueue.Enqueue(data);\n        \n        if (_audioSource != null && _pickupSound != null)\n            _audioSource.PlayOneShot(_pickupSound);\n            \n        ProcessNotificationQueue();\n    }\n    \n    public void ShowNotification(NotificationData data)\n    {\n        _notificationQueue.Enqueue(data);\n        \n        if (_audioSource != null && _pickupSound != null)\n            _audioSource.PlayOneShot(_pickupSound);\n            \n        ProcessNotificationQueue();\n    }\n    \n    private void ProcessNotificationQueue()\n    {\n        if (_notificationQueue.Count == 0) return;\n        if (_activeNotifications.Count >= _maxNotifications) return;\n        \n        NotificationData data = _notificationQueue.Dequeue();\n        GameObject notification = CreateNotification(data);\n        \n        if (notification != null)\n        {\n            _activeNotifications.Add(notification);\n            StartCoroutine(AnimateNotification(notification));\n        }\n    }\n    \n    private GameObject CreateNotification(NotificationData data)\n    {\n        if (_notificationPrefab == null || _notificationParent == null) return null;\n        \n        GameObject notification = Instantiate(_notificationPrefab, _notificationParent);\n        notification.SetActive(true);\n        \n        RectTransform rectTransform = notification.GetComponent<RectTransform>();\n        rectTransform.anchorMin = new Vector2(1f, 1f);\n        rectTransform.anchorMax = new Vector2(1f, 1f);\n        rectTransform.pivot = new Vector2(1f, 1f);\n        \n        float yOffset = -10f - (_activeNotifications.Count * 90f);\n        rectTransform.anchoredPosition = new Vector2(-10f, yOffset);\n        \n        Image background = notification.GetComponent<Image>();\n        if (background != null)\n            background.color = data.backgroundColor;\n        \n        Transform iconTransform = notification.transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            Image iconImage = iconTransform.GetComponent<Image>();\n            if (iconImage != null && data.itemIcon != null)\n            {\n                iconImage.sprite = data.itemIcon;\n                iconImage.color = Color.white;\n            }\n            else if (iconImage != null)\n            {\n                iconImage.color = Color.clear;\n            }\n        }\n        \n        Transform textTransform = notification.transform.Find(\"Text\");\n        if (textTransform != null)\n        {\n            Text itemText = textTransform.GetComponent<Text>();\n            if (itemText != null)\n                itemText.text = data.itemName;\n        }\n        \n        Transform descTransform = notification.transform.Find(\"Description\");\n        if (descTransform != null)\n        {\n            Text descText = descTransform.GetComponent<Text>();\n            if (descText != null)\n                descText.text = data.description;\n        }\n        \n        return notification;\n    }\n    \n    private IEnumerator AnimateNotification(GameObject notification)\n    {\n        if (notification == null) yield break;\n        \n        CanvasGroup canvasGroup = notification.GetComponent<CanvasGroup>();\n        RectTransform rectTransform = notification.GetComponent<RectTransform>();\n        \n        if (canvasGroup == null || rectTransform == null) yield break;\n        \n        Vector3 originalPosition = rectTransform.anchoredPosition;\n        Vector3 startPosition = originalPosition + _slideOffset;\n        rectTransform.anchoredPosition = startPosition;\n        \n        float elapsedTime = 0f;\n        while (elapsedTime < _fadeInDuration)\n        {\n            if (notification == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeInDuration;\n            \n            canvasGroup.alpha = Mathf.Lerp(0f, 1f, progress);\n            rectTransform.anchoredPosition = Vector3.Lerp(startPosition, originalPosition, progress);\n            \n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        rectTransform.anchoredPosition = originalPosition;\n        \n        yield return new WaitForSeconds(_displayDuration);\n        \n        elapsedTime = 0f;\n        while (elapsedTime < _fadeOutDuration)\n        {\n            if (notification == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeOutDuration;\n            \n            canvasGroup.alpha = Mathf.Lerp(1f, 0f, progress);\n            rectTransform.anchoredPosition = Vector3.Lerp(originalPosition, startPosition, progress);\n            \n            yield return null;\n        }\n        \n        if (notification != null)\n        {\n            _activeNotifications.Remove(notification);\n            Destroy(notification);\n            \n            UpdateNotificationPositions();\n            ProcessNotificationQueue();\n        }\n    }\n    \n    private void UpdateNotificationPositions()\n    {\n        for (int i = 0; i < _activeNotifications.Count; i++)\n        {\n            if (_activeNotifications[i] != null)\n            {\n                RectTransform rectTransform = _activeNotifications[i].GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    float yOffset = -10f - (i * 90f);\n                    Vector2 targetPosition = new Vector2(-10f, yOffset);\n                    StartCoroutine(SmoothMoveToPosition(rectTransform, targetPosition, 0.3f));\n                }\n            }\n        }\n    }\n    \n    private IEnumerator SmoothMoveToPosition(RectTransform rectTransform, Vector2 targetPosition, float duration)\n    {\n        Vector2 startPosition = rectTransform.anchoredPosition;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            if (rectTransform == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / duration;\n            \n            rectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, progress);\n            \n            yield return null;\n        }\n        \n        if (rectTransform != null)\n            rectTransform.anchoredPosition = targetPosition;\n    }\n    \n    public void ClearAllNotifications()\n    {\n        StopAllCoroutines();\n        \n        foreach (GameObject notification in _activeNotifications)\n        {\n            if (notification != null)\n                Destroy(notification);\n        }\n        \n        _activeNotifications.Clear();\n        _notificationQueue.Clear();\n    }\n    \n    private void OnDestroy()\n    {\n        ClearAllNotifications();\n    }\n}",
      "behavior_type": "pickup"
    },
    {
      "prompt": "buff and debuff icons",
      "ideal_ir": {
        "class_name": "BuffDebuffIcon",
        "components": [
          "Image",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "iconImage",
            "type": "Sprite",
            "default": null
          },
          {
            "name": "effectType",
            "type": "string",
            "default": "buff"
          },
          {
            "name": "duration",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "pulseIntensity",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_icon",
            "trigger": "when effect is applied to player",
            "actions": [
              {
                "action": "make icon visible"
              },
              {
                "action": "set icon image to match effect type"
              },
              {
                "action": "start duration countdown"
              },
              {
                "action": "mark as active"
              }
            ]
          },
          {
            "name": "pulse_animation",
            "trigger": "while icon is active",
            "actions": [
              {
                "action": "gently pulse icon transparency"
              },
              {
                "action": "create subtle breathing effect"
              }
            ]
          },
          {
            "name": "countdown_display",
            "trigger": "while duration is greater than zero",
            "actions": [
              {
                "action": "reduce remaining duration over time"
              },
              {
                "action": "update visual countdown if enabled"
              }
            ]
          },
          {
            "name": "warning_flash",
            "trigger": "when duration is less than three seconds",
            "actions": [
              {
                "action": "flash icon more rapidly"
              },
              {
                "action": "change color to warning tint"
              }
            ]
          },
          {
            "name": "expire_effect",
            "trigger": "when duration reaches zero",
            "actions": [
              {
                "action": "fade out icon smoothly"
              },
              {
                "action": "mark as inactive"
              },
              {
                "action": "hide icon completely"
              }
            ]
          },
          {
            "name": "stack_indicator",
            "trigger": "when same effect is applied multiple times",
            "actions": [
              {
                "action": "show stack count number"
              },
              {
                "action": "refresh duration to maximum"
              },
              {
                "action": "briefly highlight icon"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class BuffDebuffIconManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class BuffDebuffData\n    {\n        public string name;\n        public Sprite icon;\n        public Color iconColor = Color.white;\n        public bool isBuff = true;\n        public float duration;\n        public string description;\n    }\n\n    [System.Serializable]\n    public class ActiveEffect\n    {\n        public BuffDebuffData data;\n        public float remainingTime;\n        public GameObject iconObject;\n        public Image iconImage;\n        public Image fillImage;\n        public Text durationText;\n        \n        public ActiveEffect(BuffDebuffData effectData, float time)\n        {\n            data = effectData;\n            remainingTime = time;\n        }\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _iconContainer;\n    [SerializeField] private GameObject _iconPrefab;\n    [SerializeField] private Canvas _canvas;\n\n    [Header(\"Layout Settings\")]\n    [SerializeField] private float _iconSize = 50f;\n    [SerializeField] private float _iconSpacing = 5f;\n    [SerializeField] private int _maxIconsPerRow = 8;\n    [SerializeField] private bool _separateBuffsDebuffs = true;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _fadeOutDuration = 0.2f;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 0.8f, 1, 1f);\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _buffBorderColor = Color.green;\n    [SerializeField] private Color _debuffBorderColor = Color.red;\n    [SerializeField] private bool _showDurationText = true;\n    [SerializeField] private bool _showTooltips = true;\n\n    [Header(\"Available Effects\")]\n    [SerializeField] private List<BuffDebuffData> _availableEffects = new List<BuffDebuffData>();\n\n    private List<ActiveEffect> _activeEffects = new List<ActiveEffect>();\n    private Dictionary<string, ActiveEffect> _effectLookup = new Dictionary<string, ActiveEffect>();\n    private Coroutine _updateCoroutine;\n\n    private void Start()\n    {\n        InitializeIconContainer();\n        _updateCoroutine = StartCoroutine(UpdateEffectsCoroutine());\n    }\n\n    private void InitializeIconContainer()\n    {\n        if (_iconContainer == null)\n        {\n            GameObject container = new GameObject(\"BuffDebuffContainer\");\n            container.transform.SetParent(transform);\n            _iconContainer = container.transform;\n            \n            RectTransform rectTransform = container.AddComponent<RectTransform>();\n            rectTransform.anchorMin = new Vector2(0.5f, 1f);\n            rectTransform.anchorMax = new Vector2(0.5f, 1f);\n            rectTransform.pivot = new Vector2(0.5f, 1f);\n            rectTransform.anchoredPosition = new Vector2(0, -10f);\n        }\n\n        if (_canvas == null)\n        {\n            _canvas = GetComponentInParent<Canvas>();\n            if (_canvas == null)\n            {\n                _canvas = FindObjectOfType<Canvas>();\n            }\n        }\n\n        CreateIconPrefabIfNeeded();\n    }\n\n    private void CreateIconPrefabIfNeeded()\n    {\n        if (_iconPrefab == null)\n        {\n            _iconPrefab = new GameObject(\"BuffDebuffIcon\");\n            \n            RectTransform rectTransform = _iconPrefab.AddComponent<RectTransform>();\n            rectTransform.sizeDelta = new Vector2(_iconSize, _iconSize);\n            \n            Image backgroundImage = _iconPrefab.AddComponent<Image>();\n            backgroundImage.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);\n            \n            GameObject iconChild = new GameObject(\"Icon\");\n            iconChild.transform.SetParent(_iconPrefab.transform);\n            RectTransform iconRect = iconChild.AddComponent<RectTransform>();\n            iconRect.anchorMin = Vector2.zero;\n            iconRect.anchorMax = Vector2.one;\n            iconRect.offsetMin = Vector2.one * 2f;\n            iconRect.offsetMax = Vector2.one * -2f;\n            Image iconImage = iconChild.AddComponent<Image>();\n            \n            GameObject fillChild = new GameObject(\"Fill\");\n            fillChild.transform.SetParent(_iconPrefab.transform);\n            RectTransform fillRect = fillChild.AddComponent<RectTransform>();\n            fillRect.anchorMin = Vector2.zero;\n            fillRect.anchorMax = Vector2.one;\n            fillRect.offsetMin = Vector2.zero;\n            fillRect.offsetMax = Vector2.zero;\n            Image fillImage = fillChild.AddComponent<Image>();\n            fillImage.color = new Color(1f, 1f, 1f, 0.3f);\n            fillImage.type = Image.Type.Filled;\n            fillImage.fillMethod = Image.FillMethod.Radial360;\n            \n            if (_showDurationText)\n            {\n                GameObject textChild = new GameObject(\"Duration\");\n                textChild.transform.SetParent(_iconPrefab.transform);\n                RectTransform textRect = textChild.AddComponent<RectTransform>();\n                textRect.anchorMin = new Vector2(0f, 0f);\n                textRect.anchorMax = new Vector2(1f, 0.3f);\n                textRect.offsetMin = Vector2.zero;\n                textRect.offsetMax = Vector2.zero;\n                Text durationText = textChild.AddComponent<Text>();\n                durationText.text = \"\";\n                durationText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n                durationText.fontSize = 10;\n                durationText.color = Color.white;\n                durationText.alignment = TextAnchor.MiddleCenter;\n            }\n            \n            _iconPrefab.SetActive(false);\n        }\n    }\n\n    public void AddEffect(string effectName, float duration = -1f)\n    {\n        BuffDebuffData effectData = GetEffectData(effectName);\n        if (effectData == null)\n        {\n            Debug.LogWarning($\"Effect '{effectName}' not found in available effects.\");\n            return;\n        }\n\n        float effectDuration = duration > 0 ? duration : effectData.duration;\n        \n        if (_effectLookup.ContainsKey(effectName))\n        {\n            RefreshEffect(effectName, effectDuration);\n        }\n        else\n        {\n            CreateNewEffect(effectData, effectDuration);\n        }\n        \n        UpdateIconLayout();\n    }\n\n    public void RemoveEffect(string effectName)\n    {\n        if (_effectLookup.ContainsKey(effectName))\n        {\n            ActiveEffect effect = _effectLookup[effectName];\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    public void RemoveAllEffects()\n    {\n        List<ActiveEffect> effectsToRemove = new List<ActiveEffect>(_activeEffects);\n        foreach (ActiveEffect effect in effectsToRemove)\n        {\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    public bool HasEffect(string effectName)\n    {\n        return _effectLookup.ContainsKey(effectName);\n    }\n\n    public float GetEffectRemainingTime(string effectName)\n    {\n        if (_effectLookup.ContainsKey(effectName))\n        {\n            return _effectLookup[effectName].remainingTime;\n        }\n        return 0f;\n    }\n\n    private BuffDebuffData GetEffectData(string effectName)\n    {\n        return _availableEffects.Find(effect => effect.name == effectName);\n    }\n\n    private void RefreshEffect(string effectName, float newDuration)\n    {\n        ActiveEffect effect = _effectLookup[effectName];\n        effect.remainingTime = newDuration;\n        \n        if (effect.iconObject != null)\n        {\n            StartCoroutine(RefreshEffectAnimation(effect.iconObject));\n        }\n    }\n\n    private void CreateNewEffect(BuffDebuffData effectData, float duration)\n    {\n        GameObject iconObject = Instantiate(_iconPrefab, _iconContainer);\n        iconObject.SetActive(true);\n        \n        ActiveEffect newEffect = new ActiveEffect(effectData, duration);\n        newEffect.iconObject = iconObject;\n        \n        SetupIconComponents(newEffect);\n        _activeEffects.Add(newEffect);\n        _effectLookup[effectData.name] = newEffect;\n        \n        StartCoroutine(FadeInEffect(newEffect));\n    }\n\n    private void SetupIconComponents(ActiveEffect effect)\n    {\n        Image backgroundImage = effect.iconObject.GetComponent<Image>();\n        backgroundImage.color = effect.data.isBuff ? _buffBorderColor : _debuffBorderColor;\n        \n        Transform iconTransform = effect.iconObject.transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            effect.iconImage = iconTransform.GetComponent<Image>();\n            effect.iconImage.sprite = effect.data.icon;\n            effect.iconImage.color = effect.data.iconColor;\n        }\n        \n        Transform fillTransform = effect.iconObject.transform.Find(\"Fill\");\n        if (fillTransform != null)\n        {\n            effect.fillImage = fillTransform.GetComponent<Image>();\n        }\n        \n        if (_showDurationText)\n        {\n            Transform textTransform = effect.iconObject.transform.Find(\"Duration\");\n            if (textTransform != null)\n            {\n                effect.durationText = textTransform.GetComponent<Text>();\n            }\n        }\n        \n        if (_showTooltips)\n        {\n            SetupTooltip(effect);\n        }\n    }\n\n    private void SetupTooltip(ActiveEffect effect)\n    {\n        TooltipTrigger tooltip = effect.iconObject.GetComponent<TooltipTrigger>();\n        if (tooltip == null)\n        {\n            tooltip = effect.iconObject.AddComponent<TooltipTrigger>();\n        }\n        tooltip.tooltipText = $\"{effect.data.name}\\n{effect.data.description}\";\n    }\n\n    private IEnumerator UpdateEffectsCoroutine()\n    {\n        while (true)\n        {\n            UpdateActiveEffects();\n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n\n    private void UpdateActiveEffects()\n    {\n        List<ActiveEffect> effectsToRemove = new List<ActiveEffect>();\n        \n        foreach (ActiveEffect effect in _activeEffects)\n        {\n            if (effect.data.duration > 0)\n            {\n                effect.remainingTime -= 0.1f;\n                \n                if (effect.remainingTime <= 0)\n                {\n                    effectsToRemove.Add(effect);\n                }\n                else\n                {\n                    UpdateEffectVisuals(effect);\n                }\n            }\n        }\n        \n        foreach (ActiveEffect effect in effectsToRemove)\n        {\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    private void UpdateEffectVisuals(ActiveEffect effect)\n    {\n        if (effect.fillImage != null && effect.data.duration > 0)\n        {\n            float fillAmount = effect.remainingTime / effect.data.duration;\n            effect.fillImage.fillAmount = fillAmount;\n        }\n        \n        if (effect.durationText != null && _showDurationText)\n        {\n            if (effect.remainingTime > 60f)\n            {\n                effect.durationText.text = $\"{Mathf.CeilToInt(effect.remainingTime / 60f)}m\";\n            }\n            else if (effect.remainingTime > 0)\n            {\n                effect.durationText.text = Mathf.CeilToInt(effect.remainingTime).ToString();\n            }\n        }\n    }\n\n    private void UpdateIconLayout()\n    {\n        if (_separateBuffsDebuffs)\n        {\n            LayoutSeparatedIcons();\n        }\n        else\n        {\n            LayoutMixedIcons();\n        }\n    }\n\n    private void LayoutSeparatedIcons()\n    {\n        List<ActiveEffect> buffs = _activeEffects.FindAll(e => e.data.isBuff);\n        List<ActiveEffect> debuffs = _activeEffects.FindAll(e => !e.data.isBuff);\n        \n        float currentY = 0f;\n        \n        if (buffs.Count > 0)\n        {\n            LayoutEffectRow(buffs, ref currentY);\n            currentY -= _iconSize + _iconSpacing;\n        }\n        \n        if (debuffs.Count > 0)\n        {\n            LayoutEffectRow(debuffs, ref currentY);\n        }\n    }\n\n    private void LayoutMixedIcons()\n    {\n        float currentY = 0f;\n        LayoutEffectRow(_activeEffects, ref currentY);\n    }\n\n    private void LayoutEffectRow(List<ActiveEffect> effects, ref float currentY)\n    {\n        int iconsInRow = 0;\n        float currentX = 0f;\n        \n        for (int i = 0; i < effects.Count; i++)\n        {\n            if (iconsInRow >= _maxIconsPerRow)\n            {\n                iconsInRow = 0;\n                currentY -= _iconSize + _iconSpacing;\n                currentX = 0f;\n            }\n            \n            if (iconsInRow == 0)\n            {\n                int iconsThisRow = Mathf.Min(_maxIconsPerRow, effects.Count - i);\n                float totalWidth = iconsThisRow * _iconSize + (iconsThisRow - 1) * _iconSpacing;\n                currentX = -totalWidth * 0.5f + _iconSize * 0.5f;\n            }\n            \n            RectTransform iconRect = effects[i].iconObject.GetComponent<RectTransform>();\n            iconRect.anchoredPosition = new Vector2(currentX, currentY);\n            \n            currentX += _iconSize + _iconSpacing;\n            iconsInRow++;\n        }\n    }\n\n    private IEnumerator FadeInEffect(ActiveEffect effect)\n    {\n        CanvasGroup canvasGroup = effect.iconObject.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = effect.iconObject.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.alpha = 0f;\n        effect.iconObject.transform.localScale = Vector3.one * 0.8f;\n        \n        float elapsed = 0f;\n        while (elapsed < _fadeInDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeInDuration;\n            \n            canvasGroup.alpha = progress;\n            effect.iconObject.transform.localScale = Vector3.one * _scaleCurve.Evaluate(progress);\n            \n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        effect.iconObject.transform.localScale = Vector3.one;\n    }\n\n    private IEnumerator RemoveEffectCoroutine(ActiveEffect effect)\n    {\n        _activeEffects.Remove(effect);\n        _effectLookup.Remove(effect.data.name);",
      "behavior_type": "general"
    },
    {
      "prompt": "skateboard with tricks",
      "ideal_ir": {
        "class_name": "Skateboard",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "speed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "jumpForce",
            "type": "float",
            "default": 12.0
          },
          {
            "name": "trickDuration",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "isGrounded",
            "type": "bool",
            "default": true
          },
          {
            "name": "isPerformingTrick",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentTrick",
            "type": "string",
            "default": "none"
          }
        ],
        "behaviors": [
          {
            "name": "move_forward",
            "trigger": "when forward input is pressed and skateboard is grounded",
            "actions": [
              {
                "action": "accelerate skateboard forward at specified speed"
              },
              {
                "action": "play rolling sound effect"
              }
            ]
          },
          {
            "name": "perform_ollie",
            "trigger": "when jump input is pressed and skateboard is grounded",
            "actions": [
              {
                "action": "apply upward force to launch skateboard into air"
              },
              {
                "action": "set grounded status to false"
              },
              {
                "action": "play jump sound effect"
              },
              {
                "action": "rotate skateboard slightly backward during jump"
              }
            ]
          },
          {
            "name": "kickflip_trick",
            "trigger": "when trick input is pressed while skateboard is airborne",
            "actions": [
              {
                "action": "set trick performing status to true"
              },
              {
                "action": "set current trick to kickflip"
              },
              {
                "action": "rotate skateboard rapidly around forward axis"
              },
              {
                "action": "play trick sound effect"
              }
            ]
          },
          {
            "name": "land_skateboard",
            "trigger": "when skateboard collides with ground after being airborne",
            "actions": [
              {
                "action": "set grounded status to true"
              },
              {
                "action": "stop all trick rotations"
              },
              {
                "action": "set trick performing status to false"
              },
              {
                "action": "reset current trick to none"
              },
              {
                "action": "play landing sound effect"
              }
            ]
          },
          {
            "name": "grind_rail",
            "trigger": "when skateboard contacts rail object while moving",
            "actions": [
              {
                "action": "align skateboard to rail direction"
              },
              {
                "action": "slide along rail surface"
              },
              {
                "action": "play grinding sound effect"
              },
              {
                "action": "create sparks particle effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SkateboardController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 8f;\n    [SerializeField] private float _deceleration = 12f;\n    [SerializeField] private float _turnSpeed = 120f;\n    [SerializeField] private float _pushForce = 10f;\n    \n    [Header(\"Trick Settings\")]\n    [SerializeField] private float _jumpForce = 8f;\n    [SerializeField] private float _flipSpeed = 360f;\n    [SerializeField] private float _trickTimeWindow = 0.5f;\n    [SerializeField] private float _landingTolerance = 15f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _groundCheckDistance = 0.6f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private Transform _groundCheckPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pushSound;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _landSound;\n    [SerializeField] private AudioClip _trickSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<TrickType> OnTrickPerformed;\n    public UnityEvent<float> OnSpeedChanged;\n    public UnityEvent OnLanded;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private bool _isPerformingTrick;\n    private float _currentSpeed;\n    private float _trickTimer;\n    private Vector3 _trickRotation;\n    private TrickType _currentTrick;\n    \n    public enum TrickType\n    {\n        None,\n        Ollie,\n        Kickflip,\n        Heelflip,\n        Shuvit,\n        Treflip\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject checkPoint = new GameObject(\"GroundCheck\");\n            checkPoint.transform.SetParent(transform);\n            checkPoint.transform.localPosition = Vector3.down * 0.5f;\n            _groundCheckPoint = checkPoint.transform;\n        }\n        \n        _rigidbody.centerOfMass = Vector3.down * 0.2f;\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleInput();\n        UpdateTrickTimer();\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n        ApplyTrickRotation();\n    }\n    \n    private void CheckGrounded()\n    {\n        bool wasGrounded = _isGrounded;\n        _isGrounded = Physics.Raycast(_groundCheckPoint.position, Vector3.down, _groundCheckDistance, _groundLayer);\n        \n        if (!wasGrounded && _isGrounded)\n        {\n            OnLanded?.Invoke();\n            PlaySound(_landSound);\n            \n            if (_isPerformingTrick)\n            {\n                CompleteTrick();\n            }\n        }\n        \n        Debug.DrawRay(_groundCheckPoint.position, Vector3.down * _groundCheckDistance, _isGrounded ? Color.green : Color.red);\n    }\n    \n    private void HandleInput()\n    {\n        if (_isGrounded && !_isPerformingTrick)\n        {\n            // Push forward\n            if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow))\n            {\n                Push();\n            }\n            \n            // Tricks\n            if (Input.GetKeyDown(KeyCode.Space))\n            {\n                PerformTrick(TrickType.Ollie);\n            }\n            else if (Input.GetKeyDown(KeyCode.Q))\n            {\n                PerformTrick(TrickType.Kickflip);\n            }\n            else if (Input.GetKeyDown(KeyCode.E))\n            {\n                PerformTrick(TrickType.Heelflip);\n            }\n            else if (Input.GetKeyDown(KeyCode.R))\n            {\n                PerformTrick(TrickType.Shuvit);\n            }\n            else if (Input.GetKeyDown(KeyCode.T))\n            {\n                PerformTrick(TrickType.Treflip);\n            }\n        }\n        \n        // Steering\n        float steerInput = Input.GetAxis(\"Horizontal\");\n        if (Mathf.Abs(steerInput) > 0.1f && _currentSpeed > 1f)\n        {\n            transform.Rotate(0, steerInput * _turnSpeed * Time.deltaTime, 0);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_isGrounded)\n        {\n            // Apply deceleration\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0, _deceleration * Time.fixedDeltaTime);\n            \n            // Apply movement\n            Vector3 moveDirection = transform.forward * _currentSpeed;\n            _rigidbody.velocity = new Vector3(moveDirection.x, _rigidbody.velocity.y, moveDirection.z);\n        }\n    }\n    \n    private void Push()\n    {\n        _currentSpeed = Mathf.Min(_currentSpeed + _pushForce, _maxSpeed);\n        PlaySound(_pushSound);\n    }\n    \n    private void PerformTrick(TrickType trickType)\n    {\n        if (_isPerformingTrick) return;\n        \n        _isPerformingTrick = true;\n        _currentTrick = trickType;\n        _trickTimer = _trickTimeWindow;\n        \n        // Apply jump force\n        _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        \n        // Set trick rotation based on type\n        switch (trickType)\n        {\n            case TrickType.Ollie:\n                _trickRotation = Vector3.zero;\n                break;\n            case TrickType.Kickflip:\n                _trickRotation = new Vector3(_flipSpeed, 0, 0);\n                break;\n            case TrickType.Heelflip:\n                _trickRotation = new Vector3(-_flipSpeed, 0, 0);\n                break;\n            case TrickType.Shuvit:\n                _trickRotation = new Vector3(0, _flipSpeed, 0);\n                break;\n            case TrickType.Treflip:\n                _trickRotation = new Vector3(_flipSpeed, _flipSpeed, 0);\n                break;\n        }\n        \n        PlaySound(_jumpSound);\n        OnTrickPerformed?.Invoke(trickType);\n    }\n    \n    private void ApplyTrickRotation()\n    {\n        if (_isPerformingTrick && !_isGrounded)\n        {\n            Vector3 rotationThisFrame = _trickRotation * Time.fixedDeltaTime;\n            transform.Rotate(rotationThisFrame, Space.Self);\n        }\n    }\n    \n    private void UpdateTrickTimer()\n    {\n        if (_isPerformingTrick)\n        {\n            _trickTimer -= Time.deltaTime;\n            \n            if (_trickTimer <= 0 && !_isGrounded)\n            {\n                // Trick failed - didn't land in time\n                _isPerformingTrick = false;\n                _currentTrick = TrickType.None;\n                _trickRotation = Vector3.zero;\n            }\n        }\n    }\n    \n    private void CompleteTrick()\n    {\n        if (_currentTrick == TrickType.None) return;\n        \n        // Check if landed properly (board relatively upright)\n        float uprightAngle = Vector3.Angle(transform.up, Vector3.up);\n        \n        if (uprightAngle <= _landingTolerance)\n        {\n            // Successful trick landing\n            PlaySound(_trickSound);\n            Debug.Log($\"Successfully landed {_currentTrick}!\");\n        }\n        else\n        {\n            // Failed landing\n            Debug.Log($\"Failed to land {_currentTrick} properly. Angle: {uprightAngle:F1}\u00b0\");\n        }\n        \n        _isPerformingTrick = false;\n        _currentTrick = TrickType.None;\n        _trickRotation = Vector3.zero;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsGrounded()\n    {\n        return _isGrounded;\n    }\n    \n    public bool IsPerformingTrick()\n    {\n        return _isPerformingTrick;\n    }\n    \n    public TrickType GetCurrentTrick()\n    {\n        return _currentTrick;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, 0.1f);\n            Gizmos.DrawLine(_groundCheckPoint.position, _groundCheckPoint.position + Vector3.down * _groundCheckDistance);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "surfboard on waves",
      "ideal_ir": {
        "class_name": "Surfboard",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "buoyancyForce",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "stabilityForce",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "waveHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "waveSpeed",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "tiltSensitivity",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "float_on_waves",
            "trigger": "always while on water surface",
            "actions": [
              {
                "action": "calculate wave height at current position using sine wave pattern"
              },
              {
                "action": "apply upward buoyancy force to match wave height"
              },
              {
                "action": "bob up and down following wave motion"
              }
            ]
          },
          {
            "name": "wave_physics",
            "trigger": "when wave passes underneath",
            "actions": [
              {
                "action": "tilt forward when going up wave"
              },
              {
                "action": "tilt backward when going down wave"
              },
              {
                "action": "apply forward momentum from wave energy"
              }
            ]
          },
          {
            "name": "stability_control",
            "trigger": "when tilting beyond normal wave motion",
            "actions": [
              {
                "action": "apply counter-rotation force to prevent flipping"
              },
              {
                "action": "gradually return to upright position"
              },
              {
                "action": "dampen excessive rolling motion"
              }
            ]
          },
          {
            "name": "wave_interaction",
            "trigger": "continuously while in water",
            "actions": [
              {
                "action": "move horizontally with wave direction"
              },
              {
                "action": "create splash effects when hitting wave crests"
              },
              {
                "action": "adjust rotation to follow wave surface angle"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SurfboardController : MonoBehaviour\n{\n    [Header(\"Surfboard Physics\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _turnSpeed = 120f;\n    [SerializeField] private float _stabilityForce = 10f;\n    [SerializeField] private float _buoyancyForce = 20f;\n    \n    [Header(\"Wave Interaction\")]\n    [SerializeField] private float _waveHeight = 2f;\n    [SerializeField] private float _waveSpeed = 1f;\n    [SerializeField] private float _waveLength = 10f;\n    [SerializeField] private LayerMask _waterLayer = 1;\n    \n    [Header(\"Tilt and Balance\")]\n    [SerializeField] private float _maxTiltAngle = 30f;\n    [SerializeField] private float _tiltSpeed = 2f;\n    [SerializeField] private float _balanceRecoverySpeed = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _ridingSound;\n    \n    private Rigidbody _rigidbody;\n    private Transform _playerTransform;\n    private Vector3 _initialPosition;\n    private float _currentSpeed;\n    private float _currentTilt;\n    private bool _isOnWave;\n    private bool _isPlayerOnBoard;\n    private float _waveOffset;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        _initialPosition = transform.position;\n        _waveOffset = Random.Range(0f, Mathf.PI * 2f);\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.spatialBlend = 1f;\n        _audioSource.volume = 0.5f;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWavePosition();\n        HandleTilt();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyMovement();\n        ApplyStability();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_isPlayerOnBoard) return;\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        // Apply turning\n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            transform.Rotate(0, horizontal * _turnSpeed * Time.deltaTime, 0);\n            _currentTilt = Mathf.Lerp(_currentTilt, horizontal * _maxTiltAngle, _tiltSpeed * Time.deltaTime);\n        }\n        else\n        {\n            _currentTilt = Mathf.Lerp(_currentTilt, 0f, _balanceRecoverySpeed * Time.deltaTime);\n        }\n        \n        // Apply forward movement\n        if (vertical > 0.1f)\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, _maxSpeed * vertical, _acceleration * Time.deltaTime);\n        }\n        else\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0f, _acceleration * 0.5f * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateWavePosition()\n    {\n        float waveY = Mathf.Sin((transform.position.x / _waveLength + Time.time * _waveSpeed + _waveOffset)) * _waveHeight;\n        float targetY = _initialPosition.y + waveY;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position + Vector3.up * 5f, Vector3.down, out hit, 10f, _waterLayer))\n        {\n            targetY = hit.point.y + 0.5f;\n            _isOnWave = true;\n        }\n        else\n        {\n            _isOnWave = false;\n        }\n        \n        Vector3 targetPosition = new Vector3(transform.position.x, targetY, transform.position.z);\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 2f);\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isOnWave)\n        {\n            Vector3 buoyancy = Vector3.up * _buoyancyForce;\n            _rigidbody.AddForce(buoyancy, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        if (_isPlayerOnBoard && _currentSpeed > 0.1f)\n        {\n            Vector3 forward = transform.forward * _currentSpeed;\n            _rigidbody.AddForce(forward, ForceMode.Force);\n            \n            // Limit max velocity\n            if (_rigidbody.velocity.magnitude > _maxSpeed)\n            {\n                _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n            }\n        }\n    }\n    \n    private void ApplyStability()\n    {\n        Vector3 stabilityTorque = Vector3.zero;\n        \n        // Roll stability\n        float rollAngle = Vector3.Angle(Vector3.up, transform.up);\n        if (rollAngle > 5f)\n        {\n            Vector3 rollCorrection = Vector3.Cross(transform.up, Vector3.up);\n            stabilityTorque += rollCorrection * _stabilityForce;\n        }\n        \n        // Pitch stability\n        Vector3 forwardProjected = Vector3.ProjectOnPlane(transform.forward, Vector3.up);\n        float pitchAngle = Vector3.Angle(transform.forward, forwardProjected);\n        if (pitchAngle > 10f)\n        {\n            Vector3 pitchCorrection = Vector3.Cross(transform.forward, forwardProjected);\n            stabilityTorque += pitchCorrection * _stabilityForce * 0.5f;\n        }\n        \n        _rigidbody.AddTorque(stabilityTorque, ForceMode.Force);\n    }\n    \n    private void HandleTilt()\n    {\n        Vector3 currentRotation = transform.eulerAngles;\n        currentRotation.z = _currentTilt;\n        transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(currentRotation), Time.deltaTime * _tiltSpeed);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_isPlayerOnBoard && _currentSpeed > 1f && _ridingSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _ridingSound)\n            {\n                _audioSource.clip = _ridingSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            _audioSource.pitch = Mathf.Lerp(0.8f, 1.5f, _currentSpeed / _maxSpeed);\n        }\n        else if (_audioSource.isPlaying && _audioSource.clip == _ridingSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerOnBoard = true;\n            _playerTransform = other.transform;\n            \n            // Position player on surfboard\n            other.transform.SetParent(transform);\n            other.transform.localPosition = Vector3.up * 0.5f;\n            \n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerOnBoard = false;\n            \n            if (_playerTransform != null)\n            {\n                _playerTransform.SetParent(null);\n                _playerTransform = null;\n            }\n            \n            _currentSpeed = 0f;\n            _currentTilt = 0f;\n            \n            if (_audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, 2f);\n        \n        Gizmos.color = Color.cyan;\n        for (int i = 0; i < 20; i++)\n        {\n            float x = transform.position.x + (i - 10) * 2f;\n            float waveY = Mathf.Sin((x / _waveLength + Time.time * _waveSpeed + _waveOffset)) * _waveHeight;\n            Vector3 wavePoint = new Vector3(x, _initialPosition.y + waveY, transform.position.z);\n            Gizmos.DrawWireSphere(wavePoint, 0.2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "snowboard down slopes",
      "ideal_ir": {
        "class_name": "SnowboardController",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 25
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 8
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 120
          },
          {
            "name": "brakeForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "jumpForce",
            "type": "float",
            "default": 12
          },
          {
            "name": "slopeAngleThreshold",
            "type": "float",
            "default": 15
          },
          {
            "name": "isGrounded",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "accelerate_downhill",
            "trigger": "when on a slope steeper than threshold angle",
            "actions": [
              {
                "action": "accelerate forward based on slope steepness"
              },
              {
                "action": "limit speed to maximum allowed"
              }
            ]
          },
          {
            "name": "turn_left",
            "trigger": "when left input is pressed and grounded",
            "actions": [
              {
                "action": "rotate left at turn speed"
              },
              {
                "action": "lean snowboard left for visual effect"
              }
            ]
          },
          {
            "name": "turn_right",
            "trigger": "when right input is pressed and grounded",
            "actions": [
              {
                "action": "rotate right at turn speed"
              },
              {
                "action": "lean snowboard right for visual effect"
              }
            ]
          },
          {
            "name": "brake",
            "trigger": "when brake input is held and grounded",
            "actions": [
              {
                "action": "apply brake force to reduce speed"
              },
              {
                "action": "create snow spray particle effect"
              }
            ]
          },
          {
            "name": "jump",
            "trigger": "when jump input is pressed and grounded",
            "actions": [
              {
                "action": "apply upward jump force"
              },
              {
                "action": "set grounded status to false"
              }
            ]
          },
          {
            "name": "land_on_ground",
            "trigger": "when colliding with ground while not grounded",
            "actions": [
              {
                "action": "set grounded status to true"
              },
              {
                "action": "create landing impact effect"
              }
            ]
          },
          {
            "name": "maintain_slope_alignment",
            "trigger": "when grounded on sloped terrain",
            "actions": [
              {
                "action": "align snowboard rotation to match ground slope"
              },
              {
                "action": "adjust rider posture based on terrain angle"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SnowboardController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 20f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 3f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _gravityMultiplier = 2f;\n    \n    [Header(\"Slope Detection\")]\n    [SerializeField] private float _slopeCheckDistance = 1.5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _minSlopeAngle = 5f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _airDrag = 0.5f;\n    [SerializeField] private float _groundDrag = 2f;\n    [SerializeField] private float _jumpForce = 8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _snowSprayEffect;\n    [SerializeField] private TrailRenderer _boardTrail;\n    [SerializeField] private Transform _boardVisual;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _carveSound;\n    [SerializeField] private AudioClip _jumpSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLanding;\n    public UnityEvent OnJump;\n    public UnityEvent<float> OnSpeedChange;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private bool _isOnSlope;\n    private float _currentSpeed;\n    private float _slopeAngle;\n    private Vector3 _slopeNormal;\n    private Vector3 _moveDirection;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.freezeRotation = true;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_snowSprayEffect != null)\n        {\n            _snowSprayEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        CheckGroundStatus();\n        UpdateVisualEffects();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyMovement();\n        ApplyGravity();\n        HandleDrag();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = Input.GetAxis(\"Vertical\");\n        \n        if (_isGrounded)\n        {\n            // Turn the snowboard\n            if (Mathf.Abs(horizontalInput) > 0.1f)\n            {\n                transform.Rotate(0, horizontalInput * _turnSpeed * Time.deltaTime, 0);\n            }\n            \n            // Calculate movement direction based on slope\n            if (_isOnSlope)\n            {\n                _moveDirection = GetSlopeDirection();\n            }\n            else\n            {\n                _moveDirection = transform.forward;\n            }\n            \n            // Jump\n            if (Input.GetKeyDown(KeyCode.Space))\n            {\n                Jump();\n            }\n        }\n    }\n    \n    private void CheckGroundStatus()\n    {\n        RaycastHit hit;\n        _wasGrounded = _isGrounded;\n        \n        if (Physics.Raycast(transform.position, Vector3.down, out hit, _slopeCheckDistance, _groundLayer))\n        {\n            _isGrounded = true;\n            _slopeNormal = hit.normal;\n            _slopeAngle = Vector3.Angle(Vector3.up, _slopeNormal);\n            _isOnSlope = _slopeAngle > _minSlopeAngle && _slopeAngle < 60f;\n            \n            // Landing detection\n            if (!_wasGrounded && _isGrounded)\n            {\n                OnLanding?.Invoke();\n            }\n        }\n        else\n        {\n            _isGrounded = false;\n            _isOnSlope = false;\n            _slopeAngle = 0f;\n        }\n    }\n    \n    private Vector3 GetSlopeDirection()\n    {\n        Vector3 forward = transform.forward;\n        return Vector3.ProjectOnPlane(forward, _slopeNormal).normalized;\n    }\n    \n    private void ApplyMovement()\n    {\n        if (_isGrounded && _isOnSlope)\n        {\n            // Calculate slope-based acceleration\n            float slopeAcceleration = _acceleration * (_slopeAngle / 45f);\n            _currentSpeed = Mathf.Min(_currentSpeed + slopeAcceleration * Time.fixedDeltaTime, _maxSpeed);\n            \n            // Apply movement\n            Vector3 targetVelocity = _moveDirection * _currentSpeed;\n            targetVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 5f);\n        }\n        else if (_isGrounded && !_isOnSlope)\n        {\n            // Decelerate on flat ground\n            _currentSpeed = Mathf.Max(_currentSpeed - _deceleration * Time.fixedDeltaTime, 0f);\n            \n            Vector3 targetVelocity = _moveDirection * _currentSpeed;\n            targetVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 3f);\n        }\n        \n        OnSpeedChange?.Invoke(_currentSpeed);\n    }\n    \n    private void ApplyGravity()\n    {\n        if (!_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.down * _gravityMultiplier * Physics.gravity.magnitude, ForceMode.Acceleration);\n        }\n    }\n    \n    private void HandleDrag()\n    {\n        _rigidbody.drag = _isGrounded ? _groundDrag : _airDrag;\n    }\n    \n    private void Jump()\n    {\n        if (_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n            OnJump?.Invoke();\n            \n            if (_audioSource != null && _jumpSound != null)\n            {\n                _audioSource.PlayOneShot(_jumpSound);\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        // Snow spray effect\n        if (_snowSprayEffect != null)\n        {\n            if (_isGrounded && _currentSpeed > 5f)\n            {\n                if (!_snowSprayEffect.isPlaying)\n                {\n                    _snowSprayEffect.Play();\n                }\n                \n                var emission = _snowSprayEffect.emission;\n                emission.rateOverTime = _currentSpeed * 2f;\n            }\n            else if (_snowSprayEffect.isPlaying)\n            {\n                _snowSprayEffect.Stop();\n            }\n        }\n        \n        // Board trail\n        if (_boardTrail != null)\n        {\n            _boardTrail.emitting = _isGrounded && _currentSpeed > 3f;\n        }\n        \n        // Board visual rotation\n        if (_boardVisual != null && _isGrounded)\n        {\n            float tiltAngle = Mathf.Clamp(Input.GetAxis(\"Horizontal\") * 15f, -15f, 15f);\n            _boardVisual.localRotation = Quaternion.Lerp(_boardVisual.localRotation, \n                Quaternion.Euler(0, 0, -tiltAngle), Time.deltaTime * 5f);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _carveSound != null)\n        {\n            if (_isGrounded && _currentSpeed > 3f && Mathf.Abs(Input.GetAxis(\"Horizontal\")) > 0.3f)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _carveSound;\n                    _audioSource.Play();\n                }\n                _audioSource.volume = Mathf.Clamp01(_currentSpeed / _maxSpeed);\n            }\n            else if (_audioSource.isPlaying && _audioSource.clip == _carveSound)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw slope check ray\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * _slopeCheckDistance);\n        \n        // Draw slope normal\n        if (_isOnSlope)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawRay(transform.position, _slopeNormal * 2f);\n        }\n        \n        // Draw movement direction\n        if (_moveDirection != Vector3.zero)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(transform.position, _moveDirection * 3f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "bicycle with pedaling",
      "ideal_ir": {
        "class_name": "Bicycle",
        "components": [
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "pedalingSpeed",
            "type": "float",
            "default": 0
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 2
          },
          {
            "name": "brakeForce",
            "type": "float",
            "default": 5
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "isPedaling",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentSpeed",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "start_pedaling",
            "trigger": "when forward input is pressed",
            "actions": [
              {
                "action": "set pedaling state to true"
              },
              {
                "action": "play pedaling sound effect"
              }
            ]
          },
          {
            "name": "stop_pedaling",
            "trigger": "when forward input is released",
            "actions": [
              {
                "action": "set pedaling state to false"
              },
              {
                "action": "stop pedaling sound effect"
              }
            ]
          },
          {
            "name": "accelerate_bicycle",
            "trigger": "when pedaling is active",
            "actions": [
              {
                "action": "increase current speed toward max speed using acceleration"
              },
              {
                "action": "move bicycle forward at current speed"
              }
            ]
          },
          {
            "name": "coast_bicycle",
            "trigger": "when not pedaling and not braking",
            "actions": [
              {
                "action": "gradually reduce current speed due to friction"
              }
            ]
          },
          {
            "name": "brake_bicycle",
            "trigger": "when brake input is pressed",
            "actions": [
              {
                "action": "reduce current speed using brake force"
              },
              {
                "action": "play braking sound effect"
              }
            ]
          },
          {
            "name": "turn_bicycle",
            "trigger": "when horizontal input is detected and bicycle is moving",
            "actions": [
              {
                "action": "rotate bicycle left or right based on input at turn speed"
              },
              {
                "action": "lean bicycle slightly in turn direction"
              }
            ]
          },
          {
            "name": "stop_bicycle",
            "trigger": "when current speed reaches zero",
            "actions": [
              {
                "action": "stop all movement"
              },
              {
                "action": "return bicycle to upright position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class Bicycle : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _turnSpeed = 90f;\n    [SerializeField] private float _minSpeedForTurning = 1f;\n    \n    [Header(\"Pedaling Settings\")]\n    [SerializeField] private float _pedalForce = 10f;\n    [SerializeField] private float _pedalCooldown = 0.2f;\n    [SerializeField] private float _pedalDecayRate = 2f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _groundCheckDistance = 1.1f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _gravity = -20f;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _frontWheel;\n    [SerializeField] private Transform _backWheel;\n    [SerializeField] private Transform _pedals;\n    [SerializeField] private Transform _handlebars;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pedalSound;\n    [SerializeField] private AudioClip _wheelSound;\n    \n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private float _pedalPower;\n    private float _lastPedalTime;\n    private bool _isGrounded;\n    private float _verticalVelocity;\n    private float _wheelRotation;\n    private float _pedalRotation;\n    private Vector3 _moveDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.freezeRotation = true;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdatePedalPower();\n        CheckGrounded();\n        UpdateVisuals();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n        HandleGravity();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.W))\n        {\n            Pedal();\n        }\n        \n        if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.S))\n        {\n            Brake();\n        }\n    }\n    \n    private void Pedal()\n    {\n        if (Time.time - _lastPedalTime >= _pedalCooldown && _isGrounded)\n        {\n            _pedalPower = Mathf.Min(_pedalPower + _pedalForce, _maxSpeed);\n            _lastPedalTime = Time.time;\n            \n            if (_audioSource != null && _pedalSound != null)\n            {\n                _audioSource.PlayOneShot(_pedalSound, 0.5f);\n            }\n        }\n    }\n    \n    private void Brake()\n    {\n        _pedalPower = Mathf.Max(_pedalPower - _deceleration * Time.deltaTime, 0f);\n    }\n    \n    private void UpdatePedalPower()\n    {\n        if (Time.time - _lastPedalTime > _pedalCooldown)\n        {\n            _pedalPower = Mathf.Max(_pedalPower - _pedalDecayRate * Time.deltaTime, 0f);\n        }\n        \n        _currentSpeed = _pedalPower;\n    }\n    \n    private void HandleMovement()\n    {\n        if (!_isGrounded) return;\n        \n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (_currentSpeed > _minSpeedForTurning)\n        {\n            float turnAmount = horizontalInput * _turnSpeed * Time.fixedDeltaTime;\n            transform.Rotate(0, turnAmount, 0);\n        }\n        \n        _moveDirection = transform.forward * _currentSpeed;\n        Vector3 targetVelocity = new Vector3(_moveDirection.x, _rigidbody.velocity.y, _moveDirection.z);\n        _rigidbody.velocity = targetVelocity;\n    }\n    \n    private void HandleGravity()\n    {\n        if (!_isGrounded)\n        {\n            _verticalVelocity += _gravity * Time.fixedDeltaTime;\n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = _verticalVelocity;\n            _rigidbody.velocity = velocity;\n        }\n        else\n        {\n            _verticalVelocity = 0f;\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _groundCheckDistance, _groundLayer);\n        \n        if (_isGrounded && _verticalVelocity < 0)\n        {\n            _verticalVelocity = 0f;\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        float wheelSpeed = _currentSpeed * 50f;\n        _wheelRotation += wheelSpeed * Time.deltaTime;\n        \n        if (_frontWheel != null)\n        {\n            _frontWheel.localRotation = Quaternion.Euler(_wheelRotation, 0, 0);\n        }\n        \n        if (_backWheel != null)\n        {\n            _backWheel.localRotation = Quaternion.Euler(_wheelRotation, 0, 0);\n        }\n        \n        if (_pedals != null && Time.time - _lastPedalTime < _pedalCooldown * 2f)\n        {\n            _pedalRotation += 360f * Time.deltaTime;\n            _pedals.localRotation = Quaternion.Euler(0, 0, _pedalRotation);\n        }\n        \n        if (_handlebars != null)\n        {\n            float steerAngle = Input.GetAxis(\"Horizontal\") * 30f;\n            _handlebars.localRotation = Quaternion.Euler(0, steerAngle, 0);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _wheelSound != null)\n        {\n            if (_currentSpeed > 0.1f && _isGrounded)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _wheelSound;\n                    _audioSource.Play();\n                }\n                \n                _audioSource.pitch = Mathf.Lerp(0.5f, 2f, _currentSpeed / _maxSpeed);\n                _audioSource.volume = Mathf.Lerp(0.1f, 0.8f, _currentSpeed / _maxSpeed);\n            }\n            else\n            {\n                if (_audioSource.isPlaying && _audioSource.clip == _wheelSound)\n                {\n                    _audioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * _groundCheckDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(transform.position, transform.position + _moveDirection.normalized * 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "go-kart racing",
      "ideal_ir": {
        "class_name": "GoKartController",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 50
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 20
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 100
          },
          {
            "name": "brakeForce",
            "type": "float",
            "default": 30
          },
          {
            "name": "driftThreshold",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "enginePitch",
            "type": "float",
            "default": 1
          },
          {
            "name": "isGrounded",
            "type": "bool",
            "default": true
          },
          {
            "name": "currentLap",
            "type": "int",
            "default": 1
          },
          {
            "name": "checkpointsPassed",
            "type": "int",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "accelerate_forward",
            "trigger": "when forward input is pressed",
            "actions": [
              {
                "action": "increase forward velocity up to maximum speed"
              },
              {
                "action": "increase engine sound pitch based on current speed"
              },
              {
                "action": "create dust particles behind rear wheels"
              }
            ]
          },
          {
            "name": "brake_or_reverse",
            "trigger": "when brake input is pressed",
            "actions": [
              {
                "action": "apply braking force to reduce speed"
              },
              {
                "action": "if speed is very low then move backward slowly"
              },
              {
                "action": "create brake light effects"
              },
              {
                "action": "play tire screech sound if braking hard"
              }
            ]
          },
          {
            "name": "steer_left_right",
            "trigger": "when steering input is detected",
            "actions": [
              {
                "action": "rotate the kart in the steering direction"
              },
              {
                "action": "tilt the kart body slightly toward the turn"
              },
              {
                "action": "adjust wheel rotation to match steering angle"
              }
            ]
          },
          {
            "name": "drift_mechanics",
            "trigger": "when turning at high speed",
            "actions": [
              {
                "action": "reduce grip on rear wheels"
              },
              {
                "action": "create tire smoke effects"
              },
              {
                "action": "play drifting sound effects"
              },
              {
                "action": "slightly reduce speed during drift"
              }
            ]
          },
          {
            "name": "checkpoint_detection",
            "trigger": "when passing through a checkpoint",
            "actions": [
              {
                "action": "increment checkpoints passed counter"
              },
              {
                "action": "play checkpoint sound effect"
              },
              {
                "action": "display checkpoint notification"
              }
            ]
          },
          {
            "name": "lap_completion",
            "trigger": "when all checkpoints are passed and crossing finish line",
            "actions": [
              {
                "action": "increment current lap number"
              },
              {
                "action": "reset checkpoints passed to zero"
              },
              {
                "action": "record lap time"
              },
              {
                "action": "play lap completion sound"
              },
              {
                "action": "display lap time on screen"
              }
            ]
          },
          {
            "name": "collision_response",
            "trigger": "when colliding with walls or other karts",
            "actions": [
              {
                "action": "reduce speed based on collision force"
              },
              {
                "action": "bounce away from collision point"
              },
              {
                "action": "play collision sound effect"
              },
              {
                "action": "create impact particle effects"
              }
            ]
          },
          {
            "name": "airborne_handling",
            "trigger": "when kart leaves the ground",
            "actions": [
              {
                "action": "reduce steering effectiveness"
              },
              {
                "action": "maintain forward momentum"
              },
              {
                "action": "prepare for landing impact"
              }
            ]
          },
          {
            "name": "landing_impact",
            "trigger": "when kart touches ground after being airborne",
            "actions": [
              {
                "action": "restore normal steering control"
              },
              {
                "action": "create dust cloud on landing"
              },
              {
                "action": "play landing thud sound"
              },
              {
                "action": "briefly compress suspension visually"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class GoKartController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _motorForce = 1500f;\n    [SerializeField] private float _brakeForce = 3000f;\n    [SerializeField] private float _maxSteerAngle = 30f;\n    [SerializeField] private float _downForce = 100f;\n    \n    [Header(\"Wheel Colliders\")]\n    [SerializeField] private WheelCollider _frontLeftWheelCollider;\n    [SerializeField] private WheelCollider _frontRightWheelCollider;\n    [SerializeField] private WheelCollider _rearLeftWheelCollider;\n    [SerializeField] private WheelCollider _rearRightWheelCollider;\n    \n    [Header(\"Wheel Transforms\")]\n    [SerializeField] private Transform _frontLeftWheelTransform;\n    [SerializeField] private Transform _frontRightWheelTransform;\n    [SerializeField] private Transform _rearLeftWheelTransform;\n    [SerializeField] private Transform _rearRightWheelTransform;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _engineIdleClip;\n    [SerializeField] private AudioClip _engineRevClip;\n    [SerializeField] private float _minPitch = 0.8f;\n    [SerializeField] private float _maxPitch = 2.0f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _leftWheelSmoke;\n    [SerializeField] private ParticleSystem _rightWheelSmoke;\n    [SerializeField] private TrailRenderer _leftSkidTrail;\n    [SerializeField] private TrailRenderer _rightSkidTrail;\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _currentSteerAngle;\n    private float _currentBreakForce;\n    private bool _isBraking;\n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.centerOfMass = new Vector3(0, -0.5f, 0);\n        \n        if (_engineAudioSource != null && _engineIdleClip != null)\n        {\n            _engineAudioSource.clip = _engineIdleClip;\n            _engineAudioSource.loop = true;\n            _engineAudioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        GetInput();\n        HandleMotor();\n        HandleSteering();\n        UpdateWheelPoses();\n        UpdateAudio();\n        UpdateEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyDownForce();\n        _currentSpeed = _rigidbody.velocity.magnitude * 3.6f;\n    }\n    \n    private void GetInput()\n    {\n        _horizontalInput = Input.GetAxis(\"Horizontal\");\n        _verticalInput = Input.GetAxis(\"Vertical\");\n        _isBraking = Input.GetKey(KeyCode.Space);\n    }\n    \n    private void HandleMotor()\n    {\n        _frontLeftWheelCollider.motorTorque = _verticalInput * _motorForce;\n        _frontRightWheelCollider.motorTorque = _verticalInput * _motorForce;\n        \n        _currentBreakForce = _isBraking ? _brakeForce : 0f;\n        ApplyBraking();\n    }\n    \n    private void ApplyBraking()\n    {\n        _frontRightWheelCollider.brakeTorque = _currentBreakForce;\n        _frontLeftWheelCollider.brakeTorque = _currentBreakForce;\n        _rearLeftWheelCollider.brakeTorque = _currentBreakForce;\n        _rearRightWheelCollider.brakeTorque = _currentBreakForce;\n    }\n    \n    private void HandleSteering()\n    {\n        _currentSteerAngle = _maxSteerAngle * _horizontalInput;\n        _frontLeftWheelCollider.steerAngle = _currentSteerAngle;\n        _frontRightWheelCollider.steerAngle = _currentSteerAngle;\n    }\n    \n    private void UpdateWheelPoses()\n    {\n        UpdateWheelPose(_frontLeftWheelCollider, _frontLeftWheelTransform);\n        UpdateWheelPose(_frontRightWheelCollider, _frontRightWheelTransform);\n        UpdateWheelPose(_rearRightWheelCollider, _rearRightWheelTransform);\n        UpdateWheelPose(_rearLeftWheelCollider, _rearLeftWheelTransform);\n    }\n    \n    private void UpdateWheelPose(WheelCollider collider, Transform wheelTransform)\n    {\n        if (collider == null || wheelTransform == null) return;\n        \n        Vector3 pos;\n        Quaternion rot;\n        collider.GetWorldPose(out pos, out rot);\n        wheelTransform.position = pos;\n        wheelTransform.rotation = rot;\n    }\n    \n    private void ApplyDownForce()\n    {\n        _rigidbody.AddForce(-transform.up * _downForce * _rigidbody.velocity.magnitude);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_engineAudioSource == null) return;\n        \n        float speedRatio = Mathf.Clamp01(_currentSpeed / 100f);\n        _engineAudioSource.pitch = Mathf.Lerp(_minPitch, _maxPitch, speedRatio);\n        \n        if (Mathf.Abs(_verticalInput) > 0.1f && _engineRevClip != null)\n        {\n            if (_engineAudioSource.clip != _engineRevClip)\n            {\n                _engineAudioSource.clip = _engineRevClip;\n                _engineAudioSource.Play();\n            }\n        }\n        else if (_engineIdleClip != null)\n        {\n            if (_engineAudioSource.clip != _engineIdleClip)\n            {\n                _engineAudioSource.clip = _engineIdleClip;\n                _engineAudioSource.Play();\n            }\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        bool isSkidding = _isBraking && _currentSpeed > 10f;\n        \n        if (_leftWheelSmoke != null)\n        {\n            if (isSkidding && !_leftWheelSmoke.isPlaying)\n                _leftWheelSmoke.Play();\n            else if (!isSkidding && _leftWheelSmoke.isPlaying)\n                _leftWheelSmoke.Stop();\n        }\n        \n        if (_rightWheelSmoke != null)\n        {\n            if (isSkidding && !_rightWheelSmoke.isPlaying)\n                _rightWheelSmoke.Play();\n            else if (!isSkidding && _rightWheelSmoke.isPlaying)\n                _rightWheelSmoke.Stop();\n        }\n        \n        if (_leftSkidTrail != null)\n            _leftSkidTrail.emitting = isSkidding;\n            \n        if (_rightSkidTrail != null)\n            _rightSkidTrail.emitting = isSkidding;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsGrounded()\n    {\n        return _frontLeftWheelCollider.isGrounded || _frontRightWheelCollider.isGrounded ||\n               _rearLeftWheelCollider.isGrounded || _rearRightWheelCollider.isGrounded;\n    }\n}\n\npublic class RaceCheckpoint : MonoBehaviour\n{\n    [Header(\"Checkpoint Settings\")]\n    [SerializeField] private int _checkpointIndex;\n    [SerializeField] private bool _isFinishLine;\n    [SerializeField] private Material _activeMaterial;\n    [SerializeField] private Material _inactiveMaterial;\n    \n    private Renderer _renderer;\n    private bool _isActive = true;\n    \n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        UpdateVisual();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive) return;\n        \n        GoKartController kart = other.GetComponent<GoKartController>();\n        if (kart != null)\n        {\n            RaceManager raceManager = FindObjectOfType<RaceManager>();\n            if (raceManager != null)\n            {\n                raceManager.CheckpointReached(_checkpointIndex, _isFinishLine, kart);\n            }\n            \n            _isActive = false;\n            UpdateVisual();\n        }\n    }\n    \n    public void ResetCheckpoint()\n    {\n        _isActive = true;\n        UpdateVisual();\n    }\n    \n    private void UpdateVisual()\n    {\n        if (_renderer != null)\n        {\n            _renderer.material = _isActive ? _activeMaterial : _inactiveMaterial;\n        }\n    }\n}\n\npublic class RaceManager : MonoBehaviour\n{\n    [Header(\"Race Settings\")]\n    [SerializeField] private int _totalLaps = 3;\n    [SerializeField] private int _totalCheckpoints = 5;\n    [SerializeField] private Text _lapText;\n    [SerializeField] private Text _timeText;\n    [SerializeField] private Text _speedText;\n    [SerializeField] private GameObject _raceCompletePanel;\n    \n    private int _currentLap = 1;\n    private int _currentCheckpoint = 0;\n    private float _raceTime = 0f;\n    private bool _raceActive = true;\n    private GoKartController _playerKart;\n    private RaceCheckpoint[] _checkpoints;\n    \n    private void Start()\n    {\n        _playerKart = FindObjectOfType<GoKartController>();\n        _checkpoints = FindObjectsOfType<RaceCheckpoint>();\n        \n        if (_raceCompletePanel != null)\n            _raceCompletePanel.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_raceActive)\n        {\n            _raceTime += Time.deltaTime;\n            UpdateUI();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            RestartRace();\n        }\n    }\n    \n    public void CheckpointReached(int checkpointIndex, bool isFinishLine, GoKartController kart)\n    {\n        if (!_raceActive || kart != _playerKart) return;\n        \n        if (checkpointIndex == _currentCheckpoint)\n        {\n            _currentCheckpoint++;\n            \n            if (isFinishLine)\n            {\n                if (_currentLap >= _totalLaps)\n                {\n                    CompleteRace();\n                }\n                else\n                {\n                    _currentLap++;\n                    _currentCheckpoint = 0;\n                    ResetCheckpoints();\n                }\n            }\n        }\n    }\n    \n    private void CompleteRace()\n    {\n        _raceActive = false;\n        if (_raceCompletePanel != null)\n        {\n            _raceCompletePanel.SetActive(true);\n        }\n        \n        Debug.Log($\"Race Complete! Time: {FormatTime(_raceTime)}\");\n    }\n    \n    private void RestartRace()\n    {\n        _currentLap = 1;\n        _currentCheckpoint = 0;\n        _raceTime = 0f;\n        _raceActive = true;\n        \n        if (_raceCompletePanel != null)\n            _raceCompletePanel.SetActive(false);\n            \n        ResetCheckpoints();\n    }\n    \n    private void ResetCheckpoints()\n    {\n        foreach (RaceCheckpoint checkpoint in _checkpoints)\n        {\n            if (checkpoint != null)\n                checkpoint.ResetCheckpoint();\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_lapText != null)\n            _lapText.text = $\"Lap: {_currentLap}/{_totalLaps}\";\n            \n        if (_timeText != null)\n            _timeText.text = $\"Time: {FormatTime(_raceTime)}\";\n            \n        if (_speedText != null && _playerKart != null)\n            _speedText.text = $\"Speed: {_playerKart.GetCurrentSpeed():F0} km/h\";\n    }\n    \n    private string FormatTime(float time)\n    {\n        int minutes = Mathf.FloorToInt(time / 60f);\n        int seconds = Mathf.FloorToInt(time % 60f);\n        int milliseconds = Mathf.FloorToInt((time * 100f) % 100f);\n        return $\"{minutes:00}:{seconds:00}:{milliseconds:00}\";\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fighter jet with missiles",
      "ideal_ir": {
        "class_name": "FighterJet",
        "components": [
          "Rigidbody",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 500
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 100
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 90
          },
          {
            "name": "missileCount",
            "type": "int",
            "default": 6
          },
          {
            "name": "maxMissileCount",
            "type": "int",
            "default": 6
          },
          {
            "name": "lockOnRange",
            "type": "float",
            "default": 1000
          },
          {
            "name": "health",
            "type": "float",
            "default": 100
          },
          {
            "name": "fuel",
            "type": "float",
            "default": 100
          },
          {
            "name": "isEngineOn",
            "type": "bool",
            "default": true
          },
          {
            "name": "hasTarget",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "accelerate_forward",
            "trigger": "when thrust input is pressed",
            "actions": [
              {
                "action": "increase forward velocity up to maximum speed"
              },
              {
                "action": "play engine sound at higher pitch"
              },
              {
                "action": "emit exhaust particles from engine"
              }
            ]
          },
          {
            "name": "turn_aircraft",
            "trigger": "when steering input is detected",
            "actions": [
              {
                "action": "rotate aircraft around vertical axis based on input direction"
              },
              {
                "action": "bank aircraft left or right for realistic turning"
              },
              {
                "action": "adjust engine sound based on turn intensity"
              }
            ]
          },
          {
            "name": "lock_onto_target",
            "trigger": "when enemy aircraft enters lock on range",
            "actions": [
              {
                "action": "mark enemy as current target"
              },
              {
                "action": "play target lock sound"
              },
              {
                "action": "display targeting reticle on enemy"
              },
              {
                "action": "set has target to true"
              }
            ]
          },
          {
            "name": "fire_missile",
            "trigger": "when fire button is pressed and target is locked and missiles remain",
            "actions": [
              {
                "action": "spawn missile at missile mount point"
              },
              {
                "action": "set missile target to current locked target"
              },
              {
                "action": "launch missile toward target"
              },
              {
                "action": "reduce missile count by one"
              },
              {
                "action": "play missile launch sound"
              }
            ]
          },
          {
            "name": "lose_target_lock",
            "trigger": "when target moves beyond lock on range or is destroyed",
            "actions": [
              {
                "action": "clear current target"
              },
              {
                "action": "hide targeting reticle"
              },
              {
                "action": "set has target to false"
              },
              {
                "action": "play lock lost sound"
              }
            ]
          },
          {
            "name": "take_damage",
            "trigger": "when hit by enemy fire or collision occurs",
            "actions": [
              {
                "action": "reduce health by damage amount"
              },
              {
                "action": "play damage sound effect"
              },
              {
                "action": "emit smoke particles from damaged area"
              },
              {
                "action": "shake aircraft briefly"
              }
            ]
          },
          {
            "name": "aircraft_destroyed",
            "trigger": "when health reaches zero",
            "actions": [
              {
                "action": "play explosion sound"
              },
              {
                "action": "create large explosion particle effect"
              },
              {
                "action": "disable aircraft controls"
              },
              {
                "action": "begin falling toward ground"
              },
              {
                "action": "spawn debris pieces"
              }
            ]
          },
          {
            "name": "consume_fuel",
            "trigger": "when engine is running",
            "actions": [
              {
                "action": "gradually decrease fuel over time"
              },
              {
                "action": "reduce engine power when fuel is low"
              },
              {
                "action": "play low fuel warning when fuel is critically low"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FighterJet : MonoBehaviour\n{\n    [Header(\"Flight Controls\")]\n    [SerializeField] private float _thrustForce = 1500f;\n    [SerializeField] private float _pitchTorque = 1000f;\n    [SerializeField] private float _yawTorque = 800f;\n    [SerializeField] private float _rollTorque = 600f;\n    [SerializeField] private float _maxSpeed = 200f;\n    [SerializeField] private float _liftForce = 800f;\n    \n    [Header(\"Missile System\")]\n    [SerializeField] private GameObject _missilePrefab;\n    [SerializeField] private Transform[] _missileSpawnPoints;\n    [SerializeField] private int _maxMissiles = 8;\n    [SerializeField] private float _missileFireRate = 0.5f;\n    [SerializeField] private float _missileSpeed = 300f;\n    [SerializeField] private float _missileLifetime = 10f;\n    [SerializeField] private float _targetingRange = 500f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _missileFireSound;\n    [SerializeField] private AudioClip _engineSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem[] _engineTrails;\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    \n    private Rigidbody _rigidbody;\n    private int _currentMissileCount;\n    private float _lastMissileFireTime;\n    private int _currentSpawnPointIndex;\n    private Transform _currentTarget;\n    private List<GameObject> _activeMissiles = new List<GameObject>();\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = 1000f;\n        _rigidbody.drag = 0.1f;\n        _rigidbody.angularDrag = 5f;\n        \n        _currentMissileCount = _maxMissiles;\n        \n        if (_engineAudioSource != null && _engineSound != null)\n        {\n            _engineAudioSource.clip = _engineSound;\n            _engineAudioSource.loop = true;\n            _engineAudioSource.Play();\n        }\n        \n        SetupEngineTrails();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateEngineAudio();\n        FindTarget();\n        CleanupMissiles();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyThrust();\n        ApplyLift();\n        ApplyRotation();\n        LimitSpeed();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0))\n        {\n            FireMissile();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            ReloadMissiles();\n        }\n    }\n    \n    private void ApplyThrust()\n    {\n        float thrust = Input.GetAxis(\"Vertical\");\n        Vector3 thrustVector = transform.forward * thrust * _thrustForce;\n        _rigidbody.AddForce(thrustVector);\n    }\n    \n    private void ApplyLift()\n    {\n        float speed = Vector3.Dot(_rigidbody.velocity, transform.forward);\n        float liftAmount = speed * speed * 0.001f * _liftForce;\n        Vector3 liftVector = transform.up * liftAmount;\n        _rigidbody.AddForce(liftVector);\n    }\n    \n    private void ApplyRotation()\n    {\n        float pitch = -Input.GetAxis(\"Vertical\") * _pitchTorque;\n        float yaw = Input.GetAxis(\"Horizontal\") * _yawTorque;\n        float roll = -Input.GetAxis(\"Horizontal\") * _rollTorque;\n        \n        _rigidbody.AddTorque(transform.right * pitch);\n        _rigidbody.AddTorque(transform.up * yaw);\n        _rigidbody.AddTorque(transform.forward * roll);\n    }\n    \n    private void LimitSpeed()\n    {\n        if (_rigidbody.velocity.magnitude > _maxSpeed)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n        }\n    }\n    \n    private void FireMissile()\n    {\n        if (_currentMissileCount <= 0 || Time.time - _lastMissileFireTime < _missileFireRate)\n            return;\n        \n        if (_missilePrefab == null || _missileSpawnPoints == null || _missileSpawnPoints.Length == 0)\n            return;\n        \n        Transform spawnPoint = _missileSpawnPoints[_currentSpawnPointIndex];\n        GameObject missile = Instantiate(_missilePrefab, spawnPoint.position, spawnPoint.rotation);\n        \n        Missile missileScript = missile.GetComponent<Missile>();\n        if (missileScript == null)\n        {\n            missileScript = missile.AddComponent<Missile>();\n        }\n        \n        missileScript.Initialize(_missileSpeed, _missileLifetime, _currentTarget);\n        _activeMissiles.Add(missile);\n        \n        _currentMissileCount--;\n        _lastMissileFireTime = Time.time;\n        _currentSpawnPointIndex = (_currentSpawnPointIndex + 1) % _missileSpawnPoints.Length;\n        \n        PlayMissileFireEffects();\n    }\n    \n    private void PlayMissileFireEffects()\n    {\n        if (_missileFireSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_missileFireSound, transform.position);\n        }\n        \n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _targetingRange, _targetLayerMask);\n        float closestDistance = float.MaxValue;\n        Transform closestTarget = null;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = target.transform;\n            }\n        }\n        \n        _currentTarget = closestTarget;\n    }\n    \n    private void ReloadMissiles()\n    {\n        _currentMissileCount = _maxMissiles;\n    }\n    \n    private void UpdateEngineAudio()\n    {\n        if (_engineAudioSource != null)\n        {\n            float throttle = Mathf.Abs(Input.GetAxis(\"Vertical\"));\n            _engineAudioSource.pitch = Mathf.Lerp(0.5f, 2f, throttle);\n            _engineAudioSource.volume = Mathf.Lerp(0.3f, 1f, throttle);\n        }\n    }\n    \n    private void SetupEngineTrails()\n    {\n        if (_engineTrails != null)\n        {\n            foreach (ParticleSystem trail in _engineTrails)\n            {\n                if (trail != null)\n                {\n                    var emission = trail.emission;\n                    emission.enabled = true;\n                }\n            }\n        }\n    }\n    \n    private void CleanupMissiles()\n    {\n        _activeMissiles.RemoveAll(missile => missile == null);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _targetingRange);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}\n\npublic class Missile : MonoBehaviour\n{\n    private float _speed;\n    private float _lifetime;\n    private Transform _target;\n    private Rigidbody _rigidbody;\n    private float _spawnTime;\n    private bool _isInitialized;\n    \n    [SerializeField] private float _turnRate = 180f;\n    [SerializeField] private float _explosionRadius = 10f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _spawnTime = Time.time;\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider == null)\n        {\n            collider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)collider).radius = 0.5f;\n        }\n        collider.isTrigger = true;\n    }\n    \n    public void Initialize(float speed, float lifetime, Transform target)\n    {\n        _speed = speed;\n        _lifetime = lifetime;\n        _target = target;\n        _isInitialized = true;\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        if (Time.time - _spawnTime > _lifetime)\n        {\n            Explode();\n            return;\n        }\n        \n        MoveTowardsTarget();\n    }\n    \n    private void MoveTowardsTarget()\n    {\n        Vector3 direction;\n        \n        if (_target != null)\n        {\n            direction = (_target.position - transform.position).normalized;\n            Vector3 targetDirection = Vector3.RotateTowards(transform.forward, direction, _turnRate * Mathf.Deg2Rad * Time.deltaTime, 0f);\n            transform.rotation = Quaternion.LookRotation(targetDirection);\n        }\n        \n        _rigidbody.velocity = transform.forward * _speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.transform.parent != null && other.transform.parent.GetComponent<FighterJet>() != null)\n            return;\n        \n        Explode();\n    }\n    \n    private void Explode()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n        }\n        \n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_explosionSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "submarine underwater",
      "ideal_ir": {
        "class_name": "Submarine",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 5
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 30
          },
          {
            "name": "maxDepth",
            "type": "float",
            "default": 100
          },
          {
            "name": "buoyancyForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "enginePower",
            "type": "float",
            "default": 1000
          },
          {
            "name": "isEngineRunning",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentDepth",
            "type": "float",
            "default": 0
          },
          {
            "name": "oxygenLevel",
            "type": "float",
            "default": 100
          }
        ],
        "behaviors": [
          {
            "name": "engine_control",
            "trigger": "when engine start input is pressed",
            "actions": [
              {
                "action": "toggle engine running state"
              },
              {
                "action": "play engine startup sound"
              }
            ]
          },
          {
            "name": "forward_movement",
            "trigger": "when forward input is held and engine is running",
            "actions": [
              {
                "action": "apply forward thrust based on engine power"
              },
              {
                "action": "increase speed up to maximum speed limit"
              }
            ]
          },
          {
            "name": "steering",
            "trigger": "when horizontal input is detected",
            "actions": [
              {
                "action": "rotate submarine left or right based on input direction"
              },
              {
                "action": "apply turning force at specified turn speed"
              }
            ]
          },
          {
            "name": "dive_control",
            "trigger": "when dive input is pressed",
            "actions": [
              {
                "action": "reduce buoyancy to sink deeper"
              },
              {
                "action": "limit descent to maximum depth"
              }
            ]
          },
          {
            "name": "surface_control",
            "trigger": "when surface input is pressed",
            "actions": [
              {
                "action": "increase buoyancy to rise upward"
              },
              {
                "action": "prevent rising above water surface"
              }
            ]
          },
          {
            "name": "depth_tracking",
            "trigger": "continuously while underwater",
            "actions": [
              {
                "action": "update current depth based on position"
              },
              {
                "action": "apply water pressure effects at greater depths"
              }
            ]
          },
          {
            "name": "oxygen_consumption",
            "trigger": "continuously while submerged",
            "actions": [
              {
                "action": "gradually decrease oxygen level over time"
              },
              {
                "action": "increase consumption rate when engine is running"
              }
            ]
          },
          {
            "name": "emergency_surface",
            "trigger": "when oxygen level drops below critical threshold",
            "actions": [
              {
                "action": "automatically increase buoyancy to emergency surface"
              },
              {
                "action": "play warning alarm sound"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SubmarineController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _forwardSpeed = 10f;\n    [SerializeField] private float _rotationSpeed = 50f;\n    [SerializeField] private float _verticalSpeed = 5f;\n    [SerializeField] private float _maxDepth = -50f;\n    [SerializeField] private float _minDepth = -2f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _buoyancyForce = 100f;\n    [SerializeField] private float _waterDrag = 2f;\n    [SerializeField] private float _waterAngularDrag = 5f;\n    \n    [Header(\"Ballast System\")]\n    [SerializeField] private float _ballastFillRate = 2f;\n    [SerializeField] private float _ballastEmptyRate = 3f;\n    [SerializeField] private float _maxBallastWeight = 500f;\n    \n    [Header(\"Sonar\")]\n    [SerializeField] private float _sonarRange = 100f;\n    [SerializeField] private LayerMask _sonarLayerMask = -1;\n    [SerializeField] private AudioSource _sonarAudioSource;\n    [SerializeField] private AudioClip _sonarPingSound;\n    \n    [Header(\"Lights\")]\n    [SerializeField] private Light[] _submarineLights;\n    [SerializeField] private float _lightIntensityAtSurface = 0.5f;\n    [SerializeField] private float _lightIntensityAtDepth = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _propellerEffect;\n    [SerializeField] private Transform _propellerTransform;\n    [SerializeField] private float _propellerRotationSpeed = 360f;\n    \n    private Rigidbody _rigidbody;\n    private float _currentBallastWeight = 0f;\n    private float _waterSurfaceY = 0f;\n    private bool _isSubmerged = false;\n    private float _currentDepth = 0f;\n    private float _sonarCooldown = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        SetupUnderwaterPhysics();\n        InitializeLights();\n        InitializeEffects();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateDepth();\n        UpdateLighting();\n        UpdateEffects();\n        UpdateSonar();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyMovement();\n        ApplyBallastSystem();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        float dive = 0f;\n        \n        if (Input.GetKey(KeyCode.Q)) dive = 1f;\n        if (Input.GetKey(KeyCode.E)) dive = -1f;\n        \n        // Store input for FixedUpdate\n        _horizontalInput = horizontal;\n        _verticalInput = vertical;\n        _diveInput = dive;\n        \n        // Ballast controls\n        if (Input.GetKey(KeyCode.F))\n        {\n            FillBallast();\n        }\n        else if (Input.GetKey(KeyCode.R))\n        {\n            EmptyBallast();\n        }\n        \n        // Sonar\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            TriggerSonar();\n        }\n        \n        // Lights toggle\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            ToggleLights();\n        }\n    }\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _diveInput;\n    \n    private void ApplyMovement()\n    {\n        // Forward/backward movement\n        Vector3 forwardForce = transform.forward * _verticalInput * _forwardSpeed;\n        _rigidbody.AddForce(forwardForce);\n        \n        // Rotation\n        float torque = _horizontalInput * _rotationSpeed;\n        _rigidbody.AddTorque(0, torque, 0);\n        \n        // Vertical movement (diving/surfacing)\n        Vector3 verticalForce = Vector3.up * _diveInput * _verticalSpeed;\n        _rigidbody.AddForce(verticalForce);\n        \n        // Clamp depth\n        Vector3 position = transform.position;\n        position.y = Mathf.Clamp(position.y, _maxDepth, _minDepth);\n        transform.position = position;\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isSubmerged)\n        {\n            float buoyancyAdjustment = _buoyancyForce - _currentBallastWeight;\n            _rigidbody.AddForce(Vector3.up * buoyancyAdjustment);\n        }\n    }\n    \n    private void ApplyBallastSystem()\n    {\n        // Natural ballast adjustment based on depth\n        float depthRatio = Mathf.Abs(_currentDepth) / Mathf.Abs(_maxDepth);\n        float targetBallast = depthRatio * _maxBallastWeight * 0.3f;\n        \n        if (_currentBallastWeight < targetBallast)\n        {\n            _currentBallastWeight += _ballastFillRate * Time.fixedDeltaTime;\n        }\n        else if (_currentBallastWeight > targetBallast)\n        {\n            _currentBallastWeight -= _ballastEmptyRate * Time.fixedDeltaTime;\n        }\n        \n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void FillBallast()\n    {\n        _currentBallastWeight += _ballastFillRate * Time.deltaTime;\n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void EmptyBallast()\n    {\n        _currentBallastWeight -= _ballastEmptyRate * Time.deltaTime;\n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void SetupUnderwaterPhysics()\n    {\n        _rigidbody.drag = _waterDrag;\n        _rigidbody.angularDrag = _waterAngularDrag;\n        _rigidbody.useGravity = true;\n    }\n    \n    private void UpdateDepth()\n    {\n        _currentDepth = transform.position.y - _waterSurfaceY;\n        _isSubmerged = _currentDepth < 0f;\n    }\n    \n    private void InitializeLights()\n    {\n        if (_submarineLights == null || _submarineLights.Length == 0)\n        {\n            _submarineLights = GetComponentsInChildren<Light>();\n        }\n    }\n    \n    private void UpdateLighting()\n    {\n        if (_submarineLights == null) return;\n        \n        float depthRatio = Mathf.Abs(_currentDepth) / Mathf.Abs(_maxDepth);\n        float targetIntensity = Mathf.Lerp(_lightIntensityAtSurface, _lightIntensityAtDepth, depthRatio);\n        \n        foreach (Light light in _submarineLights)\n        {\n            if (light != null)\n            {\n                light.intensity = targetIntensity;\n            }\n        }\n    }\n    \n    private void ToggleLights()\n    {\n        if (_submarineLights == null) return;\n        \n        foreach (Light light in _submarineLights)\n        {\n            if (light != null)\n            {\n                light.enabled = !light.enabled;\n            }\n        }\n    }\n    \n    private void InitializeEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            var emission = _bubbleEffect.emission;\n            emission.enabled = false;\n        }\n        \n        if (_propellerEffect != null)\n        {\n            var emission = _propellerEffect.emission;\n            emission.enabled = false;\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        UpdateBubbleEffect();\n        UpdatePropellerEffect();\n        UpdatePropellerRotation();\n    }\n    \n    private void UpdateBubbleEffect()\n    {\n        if (_bubbleEffect == null) return;\n        \n        var emission = _bubbleEffect.emission;\n        bool shouldEmit = _isSubmerged && (_diveInput != 0f || _rigidbody.velocity.magnitude > 1f);\n        emission.enabled = shouldEmit;\n        \n        if (shouldEmit)\n        {\n            emission.rateOverTime = Mathf.Abs(_currentDepth) * 2f;\n        }\n    }\n    \n    private void UpdatePropellerEffect()\n    {\n        if (_propellerEffect == null) return;\n        \n        var emission = _propellerEffect.emission;\n        bool shouldEmit = Mathf.Abs(_verticalInput) > 0.1f;\n        emission.enabled = shouldEmit;\n        \n        if (shouldEmit)\n        {\n            emission.rateOverTime = Mathf.Abs(_verticalInput) * 50f;\n        }\n    }\n    \n    private void UpdatePropellerRotation()\n    {\n        if (_propellerTransform == null) return;\n        \n        float rotationAmount = _verticalInput * _propellerRotationSpeed * Time.deltaTime;\n        _propellerTransform.Rotate(0, 0, rotationAmount);\n    }\n    \n    private void UpdateSonar()\n    {\n        if (_sonarCooldown > 0f)\n        {\n            _sonarCooldown -= Time.deltaTime;\n        }\n    }\n    \n    private void TriggerSonar()\n    {\n        if (_sonarCooldown > 0f) return;\n        \n        _sonarCooldown = 2f;\n        \n        if (_sonarAudioSource != null && _sonarPingSound != null)\n        {\n            _sonarAudioSource.PlayOneShot(_sonarPingSound);\n        }\n        \n        // Detect objects in range\n        Collider[] detectedObjects = Physics.OverlapSphere(transform.position, _sonarRange, _sonarLayerMask);\n        \n        foreach (Collider col in detectedObjects)\n        {\n            if (col.gameObject != gameObject)\n            {\n                Debug.Log($\"Sonar detected: {col.name} at distance {Vector3.Distance(transform.position, col.transform.position):F1}m\");\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Debug.Log(\"Player entered submarine trigger zone\");\n        }\n        \n        if (other.name.Contains(\"Fish\") || other.CompareTag(\"Fish\"))\n        {\n            Debug.Log(\"Fish detected near submarine\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw sonar range\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _sonarRange);\n        \n        // Draw depth limits\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(new Vector3(transform.position.x - 5f, _maxDepth, transform.position.z),\n                       new Vector3(transform.position.x + 5f, _maxDepth, transform.position.z));\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawLine(new Vector3(transform.position.x - 5f, _minDepth, transform.position.z),\n                       new Vector3(transform.position.x + 5f, _minDepth, transform.position.z));\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "hoverboard floating",
      "ideal_ir": {
        "class_name": "HoverboardFloating",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "hoverHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "hoverForce",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "stabilityForce",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "maxFloatDistance",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "maintain_hover_height",
            "trigger": "when ground is detected below the hoverboard",
            "actions": [
              {
                "action": "apply upward force to maintain desired hover height above ground"
              },
              {
                "action": "adjust force strength based on distance from ground"
              }
            ]
          },
          {
            "name": "stabilize_rotation",
            "trigger": "when hoverboard tilts or rotates",
            "actions": [
              {
                "action": "apply counter-torque to keep hoverboard level"
              },
              {
                "action": "dampen rotational movement for stability"
              }
            ]
          },
          {
            "name": "ground_following",
            "trigger": "when terrain height changes below hoverboard",
            "actions": [
              {
                "action": "adjust hover height to follow ground contours"
              },
              {
                "action": "maintain smooth floating motion over uneven surfaces"
              }
            ]
          },
          {
            "name": "fall_when_too_high",
            "trigger": "when no ground is detected within maximum float distance",
            "actions": [
              {
                "action": "reduce hover force gradually"
              },
              {
                "action": "allow hoverboard to descend under gravity"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class HoverboardController : MonoBehaviour\n{\n    [Header(\"Hover Settings\")]\n    [SerializeField] private float _hoverHeight = 1.5f;\n    [SerializeField] private float _hoverForce = 300f;\n    [SerializeField] private float _hoverDamping = 50f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 10f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    \n    [Header(\"Tilt Effects\")]\n    [SerializeField] private float _maxTiltAngle = 15f;\n    [SerializeField] private float _tiltSpeed = 3f;\n    \n    [Header(\"Hover Points\")]\n    [SerializeField] private Transform[] _hoverPoints;\n    \n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private Vector3 _moveInput;\n    private float _turnInput;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.centerOfMass = Vector3.down * 0.5f;\n        \n        if (_hoverPoints == null || _hoverPoints.Length == 0)\n        {\n            CreateDefaultHoverPoints();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        ApplyTiltEffect();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyHoverForce();\n        ApplyMovement();\n        ApplyTurning();\n    }\n    \n    private void HandleInput()\n    {\n        _moveInput.x = Input.GetAxis(\"Horizontal\");\n        _moveInput.z = Input.GetAxis(\"Vertical\");\n        _turnInput = Input.GetAxis(\"Horizontal\");\n    }\n    \n    private void ApplyHoverForce()\n    {\n        foreach (Transform hoverPoint in _hoverPoints)\n        {\n            if (hoverPoint == null) continue;\n            \n            RaycastHit hit;\n            Vector3 rayStart = hoverPoint.position;\n            Vector3 rayDirection = -hoverPoint.up;\n            \n            if (Physics.Raycast(rayStart, rayDirection, out hit, _hoverHeight * 2f, _groundLayer))\n            {\n                float distance = hit.distance;\n                float hoverRatio = (_hoverHeight - distance) / _hoverHeight;\n                \n                if (hoverRatio > 0)\n                {\n                    Vector3 force = hoverPoint.up * _hoverForce * hoverRatio;\n                    Vector3 velocity = _rigidbody.GetPointVelocity(hoverPoint.position);\n                    float dampingForce = Vector3.Dot(velocity, hoverPoint.up) * _hoverDamping;\n                    \n                    _rigidbody.AddForceAtPosition(force - hoverPoint.up * dampingForce, hoverPoint.position);\n                }\n            }\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 worldMoveInput = transform.TransformDirection(_moveInput);\n        worldMoveInput.y = 0;\n        \n        if (_moveInput.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, _moveSpeed, _acceleration * Time.fixedDeltaTime);\n        }\n        else\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0, _deceleration * Time.fixedDeltaTime);\n        }\n        \n        Vector3 targetVelocity = worldMoveInput.normalized * _currentSpeed;\n        Vector3 velocityChange = targetVelocity - new Vector3(_rigidbody.velocity.x, 0, _rigidbody.velocity.z);\n        \n        _rigidbody.AddForce(velocityChange, ForceMode.VelocityChange);\n    }\n    \n    private void ApplyTurning()\n    {\n        if (Mathf.Abs(_turnInput) > 0.1f)\n        {\n            float torque = _turnInput * _turnSpeed * Time.fixedDeltaTime;\n            _rigidbody.AddTorque(transform.up * torque);\n        }\n    }\n    \n    private void ApplyTiltEffect()\n    {\n        float forwardTilt = -_moveInput.z * _maxTiltAngle;\n        float sideTilt = _moveInput.x * _maxTiltAngle;\n        \n        Quaternion targetRotation = Quaternion.Euler(forwardTilt, transform.eulerAngles.y, sideTilt);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _tiltSpeed * Time.deltaTime);\n    }\n    \n    private void CreateDefaultHoverPoints()\n    {\n        _hoverPoints = new Transform[4];\n        \n        Vector3[] positions = {\n            new Vector3(-0.5f, 0, 0.5f),   // Front Left\n            new Vector3(0.5f, 0, 0.5f),    // Front Right\n            new Vector3(-0.5f, 0, -0.5f),  // Back Left\n            new Vector3(0.5f, 0, -0.5f)    // Back Right\n        };\n        \n        for (int i = 0; i < positions.Length; i++)\n        {\n            GameObject hoverPoint = new GameObject($\"HoverPoint_{i}\");\n            hoverPoint.transform.SetParent(transform);\n            hoverPoint.transform.localPosition = positions[i];\n            _hoverPoints[i] = hoverPoint.transform;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_hoverPoints == null) return;\n        \n        Gizmos.color = Color.blue;\n        foreach (Transform hoverPoint in _hoverPoints)\n        {\n            if (hoverPoint == null) continue;\n            \n            Vector3 start = hoverPoint.position;\n            Vector3 end = start - hoverPoint.up * _hoverHeight * 2f;\n            \n            Gizmos.DrawLine(start, end);\n            Gizmos.DrawWireSphere(start - hoverPoint.up * _hoverHeight, 0.1f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "dragon mount flying",
      "ideal_ir": {
        "class_name": "DragonMount",
        "components": [
          "Rigidbody",
          "Collider",
          "Animator"
        ],
        "fields": [
          {
            "name": "flySpeed",
            "type": "float",
            "default": 15
          },
          {
            "name": "turnSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "ascendSpeed",
            "type": "float",
            "default": 8
          },
          {
            "name": "descendSpeed",
            "type": "float",
            "default": 6
          },
          {
            "name": "maxAltitude",
            "type": "float",
            "default": 100
          },
          {
            "name": "minAltitude",
            "type": "float",
            "default": 5
          },
          {
            "name": "wingFlapForce",
            "type": "float",
            "default": 20
          },
          {
            "name": "isFlying",
            "type": "bool",
            "default": false
          },
          {
            "name": "hasRider",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_flying",
            "trigger": "when rider mounts and presses fly button",
            "actions": [
              {
                "action": "set flying state to true"
              },
              {
                "action": "play wing flap animation"
              },
              {
                "action": "apply upward force to lift off ground"
              },
              {
                "action": "enable aerial movement controls"
              }
            ]
          },
          {
            "name": "aerial_movement",
            "trigger": "when flying and receiving movement input",
            "actions": [
              {
                "action": "move forward at fly speed based on input direction"
              },
              {
                "action": "rotate smoothly toward input direction at turn speed"
              },
              {
                "action": "tilt body to show banking during turns"
              },
              {
                "action": "adjust wing flap animation speed based on movement"
              }
            ]
          },
          {
            "name": "altitude_control",
            "trigger": "when flying and receiving vertical input",
            "actions": [
              {
                "action": "ascend at ascend speed when climb input detected"
              },
              {
                "action": "descend at descend speed when dive input detected"
              },
              {
                "action": "limit altitude between minimum and maximum values"
              },
              {
                "action": "play appropriate climbing or diving animations"
              }
            ]
          },
          {
            "name": "maintain_flight",
            "trigger": "when flying without input",
            "actions": [
              {
                "action": "maintain current altitude with gentle hovering"
              },
              {
                "action": "play idle flying animation with wing beats"
              },
              {
                "action": "apply small random movements for natural flight feel"
              },
              {
                "action": "gradually reduce speed if no forward input"
              }
            ]
          },
          {
            "name": "landing",
            "trigger": "when flying near ground and landing input received",
            "actions": [
              {
                "action": "gradually reduce altitude toward ground"
              },
              {
                "action": "slow horizontal movement for controlled descent"
              },
              {
                "action": "play landing animation when close to surface"
              },
              {
                "action": "set flying state to false when touching ground"
              },
              {
                "action": "transition to ground movement mode"
              }
            ]
          },
          {
            "name": "dismount_in_air",
            "trigger": "when rider dismounts while flying",
            "actions": [
              {
                "action": "eject rider safely with parachute or gliding ability"
              },
              {
                "action": "continue flying in autonomous mode"
              },
              {
                "action": "set has rider state to false"
              },
              {
                "action": "fly in circles or return to designated perch"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DragonMount : MonoBehaviour\n{\n    [Header(\"Flight Settings\")]\n    [SerializeField] private float _flySpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _maxAltitude = 100f;\n    [SerializeField] private float _minAltitude = 2f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _pitchSpeed = 60f;\n    [SerializeField] private float _yawSpeed = 90f;\n    [SerializeField] private float _rollSpeed = 45f;\n    [SerializeField] private float _maxPitchAngle = 45f;\n    [SerializeField] private float _maxRollAngle = 30f;\n    \n    [Header(\"Wing Animation\")]\n    [SerializeField] private Transform _leftWing;\n    [SerializeField] private Transform _rightWing;\n    [SerializeField] private float _wingFlapSpeed = 3f;\n    [SerializeField] private float _wingFlapAngle = 20f;\n    \n    [Header(\"Rider Settings\")]\n    [SerializeField] private Transform _riderSeat;\n    [SerializeField] private float _mountRange = 3f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    [SerializeField] private KeyCode _dismountKey = KeyCode.Q;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _wingFlapSound;\n    [SerializeField] private AudioClip _roarSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerMounted;\n    public UnityEvent OnPlayerDismounted;\n    public UnityEvent OnTakeOff;\n    public UnityEvent OnLanding;\n    \n    private Rigidbody _rigidbody;\n    private Transform _rider;\n    private Vector3 _currentVelocity;\n    private float _currentSpeed;\n    private float _wingFlapTimer;\n    private bool _isGrounded = true;\n    private bool _hasRider = false;\n    private Vector3 _originalRiderPosition;\n    private Quaternion _originalRiderRotation;\n    private CharacterController _riderController;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.spatialBlend = 1f;\n        _audioSource.volume = 0.7f;\n    }\n    \n    private void Update()\n    {\n        CheckForRiderInput();\n        \n        if (_hasRider)\n        {\n            HandleFlightInput();\n            AnimateWings();\n            PlayFlightSounds();\n        }\n        else\n        {\n            HandleIdleBehavior();\n        }\n        \n        CheckGroundStatus();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_hasRider)\n        {\n            ApplyFlightPhysics();\n        }\n        else\n        {\n            ApplyIdlePhysics();\n        }\n    }\n    \n    private void CheckForRiderInput()\n    {\n        if (!_hasRider)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null && Vector3.Distance(transform.position, player.transform.position) <= _mountRange)\n            {\n                if (Input.GetKeyDown(_mountKey))\n                {\n                    MountPlayer(player.transform);\n                }\n            }\n        }\n        else\n        {\n            if (Input.GetKeyDown(_dismountKey))\n            {\n                DismountPlayer();\n            }\n        }\n    }\n    \n    private void MountPlayer(Transform player)\n    {\n        _rider = player;\n        _hasRider = true;\n        \n        _originalRiderPosition = player.position;\n        _originalRiderRotation = player.rotation;\n        \n        _riderController = player.GetComponent<CharacterController>();\n        if (_riderController != null)\n        {\n            _riderController.enabled = false;\n        }\n        \n        Rigidbody riderRb = player.GetComponent<Rigidbody>();\n        if (riderRb != null)\n        {\n            riderRb.isKinematic = true;\n        }\n        \n        player.SetParent(_riderSeat);\n        player.localPosition = Vector3.zero;\n        player.localRotation = Quaternion.identity;\n        \n        OnPlayerMounted?.Invoke();\n        \n        if (_roarSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_roarSound);\n        }\n    }\n    \n    private void DismountPlayer()\n    {\n        if (_rider == null) return;\n        \n        _rider.SetParent(null);\n        \n        Vector3 dismountPosition = transform.position + transform.right * 3f;\n        RaycastHit hit;\n        if (Physics.Raycast(dismountPosition + Vector3.up * 10f, Vector3.down, out hit, 20f))\n        {\n            dismountPosition = hit.point + Vector3.up * 0.5f;\n        }\n        \n        _rider.position = dismountPosition;\n        _rider.rotation = _originalRiderRotation;\n        \n        if (_riderController != null)\n        {\n            _riderController.enabled = true;\n        }\n        \n        Rigidbody riderRb = _rider.GetComponent<Rigidbody>();\n        if (riderRb != null)\n        {\n            riderRb.isKinematic = false;\n        }\n        \n        _hasRider = false;\n        _rider = null;\n        \n        OnPlayerDismounted?.Invoke();\n    }\n    \n    private void HandleFlightInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        float ascend = Input.GetKey(KeyCode.Space) ? 1f : 0f;\n        float descend = Input.GetKey(KeyCode.LeftShift) ? 1f : 0f;\n        \n        Vector3 inputDirection = new Vector3(horizontal, ascend - descend, vertical);\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, _flySpeed, _acceleration * Time.deltaTime);\n            \n            if (_isGrounded && (ascend > 0 || vertical > 0))\n            {\n                _isGrounded = false;\n                OnTakeOff?.Invoke();\n            }\n        }\n        else\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0f, _deceleration * Time.deltaTime);\n        }\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            float targetYaw = horizontal * _yawSpeed * Time.deltaTime;\n            float targetPitch = -vertical * _pitchSpeed * Time.deltaTime;\n            float targetRoll = -horizontal * _rollSpeed * Time.deltaTime;\n            \n            targetPitch = Mathf.Clamp(targetPitch, -_maxPitchAngle, _maxPitchAngle);\n            targetRoll = Mathf.Clamp(targetRoll, -_maxRollAngle, _maxRollAngle);\n            \n            transform.Rotate(targetPitch, targetYaw, 0f, Space.Self);\n            \n            Vector3 currentEuler = transform.eulerAngles;\n            currentEuler.z = Mathf.LerpAngle(currentEuler.z, targetRoll, Time.deltaTime * 2f);\n            transform.eulerAngles = currentEuler;\n        }\n        else\n        {\n            Vector3 currentEuler = transform.eulerAngles;\n            currentEuler.z = Mathf.LerpAngle(currentEuler.z, 0f, Time.deltaTime * 2f);\n            transform.eulerAngles = currentEuler;\n        }\n    }\n    \n    private void ApplyFlightPhysics()\n    {\n        Vector3 forwardMovement = transform.forward * _currentSpeed;\n        \n        float currentAltitude = transform.position.y;\n        if (currentAltitude > _maxAltitude)\n        {\n            forwardMovement.y = Mathf.Min(forwardMovement.y, 0f);\n        }\n        else if (currentAltitude < _minAltitude)\n        {\n            forwardMovement.y = Mathf.Max(forwardMovement.y, 2f);\n        }\n        \n        _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, forwardMovement, Time.fixedDeltaTime * 3f);\n    }\n    \n    private void ApplyIdlePhysics()\n    {\n        if (!_isGrounded)\n        {\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, Vector3.down * 2f, Time.fixedDeltaTime);\n        }\n        else\n        {\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, Vector3.zero, Time.fixedDeltaTime * 5f);\n        }\n    }\n    \n    private void HandleIdleBehavior()\n    {\n        transform.rotation = Quaternion.Lerp(transform.rotation, \n            Quaternion.LookRotation(transform.forward, Vector3.up), Time.deltaTime);\n    }\n    \n    private void AnimateWings()\n    {\n        if (_leftWing == null || _rightWing == null) return;\n        \n        _wingFlapTimer += Time.deltaTime * _wingFlapSpeed;\n        float flapAngle = Mathf.Sin(_wingFlapTimer) * _wingFlapAngle;\n        \n        _leftWing.localRotation = Quaternion.Euler(0f, 0f, flapAngle);\n        _rightWing.localRotation = Quaternion.Euler(0f, 0f, -flapAngle);\n    }\n    \n    private void PlayFlightSounds()\n    {\n        if (_wingFlapSound != null && _audioSource != null && _currentSpeed > 0.5f)\n        {\n            if (!_audioSource.isPlaying)\n            {\n                _audioSource.clip = _wingFlapSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            _audioSource.pitch = Mathf.Lerp(0.8f, 1.5f, _currentSpeed / _flySpeed);\n        }\n        else if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _wingFlapSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void CheckGroundStatus()\n    {\n        RaycastHit hit;\n        bool wasGrounded = _isGrounded;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, 2f);\n        \n        if (!wasGrounded && _isGrounded)\n        {\n            OnLanding?.Invoke();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        if (_riderSeat != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_riderSeat.position, Vector3.one * 0.5f);\n        }\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "wolf mount running",
      "ideal_ir": {
        "class_name": "WolfMount",
        "components": [
          "Rigidbody",
          "Animator",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "runSpeed",
            "type": "float",
            "default": 12
          },
          {
            "name": "acceleration",
            "type": "float",
            "default": 8
          },
          {
            "name": "stamina",
            "type": "float",
            "default": 100
          },
          {
            "name": "staminaDrainRate",
            "type": "float",
            "default": 15
          },
          {
            "name": "staminaRegenRate",
            "type": "float",
            "default": 10
          },
          {
            "name": "isMounted",
            "type": "bool",
            "default": false
          },
          {
            "name": "isRunning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_running",
            "trigger": "when player presses run input while mounted and stamina is above zero",
            "actions": [
              {
                "action": "set running state to true"
              },
              {
                "action": "play running animation"
              },
              {
                "action": "play galloping sound effect"
              },
              {
                "action": "increase movement speed to run speed"
              }
            ]
          },
          {
            "name": "maintain_running",
            "trigger": "while running and run input is held",
            "actions": [
              {
                "action": "accelerate forward at acceleration rate"
              },
              {
                "action": "drain stamina at drain rate per second"
              },
              {
                "action": "create dust particle effects behind wolf"
              },
              {
                "action": "play breathing sound effects"
              }
            ]
          },
          {
            "name": "stop_running",
            "trigger": "when run input is released or stamina reaches zero",
            "actions": [
              {
                "action": "set running state to false"
              },
              {
                "action": "play walking animation"
              },
              {
                "action": "reduce movement speed to walk speed"
              },
              {
                "action": "stop galloping sound effect"
              }
            ]
          },
          {
            "name": "regenerate_stamina",
            "trigger": "when not running and stamina is below maximum",
            "actions": [
              {
                "action": "restore stamina at regeneration rate per second"
              }
            ]
          },
          {
            "name": "handle_dismount_while_running",
            "trigger": "when player dismounts while wolf is running",
            "actions": [
              {
                "action": "gradually slow down to stop"
              },
              {
                "action": "set running state to false"
              },
              {
                "action": "play tired panting animation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class WolfMount : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _walkSpeed = 3f;\n    [SerializeField] private float _runSpeed = 8f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 15f;\n    [SerializeField] private float _turnSpeed = 180f;\n    \n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    [SerializeField] private float _minStaminaToRun = 10f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _speedParameter = \"Speed\";\n    [SerializeField] private string _isRunningParameter = \"IsRunning\";\n    [SerializeField] private string _isMountedParameter = \"IsMounted\";\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _footstepSounds;\n    [SerializeField] private AudioClip[] _breathingSounds;\n    [SerializeField] private float _footstepInterval = 0.5f;\n    \n    [Header(\"Mounting Settings\")]\n    [SerializeField] private Transform _mountPoint;\n    [SerializeField] private float _mountRange = 2f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    [SerializeField] private KeyCode _dismountKey = KeyCode.F;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnMounted;\n    public UnityEvent OnDismounted;\n    public UnityEvent OnStaminaDepleted;\n    \n    private CharacterController _characterController;\n    private Transform _rider;\n    private bool _isMounted = false;\n    private bool _isRunning = false;\n    private float _currentSpeed = 0f;\n    private float _currentStamina;\n    private float _footstepTimer = 0f;\n    private Vector3 _moveDirection = Vector3.zero;\n    private Camera _playerCamera;\n    private Vector3 _lastPosition;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        if (_characterController == null)\n            _characterController = gameObject.AddComponent<CharacterController>();\n            \n        if (_animator == null)\n            _animator = GetComponentInChildren<Animator>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_mountPoint == null)\n        {\n            GameObject mountPointObj = new GameObject(\"MountPoint\");\n            mountPointObj.transform.SetParent(transform);\n            mountPointObj.transform.localPosition = new Vector3(0, 1.5f, 0);\n            _mountPoint = mountPointObj.transform;\n        }\n        \n        _currentStamina = _maxStamina;\n        _lastPosition = transform.position;\n        _playerCamera = Camera.main;\n    }\n    \n    private void Update()\n    {\n        HandleMountingInput();\n        \n        if (_isMounted && _rider != null)\n        {\n            HandleMovementInput();\n            HandleStamina();\n            UpdateAnimation();\n            HandleAudio();\n        }\n        else\n        {\n            CheckForNearbyPlayer();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isMounted && _rider != null)\n        {\n            ApplyMovement();\n        }\n    }\n    \n    private void HandleMountingInput()\n    {\n        if (Input.GetKeyDown(_mountKey) && !_isMounted)\n        {\n            TryMount();\n        }\n        else if (Input.GetKeyDown(_dismountKey) && _isMounted)\n        {\n            Dismount();\n        }\n    }\n    \n    private void CheckForNearbyPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance <= _mountRange)\n            {\n                // Visual indicator could be added here\n            }\n        }\n    }\n    \n    private void TryMount()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance <= _mountRange)\n            {\n                Mount(player.transform);\n            }\n        }\n    }\n    \n    private void Mount(Transform rider)\n    {\n        _rider = rider;\n        _isMounted = true;\n        \n        // Disable player's character controller if it exists\n        CharacterController playerController = _rider.GetComponent<CharacterController>();\n        if (playerController != null)\n            playerController.enabled = false;\n            \n        // Position rider on mount point\n        _rider.position = _mountPoint.position;\n        _rider.SetParent(_mountPoint);\n        \n        // Update animation\n        if (_animator != null)\n            _animator.SetBool(_isMountedParameter, true);\n            \n        OnMounted?.Invoke();\n    }\n    \n    private void Dismount()\n    {\n        if (_rider != null)\n        {\n            // Re-enable player's character controller\n            CharacterController playerController = _rider.GetComponent<CharacterController>();\n            if (playerController != null)\n                playerController.enabled = true;\n                \n            // Position rider next to wolf\n            _rider.SetParent(null);\n            _rider.position = transform.position + transform.right * 2f;\n        }\n        \n        _rider = null;\n        _isMounted = false;\n        _isRunning = false;\n        _currentSpeed = 0f;\n        \n        // Update animation\n        if (_animator != null)\n        {\n            _animator.SetBool(_isMountedParameter, false);\n            _animator.SetBool(_isRunningParameter, false);\n            _animator.SetFloat(_speedParameter, 0f);\n        }\n        \n        OnDismounted?.Invoke();\n    }\n    \n    private void HandleMovementInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        bool runInput = Input.GetKey(KeyCode.LeftShift);\n        \n        Vector3 inputDirection = new Vector3(horizontal, 0, vertical).normalized;\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            // Calculate movement direction relative to camera\n            Vector3 cameraForward = _playerCamera.transform.forward;\n            Vector3 cameraRight = _playerCamera.transform.right;\n            cameraForward.y = 0;\n            cameraRight.y = 0;\n            cameraForward.Normalize();\n            cameraRight.Normalize();\n            \n            _moveDirection = (cameraForward * vertical + cameraRight * horizontal).normalized;\n            \n            // Determine if running\n            _isRunning = runInput && _currentStamina > _minStaminaToRun && inputDirection.magnitude > 0.8f;\n            \n            float targetSpeed = _isRunning ? _runSpeed : _walkSpeed;\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, targetSpeed, _acceleration * Time.deltaTime);\n            \n            // Rotate wolf to face movement direction\n            if (_moveDirection != Vector3.zero)\n            {\n                Quaternion targetRotation = Quaternion.LookRotation(_moveDirection);\n                transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _turnSpeed * Time.deltaTime);\n            }\n        }\n        else\n        {\n            _isRunning = false;\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0f, _deceleration * Time.deltaTime);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 movement = _moveDirection * _currentSpeed;\n        movement.y = -9.81f; // Apply gravity\n        \n        _characterController.Move(movement * Time.fixedDeltaTime);\n    }\n    \n    private void HandleStamina()\n    {\n        if (_isRunning && _currentSpeed > _walkSpeed)\n        {\n            _currentStamina -= _staminaDrainRate * Time.deltaTime;\n            _currentStamina = Mathf.Max(0f, _currentStamina);\n            \n            if (_currentStamina <= 0f)\n            {\n                OnStaminaDepleted?.Invoke();\n            }\n        }\n        else if (_currentStamina < _maxStamina)\n        {\n            _currentStamina += _staminaRegenRate * Time.deltaTime;\n            _currentStamina = Mathf.Min(_maxStamina, _currentStamina);\n        }\n    }\n    \n    private void UpdateAnimation()\n    {\n        if (_animator != null)\n        {\n            float normalizedSpeed = _currentSpeed / _runSpeed;\n            _animator.SetFloat(_speedParameter, normalizedSpeed);\n            _animator.SetBool(_isRunningParameter, _isRunning);\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        if (_currentSpeed > 0.1f)\n        {\n            _footstepTimer += Time.deltaTime;\n            float intervalMultiplier = _isRunning ? 0.7f : 1f;\n            \n            if (_footstepTimer >= _footstepInterval * intervalMultiplier)\n            {\n                PlayFootstepSound();\n                _footstepTimer = 0f;\n            }\n        }\n        \n        // Play breathing sounds when running\n        if (_isRunning && _breathingSounds.Length > 0 && !_audioSource.isPlaying)\n        {\n            AudioClip breathingClip = _breathingSounds[Random.Range(0, _breathingSounds.Length)];\n            _audioSource.PlayOneShot(breathingClip, 0.3f);\n        }\n    }\n    \n    private void PlayFootstepSound()\n    {\n        if (_footstepSounds.Length > 0 && _audioSource != null)\n        {\n            AudioClip footstepClip = _footstepSounds[Random.Range(0, _footstepSounds.Length)];\n            _audioSource.PlayOneShot(footstepClip, 0.5f);\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsMounted()\n    {\n        return _isMounted;\n    }\n    \n    public bool IsRunning()\n    {\n        return _isRunning;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        if (_mountPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_mountPoint.position, 0.2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mine cart on tracks",
      "ideal_ir": {
        "class_name": "MineCart",
        "components": [
          "Rigidbody",
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "speed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "maxSpeed",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "brakingForce",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isOnTrack",
            "type": "bool",
            "default": true
          },
          {
            "name": "currentTrackPoint",
            "type": "int",
            "default": 0
          },
          {
            "name": "trackPoints",
            "type": "Transform[]",
            "default": null
          },
          {
            "name": "wheelSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "brakeSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "follow_track",
            "trigger": "when cart is on track and has track points to follow",
            "actions": [
              {
                "action": "move toward next track point at current speed"
              },
              {
                "action": "rotate to face direction of movement"
              },
              {
                "action": "play wheel rolling sound while moving"
              }
            ]
          },
          {
            "name": "reach_track_point",
            "trigger": "when cart reaches current target track point",
            "actions": [
              {
                "action": "advance to next track point in sequence"
              },
              {
                "action": "if at end of track then stop movement"
              }
            ]
          },
          {
            "name": "accelerate_downhill",
            "trigger": "when cart is moving downhill on track",
            "actions": [
              {
                "action": "increase speed gradually up to maximum speed"
              },
              {
                "action": "increase wheel sound pitch and volume"
              }
            ]
          },
          {
            "name": "brake_uphill",
            "trigger": "when cart is moving uphill on track",
            "actions": [
              {
                "action": "decrease speed gradually due to gravity"
              },
              {
                "action": "decrease wheel sound pitch and volume"
              }
            ]
          },
          {
            "name": "emergency_brake",
            "trigger": "when cart derails or leaves track",
            "actions": [
              {
                "action": "apply strong braking force to slow down"
              },
              {
                "action": "play brake screeching sound"
              },
              {
                "action": "mark cart as off track"
              }
            ]
          },
          {
            "name": "player_interaction",
            "trigger": "when player enters cart trigger area",
            "actions": [
              {
                "action": "allow player to control cart speed"
              },
              {
                "action": "enable manual braking input"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MineCart : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 10f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _slopeSpeedMultiplier = 1.5f;\n    \n    [Header(\"Track Detection\")]\n    [SerializeField] private LayerMask _trackLayerMask = 1;\n    [SerializeField] private float _trackDetectionDistance = 2f;\n    [SerializeField] private Transform _frontWheelPoint;\n    [SerializeField] private Transform _rearWheelPoint;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _mass = 100f;\n    [SerializeField] private float _friction = 0.1f;\n    [SerializeField] private float _airResistance = 0.05f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rollingSound;\n    [SerializeField] private AudioClip _brakeSound;\n    [SerializeField] private float _minPitchSpeed = 0f;\n    [SerializeField] private float _maxPitchSpeed = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCartStart;\n    public UnityEvent OnCartStop;\n    public UnityEvent<float> OnSpeedChanged;\n    public UnityEvent OnDerailed;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentDirection;\n    private float _currentSpeed;\n    private bool _isOnTrack;\n    private bool _isMoving;\n    private bool _playerOnBoard;\n    private RaycastHit _frontHit;\n    private RaycastHit _rearHit;\n    private Vector3 _lastValidDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.clip = _rollingSound;\n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n        \n        if (_frontWheelPoint == null)\n        {\n            GameObject frontWheel = new GameObject(\"FrontWheelPoint\");\n            frontWheel.transform.SetParent(transform);\n            frontWheel.transform.localPosition = Vector3.forward * 1f;\n            _frontWheelPoint = frontWheel.transform;\n        }\n        \n        if (_rearWheelPoint == null)\n        {\n            GameObject rearWheel = new GameObject(\"RearWheelPoint\");\n            rearWheel.transform.SetParent(transform);\n            rearWheel.transform.localPosition = Vector3.back * 1f;\n            _rearWheelPoint = rearWheel.transform;\n        }\n        \n        _currentDirection = transform.forward;\n        _lastValidDirection = _currentDirection;\n    }\n    \n    private void FixedUpdate()\n    {\n        DetectTrack();\n        \n        if (_isOnTrack)\n        {\n            CalculateTrackDirection();\n            ApplyMovement();\n        }\n        else\n        {\n            ApplyGravity();\n            HandleDerailment();\n        }\n        \n        UpdateAudio();\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void DetectTrack()\n    {\n        bool frontOnTrack = Physics.Raycast(_frontWheelPoint.position, Vector3.down, out _frontHit, _trackDetectionDistance, _trackLayerMask);\n        bool rearOnTrack = Physics.Raycast(_rearWheelPoint.position, Vector3.down, out _rearHit, _trackDetectionDistance, _trackLayerMask);\n        \n        _isOnTrack = frontOnTrack && rearOnTrack;\n        \n        if (!_isOnTrack && _isMoving)\n        {\n            OnDerailed?.Invoke();\n        }\n    }\n    \n    private void CalculateTrackDirection()\n    {\n        if (_isOnTrack)\n        {\n            Vector3 frontPoint = _frontHit.point;\n            Vector3 rearPoint = _rearHit.point;\n            \n            Vector3 trackDirection = (frontPoint - rearPoint).normalized;\n            \n            if (Vector3.Dot(trackDirection, _lastValidDirection) < 0)\n            {\n                trackDirection = -trackDirection;\n            }\n            \n            _currentDirection = trackDirection;\n            _lastValidDirection = trackDirection;\n            \n            Vector3 averageNormal = (_frontHit.normal + _rearHit.normal) * 0.5f;\n            Vector3 rightDirection = Vector3.Cross(trackDirection, averageNormal).normalized;\n            Vector3 upDirection = Vector3.Cross(rightDirection, trackDirection).normalized;\n            \n            transform.rotation = Quaternion.LookRotation(trackDirection, upDirection);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        float slopeAngle = Vector3.Angle(Vector3.up, (_frontHit.normal + _rearHit.normal) * 0.5f) - 90f;\n        float slopeForce = Mathf.Sin(slopeAngle * Mathf.Deg2Rad) * _gravity;\n        \n        if (_playerOnBoard)\n        {\n            _currentSpeed += _acceleration * Time.fixedDeltaTime;\n        }\n        \n        _currentSpeed += slopeForce * _slopeSpeedMultiplier * Time.fixedDeltaTime;\n        \n        float resistanceForce = _friction + (_airResistance * _currentSpeed * _currentSpeed);\n        _currentSpeed -= resistanceForce * Time.fixedDeltaTime;\n        \n        _currentSpeed = Mathf.Clamp(_currentSpeed, -_maxSpeed, _maxSpeed);\n        \n        if (Mathf.Abs(_currentSpeed) < 0.1f)\n        {\n            _currentSpeed = 0f;\n            if (_isMoving)\n            {\n                _isMoving = false;\n                OnCartStop?.Invoke();\n            }\n        }\n        else\n        {\n            if (!_isMoving)\n            {\n                _isMoving = true;\n                OnCartStart?.Invoke();\n            }\n        }\n        \n        Vector3 velocity = _currentDirection * _currentSpeed;\n        _rigidbody.velocity = velocity;\n        \n        Vector3 averageTrackPoint = (_frontHit.point + _rearHit.point) * 0.5f;\n        Vector3 targetPosition = averageTrackPoint + Vector3.up * 0.5f;\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.fixedDeltaTime * 10f);\n    }\n    \n    private void ApplyGravity()\n    {\n        _rigidbody.useGravity = true;\n        _currentSpeed = _rigidbody.velocity.magnitude;\n    }\n    \n    private void HandleDerailment()\n    {\n        _rigidbody.useGravity = true;\n        \n        if (_currentSpeed > 1f)\n        {\n            _currentSpeed -= _deceleration * Time.fixedDeltaTime;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_isMoving && _currentSpeed > 0.1f)\n        {\n            if (!_audioSource.isPlaying)\n            {\n                _audioSource.Play();\n            }\n            \n            float normalizedSpeed = Mathf.InverseLerp(_minPitchSpeed, _maxPitchSpeed, _currentSpeed);\n            _audioSource.pitch = Mathf.Lerp(0.5f, 2f, normalizedSpeed);\n            _audioSource.volume = Mathf.Lerp(0.3f, 1f, normalizedSpeed);\n        }\n        else\n        {\n            if (_audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerOnBoard = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerOnBoard = false;\n        }\n    }\n    \n    public void ApplyBrake()\n    {\n        _currentSpeed *= 0.5f;\n        \n        if (_brakeSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_brakeSound);\n        }\n    }\n    \n    public void AddForce(float force)\n    {\n        _currentSpeed += force;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsOnTrack()\n    {\n        return _isOnTrack;\n    }\n    \n    public bool IsMoving()\n    {\n        return _isMoving;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_frontWheelPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawRay(_frontWheelPoint.position, Vector3.down * _trackDetectionDistance);\n        }\n        \n        if (_rearWheelPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawRay(_rearWheelPoint.position, Vector3.down * _trackDetectionDistance);\n        }\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "hot air balloon floating",
      "ideal_ir": {
        "class_name": "HotAirBalloon",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "floatForce",
            "type": "float",
            "default": 15
          },
          {
            "name": "windStrength",
            "type": "float",
            "default": 2
          },
          {
            "name": "bobIntensity",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "maxHeight",
            "type": "float",
            "default": 50
          },
          {
            "name": "minHeight",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "apply_buoyancy",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "apply upward force to simulate hot air lift"
              }
            ]
          },
          {
            "name": "gentle_bobbing",
            "trigger": "continuously while floating",
            "actions": [
              {
                "action": "add subtle up and down movement using sine wave pattern"
              }
            ]
          },
          {
            "name": "wind_drift",
            "trigger": "continuously while in air",
            "actions": [
              {
                "action": "apply horizontal force to simulate wind pushing the balloon"
              }
            ]
          },
          {
            "name": "height_limit",
            "trigger": "when balloon reaches maximum height",
            "actions": [
              {
                "action": "reduce upward force to prevent going too high"
              }
            ]
          },
          {
            "name": "minimum_altitude",
            "trigger": "when balloon drops below minimum height",
            "actions": [
              {
                "action": "increase upward force to maintain floating altitude"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class HotAirBalloon : MonoBehaviour\n{\n    [Header(\"Balloon Physics\")]\n    [SerializeField] private float _baseFloatForce = 10f;\n    [SerializeField] private float _maxAltitude = 50f;\n    [SerializeField] private float _windStrength = 2f;\n    [SerializeField] private float _bobAmplitude = 0.5f;\n    [SerializeField] private float _bobFrequency = 1f;\n    \n    [Header(\"Heat Control\")]\n    [SerializeField] private float _heatDecayRate = 1f;\n    [SerializeField] private float _maxHeat = 100f;\n    [SerializeField] private float _minFloatHeat = 20f;\n    [SerializeField] private KeyCode _heatKey = KeyCode.Space;\n    [SerializeField] private float _heatIncreaseRate = 30f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private Transform _basket;\n    [SerializeField] private Transform _balloon;\n    [SerializeField] private float _basketSwayAmount = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _flameAudioSource;\n    [SerializeField] private AudioClip _flameSound;\n    \n    private Rigidbody _rigidbody;\n    private float _currentHeat;\n    private float _bobTimer;\n    private Vector3 _windDirection;\n    private float _windTimer;\n    private Vector3 _initialBasketPosition;\n    private Vector3 _initialBalloonPosition;\n    private bool _isPlayerControlled;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        \n        _currentHeat = _maxHeat * 0.7f;\n        _windDirection = new Vector3(Random.Range(-1f, 1f), 0, Random.Range(-1f, 1f)).normalized;\n        \n        if (_basket != null)\n            _initialBasketPosition = _basket.localPosition;\n        if (_balloon != null)\n            _initialBalloonPosition = _balloon.localPosition;\n            \n        if (_flameAudioSource == null && _flameSound != null)\n        {\n            _flameAudioSource = gameObject.AddComponent<AudioSource>();\n            _flameAudioSource.clip = _flameSound;\n            _flameAudioSource.loop = true;\n            _flameAudioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateHeat();\n        UpdateVisualEffects();\n        UpdateAudio();\n        _bobTimer += Time.deltaTime;\n        _windTimer += Time.deltaTime;\n        \n        if (_windTimer >= 5f)\n        {\n            _windDirection = new Vector3(Random.Range(-1f, 1f), 0, Random.Range(-1f, 1f)).normalized;\n            _windTimer = 0f;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyFloatForce();\n        ApplyWindForce();\n        ApplyBobbing();\n        LimitAltitude();\n        UpdateBasketSway();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKey(_heatKey))\n        {\n            _currentHeat = Mathf.Min(_currentHeat + _heatIncreaseRate * Time.deltaTime, _maxHeat);\n            _isPlayerControlled = true;\n        }\n        else\n        {\n            _isPlayerControlled = false;\n        }\n    }\n    \n    private void UpdateHeat()\n    {\n        _currentHeat = Mathf.Max(_currentHeat - _heatDecayRate * Time.deltaTime, 0f);\n    }\n    \n    private void ApplyFloatForce()\n    {\n        if (_currentHeat > _minFloatHeat)\n        {\n            float heatRatio = (_currentHeat - _minFloatHeat) / (_maxHeat - _minFloatHeat);\n            float floatForce = _baseFloatForce * heatRatio;\n            \n            Vector3 upwardForce = Vector3.up * floatForce;\n            _rigidbody.AddForce(upwardForce, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyWindForce()\n    {\n        Vector3 windForce = _windDirection * _windStrength;\n        windForce.y = 0f;\n        _rigidbody.AddForce(windForce, ForceMode.Force);\n    }\n    \n    private void ApplyBobbing()\n    {\n        float bobOffset = Mathf.Sin(_bobTimer * _bobFrequency) * _bobAmplitude;\n        Vector3 bobForce = Vector3.up * bobOffset;\n        _rigidbody.AddForce(bobForce, ForceMode.Force);\n    }\n    \n    private void LimitAltitude()\n    {\n        if (transform.position.y > _maxAltitude)\n        {\n            Vector3 downwardForce = Vector3.down * (_baseFloatForce * 2f);\n            _rigidbody.AddForce(downwardForce, ForceMode.Force);\n        }\n    }\n    \n    private void UpdateBasketSway()\n    {\n        if (_basket != null)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            float swayX = -velocity.x * _basketSwayAmount * 0.1f;\n            float swayZ = -velocity.z * _basketSwayAmount * 0.1f;\n            \n            Vector3 targetPosition = _initialBasketPosition + new Vector3(swayX, 0, swayZ);\n            _basket.localPosition = Vector3.Lerp(_basket.localPosition, targetPosition, Time.deltaTime * 2f);\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_flameParticles != null)\n        {\n            var emission = _flameParticles.emission;\n            \n            if (_isPlayerControlled && _currentHeat < _maxHeat)\n            {\n                if (!_flameParticles.isPlaying)\n                    _flameParticles.Play();\n                    \n                emission.rateOverTime = Mathf.Lerp(10f, 50f, (_currentHeat / _maxHeat));\n            }\n            else\n            {\n                if (_flameParticles.isPlaying)\n                    _flameParticles.Stop();\n            }\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_flameAudioSource != null)\n        {\n            if (_isPlayerControlled && _currentHeat < _maxHeat)\n            {\n                if (!_flameAudioSource.isPlaying)\n                    _flameAudioSource.Play();\n                    \n                _flameAudioSource.volume = Mathf.Lerp(0.1f, 0.8f, (_currentHeat / _maxHeat));\n            }\n            else\n            {\n                if (_flameAudioSource.isPlaying)\n                    _flameAudioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerControlled = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerControlled = false;\n        }\n    }\n    \n    public float GetHeatPercentage()\n    {\n        return _currentHeat / _maxHeat;\n    }\n    \n    public bool IsFloating()\n    {\n        return _currentHeat > _minFloatHeat;\n    }\n    \n    public void AddHeat(float amount)\n    {\n        _currentHeat = Mathf.Min(_currentHeat + amount, _maxHeat);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "glider with wind currents",
      "ideal_ir": {
        "class_name": "WindGlider",
        "components": [
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "glideSpeed",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "windSensitivity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "liftForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "maxAltitude",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "stallSpeed",
            "type": "float",
            "default": 3.0
          }
        ],
        "behaviors": [
          {
            "name": "glide_forward",
            "trigger": "always while airborne",
            "actions": [
              {
                "action": "move forward at glide speed"
              },
              {
                "action": "gradually lose altitude due to gravity"
              }
            ]
          },
          {
            "name": "catch_updraft",
            "trigger": "when entering wind current zone with upward flow",
            "actions": [
              {
                "action": "gain upward lift force"
              },
              {
                "action": "increase altitude while in updraft"
              },
              {
                "action": "slightly increase forward speed from wind assistance"
              }
            ]
          },
          {
            "name": "drift_with_crosswind",
            "trigger": "when in wind current zone with horizontal flow",
            "actions": [
              {
                "action": "drift sideways in direction of wind flow"
              },
              {
                "action": "adjust flight path based on wind strength"
              }
            ]
          },
          {
            "name": "lose_lift_in_downdraft",
            "trigger": "when entering wind current zone with downward flow",
            "actions": [
              {
                "action": "lose lift and descend faster"
              },
              {
                "action": "reduce forward speed due to air resistance"
              }
            ]
          },
          {
            "name": "stall_at_low_speed",
            "trigger": "when forward speed drops below stall speed",
            "actions": [
              {
                "action": "lose control and drop rapidly"
              },
              {
                "action": "tumble slightly while falling"
              }
            ]
          },
          {
            "name": "altitude_limit",
            "trigger": "when reaching maximum altitude",
            "actions": [
              {
                "action": "prevent further upward movement"
              },
              {
                "action": "maintain level flight at altitude ceiling"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Glider : MonoBehaviour\n{\n    [Header(\"Glider Physics\")]\n    [SerializeField] private float _liftForce = 15f;\n    [SerializeField] private float _dragCoefficient = 0.98f;\n    [SerializeField] private float _minGlideSpeed = 5f;\n    [SerializeField] private float _maxGlideSpeed = 25f;\n    [SerializeField] private float _stallSpeed = 3f;\n    \n    [Header(\"Control Settings\")]\n    [SerializeField] private float _pitchSensitivity = 2f;\n    [SerializeField] private float _rollSensitivity = 1.5f;\n    [SerializeField] private float _yawSensitivity = 1f;\n    [SerializeField] private float _maxPitchAngle = 45f;\n    [SerializeField] private float _maxRollAngle = 60f;\n    \n    [Header(\"Wind Response\")]\n    [SerializeField] private float _windInfluenceMultiplier = 1.2f;\n    [SerializeField] private float _turbulenceResistance = 0.8f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _windAudioSource;\n    [SerializeField] private AudioClip _windSoundClip;\n    [SerializeField] private float _minWindVolume = 0.1f;\n    [SerializeField] private float _maxWindVolume = 0.8f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStall;\n    public UnityEvent OnLanding;\n    public UnityEvent<float> OnSpeedChanged;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded = false;\n    private bool _isStalling = false;\n    private float _currentSpeed;\n    private Vector3 _windVelocity;\n    private WindCurrent _currentWindZone;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = true;\n        _rigidbody.drag = 0.1f;\n        _rigidbody.angularDrag = 5f;\n        \n        if (_windAudioSource == null)\n        {\n            _windAudioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupAudio();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_windAudioSource != null && _windSoundClip != null)\n        {\n            _windAudioSource.clip = _windSoundClip;\n            _windAudioSource.loop = true;\n            _windAudioSource.volume = _minWindVolume;\n            _windAudioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isGrounded) return;\n        \n        HandleInput();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGrounded) return;\n        \n        CalculateAerodynamics();\n        ApplyWindEffects();\n        CheckStallCondition();\n        \n        _currentSpeed = _rigidbody.velocity.magnitude;\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void HandleInput()\n    {\n        float pitch = Input.GetAxis(\"Vertical\") * _pitchSensitivity;\n        float roll = -Input.GetAxis(\"Horizontal\") * _rollSensitivity;\n        float yaw = 0f;\n        \n        if (Input.GetKey(KeyCode.Q))\n            yaw = -_yawSensitivity;\n        else if (Input.GetKey(KeyCode.E))\n            yaw = _yawSensitivity;\n        \n        ApplyControlInputs(pitch, roll, yaw);\n    }\n    \n    private void ApplyControlInputs(float pitch, float roll, float yaw)\n    {\n        Vector3 torque = new Vector3(pitch, yaw, roll) * Time.fixedDeltaTime;\n        \n        Vector3 currentEuler = transform.eulerAngles;\n        float normalizedPitch = Mathf.DeltaAngle(0, currentEuler.x);\n        float normalizedRoll = Mathf.DeltaAngle(0, currentEuler.z);\n        \n        if (Mathf.Abs(normalizedPitch) > _maxPitchAngle && Mathf.Sign(pitch) == Mathf.Sign(normalizedPitch))\n            torque.x = 0;\n        \n        if (Mathf.Abs(normalizedRoll) > _maxRollAngle && Mathf.Sign(roll) == Mathf.Sign(normalizedRoll))\n            torque.z = 0;\n        \n        _rigidbody.AddTorque(torque, ForceMode.VelocityChange);\n    }\n    \n    private void CalculateAerodynamics()\n    {\n        Vector3 velocity = _rigidbody.velocity;\n        float speed = velocity.magnitude;\n        \n        if (speed < 0.1f) return;\n        \n        Vector3 forward = transform.forward;\n        Vector3 up = transform.up;\n        \n        float angleOfAttack = Vector3.Angle(forward, velocity.normalized);\n        float liftAmount = Mathf.Clamp01(1f - (angleOfAttack / 90f)) * _liftForce;\n        \n        Vector3 lift = up * liftAmount * speed * 0.1f;\n        _rigidbody.AddForce(lift, ForceMode.Force);\n        \n        Vector3 drag = -velocity.normalized * speed * speed * 0.01f * _dragCoefficient;\n        _rigidbody.AddForce(drag, ForceMode.Force);\n        \n        _rigidbody.velocity = Vector3.ClampMagnitude(_rigidbody.velocity, _maxGlideSpeed);\n    }\n    \n    private void ApplyWindEffects()\n    {\n        if (_currentWindZone != null)\n        {\n            _windVelocity = _currentWindZone.GetWindVelocityAtPosition(transform.position);\n            Vector3 windForce = _windVelocity * _windInfluenceMultiplier;\n            \n            if (_currentWindZone.HasTurbulence())\n            {\n                Vector3 turbulence = _currentWindZone.GetTurbulence(transform.position);\n                windForce += turbulence * (1f - _turbulenceResistance);\n            }\n            \n            _rigidbody.AddForce(windForce, ForceMode.Force);\n        }\n    }\n    \n    private void CheckStallCondition()\n    {\n        bool wasStalling = _isStalling;\n        _isStalling = _currentSpeed < _stallSpeed;\n        \n        if (_isStalling && !wasStalling)\n        {\n            OnStall?.Invoke();\n        }\n        \n        if (_isStalling)\n        {\n            _rigidbody.AddForce(Vector3.down * 20f, ForceMode.Force);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_windAudioSource != null && _windSoundClip != null)\n        {\n            float speedRatio = Mathf.Clamp01(_currentSpeed / _maxGlideSpeed);\n            float windStrength = _windVelocity.magnitude * 0.1f;\n            float targetVolume = Mathf.Lerp(_minWindVolume, _maxWindVolume, speedRatio + windStrength);\n            \n            _windAudioSource.volume = Mathf.Lerp(_windAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n            _windAudioSource.pitch = Mathf.Lerp(0.8f, 1.4f, speedRatio);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Ground\"))\n        {\n            _isGrounded = true;\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n            OnLanding?.Invoke();\n        }\n        \n        WindCurrent windCurrent = other.GetComponent<WindCurrent>();\n        if (windCurrent != null)\n        {\n            _currentWindZone = windCurrent;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Ground\"))\n        {\n            _isGrounded = false;\n        }\n        \n        WindCurrent windCurrent = other.GetComponent<WindCurrent>();\n        if (windCurrent != null && windCurrent == _currentWindZone)\n        {\n            _currentWindZone = null;\n            _windVelocity = Vector3.zero;\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsStalling()\n    {\n        return _isStalling;\n    }\n    \n    public Vector3 GetWindVelocity()\n    {\n        return _windVelocity;\n    }\n}\n\npublic class WindCurrent : MonoBehaviour\n{\n    [Header(\"Wind Properties\")]\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private float _windStrength = 10f;\n    [SerializeField] private AnimationCurve _strengthOverDistance = AnimationCurve.Linear(0, 1, 1, 0);\n    \n    [Header(\"Turbulence\")]\n    [SerializeField] private bool _hasTurbulence = false;\n    [SerializeField] private float _turbulenceStrength = 2f;\n    [SerializeField] private float _turbulenceFrequency = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _windParticles;\n    [SerializeField] private Color _windColor = Color.white;\n    \n    private Collider _windZone;\n    private Vector3 _center;\n    private Vector3 _size;\n    \n    private void Start()\n    {\n        _windZone = GetComponent<Collider>();\n        if (_windZone == null)\n        {\n            BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();\n            boxCollider.isTrigger = true;\n            boxCollider.size = Vector3.one * 10f;\n            _windZone = boxCollider;\n        }\n        \n        _windZone.isTrigger = true;\n        _center = _windZone.bounds.center;\n        _size = _windZone.bounds.size;\n        \n        SetupParticles();\n    }\n    \n    private void SetupParticles()\n    {\n        if (_windParticles == null)\n        {\n            GameObject particleGO = new GameObject(\"WindParticles\");\n            particleGO.transform.SetParent(transform);\n            particleGO.transform.localPosition = Vector3.zero;\n            _windParticles = particleGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _windParticles.main;\n        main.startColor = _windColor;\n        main.startSpeed = _windStrength * 0.5f;\n        main.maxParticles = 100;\n        \n        var shape = _windParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = _size;\n        \n        var velocityOverLifetime = _windParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.x = _windDirection.x * _windStrength;\n        velocityOverLifetime.y = _windDirection.y * _windStrength;\n        velocityOverLifetime.z = _windDirection.z * _windStrength;\n    }\n    \n    public Vector3 GetWindVelocityAtPosition(Vector3 position)\n    {\n        float distance = Vector3.Distance(position, _center);\n        float maxDistance = Mathf.Max(_size.x, _size.y, _size.z) * 0.5f;\n        float normalizedDistance = Mathf.Clamp01(distance / maxDistance);\n        \n        float strengthMultiplier = _strengthOverDistance.Evaluate(normalizedDistance);\n        return _windDirection.normalized * _windStrength * strengthMultiplier;\n    }\n    \n    public bool HasTurbulence()\n    {\n        return _hasTurbulence;\n    }\n    \n    public Vector3 GetTurbulence(Vector3 position)\n    {\n        if (!_hasTurbulence) return Vector3.zero;\n        \n        float time = Time.time * _turbulenceFrequency;\n        float noiseX = Mathf.PerlinNoise(position.x * 0.1f + time, position.z * 0.1f) - 0.5f;\n        float noiseY = Mathf.PerlinNoise(position.y * 0.1f + time, position.x * 0.1f) - 0.5f;\n        float noiseZ = Mathf.PerlinNoise(position.z * 0.1f + time, position.y * 0.1f) - 0.5f;\n        \n        return new Vector3(noiseX, noiseY, noiseZ) * _turbulenceStrength;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _windColor;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n        \n        Gizmos.color = Color.yellow;\n        Vector3 arrowEnd = _windDirection.normalized * 2f;\n        Gizmos.DrawRay(Vector3.zero, arrowEnd);\n        Gizmos.DrawWireSphere(arrowEnd, 0.2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "rocket ship launch",
      "ideal_ir": {
        "class_name": "RocketShipLaunch",
        "components": [
          "Rigidbody",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "launchForce",
            "type": "float",
            "default": 1000
          },
          {
            "name": "fuelDuration",
            "type": "float",
            "default": 5
          },
          {
            "name": "isLaunched",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initiate_launch",
            "trigger": "when launch key is pressed and rocket has not launched yet",
            "actions": [
              {
                "action": "mark rocket as launched"
              },
              {
                "action": "apply upward force to rocket body"
              },
              {
                "action": "start engine sound effect"
              },
              {
                "action": "activate thruster particle effects"
              },
              {
                "action": "begin fuel consumption countdown"
              }
            ]
          },
          {
            "name": "maintain_thrust",
            "trigger": "while rocket is launched and fuel duration has not expired",
            "actions": [
              {
                "action": "continue applying upward thrust force"
              },
              {
                "action": "keep thruster particles active"
              },
              {
                "action": "maintain engine audio loop"
              }
            ]
          },
          {
            "name": "fuel_depletion",
            "trigger": "when fuel duration time has elapsed",
            "actions": [
              {
                "action": "stop applying thrust force"
              },
              {
                "action": "fade out engine sound"
              },
              {
                "action": "reduce thruster particle intensity"
              },
              {
                "action": "allow rocket to fall under gravity"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RocketShipLauncher : MonoBehaviour\n{\n    [Header(\"Launch Settings\")]\n    [SerializeField] private float _launchForce = 1000f;\n    [SerializeField] private float _launchDelay = 3f;\n    [SerializeField] private float _fuelBurnDuration = 5f;\n    [SerializeField] private AnimationCurve _thrustCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _countdownSound;\n    [SerializeField] private AudioClip _launchSound;\n    [SerializeField] private AudioClip _thrusterSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _thrusterParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private Light _thrusterLight;\n    [SerializeField] private Transform _rocketTransform;\n    \n    [Header(\"Launch Trigger\")]\n    [SerializeField] private KeyCode _launchKey = KeyCode.Space;\n    [SerializeField] private bool _autoLaunch = false;\n    [SerializeField] private float _autoLaunchDelay = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCountdownStart;\n    public UnityEvent OnLaunchStart;\n    public UnityEvent OnLaunchComplete;\n    \n    private Rigidbody _rigidbody;\n    private bool _isLaunching = false;\n    private bool _hasLaunched = false;\n    private float _launchTimer = 0f;\n    private float _thrustTimer = 0f;\n    private Vector3 _initialPosition;\n    private Quaternion _initialRotation;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_rocketTransform == null)\n        {\n            _rocketTransform = transform;\n        }\n        \n        _initialPosition = transform.position;\n        _initialRotation = transform.rotation;\n        \n        _rigidbody.isKinematic = true;\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n        \n        if (_autoLaunch)\n        {\n            Invoke(nameof(StartLaunchSequence), _autoLaunchDelay);\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_hasLaunched && !_isLaunching && Input.GetKeyDown(_launchKey))\n        {\n            StartLaunchSequence();\n        }\n        \n        if (_isLaunching)\n        {\n            UpdateLaunchSequence();\n        }\n    }\n    \n    private void StartLaunchSequence()\n    {\n        if (_hasLaunched || _isLaunching) return;\n        \n        _isLaunching = true;\n        _launchTimer = 0f;\n        \n        OnCountdownStart?.Invoke();\n        \n        if (_countdownSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_countdownSound);\n        }\n        \n        if (_smokeParticles != null)\n        {\n            _smokeParticles.Play();\n        }\n    }\n    \n    private void UpdateLaunchSequence()\n    {\n        _launchTimer += Time.deltaTime;\n        \n        if (_launchTimer >= _launchDelay && !_hasLaunched)\n        {\n            Launch();\n        }\n        \n        if (_hasLaunched)\n        {\n            UpdateThrust();\n        }\n    }\n    \n    private void Launch()\n    {\n        _hasLaunched = true;\n        _thrustTimer = 0f;\n        _rigidbody.isKinematic = false;\n        \n        OnLaunchStart?.Invoke();\n        \n        if (_launchSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_launchSound);\n        }\n        \n        if (_thrusterSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _thrusterSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Play();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = true;\n        }\n    }\n    \n    private void UpdateThrust()\n    {\n        _thrustTimer += Time.deltaTime;\n        \n        if (_thrustTimer <= _fuelBurnDuration)\n        {\n            float normalizedTime = _thrustTimer / _fuelBurnDuration;\n            float thrustMultiplier = _thrustCurve.Evaluate(normalizedTime);\n            \n            Vector3 thrustForce = _rocketTransform.up * _launchForce * thrustMultiplier * Time.deltaTime;\n            _rigidbody.AddForce(thrustForce, ForceMode.Force);\n            \n            if (_thrusterLight != null)\n            {\n                _thrusterLight.intensity = thrustMultiplier * 2f;\n            }\n        }\n        else\n        {\n            CompleteLaunch();\n        }\n    }\n    \n    private void CompleteLaunch()\n    {\n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _thrusterSound)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_thrusterParticles != null && _thrusterParticles.isPlaying)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n        \n        OnLaunchComplete?.Invoke();\n    }\n    \n    public void ResetRocket()\n    {\n        _isLaunching = false;\n        _hasLaunched = false;\n        _launchTimer = 0f;\n        _thrustTimer = 0f;\n        \n        transform.position = _initialPosition;\n        transform.rotation = _initialRotation;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_thrusterParticles != null && _thrusterParticles.isPlaying)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        if (_smokeParticles != null && _smokeParticles.isPlaying)\n        {\n            _smokeParticles.Stop();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n    }\n    \n    public void SetLaunchForce(float force)\n    {\n        _launchForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetLaunchDelay(float delay)\n    {\n        _launchDelay = Mathf.Max(0f, delay);\n    }\n    \n    public bool IsLaunching => _isLaunching;\n    public bool HasLaunched => _hasLaunched;\n    public float LaunchProgress => _hasLaunched ? _thrustTimer / _fuelBurnDuration : _launchTimer / _launchDelay;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "portal travel between points",
      "ideal_ir": {
        "class_name": "Portal",
        "components": [
          "Collider",
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "destinationPortal",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "teleportDelay",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          },
          {
            "name": "requiresKey",
            "type": "bool",
            "default": false
          },
          {
            "name": "keyItemName",
            "type": "string",
            "default": ""
          },
          {
            "name": "lastTeleportTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "teleport_player",
            "trigger": "when player enters portal trigger area and portal is active and cooldown period has passed",
            "actions": [
              {
                "action": "check if player has required key item if key is required"
              },
              {
                "action": "play portal activation sound effect"
              },
              {
                "action": "start teleportation particle effects"
              },
              {
                "action": "disable player movement temporarily"
              },
              {
                "action": "wait for teleport delay duration"
              },
              {
                "action": "move player to destination portal location"
              },
              {
                "action": "face player away from destination portal"
              },
              {
                "action": "play arrival particle effects at destination"
              },
              {
                "action": "re-enable player movement"
              },
              {
                "action": "record current time as last teleport time"
              },
              {
                "action": "trigger cooldown on both portals"
              }
            ]
          },
          {
            "name": "portal_visual_feedback",
            "trigger": "when player approaches portal within interaction range",
            "actions": [
              {
                "action": "increase portal particle intensity"
              },
              {
                "action": "play ambient portal humming sound"
              },
              {
                "action": "display interaction prompt if portal is usable"
              }
            ]
          },
          {
            "name": "portal_idle_state",
            "trigger": "when player moves away from portal interaction range",
            "actions": [
              {
                "action": "return portal particles to normal intensity"
              },
              {
                "action": "fade out ambient portal sounds"
              },
              {
                "action": "hide interaction prompt"
              }
            ]
          },
          {
            "name": "handle_missing_destination",
            "trigger": "when player tries to use portal but destination portal is not set",
            "actions": [
              {
                "action": "play error sound effect"
              },
              {
                "action": "display message that portal is not connected"
              },
              {
                "action": "prevent teleportation"
              }
            ]
          },
          {
            "name": "handle_locked_portal",
            "trigger": "when player tries to use portal but does not have required key",
            "actions": [
              {
                "action": "play locked portal sound effect"
              },
              {
                "action": "display message about required key item"
              },
              {
                "action": "show portal locked visual effect"
              },
              {
                "action": "prevent teleportation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Portal : MonoBehaviour\n{\n    [Header(\"Portal Configuration\")]\n    [SerializeField] private Portal _destinationPortal;\n    [SerializeField] private Transform _spawnPoint;\n    [SerializeField] private float _teleportCooldown = 1f;\n    [SerializeField] private bool _requiresActivation = false;\n    [SerializeField] private KeyCode _activationKey = KeyCode.E;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _portalEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private GameObject _activationPrompt;\n    \n    [Header(\"Portal Behavior\")]\n    [SerializeField] private LayerMask _teleportLayers = -1;\n    [SerializeField] private float _teleportForce = 5f;\n    [SerializeField] private bool _maintainVelocity = true;\n    [SerializeField] private bool _faceDestinationDirection = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTeleportStart;\n    public UnityEvent OnTeleportComplete;\n    public UnityEvent<GameObject> OnObjectTeleported;\n    \n    private bool _isActive = true;\n    private float _lastTeleportTime;\n    private GameObject _playerInRange;\n    private Collider _portalCollider;\n    \n    private void Start()\n    {\n        _portalCollider = GetComponent<Collider>();\n        if (_portalCollider == null)\n        {\n            _portalCollider = gameObject.AddComponent<BoxCollider>();\n            ((BoxCollider)_portalCollider).isTrigger = true;\n        }\n        \n        if (_spawnPoint == null)\n        {\n            GameObject spawnPoint = new GameObject(\"SpawnPoint\");\n            spawnPoint.transform.SetParent(transform);\n            spawnPoint.transform.localPosition = Vector3.forward * 2f;\n            _spawnPoint = spawnPoint.transform;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_activationPrompt != null)\n            _activationPrompt.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_requiresActivation && _playerInRange != null)\n        {\n            if (Input.GetKeyDown(_activationKey))\n            {\n                TeleportObject(_playerInRange);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive || Time.time - _lastTeleportTime < _teleportCooldown)\n            return;\n            \n        if (!IsValidTeleportTarget(other.gameObject))\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = other.gameObject;\n            if (_requiresActivation && _activationPrompt != null)\n                _activationPrompt.SetActive(true);\n        }\n        \n        if (!_requiresActivation)\n        {\n            TeleportObject(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = null;\n            if (_activationPrompt != null)\n                _activationPrompt.SetActive(false);\n        }\n    }\n    \n    private bool IsValidTeleportTarget(GameObject target)\n    {\n        if (_destinationPortal == null)\n            return false;\n            \n        int targetLayer = 1 << target.layer;\n        return (_teleportLayers.value & targetLayer) != 0;\n    }\n    \n    private void TeleportObject(GameObject target)\n    {\n        if (!IsValidTeleportTarget(target) || !_isActive)\n            return;\n            \n        StartCoroutine(PerformTeleport(target));\n    }\n    \n    private IEnumerator PerformTeleport(GameObject target)\n    {\n        _isActive = false;\n        _lastTeleportTime = Time.time;\n        \n        OnTeleportStart?.Invoke();\n        \n        if (_portalEffect != null)\n            _portalEffect.Play();\n            \n        if (_audioSource != null && _teleportSound != null)\n            _audioSource.PlayOneShot(_teleportSound);\n        \n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        Vector3 originalVelocity = Vector3.zero;\n        \n        if (targetRigidbody != null && _maintainVelocity)\n            originalVelocity = targetRigidbody.velocity;\n        \n        CharacterController characterController = target.GetComponent<CharacterController>();\n        if (characterController != null)\n            characterController.enabled = false;\n        \n        Vector3 destinationPosition = _destinationPortal._spawnPoint.position;\n        target.transform.position = destinationPosition;\n        \n        if (_faceDestinationDirection)\n        {\n            target.transform.rotation = _destinationPortal._spawnPoint.rotation;\n        }\n        \n        yield return new WaitForFixedUpdate();\n        \n        if (characterController != null)\n            characterController.enabled = true;\n        \n        if (targetRigidbody != null)\n        {\n            if (_maintainVelocity)\n            {\n                Vector3 adjustedVelocity = _destinationPortal.transform.TransformDirection(\n                    transform.InverseTransformDirection(originalVelocity));\n                targetRigidbody.velocity = adjustedVelocity;\n            }\n            else\n            {\n                Vector3 forwardForce = _destinationPortal._spawnPoint.forward * _teleportForce;\n                targetRigidbody.velocity = forwardForce;\n            }\n        }\n        \n        if (_destinationPortal._portalEffect != null)\n            _destinationPortal._portalEffect.Play();\n        \n        OnObjectTeleported?.Invoke(target);\n        OnTeleportComplete?.Invoke();\n        \n        _destinationPortal._lastTeleportTime = Time.time;\n        \n        yield return new WaitForSeconds(_teleportCooldown);\n        \n        _isActive = true;\n    }\n    \n    public void SetDestination(Portal destination)\n    {\n        _destinationPortal = destination;\n    }\n    \n    public void ActivatePortal()\n    {\n        _isActive = true;\n    }\n    \n    public void DeactivatePortal()\n    {\n        _isActive = false;\n    }\n    \n    public void TogglePortal()\n    {\n        _isActive = !_isActive;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_destinationPortal != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _destinationPortal.transform.position);\n            Gizmos.DrawWireSphere(_destinationPortal.transform.position, 0.5f);\n        }\n        \n        if (_spawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_spawnPoint.position, 0.3f);\n            Gizmos.DrawRay(_spawnPoint.position, _spawnPoint.forward * 2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "vending machine with selection",
      "ideal_ir": {
        "class_name": "VendingMachine",
        "components": [
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "selectedItem",
            "type": "int",
            "default": 0
          },
          {
            "name": "itemCount",
            "type": "int",
            "default": 5
          },
          {
            "name": "requiresCoin",
            "type": "bool",
            "default": true
          },
          {
            "name": "hasCoin",
            "type": "bool",
            "default": false
          },
          {
            "name": "dispensingItem",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "cycle_selection_up",
            "trigger": "when up arrow key is pressed",
            "actions": [
              {
                "action": "increase selected item number by one"
              },
              {
                "action": "wrap selection to first item if past last item"
              },
              {
                "action": "play selection sound effect"
              },
              {
                "action": "update display to show current selection"
              }
            ]
          },
          {
            "name": "cycle_selection_down",
            "trigger": "when down arrow key is pressed",
            "actions": [
              {
                "action": "decrease selected item number by one"
              },
              {
                "action": "wrap selection to last item if before first item"
              },
              {
                "action": "play selection sound effect"
              },
              {
                "action": "update display to show current selection"
              }
            ]
          },
          {
            "name": "insert_coin",
            "trigger": "when coin is inserted into machine",
            "actions": [
              {
                "action": "set has coin status to true"
              },
              {
                "action": "play coin insertion sound"
              },
              {
                "action": "illuminate purchase button"
              }
            ]
          },
          {
            "name": "purchase_item",
            "trigger": "when purchase button is pressed and machine has coin",
            "actions": [
              {
                "action": "set dispensing status to true"
              },
              {
                "action": "set has coin status to false"
              },
              {
                "action": "play dispensing motor sound"
              },
              {
                "action": "spawn selected item at dispenser slot"
              },
              {
                "action": "set dispensing status to false after delay"
              }
            ]
          },
          {
            "name": "reject_purchase",
            "trigger": "when purchase button is pressed and machine has no coin",
            "actions": [
              {
                "action": "play error buzzer sound"
              },
              {
                "action": "flash coin required message on display"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class VendingMachine : MonoBehaviour\n{\n    [System.Serializable]\n    public class VendingItem\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public GameObject itemPrefab;\n        public int price;\n        public int stock;\n        public string description;\n    }\n\n    [System.Serializable]\n    public class PurchaseEvent : UnityEvent<string, int> { }\n\n    [Header(\"Vending Machine Settings\")]\n    [SerializeField] private List<VendingItem> _availableItems = new List<VendingItem>();\n    [SerializeField] private Transform _dispensingPoint;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _vendingUI;\n    [SerializeField] private Transform _itemButtonContainer;\n    [SerializeField] private Button _itemButtonPrefab;\n    [SerializeField] private Text _moneyDisplay;\n    [SerializeField] private Text _messageDisplay;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _purchaseSound;\n    [SerializeField] private AudioClip _errorSound;\n    [SerializeField] private AudioClip _dispensingSound;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Animator _machineAnimator;\n    [SerializeField] private ParticleSystem _dispensingEffect;\n\n    [Header(\"Events\")]\n    public PurchaseEvent OnItemPurchased;\n\n    private bool _isPlayerNearby = false;\n    private GameObject _currentPlayer;\n    private int _playerMoney = 100;\n    private List<Button> _itemButtons = new List<Button>();\n    private VendingItem _selectedItem;\n    private bool _isDispensing = false;\n\n    private void Start()\n    {\n        InitializeUI();\n        SetupEventListeners();\n        UpdateMoneyDisplay();\n        \n        if (_vendingUI != null)\n            _vendingUI.gameObject.SetActive(false);\n    }\n\n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n    }\n\n    private void InitializeUI()\n    {\n        if (_itemButtonContainer == null || _itemButtonPrefab == null) return;\n\n        foreach (Transform child in _itemButtonContainer)\n        {\n            if (child != _itemButtonPrefab.transform)\n                DestroyImmediate(child.gameObject);\n        }\n\n        _itemButtons.Clear();\n\n        for (int i = 0; i < _availableItems.Count; i++)\n        {\n            VendingItem item = _availableItems[i];\n            Button itemButton = Instantiate(_itemButtonPrefab, _itemButtonContainer);\n            itemButton.gameObject.SetActive(true);\n\n            Text[] texts = itemButton.GetComponentsInChildren<Text>();\n            Image[] images = itemButton.GetComponentsInChildren<Image>();\n\n            if (texts.Length > 0) texts[0].text = item.itemName;\n            if (texts.Length > 1) texts[1].text = $\"${item.price}\";\n            if (texts.Length > 2) texts[2].text = $\"Stock: {item.stock}\";\n\n            if (images.Length > 1 && item.itemIcon != null)\n                images[1].sprite = item.itemIcon;\n\n            int index = i;\n            itemButton.onClick.AddListener(() => SelectItem(index));\n            \n            _itemButtons.Add(itemButton);\n        }\n\n        if (_itemButtonPrefab != null)\n            _itemButtonPrefab.gameObject.SetActive(false);\n    }\n\n    private void SetupEventListeners()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(CloseVendingMachine);\n    }\n\n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange, _playerLayer);\n        bool playerFound = false;\n\n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                if (!_isPlayerNearby)\n                {\n                    _isPlayerNearby = true;\n                    _currentPlayer = col.gameObject;\n                    ShowInteractionPrompt();\n                }\n                playerFound = true;\n                break;\n            }\n        }\n\n        if (!playerFound && _isPlayerNearby)\n        {\n            _isPlayerNearby = false;\n            _currentPlayer = null;\n            HideInteractionPrompt();\n            CloseVendingMachine();\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_isPlayerNearby && Input.GetKeyDown(KeyCode.E))\n        {\n            if (_vendingUI != null && !_vendingUI.gameObject.activeInHierarchy)\n            {\n                OpenVendingMachine();\n            }\n        }\n\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            CloseVendingMachine();\n        }\n    }\n\n    private void OpenVendingMachine()\n    {\n        if (_vendingUI != null)\n        {\n            _vendingUI.gameObject.SetActive(true);\n            Time.timeScale = 0f;\n            Cursor.lockState = CursorLockMode.None;\n            Cursor.visible = true;\n            \n            RefreshItemButtons();\n            ShowMessage(\"Select an item to purchase\");\n        }\n    }\n\n    private void CloseVendingMachine()\n    {\n        if (_vendingUI != null && _vendingUI.gameObject.activeInHierarchy)\n        {\n            _vendingUI.gameObject.SetActive(false);\n            Time.timeScale = 1f;\n            Cursor.lockState = CursorLockMode.Locked;\n            Cursor.visible = false;\n            _selectedItem = null;\n        }\n    }\n\n    private void SelectItem(int itemIndex)\n    {\n        if (itemIndex < 0 || itemIndex >= _availableItems.Count) return;\n\n        _selectedItem = _availableItems[itemIndex];\n        \n        if (_selectedItem.stock <= 0)\n        {\n            ShowMessage(\"Item out of stock!\");\n            PlayErrorSound();\n            return;\n        }\n\n        if (_playerMoney < _selectedItem.price)\n        {\n            ShowMessage(\"Insufficient funds!\");\n            PlayErrorSound();\n            return;\n        }\n\n        PurchaseItem(_selectedItem, itemIndex);\n    }\n\n    private void PurchaseItem(VendingItem item, int itemIndex)\n    {\n        if (_isDispensing) return;\n\n        _playerMoney -= item.price;\n        item.stock--;\n        \n        UpdateMoneyDisplay();\n        RefreshItemButtons();\n        \n        ShowMessage($\"Purchased {item.itemName}!\");\n        PlayPurchaseSound();\n        \n        StartCoroutine(DispenseItem(item));\n        \n        OnItemPurchased?.Invoke(item.itemName, item.price);\n    }\n\n    private IEnumerator DispenseItem(VendingItem item)\n    {\n        _isDispensing = true;\n\n        if (_machineAnimator != null)\n            _machineAnimator.SetTrigger(\"Dispense\");\n\n        yield return new WaitForSeconds(0.5f);\n\n        if (_dispensingEffect != null)\n            _dispensingEffect.Play();\n\n        if (_dispensingSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_dispensingSound);\n\n        yield return new WaitForSeconds(1f);\n\n        if (item.itemPrefab != null && _dispensingPoint != null)\n        {\n            GameObject dispensedItem = Instantiate(item.itemPrefab, _dispensingPoint.position, _dispensingPoint.rotation);\n            \n            Rigidbody rb = dispensedItem.GetComponent<Rigidbody>();\n            if (rb == null)\n                rb = dispensedItem.AddComponent<Rigidbody>();\n            \n            rb.AddForce(Vector3.forward * 2f + Vector3.down * 1f, ForceMode.Impulse);\n        }\n\n        _isDispensing = false;\n    }\n\n    private void RefreshItemButtons()\n    {\n        for (int i = 0; i < _itemButtons.Count && i < _availableItems.Count; i++)\n        {\n            VendingItem item = _availableItems[i];\n            Button button = _itemButtons[i];\n            \n            Text[] texts = button.GetComponentsInChildren<Text>();\n            if (texts.Length > 2)\n                texts[2].text = $\"Stock: {item.stock}\";\n\n            button.interactable = item.stock > 0 && _playerMoney >= item.price;\n            \n            if (item.stock <= 0)\n            {\n                button.GetComponent<Image>().color = Color.gray;\n            }\n            else if (_playerMoney < item.price)\n            {\n                button.GetComponent<Image>().color = Color.red;\n            }\n            else\n            {\n                button.GetComponent<Image>().color = Color.white;\n            }\n        }\n    }\n\n    private void UpdateMoneyDisplay()\n    {\n        if (_moneyDisplay != null)\n            _moneyDisplay.text = $\"Money: ${_playerMoney}\";\n    }\n\n    private void ShowMessage(string message)\n    {\n        if (_messageDisplay != null)\n        {\n            _messageDisplay.text = message;\n            StopCoroutine(nameof(ClearMessageAfterDelay));\n            StartCoroutine(ClearMessageAfterDelay());\n        }\n    }\n\n    private IEnumerator ClearMessageAfterDelay()\n    {\n        yield return new WaitForSecondsRealtime(3f);\n        if (_messageDisplay != null)\n            _messageDisplay.text = \"\";\n    }\n\n    private void ShowInteractionPrompt()\n    {\n        // Override this method to show interaction UI\n    }\n\n    private void HideInteractionPrompt()\n    {\n        // Override this method to hide interaction UI\n    }\n\n    private void PlayPurchaseSound()\n    {\n        if (_audioSource != null && _purchaseSound != null)\n            _audioSource.PlayOneShot(_purchaseSound);\n    }\n\n    private void PlayErrorSound()\n    {\n        if (_audioSource != null && _errorSound != null)\n            _audioSource.PlayOneShot(_errorSound);\n    }\n\n    public void AddMoney(int amount)\n    {\n        _playerMoney += amount;\n        UpdateMoneyDisplay();\n        RefreshItemButtons();\n    }\n\n    public void RestockItem(int itemIndex, int amount)\n    {\n        if (itemIndex >= 0 && itemIndex < _availableItems.Count)\n        {\n            _availableItems[itemIndex].stock += amount;\n            RefreshItemButtons();\n        }\n    }\n\n    public void RestockAllItems(int amount)\n    {\n        for (int i = 0; i < _availableItems.Count; i++)\n        {\n            _availableItems[i].stock += amount;\n        }\n        RefreshItemButtons();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_dispensingPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_dispensingPoint.position, Vector3.one * 0.2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "computer terminal with text",
      "ideal_ir": {
        "class_name": "ComputerTerminal",
        "components": [
          "Canvas",
          "Text",
          "Image",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "terminalText",
            "type": "string",
            "default": "SYSTEM READY"
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "typingSpeed",
            "type": "float",
            "default": 0.05
          },
          {
            "name": "screenGlow",
            "type": "Color",
            "default": "green"
          },
          {
            "name": "maxLines",
            "type": "int",
            "default": 20
          }
        ],
        "behaviors": [
          {
            "name": "activate_terminal",
            "trigger": "when player interacts with terminal",
            "actions": [
              {
                "action": "turn on screen display"
              },
              {
                "action": "play startup sound effect"
              },
              {
                "action": "begin displaying terminal text with typing effect"
              }
            ]
          },
          {
            "name": "type_text_effect",
            "trigger": "when displaying new text",
            "actions": [
              {
                "action": "reveal characters one by one at typing speed"
              },
              {
                "action": "play keyboard typing sound for each character"
              },
              {
                "action": "add cursor blinking effect at end of current line"
              }
            ]
          },
          {
            "name": "scroll_text",
            "trigger": "when text exceeds maximum visible lines",
            "actions": [
              {
                "action": "scroll older text upward"
              },
              {
                "action": "remove oldest lines from display"
              },
              {
                "action": "keep newest text at bottom of screen"
              }
            ]
          },
          {
            "name": "screen_flicker",
            "trigger": "randomly while terminal is active",
            "actions": [
              {
                "action": "briefly dim screen brightness"
              },
              {
                "action": "add slight static visual effect"
              },
              {
                "action": "play subtle electrical humming sound"
              }
            ]
          },
          {
            "name": "deactivate_terminal",
            "trigger": "when player moves away from interaction range",
            "actions": [
              {
                "action": "fade screen to black"
              },
              {
                "action": "stop all terminal sounds"
              },
              {
                "action": "reset text display to initial state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ComputerTerminal : MonoBehaviour\n{\n    [Header(\"Terminal Display\")]\n    [SerializeField] private Canvas _terminalCanvas;\n    [SerializeField] private Text _terminalText;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private InputField _inputField;\n    [SerializeField] private Button _submitButton;\n    \n    [Header(\"Terminal Settings\")]\n    [SerializeField] private float _typewriterSpeed = 0.05f;\n    [SerializeField] private int _maxLines = 20;\n    [SerializeField] private string _promptSymbol = \"> \";\n    [SerializeField] private Color _inputColor = Color.green;\n    [SerializeField] private Color _outputColor = Color.white;\n    [SerializeField] private Color _errorColor = Color.red;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private GameObject _interactionPrompt;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _keyPressSound;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _errorSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTerminalActivated;\n    public UnityEvent OnTerminalDeactivated;\n    public UnityEvent<string> OnCommandExecuted;\n    \n    private List<string> _terminalLines = new List<string>();\n    private Dictionary<string, System.Action<string[]>> _commands = new Dictionary<string, System.Action<string[]>>();\n    private Transform _player;\n    private bool _isActive = false;\n    private bool _isTyping = false;\n    private Coroutine _typewriterCoroutine;\n    \n    [System.Serializable]\n    public class TerminalCommand\n    {\n        public string command;\n        public string description;\n        public string response;\n    }\n    \n    [Header(\"Predefined Commands\")]\n    [SerializeField] private TerminalCommand[] _predefinedCommands = new TerminalCommand[]\n    {\n        new TerminalCommand { command = \"help\", description = \"Show available commands\", response = \"\" },\n        new TerminalCommand { command = \"clear\", description = \"Clear terminal screen\", response = \"\" },\n        new TerminalCommand { command = \"status\", description = \"Show system status\", response = \"System Status: ONLINE\\nCPU Usage: 23%\\nMemory: 4.2GB/8GB\" },\n        new TerminalCommand { command = \"date\", description = \"Show current date\", response = \"\" },\n        new TerminalCommand { command = \"whoami\", description = \"Show current user\", response = \"User: Administrator\" }\n    };\n    \n    void Start()\n    {\n        InitializeTerminal();\n        SetupCommands();\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n        \n        if (_submitButton != null)\n            _submitButton.onClick.AddListener(ProcessInput);\n            \n        if (_inputField != null)\n        {\n            _inputField.onEndEdit.AddListener(OnInputEndEdit);\n        }\n    }\n    \n    void Update()\n    {\n        CheckPlayerDistance();\n        HandleInput();\n    }\n    \n    void InitializeTerminal()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        AddLine(\"Terminal initialized...\", _outputColor);\n        AddLine(\"Type 'help' for available commands\", _outputColor);\n        AddLine(\"\", _outputColor);\n    }\n    \n    void SetupCommands()\n    {\n        _commands.Clear();\n        _commands.Add(\"help\", ExecuteHelp);\n        _commands.Add(\"clear\", ExecuteClear);\n        _commands.Add(\"status\", ExecuteStatus);\n        _commands.Add(\"date\", ExecuteDate);\n        _commands.Add(\"whoami\", ExecuteWhoAmI);\n        _commands.Add(\"echo\", ExecuteEcho);\n        _commands.Add(\"exit\", ExecuteExit);\n        \n        foreach (var cmd in _predefinedCommands)\n        {\n            if (!_commands.ContainsKey(cmd.command.ToLower()))\n            {\n                _commands.Add(cmd.command.ToLower(), (args) => ExecuteCustomCommand(cmd));\n            }\n        }\n    }\n    \n    void CheckPlayerDistance()\n    {\n        if (_player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        bool inRange = distance <= _interactionDistance;\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(inRange && !_isActive);\n    }\n    \n    void HandleInput()\n    {\n        if (_player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        \n        if (distance <= _interactionDistance && Input.GetKeyDown(_interactionKey))\n        {\n            if (!_isActive)\n                ActivateTerminal();\n            else\n                DeactivateTerminal();\n        }\n        \n        if (_isActive && Input.GetKeyDown(KeyCode.Escape))\n        {\n            DeactivateTerminal();\n        }\n    }\n    \n    void OnInputEndEdit(string input)\n    {\n        if (Input.GetKeyDown(KeyCode.Return) || Input.GetKeyDown(KeyCode.KeypadEnter))\n        {\n            ProcessInput();\n        }\n    }\n    \n    void ActivateTerminal()\n    {\n        _isActive = true;\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(true);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n        \n        if (_inputField != null)\n        {\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n        \n        OnTerminalActivated.Invoke();\n    }\n    \n    void DeactivateTerminal()\n    {\n        _isActive = false;\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n            \n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n        \n        OnTerminalDeactivated.Invoke();\n    }\n    \n    void ProcessInput()\n    {\n        if (_inputField == null || string.IsNullOrEmpty(_inputField.text.Trim()) || _isTyping)\n            return;\n            \n        string input = _inputField.text.Trim();\n        AddLine(_promptSymbol + input, _inputColor);\n        \n        PlaySound(_enterSound);\n        \n        string[] parts = input.ToLower().Split(' ');\n        string command = parts[0];\n        \n        if (_commands.ContainsKey(command))\n        {\n            _commands[command](parts);\n            OnCommandExecuted.Invoke(input);\n        }\n        else\n        {\n            AddLine($\"Command '{command}' not recognized. Type 'help' for available commands.\", _errorColor);\n            PlaySound(_errorSound);\n        }\n        \n        _inputField.text = \"\";\n        _inputField.Select();\n        _inputField.ActivateInputField();\n    }\n    \n    void AddLine(string text, Color color)\n    {\n        if (_isTyping && _typewriterCoroutine != null)\n        {\n            StopCoroutine(_typewriterCoroutine);\n            _isTyping = false;\n        }\n        \n        _terminalLines.Add($\"<color=#{ColorUtility.ToHtmlStringRGB(color)}>{text}</color>\");\n        \n        while (_terminalLines.Count > _maxLines)\n        {\n            _terminalLines.RemoveAt(0);\n        }\n        \n        if (_typewriterSpeed > 0)\n        {\n            _typewriterCoroutine = StartCoroutine(TypewriterEffect());\n        }\n        else\n        {\n            UpdateTerminalDisplay();\n        }\n    }\n    \n    void AddLineWithTypewriter(string text, Color color)\n    {\n        _typewriterCoroutine = StartCoroutine(TypewriterLine(text, color));\n    }\n    \n    IEnumerator TypewriterLine(string text, Color color)\n    {\n        _isTyping = true;\n        string coloredText = $\"<color=#{ColorUtility.ToHtmlStringRGB(color)}>\";\n        _terminalLines.Add(coloredText);\n        \n        for (int i = 0; i < text.Length; i++)\n        {\n            _terminalLines[_terminalLines.Count - 1] = coloredText + text.Substring(0, i + 1) + \"</color>\";\n            UpdateTerminalDisplay();\n            \n            if (_keyPressSound != null && i % 3 == 0)\n                PlaySound(_keyPressSound);\n                \n            yield return new WaitForSeconds(_typewriterSpeed);\n        }\n        \n        _isTyping = false;\n    }\n    \n    IEnumerator TypewriterEffect()\n    {\n        _isTyping = true;\n        yield return new WaitForSeconds(_typewriterSpeed);\n        UpdateTerminalDisplay();\n        _isTyping = false;\n    }\n    \n    void UpdateTerminalDisplay()\n    {\n        if (_terminalText != null)\n        {\n            _terminalText.text = string.Join(\"\\n\", _terminalLines);\n            \n            if (_scrollRect != null)\n            {\n                Canvas.ForceUpdateCanvases();\n                _scrollRect.verticalNormalizedPosition = 0f;\n            }\n        }\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    // Command Implementations\n    void ExecuteHelp(string[] args)\n    {\n        AddLine(\"Available Commands:\", _outputColor);\n        AddLine(\"==================\", _outputColor);\n        \n        foreach (var cmd in _predefinedCommands)\n        {\n            AddLine($\"{cmd.command.PadRight(12)} - {cmd.description}\", _outputColor);\n        }\n        \n        AddLine(\"echo [text]  - Echo text back\", _outputColor);\n        AddLine(\"exit         - Close terminal\", _outputColor);\n    }\n    \n    void ExecuteClear(string[] args)\n    {\n        _terminalLines.Clear();\n        UpdateTerminalDisplay();\n    }\n    \n    void ExecuteStatus(string[] args)\n    {\n        var statusCmd = System.Array.Find(_predefinedCommands, cmd => cmd.command == \"status\");\n        if (statusCmd != null && !string.IsNullOrEmpty(statusCmd.response))\n        {\n            string[] lines = statusCmd.response.Split('\\n');\n            foreach (string line in lines)\n            {\n                AddLine(line, _outputColor);\n            }\n        }\n    }\n    \n    void ExecuteDate(string[] args)\n    {\n        AddLine(System.DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), _outputColor);\n    }\n    \n    void ExecuteWhoAmI(string[] args)\n    {\n        var whoamiCmd = System.Array.Find(_predefinedCommands, cmd => cmd.command == \"whoami\");\n        if (whoamiCmd != null && !string.IsNullOrEmpty(whoamiCmd.response))\n        {\n            AddLine(whoamiCmd.response, _outputColor);\n        }\n    }\n    \n    void ExecuteEcho(string[] args)\n    {\n        if (args.Length > 1)\n        {\n            string echoText = string.Join(\" \", args, 1, args.Length - 1);\n            AddLine(echoText, _outputColor);\n        }\n        else\n        {\n            AddLine(\"Usage: echo [text]\", _errorColor);\n        }\n    }\n    \n    void ExecuteExit(string[] args)\n    {\n        AddLine(\"Closing terminal...\", _outputColor);\n        StartCoroutine(DelayedDeactivate());\n    }\n    \n    void ExecuteCustomCommand(TerminalCommand cmd)\n    {\n        if (!string.IsNullOrEmpty(cmd.response))\n        {\n            string[] lines = cmd.response.Split('\\n');\n            foreach (string line in lines)\n            {\n                AddLine(line, _outputColor);\n            }\n        }\n    }\n    \n    IEnumerator DelayedDeactivate()\n    {\n        yield return new WaitForSeconds(1f);\n        DeactivateTerminal();\n    }\n    \n    public void AddCustomCommand(string command, string description, string response)\n    {\n        var newCommand = new TerminalCommand\n        {\n            command = command.ToLower(),\n            description = description,\n            response = response\n        };\n        \n        _commands[command.ToLower()] = (args) => ExecuteCustomCommand(newCommand);\n    }\n    \n    public void ExecuteCommand(string commandLine)\n    {\n        if (_inputField != null)\n        {\n            _inputField.text = commandLine;\n            ProcessInput();\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "radio that plays music",
      "ideal_ir": {
        "class_name": "Radio",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isPlaying",
            "type": "bool",
            "default": false
          },
          {
            "name": "volume",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "musicClips",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "currentClipIndex",
            "type": "int",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "toggle_music",
            "trigger": "when player interacts with radio",
            "actions": [
              {
                "action": "if radio is currently playing then stop the music"
              },
              {
                "action": "if radio is not playing then start playing current music clip"
              },
              {
                "action": "toggle the playing state"
              }
            ]
          },
          {
            "name": "change_station",
            "trigger": "when player presses next station button",
            "actions": [
              {
                "action": "stop current music"
              },
              {
                "action": "move to next music clip in the list"
              },
              {
                "action": "if at end of list then go back to first clip"
              },
              {
                "action": "start playing the new music clip"
              }
            ]
          },
          {
            "name": "adjust_volume",
            "trigger": "when player adjusts volume control",
            "actions": [
              {
                "action": "change the audio volume based on player input"
              },
              {
                "action": "clamp volume between zero and maximum"
              }
            ]
          },
          {
            "name": "auto_next_song",
            "trigger": "when current music clip finishes playing",
            "actions": [
              {
                "action": "move to next music clip in the list"
              },
              {
                "action": "if at end of list then go back to first clip"
              },
              {
                "action": "start playing the new music clip automatically"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Radio : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _musicTracks;\n    [SerializeField] private float _volume = 0.7f;\n    [SerializeField] private bool _playOnStart = false;\n    [SerializeField] private bool _shuffleMode = false;\n    [SerializeField] private bool _loopPlaylist = true;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool _canPlayerInteract = true;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _powerIndicator;\n    [SerializeField] private Light _radioLight;\n    [SerializeField] private Color _onColor = Color.green;\n    [SerializeField] private Color _offColor = Color.red;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRadioTurnedOn;\n    public UnityEvent OnRadioTurnedOff;\n    public UnityEvent OnTrackChanged;\n    \n    private bool _isPlaying = false;\n    private int _currentTrackIndex = 0;\n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        InitializeRadio();\n        \n        if (_playOnStart && _musicTracks.Length > 0)\n        {\n            TurnOn();\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        CheckTrackCompletion();\n    }\n    \n    private void InitializeRadio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.volume = _volume;\n        _audioSource.loop = false;\n        _audioSource.playOnAwake = false;\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (!_canPlayerInteract || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        _playerInRange = distanceToPlayer <= _interactionRange;\n        \n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            ToggleRadio();\n        }\n    }\n    \n    private void CheckTrackCompletion()\n    {\n        if (_isPlaying && !_audioSource.isPlaying && _musicTracks.Length > 0)\n        {\n            PlayNextTrack();\n        }\n    }\n    \n    public void ToggleRadio()\n    {\n        if (_isPlaying)\n        {\n            TurnOff();\n        }\n        else\n        {\n            TurnOn();\n        }\n    }\n    \n    public void TurnOn()\n    {\n        if (_musicTracks.Length == 0) return;\n        \n        _isPlaying = true;\n        PlayCurrentTrack();\n        UpdateVisualFeedback();\n        OnRadioTurnedOn?.Invoke();\n    }\n    \n    public void TurnOff()\n    {\n        _isPlaying = false;\n        _audioSource.Stop();\n        UpdateVisualFeedback();\n        OnRadioTurnedOff?.Invoke();\n    }\n    \n    private void PlayCurrentTrack()\n    {\n        if (_musicTracks.Length == 0 || _currentTrackIndex >= _musicTracks.Length) return;\n        \n        _audioSource.clip = _musicTracks[_currentTrackIndex];\n        _audioSource.Play();\n        OnTrackChanged?.Invoke();\n    }\n    \n    private void PlayNextTrack()\n    {\n        if (_shuffleMode)\n        {\n            _currentTrackIndex = Random.Range(0, _musicTracks.Length);\n        }\n        else\n        {\n            _currentTrackIndex++;\n            if (_currentTrackIndex >= _musicTracks.Length)\n            {\n                if (_loopPlaylist)\n                {\n                    _currentTrackIndex = 0;\n                }\n                else\n                {\n                    TurnOff();\n                    return;\n                }\n            }\n        }\n        \n        PlayCurrentTrack();\n    }\n    \n    public void NextTrack()\n    {\n        if (!_isPlaying || _musicTracks.Length <= 1) return;\n        \n        _audioSource.Stop();\n        PlayNextTrack();\n    }\n    \n    public void PreviousTrack()\n    {\n        if (!_isPlaying || _musicTracks.Length <= 1) return;\n        \n        _currentTrackIndex--;\n        if (_currentTrackIndex < 0)\n        {\n            _currentTrackIndex = _musicTracks.Length - 1;\n        }\n        \n        _audioSource.Stop();\n        PlayCurrentTrack();\n    }\n    \n    public void SetVolume(float volume)\n    {\n        _volume = Mathf.Clamp01(volume);\n        _audioSource.volume = _volume;\n    }\n    \n    public void SetShuffleMode(bool shuffle)\n    {\n        _shuffleMode = shuffle;\n    }\n    \n    public void SetLoopMode(bool loop)\n    {\n        _loopPlaylist = loop;\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_powerIndicator != null)\n        {\n            _powerIndicator.SetActive(_isPlaying);\n        }\n        \n        if (_radioLight != null)\n        {\n            _radioLight.color = _isPlaying ? _onColor : _offColor;\n            _radioLight.enabled = _isPlaying;\n        }\n    }\n    \n    public bool IsPlaying => _isPlaying;\n    public string CurrentTrackName => _musicTracks.Length > 0 && _currentTrackIndex < _musicTracks.Length ? _musicTracks[_currentTrackIndex].name : \"None\";\n    public int CurrentTrackIndex => _currentTrackIndex;\n    public int TotalTracks => _musicTracks.Length;\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_canPlayerInteract)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mirror that reflects",
      "ideal_ir": {
        "class_name": "Mirror",
        "components": [
          "MeshRenderer",
          "MeshCollider"
        ],
        "fields": [
          {
            "name": "reflectionIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "reflectionQuality",
            "type": "int",
            "default": 512
          }
        ],
        "behaviors": [
          {
            "name": "create_reflection",
            "trigger": "when camera approaches mirror",
            "actions": [
              {
                "action": "create reflection camera that mirrors main camera position and rotation"
              },
              {
                "action": "render scene from reflection camera perspective"
              },
              {
                "action": "apply rendered image to mirror surface as texture"
              }
            ]
          },
          {
            "name": "update_reflection",
            "trigger": "every frame while camera is near",
            "actions": [
              {
                "action": "update reflection camera to match main camera movement"
              },
              {
                "action": "flip reflection camera orientation across mirror plane"
              },
              {
                "action": "refresh reflection texture on mirror surface"
              }
            ]
          },
          {
            "name": "optimize_reflection",
            "trigger": "when camera moves far from mirror",
            "actions": [
              {
                "action": "disable reflection rendering to save performance"
              },
              {
                "action": "show static reflection texture or disable reflection entirely"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\n\npublic class Mirror : MonoBehaviour\n{\n    [Header(\"Mirror Settings\")]\n    [SerializeField] private Camera _mirrorCamera;\n    [SerializeField] private RenderTexture _mirrorTexture;\n    [SerializeField] private Material _mirrorMaterial;\n    [SerializeField] private int _textureSize = 512;\n    [SerializeField] private LayerMask _reflectionLayers = -1;\n    [SerializeField] private bool _disablePixelLights = true;\n    [SerializeField] private float _clipPlaneOffset = 0.07f;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private bool _useOcclusionCulling = true;\n    [SerializeField] private float _maxRenderDistance = 100f;\n    [SerializeField] private int _maxReflectionFPS = 30;\n    \n    private Camera _mainCamera;\n    private float _lastRenderTime;\n    private Vector4 _reflectionPlane;\n    private Matrix4x4 _reflectionMatrix;\n    private bool _isRendering;\n\n    void Start()\n    {\n        SetupMirror();\n    }\n\n    void Update()\n    {\n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n            \n        if (_mainCamera != null && ShouldRender())\n        {\n            RenderMirror();\n        }\n    }\n\n    void SetupMirror()\n    {\n        if (_mirrorTexture == null)\n        {\n            _mirrorTexture = new RenderTexture(_textureSize, _textureSize, 16, RenderTextureFormat.ARGB32);\n            _mirrorTexture.name = \"MirrorTexture_\" + GetInstanceID();\n            _mirrorTexture.isPowerOfTwo = true;\n            _mirrorTexture.hideFlags = HideFlags.DontSave;\n        }\n\n        if (_mirrorCamera == null)\n        {\n            GameObject cameraObject = new GameObject(\"MirrorCamera_\" + GetInstanceID());\n            cameraObject.transform.SetParent(transform);\n            _mirrorCamera = cameraObject.AddComponent<Camera>();\n            _mirrorCamera.enabled = false;\n            _mirrorCamera.targetTexture = _mirrorTexture;\n        }\n\n        if (_mirrorMaterial == null)\n        {\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                _mirrorMaterial = renderer.material;\n            }\n        }\n\n        if (_mirrorMaterial != null)\n        {\n            _mirrorMaterial.mainTexture = _mirrorTexture;\n        }\n\n        CalculateReflectionPlane();\n    }\n\n    bool ShouldRender()\n    {\n        if (_isRendering || _mainCamera == null || _mirrorCamera == null)\n            return false;\n\n        float distance = Vector3.Distance(_mainCamera.transform.position, transform.position);\n        if (distance > _maxRenderDistance)\n            return false;\n\n        float timeSinceLastRender = Time.time - _lastRenderTime;\n        float minInterval = 1f / _maxReflectionFPS;\n        \n        return timeSinceLastRender >= minInterval;\n    }\n\n    void RenderMirror()\n    {\n        _isRendering = true;\n        _lastRenderTime = Time.time;\n\n        Vector3 cameraPosition = _mainCamera.transform.position;\n        Vector3 cameraDirection = _mainCamera.transform.forward;\n\n        Vector3 reflectedPosition = ReflectPosition(cameraPosition);\n        Vector3 reflectedDirection = ReflectDirection(cameraDirection);\n\n        _mirrorCamera.transform.position = reflectedPosition;\n        _mirrorCamera.transform.LookAt(reflectedPosition + reflectedDirection, Vector3.up);\n\n        _mirrorCamera.fieldOfView = _mainCamera.fieldOfView;\n        _mirrorCamera.aspect = _mainCamera.aspect;\n        _mirrorCamera.nearClipPlane = _mainCamera.nearClipPlane;\n        _mirrorCamera.farClipPlane = _mainCamera.farClipPlane;\n        _mirrorCamera.cullingMask = _reflectionLayers;\n        _mirrorCamera.useOcclusionCulling = _useOcclusionCulling;\n\n        if (_disablePixelLights)\n            _mirrorCamera.renderingPath = RenderingPath.VertexLit;\n\n        SetupClipPlane();\n\n        GL.invertCulling = true;\n        _mirrorCamera.Render();\n        GL.invertCulling = false;\n\n        _isRendering = false;\n    }\n\n    void CalculateReflectionPlane()\n    {\n        Vector3 normal = transform.up;\n        Vector3 position = transform.position;\n        float distance = -Vector3.Dot(normal, position);\n        _reflectionPlane = new Vector4(normal.x, normal.y, normal.z, distance);\n    }\n\n    Vector3 ReflectPosition(Vector3 position)\n    {\n        Vector3 normal = new Vector3(_reflectionPlane.x, _reflectionPlane.y, _reflectionPlane.z);\n        float distance = Vector3.Dot(normal, position) + _reflectionPlane.w;\n        return position - 2f * distance * normal;\n    }\n\n    Vector3 ReflectDirection(Vector3 direction)\n    {\n        Vector3 normal = new Vector3(_reflectionPlane.x, _reflectionPlane.y, _reflectionPlane.z);\n        return Vector3.Reflect(direction, normal);\n    }\n\n    void SetupClipPlane()\n    {\n        Vector3 normal = transform.up;\n        Vector3 position = transform.position + normal * _clipPlaneOffset;\n        \n        Vector4 clipPlane = new Vector4(normal.x, normal.y, normal.z, -Vector3.Dot(position, normal));\n        \n        Matrix4x4 projection = _mirrorCamera.CalculateObliqueMatrix(clipPlane);\n        _mirrorCamera.projectionMatrix = projection;\n    }\n\n    void OnValidate()\n    {\n        if (_textureSize < 64) _textureSize = 64;\n        if (_textureSize > 2048) _textureSize = 2048;\n        if (_maxReflectionFPS < 1) _maxReflectionFPS = 1;\n        if (_maxReflectionFPS > 60) _maxReflectionFPS = 60;\n    }\n\n    void OnDestroy()\n    {\n        if (_mirrorTexture != null)\n        {\n            DestroyImmediate(_mirrorTexture);\n        }\n        \n        if (_mirrorCamera != null)\n        {\n            DestroyImmediate(_mirrorCamera.gameObject);\n        }\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(Vector3.zero, Vector3.up * 2f);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "painting that reveals secret",
      "ideal_ir": {
        "class_name": "SecretRevealingPainting",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isSecretRevealed",
            "type": "bool",
            "default": false
          },
          {
            "name": "revealDistance",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "revealSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "secretObject",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "normalTexture",
            "type": "Texture",
            "default": null
          },
          {
            "name": "secretTexture",
            "type": "Texture",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "reveal_secret_on_approach",
            "trigger": "when player comes within reveal distance",
            "actions": [
              {
                "action": "change painting texture to secret texture"
              },
              {
                "action": "make secret object visible"
              },
              {
                "action": "play reveal sound effect"
              },
              {
                "action": "set secret revealed flag to true"
              }
            ]
          },
          {
            "name": "hide_secret_on_distance",
            "trigger": "when player moves away beyond reveal distance and secret is currently revealed",
            "actions": [
              {
                "action": "change painting texture back to normal texture"
              },
              {
                "action": "make secret object invisible"
              },
              {
                "action": "set secret revealed flag to false"
              }
            ]
          },
          {
            "name": "interact_with_painting",
            "trigger": "when player clicks on painting while close enough",
            "actions": [
              {
                "action": "toggle between normal and secret texture"
              },
              {
                "action": "toggle secret object visibility"
              },
              {
                "action": "play interaction sound"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SecretRevealingPainting : MonoBehaviour\n{\n    [Header(\"Painting Settings\")]\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Secret Reveal\")]\n    [SerializeField] private GameObject _secretObject;\n    [SerializeField] private Transform _secretRevealPosition;\n    [SerializeField] private float _revealDuration = 2f;\n    [SerializeField] private AnimationCurve _revealCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _revealParticles;\n    [SerializeField] private Light _mysticalLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _revealSound;\n    [SerializeField] private Material _glowMaterial;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private string _promptText = \"Press E to examine painting\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSecretRevealed;\n    public UnityEvent OnPlayerNearby;\n    public UnityEvent OnPlayerLeft;\n    \n    private bool _secretRevealed = false;\n    private bool _isRevealing = false;\n    private bool _playerNearby = false;\n    private Transform _playerTransform;\n    private Renderer _paintingRenderer;\n    private Material _originalMaterial;\n    private Vector3 _originalSecretPosition;\n    private Vector3 _originalSecretScale;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupSecret();\n        SetupUI();\n    }\n    \n    private void InitializeComponents()\n    {\n        _paintingRenderer = GetComponent<Renderer>();\n        if (_paintingRenderer != null)\n        {\n            _originalMaterial = _paintingRenderer.material;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = false;\n        }\n    }\n    \n    private void SetupSecret()\n    {\n        if (_secretObject != null)\n        {\n            _originalSecretPosition = _secretObject.transform.position;\n            _originalSecretScale = _secretObject.transform.localScale;\n            \n            if (_secretRevealPosition == null)\n            {\n                _secretRevealPosition = transform;\n            }\n            \n            _secretObject.transform.localScale = Vector3.zero;\n            _secretObject.SetActive(false);\n        }\n    }\n    \n    private void SetupUI()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _interactionDistance, _playerLayer);\n        bool playerFound = false;\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                playerFound = true;\n                _playerTransform = col.transform;\n                \n                if (!_playerNearby)\n                {\n                    OnPlayerEntered();\n                }\n                break;\n            }\n        }\n        \n        if (!playerFound && _playerNearby)\n        {\n            OnPlayerExited();\n        }\n    }\n    \n    private void OnPlayerEntered()\n    {\n        _playerNearby = true;\n        \n        if (_interactionPrompt != null && !_secretRevealed)\n        {\n            _interactionPrompt.SetActive(true);\n        }\n        \n        OnPlayerNearby?.Invoke();\n    }\n    \n    private void OnPlayerExited()\n    {\n        _playerNearby = false;\n        _playerTransform = null;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        OnPlayerLeft?.Invoke();\n    }\n    \n    private void HandleInput()\n    {\n        if (_playerNearby && !_secretRevealed && !_isRevealing && Input.GetKeyDown(_interactionKey))\n        {\n            RevealSecret();\n        }\n    }\n    \n    private void RevealSecret()\n    {\n        if (_secretRevealed || _isRevealing) return;\n        \n        _isRevealing = true;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        StartCoroutine(RevealSequence());\n    }\n    \n    private System.Collections.IEnumerator RevealSequence()\n    {\n        // Start visual effects\n        if (_revealParticles != null)\n        {\n            _revealParticles.Play();\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = true;\n        }\n        \n        // Play sound\n        if (_audioSource != null && _revealSound != null)\n        {\n            _audioSource.PlayOneShot(_revealSound);\n        }\n        \n        // Change painting material\n        if (_paintingRenderer != null && _glowMaterial != null)\n        {\n            _paintingRenderer.material = _glowMaterial;\n        }\n        \n        // Reveal secret object\n        if (_secretObject != null)\n        {\n            _secretObject.SetActive(true);\n            _secretObject.transform.position = _secretRevealPosition.position;\n            \n            float elapsedTime = 0f;\n            \n            while (elapsedTime < _revealDuration)\n            {\n                elapsedTime += Time.deltaTime;\n                float progress = elapsedTime / _revealDuration;\n                float curveValue = _revealCurve.Evaluate(progress);\n                \n                _secretObject.transform.localScale = Vector3.Lerp(Vector3.zero, _originalSecretScale, curveValue);\n                \n                if (_mysticalLight != null)\n                {\n                    _mysticalLight.intensity = Mathf.Lerp(0f, 2f, curveValue);\n                }\n                \n                yield return null;\n            }\n            \n            _secretObject.transform.localScale = _originalSecretScale;\n        }\n        \n        _secretRevealed = true;\n        _isRevealing = false;\n        \n        OnSecretRevealed?.Invoke();\n        \n        // Fade out light after reveal\n        if (_mysticalLight != null)\n        {\n            StartCoroutine(FadeLight());\n        }\n    }\n    \n    private System.Collections.IEnumerator FadeLight()\n    {\n        yield return new WaitForSeconds(1f);\n        \n        float startIntensity = _mysticalLight.intensity;\n        float elapsedTime = 0f;\n        float fadeDuration = 2f;\n        \n        while (elapsedTime < fadeDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / fadeDuration;\n            \n            _mysticalLight.intensity = Mathf.Lerp(startIntensity, 0.5f, progress);\n            \n            yield return null;\n        }\n    }\n    \n    public void ResetPainting()\n    {\n        _secretRevealed = false;\n        _isRevealing = false;\n        \n        if (_secretObject != null)\n        {\n            _secretObject.SetActive(false);\n            _secretObject.transform.position = _originalSecretPosition;\n            _secretObject.transform.localScale = Vector3.zero;\n        }\n        \n        if (_paintingRenderer != null && _originalMaterial != null)\n        {\n            _paintingRenderer.material = _originalMaterial;\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = false;\n        }\n        \n        if (_revealParticles != null)\n        {\n            _revealParticles.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n        \n        if (_secretRevealPosition != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_secretRevealPosition.position, Vector3.one * 0.5f);\n            Gizmos.DrawLine(transform.position, _secretRevealPosition.position);\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "bookshelf with hidden switch",
      "ideal_ir": {
        "class_name": "HiddenSwitchBookshelf",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "requiredBook",
            "type": "string",
            "default": "red_book"
          },
          {
            "name": "activationSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "secretDoorTarget",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_book_interaction",
            "trigger": "when player interacts with the correct book on the shelf",
            "actions": [
              {
                "action": "play mechanical clicking sound"
              },
              {
                "action": "mark switch as activated"
              },
              {
                "action": "send activation signal to connected secret door"
              },
              {
                "action": "slightly move the book inward to show it has been pressed"
              }
            ]
          },
          {
            "name": "wrong_book_interaction",
            "trigger": "when player interacts with any incorrect book on the shelf",
            "actions": [
              {
                "action": "play soft book sliding sound"
              },
              {
                "action": "briefly move the book outward then return to original position"
              }
            ]
          },
          {
            "name": "reset_switch",
            "trigger": "when reset signal is received from game manager",
            "actions": [
              {
                "action": "mark switch as not activated"
              },
              {
                "action": "return the correct book to its original position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class BookshelfHiddenSwitch : MonoBehaviour\n{\n    [Header(\"Bookshelf Settings\")]\n    [SerializeField] private Transform _bookshelf;\n    [SerializeField] private Transform _hiddenBook;\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _bookPullDistance = 0.2f;\n    [SerializeField] private float _animationDuration = 1f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _bookPullSound;\n    [SerializeField] private AudioClip _switchActivateSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _highlightEffect;\n    [SerializeField] private ParticleSystem _activationParticles;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSwitchActivated;\n    public UnityEvent OnSwitchDeactivated;\n    \n    private bool _isActivated = false;\n    private bool _isAnimating = false;\n    private bool _playerInRange = false;\n    private Vector3 _originalBookPosition;\n    private Vector3 _pulledBookPosition;\n    private Camera _playerCamera;\n    private Collider _bookCollider;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupPositions();\n        SetupAudio();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_hiddenBook == null)\n            _hiddenBook = transform.GetChild(0);\n            \n        if (_bookshelf == null)\n            _bookshelf = transform;\n            \n        _bookCollider = _hiddenBook.GetComponent<Collider>();\n        if (_bookCollider == null)\n            _bookCollider = _hiddenBook.gameObject.AddComponent<BoxCollider>();\n            \n        _playerCamera = Camera.main;\n        \n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n    \n    private void SetupPositions()\n    {\n        _originalBookPosition = _hiddenBook.localPosition;\n        _pulledBookPosition = _originalBookPosition + _hiddenBook.forward * _bookPullDistance;\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        bool wasInRange = _playerInRange;\n        _playerInRange = false;\n        \n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _interactionDistance, _playerLayer);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n                break;\n            }\n        }\n        \n        if (_playerInRange != wasInRange)\n        {\n            if (_highlightEffect != null)\n                _highlightEffect.SetActive(_playerInRange && !_isActivated);\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (!_playerInRange || _isAnimating)\n            return;\n            \n        if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(0))\n        {\n            if (IsLookingAtBook())\n            {\n                ToggleSwitch();\n            }\n        }\n    }\n    \n    private bool IsLookingAtBook()\n    {\n        if (_playerCamera == null)\n            return true;\n            \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _interactionDistance))\n        {\n            return hit.collider == _bookCollider;\n        }\n        \n        return false;\n    }\n    \n    private void ToggleSwitch()\n    {\n        if (_isAnimating)\n            return;\n            \n        _isActivated = !_isActivated;\n        StartCoroutine(AnimateBook());\n        \n        if (_isActivated)\n        {\n            PlaySound(_switchActivateSound);\n            OnSwitchActivated?.Invoke();\n            \n            if (_activationParticles != null)\n                _activationParticles.Play();\n        }\n        else\n        {\n            PlaySound(_bookPullSound);\n            OnSwitchDeactivated?.Invoke();\n        }\n        \n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n    \n    private System.Collections.IEnumerator AnimateBook()\n    {\n        _isAnimating = true;\n        \n        Vector3 startPosition = _hiddenBook.localPosition;\n        Vector3 targetPosition = _isActivated ? _pulledBookPosition : _originalBookPosition;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _animationDuration;\n            float curveValue = _animationCurve.Evaluate(progress);\n            \n            _hiddenBook.localPosition = Vector3.Lerp(startPosition, targetPosition, curveValue);\n            \n            yield return null;\n        }\n        \n        _hiddenBook.localPosition = targetPosition;\n        _isAnimating = false;\n        \n        if (_highlightEffect != null && _playerInRange && !_isActivated)\n            _highlightEffect.SetActive(true);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    public void ResetSwitch()\n    {\n        if (_isAnimating)\n            return;\n            \n        _isActivated = false;\n        _hiddenBook.localPosition = _originalBookPosition;\n        \n        if (_highlightEffect != null && _playerInRange)\n            _highlightEffect.SetActive(true);\n    }\n    \n    public void ForceActivate()\n    {\n        if (_isAnimating || _isActivated)\n            return;\n            \n        _isActivated = true;\n        _hiddenBook.localPosition = _pulledBookPosition;\n        OnSwitchActivated?.Invoke();\n        \n        if (_activationParticles != null)\n            _activationParticles.Play();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n        \n        if (_hiddenBook != null)\n        {\n            Gizmos.color = Color.red;\n            Vector3 pullDirection = _hiddenBook.forward * _bookPullDistance;\n            Gizmos.DrawLine(_hiddenBook.position, _hiddenBook.position + pullDirection);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fireplace with warmth zone",
      "ideal_ir": {
        "class_name": "Fireplace",
        "components": [
          "Collider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "warmthRadius",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "warmthStrength",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "fuelLevel",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "burnRate",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isLit",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "provide_warmth",
            "trigger": "when player enters warmth zone",
            "actions": [
              {
                "action": "gradually increase player temperature"
              },
              {
                "action": "display warmth effect on screen"
              },
              {
                "action": "play crackling fire sounds"
              }
            ]
          },
          {
            "name": "remove_warmth",
            "trigger": "when player exits warmth zone",
            "actions": [
              {
                "action": "stop warming player"
              },
              {
                "action": "fade out warmth effects"
              },
              {
                "action": "reduce fire sound volume"
              }
            ]
          },
          {
            "name": "consume_fuel",
            "trigger": "continuously while fireplace is lit",
            "actions": [
              {
                "action": "decrease fuel level over time"
              },
              {
                "action": "reduce flame intensity as fuel decreases"
              }
            ]
          },
          {
            "name": "extinguish_fire",
            "trigger": "when fuel level reaches zero",
            "actions": [
              {
                "action": "stop all flame particles"
              },
              {
                "action": "stop fire sounds"
              },
              {
                "action": "disable warmth zone"
              },
              {
                "action": "set fireplace as unlit"
              }
            ]
          },
          {
            "name": "relight_fireplace",
            "trigger": "when player interacts with unlit fireplace and has fuel",
            "actions": [
              {
                "action": "restart flame particles"
              },
              {
                "action": "resume fire sounds"
              },
              {
                "action": "reactivate warmth zone"
              },
              {
                "action": "set fireplace as lit"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class Fireplace : MonoBehaviour\n{\n    [Header(\"Fire Settings\")]\n    [SerializeField] private GameObject fireEffect;\n    [SerializeField] private AudioSource fireAudioSource;\n    [SerializeField] private Light fireLight;\n    [SerializeField] private bool isLit = true;\n    [SerializeField] private float fuelDuration = 300f;\n    [SerializeField] private float currentFuel = 300f;\n    \n    [Header(\"Warmth Zone\")]\n    [SerializeField] private float warmthRadius = 5f;\n    [SerializeField] private float maxWarmthStrength = 100f;\n    [SerializeField] private float warmthFalloffRate = 2f;\n    [SerializeField] private LayerMask playerLayer = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private AnimationCurve flameSizeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private AnimationCurve lightIntensityCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private float baseFireScale = 1f;\n    [SerializeField] private float baseLightIntensity = 2f;\n    [SerializeField] private Color warmLightColor = Color.yellow;\n    [SerializeField] private Color coolLightColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] cracklingSounds;\n    [SerializeField] private float crackleInterval = 3f;\n    [SerializeField] private float baseVolume = 0.5f;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private bool requiresFuel = true;\n    [SerializeField] private string fuelTag = \"Wood\";\n    [SerializeField] private float fuelAddAmount = 60f;\n    [SerializeField] private float interactionRange = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFireLit;\n    public UnityEvent OnFireExtinguished;\n    public UnityEvent OnPlayerEnterWarmth;\n    public UnityEvent OnPlayerExitWarmth;\n    \n    private List<GameObject> _playersInWarmth = new List<GameObject>();\n    private float _crackleTimer;\n    private bool _playerNearby;\n    private Vector3 _originalFireScale;\n    private float _originalLightIntensity;\n    \n    [System.Serializable]\n    public class WarmthData\n    {\n        public GameObject player;\n        public float warmthLevel;\n        public float timeInWarmth;\n        \n        public WarmthData(GameObject p)\n        {\n            player = p;\n            warmthLevel = 0f;\n            timeInWarmth = 0f;\n        }\n    }\n    \n    private List<WarmthData> _warmthDataList = new List<WarmthData>();\n    \n    void Start()\n    {\n        InitializeFireplace();\n        SetupComponents();\n    }\n    \n    void Update()\n    {\n        if (requiresFuel && isLit)\n        {\n            ConsumeFuel();\n        }\n        \n        UpdateFireEffects();\n        UpdateWarmthZone();\n        HandleAudio();\n        CheckForPlayerInteraction();\n    }\n    \n    void InitializeFireplace()\n    {\n        if (fireEffect != null)\n        {\n            _originalFireScale = fireEffect.transform.localScale;\n        }\n        \n        if (fireLight != null)\n        {\n            _originalLightIntensity = fireLight.intensity;\n        }\n        \n        currentFuel = Mathf.Clamp(currentFuel, 0f, fuelDuration);\n        \n        if (currentFuel <= 0f)\n        {\n            ExtinguishFire();\n        }\n    }\n    \n    void SetupComponents()\n    {\n        if (fireAudioSource == null)\n        {\n            fireAudioSource = GetComponent<AudioSource>();\n            if (fireAudioSource == null)\n            {\n                fireAudioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (fireAudioSource != null)\n        {\n            fireAudioSource.loop = true;\n            fireAudioSource.volume = baseVolume;\n        }\n    }\n    \n    void ConsumeFuel()\n    {\n        currentFuel -= Time.deltaTime;\n        currentFuel = Mathf.Max(0f, currentFuel);\n        \n        if (currentFuel <= 0f && isLit)\n        {\n            ExtinguishFire();\n        }\n    }\n    \n    void UpdateFireEffects()\n    {\n        float fuelPercentage = requiresFuel ? (currentFuel / fuelDuration) : 1f;\n        \n        if (fireEffect != null)\n        {\n            fireEffect.SetActive(isLit);\n            if (isLit)\n            {\n                float scaleMultiplier = flameSizeCurve.Evaluate(fuelPercentage);\n                fireEffect.transform.localScale = _originalFireScale * scaleMultiplier * baseFireScale;\n            }\n        }\n        \n        if (fireLight != null)\n        {\n            fireLight.enabled = isLit;\n            if (isLit)\n            {\n                float intensityMultiplier = lightIntensityCurve.Evaluate(fuelPercentage);\n                fireLight.intensity = _originalLightIntensity * intensityMultiplier * baseLightIntensity;\n                fireLight.color = Color.Lerp(coolLightColor, warmLightColor, fuelPercentage);\n                \n                // Add flickering effect\n                fireLight.intensity += Mathf.Sin(Time.time * 10f) * 0.1f * intensityMultiplier;\n            }\n        }\n    }\n    \n    void UpdateWarmthZone()\n    {\n        if (!isLit) return;\n        \n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, warmthRadius, playerLayer);\n        \n        // Remove players who left the warmth zone\n        for (int i = _warmthDataList.Count - 1; i >= 0; i--)\n        {\n            bool stillInRange = false;\n            foreach (var collider in playersInRange)\n            {\n                if (collider.gameObject == _warmthDataList[i].player)\n                {\n                    stillInRange = true;\n                    break;\n                }\n            }\n            \n            if (!stillInRange)\n            {\n                OnPlayerExitWarmth.Invoke();\n                _warmthDataList.RemoveAt(i);\n            }\n        }\n        \n        // Add new players and update existing ones\n        foreach (var collider in playersInRange)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                WarmthData existingData = _warmthDataList.Find(w => w.player == collider.gameObject);\n                \n                if (existingData == null)\n                {\n                    _warmthDataList.Add(new WarmthData(collider.gameObject));\n                    OnPlayerEnterWarmth.Invoke();\n                }\n                else\n                {\n                    UpdatePlayerWarmth(existingData, collider.gameObject);\n                }\n            }\n        }\n    }\n    \n    void UpdatePlayerWarmth(WarmthData warmthData, GameObject player)\n    {\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        float warmthStrength = Mathf.Clamp01(1f - (distance / warmthRadius));\n        warmthStrength = Mathf.Pow(warmthStrength, warmthFalloffRate);\n        \n        warmthData.warmthLevel = warmthStrength * maxWarmthStrength;\n        warmthData.timeInWarmth += Time.deltaTime;\n        \n        // Apply warmth effect to player (you can extend this based on your needs)\n        ApplyWarmthToPlayer(player, warmthData.warmthLevel);\n    }\n    \n    void ApplyWarmthToPlayer(GameObject player, float warmthLevel)\n    {\n        // Send message to player about warmth level\n        player.SendMessage(\"ReceiveWarmth\", warmthLevel, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    void HandleAudio()\n    {\n        if (fireAudioSource == null) return;\n        \n        if (isLit)\n        {\n            float fuelPercentage = requiresFuel ? (currentFuel / fuelDuration) : 1f;\n            fireAudioSource.volume = baseVolume * fuelPercentage;\n            \n            _crackleTimer -= Time.deltaTime;\n            if (_crackleTimer <= 0f && cracklingSounds.Length > 0)\n            {\n                AudioClip randomCrackle = cracklingSounds[Random.Range(0, cracklingSounds.Length)];\n                AudioSource.PlayClipAtPoint(randomCrackle, transform.position, baseVolume * fuelPercentage);\n                _crackleTimer = crackleInterval + Random.Range(-1f, 1f);\n            }\n        }\n        else\n        {\n            fireAudioSource.volume = 0f;\n        }\n    }\n    \n    void CheckForPlayerInteraction()\n    {\n        bool playerWasNearby = _playerNearby;\n        _playerNearby = false;\n        \n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, interactionRange);\n        foreach (var collider in nearbyObjects)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                _playerNearby = true;\n                \n                if (Input.GetKeyDown(KeyCode.E))\n                {\n                    TryAddFuel(collider.gameObject);\n                }\n                break;\n            }\n        }\n    }\n    \n    void TryAddFuel(GameObject player)\n    {\n        if (!requiresFuel) return;\n        \n        // Look for fuel in player's vicinity or inventory\n        Collider[] nearbyItems = Physics.OverlapSphere(player.transform.position, 2f);\n        foreach (var item in nearbyItems)\n        {\n            if (item.CompareTag(fuelTag))\n            {\n                AddFuel();\n                Destroy(item.gameObject);\n                break;\n            }\n        }\n    }\n    \n    public void AddFuel()\n    {\n        currentFuel = Mathf.Min(currentFuel + fuelAddAmount, fuelDuration);\n        \n        if (!isLit && currentFuel > 0f)\n        {\n            LightFire();\n        }\n    }\n    \n    public void LightFire()\n    {\n        if (requiresFuel && currentFuel <= 0f) return;\n        \n        isLit = true;\n        OnFireLit.Invoke();\n    }\n    \n    public void ExtinguishFire()\n    {\n        isLit = false;\n        OnFireExtinguished.Invoke();\n        \n        // Clear warmth data\n        _warmthDataList.Clear();\n    }\n    \n    public float GetWarmthAtPosition(Vector3 position)\n    {\n        if (!isLit) return 0f;\n        \n        float distance = Vector3.Distance(transform.position, position);\n        if (distance > warmthRadius) return 0f;\n        \n        float warmthStrength = Mathf.Clamp01(1f - (distance / warmthRadius));\n        return Mathf.Pow(warmthStrength, warmthFalloffRate) * maxWarmthStrength;\n    }\n    \n    public bool IsPlayerInWarmth(GameObject player)\n    {\n        return _warmthDataList.Exists(w => w.player == player);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return requiresFuel ? (currentFuel / fuelDuration) : 1f;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw warmth radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, warmthRadius);\n        \n        // Draw interaction range\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, interactionRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "bed for sleeping",
      "ideal_ir": {
        "class_name": "SleepingBed",
        "components": [
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "isOccupied",
            "type": "bool",
            "default": false
          },
          {
            "name": "sleepDuration",
            "type": "float",
            "default": 8.0
          },
          {
            "name": "comfortLevel",
            "type": "float",
            "default": 7.5
          }
        ],
        "behaviors": [
          {
            "name": "allow_player_to_sleep",
            "trigger": "when player interacts with bed and bed is not occupied",
            "actions": [
              {
                "action": "mark bed as occupied"
              },
              {
                "action": "start sleep sequence for player"
              },
              {
                "action": "fade screen to black"
              },
              {
                "action": "restore player health and energy over sleep duration"
              }
            ]
          },
          {
            "name": "wake_up_player",
            "trigger": "when sleep duration is complete or player chooses to wake up",
            "actions": [
              {
                "action": "fade screen back to normal"
              },
              {
                "action": "mark bed as unoccupied"
              },
              {
                "action": "end sleep sequence"
              },
              {
                "action": "apply rested status effects to player"
              }
            ]
          },
          {
            "name": "show_interaction_prompt",
            "trigger": "when player is near bed and bed is not occupied",
            "actions": [
              {
                "action": "display sleep interaction prompt"
              }
            ]
          },
          {
            "name": "hide_interaction_prompt",
            "trigger": "when player moves away from bed",
            "actions": [
              {
                "action": "hide sleep interaction prompt"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Bed : MonoBehaviour\n{\n    [Header(\"Sleep Settings\")]\n    [SerializeField] private float _sleepDuration = 8f;\n    [SerializeField] private bool _requireNightTime = true;\n    [SerializeField] private float _nightStartHour = 20f;\n    [SerializeField] private float _nightEndHour = 6f;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Renderer _bedRenderer;\n    [SerializeField] private Material _occupiedMaterial;\n    [SerializeField] private Material _defaultMaterial;\n    \n    [Header(\"Sleep Effects\")]\n    [SerializeField] private GameObject _sleepParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sleepSound;\n    [SerializeField] private AudioClip _wakeUpSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSleepStart;\n    public UnityEvent OnSleepEnd;\n    public UnityEvent<float> OnSleepProgress;\n    \n    private bool _isOccupied = false;\n    private bool _isSleeping = false;\n    private float _sleepTimer = 0f;\n    private Transform _sleepingPlayer;\n    private Vector3 _originalPlayerPosition;\n    private bool _playerInRange = false;\n    private Camera _playerCamera;\n    private bool _originalCameraState;\n    \n    [System.Serializable]\n    public class SleepData\n    {\n        public bool isComplete;\n        public float timeSlept;\n        public float restBonus;\n    }\n    \n    private void Start()\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(false);\n            \n        if (_bedRenderer != null && _defaultMaterial != null)\n            _bedRenderer.material = _defaultMaterial;\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInteraction();\n        UpdateSleep();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(_playerTag);\n        if (player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange && !_isSleeping;\n        \n        if (_playerInRange && !wasInRange)\n        {\n            ShowInteractionPrompt(true);\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            ShowInteractionPrompt(false);\n        }\n    }\n    \n    private void HandleInteraction()\n    {\n        if (!_playerInRange || !Input.GetKeyDown(_interactionKey)) return;\n        \n        if (!_isSleeping && !_isOccupied)\n        {\n            if (CanSleep())\n            {\n                StartSleep();\n            }\n        }\n        else if (_isSleeping)\n        {\n            WakeUp();\n        }\n    }\n    \n    private bool CanSleep()\n    {\n        if (!_requireNightTime) return true;\n        \n        float currentHour = System.DateTime.Now.Hour;\n        \n        if (_nightStartHour > _nightEndHour)\n        {\n            return currentHour >= _nightStartHour || currentHour <= _nightEndHour;\n        }\n        else\n        {\n            return currentHour >= _nightStartHour && currentHour <= _nightEndHour;\n        }\n    }\n    \n    private void StartSleep()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(_playerTag);\n        if (player == null) return;\n        \n        _sleepingPlayer = player.transform;\n        _originalPlayerPosition = _sleepingPlayer.position;\n        _isSleeping = true;\n        _isOccupied = true;\n        _sleepTimer = 0f;\n        \n        // Position player on bed\n        Vector3 bedPosition = transform.position + Vector3.up * 0.5f;\n        _sleepingPlayer.position = bedPosition;\n        \n        // Disable player movement\n        MonoBehaviour[] playerScripts = _sleepingPlayer.GetComponents<MonoBehaviour>();\n        foreach (var script in playerScripts)\n        {\n            if (script.GetType().Name.Contains(\"Movement\") || \n                script.GetType().Name.Contains(\"Controller\"))\n            {\n                script.enabled = false;\n            }\n        }\n        \n        // Handle camera\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_playerCamera != null)\n        {\n            _originalCameraState = _playerCamera.enabled;\n            _playerCamera.enabled = false;\n        }\n        \n        // Visual and audio feedback\n        UpdateBedVisuals(true);\n        PlaySound(_sleepSound);\n        \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(true);\n            \n        ShowInteractionPrompt(false);\n        OnSleepStart?.Invoke();\n    }\n    \n    private void UpdateSleep()\n    {\n        if (!_isSleeping) return;\n        \n        _sleepTimer += Time.deltaTime;\n        float progress = _sleepTimer / _sleepDuration;\n        \n        OnSleepProgress?.Invoke(progress);\n        \n        if (_sleepTimer >= _sleepDuration)\n        {\n            CompleteSleep();\n        }\n    }\n    \n    private void CompleteSleep()\n    {\n        WakeUp();\n        \n        // Provide sleep benefits\n        SleepData sleepData = new SleepData\n        {\n            isComplete = true,\n            timeSlept = _sleepDuration,\n            restBonus = 1f\n        };\n        \n        // You could send this data to other systems here\n        Debug.Log($\"Sleep completed! Rested for {_sleepDuration} seconds\");\n    }\n    \n    private void WakeUp()\n    {\n        if (!_isSleeping) return;\n        \n        _isSleeping = false;\n        _isOccupied = false;\n        \n        if (_sleepingPlayer != null)\n        {\n            // Re-enable player movement\n            MonoBehaviour[] playerScripts = _sleepingPlayer.GetComponents<MonoBehaviour>();\n            foreach (var script in playerScripts)\n            {\n                if (script.GetType().Name.Contains(\"Movement\") || \n                    script.GetType().Name.Contains(\"Controller\"))\n                {\n                    script.enabled = true;\n                }\n            }\n            \n            // Restore camera\n            if (_playerCamera != null)\n                _playerCamera.enabled = _originalCameraState;\n        }\n        \n        // Visual and audio feedback\n        UpdateBedVisuals(false);\n        PlaySound(_wakeUpSound);\n        \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(false);\n            \n        _sleepingPlayer = null;\n        OnSleepEnd?.Invoke();\n    }\n    \n    private void UpdateBedVisuals(bool occupied)\n    {\n        if (_bedRenderer == null) return;\n        \n        if (occupied && _occupiedMaterial != null)\n        {\n            _bedRenderer.material = _occupiedMaterial;\n        }\n        else if (!occupied && _defaultMaterial != null)\n        {\n            _bedRenderer.material = _defaultMaterial;\n        }\n    }\n    \n    private void ShowInteractionPrompt(bool show)\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(show);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsOccupied()\n    {\n        return _isOccupied;\n    }\n    \n    public bool IsSleeping()\n    {\n        return _isSleeping;\n    }\n    \n    public float GetSleepProgress()\n    {\n        return _isSleeping ? _sleepTimer / _sleepDuration : 0f;\n    }\n    \n    public void ForceWakeUp()\n    {\n        if (_isSleeping)\n            WakeUp();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "cooking pot with recipes",
      "ideal_ir": {
        "class_name": "CookingPot",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isLit",
            "type": "bool",
            "default": false
          },
          {
            "name": "cookingTime",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "currentCookTime",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "isCooking",
            "type": "bool",
            "default": false
          },
          {
            "name": "maxIngredients",
            "type": "int",
            "default": 3
          },
          {
            "name": "currentIngredients",
            "type": "List<string>",
            "default": null
          },
          {
            "name": "availableRecipes",
            "type": "List<Recipe>",
            "default": null
          },
          {
            "name": "currentRecipe",
            "type": "Recipe",
            "default": null
          },
          {
            "name": "cookingSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "completeSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "light_pot",
            "trigger": "when player interacts with pot and pot is not lit",
            "actions": [
              {
                "action": "set pot to lit state"
              },
              {
                "action": "enable fire particle effects"
              },
              {
                "action": "play lighting sound effect"
              }
            ]
          },
          {
            "name": "add_ingredient",
            "trigger": "when player drops ingredient item into pot and pot is lit and not currently cooking",
            "actions": [
              {
                "action": "add ingredient to current ingredients list"
              },
              {
                "action": "destroy the ingredient item"
              },
              {
                "action": "play ingredient splash sound"
              },
              {
                "action": "check if current ingredients match any available recipe"
              }
            ]
          },
          {
            "name": "start_cooking",
            "trigger": "when ingredients match a valid recipe and pot is lit",
            "actions": [
              {
                "action": "set cooking state to true"
              },
              {
                "action": "store the matched recipe as current recipe"
              },
              {
                "action": "reset cooking timer to zero"
              },
              {
                "action": "play cooking sound on loop"
              },
              {
                "action": "enable bubbling particle effects"
              }
            ]
          },
          {
            "name": "cooking_progress",
            "trigger": "when pot is cooking and fire is lit",
            "actions": [
              {
                "action": "increase cooking timer"
              },
              {
                "action": "update cooking progress visual indicator"
              }
            ]
          },
          {
            "name": "finish_cooking",
            "trigger": "when cooking timer reaches required cooking time",
            "actions": [
              {
                "action": "set cooking state to false"
              },
              {
                "action": "stop cooking sound"
              },
              {
                "action": "disable bubbling effects"
              },
              {
                "action": "spawn the completed recipe item"
              },
              {
                "action": "clear current ingredients list"
              },
              {
                "action": "clear current recipe"
              },
              {
                "action": "play cooking complete sound"
              }
            ]
          },
          {
            "name": "extinguish_fire",
            "trigger": "when player pours water on lit pot",
            "actions": [
              {
                "action": "set pot to unlit state"
              },
              {
                "action": "disable fire particle effects"
              },
              {
                "action": "stop all cooking processes"
              },
              {
                "action": "play extinguishing steam sound"
              },
              {
                "action": "enable steam particle effects briefly"
              }
            ]
          },
          {
            "name": "remove_ingredients",
            "trigger": "when player interacts with pot while ingredients are added but not cooking",
            "actions": [
              {
                "action": "spawn ingredient items from current ingredients list"
              },
              {
                "action": "clear current ingredients list"
              },
              {
                "action": "play pouring out sound"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class CookingPot : MonoBehaviour\n{\n    [System.Serializable]\n    public class Ingredient\n    {\n        public string name;\n        public GameObject prefab;\n        public int quantity;\n        \n        public Ingredient(string itemName, GameObject itemPrefab, int itemQuantity = 1)\n        {\n            name = itemName;\n            prefab = itemPrefab;\n            quantity = itemQuantity;\n        }\n    }\n    \n    [System.Serializable]\n    public class Recipe\n    {\n        public string recipeName;\n        public List<Ingredient> requiredIngredients = new List<Ingredient>();\n        public GameObject resultPrefab;\n        public float cookingTime = 3f;\n        public string description;\n    }\n    \n    [Header(\"Cooking Configuration\")]\n    [SerializeField] private List<Recipe> _availableRecipes = new List<Recipe>();\n    [SerializeField] private Transform _ingredientDropZone;\n    [SerializeField] private Transform _resultSpawnPoint;\n    [SerializeField] private float _interactionRange = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _cookingParticles;\n    [SerializeField] private ParticleSystem _completeParticles;\n    [SerializeField] private Animator _potAnimator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _cookingSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private AudioClip _failSound;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _uiCanvas;\n    [SerializeField] private GameObject _recipePanel;\n    [SerializeField] private UnityEngine.UI.Text _statusText;\n    [SerializeField] private UnityEngine.UI.Button _cookButton;\n    [SerializeField] private UnityEngine.UI.Text _recipeListText;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnRecipeCompleted;\n    public UnityEvent OnCookingStarted;\n    public UnityEvent OnCookingFailed;\n    \n    private List<Ingredient> _currentIngredients = new List<Ingredient>();\n    private bool _isCooking = false;\n    private float _cookingTimer = 0f;\n    private Recipe _currentRecipe;\n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_cookButton != null)\n            _cookButton.onClick.AddListener(StartCooking);\n            \n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(false);\n            \n        UpdateUI();\n        DisplayAvailableRecipes();\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        HandleCooking();\n        UpdateUI();\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n        \n        if (_playerTransform != null)\n        {\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _interactionRange;\n            \n            if (_playerInRange && !wasInRange)\n            {\n                ShowUI();\n            }\n            else if (!_playerInRange && wasInRange)\n            {\n                HideUI();\n            }\n            \n            if (_playerInRange && Input.GetKeyDown(KeyCode.E) && !_isCooking)\n            {\n                ToggleRecipePanel();\n            }\n        }\n    }\n    \n    private void HandleCooking()\n    {\n        if (_isCooking)\n        {\n            _cookingTimer += Time.deltaTime;\n            \n            if (_cookingTimer >= _currentRecipe.cookingTime)\n            {\n                CompleteCooking();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Ingredient\") || other.CompareTag(\"Item\"))\n        {\n            AddIngredient(other.gameObject);\n        }\n    }\n    \n    private void AddIngredient(GameObject ingredientObject)\n    {\n        if (_isCooking) return;\n        \n        string ingredientName = ingredientObject.name.Replace(\"(Clone)\", \"\").Trim();\n        \n        Ingredient existingIngredient = _currentIngredients.Find(i => i.name == ingredientName);\n        if (existingIngredient != null)\n        {\n            existingIngredient.quantity++;\n        }\n        else\n        {\n            _currentIngredients.Add(new Ingredient(ingredientName, ingredientObject, 1));\n        }\n        \n        Destroy(ingredientObject);\n        UpdateUI();\n    }\n    \n    public void StartCooking()\n    {\n        if (_isCooking) return;\n        \n        Recipe matchedRecipe = FindMatchingRecipe();\n        if (matchedRecipe != null)\n        {\n            _currentRecipe = matchedRecipe;\n            _isCooking = true;\n            _cookingTimer = 0f;\n            \n            OnCookingStarted?.Invoke();\n            \n            if (_cookingParticles != null)\n                _cookingParticles.Play();\n                \n            if (_potAnimator != null)\n                _potAnimator.SetBool(\"IsCooking\", true);\n                \n            if (_audioSource != null && _cookingSound != null)\n                _audioSource.PlayOneShot(_cookingSound);\n        }\n        else\n        {\n            OnCookingFailed?.Invoke();\n            \n            if (_audioSource != null && _failSound != null)\n                _audioSource.PlayOneShot(_failSound);\n                \n            ClearIngredients();\n        }\n    }\n    \n    private Recipe FindMatchingRecipe()\n    {\n        foreach (Recipe recipe in _availableRecipes)\n        {\n            if (IngredientsMatch(recipe.requiredIngredients, _currentIngredients))\n            {\n                return recipe;\n            }\n        }\n        return null;\n    }\n    \n    private bool IngredientsMatch(List<Ingredient> required, List<Ingredient> current)\n    {\n        if (required.Count != current.Count) return false;\n        \n        foreach (Ingredient requiredIngredient in required)\n        {\n            Ingredient currentIngredient = current.Find(i => i.name == requiredIngredient.name);\n            if (currentIngredient == null || currentIngredient.quantity < requiredIngredient.quantity)\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private void CompleteCooking()\n    {\n        _isCooking = false;\n        \n        if (_cookingParticles != null)\n            _cookingParticles.Stop();\n            \n        if (_completeParticles != null)\n            _completeParticles.Play();\n            \n        if (_potAnimator != null)\n            _potAnimator.SetBool(\"IsCooking\", false);\n            \n        if (_audioSource != null && _completeSound != null)\n            _audioSource.PlayOneShot(_completeSound);\n        \n        SpawnResult();\n        OnRecipeCompleted?.Invoke(_currentRecipe.recipeName);\n        \n        ClearIngredients();\n        _currentRecipe = null;\n    }\n    \n    private void SpawnResult()\n    {\n        if (_currentRecipe.resultPrefab != null && _resultSpawnPoint != null)\n        {\n            Instantiate(_currentRecipe.resultPrefab, _resultSpawnPoint.position, _resultSpawnPoint.rotation);\n        }\n    }\n    \n    private void ClearIngredients()\n    {\n        _currentIngredients.Clear();\n        UpdateUI();\n    }\n    \n    private void ShowUI()\n    {\n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(true);\n    }\n    \n    private void HideUI()\n    {\n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(false);\n            \n        if (_recipePanel != null)\n            _recipePanel.SetActive(false);\n    }\n    \n    private void ToggleRecipePanel()\n    {\n        if (_recipePanel != null)\n            _recipePanel.SetActive(!_recipePanel.activeSelf);\n    }\n    \n    private void UpdateUI()\n    {\n        if (_statusText != null)\n        {\n            if (_isCooking)\n            {\n                float progress = _cookingTimer / _currentRecipe.cookingTime;\n                _statusText.text = $\"Cooking {_currentRecipe.recipeName}... {progress:P0}\";\n            }\n            else if (_currentIngredients.Count > 0)\n            {\n                _statusText.text = \"Ingredients added. Press Cook to start!\";\n            }\n            else\n            {\n                _statusText.text = \"Drop ingredients here. Press E for recipes.\";\n            }\n        }\n        \n        if (_cookButton != null)\n        {\n            _cookButton.interactable = !_isCooking && _currentIngredients.Count > 0;\n        }\n    }\n    \n    private void DisplayAvailableRecipes()\n    {\n        if (_recipeListText != null)\n        {\n            string recipeText = \"Available Recipes:\\n\\n\";\n            \n            foreach (Recipe recipe in _availableRecipes)\n            {\n                recipeText += $\"<b>{recipe.recipeName}</b>\\n\";\n                recipeText += $\"{recipe.description}\\n\";\n                recipeText += \"Ingredients:\\n\";\n                \n                foreach (Ingredient ingredient in recipe.requiredIngredients)\n                {\n                    recipeText += $\"- {ingredient.name} x{ingredient.quantity}\\n\";\n                }\n                \n                recipeText += $\"Cooking Time: {recipe.cookingTime}s\\n\\n\";\n            }\n            \n            _recipeListText.text = recipeText;\n        }\n    }\n    \n    public void AddRecipe(Recipe newRecipe)\n    {\n        if (!_availableRecipes.Contains(newRecipe))\n        {\n            _availableRecipes.Add(newRecipe);\n            DisplayAvailableRecipes();\n        }\n    }\n    \n    public void RemoveRecipe(string recipeName)\n    {\n        _availableRecipes.RemoveAll(r => r.recipeName == recipeName);\n        DisplayAvailableRecipes();\n    }\n    \n    public bool HasIngredient(string ingredientName)\n    {\n        return _currentIngredients.Exists(i => i.name == ingredientName);\n    }\n    \n    public int GetIngredientCount(string ingredientName)\n    {\n        Ingredient ingredient = _currentIngredients.Find(i => i.name == ingredientName);\n        return ingredient != null ? ingredient.quantity : 0;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_ingredientDropZone != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_ingredientDropZone.position, Vector3.one);\n        }\n        \n        if (_resultSpawnPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_resultSpawnPoint.position, 0.5f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "forge for crafting",
      "ideal_ir": {
        "class_name": "CraftingForge",
        "components": [
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "craftingTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "currentCraftingTime",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "requiredMaterials",
            "type": "List<string>",
            "default": null
          },
          {
            "name": "craftedItem",
            "type": "string",
            "default": ""
          },
          {
            "name": "maxTemperature",
            "type": "float",
            "default": 1000.0
          },
          {
            "name": "currentTemperature",
            "type": "float",
            "default": 20.0
          },
          {
            "name": "fuelLevel",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "isLit",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "light_forge",
            "trigger": "when player interacts with forge and has fuel",
            "actions": [
              {
                "action": "ignite the forge flames"
              },
              {
                "action": "start heating up gradually"
              },
              {
                "action": "play fire crackling sound"
              },
              {
                "action": "emit orange glow and particle effects"
              }
            ]
          },
          {
            "name": "start_crafting",
            "trigger": "when player places required materials and forge is hot enough",
            "actions": [
              {
                "action": "begin crafting process"
              },
              {
                "action": "consume the materials from inventory"
              },
              {
                "action": "start crafting timer"
              },
              {
                "action": "play hammering and sizzling sounds"
              },
              {
                "action": "show crafting progress indicator"
              }
            ]
          },
          {
            "name": "complete_crafting",
            "trigger": "when crafting time is finished",
            "actions": [
              {
                "action": "create the crafted item"
              },
              {
                "action": "place item in output slot"
              },
              {
                "action": "play completion chime sound"
              },
              {
                "action": "show success particle effects"
              },
              {
                "action": "reset crafting state"
              }
            ]
          },
          {
            "name": "maintain_temperature",
            "trigger": "when forge is lit and has fuel",
            "actions": [
              {
                "action": "gradually increase temperature to maximum"
              },
              {
                "action": "consume fuel over time"
              },
              {
                "action": "maintain flame effects and sounds"
              }
            ]
          },
          {
            "name": "cool_down",
            "trigger": "when forge runs out of fuel or is extinguished",
            "actions": [
              {
                "action": "gradually decrease temperature"
              },
              {
                "action": "dim the flame effects"
              },
              {
                "action": "fade out fire sounds"
              },
              {
                "action": "cancel any active crafting"
              }
            ]
          },
          {
            "name": "show_recipe_requirements",
            "trigger": "when player examines forge with materials in hand",
            "actions": [
              {
                "action": "display required materials for possible recipes"
              },
              {
                "action": "highlight missing materials in red"
              },
              {
                "action": "show estimated crafting time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Forge : MonoBehaviour\n{\n    [System.Serializable]\n    public class CraftingMaterial\n    {\n        public string materialName;\n        public Sprite icon;\n        public int quantity;\n        \n        public CraftingMaterial(string name, Sprite sprite, int qty)\n        {\n            materialName = name;\n            icon = sprite;\n            quantity = qty;\n        }\n    }\n    \n    [System.Serializable]\n    public class CraftingRecipe\n    {\n        public string recipeName;\n        public Sprite resultIcon;\n        public List<CraftingMaterial> requiredMaterials = new List<CraftingMaterial>();\n        public GameObject resultPrefab;\n        public int craftingTime = 3;\n        public AudioClip craftingSound;\n        \n        public bool CanCraft(List<CraftingMaterial> availableMaterials)\n        {\n            foreach (var required in requiredMaterials)\n            {\n                var available = availableMaterials.FirstOrDefault(m => m.materialName == required.materialName);\n                if (available == null || available.quantity < required.quantity)\n                    return false;\n            }\n            return true;\n        }\n    }\n    \n    [Header(\"Forge Settings\")]\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private Transform _craftingPoint;\n    [SerializeField] private ParticleSystem _forgeFlames;\n    [SerializeField] private ParticleSystem _craftingEffect;\n    [SerializeField] private Light _forgeLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _forgeIdleSound;\n    [SerializeField] private AudioClip _craftingCompleteSound;\n    \n    [Header(\"Recipes\")]\n    [SerializeField] private List<CraftingRecipe> _availableRecipes = new List<CraftingRecipe>();\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _forgeUI;\n    [SerializeField] private GameObject _recipeButtonPrefab;\n    [SerializeField] private Transform _recipeContainer;\n    [SerializeField] private UnityEngine.UI.Button _closeButton;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnItemCrafted;\n    public UnityEvent OnForgeOpened;\n    public UnityEvent OnForgeClosed;\n    \n    private List<CraftingMaterial> _playerMaterials = new List<CraftingMaterial>();\n    private bool _isPlayerNearby = false;\n    private bool _isCrafting = false;\n    private float _craftingTimer = 0f;\n    private CraftingRecipe _currentRecipe;\n    private Transform _player;\n    \n    private void Start()\n    {\n        InitializeForge();\n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n        UpdateCrafting();\n        UpdateEffects();\n    }\n    \n    private void InitializeForge()\n    {\n        if (_forgeUI != null)\n            _forgeUI.gameObject.SetActive(false);\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_craftingPoint == null)\n            _craftingPoint = transform;\n            \n        if (_forgeFlames != null)\n            _forgeFlames.Play();\n            \n        PlayIdleSound();\n    }\n    \n    private void SetupUI()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(CloseForgeUI);\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasNearby = _isPlayerNearby;\n        _isPlayerNearby = distance <= _interactionRange;\n        _player = player.transform;\n        \n        if (_isPlayerNearby && !wasNearby)\n        {\n            ShowInteractionPrompt();\n        }\n        else if (!_isPlayerNearby && wasNearby)\n        {\n            HideInteractionPrompt();\n            CloseForgeUI();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_isPlayerNearby && Input.GetKeyDown(KeyCode.E))\n        {\n            if (_forgeUI != null && _forgeUI.gameObject.activeInHierarchy)\n                CloseForgeUI();\n            else\n                OpenForgeUI();\n        }\n    }\n    \n    private void UpdateCrafting()\n    {\n        if (!_isCrafting) return;\n        \n        _craftingTimer -= Time.deltaTime;\n        \n        if (_craftingTimer <= 0f)\n        {\n            CompleteCrafting();\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_forgeLight != null)\n        {\n            float intensity = _isCrafting ? 2f : 1f;\n            _forgeLight.intensity = Mathf.Lerp(_forgeLight.intensity, intensity, Time.deltaTime * 2f);\n        }\n        \n        if (_craftingEffect != null)\n        {\n            if (_isCrafting && !_craftingEffect.isPlaying)\n                _craftingEffect.Play();\n            else if (!_isCrafting && _craftingEffect.isPlaying)\n                _craftingEffect.Stop();\n        }\n    }\n    \n    private void OpenForgeUI()\n    {\n        if (_forgeUI == null) return;\n        \n        _forgeUI.gameObject.SetActive(true);\n        UpdatePlayerMaterials();\n        PopulateRecipes();\n        OnForgeOpened?.Invoke();\n        \n        Time.timeScale = 0f;\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n    \n    private void CloseForgeUI()\n    {\n        if (_forgeUI == null) return;\n        \n        _forgeUI.gameObject.SetActive(false);\n        OnForgeClosed?.Invoke();\n        \n        Time.timeScale = 1f;\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n    \n    private void UpdatePlayerMaterials()\n    {\n        _playerMaterials.Clear();\n        \n        if (_player == null) return;\n        \n        // Simulate getting materials from player inventory\n        // In a real implementation, this would interface with an inventory system\n        _playerMaterials.Add(new CraftingMaterial(\"Iron Ore\", null, 5));\n        _playerMaterials.Add(new CraftingMaterial(\"Wood\", null, 10));\n        _playerMaterials.Add(new CraftingMaterial(\"Coal\", null, 3));\n    }\n    \n    private void PopulateRecipes()\n    {\n        if (_recipeContainer == null || _recipeButtonPrefab == null) return;\n        \n        // Clear existing recipe buttons\n        foreach (Transform child in _recipeContainer)\n        {\n            if (child.gameObject != _recipeButtonPrefab)\n                Destroy(child.gameObject);\n        }\n        \n        // Create recipe buttons\n        foreach (var recipe in _availableRecipes)\n        {\n            GameObject buttonObj = Instantiate(_recipeButtonPrefab, _recipeContainer);\n            UnityEngine.UI.Button button = buttonObj.GetComponent<UnityEngine.UI.Button>();\n            \n            if (button != null)\n            {\n                button.onClick.AddListener(() => StartCrafting(recipe));\n                \n                // Update button appearance based on availability\n                bool canCraft = recipe.CanCraft(_playerMaterials);\n                button.interactable = canCraft && !_isCrafting;\n                \n                // Update button text/image if components exist\n                UnityEngine.UI.Text buttonText = button.GetComponentInChildren<UnityEngine.UI.Text>();\n                if (buttonText != null)\n                    buttonText.text = recipe.recipeName;\n                    \n                UnityEngine.UI.Image buttonImage = button.GetComponent<UnityEngine.UI.Image>();\n                if (buttonImage != null && recipe.resultIcon != null)\n                    buttonImage.sprite = recipe.resultIcon;\n            }\n            \n            buttonObj.SetActive(true);\n        }\n    }\n    \n    private void StartCrafting(CraftingRecipe recipe)\n    {\n        if (_isCrafting || !recipe.CanCraft(_playerMaterials)) return;\n        \n        _currentRecipe = recipe;\n        _isCrafting = true;\n        _craftingTimer = recipe.craftingTime;\n        \n        // Consume materials\n        foreach (var required in recipe.requiredMaterials)\n        {\n            var material = _playerMaterials.FirstOrDefault(m => m.materialName == required.materialName);\n            if (material != null)\n                material.quantity -= required.quantity;\n        }\n        \n        // Play crafting sound\n        if (_audioSource != null && recipe.craftingSound != null)\n            _audioSource.PlayOneShot(recipe.craftingSound);\n            \n        // Update UI\n        PopulateRecipes();\n    }\n    \n    private void CompleteCrafting()\n    {\n        if (_currentRecipe == null) return;\n        \n        _isCrafting = false;\n        \n        // Spawn crafted item\n        if (_currentRecipe.resultPrefab != null)\n        {\n            Vector3 spawnPosition = _craftingPoint.position + Vector3.up * 0.5f;\n            GameObject craftedItem = Instantiate(_currentRecipe.resultPrefab, spawnPosition, Quaternion.identity);\n            \n            // Add some upward force to the crafted item\n            Rigidbody rb = craftedItem.GetComponent<Rigidbody>();\n            if (rb != null)\n                rb.AddForce(Vector3.up * 3f, ForceMode.Impulse);\n        }\n        \n        // Play completion sound\n        if (_audioSource != null && _craftingCompleteSound != null)\n            _audioSource.PlayOneShot(_craftingCompleteSound);\n        \n        // Invoke event\n        OnItemCrafted?.Invoke(_currentRecipe.recipeName);\n        \n        _currentRecipe = null;\n        \n        // Update UI\n        PopulateRecipes();\n        \n        // Resume idle sound\n        Invoke(nameof(PlayIdleSound), 1f);\n    }\n    \n    private void PlayIdleSound()\n    {\n        if (_audioSource != null && _forgeIdleSound != null && !_isCrafting)\n        {\n            _audioSource.clip = _forgeIdleSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void ShowInteractionPrompt()\n    {\n        // This would typically show a UI prompt\n        Debug.Log(\"Press E to use Forge\");\n    }\n    \n    private void HideInteractionPrompt()\n    {\n        // This would typically hide the UI prompt\n    }\n    \n    public void AddMaterial(string materialName, int quantity)\n    {\n        var existing = _playerMaterials.FirstOrDefault(m => m.materialName == materialName);\n        if (existing != null)\n            existing.quantity += quantity;\n        else\n            _playerMaterials.Add(new CraftingMaterial(materialName, null, quantity));\n    }\n    \n    public bool HasMaterial(string materialName, int quantity)\n    {\n        var material = _playerMaterials.FirstOrDefault(m => m.materialName == materialName);\n        return material != null && material.quantity >= quantity;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_craftingPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(_craftingPoint.position, Vector3.one * 0.5f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fishing spot",
      "ideal_ir": {
        "class_name": "FishingSpot",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "fishingRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "catchChance",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "fishTypes",
            "type": "string[]",
            "default": [
              "Bass",
              "Trout",
              "Salmon"
            ]
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          },
          {
            "name": "rippleEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "splashSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_player_approach",
            "trigger": "when player enters fishing range",
            "actions": [
              {
                "action": "show fishing interaction prompt"
              },
              {
                "action": "spawn ripple effects on water surface"
              }
            ]
          },
          {
            "name": "handle_fishing_attempt",
            "trigger": "when player uses fishing rod at this spot",
            "actions": [
              {
                "action": "play water splash sound"
              },
              {
                "action": "start fishing minigame"
              },
              {
                "action": "determine catch success based on catch chance"
              },
              {
                "action": "spawn random fish type if successful"
              },
              {
                "action": "deactivate spot temporarily"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "reactivate_spot",
            "trigger": "when cooldown timer expires",
            "actions": [
              {
                "action": "reactivate fishing spot"
              },
              {
                "action": "restore ripple effects"
              }
            ]
          },
          {
            "name": "hide_interaction",
            "trigger": "when player leaves fishing range",
            "actions": [
              {
                "action": "hide fishing interaction prompt"
              },
              {
                "action": "stop ripple effects"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class FishingSpot : MonoBehaviour\n{\n    [Header(\"Fishing Configuration\")]\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private float _fishingDuration = 5f;\n    [SerializeField] private float _catchChance = 0.7f;\n    [SerializeField] private int _maxFishCount = 10;\n    [SerializeField] private float _respawnTime = 30f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _rippleEffect;\n    [SerializeField] private ParticleSystem _bubbleParticles;\n    [SerializeField] private Animator _waterAnimator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _catchSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    [Header(\"Fish Types\")]\n    [SerializeField] private FishData[] _availableFish;\n    \n    [Header(\"Events\")]\n    public UnityEvent<FishData> OnFishCaught;\n    public UnityEvent OnFishingStarted;\n    public UnityEvent OnFishingFailed;\n    public UnityEvent OnSpotDepleted;\n    \n    private Transform _playerTransform;\n    private bool _isPlayerNearby;\n    private bool _isFishing;\n    private bool _isDepleted;\n    private int _currentFishCount;\n    private Coroutine _fishingCoroutine;\n    private Coroutine _respawnCoroutine;\n    \n    [System.Serializable]\n    public class FishData\n    {\n        public string fishName;\n        public Sprite fishIcon;\n        public float rarity; // 0-1, lower is rarer\n        public int value;\n        public float size;\n    }\n    \n    private void Start()\n    {\n        _currentFishCount = _maxFishCount;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_bubbleParticles != null && !_isDepleted)\n            _bubbleParticles.Play();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            _isPlayerNearby = distance <= _interactionRange && !_isDepleted;\n        }\n        else\n        {\n            _isPlayerNearby = false;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_isPlayerNearby && !_isFishing && Input.GetKeyDown(KeyCode.E))\n        {\n            StartFishing();\n        }\n        else if (_isFishing && Input.GetKeyDown(KeyCode.E))\n        {\n            StopFishing();\n        }\n    }\n    \n    private void StartFishing()\n    {\n        if (_isDepleted || _currentFishCount <= 0)\n        {\n            Debug.Log(\"Fishing spot is depleted!\");\n            return;\n        }\n        \n        _isFishing = true;\n        OnFishingStarted.Invoke();\n        \n        PlaySound(_castSound);\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", true);\n            \n        _fishingCoroutine = StartCoroutine(FishingProcess());\n    }\n    \n    private void StopFishing()\n    {\n        if (_fishingCoroutine != null)\n        {\n            StopCoroutine(_fishingCoroutine);\n            _fishingCoroutine = null;\n        }\n        \n        _isFishing = false;\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", false);\n    }\n    \n    private IEnumerator FishingProcess()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fishingDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            \n            // Random chance for early bite\n            if (Random.value < 0.1f)\n            {\n                yield return new WaitForSeconds(Random.Range(0.5f, 2f));\n                break;\n            }\n            \n            yield return null;\n        }\n        \n        // Determine if catch is successful\n        bool catchSuccessful = Random.value < _catchChance;\n        \n        if (catchSuccessful)\n        {\n            CatchFish();\n        }\n        else\n        {\n            FailedCatch();\n        }\n        \n        _isFishing = false;\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", false);\n    }\n    \n    private void CatchFish()\n    {\n        if (_availableFish.Length == 0) return;\n        \n        FishData caughtFish = SelectRandomFish();\n        _currentFishCount--;\n        \n        PlaySound(_catchSound);\n        CreateRippleEffect();\n        \n        OnFishCaught.Invoke(caughtFish);\n        \n        Debug.Log($\"Caught: {caughtFish.fishName}!\");\n        \n        if (_currentFishCount <= 0)\n        {\n            DepleteFishingSpot();\n        }\n    }\n    \n    private void FailedCatch()\n    {\n        PlaySound(_splashSound);\n        OnFishingFailed.Invoke();\n        Debug.Log(\"The fish got away!\");\n    }\n    \n    private FishData SelectRandomFish()\n    {\n        float totalWeight = 0f;\n        foreach (var fish in _availableFish)\n        {\n            totalWeight += fish.rarity;\n        }\n        \n        float randomValue = Random.value * totalWeight;\n        float currentWeight = 0f;\n        \n        foreach (var fish in _availableFish)\n        {\n            currentWeight += fish.rarity;\n            if (randomValue <= currentWeight)\n            {\n                return fish;\n            }\n        }\n        \n        return _availableFish[0];\n    }\n    \n    private void CreateRippleEffect()\n    {\n        if (_rippleEffect != null)\n        {\n            GameObject ripple = Instantiate(_rippleEffect, transform.position, Quaternion.identity);\n            Destroy(ripple, 3f);\n        }\n    }\n    \n    private void DepleteFishingSpot()\n    {\n        _isDepleted = true;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Stop();\n            \n        OnSpotDepleted.Invoke();\n        \n        if (_respawnTime > 0)\n        {\n            _respawnCoroutine = StartCoroutine(RespawnFish());\n        }\n    }\n    \n    private IEnumerator RespawnFish()\n    {\n        yield return new WaitForSeconds(_respawnTime);\n        \n        _currentFishCount = _maxFishCount;\n        _isDepleted = false;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Play();\n            \n        Debug.Log(\"Fishing spot has been replenished!\");\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_isDepleted)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(transform.position + Vector3.up, Vector3.one * 0.5f);\n        }\n    }\n    \n    public bool IsAvailable()\n    {\n        return !_isDepleted && _currentFishCount > 0;\n    }\n    \n    public int GetRemainingFish()\n    {\n        return _currentFishCount;\n    }\n    \n    public void RefillSpot()\n    {\n        _currentFishCount = _maxFishCount;\n        _isDepleted = false;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Play();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "garden patch for planting",
      "ideal_ir": {
        "class_name": "GardenPatch",
        "components": [
          "BoxCollider",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "isPlanted",
            "type": "bool",
            "default": false
          },
          {
            "name": "cropType",
            "type": "string",
            "default": ""
          },
          {
            "name": "growthStage",
            "type": "int",
            "default": 0
          },
          {
            "name": "maxGrowthStage",
            "type": "int",
            "default": 3
          },
          {
            "name": "growthTime",
            "type": "float",
            "default": 30.0
          },
          {
            "name": "currentGrowthTime",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "soilMaterial",
            "type": "Material",
            "default": null
          },
          {
            "name": "plantedMaterial",
            "type": "Material",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "plant_seed",
            "trigger": "when player interacts with empty patch while holding seeds",
            "actions": [
              {
                "action": "mark patch as planted"
              },
              {
                "action": "set crop type to seed type"
              },
              {
                "action": "change material to planted appearance"
              },
              {
                "action": "reset growth timer"
              },
              {
                "action": "remove seed from player inventory"
              }
            ]
          },
          {
            "name": "grow_crop",
            "trigger": "when patch is planted and growth timer reaches growth time",
            "actions": [
              {
                "action": "increase growth stage by one"
              },
              {
                "action": "reset growth timer"
              },
              {
                "action": "update visual appearance based on growth stage"
              }
            ]
          },
          {
            "name": "harvest_crop",
            "trigger": "when player interacts with fully grown crop",
            "actions": [
              {
                "action": "add harvested crop to player inventory"
              },
              {
                "action": "mark patch as empty"
              },
              {
                "action": "reset growth stage to zero"
              },
              {
                "action": "change material back to soil appearance"
              },
              {
                "action": "clear crop type"
              }
            ]
          },
          {
            "name": "show_growth_progress",
            "trigger": "when player looks at planted patch",
            "actions": [
              {
                "action": "display growth stage information"
              },
              {
                "action": "show crop type being grown"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class GardenPatch : MonoBehaviour\n{\n    [System.Serializable]\n    public class PlantData\n    {\n        public string plantName;\n        public GameObject plantPrefab;\n        public float growthTime;\n        public int harvestAmount;\n        public Sprite plantIcon;\n    }\n\n    [System.Serializable]\n    public class GrowthStage\n    {\n        public GameObject stagePrefab;\n        public float stageTime;\n    }\n\n    [Header(\"Garden Configuration\")]\n    [SerializeField] private List<PlantData> _availablePlants = new List<PlantData>();\n    [SerializeField] private List<GrowthStage> _growthStages = new List<GrowthStage>();\n    [SerializeField] private Transform _plantSpawnPoint;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n\n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _soilPrefab;\n    [SerializeField] private GameObject _wateredSoilPrefab;\n    [SerializeField] private GameObject _highlightEffect;\n    [SerializeField] private ParticleSystem _plantingEffect;\n    [SerializeField] private ParticleSystem _harvestEffect;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _plantingSound;\n    [SerializeField] private AudioClip _harvestSound;\n    [SerializeField] private AudioClip _wateringSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<string> OnPlantPlanted;\n    public UnityEvent<string, int> OnPlantHarvested;\n    public UnityEvent OnPatchWatered;\n\n    private enum PatchState\n    {\n        Empty,\n        Planted,\n        Growing,\n        ReadyToHarvest,\n        Watered\n    }\n\n    private PatchState _currentState = PatchState.Empty;\n    private PlantData _currentPlant;\n    private GameObject _currentPlantObject;\n    private GameObject _currentSoilObject;\n    private float _plantingTime;\n    private float _wateringTime;\n    private int _currentGrowthStage;\n    private bool _isWatered;\n    private bool _playerInRange;\n\n    private void Start()\n    {\n        InitializePatch();\n        SetupAudioSource();\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleGrowth();\n        HandleWatering();\n        UpdateVisuals();\n        HandleInput();\n    }\n\n    private void InitializePatch()\n    {\n        if (_plantSpawnPoint == null)\n            _plantSpawnPoint = transform;\n\n        if (_soilPrefab != null)\n        {\n            _currentSoilObject = Instantiate(_soilPrefab, _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentSoilObject.transform.SetParent(transform);\n        }\n\n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n\n    private void SetupAudioSource()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n\n    private void CheckPlayerProximity()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _interactionRange, _playerLayer);\n        bool playerNearby = false;\n\n        foreach (Collider col in playersInRange)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                playerNearby = true;\n                break;\n            }\n        }\n\n        if (playerNearby != _playerInRange)\n        {\n            _playerInRange = playerNearby;\n            if (_highlightEffect != null)\n                _highlightEffect.SetActive(_playerInRange);\n        }\n    }\n\n    private void HandleGrowth()\n    {\n        if (_currentState != PatchState.Growing)\n            return;\n\n        float growthProgress = (Time.time - _plantingTime) / _currentPlant.growthTime;\n        \n        if (_isWatered)\n            growthProgress *= 1.5f;\n\n        UpdateGrowthStage(growthProgress);\n\n        if (growthProgress >= 1f)\n        {\n            _currentState = PatchState.ReadyToHarvest;\n            ShowFinalGrowthStage();\n        }\n    }\n\n    private void UpdateGrowthStage(float progress)\n    {\n        if (_growthStages.Count == 0)\n            return;\n\n        int targetStage = Mathf.FloorToInt(progress * _growthStages.Count);\n        targetStage = Mathf.Clamp(targetStage, 0, _growthStages.Count - 1);\n\n        if (targetStage != _currentGrowthStage)\n        {\n            _currentGrowthStage = targetStage;\n            ShowGrowthStage(targetStage);\n        }\n    }\n\n    private void ShowGrowthStage(int stageIndex)\n    {\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        if (stageIndex < _growthStages.Count && _growthStages[stageIndex].stagePrefab != null)\n        {\n            _currentPlantObject = Instantiate(_growthStages[stageIndex].stagePrefab, \n                _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentPlantObject.transform.SetParent(transform);\n        }\n    }\n\n    private void ShowFinalGrowthStage()\n    {\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        if (_currentPlant.plantPrefab != null)\n        {\n            _currentPlantObject = Instantiate(_currentPlant.plantPrefab, \n                _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentPlantObject.transform.SetParent(transform);\n        }\n    }\n\n    private void HandleWatering()\n    {\n        if (_isWatered && Time.time - _wateringTime > 300f) // 5 minutes\n        {\n            _isWatered = false;\n            UpdateSoilVisual();\n        }\n    }\n\n    private void UpdateVisuals()\n    {\n        // Update soil visual based on watering state\n        if (_currentState == PatchState.Empty || _currentState == PatchState.Watered)\n        {\n            UpdateSoilVisual();\n        }\n    }\n\n    private void UpdateSoilVisual()\n    {\n        if (_currentSoilObject != null)\n            DestroyImmediate(_currentSoilObject);\n\n        GameObject soilPrefab = _isWatered ? _wateredSoilPrefab : _soilPrefab;\n        if (soilPrefab != null)\n        {\n            _currentSoilObject = Instantiate(soilPrefab, _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentSoilObject.transform.SetParent(transform);\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (!_playerInRange)\n            return;\n\n        if (Input.GetKeyDown(KeyCode.E))\n        {\n            InteractWithPatch();\n        }\n        else if (Input.GetKeyDown(KeyCode.R))\n        {\n            WaterPatch();\n        }\n    }\n\n    public void InteractWithPatch()\n    {\n        switch (_currentState)\n        {\n            case PatchState.Empty:\n            case PatchState.Watered:\n                TryPlantSeed();\n                break;\n            case PatchState.ReadyToHarvest:\n                HarvestPlant();\n                break;\n        }\n    }\n\n    public void PlantSeed(int plantIndex)\n    {\n        if (plantIndex < 0 || plantIndex >= _availablePlants.Count)\n            return;\n\n        if (_currentState != PatchState.Empty && _currentState != PatchState.Watered)\n            return;\n\n        _currentPlant = _availablePlants[plantIndex];\n        _currentState = PatchState.Growing;\n        _plantingTime = Time.time;\n        _currentGrowthStage = -1;\n\n        PlaySound(_plantingSound);\n        PlayEffect(_plantingEffect);\n        OnPlantPlanted?.Invoke(_currentPlant.plantName);\n\n        if (_currentSoilObject != null)\n            _currentSoilObject.SetActive(false);\n    }\n\n    private void TryPlantSeed()\n    {\n        if (_availablePlants.Count > 0)\n        {\n            PlantSeed(0); // Plant first available seed\n        }\n    }\n\n    public void HarvestPlant()\n    {\n        if (_currentState != PatchState.ReadyToHarvest || _currentPlant == null)\n            return;\n\n        string harvestedPlant = _currentPlant.plantName;\n        int harvestAmount = _currentPlant.harvestAmount;\n\n        // Clean up current plant\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        // Reset patch state\n        _currentState = PatchState.Empty;\n        _currentPlant = null;\n        _currentGrowthStage = -1;\n        _isWatered = false;\n\n        // Show soil again\n        if (_currentSoilObject != null)\n            _currentSoilObject.SetActive(true);\n        else\n            UpdateSoilVisual();\n\n        PlaySound(_harvestSound);\n        PlayEffect(_harvestEffect);\n        OnPlantHarvested?.Invoke(harvestedPlant, harvestAmount);\n    }\n\n    public void WaterPatch()\n    {\n        if (_isWatered)\n            return;\n\n        _isWatered = true;\n        _wateringTime = Time.time;\n\n        if (_currentState == PatchState.Empty)\n            _currentState = PatchState.Watered;\n\n        UpdateSoilVisual();\n        PlaySound(_wateringSound);\n        OnPatchWatered?.Invoke();\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n            effect.Play();\n    }\n\n    public bool CanPlant()\n    {\n        return _currentState == PatchState.Empty || _currentState == PatchState.Watered;\n    }\n\n    public bool CanHarvest()\n    {\n        return _currentState == PatchState.ReadyToHarvest;\n    }\n\n    public bool IsWatered()\n    {\n        return _isWatered;\n    }\n\n    public float GetGrowthProgress()\n    {\n        if (_currentState != PatchState.Growing || _currentPlant == null)\n            return 0f;\n\n        float progress = (Time.time - _plantingTime) / _currentPlant.growthTime;\n        if (_isWatered)\n            progress *= 1.5f;\n\n        return Mathf.Clamp01(progress);\n    }\n\n    public string GetCurrentPlantName()\n    {\n        return _currentPlant?.plantName ?? \"\";\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "mailbox with letters",
      "ideal_ir": {
        "class_name": "Mailbox",
        "components": [
          "BoxCollider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "maxLetters",
            "type": "int",
            "default": 10
          },
          {
            "name": "currentLetterCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "isOpen",
            "type": "bool",
            "default": false
          },
          {
            "name": "deliverySound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "openSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "open_mailbox",
            "trigger": "when player interacts with mailbox",
            "actions": [
              {
                "action": "open mailbox door"
              },
              {
                "action": "play opening sound"
              },
              {
                "action": "set mailbox state to open"
              }
            ]
          },
          {
            "name": "close_mailbox",
            "trigger": "when player interacts with open mailbox",
            "actions": [
              {
                "action": "close mailbox door"
              },
              {
                "action": "set mailbox state to closed"
              }
            ]
          },
          {
            "name": "receive_letter",
            "trigger": "when mail carrier delivers letter",
            "actions": [
              {
                "action": "increase letter count by one"
              },
              {
                "action": "play delivery sound"
              },
              {
                "action": "show visual indicator for new mail"
              }
            ]
          },
          {
            "name": "collect_letters",
            "trigger": "when player takes letters from open mailbox",
            "actions": [
              {
                "action": "transfer all letters to player inventory"
              },
              {
                "action": "reset letter count to zero"
              },
              {
                "action": "hide new mail indicator"
              }
            ]
          },
          {
            "name": "show_mail_indicator",
            "trigger": "when mailbox has letters inside",
            "actions": [
              {
                "action": "display flag or light to indicate mail present"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class Mailbox : MonoBehaviour\n{\n    [System.Serializable]\n    public class Letter\n    {\n        public string senderName;\n        public string subject;\n        [TextArea(3, 10)]\n        public string content;\n        public bool isRead;\n        public Sprite letterIcon;\n    }\n\n    [System.Serializable]\n    public class MailboxEvent : UnityEvent<Letter> { }\n\n    [Header(\"Mailbox Settings\")]\n    [SerializeField] private List<Letter> _letters = new List<Letter>();\n    [SerializeField] private Transform _letterSpawnPoint;\n    [SerializeField] private GameObject _letterPrefab;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _hasMailIndicator;\n    [SerializeField] private AudioClip _openMailboxSound;\n    [SerializeField] private AudioClip _newLetterSound;\n    [SerializeField] private ParticleSystem _mailDeliveryEffect;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Animator _mailboxAnimator;\n    [SerializeField] private string _openAnimationTrigger = \"Open\";\n    [SerializeField] private string _closeAnimationTrigger = \"Close\";\n\n    [Header(\"Events\")]\n    public MailboxEvent OnLetterRead;\n    public UnityEvent OnMailboxOpened;\n    public UnityEvent OnMailboxClosed;\n    public UnityEvent OnNewLetterReceived;\n\n    private AudioSource _audioSource;\n    private bool _isOpen = false;\n    private bool _playerInRange = false;\n    private GameObject _currentPlayer;\n    private Canvas _mailboxUI;\n    private bool _hasUnreadMail = false;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        CreateMailboxUI();\n        UpdateMailIndicator();\n    }\n\n    private void Update()\n    {\n        CheckForPlayerInteraction();\n        HandleInput();\n    }\n\n    private void CheckForPlayerInteraction()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        bool playerFound = false;\n\n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                if (!_playerInRange)\n                {\n                    _playerInRange = true;\n                    _currentPlayer = col.gameObject;\n                    ShowInteractionPrompt(true);\n                }\n                playerFound = true;\n                break;\n            }\n        }\n\n        if (!playerFound && _playerInRange)\n        {\n            _playerInRange = false;\n            _currentPlayer = null;\n            ShowInteractionPrompt(false);\n            if (_isOpen)\n                CloseMailbox();\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            if (_isOpen)\n                CloseMailbox();\n            else\n                OpenMailbox();\n        }\n    }\n\n    private void OpenMailbox()\n    {\n        if (_isOpen) return;\n\n        _isOpen = true;\n        \n        if (_mailboxAnimator != null)\n            _mailboxAnimator.SetTrigger(_openAnimationTrigger);\n\n        PlaySound(_openMailboxSound);\n        ShowMailboxUI(true);\n        OnMailboxOpened?.Invoke();\n    }\n\n    private void CloseMailbox()\n    {\n        if (!_isOpen) return;\n\n        _isOpen = false;\n        \n        if (_mailboxAnimator != null)\n            _mailboxAnimator.SetTrigger(_closeAnimationTrigger);\n\n        ShowMailboxUI(false);\n        OnMailboxClosed?.Invoke();\n    }\n\n    public void AddLetter(Letter newLetter)\n    {\n        _letters.Add(newLetter);\n        PlaySound(_newLetterSound);\n        \n        if (_mailDeliveryEffect != null)\n            _mailDeliveryEffect.Play();\n\n        UpdateMailIndicator();\n        OnNewLetterReceived?.Invoke();\n\n        if (_letterPrefab != null && _letterSpawnPoint != null)\n        {\n            GameObject letterObj = Instantiate(_letterPrefab, _letterSpawnPoint.position, _letterSpawnPoint.rotation);\n            LetterItem letterItem = letterObj.GetComponent<LetterItem>();\n            if (letterItem == null)\n                letterItem = letterObj.AddComponent<LetterItem>();\n            letterItem.Initialize(newLetter);\n        }\n    }\n\n    public void ReadLetter(int letterIndex)\n    {\n        if (letterIndex >= 0 && letterIndex < _letters.Count)\n        {\n            _letters[letterIndex].isRead = true;\n            OnLetterRead?.Invoke(_letters[letterIndex]);\n            UpdateMailIndicator();\n        }\n    }\n\n    public void RemoveLetter(int letterIndex)\n    {\n        if (letterIndex >= 0 && letterIndex < _letters.Count)\n        {\n            _letters.RemoveAt(letterIndex);\n            UpdateMailIndicator();\n        }\n    }\n\n    private void UpdateMailIndicator()\n    {\n        _hasUnreadMail = false;\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n            {\n                _hasUnreadMail = true;\n                break;\n            }\n        }\n\n        if (_hasMailIndicator != null)\n            _hasMailIndicator.SetActive(_hasUnreadMail);\n    }\n\n    private void CreateMailboxUI()\n    {\n        GameObject uiObject = new GameObject(\"MailboxUI\");\n        _mailboxUI = uiObject.AddComponent<Canvas>();\n        _mailboxUI.renderMode = RenderMode.WorldSpace;\n        _mailboxUI.worldCamera = Camera.main;\n        \n        uiObject.transform.SetParent(transform);\n        uiObject.transform.localPosition = Vector3.up * 2f;\n        uiObject.transform.localScale = Vector3.one * 0.01f;\n        \n        _mailboxUI.gameObject.SetActive(false);\n    }\n\n    private void ShowMailboxUI(bool show)\n    {\n        if (_mailboxUI != null)\n            _mailboxUI.gameObject.SetActive(show);\n    }\n\n    private void ShowInteractionPrompt(bool show)\n    {\n        // This would typically show/hide UI prompt\n        // Implementation depends on your UI system\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    public int GetLetterCount()\n    {\n        return _letters.Count;\n    }\n\n    public int GetUnreadLetterCount()\n    {\n        int count = 0;\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n                count++;\n        }\n        return count;\n    }\n\n    public List<Letter> GetAllLetters()\n    {\n        return new List<Letter>(_letters);\n    }\n\n    public List<Letter> GetUnreadLetters()\n    {\n        List<Letter> unreadLetters = new List<Letter>();\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n                unreadLetters.Add(letter);\n        }\n        return unreadLetters;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}\n\npublic class LetterItem : MonoBehaviour\n{\n    private Mailbox.Letter _letterData;\n    private bool _isCollected = false;\n\n    public void Initialize(Mailbox.Letter letter)\n    {\n        _letterData = letter;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isCollected)\n        {\n            CollectLetter();\n        }\n    }\n\n    private void CollectLetter()\n    {\n        _isCollected = true;\n        \n        // Add visual/audio feedback here\n        Destroy(gameObject, 0.1f);\n    }\n\n    public Mailbox.Letter GetLetterData()\n    {\n        return _letterData;\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "phone with conversation",
      "ideal_ir": {
        "class_name": "ConversationPhone",
        "components": [
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "isRinging",
            "type": "bool",
            "default": false
          },
          {
            "name": "isInConversation",
            "type": "bool",
            "default": false
          },
          {
            "name": "ringVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "conversationVolume",
            "type": "float",
            "default": 0.6
          },
          {
            "name": "ringDuration",
            "type": "float",
            "default": 30.0
          }
        ],
        "behaviors": [
          {
            "name": "start_ringing",
            "trigger": "when phone receives incoming call",
            "actions": [
              {
                "action": "play ringing sound at ring volume"
              },
              {
                "action": "set phone to ringing state"
              },
              {
                "action": "make phone visually indicate incoming call"
              }
            ]
          },
          {
            "name": "answer_phone",
            "trigger": "when player interacts with ringing phone",
            "actions": [
              {
                "action": "stop ringing sound"
              },
              {
                "action": "start conversation audio"
              },
              {
                "action": "set phone to conversation state"
              },
              {
                "action": "disable ringing state"
              }
            ]
          },
          {
            "name": "end_conversation",
            "trigger": "when conversation audio finishes playing",
            "actions": [
              {
                "action": "stop conversation audio"
              },
              {
                "action": "set phone to idle state"
              },
              {
                "action": "disable conversation state"
              }
            ]
          },
          {
            "name": "hang_up",
            "trigger": "when player interacts with phone during conversation",
            "actions": [
              {
                "action": "stop conversation audio immediately"
              },
              {
                "action": "play hang up sound"
              },
              {
                "action": "set phone to idle state"
              }
            ]
          },
          {
            "name": "stop_ringing_timeout",
            "trigger": "when phone has been ringing for maximum duration",
            "actions": [
              {
                "action": "stop ringing sound"
              },
              {
                "action": "set phone to idle state"
              },
              {
                "action": "disable ringing state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Phone : MonoBehaviour\n{\n    [System.Serializable]\n    public class ConversationLine\n    {\n        public string speakerName;\n        [TextArea(2, 4)]\n        public string text;\n        public float displayDuration = 3f;\n        public AudioClip voiceClip;\n    }\n\n    [System.Serializable]\n    public class Conversation\n    {\n        public string conversationName;\n        public List<ConversationLine> lines = new List<ConversationLine>();\n        public bool canSkip = true;\n        public bool autoAdvance = true;\n    }\n\n    [Header(\"Phone Settings\")]\n    [SerializeField] private GameObject _phoneUI;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactKey = KeyCode.E;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"UI Components\")]\n    [SerializeField] private Text _speakerNameText;\n    [SerializeField] private Text _conversationText;\n    [SerializeField] private Button _nextButton;\n    [SerializeField] private Button _skipButton;\n    [SerializeField] private Button _hangUpButton;\n    [SerializeField] private Image _phoneScreen;\n    [SerializeField] private GameObject _interactionPrompt;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _ringTone;\n    [SerializeField] private AudioClip _dialTone;\n    [SerializeField] private AudioClip _hangUpSound;\n    [SerializeField] private float _ringVolume = 0.7f;\n\n    [Header(\"Conversations\")]\n    [SerializeField] private List<Conversation> _conversations = new List<Conversation>();\n    [SerializeField] private int _currentConversationIndex = 0;\n    [SerializeField] private bool _randomizeConversations = false;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _ringingEffect;\n    [SerializeField] private Color _activeScreenColor = Color.green;\n    [SerializeField] private Color _inactiveScreenColor = Color.black;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPhoneRing;\n    public UnityEvent OnConversationStart;\n    public UnityEvent OnConversationEnd;\n    public UnityEvent OnPlayerNearby;\n    public UnityEvent OnPlayerLeft;\n\n    private bool _isRinging = false;\n    private bool _isInConversation = false;\n    private bool _playerInRange = false;\n    private int _currentLineIndex = 0;\n    private Conversation _currentConversation;\n    private Coroutine _conversationCoroutine;\n    private Coroutine _ringingCoroutine;\n    private Transform _playerTransform;\n\n    private void Start()\n    {\n        InitializePhone();\n        SetupUI();\n        \n        if (_conversations.Count > 0)\n        {\n            StartRinging();\n        }\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n\n    private void InitializePhone()\n    {\n        if (_phoneUI != null)\n            _phoneUI.SetActive(false);\n\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n\n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(false);\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        UpdateScreenColor(_inactiveScreenColor);\n    }\n\n    private void SetupUI()\n    {\n        if (_nextButton != null)\n            _nextButton.onClick.AddListener(NextLine);\n\n        if (_skipButton != null)\n            _skipButton.onClick.AddListener(SkipConversation);\n\n        if (_hangUpButton != null)\n            _hangUpButton.onClick.AddListener(HangUp);\n    }\n\n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange;\n\n        if (_playerInRange && !wasInRange)\n        {\n            _playerTransform = player.transform;\n            OnPlayerNearby.Invoke();\n            ShowInteractionPrompt(true);\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            _playerTransform = null;\n            OnPlayerLeft.Invoke();\n            ShowInteractionPrompt(false);\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (!_playerInRange) return;\n\n        if (Input.GetKeyDown(_interactKey))\n        {\n            if (_isRinging && !_isInConversation)\n            {\n                AnswerPhone();\n            }\n            else if (_isInConversation)\n            {\n                NextLine();\n            }\n        }\n\n        if (Input.GetKeyDown(KeyCode.Escape) && _isInConversation)\n        {\n            HangUp();\n        }\n    }\n\n    private void ShowInteractionPrompt(bool show)\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(show && (_isRinging || _isInConversation));\n    }\n\n    public void StartRinging()\n    {\n        if (_isInConversation || _conversations.Count == 0) return;\n\n        _isRinging = true;\n        \n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(true);\n\n        OnPhoneRing.Invoke();\n        ShowInteractionPrompt(_playerInRange);\n\n        if (_ringingCoroutine != null)\n            StopCoroutine(_ringingCoroutine);\n        \n        _ringingCoroutine = StartCoroutine(PlayRingTone());\n    }\n\n    public void AnswerPhone()\n    {\n        if (!_isRinging || _isInConversation) return;\n\n        StopRinging();\n        StartConversation();\n    }\n\n    private void StopRinging()\n    {\n        _isRinging = false;\n        \n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(false);\n\n        if (_ringingCoroutine != null)\n        {\n            StopCoroutine(_ringingCoroutine);\n            _ringingCoroutine = null;\n        }\n\n        _audioSource.Stop();\n    }\n\n    private void StartConversation()\n    {\n        if (_conversations.Count == 0) return;\n\n        _isInConversation = true;\n        _currentLineIndex = 0;\n\n        if (_randomizeConversations)\n        {\n            _currentConversationIndex = Random.Range(0, _conversations.Count);\n        }\n\n        _currentConversation = _conversations[_currentConversationIndex];\n        \n        if (_phoneUI != null)\n            _phoneUI.SetActive(true);\n\n        UpdateScreenColor(_activeScreenColor);\n        OnConversationStart.Invoke();\n\n        if (_dialTone != null)\n        {\n            _audioSource.PlayOneShot(_dialTone);\n        }\n\n        ShowInteractionPrompt(_playerInRange);\n        DisplayCurrentLine();\n    }\n\n    private void DisplayCurrentLine()\n    {\n        if (_currentConversation == null || _currentLineIndex >= _currentConversation.lines.Count)\n        {\n            EndConversation();\n            return;\n        }\n\n        ConversationLine currentLine = _currentConversation.lines[_currentLineIndex];\n\n        if (_speakerNameText != null)\n            _speakerNameText.text = currentLine.speakerName;\n\n        if (_conversationText != null)\n            _conversationText.text = currentLine.text;\n\n        if (currentLine.voiceClip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(currentLine.voiceClip);\n        }\n\n        UpdateUIButtons();\n\n        if (_currentConversation.autoAdvance)\n        {\n            if (_conversationCoroutine != null)\n                StopCoroutine(_conversationCoroutine);\n            \n            _conversationCoroutine = StartCoroutine(AutoAdvanceLine(currentLine.displayDuration));\n        }\n    }\n\n    private void UpdateUIButtons()\n    {\n        bool isLastLine = _currentLineIndex >= _currentConversation.lines.Count - 1;\n        \n        if (_nextButton != null)\n            _nextButton.gameObject.SetActive(!isLastLine || !_currentConversation.autoAdvance);\n\n        if (_skipButton != null)\n            _skipButton.gameObject.SetActive(_currentConversation.canSkip);\n    }\n\n    public void NextLine()\n    {\n        if (!_isInConversation) return;\n\n        if (_conversationCoroutine != null)\n        {\n            StopCoroutine(_conversationCoroutine);\n            _conversationCoroutine = null;\n        }\n\n        _currentLineIndex++;\n        DisplayCurrentLine();\n    }\n\n    public void SkipConversation()\n    {\n        if (!_isInConversation || !_currentConversation.canSkip) return;\n\n        EndConversation();\n    }\n\n    public void HangUp()\n    {\n        if (_isInConversation)\n        {\n            EndConversation();\n        }\n        else if (_isRinging)\n        {\n            StopRinging();\n        }\n    }\n\n    private void EndConversation()\n    {\n        _isInConversation = false;\n        \n        if (_conversationCoroutine != null)\n        {\n            StopCoroutine(_conversationCoroutine);\n            _conversationCoroutine = null;\n        }\n\n        if (_phoneUI != null)\n            _phoneUI.SetActive(false);\n\n        UpdateScreenColor(_inactiveScreenColor);\n        ShowInteractionPrompt(false);\n\n        if (_hangUpSound != null)\n        {\n            _audioSource.PlayOneShot(_hangUpSound);\n        }\n\n        OnConversationEnd.Invoke();\n\n        // Move to next conversation for future calls\n        _currentConversationIndex = (_currentConversationIndex + 1) % _conversations.Count;\n    }\n\n    private IEnumerator AutoAdvanceLine(float duration)\n    {\n        yield return new WaitForSeconds(duration);\n        NextLine();\n    }\n\n    private IEnumerator PlayRingTone()\n    {\n        while (_isRinging)\n        {\n            if (_ringTone != null)\n            {\n                _audioSource.PlayOneShot(_ringTone, _ringVolume);\n                yield return new WaitForSeconds(_ringTone.length + 1f);\n            }\n            else\n            {\n                yield return new WaitForSeconds(2f);\n            }\n        }\n    }\n\n    private void UpdateScreenColor(Color color)\n    {\n        if (_phoneScreen != null)\n            _phoneScreen.color = color;\n    }\n\n    public void AddConversation(Conversation conversation)\n    {\n        _conversations.Add(conversation);\n    }\n\n    public void TriggerCall()\n    {\n        if (!_isRinging && !_isInConversation)\n        {\n            StartRinging();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n\n    private void OnDisable()\n    {\n        if (_conversationCoroutine != null)\n            StopCoroutine(_conversationCoroutine);\n        \n        if (_ringingCoroutine != null)\n            StopCoroutine(_ringingCoroutine);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "elevator with floor selection",
      "ideal_ir": {
        "class_name": "Elevator",
        "components": [
          "Transform",
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "currentFloor",
            "type": "int",
            "default": 1
          },
          {
            "name": "targetFloor",
            "type": "int",
            "default": 1
          },
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "floorHeight",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "maxFloor",
            "type": "int",
            "default": 10
          },
          {
            "name": "minFloor",
            "type": "int",
            "default": 1
          },
          {
            "name": "isMoving",
            "type": "bool",
            "default": false
          },
          {
            "name": "doorOpenTime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "doorsOpen",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "select_floor",
            "trigger": "when floor button is pressed",
            "actions": [
              {
                "action": "set target floor to selected floor number"
              },
              {
                "action": "close doors if they are open"
              },
              {
                "action": "play button press sound"
              }
            ]
          },
          {
            "name": "move_to_target_floor",
            "trigger": "when target floor is different from current floor and doors are closed",
            "actions": [
              {
                "action": "set moving state to true"
              },
              {
                "action": "play elevator movement sound"
              },
              {
                "action": "move elevator vertically toward target floor position"
              }
            ]
          },
          {
            "name": "arrive_at_floor",
            "trigger": "when elevator reaches target floor position",
            "actions": [
              {
                "action": "set moving state to false"
              },
              {
                "action": "update current floor to target floor"
              },
              {
                "action": "stop movement sound"
              },
              {
                "action": "play arrival chime"
              },
              {
                "action": "open doors"
              }
            ]
          },
          {
            "name": "close_doors_automatically",
            "trigger": "when doors have been open for the specified time",
            "actions": [
              {
                "action": "close doors"
              },
              {
                "action": "play door closing sound"
              }
            ]
          },
          {
            "name": "prevent_invalid_selection",
            "trigger": "when selected floor is outside valid range",
            "actions": [
              {
                "action": "play error sound"
              },
              {
                "action": "ignore floor selection"
              }
            ]
          },
          {
            "name": "emergency_stop",
            "trigger": "when emergency button is pressed",
            "actions": [
              {
                "action": "stop all movement immediately"
              },
              {
                "action": "set moving state to false"
              },
              {
                "action": "play emergency alarm"
              },
              {
                "action": "open doors"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Elevator : MonoBehaviour\n{\n    [System.Serializable]\n    public class Floor\n    {\n        public string floorName;\n        public Transform floorPosition;\n        public Button floorButton;\n        public bool isAccessible = true;\n    }\n\n    [Header(\"Elevator Settings\")]\n    [SerializeField] private Transform _elevatorCabin;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _doorOpenTime = 3f;\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n\n    [Header(\"Floors\")]\n    [SerializeField] private List<Floor> _floors = new List<Floor>();\n    [SerializeField] private int _currentFloorIndex = 0;\n\n    [Header(\"Doors\")]\n    [SerializeField] private Transform _leftDoor;\n    [SerializeField] private Transform _rightDoor;\n    [SerializeField] private Vector3 _doorOpenOffset = new Vector3(1.5f, 0, 0);\n    [SerializeField] private float _doorSpeed = 1f;\n\n    [Header(\"UI\")]\n    [SerializeField] private Text _floorDisplay;\n    [SerializeField] private Text _statusDisplay;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _movingSound;\n    [SerializeField] private AudioClip _arrivalSound;\n    [SerializeField] private AudioClip _doorSound;\n\n    [Header(\"Lights\")]\n    [SerializeField] private Light _elevatorLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _movingLightColor = Color.yellow;\n\n    private bool _isMoving = false;\n    private bool _doorsOpen = false;\n    private Vector3 _leftDoorClosedPos;\n    private Vector3 _rightDoorClosedPos;\n    private Queue<int> _floorQueue = new Queue<int>();\n    private Coroutine _currentMovement;\n\n    private void Start()\n    {\n        InitializeElevator();\n        SetupFloorButtons();\n        UpdateDisplay();\n        StartCoroutine(OpenDoorsRoutine());\n    }\n\n    private void InitializeElevator()\n    {\n        if (_elevatorCabin == null)\n            _elevatorCabin = transform;\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_leftDoor != null)\n            _leftDoorClosedPos = _leftDoor.localPosition;\n\n        if (_rightDoor != null)\n            _rightDoorClosedPos = _rightDoor.localPosition;\n\n        if (_floors.Count > 0 && _currentFloorIndex < _floors.Count)\n        {\n            _elevatorCabin.position = _floors[_currentFloorIndex].floorPosition.position;\n        }\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _normalLightColor;\n    }\n\n    private void SetupFloorButtons()\n    {\n        for (int i = 0; i < _floors.Count; i++)\n        {\n            int floorIndex = i;\n            if (_floors[i].floorButton != null)\n            {\n                _floors[i].floorButton.onClick.AddListener(() => RequestFloor(floorIndex));\n                UpdateButtonState(i);\n            }\n        }\n    }\n\n    public void RequestFloor(int floorIndex)\n    {\n        if (floorIndex < 0 || floorIndex >= _floors.Count)\n            return;\n\n        if (!_floors[floorIndex].isAccessible)\n        {\n            UpdateStatus(\"Floor not accessible\");\n            return;\n        }\n\n        if (floorIndex == _currentFloorIndex)\n        {\n            if (!_doorsOpen)\n                StartCoroutine(OpenDoorsRoutine());\n            return;\n        }\n\n        if (!_floorQueue.Contains(floorIndex))\n        {\n            _floorQueue.Enqueue(floorIndex);\n            UpdateButtonState(floorIndex);\n        }\n\n        if (!_isMoving)\n            StartCoroutine(ProcessFloorQueue());\n    }\n\n    private IEnumerator ProcessFloorQueue()\n    {\n        while (_floorQueue.Count > 0)\n        {\n            int targetFloor = _floorQueue.Dequeue();\n            yield return StartCoroutine(MoveToFloor(targetFloor));\n            UpdateButtonState(targetFloor);\n        }\n    }\n\n    private IEnumerator MoveToFloor(int targetFloorIndex)\n    {\n        if (targetFloorIndex == _currentFloorIndex)\n            yield break;\n\n        _isMoving = true;\n        UpdateStatus(\"Moving...\");\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _movingLightColor;\n\n        yield return StartCoroutine(CloseDoorsRoutine());\n\n        Vector3 startPos = _elevatorCabin.position;\n        Vector3 targetPos = _floors[targetFloorIndex].floorPosition.position;\n        float distance = Vector3.Distance(startPos, targetPos);\n        float duration = distance / _moveSpeed;\n\n        PlaySound(_movingSound, true);\n\n        float elapsed = 0f;\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = _movementCurve.Evaluate(elapsed / duration);\n            _elevatorCabin.position = Vector3.Lerp(startPos, targetPos, progress);\n            yield return null;\n        }\n\n        _elevatorCabin.position = targetPos;\n        _currentFloorIndex = targetFloorIndex;\n\n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n\n        PlaySound(_arrivalSound);\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _normalLightColor;\n\n        _isMoving = false;\n        UpdateDisplay();\n        UpdateStatus(\"Arrived\");\n\n        yield return StartCoroutine(OpenDoorsRoutine());\n    }\n\n    private IEnumerator OpenDoorsRoutine()\n    {\n        if (_doorsOpen)\n            yield break;\n\n        PlaySound(_doorSound);\n        UpdateStatus(\"Opening doors...\");\n\n        Vector3 leftTarget = _leftDoorClosedPos - _doorOpenOffset;\n        Vector3 rightTarget = _rightDoorClosedPos + _doorOpenOffset;\n\n        float elapsed = 0f;\n        float duration = 1f / _doorSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n\n            if (_leftDoor != null)\n                _leftDoor.localPosition = Vector3.Lerp(_leftDoorClosedPos, leftTarget, progress);\n\n            if (_rightDoor != null)\n                _rightDoor.localPosition = Vector3.Lerp(_rightDoorClosedPos, rightTarget, progress);\n\n            yield return null;\n        }\n\n        _doorsOpen = true;\n        UpdateStatus(\"Doors open\");\n\n        yield return new WaitForSeconds(_doorOpenTime);\n\n        if (!_isMoving && _floorQueue.Count == 0)\n            yield return StartCoroutine(CloseDoorsRoutine());\n    }\n\n    private IEnumerator CloseDoorsRoutine()\n    {\n        if (!_doorsOpen)\n            yield break;\n\n        PlaySound(_doorSound);\n        UpdateStatus(\"Closing doors...\");\n\n        Vector3 leftCurrent = _leftDoor != null ? _leftDoor.localPosition : _leftDoorClosedPos;\n        Vector3 rightCurrent = _rightDoor != null ? _rightDoor.localPosition : _rightDoorClosedPos;\n\n        float elapsed = 0f;\n        float duration = 1f / _doorSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n\n            if (_leftDoor != null)\n                _leftDoor.localPosition = Vector3.Lerp(leftCurrent, _leftDoorClosedPos, progress);\n\n            if (_rightDoor != null)\n                _rightDoor.localPosition = Vector3.Lerp(rightCurrent, _rightDoorClosedPos, progress);\n\n            yield return null;\n        }\n\n        _doorsOpen = false;\n        UpdateStatus(\"Doors closed\");\n    }\n\n    private void UpdateDisplay()\n    {\n        if (_floorDisplay != null && _currentFloorIndex < _floors.Count)\n        {\n            _floorDisplay.text = _floors[_currentFloorIndex].floorName;\n        }\n    }\n\n    private void UpdateStatus(string status)\n    {\n        if (_statusDisplay != null)\n            _statusDisplay.text = status;\n    }\n\n    private void UpdateButtonState(int floorIndex)\n    {\n        if (floorIndex < 0 || floorIndex >= _floors.Count)\n            return;\n\n        Button button = _floors[floorIndex].floorButton;\n        if (button != null)\n        {\n            bool isQueued = _floorQueue.Contains(floorIndex);\n            bool isCurrent = floorIndex == _currentFloorIndex;\n            \n            ColorBlock colors = button.colors;\n            colors.normalColor = isCurrent ? Color.green : (isQueued ? Color.yellow : Color.white);\n            button.colors = colors;\n            \n            button.interactable = _floors[floorIndex].isAccessible && !isCurrent;\n        }\n    }\n\n    private void PlaySound(AudioClip clip, bool loop = false)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.loop = loop;\n            _audioSource.Play();\n        }\n    }\n\n    public void SetFloorAccessibility(int floorIndex, bool accessible)\n    {\n        if (floorIndex >= 0 && floorIndex < _floors.Count)\n        {\n            _floors[floorIndex].isAccessible = accessible;\n            UpdateButtonState(floorIndex);\n        }\n    }\n\n    public int GetCurrentFloor()\n    {\n        return _currentFloorIndex;\n    }\n\n    public bool IsMoving()\n    {\n        return _isMoving;\n    }\n\n    public bool AreDoorsOpen()\n    {\n        return _doorsOpen;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _doorsOpen)\n        {\n            UpdateStatus(\"Welcome aboard!\");\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _doorsOpen)\n        {\n            UpdateStatus(\"Doors open\");\n        }\n    }\n\n    private void OnValidate()\n    {\n        if (_floors != null)\n        {\n            for (int i = 0; i < _floors.Count; i++)\n            {\n                if (string.IsNullOrEmpty(_floors[i].floorName))\n                    _floors[i].floorName = \"Floor \" + (i + 1);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "bridge that extends",
      "ideal_ir": {
        "class_name": "ExtendingBridge",
        "components": [
          "Transform",
          "Renderer"
        ],
        "fields": [
          {
            "name": "extensionSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "maxLength",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isExtending",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentLength",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "start_extending",
            "trigger": "when player approaches bridge activation area",
            "actions": [
              {
                "action": "begin extending the bridge forward"
              },
              {
                "action": "play bridge extension sound effect"
              }
            ]
          },
          {
            "name": "extend_bridge",
            "trigger": "while bridge is extending and has not reached maximum length",
            "actions": [
              {
                "action": "increase bridge length gradually"
              },
              {
                "action": "update bridge visual appearance to show extension"
              }
            ]
          },
          {
            "name": "stop_extending",
            "trigger": "when bridge reaches maximum length",
            "actions": [
              {
                "action": "stop bridge extension"
              },
              {
                "action": "play bridge completion sound"
              },
              {
                "action": "make bridge solid and walkable"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExtendingBridge : MonoBehaviour\n{\n    [Header(\"Bridge Settings\")]\n    [SerializeField] private Transform _bridgeSegment;\n    [SerializeField] private float _extendDistance = 10f;\n    [SerializeField] private float _extendSpeed = 2f;\n    [SerializeField] private bool _autoExtend = false;\n    [SerializeField] private float _autoExtendDelay = 1f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _usePlayerTrigger = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private KeyCode _manualExtendKey = KeyCode.E;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _extendSound;\n    [SerializeField] private AudioClip _retractSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBridgeExtended;\n    public UnityEvent OnBridgeRetracted;\n    public UnityEvent OnExtensionComplete;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _extendedPosition;\n    private bool _isExtended = false;\n    private bool _isExtending = false;\n    private bool _isRetracting = false;\n    private bool _playerInRange = false;\n    private Coroutine _autoExtendCoroutine;\n    \n    private void Start()\n    {\n        if (_bridgeSegment == null)\n            _bridgeSegment = transform;\n            \n        _originalPosition = _bridgeSegment.position;\n        _extendedPosition = _originalPosition + _bridgeSegment.forward * _extendDistance;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_autoExtend)\n        {\n            _autoExtendCoroutine = StartCoroutine(AutoExtendCoroutine());\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_autoExtend)\n        {\n            HandleManualInput();\n        }\n        \n        HandleBridgeMovement();\n    }\n    \n    private void HandleManualInput()\n    {\n        bool shouldExtend = false;\n        \n        if (_usePlayerTrigger && _playerInRange && Input.GetKeyDown(_manualExtendKey))\n        {\n            shouldExtend = true;\n        }\n        else if (!_usePlayerTrigger && Input.GetKeyDown(_manualExtendKey))\n        {\n            shouldExtend = true;\n        }\n        \n        if (shouldExtend)\n        {\n            if (!_isExtended && !_isExtending)\n            {\n                ExtendBridge();\n            }\n            else if (_isExtended && !_isRetracting)\n            {\n                RetractBridge();\n            }\n        }\n    }\n    \n    private void HandleBridgeMovement()\n    {\n        if (_isExtending)\n        {\n            _bridgeSegment.position = Vector3.MoveTowards(_bridgeSegment.position, _extendedPosition, _extendSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(_bridgeSegment.position, _extendedPosition) < 0.01f)\n            {\n                _bridgeSegment.position = _extendedPosition;\n                _isExtending = false;\n                _isExtended = true;\n                OnExtensionComplete?.Invoke();\n            }\n        }\n        else if (_isRetracting)\n        {\n            _bridgeSegment.position = Vector3.MoveTowards(_bridgeSegment.position, _originalPosition, _extendSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(_bridgeSegment.position, _originalPosition) < 0.01f)\n            {\n                _bridgeSegment.position = _originalPosition;\n                _isRetracting = false;\n                _isExtended = false;\n                OnExtensionComplete?.Invoke();\n            }\n        }\n    }\n    \n    public void ExtendBridge()\n    {\n        if (_isExtended || _isExtending) return;\n        \n        _isExtending = true;\n        OnBridgeExtended?.Invoke();\n        \n        if (_audioSource != null && _extendSound != null)\n        {\n            _audioSource.PlayOneShot(_extendSound);\n        }\n    }\n    \n    public void RetractBridge()\n    {\n        if (!_isExtended || _isRetracting) return;\n        \n        _isRetracting = true;\n        OnBridgeRetracted?.Invoke();\n        \n        if (_audioSource != null && _retractSound != null)\n        {\n            _audioSource.PlayOneShot(_retractSound);\n        }\n    }\n    \n    public void ToggleBridge()\n    {\n        if (_isExtended || _isRetracting)\n        {\n            RetractBridge();\n        }\n        else if (!_isExtended || _isExtending)\n        {\n            ExtendBridge();\n        }\n    }\n    \n    private System.Collections.IEnumerator AutoExtendCoroutine()\n    {\n        yield return new WaitForSeconds(_autoExtendDelay);\n        ExtendBridge();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_usePlayerTrigger && other.CompareTag(_playerTag))\n        {\n            _playerInRange = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_usePlayerTrigger && other.CompareTag(_playerTag))\n        {\n            _playerInRange = false;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_bridgeSegment == null) return;\n        \n        Vector3 startPos = Application.isPlaying ? _originalPosition : _bridgeSegment.position;\n        Vector3 endPos = startPos + _bridgeSegment.forward * _extendDistance;\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawLine(startPos, endPos);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(endPos, Vector3.one * 0.5f);\n    }\n    \n    public bool IsExtended => _isExtended;\n    public bool IsMoving => _isExtending || _isRetracting;\n    public float ExtensionProgress\n    {\n        get\n        {\n            if (_bridgeSegment == null) return 0f;\n            float totalDistance = Vector3.Distance(_originalPosition, _extendedPosition);\n            float currentDistance = Vector3.Distance(_originalPosition, _bridgeSegment.position);\n            return Mathf.Clamp01(currentDistance / totalDistance);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "gate that requires key",
      "ideal_ir": {
        "class_name": "KeyGate",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isLocked",
            "type": "bool",
            "default": true
          },
          {
            "name": "requiredKeyName",
            "type": "string",
            "default": "GateKey"
          },
          {
            "name": "openHeight",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "openSpeed",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "check_for_key_interaction",
            "trigger": "when player enters trigger area",
            "actions": [
              {
                "action": "check if player has required key in inventory"
              },
              {
                "action": "if player has key then unlock gate and remove key from inventory"
              },
              {
                "action": "if player does not have key then display message that key is required"
              }
            ]
          },
          {
            "name": "open_gate",
            "trigger": "when gate becomes unlocked",
            "actions": [
              {
                "action": "play gate opening sound"
              },
              {
                "action": "smoothly move gate upward to open height"
              },
              {
                "action": "disable gate collider when fully open"
              }
            ]
          },
          {
            "name": "block_passage",
            "trigger": "when gate is locked and player tries to pass through",
            "actions": [
              {
                "action": "prevent player movement through gate area"
              },
              {
                "action": "display locked gate message"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class KeyGate : MonoBehaviour\n{\n    [Header(\"Gate Settings\")]\n    [SerializeField] private string _requiredKeyTag = \"Key\";\n    [SerializeField] private float _openHeight = 3f;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private bool _stayOpen = true;\n    [SerializeField] private float _autoCloseDelay = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _unlockSound;\n    [SerializeField] private AudioClip _lockedSound;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _lockedIndicator;\n    [SerializeField] private GameObject _unlockedIndicator;\n    [SerializeField] private ParticleSystem _unlockEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGateUnlocked;\n    public UnityEvent OnGateOpened;\n    public UnityEvent OnGateClosed;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isUnlocked = false;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private AudioSource _audioSource;\n    private Collider _gateCollider;\n    private float _autoCloseTimer;\n    \n    private void Start()\n    {\n        _closedPosition = transform.position;\n        _openPosition = _closedPosition + Vector3.up * _openHeight;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _gateCollider = GetComponent<Collider>();\n        if (_gateCollider == null)\n        {\n            _gateCollider = gameObject.AddComponent<BoxCollider>();\n        }\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void Update()\n    {\n        HandleGateMovement();\n        HandleAutoClose();\n    }\n    \n    private void HandleGateMovement()\n    {\n        if (!_isMoving) return;\n        \n        Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _openSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.01f)\n        {\n            transform.position = targetPosition;\n            _isMoving = false;\n            \n            if (_isOpen)\n            {\n                OnGateOpened?.Invoke();\n                if (!_stayOpen)\n                {\n                    _autoCloseTimer = _autoCloseDelay;\n                }\n            }\n            else\n            {\n                OnGateClosed?.Invoke();\n                if (_gateCollider != null)\n                {\n                    _gateCollider.enabled = true;\n                }\n            }\n        }\n    }\n    \n    private void HandleAutoClose()\n    {\n        if (!_stayOpen && _isOpen && !_isMoving && _autoCloseTimer > 0f)\n        {\n            _autoCloseTimer -= Time.deltaTime;\n            if (_autoCloseTimer <= 0f)\n            {\n                CloseGate();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        if (!_isUnlocked)\n        {\n            if (PlayerHasKey(other))\n            {\n                UnlockGate(other);\n            }\n            else\n            {\n                PlayLockedFeedback();\n            }\n        }\n        else if (!_isOpen && !_isMoving)\n        {\n            OpenGate();\n        }\n    }\n    \n    private bool PlayerHasKey(Collider player)\n    {\n        KeyItem[] keys = player.GetComponentsInChildren<KeyItem>();\n        foreach (KeyItem key in keys)\n        {\n            if (key.CompareTag(_requiredKeyTag))\n            {\n                return true;\n            }\n        }\n        \n        GameObject[] childObjects = new GameObject[player.transform.childCount];\n        for (int i = 0; i < player.transform.childCount; i++)\n        {\n            childObjects[i] = player.transform.GetChild(i).gameObject;\n        }\n        \n        foreach (GameObject child in childObjects)\n        {\n            if (child.CompareTag(_requiredKeyTag))\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void UnlockGate(Collider player)\n    {\n        _isUnlocked = true;\n        \n        ConsumeKey(player);\n        \n        PlaySound(_unlockSound);\n        UpdateVisualFeedback();\n        \n        if (_unlockEffect != null)\n        {\n            _unlockEffect.Play();\n        }\n        \n        OnGateUnlocked?.Invoke();\n        \n        OpenGate();\n    }\n    \n    private void ConsumeKey(Collider player)\n    {\n        KeyItem[] keys = player.GetComponentsInChildren<KeyItem>();\n        foreach (KeyItem key in keys)\n        {\n            if (key.CompareTag(_requiredKeyTag))\n            {\n                Destroy(key.gameObject);\n                return;\n            }\n        }\n        \n        for (int i = 0; i < player.transform.childCount; i++)\n        {\n            GameObject child = player.transform.GetChild(i).gameObject;\n            if (child.CompareTag(_requiredKeyTag))\n            {\n                Destroy(child);\n                return;\n            }\n        }\n    }\n    \n    private void OpenGate()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        if (_gateCollider != null)\n        {\n            _gateCollider.enabled = false;\n        }\n        \n        PlaySound(_openSound);\n    }\n    \n    private void CloseGate()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _isMoving = true;\n        \n        PlaySound(_closeSound);\n    }\n    \n    private void PlayLockedFeedback()\n    {\n        PlaySound(_lockedSound);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_lockedIndicator != null)\n        {\n            _lockedIndicator.SetActive(!_isUnlocked);\n        }\n        \n        if (_unlockedIndicator != null)\n        {\n            _unlockedIndicator.SetActive(_isUnlocked);\n        }\n    }\n    \n    public void ForceUnlock()\n    {\n        _isUnlocked = true;\n        UpdateVisualFeedback();\n        OnGateUnlocked?.Invoke();\n    }\n    \n    public void ForceOpen()\n    {\n        if (_isUnlocked)\n        {\n            OpenGate();\n        }\n    }\n    \n    public void ForceClose()\n    {\n        CloseGate();\n    }\n}\n\n[System.Serializable]\npublic class KeyItem : MonoBehaviour\n{\n    [Header(\"Key Settings\")]\n    [SerializeField] private string _keyType = \"DefaultKey\";\n    \n    public string KeyType => _keyType;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "alarm that triggers on detection",
      "ideal_ir": {
        "class_name": "AlarmSystem",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 10
          },
          {
            "name": "isTriggered",
            "type": "bool",
            "default": false
          },
          {
            "name": "alarmDuration",
            "type": "float",
            "default": 5
          },
          {
            "name": "playerTag",
            "type": "string",
            "default": "Player"
          }
        ],
        "behaviors": [
          {
            "name": "detect_player",
            "trigger": "when player enters detection radius",
            "actions": [
              {
                "action": "set alarm as triggered"
              },
              {
                "action": "play alarm sound"
              },
              {
                "action": "start alarm duration timer"
              }
            ]
          },
          {
            "name": "stop_alarm",
            "trigger": "when alarm duration timer expires",
            "actions": [
              {
                "action": "stop alarm sound"
              },
              {
                "action": "set alarm as not triggered"
              }
            ]
          },
          {
            "name": "reset_on_player_exit",
            "trigger": "when player exits detection radius and alarm is not triggered",
            "actions": [
              {
                "action": "ensure alarm remains inactive"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class AlarmSystem : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private bool _requireLineOfSight = true;\n    [SerializeField] private LayerMask _obstacleLayers = 1;\n    \n    [Header(\"Alarm Settings\")]\n    [SerializeField] private float _alarmDuration = 5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _resetOnLostTarget = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _alarmSound;\n    [SerializeField] private bool _loopAlarmSound = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _alarmLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _alarmLightColor = Color.red;\n    [SerializeField] private float _flashSpeed = 2f;\n    [SerializeField] private Renderer _indicatorRenderer;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _alarmMaterial;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onAlarmTriggered;\n    [SerializeField] private UnityEvent _onAlarmStopped;\n    [SerializeField] private UnityEvent _onTargetDetected;\n    [SerializeField] private UnityEvent _onTargetLost;\n    \n    private bool _isAlarmActive = false;\n    private bool _targetDetected = false;\n    private bool _isOnCooldown = false;\n    private float _alarmTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Transform _currentTarget;\n    private Coroutine _flashCoroutine;\n    \n    private enum AlarmState\n    {\n        Idle,\n        Detecting,\n        Alarming,\n        Cooldown\n    }\n    \n    private AlarmState _currentState = AlarmState.Idle;\n    \n    void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_alarmLight == null)\n            _alarmLight = GetComponentInChildren<Light>();\n            \n        if (_indicatorRenderer == null)\n            _indicatorRenderer = GetComponent<Renderer>();\n            \n        SetNormalState();\n    }\n    \n    void Update()\n    {\n        switch (_currentState)\n        {\n            case AlarmState.Idle:\n                CheckForTargets();\n                break;\n                \n            case AlarmState.Detecting:\n                if (_targetDetected && _currentTarget != null)\n                {\n                    if (!_isOnCooldown)\n                    {\n                        TriggerAlarm();\n                    }\n                }\n                else\n                {\n                    _currentState = AlarmState.Idle;\n                }\n                break;\n                \n            case AlarmState.Alarming:\n                _alarmTimer -= Time.deltaTime;\n                \n                if (_resetOnLostTarget && !_targetDetected)\n                {\n                    StopAlarm();\n                }\n                else if (_alarmTimer <= 0f)\n                {\n                    StopAlarm();\n                }\n                break;\n                \n            case AlarmState.Cooldown:\n                _cooldownTimer -= Time.deltaTime;\n                if (_cooldownTimer <= 0f)\n                {\n                    _isOnCooldown = false;\n                    _currentState = AlarmState.Idle;\n                }\n                break;\n        }\n        \n        CheckForTargets();\n    }\n    \n    void CheckForTargets()\n    {\n        bool previousDetection = _targetDetected;\n        _targetDetected = false;\n        _currentTarget = null;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!string.IsNullOrEmpty(_targetTag) && !col.CompareTag(_targetTag))\n                continue;\n                \n            if (_requireLineOfSight)\n            {\n                Vector3 directionToTarget = (col.transform.position - transform.position).normalized;\n                float distanceToTarget = Vector3.Distance(transform.position, col.transform.position);\n                \n                if (Physics.Raycast(transform.position, directionToTarget, distanceToTarget, _obstacleLayers))\n                    continue;\n            }\n            \n            _targetDetected = true;\n            _currentTarget = col.transform;\n            \n            if (_currentState == AlarmState.Idle)\n            {\n                _currentState = AlarmState.Detecting;\n            }\n            \n            break;\n        }\n        \n        if (previousDetection && !_targetDetected)\n        {\n            _onTargetLost?.Invoke();\n        }\n        else if (!previousDetection && _targetDetected)\n        {\n            _onTargetDetected?.Invoke();\n        }\n    }\n    \n    void TriggerAlarm()\n    {\n        if (_isAlarmActive || _isOnCooldown)\n            return;\n            \n        _isAlarmActive = true;\n        _currentState = AlarmState.Alarming;\n        _alarmTimer = _alarmDuration;\n        \n        if (_audioSource != null && _alarmSound != null)\n        {\n            _audioSource.clip = _alarmSound;\n            _audioSource.loop = _loopAlarmSound;\n            _audioSource.Play();\n        }\n        \n        if (_alarmLight != null)\n        {\n            _alarmLight.color = _alarmLightColor;\n            if (_flashCoroutine != null)\n                StopCoroutine(_flashCoroutine);\n            _flashCoroutine = StartCoroutine(FlashLight());\n        }\n        \n        if (_indicatorRenderer != null && _alarmMaterial != null)\n        {\n            _indicatorRenderer.material = _alarmMaterial;\n        }\n        \n        _onAlarmTriggered?.Invoke();\n    }\n    \n    void StopAlarm()\n    {\n        if (!_isAlarmActive)\n            return;\n            \n        _isAlarmActive = false;\n        _currentState = AlarmState.Cooldown;\n        _cooldownTimer = _cooldownTime;\n        _isOnCooldown = true;\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n            _flashCoroutine = null;\n        }\n        \n        SetNormalState();\n        _onAlarmStopped?.Invoke();\n    }\n    \n    void SetNormalState()\n    {\n        if (_alarmLight != null)\n        {\n            _alarmLight.color = _normalLightColor;\n        }\n        \n        if (_indicatorRenderer != null && _normalMaterial != null)\n        {\n            _indicatorRenderer.material = _normalMaterial;\n        }\n    }\n    \n    IEnumerator FlashLight()\n    {\n        while (_isAlarmActive)\n        {\n            if (_alarmLight != null)\n            {\n                _alarmLight.enabled = !_alarmLight.enabled;\n            }\n            yield return new WaitForSeconds(1f / _flashSpeed);\n        }\n        \n        if (_alarmLight != null)\n        {\n            _alarmLight.enabled = true;\n        }\n    }\n    \n    public void ForceStopAlarm()\n    {\n        StopAlarm();\n    }\n    \n    public void ResetAlarm()\n    {\n        StopAlarm();\n        _isOnCooldown = false;\n        _currentState = AlarmState.Idle;\n    }\n    \n    public bool IsAlarmActive()\n    {\n        return _isAlarmActive;\n    }\n    \n    public bool IsTargetDetected()\n    {\n        return _targetDetected;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _targetDetected ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "camera security system",
      "ideal_ir": {
        "class_name": "SecurityCamera",
        "components": [
          "Camera",
          "Light"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 15
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 30
          },
          {
            "name": "sweepAngle",
            "type": "float",
            "default": 90
          },
          {
            "name": "alertDuration",
            "type": "float",
            "default": 3
          },
          {
            "name": "isAlerted",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentRotation",
            "type": "float",
            "default": 0
          },
          {
            "name": "sweepDirection",
            "type": "int",
            "default": 1
          }
        ],
        "behaviors": [
          {
            "name": "sweep_patrol",
            "trigger": "when not alerted and during normal operation",
            "actions": [
              {
                "action": "rotate camera left and right within sweep angle range"
              },
              {
                "action": "reverse rotation direction when reaching sweep limits"
              },
              {
                "action": "maintain steady rotation speed during sweep"
              }
            ]
          },
          {
            "name": "detect_intruder",
            "trigger": "when player enters detection range and is within camera view cone",
            "actions": [
              {
                "action": "stop sweeping motion immediately"
              },
              {
                "action": "track and follow the detected player"
              },
              {
                "action": "change camera light to red color"
              },
              {
                "action": "set alert state to active"
              },
              {
                "action": "play alarm sound effect"
              }
            ]
          },
          {
            "name": "track_target",
            "trigger": "when in alert state and player is visible",
            "actions": [
              {
                "action": "rotate camera to keep player centered in view"
              },
              {
                "action": "maintain red alert lighting"
              },
              {
                "action": "continue playing alarm sounds"
              }
            ]
          },
          {
            "name": "lose_target",
            "trigger": "when player leaves detection range or breaks line of sight",
            "actions": [
              {
                "action": "continue alert state for alert duration"
              },
              {
                "action": "search by rotating toward last known player position"
              },
              {
                "action": "keep red lighting active during search"
              }
            ]
          },
          {
            "name": "return_to_patrol",
            "trigger": "when alert duration expires and no player detected",
            "actions": [
              {
                "action": "change camera light back to white color"
              },
              {
                "action": "stop alarm sound effects"
              },
              {
                "action": "set alert state to inactive"
              },
              {
                "action": "resume normal sweeping patrol pattern"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class SecurityCamera : MonoBehaviour\n{\n    [Header(\"Camera Settings\")]\n    [SerializeField] private Camera _securityCamera;\n    [SerializeField] private Transform _cameraHead;\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _fieldOfView = 60f;\n    [SerializeField] private LayerMask _detectionLayers = -1;\n    [SerializeField] private LayerMask _obstacleLayers = -1;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private bool _enableRotation = true;\n    [SerializeField] private float _rotationSpeed = 30f;\n    [SerializeField] private float _minRotationAngle = -45f;\n    [SerializeField] private float _maxRotationAngle = 45f;\n    [SerializeField] private float _pauseDuration = 2f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionTime = 3f;\n    [SerializeField] private float _lostTargetTime = 5f;\n    [SerializeField] private bool _requireLineOfSight = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Light _cameraLight;\n    [SerializeField] private Color _normalColor = Color.green;\n    [SerializeField] private Color _alertColor = Color.red;\n    [SerializeField] private Color _detectedColor = Color.red;\n    [SerializeField] private MeshRenderer _cameraRenderer;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _alertMaterial;\n    [SerializeField] private Material _detectedMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _detectionSound;\n    [SerializeField] private AudioClip _alertSound;\n    [SerializeField] private AudioClip _lostTargetSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnTargetDetected;\n    public UnityEvent<Transform> OnTargetLost;\n    public UnityEvent<Transform> OnTargetFullyDetected;\n    \n    private CameraState _currentState = CameraState.Normal;\n    private Transform _currentTarget;\n    private float _detectionProgress = 0f;\n    private float _lostTargetTimer = 0f;\n    private bool _rotatingRight = true;\n    private float _pauseTimer = 0f;\n    private bool _isPaused = false;\n    private List<Transform> _detectedTargets = new List<Transform>();\n    private Coroutine _rotationCoroutine;\n    \n    private enum CameraState\n    {\n        Normal,\n        Alert,\n        Detected,\n        Tracking\n    }\n    \n    private void Start()\n    {\n        InitializeCamera();\n        if (_enableRotation)\n        {\n            _rotationCoroutine = StartCoroutine(RotationRoutine());\n        }\n    }\n    \n    private void InitializeCamera()\n    {\n        if (_securityCamera == null)\n            _securityCamera = GetComponentInChildren<Camera>();\n        \n        if (_cameraHead == null)\n            _cameraHead = _securityCamera != null ? _securityCamera.transform : transform;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_cameraLight == null)\n            _cameraLight = GetComponentInChildren<Light>();\n        \n        if (_cameraRenderer == null)\n            _cameraRenderer = GetComponent<MeshRenderer>();\n        \n        SetCameraState(CameraState.Normal);\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        UpdateDetectionProgress();\n        UpdateVisuals();\n    }\n    \n    private void DetectTargets()\n    {\n        _detectedTargets.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _detectionLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.transform == transform) continue;\n            \n            if (IsTargetInFieldOfView(col.transform) && (!_requireLineOfSight || HasLineOfSight(col.transform)))\n            {\n                _detectedTargets.Add(col.transform);\n            }\n        }\n        \n        HandleTargetDetection();\n    }\n    \n    private bool IsTargetInFieldOfView(Transform target)\n    {\n        Vector3 directionToTarget = (target.position - _cameraHead.position).normalized;\n        float angle = Vector3.Angle(_cameraHead.forward, directionToTarget);\n        return angle <= _fieldOfView * 0.5f;\n    }\n    \n    private bool HasLineOfSight(Transform target)\n    {\n        Vector3 directionToTarget = target.position - _cameraHead.position;\n        float distanceToTarget = directionToTarget.magnitude;\n        \n        if (Physics.Raycast(_cameraHead.position, directionToTarget.normalized, out RaycastHit hit, distanceToTarget, _obstacleLayers))\n        {\n            return hit.transform == target;\n        }\n        \n        return true;\n    }\n    \n    private void HandleTargetDetection()\n    {\n        if (_detectedTargets.Count > 0)\n        {\n            Transform closestTarget = GetClosestTarget();\n            \n            if (_currentTarget != closestTarget)\n            {\n                if (_currentTarget != null)\n                {\n                    OnTargetLost?.Invoke(_currentTarget);\n                    PlaySound(_lostTargetSound);\n                }\n                \n                _currentTarget = closestTarget;\n                _detectionProgress = 0f;\n                OnTargetDetected?.Invoke(_currentTarget);\n                SetCameraState(CameraState.Alert);\n            }\n            \n            _lostTargetTimer = 0f;\n        }\n        else\n        {\n            if (_currentTarget != null)\n            {\n                _lostTargetTimer += Time.deltaTime;\n                \n                if (_lostTargetTimer >= _lostTargetTime)\n                {\n                    OnTargetLost?.Invoke(_currentTarget);\n                    PlaySound(_lostTargetSound);\n                    _currentTarget = null;\n                    _detectionProgress = 0f;\n                    SetCameraState(CameraState.Normal);\n                }\n            }\n        }\n    }\n    \n    private Transform GetClosestTarget()\n    {\n        Transform closest = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Transform target in _detectedTargets)\n        {\n            float distance = Vector3.Distance(transform.position, target.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closest = target;\n            }\n        }\n        \n        return closest;\n    }\n    \n    private void UpdateDetectionProgress()\n    {\n        if (_currentTarget != null && _detectedTargets.Contains(_currentTarget))\n        {\n            _detectionProgress += Time.deltaTime / _detectionTime;\n            \n            if (_detectionProgress >= 1f && _currentState != CameraState.Detected)\n            {\n                SetCameraState(CameraState.Detected);\n                OnTargetFullyDetected?.Invoke(_currentTarget);\n                PlaySound(_detectionSound);\n            }\n        }\n        else if (_currentTarget != null)\n        {\n            _detectionProgress -= Time.deltaTime / (_detectionTime * 0.5f);\n            _detectionProgress = Mathf.Max(0f, _detectionProgress);\n            \n            if (_detectionProgress <= 0f && _currentState == CameraState.Detected)\n            {\n                SetCameraState(CameraState.Alert);\n            }\n        }\n    }\n    \n    private void SetCameraState(CameraState newState)\n    {\n        _currentState = newState;\n        \n        switch (_currentState)\n        {\n            case CameraState.Normal:\n                if (_enableRotation && _rotationCoroutine == null)\n                    _rotationCoroutine = StartCoroutine(RotationRoutine());\n                break;\n                \n            case CameraState.Alert:\n                if (_rotationCoroutine != null)\n                {\n                    StopCoroutine(_rotationCoroutine);\n                    _rotationCoroutine = null;\n                }\n                TrackTarget();\n                PlaySound(_alertSound);\n                break;\n                \n            case CameraState.Detected:\n                TrackTarget();\n                break;\n        }\n    }\n    \n    private void TrackTarget()\n    {\n        if (_currentTarget != null)\n        {\n            Vector3 directionToTarget = (_currentTarget.position - _cameraHead.position).normalized;\n            Quaternion targetRotation = Quaternion.LookRotation(directionToTarget);\n            _cameraHead.rotation = Quaternion.Slerp(_cameraHead.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private IEnumerator RotationRoutine()\n    {\n        while (_enableRotation && _currentState == CameraState.Normal)\n        {\n            if (!_isPaused)\n            {\n                float currentY = _cameraHead.localEulerAngles.y;\n                if (currentY > 180f) currentY -= 360f;\n                \n                if (_rotatingRight)\n                {\n                    if (currentY >= _maxRotationAngle)\n                    {\n                        _rotatingRight = false;\n                        _isPaused = true;\n                        _pauseTimer = 0f;\n                    }\n                    else\n                    {\n                        _cameraHead.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n                    }\n                }\n                else\n                {\n                    if (currentY <= _minRotationAngle)\n                    {\n                        _rotatingRight = true;\n                        _isPaused = true;\n                        _pauseTimer = 0f;\n                    }\n                    else\n                    {\n                        _cameraHead.Rotate(0, -_rotationSpeed * Time.deltaTime, 0);\n                    }\n                }\n            }\n            else\n            {\n                _pauseTimer += Time.deltaTime;\n                if (_pauseTimer >= _pauseDuration)\n                {\n                    _isPaused = false;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        Color targetColor = _normalColor;\n        Material targetMaterial = _normalMaterial;\n        \n        switch (_currentState)\n        {\n            case CameraState.Normal:\n                targetColor = _normalColor;\n                targetMaterial = _normalMaterial;\n                break;\n                \n            case CameraState.Alert:\n                targetColor = Color.Lerp(_normalColor, _alertColor, _detectionProgress);\n                targetMaterial = _detectionProgress > 0.5f ? _alertMaterial : _normalMaterial;\n                break;\n                \n            case CameraState.Detected:\n                targetColor = _detectedColor;\n                targetMaterial = _detectedMaterial;\n                break;\n        }\n        \n        if (_cameraLight != null)\n        {\n            _cameraLight.color = targetColor;\n        }\n        \n        if (_cameraRenderer != null && targetMaterial != null)\n        {\n            _cameraRenderer.material = targetMaterial;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_cameraHead != null)\n        {\n            Gizmos.color = _currentState == CameraState.Detected ? Color.red : \n                          _currentState == CameraState.Alert ? Color.orange : Color.green;\n            \n            Vector3 forward = _cameraHead.forward;\n            Vector3 right = Quaternion.AngleAxis(_fieldOfView * 0.5f, _cameraHead.up) * forward;\n            Vector3 left = Quaternion.AngleAxis(-_fieldOfView * 0.5f, _cameraHead.up) * forward;\n            \n            Gizmos.DrawRay(_cameraHead.position, right * _detectionRange);\n            Gizmos.DrawRay(_cameraHead.position, left * _detectionRange);\n            Gizmos.DrawRay(_cameraHead.position, forward * _detectionRange);\n        }\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_cameraHead.position, _currentTarget.position);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "turntable DJ mixer",
      "ideal_ir": {
        "class_name": "TurntableDJMixer",
        "components": [
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "crossfaderPosition",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "leftTurntableSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "rightTurntableSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "leftVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "rightVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "bassLevel",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "midLevel",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "trebleLevel",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "isPlaying",
            "type": "bool",
            "default": false
          },
          {
            "name": "leftTrackLoaded",
            "type": "bool",
            "default": false
          },
          {
            "name": "rightTrackLoaded",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "adjust_crossfader",
            "trigger": "when crossfader slider is moved",
            "actions": [
              {
                "action": "blend audio between left and right turntables based on crossfader position"
              },
              {
                "action": "adjust volume levels of both tracks proportionally"
              }
            ]
          },
          {
            "name": "control_left_turntable",
            "trigger": "when left turntable is touched or scratched",
            "actions": [
              {
                "action": "modify left turntable playback speed based on touch direction"
              },
              {
                "action": "create scratch sound effects when moved rapidly"
              },
              {
                "action": "pause left track when turntable is held still"
              }
            ]
          },
          {
            "name": "control_right_turntable",
            "trigger": "when right turntable is touched or scratched",
            "actions": [
              {
                "action": "modify right turntable playback speed based on touch direction"
              },
              {
                "action": "create scratch sound effects when moved rapidly"
              },
              {
                "action": "pause right track when turntable is held still"
              }
            ]
          },
          {
            "name": "adjust_equalizer",
            "trigger": "when bass, mid, or treble knobs are rotated",
            "actions": [
              {
                "action": "modify corresponding frequency range of the mixed audio output"
              },
              {
                "action": "update visual feedback on equalizer display"
              }
            ]
          },
          {
            "name": "load_track",
            "trigger": "when track is dropped onto turntable deck",
            "actions": [
              {
                "action": "load audio file into corresponding turntable"
              },
              {
                "action": "display track information on deck screen"
              },
              {
                "action": "enable playback controls for that deck"
              }
            ]
          },
          {
            "name": "start_playback",
            "trigger": "when play button is pressed on either deck",
            "actions": [
              {
                "action": "begin audio playback on selected turntable"
              },
              {
                "action": "illuminate play button indicator"
              },
              {
                "action": "start turntable rotation animation"
              }
            ]
          },
          {
            "name": "cue_track",
            "trigger": "when cue button is pressed and held",
            "actions": [
              {
                "action": "play audio preview through headphones only"
              },
              {
                "action": "allow track positioning without affecting main output"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Audio;\nusing System.Collections;\n\npublic class TurntableDJMixer : MonoBehaviour\n{\n    [System.Serializable]\n    public class TurntableSettings\n    {\n        [Header(\"Turntable Properties\")]\n        public Transform turntablePlatter;\n        public AudioSource audioSource;\n        public AudioClip[] trackClips;\n        [Range(0f, 2f)] public float pitchRange = 0.5f;\n        [Range(0f, 1f)] public float volume = 1f;\n        public bool isPlaying = false;\n        public float currentRPM = 33.33f;\n        public int currentTrackIndex = 0;\n    }\n\n    [System.Serializable]\n    public class CrossfaderSettings\n    {\n        [Range(-1f, 1f)] public float position = 0f;\n        public AnimationCurve crossfadeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);\n    }\n\n    [System.Serializable]\n    public class EffectSettings\n    {\n        [Range(0f, 1f)] public float reverbAmount = 0f;\n        [Range(0f, 1f)] public float distortionAmount = 0f;\n        [Range(0f, 1f)] public float echoAmount = 0f;\n        [Range(20f, 20000f)] public float lowPassFreq = 20000f;\n        [Range(20f, 20000f)] public float highPassFreq = 20f;\n    }\n\n    [Header(\"Turntables\")]\n    [SerializeField] private TurntableSettings _leftTurntable;\n    [SerializeField] private TurntableSettings _rightTurntable;\n\n    [Header(\"Mixer Controls\")]\n    [SerializeField] private CrossfaderSettings _crossfader;\n    [SerializeField] private Transform _crossfaderKnob;\n    [Range(0f, 1f)] [SerializeField] private float _masterVolume = 1f;\n    [Range(0f, 1f)] [SerializeField] private float _leftChannelGain = 1f;\n    [Range(0f, 1f)] [SerializeField] private float _rightChannelGain = 1f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private EffectSettings _leftEffects;\n    [SerializeField] private EffectSettings _rightEffects;\n\n    [Header(\"Visual Elements\")]\n    [SerializeField] private Transform _leftPitchSlider;\n    [SerializeField] private Transform _rightPitchSlider;\n    [SerializeField] private Light[] _vuMeterLights;\n    [SerializeField] private Material _activeLightMaterial;\n    [SerializeField] private Material _inactiveLightMaterial;\n\n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _leftPlayKey = KeyCode.Q;\n    [SerializeField] private KeyCode _rightPlayKey = KeyCode.P;\n    [SerializeField] private KeyCode _leftNextTrackKey = KeyCode.W;\n    [SerializeField] private KeyCode _rightNextTrackKey = KeyCode.O;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnLeftTrackChanged;\n    public UnityEvent<int> OnRightTrackChanged;\n    public UnityEvent<bool> OnLeftPlayStateChanged;\n    public UnityEvent<bool> OnRightPlayStateChanged;\n    public UnityEvent<float> OnCrossfaderChanged;\n\n    private AudioLowPassFilter _leftLowPass;\n    private AudioHighPassFilter _leftHighPass;\n    private AudioReverbFilter _leftReverb;\n    private AudioDistortionFilter _leftDistortion;\n    private AudioEchoFilter _leftEcho;\n\n    private AudioLowPassFilter _rightLowPass;\n    private AudioHighPassFilter _rightHighPass;\n    private AudioReverbFilter _rightReverb;\n    private AudioDistortionFilter _rightDistortion;\n    private AudioEchoFilter _rightEcho;\n\n    private bool _isDraggingCrossfader = false;\n    private bool _isDraggingLeftPitch = false;\n    private bool _isDraggingRightPitch = false;\n\n    private float _leftVuLevel = 0f;\n    private float _rightVuLevel = 0f;\n\n    private void Start()\n    {\n        InitializeTurntables();\n        InitializeAudioEffects();\n        InitializeVisuals();\n    }\n\n    private void InitializeTurntables()\n    {\n        if (_leftTurntable.audioSource == null)\n            _leftTurntable.audioSource = gameObject.AddComponent<AudioSource>();\n        if (_rightTurntable.audioSource == null)\n            _rightTurntable.audioSource = gameObject.AddComponent<AudioSource>();\n\n        _leftTurntable.audioSource.loop = true;\n        _rightTurntable.audioSource.loop = true;\n        _leftTurntable.audioSource.playOnAwake = false;\n        _rightTurntable.audioSource.playOnAwake = false;\n\n        if (_leftTurntable.trackClips != null && _leftTurntable.trackClips.Length > 0)\n            _leftTurntable.audioSource.clip = _leftTurntable.trackClips[0];\n        if (_rightTurntable.trackClips != null && _rightTurntable.trackClips.Length > 0)\n            _rightTurntable.audioSource.clip = _rightTurntable.trackClips[0];\n    }\n\n    private void InitializeAudioEffects()\n    {\n        _leftLowPass = _leftTurntable.audioSource.gameObject.AddComponent<AudioLowPassFilter>();\n        _leftHighPass = _leftTurntable.audioSource.gameObject.AddComponent<AudioHighPassFilter>();\n        _leftReverb = _leftTurntable.audioSource.gameObject.AddComponent<AudioReverbFilter>();\n        _leftDistortion = _leftTurntable.audioSource.gameObject.AddComponent<AudioDistortionFilter>();\n        _leftEcho = _leftTurntable.audioSource.gameObject.AddComponent<AudioEchoFilter>();\n\n        _rightLowPass = _rightTurntable.audioSource.gameObject.AddComponent<AudioLowPassFilter>();\n        _rightHighPass = _rightTurntable.audioSource.gameObject.AddComponent<AudioHighPassFilter>();\n        _rightReverb = _rightTurntable.audioSource.gameObject.AddComponent<AudioReverbFilter>();\n        _rightDistortion = _rightTurntable.audioSource.gameObject.AddComponent<AudioDistortionFilter>();\n        _rightEcho = _rightTurntable.audioSource.gameObject.AddComponent<AudioEchoFilter>();\n\n        _leftReverb.enabled = false;\n        _leftDistortion.enabled = false;\n        _leftEcho.enabled = false;\n        _rightReverb.enabled = false;\n        _rightDistortion.enabled = false;\n        _rightEcho.enabled = false;\n    }\n\n    private void InitializeVisuals()\n    {\n        if (_crossfaderKnob != null)\n            _crossfaderKnob.localPosition = new Vector3(_crossfader.position, 0f, 0f);\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        UpdateTurntableRotation();\n        UpdateAudioEffects();\n        UpdateCrossfader();\n        UpdateVUMeters();\n        UpdateVisuals();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_leftPlayKey))\n            ToggleLeftTurntable();\n        if (Input.GetKeyDown(_rightPlayKey))\n            ToggleRightTurntable();\n        if (Input.GetKeyDown(_leftNextTrackKey))\n            NextLeftTrack();\n        if (Input.GetKeyDown(_rightNextTrackKey))\n            NextRightTrack();\n\n        HandleMouseInput();\n    }\n\n    private void HandleMouseInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit))\n            {\n                if (hit.collider.CompareTag(\"Crossfader\"))\n                    _isDraggingCrossfader = true;\n                else if (hit.collider.CompareTag(\"LeftPitch\"))\n                    _isDraggingLeftPitch = true;\n                else if (hit.collider.CompareTag(\"RightPitch\"))\n                    _isDraggingRightPitch = true;\n            }\n        }\n\n        if (Input.GetMouseButtonUp(0))\n        {\n            _isDraggingCrossfader = false;\n            _isDraggingLeftPitch = false;\n            _isDraggingRightPitch = false;\n        }\n\n        if (_isDraggingCrossfader)\n            UpdateCrossfaderFromMouse();\n        if (_isDraggingLeftPitch)\n            UpdateLeftPitchFromMouse();\n        if (_isDraggingRightPitch)\n            UpdateRightPitchFromMouse();\n    }\n\n    private void UpdateCrossfaderFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float newPosition = Mathf.Clamp((mousePos.x - transform.position.x) / 2f, -1f, 1f);\n        SetCrossfaderPosition(newPosition);\n    }\n\n    private void UpdateLeftPitchFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float pitchValue = Mathf.Clamp((mousePos.y - transform.position.y) / 2f, -_leftTurntable.pitchRange, _leftTurntable.pitchRange);\n        SetLeftTurntablePitch(1f + pitchValue);\n    }\n\n    private void UpdateRightPitchFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float pitchValue = Mathf.Clamp((mousePos.y - transform.position.y) / 2f, -_rightTurntable.pitchRange, _rightTurntable.pitchRange);\n        SetRightTurntablePitch(1f + pitchValue);\n    }\n\n    private void UpdateTurntableRotation()\n    {\n        if (_leftTurntable.turntablePlatter != null && _leftTurntable.isPlaying)\n        {\n            float rotationSpeed = (_leftTurntable.currentRPM / 60f) * 360f * _leftTurntable.audioSource.pitch;\n            _leftTurntable.turntablePlatter.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);\n        }\n\n        if (_rightTurntable.turntablePlatter != null && _rightTurntable.isPlaying)\n        {\n            float rotationSpeed = (_rightTurntable.currentRPM / 60f) * 360f * _rightTurntable.audioSource.pitch;\n            _rightTurntable.turntablePlatter.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);\n        }\n    }\n\n    private void UpdateAudioEffects()\n    {\n        UpdateEffectsForTurntable(_leftEffects, _leftLowPass, _leftHighPass, _leftReverb, _leftDistortion, _leftEcho);\n        UpdateEffectsForTurntable(_rightEffects, _rightLowPass, _rightHighPass, _rightReverb, _rightDistortion, _rightEcho);\n    }\n\n    private void UpdateEffectsForTurntable(EffectSettings effects, AudioLowPassFilter lowPass, AudioHighPassFilter highPass,\n        AudioReverbFilter reverb, AudioDistortionFilter distortion, AudioEchoFilter echo)\n    {\n        lowPass.cutoffFrequency = effects.lowPassFreq;\n        highPass.cutoffFrequency = effects.highPassFreq;\n\n        reverb.enabled = effects.reverbAmount > 0.01f;\n        if (reverb.enabled)\n            reverb.reverbLevel = Mathf.Lerp(-10000f, 0f, effects.reverbAmount);\n\n        distortion.enabled = effects.distortionAmount > 0.01f;\n        if (distortion.enabled)\n            distortion.distortionLevel = effects.distortionAmount;\n\n        echo.enabled = effects.echoAmount > 0.01f;\n        if (echo.enabled)\n        {\n            echo.wetMix = effects.echoAmount;\n            echo.delay = 500f;\n            echo.decayRatio = 0.5f;\n        }\n    }\n\n    private void UpdateCrossfader()\n    {\n        float leftVolume = _crossfader.crossfadeCurve.Evaluate(Mathf.Clamp01(1f + _crossfader.position));\n        float rightVolume = _crossfader.crossfadeCurve.Evaluate(Mathf.Clamp01(1f - _crossfader.position));\n\n        _leftTurntable.audioSource.volume = _leftTurntable.volume * _leftChannelGain * leftVolume * _masterVolume;\n        _rightTurntable.audioSource.volume = _rightTurntable.volume * _rightChannelGain * rightVolume * _masterVolume;\n    }\n\n    private void UpdateVUMeters()\n    {\n        _leftVuLevel = GetAudioLevel(_leftTurntable.audioSource);\n        _rightVuLevel = GetAudioLevel(_rightTurntable.audioSource);\n\n        if (_vuMeterLights != null)\n        {\n            int leftLights = Mathf.RoundToInt(_leftVuLevel * (_vuMeterLights.Length / 2f));\n            int rightLights = Mathf.RoundToInt(_rightVuLevel * (_vuMeterLights.Length / 2f));\n\n            for (int i = 0; i < _vuMeterLights.Length / 2; i++)\n            {\n                if (_vuMeterLights[i] != null)\n                {\n                    _vuMeterLights[i].enabled = i < leftLights;\n                    _vuMeterLights[i].color = i < leftLights ? Color.green : Color.black;\n                }\n            }\n\n            for (int i = _vuMeterLights.Length / 2; i < _vuMeterLights.Length; i++)\n            {\n                if (_vuMeterLights[i] != null)\n                {\n                    int rightIndex = i - (_vuMeterLights.Length / 2);\n                    _vuMeterLights[i].enabled = rightIndex < rightLights;\n                    _vuMeterLights[i].color = rightIndex < rightLights ? Color.green : Color.black;\n                }\n            }\n        }\n    }\n\n    private float GetAudioLevel(AudioSource audioSource)\n    {\n        if (audioSource == null || !audioSource.isPlaying)\n            return 0f;\n\n        float[] samples = new float[256];\n        audioSource.GetOutputData(samples, 0);\n        \n        float sum = 0f;\n        for (int i = 0; i < samples.Length; i++)\n            sum += Mathf.Abs(samples[i]);\n        \n        return Mathf.Clamp01(sum / samples.Length * 10f);\n    }\n\n    private void UpdateVisuals()\n    {\n        if (_crossfaderKnob != null)\n            _crossf",
      "behavior_type": "general"
    },
    {
      "prompt": "day night cycle",
      "ideal_ir": {
        "class_name": "DayNightCycle",
        "components": [
          "Light"
        ],
        "fields": [
          {
            "name": "dayDuration",
            "type": "float",
            "default": 120
          },
          {
            "name": "nightDuration",
            "type": "float",
            "default": 60
          },
          {
            "name": "dayIntensity",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "nightIntensity",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "dayColor",
            "type": "Color",
            "default": "white"
          },
          {
            "name": "nightColor",
            "type": "Color",
            "default": "blue"
          },
          {
            "name": "transitionSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "currentTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isDay",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "cycle_time",
            "trigger": "every frame",
            "actions": [
              {
                "action": "increase current time by elapsed time"
              }
            ]
          },
          {
            "name": "transition_to_night",
            "trigger": "when current time exceeds day duration and it is currently day",
            "actions": [
              {
                "action": "set is day to false"
              },
              {
                "action": "reset current time to zero"
              }
            ]
          },
          {
            "name": "transition_to_day",
            "trigger": "when current time exceeds night duration and it is currently night",
            "actions": [
              {
                "action": "set is day to true"
              },
              {
                "action": "reset current time to zero"
              }
            ]
          },
          {
            "name": "update_day_lighting",
            "trigger": "when it is day",
            "actions": [
              {
                "action": "gradually change light intensity toward day intensity"
              },
              {
                "action": "gradually change light color toward day color"
              }
            ]
          },
          {
            "name": "update_night_lighting",
            "trigger": "when it is night",
            "actions": [
              {
                "action": "gradually change light intensity toward night intensity"
              },
              {
                "action": "gradually change light color toward night color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DayNightCycle : MonoBehaviour\n{\n    [Header(\"Time Settings\")]\n    [SerializeField] private float _dayDurationInMinutes = 10f;\n    [SerializeField] private float _currentTimeOfDay = 0.5f;\n    [SerializeField] private bool _pauseTime = false;\n    \n    [Header(\"Sun Settings\")]\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Transform _sunTransform;\n    [SerializeField] private Gradient _sunColorGradient;\n    [SerializeField] private AnimationCurve _sunIntensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _maxSunIntensity = 1.5f;\n    \n    [Header(\"Moon Settings\")]\n    [SerializeField] private Light _moonLight;\n    [SerializeField] private Transform _moonTransform;\n    [SerializeField] private Color _moonColor = Color.blue;\n    [SerializeField] private float _maxMoonIntensity = 0.3f;\n    \n    [Header(\"Sky Settings\")]\n    [SerializeField] private Material _skyboxMaterial;\n    [SerializeField] private Gradient _fogColorGradient;\n    [SerializeField] private AnimationCurve _fogDensityCurve = AnimationCurve.EaseInOut(0f, 0.01f, 1f, 0.01f);\n    [SerializeField] private float _maxFogDensity = 0.05f;\n    \n    [Header(\"Ambient Settings\")]\n    [SerializeField] private Gradient _ambientColorGradient;\n    [SerializeField] private AnimationCurve _ambientIntensityCurve = AnimationCurve.EaseInOut(0f, 0.3f, 1f, 1f);\n    [SerializeField] private float _maxAmbientIntensity = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSunrise;\n    public UnityEvent OnNoon;\n    public UnityEvent OnSunset;\n    public UnityEvent OnMidnight;\n    \n    private float _timeSpeed;\n    private bool _hasSunriseTriggered = false;\n    private bool _hasNoonTriggered = false;\n    private bool _hasSunsetTriggered = false;\n    private bool _hasMidnightTriggered = false;\n    \n    private void Start()\n    {\n        _timeSpeed = 1f / (_dayDurationInMinutes * 60f);\n        \n        if (_sunLight == null)\n            _sunLight = FindObjectOfType<Light>();\n            \n        if (_sunTransform == null && _sunLight != null)\n            _sunTransform = _sunLight.transform;\n            \n        if (_skyboxMaterial == null)\n            _skyboxMaterial = RenderSettings.skybox;\n            \n        InitializeGradients();\n        UpdateCycle();\n    }\n    \n    private void Update()\n    {\n        if (!_pauseTime)\n        {\n            _currentTimeOfDay += Time.deltaTime * _timeSpeed;\n            \n            if (_currentTimeOfDay >= 1f)\n            {\n                _currentTimeOfDay = 0f;\n                ResetEventTriggers();\n            }\n            \n            UpdateCycle();\n            CheckTimeEvents();\n        }\n    }\n    \n    private void UpdateCycle()\n    {\n        UpdateSun();\n        UpdateMoon();\n        UpdateSkybox();\n        UpdateFog();\n        UpdateAmbientLighting();\n    }\n    \n    private void UpdateSun()\n    {\n        if (_sunLight == null) return;\n        \n        float sunAngle = _currentTimeOfDay * 360f - 90f;\n        \n        if (_sunTransform != null)\n        {\n            _sunTransform.rotation = Quaternion.Euler(sunAngle, 30f, 0f);\n        }\n        \n        float sunIntensity = _sunIntensityCurve.Evaluate(_currentTimeOfDay) * _maxSunIntensity;\n        _sunLight.intensity = sunIntensity;\n        \n        _sunLight.color = _sunColorGradient.Evaluate(_currentTimeOfDay);\n        \n        _sunLight.enabled = sunIntensity > 0.01f;\n    }\n    \n    private void UpdateMoon()\n    {\n        if (_moonLight == null) return;\n        \n        float moonAngle = (_currentTimeOfDay + 0.5f) % 1f * 360f - 90f;\n        \n        if (_moonTransform != null)\n        {\n            _moonTransform.rotation = Quaternion.Euler(moonAngle, 30f, 0f);\n        }\n        \n        float nightTime = Mathf.Abs(_currentTimeOfDay - 0.5f) * 2f;\n        nightTime = 1f - nightTime;\n        nightTime = Mathf.Clamp01(nightTime);\n        \n        float moonIntensity = nightTime * _maxMoonIntensity;\n        _moonLight.intensity = moonIntensity;\n        _moonLight.color = _moonColor;\n        \n        _moonLight.enabled = moonIntensity > 0.01f;\n    }\n    \n    private void UpdateSkybox()\n    {\n        if (_skyboxMaterial == null) return;\n        \n        if (_skyboxMaterial.HasProperty(\"_Exposure\"))\n        {\n            float exposure = _sunIntensityCurve.Evaluate(_currentTimeOfDay);\n            _skyboxMaterial.SetFloat(\"_Exposure\", exposure);\n        }\n        \n        if (_skyboxMaterial.HasProperty(\"_Tint\"))\n        {\n            Color tint = _sunColorGradient.Evaluate(_currentTimeOfDay);\n            _skyboxMaterial.SetColor(\"_Tint\", tint);\n        }\n    }\n    \n    private void UpdateFog()\n    {\n        RenderSettings.fog = true;\n        RenderSettings.fogColor = _fogColorGradient.Evaluate(_currentTimeOfDay);\n        RenderSettings.fogDensity = _fogDensityCurve.Evaluate(_currentTimeOfDay) * _maxFogDensity;\n    }\n    \n    private void UpdateAmbientLighting()\n    {\n        RenderSettings.ambientLight = _ambientColorGradient.Evaluate(_currentTimeOfDay);\n        RenderSettings.ambientIntensity = _ambientIntensityCurve.Evaluate(_currentTimeOfDay) * _maxAmbientIntensity;\n    }\n    \n    private void CheckTimeEvents()\n    {\n        if (_currentTimeOfDay >= 0.25f && _currentTimeOfDay < 0.26f && !_hasSunriseTriggered)\n        {\n            OnSunrise?.Invoke();\n            _hasSunriseTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.5f && _currentTimeOfDay < 0.51f && !_hasNoonTriggered)\n        {\n            OnNoon?.Invoke();\n            _hasNoonTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.75f && _currentTimeOfDay < 0.76f && !_hasSunsetTriggered)\n        {\n            OnSunset?.Invoke();\n            _hasSunsetTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.99f && !_hasMidnightTriggered)\n        {\n            OnMidnight?.Invoke();\n            _hasMidnightTriggered = true;\n        }\n    }\n    \n    private void ResetEventTriggers()\n    {\n        _hasSunriseTriggered = false;\n        _hasNoonTriggered = false;\n        _hasSunsetTriggered = false;\n        _hasMidnightTriggered = false;\n    }\n    \n    private void InitializeGradients()\n    {\n        if (_sunColorGradient.colorKeys.Length == 0)\n        {\n            GradientColorKey[] colorKeys = new GradientColorKey[5];\n            colorKeys[0] = new GradientColorKey(new Color(0.2f, 0.2f, 0.4f), 0f);\n            colorKeys[1] = new GradientColorKey(new Color(1f, 0.6f, 0.3f), 0.25f);\n            colorKeys[2] = new GradientColorKey(Color.white, 0.5f);\n            colorKeys[3] = new GradientColorKey(new Color(1f, 0.4f, 0.2f), 0.75f);\n            colorKeys[4] = new GradientColorKey(new Color(0.2f, 0.2f, 0.4f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(1f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(1f, 1f);\n            \n            _sunColorGradient.SetKeys(colorKeys, alphaKeys);\n        }\n        \n        if (_fogColorGradient.colorKeys.Length == 0)\n        {\n            _fogColorGradient = _sunColorGradient;\n        }\n        \n        if (_ambientColorGradient.colorKeys.Length == 0)\n        {\n            _ambientColorGradient = _sunColorGradient;\n        }\n    }\n    \n    public void SetTimeOfDay(float time)\n    {\n        _currentTimeOfDay = Mathf.Clamp01(time);\n        ResetEventTriggers();\n        UpdateCycle();\n    }\n    \n    public void PauseTime(bool pause)\n    {\n        _pauseTime = pause;\n    }\n    \n    public void SetDayDuration(float minutes)\n    {\n        _dayDurationInMinutes = Mathf.Max(0.1f, minutes);\n        _timeSpeed = 1f / (_dayDurationInMinutes * 60f);\n    }\n    \n    public float GetTimeOfDay()\n    {\n        return _currentTimeOfDay;\n    }\n    \n    public bool IsDay()\n    {\n        return _currentTimeOfDay > 0.25f && _currentTimeOfDay < 0.75f;\n    }\n    \n    public bool IsNight()\n    {\n        return !IsDay();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "weather rain effect",
      "ideal_ir": {
        "class_name": "WeatherRainEffect",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rainIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "windStrength",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "rainDropSize",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "rainColor",
            "type": "Color",
            "default": "gray"
          },
          {
            "name": "maxRainDrops",
            "type": "int",
            "default": 1000
          },
          {
            "name": "rainSoundVolume",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "isRaining",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_rain",
            "trigger": "when rain is enabled",
            "actions": [
              {
                "action": "activate particle system"
              },
              {
                "action": "set particle emission rate based on rain intensity"
              },
              {
                "action": "set particle size based on rain drop size"
              },
              {
                "action": "set particle color to rain color"
              },
              {
                "action": "start playing rain sound effect"
              },
              {
                "action": "set audio volume to rain sound volume"
              }
            ]
          },
          {
            "name": "stop_rain",
            "trigger": "when rain is disabled",
            "actions": [
              {
                "action": "stop particle emission"
              },
              {
                "action": "fade out rain sound effect"
              },
              {
                "action": "wait for existing particles to disappear"
              },
              {
                "action": "deactivate particle system"
              }
            ]
          },
          {
            "name": "adjust_rain_intensity",
            "trigger": "when rain intensity changes",
            "actions": [
              {
                "action": "modify particle emission rate to match new intensity"
              },
              {
                "action": "adjust rain sound volume proportionally"
              },
              {
                "action": "change particle velocity based on intensity"
              }
            ]
          },
          {
            "name": "apply_wind_effect",
            "trigger": "when wind strength is greater than zero",
            "actions": [
              {
                "action": "tilt rain particles in wind direction"
              },
              {
                "action": "add horizontal velocity to particles based on wind strength"
              },
              {
                "action": "create swaying motion in rain pattern"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WeatherRainEffect : MonoBehaviour\n{\n    [Header(\"Rain Settings\")]\n    [SerializeField] private GameObject _rainDropPrefab;\n    [SerializeField] private int _maxRainDrops = 1000;\n    [SerializeField] private float _rainIntensity = 0.5f;\n    [SerializeField] private Vector3 _rainAreaSize = new Vector3(50f, 20f, 50f);\n    [SerializeField] private float _rainDropSpeed = 10f;\n    [SerializeField] private Vector3 _windDirection = new Vector3(0.1f, 0f, 0f);\n    \n    [Header(\"Rain Drop Properties\")]\n    [SerializeField] private float _dropLifetime = 5f;\n    [SerializeField] private float _dropScale = 1f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _rainAudioSource;\n    [SerializeField] private AudioClip _rainSoundClip;\n    [SerializeField] private float _audioVolume = 0.3f;\n    \n    [Header(\"Particle System\")]\n    [SerializeField] private ParticleSystem _rainParticleSystem;\n    [SerializeField] private bool _useParticleSystem = true;\n    \n    private List<RainDrop> _activeRainDrops = new List<RainDrop>();\n    private Queue<RainDrop> _rainDropPool = new Queue<RainDrop>();\n    private Transform _playerTransform;\n    private Camera _mainCamera;\n    private float _spawnTimer;\n    private bool _isRaining = true;\n    \n    [System.Serializable]\n    private class RainDrop\n    {\n        public GameObject gameObject;\n        public Transform transform;\n        public Rigidbody rigidbody;\n        public float lifetime;\n        public bool isActive;\n        \n        public RainDrop(GameObject obj)\n        {\n            gameObject = obj;\n            transform = obj.transform;\n            rigidbody = obj.GetComponent<Rigidbody>();\n            lifetime = 0f;\n            isActive = false;\n        }\n    }\n    \n    void Start()\n    {\n        InitializeRainSystem();\n        SetupAudio();\n        SetupParticleSystem();\n        FindPlayerAndCamera();\n    }\n    \n    void Update()\n    {\n        if (!_isRaining) return;\n        \n        UpdatePlayerPosition();\n        SpawnRainDrops();\n        UpdateRainDrops();\n        UpdateAudio();\n    }\n    \n    private void InitializeRainSystem()\n    {\n        if (_rainDropPrefab == null)\n        {\n            CreateDefaultRainDropPrefab();\n        }\n        \n        PrewarmRainDropPool();\n    }\n    \n    private void CreateDefaultRainDropPrefab()\n    {\n        _rainDropPrefab = GameObject.CreatePrimitive(PrimitiveType.Capsule);\n        _rainDropPrefab.transform.localScale = new Vector3(0.02f, 0.1f, 0.02f);\n        \n        Renderer renderer = _rainDropPrefab.GetComponent<Renderer>();\n        Material rainMaterial = new Material(Shader.Find(\"Standard\"));\n        rainMaterial.color = new Color(0.7f, 0.8f, 1f, 0.6f);\n        rainMaterial.SetFloat(\"_Mode\", 3);\n        rainMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        rainMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        rainMaterial.SetInt(\"_ZWrite\", 0);\n        rainMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n        rainMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n        rainMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        rainMaterial.renderQueue = 3000;\n        renderer.material = rainMaterial;\n        \n        Rigidbody rb = _rainDropPrefab.GetComponent<Rigidbody>();\n        rb.useGravity = false;\n        rb.drag = 0f;\n        \n        _rainDropPrefab.SetActive(false);\n    }\n    \n    private void PrewarmRainDropPool()\n    {\n        for (int i = 0; i < _maxRainDrops; i++)\n        {\n            GameObject dropObj = Instantiate(_rainDropPrefab, transform);\n            RainDrop rainDrop = new RainDrop(dropObj);\n            _rainDropPool.Enqueue(rainDrop);\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_rainAudioSource == null)\n        {\n            _rainAudioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rainAudioSource.clip = _rainSoundClip;\n        _rainAudioSource.loop = true;\n        _rainAudioSource.volume = _audioVolume;\n        _rainAudioSource.spatialBlend = 0f;\n        \n        if (_rainSoundClip != null && _isRaining)\n        {\n            _rainAudioSource.Play();\n        }\n    }\n    \n    private void SetupParticleSystem()\n    {\n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var main = _rainParticleSystem.main;\n            main.startLifetime = _dropLifetime;\n            main.startSpeed = _rainDropSpeed;\n            main.maxParticles = _maxRainDrops;\n            \n            var emission = _rainParticleSystem.emission;\n            emission.rateOverTime = _maxRainDrops * _rainIntensity / _dropLifetime;\n            \n            var shape = _rainParticleSystem.shape;\n            shape.shapeType = ParticleSystemShapeType.Box;\n            shape.scale = _rainAreaSize;\n            \n            var velocityOverLifetime = _rainParticleSystem.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            velocityOverLifetime.x = _windDirection.x * _rainDropSpeed;\n            velocityOverLifetime.y = -_rainDropSpeed;\n            velocityOverLifetime.z = _windDirection.z * _rainDropSpeed;\n        }\n    }\n    \n    private void FindPlayerAndCamera()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n        {\n            _mainCamera = FindObjectOfType<Camera>();\n        }\n    }\n    \n    private void UpdatePlayerPosition()\n    {\n        if (_playerTransform != null)\n        {\n            Vector3 playerPos = _playerTransform.position;\n            transform.position = new Vector3(playerPos.x, playerPos.y + _rainAreaSize.y * 0.5f, playerPos.z);\n        }\n        else if (_mainCamera != null)\n        {\n            Vector3 cameraPos = _mainCamera.transform.position;\n            transform.position = new Vector3(cameraPos.x, cameraPos.y + _rainAreaSize.y * 0.5f, cameraPos.z);\n        }\n    }\n    \n    private void SpawnRainDrops()\n    {\n        _spawnTimer += Time.deltaTime;\n        float spawnRate = _maxRainDrops * _rainIntensity / _dropLifetime;\n        float spawnInterval = 1f / spawnRate;\n        \n        if (_spawnTimer >= spawnInterval && _rainDropPool.Count > 0)\n        {\n            _spawnTimer = 0f;\n            SpawnRainDrop();\n        }\n    }\n    \n    private void SpawnRainDrop()\n    {\n        RainDrop rainDrop = _rainDropPool.Dequeue();\n        \n        Vector3 spawnPosition = transform.position + new Vector3(\n            Random.Range(-_rainAreaSize.x * 0.5f, _rainAreaSize.x * 0.5f),\n            Random.Range(0f, _rainAreaSize.y * 0.5f),\n            Random.Range(-_rainAreaSize.z * 0.5f, _rainAreaSize.z * 0.5f)\n        );\n        \n        rainDrop.transform.position = spawnPosition;\n        rainDrop.transform.localScale = Vector3.one * _dropScale;\n        rainDrop.lifetime = _dropLifetime;\n        rainDrop.isActive = true;\n        rainDrop.gameObject.SetActive(true);\n        \n        Vector3 velocity = new Vector3(_windDirection.x, -1f, _windDirection.z) * _rainDropSpeed;\n        rainDrop.rigidbody.velocity = velocity;\n        \n        _activeRainDrops.Add(rainDrop);\n    }\n    \n    private void UpdateRainDrops()\n    {\n        for (int i = _activeRainDrops.Count - 1; i >= 0; i--)\n        {\n            RainDrop rainDrop = _activeRainDrops[i];\n            \n            rainDrop.lifetime -= Time.deltaTime;\n            \n            if (rainDrop.lifetime <= 0f || IsRainDropHittingGround(rainDrop))\n            {\n                DeactivateRainDrop(rainDrop, i);\n            }\n        }\n    }\n    \n    private bool IsRainDropHittingGround(RainDrop rainDrop)\n    {\n        RaycastHit hit;\n        Vector3 rayOrigin = rainDrop.transform.position;\n        Vector3 rayDirection = rainDrop.rigidbody.velocity.normalized;\n        float rayDistance = rainDrop.rigidbody.velocity.magnitude * Time.deltaTime;\n        \n        return Physics.Raycast(rayOrigin, rayDirection, out hit, rayDistance, _groundLayer);\n    }\n    \n    private void DeactivateRainDrop(RainDrop rainDrop, int index)\n    {\n        rainDrop.isActive = false;\n        rainDrop.gameObject.SetActive(false);\n        rainDrop.rigidbody.velocity = Vector3.zero;\n        \n        _activeRainDrops.RemoveAt(index);\n        _rainDropPool.Enqueue(rainDrop);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rainAudioSource != null)\n        {\n            float targetVolume = _isRaining ? _audioVolume * _rainIntensity : 0f;\n            _rainAudioSource.volume = Mathf.Lerp(_rainAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n        }\n    }\n    \n    public void SetRainIntensity(float intensity)\n    {\n        _rainIntensity = Mathf.Clamp01(intensity);\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var emission = _rainParticleSystem.emission;\n            emission.rateOverTime = _maxRainDrops * _rainIntensity / _dropLifetime;\n        }\n    }\n    \n    public void StartRain()\n    {\n        _isRaining = true;\n        \n        if (_rainAudioSource != null && _rainSoundClip != null)\n        {\n            _rainAudioSource.Play();\n        }\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            _rainParticleSystem.Play();\n        }\n    }\n    \n    public void StopRain()\n    {\n        _isRaining = false;\n        \n        if (_rainAudioSource != null)\n        {\n            _rainAudioSource.Stop();\n        }\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            _rainParticleSystem.Stop();\n        }\n        \n        for (int i = _activeRainDrops.Count - 1; i >= 0; i--)\n        {\n            DeactivateRainDrop(_activeRainDrops[i], i);\n        }\n    }\n    \n    public void SetWindDirection(Vector3 windDirection)\n    {\n        _windDirection = windDirection;\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var velocityOverLifetime = _rainParticleSystem.velocityOverLifetime;\n            velocityOverLifetime.x = _windDirection.x * _rainDropSpeed;\n            velocityOverLifetime.z = _windDirection.z * _rainDropSpeed;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = new Color(0f, 0.5f, 1f, 0.3f);\n        Gizmos.DrawCube(transform.position, _rainAreaSize);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, _rainAreaSize);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "thunder and lightning",
      "ideal_ir": {
        "class_name": "ThunderLightning",
        "components": [
          "AudioSource",
          "Light"
        ],
        "fields": [
          {
            "name": "minInterval",
            "type": "float",
            "default": 5
          },
          {
            "name": "maxInterval",
            "type": "float",
            "default": 15
          },
          {
            "name": "lightningDuration",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "thunderDelay",
            "type": "float",
            "default": 2
          },
          {
            "name": "lightningIntensity",
            "type": "float",
            "default": 8
          },
          {
            "name": "flashCount",
            "type": "int",
            "default": 3
          }
        ],
        "behaviors": [
          {
            "name": "trigger_lightning_storm",
            "trigger": "when random interval timer expires",
            "actions": [
              {
                "action": "reset timer with random interval between min and max"
              },
              {
                "action": "start lightning flash sequence"
              }
            ]
          },
          {
            "name": "lightning_flash",
            "trigger": "when lightning sequence starts",
            "actions": [
              {
                "action": "rapidly flash light on and off multiple times"
              },
              {
                "action": "set light intensity to maximum during flashes"
              },
              {
                "action": "illuminate entire scene briefly"
              },
              {
                "action": "schedule thunder sound after delay"
              }
            ]
          },
          {
            "name": "thunder_sound",
            "trigger": "when thunder delay timer expires after lightning",
            "actions": [
              {
                "action": "play thunder audio clip"
              },
              {
                "action": "shake camera slightly for impact effect"
              }
            ]
          },
          {
            "name": "ambient_setup",
            "trigger": "when object starts",
            "actions": [
              {
                "action": "set light to disabled initially"
              },
              {
                "action": "configure light as directional with white color"
              },
              {
                "action": "start first random interval timer"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ThunderLightning : MonoBehaviour\n{\n    [Header(\"Lightning Settings\")]\n    [SerializeField] private Light _lightningLight;\n    [SerializeField] private float _lightningIntensity = 8f;\n    [SerializeField] private Color _lightningColor = Color.white;\n    [SerializeField] private float _lightningDuration = 0.1f;\n    [SerializeField] private int _minFlashes = 1;\n    [SerializeField] private int _maxFlashes = 3;\n    [SerializeField] private float _flashInterval = 0.05f;\n    \n    [Header(\"Thunder Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _thunderSounds;\n    [SerializeField] private float _minThunderDelay = 0.5f;\n    [SerializeField] private float _maxThunderDelay = 3f;\n    [SerializeField] private float _thunderVolume = 1f;\n    \n    [Header(\"Storm Settings\")]\n    [SerializeField] private bool _autoStorm = true;\n    [SerializeField] private float _minStormInterval = 5f;\n    [SerializeField] private float _maxStormInterval = 15f;\n    [SerializeField] private bool _randomIntensity = true;\n    \n    [Header(\"Environment Effects\")]\n    [SerializeField] private ParticleSystem _rainParticles;\n    [SerializeField] private Material _skyboxMaterial;\n    [SerializeField] private string _skyboxTintProperty = \"_Tint\";\n    [SerializeField] private Color _stormSkyTint = new Color(0.3f, 0.3f, 0.4f, 1f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLightningStrike;\n    public UnityEvent OnThunderRoll;\n    public UnityEvent OnStormStart;\n    public UnityEvent OnStormEnd;\n    \n    private float _originalLightIntensity;\n    private Color _originalLightColor;\n    private Color _originalSkyTint;\n    private bool _isStorming = false;\n    private Coroutine _stormCoroutine;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        \n        if (_lightningLight == null)\n        {\n            _lightningLight = GetComponent<Light>();\n            if (_lightningLight == null)\n            {\n                GameObject lightGO = new GameObject(\"Lightning Light\");\n                lightGO.transform.SetParent(transform);\n                _lightningLight = lightGO.AddComponent<Light>();\n                _lightningLight.type = LightType.Directional;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _originalLightIntensity = _lightningLight.intensity;\n        _originalLightColor = _lightningLight.color;\n        _lightningLight.intensity = 0f;\n        \n        if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n        {\n            _originalSkyTint = _skyboxMaterial.GetColor(_skyboxTintProperty);\n        }\n        \n        if (_autoStorm)\n        {\n            _stormCoroutine = StartCoroutine(AutoStormRoutine());\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_stormCoroutine != null)\n        {\n            StopCoroutine(_stormCoroutine);\n        }\n        \n        if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n        {\n            _skyboxMaterial.SetColor(_skyboxTintProperty, _originalSkyTint);\n        }\n    }\n    \n    public void TriggerLightningStrike()\n    {\n        StartCoroutine(LightningStrikeRoutine());\n    }\n    \n    public void StartStorm()\n    {\n        if (!_isStorming)\n        {\n            _isStorming = true;\n            OnStormStart?.Invoke();\n            \n            if (_rainParticles != null && !_rainParticles.isPlaying)\n            {\n                _rainParticles.Play();\n            }\n            \n            if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n            {\n                StartCoroutine(ChangeSkyTint(_stormSkyTint, 2f));\n            }\n        }\n    }\n    \n    public void EndStorm()\n    {\n        if (_isStorming)\n        {\n            _isStorming = false;\n            OnStormEnd?.Invoke();\n            \n            if (_rainParticles != null && _rainParticles.isPlaying)\n            {\n                _rainParticles.Stop();\n            }\n            \n            if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n            {\n                StartCoroutine(ChangeSkyTint(_originalSkyTint, 3f));\n            }\n        }\n    }\n    \n    private IEnumerator AutoStormRoutine()\n    {\n        while (true)\n        {\n            float waitTime = Random.Range(_minStormInterval, _maxStormInterval);\n            yield return new WaitForSeconds(waitTime);\n            \n            if (!_isStorming)\n            {\n                StartStorm();\n                \n                int lightningStrikes = Random.Range(3, 8);\n                for (int i = 0; i < lightningStrikes; i++)\n                {\n                    yield return new WaitForSeconds(Random.Range(1f, 4f));\n                    TriggerLightningStrike();\n                }\n                \n                yield return new WaitForSeconds(Random.Range(5f, 10f));\n                EndStorm();\n            }\n        }\n    }\n    \n    private IEnumerator LightningStrikeRoutine()\n    {\n        OnLightningStrike?.Invoke();\n        \n        int flashCount = Random.Range(_minFlashes, _maxFlashes + 1);\n        float intensity = _randomIntensity ? Random.Range(_lightningIntensity * 0.7f, _lightningIntensity * 1.3f) : _lightningIntensity;\n        \n        for (int i = 0; i < flashCount; i++)\n        {\n            _lightningLight.intensity = intensity;\n            _lightningLight.color = _lightningColor;\n            \n            if (_mainCamera != null)\n            {\n                StartCoroutine(CameraShake(0.1f, 0.2f));\n            }\n            \n            yield return new WaitForSeconds(_lightningDuration);\n            \n            _lightningLight.intensity = 0f;\n            \n            if (i < flashCount - 1)\n            {\n                yield return new WaitForSeconds(_flashInterval);\n            }\n        }\n        \n        float thunderDelay = Random.Range(_minThunderDelay, _maxThunderDelay);\n        yield return new WaitForSeconds(thunderDelay);\n        \n        PlayThunder();\n    }\n    \n    private void PlayThunder()\n    {\n        if (_thunderSounds != null && _thunderSounds.Length > 0 && _audioSource != null)\n        {\n            AudioClip thunderClip = _thunderSounds[Random.Range(0, _thunderSounds.Length)];\n            _audioSource.clip = thunderClip;\n            _audioSource.volume = _thunderVolume;\n            _audioSource.Play();\n            \n            OnThunderRoll?.Invoke();\n        }\n    }\n    \n    private IEnumerator CameraShake(float duration, float magnitude)\n    {\n        if (_mainCamera == null) yield break;\n        \n        Vector3 originalPosition = _mainCamera.transform.localPosition;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float x = Random.Range(-1f, 1f) * magnitude;\n            float y = Random.Range(-1f, 1f) * magnitude;\n            \n            _mainCamera.transform.localPosition = new Vector3(originalPosition.x + x, originalPosition.y + y, originalPosition.z);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.localPosition = originalPosition;\n    }\n    \n    private IEnumerator ChangeSkyTint(Color targetColor, float duration)\n    {\n        if (_skyboxMaterial == null || !_skyboxMaterial.HasProperty(_skyboxTintProperty))\n            yield break;\n        \n        Color startColor = _skyboxMaterial.GetColor(_skyboxTintProperty);\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            Color currentColor = Color.Lerp(startColor, targetColor, t);\n            _skyboxMaterial.SetColor(_skyboxTintProperty, currentColor);\n            yield return null;\n        }\n        \n        _skyboxMaterial.SetColor(_skyboxTintProperty, targetColor);\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            TriggerLightningStrike();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.K))\n        {\n            if (_isStorming)\n                EndStorm();\n            else\n                StartStorm();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fog rolling in",
      "ideal_ir": {
        "class_name": "RollingFog",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rollSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fogDensity",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "rollDirection",
            "type": "Vector3",
            "default": "Vector3.forward"
          },
          {
            "name": "maxCoverage",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "currentCoverage",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "start_fog_roll",
            "trigger": "when fog rolling begins",
            "actions": [
              {
                "action": "activate particle system with fog effects"
              },
              {
                "action": "play ambient fog rolling sound"
              },
              {
                "action": "begin moving fog forward in roll direction"
              }
            ]
          },
          {
            "name": "expand_fog_coverage",
            "trigger": "while fog is rolling and coverage is below maximum",
            "actions": [
              {
                "action": "gradually increase fog density and coverage area"
              },
              {
                "action": "reduce visibility in affected areas"
              },
              {
                "action": "continue forward movement at roll speed"
              }
            ]
          },
          {
            "name": "maintain_fog_presence",
            "trigger": "when fog reaches maximum coverage",
            "actions": [
              {
                "action": "maintain current fog density"
              },
              {
                "action": "keep fog particles active and swirling"
              },
              {
                "action": "continue playing ambient fog sounds"
              }
            ]
          },
          {
            "name": "interact_with_environment",
            "trigger": "when fog encounters obstacles or terrain changes",
            "actions": [
              {
                "action": "flow around solid objects naturally"
              },
              {
                "action": "settle into low areas and valleys"
              },
              {
                "action": "adjust particle density based on terrain"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\n\npublic class FogRoller : MonoBehaviour\n{\n    [Header(\"Fog Settings\")]\n    [SerializeField] private bool _enableFog = true;\n    [SerializeField] private Color _fogColor = Color.gray;\n    [SerializeField] private FogMode _fogMode = FogMode.ExponentialSquared;\n    \n    [Header(\"Rolling Animation\")]\n    [SerializeField] private float _rollDuration = 30f;\n    [SerializeField] private AnimationCurve _rollCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private bool _rollOnStart = true;\n    [SerializeField] private bool _loop = false;\n    \n    [Header(\"Fog Density\")]\n    [SerializeField] private float _startDensity = 0f;\n    [SerializeField] private float _endDensity = 0.02f;\n    \n    [Header(\"Fog Distance (Linear Mode)\")]\n    [SerializeField] private float _startDistance = 300f;\n    [SerializeField] private float _endDistance = 50f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fogParticles;\n    [SerializeField] private Light _ambientLight;\n    [SerializeField] private Color _startLightColor = Color.white;\n    [SerializeField] private Color _endLightColor = Color.gray;\n    [SerializeField] private float _startLightIntensity = 1f;\n    [SerializeField] private float _endLightIntensity = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fogRollingSound;\n    [SerializeField] private float _audioFadeInDuration = 5f;\n    \n    private bool _isRolling = false;\n    private float _rollTimer = 0f;\n    private bool _originalFogEnabled;\n    private Color _originalFogColor;\n    private FogMode _originalFogMode;\n    private float _originalFogDensity;\n    private float _originalFogStartDistance;\n    private float _originalFogEndDistance;\n    private Color _originalLightColor;\n    private float _originalLightIntensity;\n    private float _targetAudioVolume;\n    \n    private void Start()\n    {\n        StoreOriginalSettings();\n        \n        if (_audioSource != null)\n        {\n            _targetAudioVolume = _audioSource.volume;\n            _audioSource.volume = 0f;\n        }\n        \n        if (_rollOnStart)\n        {\n            StartFogRoll();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isRolling)\n        {\n            UpdateFogRoll();\n        }\n    }\n    \n    private void StoreOriginalSettings()\n    {\n        _originalFogEnabled = RenderSettings.fog;\n        _originalFogColor = RenderSettings.fogColor;\n        _originalFogMode = RenderSettings.fogMode;\n        _originalFogDensity = RenderSettings.fogDensity;\n        _originalFogStartDistance = RenderSettings.fogStartDistance;\n        _originalFogEndDistance = RenderSettings.fogEndDistance;\n        \n        if (_ambientLight != null)\n        {\n            _originalLightColor = _ambientLight.color;\n            _originalLightIntensity = _ambientLight.intensity;\n        }\n    }\n    \n    public void StartFogRoll()\n    {\n        if (_isRolling) return;\n        \n        _isRolling = true;\n        _rollTimer = 0f;\n        \n        RenderSettings.fog = _enableFog;\n        RenderSettings.fogMode = _fogMode;\n        RenderSettings.fogColor = _fogColor;\n        \n        if (_fogParticles != null && !_fogParticles.isPlaying)\n        {\n            _fogParticles.Play();\n        }\n        \n        if (_audioSource != null && _fogRollingSound != null)\n        {\n            _audioSource.clip = _fogRollingSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    public void StopFogRoll()\n    {\n        if (!_isRolling) return;\n        \n        _isRolling = false;\n        RestoreOriginalSettings();\n        \n        if (_fogParticles != null && _fogParticles.isPlaying)\n        {\n            _fogParticles.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void UpdateFogRoll()\n    {\n        _rollTimer += Time.deltaTime;\n        float normalizedTime = Mathf.Clamp01(_rollTimer / _rollDuration);\n        float curveValue = _rollCurve.Evaluate(normalizedTime);\n        \n        // Update fog density\n        if (_fogMode == FogMode.Exponential || _fogMode == FogMode.ExponentialSquared)\n        {\n            RenderSettings.fogDensity = Mathf.Lerp(_startDensity, _endDensity, curveValue);\n        }\n        else if (_fogMode == FogMode.Linear)\n        {\n            RenderSettings.fogStartDistance = Mathf.Lerp(_startDistance, _endDistance, curveValue);\n            RenderSettings.fogEndDistance = RenderSettings.fogStartDistance * 2f;\n        }\n        \n        // Update ambient light\n        if (_ambientLight != null)\n        {\n            _ambientLight.color = Color.Lerp(_startLightColor, _endLightColor, curveValue);\n            _ambientLight.intensity = Mathf.Lerp(_startLightIntensity, _endLightIntensity, curveValue);\n        }\n        \n        // Update audio volume\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float audioFadeProgress = Mathf.Clamp01(_rollTimer / _audioFadeInDuration);\n            _audioSource.volume = Mathf.Lerp(0f, _targetAudioVolume, audioFadeProgress);\n        }\n        \n        // Check if roll is complete\n        if (normalizedTime >= 1f)\n        {\n            if (_loop)\n            {\n                _rollTimer = 0f;\n            }\n            else\n            {\n                _isRolling = false;\n                \n                if (_audioSource != null && _audioSource.isPlaying)\n                {\n                    _audioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    private void RestoreOriginalSettings()\n    {\n        RenderSettings.fog = _originalFogEnabled;\n        RenderSettings.fogColor = _originalFogColor;\n        RenderSettings.fogMode = _originalFogMode;\n        RenderSettings.fogDensity = _originalFogDensity;\n        RenderSettings.fogStartDistance = _originalFogStartDistance;\n        RenderSettings.fogEndDistance = _originalFogEndDistance;\n        \n        if (_ambientLight != null)\n        {\n            _ambientLight.color = _originalLightColor;\n            _ambientLight.intensity = _originalLightIntensity;\n        }\n    }\n    \n    public void ToggleFogRoll()\n    {\n        if (_isRolling)\n        {\n            StopFogRoll();\n        }\n        else\n        {\n            StartFogRoll();\n        }\n    }\n    \n    public bool IsRolling => _isRolling;\n    \n    public float RollProgress => _isRolling ? Mathf.Clamp01(_rollTimer / _rollDuration) : 0f;\n    \n    private void OnDestroy()\n    {\n        if (_isRolling)\n        {\n            RestoreOriginalSettings();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _rollDuration = Mathf.Max(0.1f, _rollDuration);\n        _startDensity = Mathf.Max(0f, _startDensity);\n        _endDensity = Mathf.Max(0f, _endDensity);\n        _startDistance = Mathf.Max(0.1f, _startDistance);\n        _endDistance = Mathf.Max(0.1f, _endDistance);\n        _audioFadeInDuration = Mathf.Max(0.1f, _audioFadeInDuration);\n        _startLightIntensity = Mathf.Max(0f, _startLightIntensity);\n        _endLightIntensity = Mathf.Max(0f, _endLightIntensity);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "leaves falling from trees",
      "ideal_ir": {
        "class_name": "FallingLeaf",
        "components": [
          "Transform",
          "Rigidbody",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "swayAmount",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 30.0
          },
          {
            "name": "despawnHeight",
            "type": "float",
            "default": -10.0
          },
          {
            "name": "windStrength",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "start_falling",
            "trigger": "when leaf spawns or detaches from tree",
            "actions": [
              {
                "action": "begin falling downward at fall speed"
              },
              {
                "action": "apply gentle swaying motion side to side"
              },
              {
                "action": "start random rotation around all axes"
              }
            ]
          },
          {
            "name": "sway_in_wind",
            "trigger": "continuously while falling",
            "actions": [
              {
                "action": "drift horizontally based on wind strength"
              },
              {
                "action": "vary fall speed slightly for natural movement"
              },
              {
                "action": "adjust sway amount based on wind conditions"
              }
            ]
          },
          {
            "name": "rotate_naturally",
            "trigger": "continuously while falling",
            "actions": [
              {
                "action": "rotate slowly around random axes"
              },
              {
                "action": "change rotation speed occasionally for variation"
              }
            ]
          },
          {
            "name": "despawn_when_low",
            "trigger": "when leaf falls below despawn height",
            "actions": [
              {
                "action": "destroy the leaf object"
              },
              {
                "action": "remove from scene to maintain performance"
              }
            ]
          },
          {
            "name": "land_on_ground",
            "trigger": "when leaf collides with ground or solid surface",
            "actions": [
              {
                "action": "stop falling motion"
              },
              {
                "action": "settle onto surface naturally"
              },
              {
                "action": "reduce rotation to gentle rocking motion"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FallingLeaves : MonoBehaviour\n{\n    [Header(\"Leaf Settings\")]\n    [SerializeField] private GameObject[] _leafPrefabs;\n    [SerializeField] private int _maxLeaves = 50;\n    [SerializeField] private float _spawnRate = 2f;\n    [SerializeField] private float _leafLifetime = 10f;\n    \n    [Header(\"Spawn Area\")]\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(20f, 5f, 20f);\n    [SerializeField] private float _spawnHeight = 10f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _fallSpeed = 2f;\n    [SerializeField] private float _swayAmount = 1f;\n    [SerializeField] private float _swaySpeed = 1f;\n    [SerializeField] private float _rotationSpeed = 30f;\n    [SerializeField] private Vector3 _windDirection = Vector3.right;\n    [SerializeField] private float _windStrength = 0.5f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    \n    private List<LeafController> _activeLeaves = new List<LeafController>();\n    private float _nextSpawnTime;\n    \n    [System.Serializable]\n    public class LeafController\n    {\n        public GameObject leafObject;\n        public Vector3 startPosition;\n        public float swayOffset;\n        public float spawnTime;\n        public bool hasLanded;\n        public Vector3 rotationAxis;\n        \n        public LeafController(GameObject leaf, Vector3 startPos, float time)\n        {\n            leafObject = leaf;\n            startPosition = startPos;\n            swayOffset = Random.Range(0f, Mathf.PI * 2f);\n            spawnTime = time;\n            hasLanded = false;\n            rotationAxis = Random.onUnitSphere;\n        }\n    }\n    \n    void Start()\n    {\n        if (_leafPrefabs == null || _leafPrefabs.Length == 0)\n        {\n            Debug.LogWarning(\"No leaf prefabs assigned to FallingLeaves component!\");\n            return;\n        }\n        \n        _nextSpawnTime = Time.time + (1f / _spawnRate);\n    }\n    \n    void Update()\n    {\n        if (_leafPrefabs != null && _leafPrefabs.Length > 0)\n        {\n            SpawnLeaves();\n        }\n        \n        UpdateLeaves();\n        CleanupLeaves();\n    }\n    \n    void SpawnLeaves()\n    {\n        if (Time.time >= _nextSpawnTime && _activeLeaves.Count < _maxLeaves)\n        {\n            Vector3 spawnPosition = GetRandomSpawnPosition();\n            GameObject leafPrefab = _leafPrefabs[Random.Range(0, _leafPrefabs.Length)];\n            \n            if (leafPrefab != null)\n            {\n                GameObject newLeaf = Instantiate(leafPrefab, spawnPosition, Random.rotation);\n                \n                Rigidbody rb = newLeaf.GetComponent<Rigidbody>();\n                if (rb == null)\n                {\n                    rb = newLeaf.AddComponent<Rigidbody>();\n                }\n                \n                rb.useGravity = false;\n                rb.drag = 2f;\n                rb.angularDrag = 5f;\n                \n                Collider col = newLeaf.GetComponent<Collider>();\n                if (col == null)\n                {\n                    col = newLeaf.AddComponent<BoxCollider>();\n                }\n                col.isTrigger = false;\n                \n                LeafController leafController = new LeafController(newLeaf, spawnPosition, Time.time);\n                _activeLeaves.Add(leafController);\n            }\n            \n            _nextSpawnTime = Time.time + (1f / _spawnRate) + Random.Range(-0.2f, 0.2f);\n        }\n    }\n    \n    Vector3 GetRandomSpawnPosition()\n    {\n        Vector3 basePosition = transform.position;\n        float x = Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f);\n        float y = _spawnHeight + Random.Range(0f, _spawnAreaSize.y);\n        float z = Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f);\n        \n        return basePosition + new Vector3(x, y, z);\n    }\n    \n    void UpdateLeaves()\n    {\n        for (int i = _activeLeaves.Count - 1; i >= 0; i--)\n        {\n            LeafController leaf = _activeLeaves[i];\n            \n            if (leaf.leafObject == null)\n            {\n                _activeLeaves.RemoveAt(i);\n                continue;\n            }\n            \n            if (!leaf.hasLanded)\n            {\n                UpdateFallingLeaf(leaf);\n                CheckGroundCollision(leaf);\n            }\n            else\n            {\n                UpdateGroundedLeaf(leaf);\n            }\n        }\n    }\n    \n    void UpdateFallingLeaf(LeafController leaf)\n    {\n        Transform leafTransform = leaf.leafObject.transform;\n        \n        float swayX = Mathf.Sin((Time.time + leaf.swayOffset) * _swaySpeed) * _swayAmount;\n        float swayZ = Mathf.Cos((Time.time + leaf.swayOffset) * _swaySpeed * 0.7f) * _swayAmount * 0.5f;\n        \n        Vector3 movement = new Vector3(swayX, -_fallSpeed, swayZ) * Time.deltaTime;\n        movement += _windDirection.normalized * _windStrength * Time.deltaTime;\n        \n        leafTransform.position += movement;\n        \n        leafTransform.Rotate(leaf.rotationAxis * _rotationSpeed * Time.deltaTime);\n        \n        Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.velocity = movement / Time.deltaTime;\n        }\n    }\n    \n    void CheckGroundCollision(LeafController leaf)\n    {\n        Transform leafTransform = leaf.leafObject.transform;\n        \n        if (Physics.Raycast(leafTransform.position, Vector3.down, _groundCheckDistance, _groundLayer))\n        {\n            leaf.hasLanded = true;\n            \n            Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.velocity = Vector3.zero;\n                rb.angularVelocity = Vector3.zero;\n                rb.useGravity = true;\n                rb.drag = 10f;\n            }\n        }\n    }\n    \n    void UpdateGroundedLeaf(LeafController leaf)\n    {\n        Vector3 windForce = _windDirection.normalized * _windStrength * 0.1f;\n        \n        Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.AddForce(windForce, ForceMode.Force);\n        }\n    }\n    \n    void CleanupLeaves()\n    {\n        for (int i = _activeLeaves.Count - 1; i >= 0; i--)\n        {\n            LeafController leaf = _activeLeaves[i];\n            \n            if (leaf.leafObject == null || Time.time - leaf.spawnTime > _leafLifetime)\n            {\n                if (leaf.leafObject != null)\n                {\n                    DestroyImmediate(leaf.leafObject);\n                }\n                _activeLeaves.RemoveAt(i);\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * (_spawnHeight + _spawnAreaSize.y * 0.5f), _spawnAreaSize);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, _windDirection.normalized * 3f);\n    }\n    \n    void OnDestroy()\n    {\n        for (int i = 0; i < _activeLeaves.Count; i++)\n        {\n            if (_activeLeaves[i].leafObject != null)\n            {\n                DestroyImmediate(_activeLeaves[i].leafObject);\n            }\n        }\n        _activeLeaves.Clear();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "dust particles in light",
      "ideal_ir": {
        "class_name": "DustParticles",
        "components": [
          "ParticleSystem",
          "Light"
        ],
        "fields": [
          {
            "name": "particleCount",
            "type": "int",
            "default": 100
          },
          {
            "name": "driftSpeed",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "lightIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "particleSize",
            "type": "float",
            "default": 0.01
          }
        ],
        "behaviors": [
          {
            "name": "spawn_dust_particles",
            "trigger": "when scene starts",
            "actions": [
              {
                "action": "create small floating dust particles in the air"
              },
              {
                "action": "set particles to drift slowly and randomly"
              },
              {
                "action": "make particles visible only when illuminated by light"
              }
            ]
          },
          {
            "name": "illuminate_particles",
            "trigger": "when light shines on particles",
            "actions": [
              {
                "action": "make dust particles glow and become visible"
              },
              {
                "action": "adjust particle brightness based on light intensity"
              },
              {
                "action": "create sparkling effect on illuminated dust"
              }
            ]
          },
          {
            "name": "drift_movement",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "move particles in gentle floating motion"
              },
              {
                "action": "add subtle random movement to simulate air currents"
              },
              {
                "action": "keep particles within light beam area"
              }
            ]
          },
          {
            "name": "fade_in_darkness",
            "trigger": "when particles move away from light",
            "actions": [
              {
                "action": "gradually fade particles to invisible"
              },
              {
                "action": "reduce particle opacity in dark areas"
              },
              {
                "action": "maintain particle positions but hide them"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class DustParticlesInLight : MonoBehaviour\n{\n    [Header(\"Particle Settings\")]\n    [SerializeField] private int _maxParticles = 100;\n    [SerializeField] private float _particleSize = 0.02f;\n    [SerializeField] private float _particleSizeVariation = 0.01f;\n    [SerializeField] private Material _dustMaterial;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _driftSpeed = 0.5f;\n    [SerializeField] private float _driftVariation = 0.3f;\n    [SerializeField] private float _floatAmplitude = 0.1f;\n    [SerializeField] private float _floatFrequency = 1f;\n    \n    [Header(\"Light Detection\")]\n    [SerializeField] private LayerMask _lightLayerMask = -1;\n    [SerializeField] private float _lightDetectionRadius = 10f;\n    [SerializeField] private float _fadeDistance = 2f;\n    \n    [Header(\"Spawn Area\")]\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(5f, 5f, 5f);\n    [SerializeField] private float _respawnHeight = 3f;\n    \n    private List<DustParticle> _particles = new List<DustParticle>();\n    private Light[] _nearbyLights;\n    private Camera _mainCamera;\n    \n    [System.Serializable]\n    private class DustParticle\n    {\n        public GameObject gameObject;\n        public Renderer renderer;\n        public Vector3 velocity;\n        public float floatOffset;\n        public float baseAlpha;\n        public Vector3 startPosition;\n        public float lifetime;\n        public float maxLifetime;\n        \n        public DustParticle(GameObject go, Renderer rend)\n        {\n            gameObject = go;\n            renderer = rend;\n            floatOffset = Random.Range(0f, Mathf.PI * 2f);\n            baseAlpha = Random.Range(0.1f, 0.3f);\n            maxLifetime = Random.Range(10f, 30f);\n            lifetime = 0f;\n        }\n    }\n    \n    void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        if (_dustMaterial == null)\n        {\n            _dustMaterial = CreateDefaultDustMaterial();\n        }\n        \n        InitializeParticles();\n        InvokeRepeating(nameof(UpdateLightSources), 0f, 1f);\n    }\n    \n    void Update()\n    {\n        UpdateParticles();\n        UpdateParticleVisibility();\n    }\n    \n    private Material CreateDefaultDustMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.color = new Color(1f, 1f, 1f, 0.2f);\n        mat.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        mat.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        mat.SetInt(\"_ZWrite\", 0);\n        mat.DisableKeyword(\"_ALPHATEST_ON\");\n        mat.EnableKeyword(\"_ALPHABLEND_ON\");\n        mat.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        mat.renderQueue = 3000;\n        return mat;\n    }\n    \n    private void InitializeParticles()\n    {\n        for (int i = 0; i < _maxParticles; i++)\n        {\n            CreateParticle();\n        }\n    }\n    \n    private void CreateParticle()\n    {\n        GameObject particleGO = GameObject.CreatePrimitive(PrimitiveType.Quad);\n        particleGO.name = \"DustParticle\";\n        particleGO.transform.SetParent(transform);\n        \n        DestroyImmediate(particleGO.GetComponent<Collider>());\n        \n        Renderer renderer = particleGO.GetComponent<Renderer>();\n        renderer.material = _dustMaterial;\n        renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n        renderer.receiveShadows = false;\n        \n        float size = _particleSize + Random.Range(-_particleSizeVariation, _particleSizeVariation);\n        particleGO.transform.localScale = Vector3.one * size;\n        \n        Vector3 spawnPos = GetRandomSpawnPosition();\n        particleGO.transform.position = spawnPos;\n        \n        DustParticle particle = new DustParticle(particleGO, renderer);\n        particle.startPosition = spawnPos;\n        particle.velocity = new Vector3(\n            Random.Range(-_driftVariation, _driftVariation),\n            Random.Range(-_driftSpeed * 0.5f, _driftSpeed * 0.5f),\n            Random.Range(-_driftVariation, _driftVariation)\n        );\n        \n        _particles.Add(particle);\n    }\n    \n    private Vector3 GetRandomSpawnPosition()\n    {\n        return transform.position + new Vector3(\n            Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f),\n            Random.Range(-_spawnAreaSize.y * 0.5f, _spawnAreaSize.y * 0.5f),\n            Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f)\n        );\n    }\n    \n    private void UpdateParticles()\n    {\n        for (int i = 0; i < _particles.Count; i++)\n        {\n            DustParticle particle = _particles[i];\n            if (particle.gameObject == null) continue;\n            \n            particle.lifetime += Time.deltaTime;\n            \n            Vector3 floatMotion = new Vector3(\n                Mathf.Sin(Time.time * _floatFrequency + particle.floatOffset) * _floatAmplitude,\n                Mathf.Cos(Time.time * _floatFrequency * 0.7f + particle.floatOffset) * _floatAmplitude * 0.5f,\n                Mathf.Sin(Time.time * _floatFrequency * 1.3f + particle.floatOffset) * _floatAmplitude * 0.3f\n            );\n            \n            Vector3 movement = (particle.velocity * _driftSpeed + floatMotion) * Time.deltaTime;\n            particle.gameObject.transform.position += movement;\n            \n            if (_mainCamera != null)\n            {\n                Vector3 dirToCamera = _mainCamera.transform.position - particle.gameObject.transform.position;\n                particle.gameObject.transform.rotation = Quaternion.LookRotation(dirToCamera);\n            }\n            \n            if (particle.gameObject.transform.position.y > transform.position.y + _respawnHeight ||\n                particle.lifetime > particle.maxLifetime ||\n                Vector3.Distance(particle.gameObject.transform.position, transform.position) > _spawnAreaSize.magnitude)\n            {\n                RespawnParticle(particle);\n            }\n        }\n    }\n    \n    private void RespawnParticle(DustParticle particle)\n    {\n        Vector3 newPos = GetRandomSpawnPosition();\n        newPos.y = transform.position.y - _spawnAreaSize.y * 0.5f;\n        particle.gameObject.transform.position = newPos;\n        particle.startPosition = newPos;\n        particle.lifetime = 0f;\n        particle.maxLifetime = Random.Range(10f, 30f);\n        \n        particle.velocity = new Vector3(\n            Random.Range(-_driftVariation, _driftVariation),\n            Random.Range(-_driftSpeed * 0.5f, _driftSpeed * 0.5f),\n            Random.Range(-_driftVariation, _driftVariation)\n        );\n    }\n    \n    private void UpdateParticleVisibility()\n    {\n        if (_nearbyLights == null) return;\n        \n        foreach (DustParticle particle in _particles)\n        {\n            if (particle.gameObject == null) continue;\n            \n            float lightInfluence = CalculateLightInfluence(particle.gameObject.transform.position);\n            float alpha = particle.baseAlpha * lightInfluence;\n            \n            Color currentColor = particle.renderer.material.color;\n            currentColor.a = alpha;\n            particle.renderer.material.color = currentColor;\n            \n            particle.renderer.enabled = alpha > 0.01f;\n        }\n    }\n    \n    private float CalculateLightInfluence(Vector3 position)\n    {\n        float totalInfluence = 0f;\n        \n        foreach (Light light in _nearbyLights)\n        {\n            if (light == null || !light.enabled) continue;\n            \n            float distance = Vector3.Distance(position, light.transform.position);\n            float lightRange = light.range;\n            \n            if (distance > lightRange) continue;\n            \n            float influence = 1f - (distance / lightRange);\n            influence = Mathf.Pow(influence, 2f);\n            \n            if (light.type == LightType.Spot)\n            {\n                Vector3 dirToParticle = (position - light.transform.position).normalized;\n                float angle = Vector3.Angle(light.transform.forward, dirToParticle);\n                float spotAngle = light.spotAngle * 0.5f;\n                \n                if (angle > spotAngle)\n                {\n                    influence *= Mathf.Max(0f, 1f - (angle - spotAngle) / _fadeDistance);\n                }\n            }\n            \n            influence *= light.intensity;\n            totalInfluence += influence;\n        }\n        \n        return Mathf.Clamp01(totalInfluence);\n    }\n    \n    private void UpdateLightSources()\n    {\n        Collider[] lightColliders = Physics.OverlapSphere(transform.position, _lightDetectionRadius, _lightLayerMask);\n        List<Light> lights = new List<Light>();\n        \n        foreach (Collider col in lightColliders)\n        {\n            Light light = col.GetComponent<Light>();\n            if (light != null)\n            {\n                lights.Add(light);\n            }\n        }\n        \n        Light[] allLights = FindObjectsOfType<Light>();\n        foreach (Light light in allLights)\n        {\n            if (Vector3.Distance(light.transform.position, transform.position) <= _lightDetectionRadius)\n            {\n                if (!lights.Contains(light))\n                {\n                    lights.Add(light);\n                }\n            }\n        }\n        \n        _nearbyLights = lights.ToArray();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, _spawnAreaSize);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _lightDetectionRadius);\n    }\n    \n    void OnDestroy()\n    {\n        foreach (DustParticle particle in _particles)\n        {\n            if (particle.gameObject != null)\n            {\n                DestroyImmediate(particle.gameObject);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "underwater bubble effects",
      "ideal_ir": {
        "class_name": "UnderwaterBubbleEffects",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "bubbleSpawnRate",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "bubbleSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "maxBubbles",
            "type": "int",
            "default": 50
          },
          {
            "name": "bubbleLifetime",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "spawnRadius",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "surfaceHeight",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "bubblePopSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "ambientBubbleSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "spawn_bubbles_continuously",
            "trigger": "when underwater effect is active",
            "actions": [
              {
                "action": "spawn bubbles at random positions within spawn radius"
              },
              {
                "action": "vary bubble sizes randomly"
              },
              {
                "action": "set bubble transparency to semi-transparent"
              }
            ]
          },
          {
            "name": "animate_bubble_movement",
            "trigger": "when bubbles exist in scene",
            "actions": [
              {
                "action": "move bubbles upward toward surface"
              },
              {
                "action": "add slight wobbling motion to bubbles"
              },
              {
                "action": "gradually increase bubble speed as they rise"
              }
            ]
          },
          {
            "name": "handle_surface_interaction",
            "trigger": "when bubble reaches surface height",
            "actions": [
              {
                "action": "play bubble pop sound effect"
              },
              {
                "action": "create small splash particle effect"
              },
              {
                "action": "destroy bubble particle"
              }
            ]
          },
          {
            "name": "manage_bubble_lifetime",
            "trigger": "when bubble exceeds maximum lifetime",
            "actions": [
              {
                "action": "fade out bubble gradually"
              },
              {
                "action": "remove bubble from scene"
              }
            ]
          },
          {
            "name": "play_ambient_sounds",
            "trigger": "when underwater bubble effects are active",
            "actions": [
              {
                "action": "play looping ambient bubble sounds"
              },
              {
                "action": "adjust sound volume based on bubble density"
              }
            ]
          },
          {
            "name": "limit_bubble_count",
            "trigger": "when bubble count exceeds maximum limit",
            "actions": [
              {
                "action": "stop spawning new bubbles temporarily"
              },
              {
                "action": "remove oldest bubbles first"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class UnderwaterBubbleEffects : MonoBehaviour\n{\n    [Header(\"Bubble Generation\")]\n    [SerializeField] private GameObject _bubblePrefab;\n    [SerializeField] private int _maxBubbles = 50;\n    [SerializeField] private float _bubbleSpawnRate = 2f;\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(10f, 1f, 10f);\n    [SerializeField] private float _bubbleLifetime = 8f;\n    \n    [Header(\"Bubble Movement\")]\n    [SerializeField] private float _minRiseSpeed = 1f;\n    [SerializeField] private float _maxRiseSpeed = 3f;\n    [SerializeField] private float _horizontalDriftStrength = 0.5f;\n    [SerializeField] private float _wavyMotionFrequency = 1f;\n    [SerializeField] private float _wavyMotionAmplitude = 0.3f;\n    \n    [Header(\"Bubble Appearance\")]\n    [SerializeField] private float _minBubbleSize = 0.1f;\n    [SerializeField] private float _maxBubbleSize = 0.5f;\n    [SerializeField] private AnimationCurve _sizeOverLifetime = AnimationCurve.Linear(0f, 1f, 1f, 0.8f);\n    [SerializeField] private AnimationCurve _alphaOverLifetime = AnimationCurve.EaseInOut(0f, 0f, 0.2f, 1f);\n    \n    [Header(\"Water Surface\")]\n    [SerializeField] private float _waterSurfaceY = 5f;\n    [SerializeField] private bool _popAtSurface = true;\n    [SerializeField] private GameObject _popEffectPrefab;\n    \n    [Header(\"Player Interaction\")]\n    [SerializeField] private bool _reactToPlayer = true;\n    [SerializeField] private float _playerDetectionRadius = 3f;\n    [SerializeField] private float _playerAvoidanceStrength = 2f;\n    \n    private List<BubbleData> _activeBubbles = new List<BubbleData>();\n    private float _nextSpawnTime;\n    private Transform _playerTransform;\n    \n    [System.Serializable]\n    private class BubbleData\n    {\n        public GameObject gameObject;\n        public Transform transform;\n        public Renderer renderer;\n        public float spawnTime;\n        public float riseSpeed;\n        public float initialSize;\n        public Vector3 driftDirection;\n        public float wavyOffset;\n        public Material material;\n        public Color originalColor;\n    }\n    \n    private void Start()\n    {\n        if (_bubblePrefab == null)\n        {\n            CreateDefaultBubblePrefab();\n        }\n        \n        FindPlayer();\n        _nextSpawnTime = Time.time + (1f / _bubbleSpawnRate);\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _nextSpawnTime && _activeBubbles.Count < _maxBubbles)\n        {\n            SpawnBubble();\n            _nextSpawnTime = Time.time + (1f / _bubbleSpawnRate);\n        }\n        \n        UpdateBubbles();\n        CleanupBubbles();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void SpawnBubble()\n    {\n        Vector3 spawnPosition = transform.position + new Vector3(\n            Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f),\n            Random.Range(-_spawnAreaSize.y * 0.5f, _spawnAreaSize.y * 0.5f),\n            Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f)\n        );\n        \n        GameObject bubbleObj = Instantiate(_bubblePrefab, spawnPosition, Quaternion.identity);\n        \n        BubbleData bubble = new BubbleData\n        {\n            gameObject = bubbleObj,\n            transform = bubbleObj.transform,\n            renderer = bubbleObj.GetComponent<Renderer>(),\n            spawnTime = Time.time,\n            riseSpeed = Random.Range(_minRiseSpeed, _maxRiseSpeed),\n            initialSize = Random.Range(_minBubbleSize, _maxBubbleSize),\n            driftDirection = new Vector3(Random.Range(-1f, 1f), 0f, Random.Range(-1f, 1f)).normalized,\n            wavyOffset = Random.Range(0f, Mathf.PI * 2f)\n        };\n        \n        if (bubble.renderer != null)\n        {\n            bubble.material = bubble.renderer.material;\n            bubble.originalColor = bubble.material.color;\n        }\n        \n        bubble.transform.localScale = Vector3.one * bubble.initialSize;\n        _activeBubbles.Add(bubble);\n    }\n    \n    private void UpdateBubbles()\n    {\n        for (int i = 0; i < _activeBubbles.Count; i++)\n        {\n            BubbleData bubble = _activeBubbles[i];\n            if (bubble.gameObject == null) continue;\n            \n            float age = Time.time - bubble.spawnTime;\n            float normalizedAge = age / _bubbleLifetime;\n            \n            // Movement\n            Vector3 movement = Vector3.up * bubble.riseSpeed * Time.deltaTime;\n            \n            // Add wavy motion\n            float wavyX = Mathf.Sin((Time.time * _wavyMotionFrequency) + bubble.wavyOffset) * _wavyMotionAmplitude;\n            float wavyZ = Mathf.Cos((Time.time * _wavyMotionFrequency * 0.7f) + bubble.wavyOffset) * _wavyMotionAmplitude;\n            movement += new Vector3(wavyX, 0f, wavyZ) * Time.deltaTime;\n            \n            // Add drift\n            movement += bubble.driftDirection * _horizontalDriftStrength * Time.deltaTime;\n            \n            // Player avoidance\n            if (_reactToPlayer && _playerTransform != null)\n            {\n                Vector3 toPlayer = _playerTransform.position - bubble.transform.position;\n                float distanceToPlayer = toPlayer.magnitude;\n                \n                if (distanceToPlayer < _playerDetectionRadius)\n                {\n                    Vector3 avoidanceForce = -toPlayer.normalized * _playerAvoidanceStrength * Time.deltaTime;\n                    avoidanceForce.y *= 0.3f; // Reduce vertical avoidance\n                    movement += avoidanceForce;\n                }\n            }\n            \n            bubble.transform.position += movement;\n            \n            // Update appearance\n            float sizeMultiplier = _sizeOverLifetime.Evaluate(normalizedAge);\n            bubble.transform.localScale = Vector3.one * (bubble.initialSize * sizeMultiplier);\n            \n            if (bubble.material != null)\n            {\n                float alpha = _alphaOverLifetime.Evaluate(normalizedAge);\n                Color color = bubble.originalColor;\n                color.a = alpha;\n                bubble.material.color = color;\n            }\n            \n            // Check if bubble reached surface\n            if (_popAtSurface && bubble.transform.position.y >= _waterSurfaceY)\n            {\n                if (_popEffectPrefab != null)\n                {\n                    Vector3 popPosition = new Vector3(bubble.transform.position.x, _waterSurfaceY, bubble.transform.position.z);\n                    Instantiate(_popEffectPrefab, popPosition, Quaternion.identity);\n                }\n                \n                DestroyBubble(i);\n                i--;\n            }\n        }\n    }\n    \n    private void CleanupBubbles()\n    {\n        for (int i = _activeBubbles.Count - 1; i >= 0; i--)\n        {\n            BubbleData bubble = _activeBubbles[i];\n            \n            if (bubble.gameObject == null || Time.time - bubble.spawnTime >= _bubbleLifetime)\n            {\n                DestroyBubble(i);\n            }\n        }\n    }\n    \n    private void DestroyBubble(int index)\n    {\n        if (index >= 0 && index < _activeBubbles.Count)\n        {\n            BubbleData bubble = _activeBubbles[index];\n            if (bubble.gameObject != null)\n            {\n                DestroyImmediate(bubble.gameObject);\n            }\n            _activeBubbles.RemoveAt(index);\n        }\n    }\n    \n    private void CreateDefaultBubblePrefab()\n    {\n        GameObject bubble = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        bubble.name = \"DefaultBubble\";\n        \n        // Remove collider\n        Collider collider = bubble.GetComponent<Collider>();\n        if (collider != null)\n        {\n            DestroyImmediate(collider);\n        }\n        \n        // Setup material\n        Renderer renderer = bubble.GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            Material bubbleMaterial = new Material(Shader.Find(\"Standard\"));\n            bubbleMaterial.SetFloat(\"_Mode\", 3); // Transparent mode\n            bubbleMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            bubbleMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            bubbleMaterial.SetInt(\"_ZWrite\", 0);\n            bubbleMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            bubbleMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            bubbleMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            bubbleMaterial.renderQueue = 3000;\n            \n            bubbleMaterial.color = new Color(0.8f, 0.9f, 1f, 0.3f);\n            bubbleMaterial.SetFloat(\"_Metallic\", 0f);\n            bubbleMaterial.SetFloat(\"_Glossiness\", 0.9f);\n            \n            renderer.material = bubbleMaterial;\n        }\n        \n        _bubblePrefab = bubble;\n        bubble.SetActive(false);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, _spawnAreaSize);\n        \n        if (_reactToPlayer && _playerTransform != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_playerTransform.position, _playerDetectionRadius);\n        }\n        \n        if (_popAtSurface)\n        {\n            Gizmos.color = Color.blue;\n            Vector3 surfaceStart = transform.position - Vector3.right * _spawnAreaSize.x * 0.5f;\n            Vector3 surfaceEnd = transform.position + Vector3.right * _spawnAreaSize.x * 0.5f;\n            surfaceStart.y = _waterSurfaceY;\n            surfaceEnd.y = _waterSurfaceY;\n            Gizmos.DrawLine(surfaceStart, surfaceEnd);\n        }\n    }\n    \n    public void SetBubbleSpawnRate(float rate)\n    {\n        _bubbleSpawnRate = Mathf.Max(0.1f, rate);\n    }\n    \n    public void SetWaterSurfaceLevel(float level)\n    {\n        _waterSurfaceY = level;\n    }\n    \n    public void ClearAllBubbles()\n    {\n        for (int i = _activeBubbles.Count - 1; i >= 0; i--)\n        {\n            DestroyBubble(i);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "fire crackling with embers",
      "ideal_ir": {
        "class_name": "FireCrackling",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "crackleIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "emberCount",
            "type": "int",
            "default": 20
          },
          {
            "name": "fireSize",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "continuous_crackling",
            "trigger": "always active",
            "actions": [
              {
                "action": "play crackling fire sound continuously"
              },
              {
                "action": "emit orange and red flame particles upward"
              },
              {
                "action": "create flickering light effect"
              }
            ]
          },
          {
            "name": "random_crackle_pops",
            "trigger": "randomly every few seconds",
            "actions": [
              {
                "action": "play sharp crackling pop sound"
              },
              {
                "action": "briefly increase particle emission rate"
              },
              {
                "action": "create small spark burst effect"
              }
            ]
          },
          {
            "name": "ember_generation",
            "trigger": "continuously while fire is active",
            "actions": [
              {
                "action": "spawn glowing ember particles"
              },
              {
                "action": "make embers float upward and fade out"
              },
              {
                "action": "give embers random drift movement"
              }
            ]
          },
          {
            "name": "intensity_variation",
            "trigger": "based on crackling intensity setting",
            "actions": [
              {
                "action": "adjust flame particle size and speed"
              },
              {
                "action": "modify crackling sound volume"
              },
              {
                "action": "change ember spawn frequency"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FireCrackling : MonoBehaviour\n{\n    [Header(\"Fire Settings\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private ParticleSystem _emberParticles;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private AudioSource _crackleAudioSource;\n    \n    [Header(\"Crackling Audio\")]\n    [SerializeField] private AudioClip[] _crackleClips;\n    [SerializeField] private float _minCrackleInterval = 1f;\n    [SerializeField] private float _maxCrackleInterval = 4f;\n    [SerializeField] private float _crackleVolumeMin = 0.3f;\n    [SerializeField] private float _crackleVolumeMax = 0.8f;\n    \n    [Header(\"Fire Light Animation\")]\n    [SerializeField] private float _baseLightIntensity = 2f;\n    [SerializeField] private float _lightFlickerAmount = 0.5f;\n    [SerializeField] private float _lightFlickerSpeed = 8f;\n    [SerializeField] private Color _baseLightColor = Color.yellow;\n    [SerializeField] private Color _flickerLightColor = new Color(1f, 0.6f, 0.2f);\n    \n    [Header(\"Ember Settings\")]\n    [SerializeField] private int _maxEmbers = 20;\n    [SerializeField] private float _emberSpawnRate = 2f;\n    [SerializeField] private float _emberLifetime = 3f;\n    [SerializeField] private Vector3 _emberSpawnArea = new Vector3(1f, 0.5f, 1f);\n    [SerializeField] private float _emberUpwardForce = 2f;\n    [SerializeField] private float _emberRandomForce = 1f;\n    \n    [Header(\"Fire Intensity\")]\n    [SerializeField] private float _fireIntensity = 1f;\n    [SerializeField] private bool _isLit = true;\n    \n    private float _nextCrackleTime;\n    private float _nextEmberSpawnTime;\n    private List<EmberParticle> _activeEmbers = new List<EmberParticle>();\n    private float _lightFlickerOffset;\n    \n    [System.Serializable]\n    private class EmberParticle\n    {\n        public GameObject gameObject;\n        public Rigidbody rigidbody;\n        public Light light;\n        public float lifetime;\n        public float maxLifetime;\n        public Color startColor;\n        \n        public EmberParticle(GameObject go, float life)\n        {\n            gameObject = go;\n            rigidbody = go.GetComponent<Rigidbody>();\n            light = go.GetComponent<Light>();\n            maxLifetime = life;\n            lifetime = life;\n            startColor = light ? light.color : Color.red;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _lightFlickerOffset = Random.Range(0f, 100f);\n        _nextCrackleTime = Time.time + Random.Range(_minCrackleInterval, _maxCrackleInterval);\n        _nextEmberSpawnTime = Time.time + (1f / _emberSpawnRate);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_fireLight == null)\n            _fireLight = GetComponent<Light>();\n            \n        if (_crackleAudioSource == null)\n            _crackleAudioSource = GetComponent<AudioSource>();\n            \n        if (_fireParticles == null)\n            _fireParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (!_isLit) return;\n        \n        UpdateFireLight();\n        HandleCrackling();\n        HandleEmberSpawning();\n        UpdateEmbers();\n        UpdateParticleIntensity();\n    }\n    \n    private void UpdateFireLight()\n    {\n        if (_fireLight == null) return;\n        \n        float flicker = Mathf.PerlinNoise(Time.time * _lightFlickerSpeed, _lightFlickerOffset);\n        float intensity = _baseLightIntensity + (flicker - 0.5f) * _lightFlickerAmount;\n        intensity *= _fireIntensity;\n        \n        _fireLight.intensity = Mathf.Max(0f, intensity);\n        _fireLight.color = Color.Lerp(_baseLightColor, _flickerLightColor, flicker * 0.5f);\n    }\n    \n    private void HandleCrackling()\n    {\n        if (Time.time >= _nextCrackleTime && _crackleClips.Length > 0 && _crackleAudioSource != null)\n        {\n            PlayCrackleSound();\n            _nextCrackleTime = Time.time + Random.Range(_minCrackleInterval, _maxCrackleInterval);\n        }\n    }\n    \n    private void PlayCrackleSound()\n    {\n        AudioClip clip = _crackleClips[Random.Range(0, _crackleClips.Length)];\n        float volume = Random.Range(_crackleVolumeMin, _crackleVolumeMax) * _fireIntensity;\n        float pitch = Random.Range(0.8f, 1.2f);\n        \n        _crackleAudioSource.pitch = pitch;\n        _crackleAudioSource.PlayOneShot(clip, volume);\n    }\n    \n    private void HandleEmberSpawning()\n    {\n        if (Time.time >= _nextEmberSpawnTime && _activeEmbers.Count < _maxEmbers)\n        {\n            SpawnEmber();\n            _nextEmberSpawnTime = Time.time + (1f / (_emberSpawnRate * _fireIntensity));\n        }\n    }\n    \n    private void SpawnEmber()\n    {\n        GameObject ember = CreateEmberGameObject();\n        EmberParticle emberParticle = new EmberParticle(ember, _emberLifetime);\n        \n        Vector3 spawnPos = transform.position + new Vector3(\n            Random.Range(-_emberSpawnArea.x * 0.5f, _emberSpawnArea.x * 0.5f),\n            Random.Range(0f, _emberSpawnArea.y),\n            Random.Range(-_emberSpawnArea.z * 0.5f, _emberSpawnArea.z * 0.5f)\n        );\n        \n        ember.transform.position = spawnPos;\n        \n        Vector3 force = Vector3.up * _emberUpwardForce + Random.insideUnitSphere * _emberRandomForce;\n        emberParticle.rigidbody.AddForce(force, ForceMode.Impulse);\n        \n        _activeEmbers.Add(emberParticle);\n    }\n    \n    private GameObject CreateEmberGameObject()\n    {\n        GameObject ember = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        ember.name = \"Ember\";\n        ember.transform.localScale = Vector3.one * Random.Range(0.02f, 0.05f);\n        \n        Destroy(ember.GetComponent<Collider>());\n        \n        Rigidbody rb = ember.AddComponent<Rigidbody>();\n        rb.mass = 0.01f;\n        rb.drag = 2f;\n        rb.angularDrag = 5f;\n        \n        Light emberLight = ember.AddComponent<Light>();\n        emberLight.type = LightType.Point;\n        emberLight.color = new Color(1f, 0.4f, 0.1f);\n        emberLight.intensity = Random.Range(0.5f, 1.5f);\n        emberLight.range = Random.Range(0.5f, 1.5f);\n        \n        Renderer renderer = ember.GetComponent<Renderer>();\n        Material mat = new Material(Shader.Find(\"Standard\"));\n        mat.SetColor(\"_Color\", Color.red);\n        mat.SetColor(\"_EmissionColor\", Color.red * 2f);\n        mat.EnableKeyword(\"_EMISSION\");\n        renderer.material = mat;\n        \n        return ember;\n    }\n    \n    private void UpdateEmbers()\n    {\n        for (int i = _activeEmbers.Count - 1; i >= 0; i--)\n        {\n            EmberParticle ember = _activeEmbers[i];\n            ember.lifetime -= Time.deltaTime;\n            \n            if (ember.lifetime <= 0f || ember.gameObject == null)\n            {\n                if (ember.gameObject != null)\n                    Destroy(ember.gameObject);\n                _activeEmbers.RemoveAt(i);\n                continue;\n            }\n            \n            float lifetimeRatio = ember.lifetime / ember.maxLifetime;\n            \n            if (ember.light != null)\n            {\n                ember.light.intensity *= lifetimeRatio;\n                ember.light.color = Color.Lerp(Color.black, ember.startColor, lifetimeRatio);\n            }\n            \n            if (ember.gameObject != null)\n            {\n                Renderer renderer = ember.gameObject.GetComponent<Renderer>();\n                if (renderer != null && renderer.material != null)\n                {\n                    Color emberColor = Color.Lerp(Color.black, Color.red, lifetimeRatio);\n                    renderer.material.SetColor(\"_Color\", emberColor);\n                    renderer.material.SetColor(\"_EmissionColor\", emberColor * lifetimeRatio * 2f);\n                }\n            }\n        }\n    }\n    \n    private void UpdateParticleIntensity()\n    {\n        UpdateParticleSystem(_fireParticles, _fireIntensity);\n        UpdateParticleSystem(_smokeParticles, _fireIntensity * 0.8f);\n        UpdateParticleSystem(_emberParticles, _fireIntensity);\n    }\n    \n    private void UpdateParticleSystem(ParticleSystem particles, float intensity)\n    {\n        if (particles == null) return;\n        \n        var emission = particles.emission;\n        var main = particles.main;\n        \n        emission.rateOverTime = emission.rateOverTime.constant * intensity;\n        main.startLifetime = main.startLifetime.constant * (0.5f + intensity * 0.5f);\n    }\n    \n    public void SetFireIntensity(float intensity)\n    {\n        _fireIntensity = Mathf.Clamp01(intensity);\n    }\n    \n    public void ExtinguishFire()\n    {\n        _isLit = false;\n        _fireIntensity = 0f;\n        \n        if (_fireParticles != null) _fireParticles.Stop();\n        if (_emberParticles != null) _emberParticles.Stop();\n        if (_fireLight != null) _fireLight.intensity = 0f;\n        \n        foreach (var ember in _activeEmbers)\n        {\n            if (ember.gameObject != null)\n                Destroy(ember.gameObject);\n        }\n        _activeEmbers.Clear();\n    }\n    \n    public void LightFire()\n    {\n        _isLit = true;\n        _fireIntensity = 1f;\n        \n        if (_fireParticles != null) _fireParticles.Play();\n        if (_emberParticles != null) _emberParticles.Play();\n        if (_smokeParticles != null) _smokeParticles.Play();\n    }\n    \n    private void OnDestroy()\n    {\n        foreach (var ember in _activeEmbers)\n        {\n            if (ember.gameObject != null)\n                Destroy(ember.gameObject);\n        }\n        _activeEmbers.Clear();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "waterfall with mist",
      "ideal_ir": {
        "class_name": "Waterfall",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "mistIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "waterFlowRate",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "mistSpreadRadius",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "soundVolume",
            "type": "float",
            "default": 0.8
          }
        ],
        "behaviors": [
          {
            "name": "generate_water_particles",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "emit water particles downward at flow rate"
              },
              {
                "action": "apply gravity to water particles"
              },
              {
                "action": "fade out particles as they fall"
              }
            ]
          },
          {
            "name": "create_mist_effect",
            "trigger": "when water particles hit bottom",
            "actions": [
              {
                "action": "spawn mist particles at impact point"
              },
              {
                "action": "spread mist particles outward in radius"
              },
              {
                "action": "make mist particles rise slowly"
              },
              {
                "action": "fade mist particles over time"
              }
            ]
          },
          {
            "name": "play_waterfall_sound",
            "trigger": "continuously while active",
            "actions": [
              {
                "action": "play rushing water sound at specified volume"
              },
              {
                "action": "adjust sound intensity based on flow rate"
              }
            ]
          },
          {
            "name": "adjust_mist_density",
            "trigger": "when mist intensity changes",
            "actions": [
              {
                "action": "increase or decrease mist particle count"
              },
              {
                "action": "modify mist particle size based on intensity"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Waterfall : MonoBehaviour\n{\n    [Header(\"Water Settings\")]\n    [SerializeField] private ParticleSystem _waterParticles;\n    [SerializeField] private float _waterFlowRate = 100f;\n    [SerializeField] private float _waterSpeed = 5f;\n    [SerializeField] private Color _waterColor = Color.cyan;\n    \n    [Header(\"Mist Settings\")]\n    [SerializeField] private ParticleSystem _mistParticles;\n    [SerializeField] private float _mistDensity = 50f;\n    [SerializeField] private float _mistSpread = 2f;\n    [SerializeField] private Color _mistColor = Color.white;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _waterfallSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private BoxCollider _splashZone;\n    [SerializeField] private float _splashForce = 10f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _mistLight;\n    [SerializeField] private float _lightIntensity = 0.5f;\n    [SerializeField] private Color _lightColor = Color.white;\n    [SerializeField] private AnimationCurve _intensityCurve = AnimationCurve.EaseInOut(0f, 0.3f, 1f, 1f);\n    \n    private float _timeOffset;\n    private Vector3 _originalLightPosition;\n    private List<Rigidbody> _objectsInSplashZone = new List<Rigidbody>();\n    \n    void Start()\n    {\n        _timeOffset = Random.Range(0f, 100f);\n        SetupWaterParticles();\n        SetupMistParticles();\n        SetupAudio();\n        SetupSplashZone();\n        SetupLighting();\n    }\n    \n    void SetupWaterParticles()\n    {\n        if (_waterParticles == null)\n        {\n            GameObject waterGO = new GameObject(\"WaterParticles\");\n            waterGO.transform.SetParent(transform);\n            waterGO.transform.localPosition = Vector3.zero;\n            _waterParticles = waterGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _waterParticles.main;\n        main.startLifetime = 3f;\n        main.startSpeed = _waterSpeed;\n        main.startSize = 0.1f;\n        main.startColor = _waterColor;\n        main.maxParticles = (int)_waterFlowRate;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _waterParticles.emission;\n        emission.rateOverTime = _waterFlowRate;\n        \n        var shape = _waterParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(1f, 0.1f, 0.5f);\n        \n        var velocityOverLifetime = _waterParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(-_waterSpeed);\n        \n        var collision = _waterParticles.collision;\n        collision.enabled = true;\n        collision.type = ParticleSystemCollisionType.World;\n        collision.mode = ParticleSystemCollisionMode.Collision3D;\n        collision.dampen = 0.3f;\n        collision.bounce = 0.1f;\n    }\n    \n    void SetupMistParticles()\n    {\n        if (_mistParticles == null)\n        {\n            GameObject mistGO = new GameObject(\"MistParticles\");\n            mistGO.transform.SetParent(transform);\n            mistGO.transform.localPosition = new Vector3(0f, -2f, 0f);\n            _mistParticles = mistGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _mistParticles.main;\n        main.startLifetime = 5f;\n        main.startSpeed = 0.5f;\n        main.startSize = new ParticleSystem.MinMaxCurve(0.5f, 2f);\n        main.startColor = _mistColor;\n        main.maxParticles = (int)_mistDensity;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _mistParticles.emission;\n        emission.rateOverTime = _mistDensity;\n        \n        var shape = _mistParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(_mistSpread, 0.5f, _mistSpread);\n        \n        var velocityOverLifetime = _mistParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(0.2f, 1f);\n        \n        var sizeOverLifetime = _mistParticles.sizeOverLifetime;\n        sizeOverLifetime.enabled = true;\n        sizeOverLifetime.size = new ParticleSystem.MinMaxCurve(1f, AnimationCurve.Linear(0f, 0.2f, 1f, 1f));\n        \n        var colorOverLifetime = _mistParticles.colorOverLifetime;\n        colorOverLifetime.enabled = true;\n        Gradient gradient = new Gradient();\n        gradient.SetKeys(\n            new GradientColorKey[] { new GradientColorKey(_mistColor, 0f), new GradientColorKey(_mistColor, 1f) },\n            new GradientAlphaKey[] { new GradientAlphaKey(0f, 0f), new GradientAlphaKey(0.8f, 0.3f), new GradientAlphaKey(0f, 1f) }\n        );\n        colorOverLifetime.color = gradient;\n    }\n    \n    void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        if (_waterfallSound != null)\n        {\n            _audioSource.clip = _waterfallSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            _audioSource.spatialBlend = 1f;\n            _audioSource.rolloffMode = AudioRolloffMode.Logarithmic;\n            _audioSource.maxDistance = 20f;\n            _audioSource.Play();\n        }\n    }\n    \n    void SetupSplashZone()\n    {\n        if (_splashZone == null)\n        {\n            _splashZone = gameObject.AddComponent<BoxCollider>();\n            _splashZone.isTrigger = true;\n            _splashZone.size = new Vector3(2f, 1f, 2f);\n            _splashZone.center = new Vector3(0f, -2.5f, 0f);\n        }\n    }\n    \n    void SetupLighting()\n    {\n        if (_mistLight == null)\n        {\n            GameObject lightGO = new GameObject(\"MistLight\");\n            lightGO.transform.SetParent(transform);\n            lightGO.transform.localPosition = new Vector3(0f, -1f, 1f);\n            _mistLight = lightGO.AddComponent<Light>();\n        }\n        \n        _mistLight.type = LightType.Point;\n        _mistLight.color = _lightColor;\n        _mistLight.intensity = _lightIntensity;\n        _mistLight.range = 5f;\n        _mistLight.shadows = LightShadows.Soft;\n        \n        _originalLightPosition = _mistLight.transform.localPosition;\n    }\n    \n    void Update()\n    {\n        UpdateLighting();\n        UpdateParticleEffects();\n        ApplySplashForces();\n    }\n    \n    void UpdateLighting()\n    {\n        if (_mistLight != null)\n        {\n            float time = Time.time + _timeOffset;\n            float intensity = _intensityCurve.Evaluate((Mathf.Sin(time * 0.5f) + 1f) * 0.5f);\n            _mistLight.intensity = _lightIntensity * intensity;\n            \n            Vector3 offset = new Vector3(\n                Mathf.Sin(time * 0.3f) * 0.2f,\n                Mathf.Sin(time * 0.7f) * 0.1f,\n                Mathf.Cos(time * 0.4f) * 0.15f\n            );\n            _mistLight.transform.localPosition = _originalLightPosition + offset;\n        }\n    }\n    \n    void UpdateParticleEffects()\n    {\n        if (_waterParticles != null)\n        {\n            var emission = _waterParticles.emission;\n            emission.rateOverTime = _waterFlowRate;\n            \n            var main = _waterParticles.main;\n            main.startSpeed = _waterSpeed;\n            main.startColor = _waterColor;\n        }\n        \n        if (_mistParticles != null)\n        {\n            var emission = _mistParticles.emission;\n            emission.rateOverTime = _mistDensity;\n            \n            var main = _mistParticles.main;\n            main.startColor = _mistColor;\n            \n            var shape = _mistParticles.shape;\n            shape.scale = new Vector3(_mistSpread, 0.5f, _mistSpread);\n        }\n    }\n    \n    void ApplySplashForces()\n    {\n        for (int i = _objectsInSplashZone.Count - 1; i >= 0; i--)\n        {\n            if (_objectsInSplashZone[i] == null)\n            {\n                _objectsInSplashZone.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody rb = _objectsInSplashZone[i];\n            Vector3 splashDirection = Vector3.up + Random.insideUnitSphere * 0.3f;\n            rb.AddForce(splashDirection * _splashForce * Time.deltaTime, ForceMode.Force);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _affectedLayers) != 0)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && !_objectsInSplashZone.Contains(rb))\n            {\n                _objectsInSplashZone.Add(rb);\n                \n                // Create splash effect\n                CreateSplashEffect(other.transform.position);\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && _objectsInSplashZone.Contains(rb))\n        {\n            _objectsInSplashZone.Remove(rb);\n        }\n    }\n    \n    void CreateSplashEffect(Vector3 position)\n    {\n        GameObject splashGO = new GameObject(\"SplashEffect\");\n        splashGO.transform.position = position;\n        \n        ParticleSystem splash = splashGO.AddComponent<ParticleSystem>();\n        \n        var main = splash.main;\n        main.startLifetime = 1f;\n        main.startSpeed = 3f;\n        main.startSize = 0.2f;\n        main.startColor = _waterColor;\n        main.maxParticles = 20;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = splash.emission;\n        emission.SetBursts(new ParticleSystem.Burst[] {\n            new ParticleSystem.Burst(0f, 20)\n        });\n        \n        var shape = splash.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Hemisphere;\n        shape.radius = 0.5f;\n        \n        Destroy(splashGO, 2f);\n    }\n    \n    void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            UpdateParticleEffects();\n            \n            if (_audioSource != null)\n                _audioSource.volume = _audioVolume;\n            \n            if (_mistLight != null)\n            {\n                _mistLight.color = _lightColor;\n                _mistLight.intensity = _lightIntensity;\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "aurora borealis sky effect",
      "ideal_ir": {
        "class_name": "AuroraBorealisEffect",
        "components": [
          "ParticleSystem",
          "Light",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "intensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "waveSpeed",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "colorShiftSpeed",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "flickerIntensity",
            "type": "float",
            "default": 0.2
          },
          {
            "name": "ambientVolume",
            "type": "float",
            "default": 0.4
          },
          {
            "name": "maxBrightness",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "minBrightness",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "continuous_wave_motion",
            "trigger": "every frame while effect is active",
            "actions": [
              {
                "action": "create flowing wave patterns across the sky"
              },
              {
                "action": "animate particle positions in smooth undulating motion"
              },
              {
                "action": "vary the height and width of aurora bands dynamically"
              }
            ]
          },
          {
            "name": "color_cycling",
            "trigger": "continuously over time",
            "actions": [
              {
                "action": "cycle through green blue and purple color spectrum"
              },
              {
                "action": "blend colors smoothly between different hues"
              },
              {
                "action": "adjust particle color gradients from bottom to top"
              }
            ]
          },
          {
            "name": "brightness_flickering",
            "trigger": "at random intervals",
            "actions": [
              {
                "action": "create subtle brightness variations"
              },
              {
                "action": "simulate natural aurora intensity fluctuations"
              },
              {
                "action": "adjust light component brightness accordingly"
              }
            ]
          },
          {
            "name": "ambient_lighting",
            "trigger": "when aurora brightness changes",
            "actions": [
              {
                "action": "cast colored light onto surrounding environment"
              },
              {
                "action": "create soft atmospheric glow effect"
              },
              {
                "action": "reflect aurora colors on nearby surfaces"
              }
            ]
          },
          {
            "name": "atmospheric_sound",
            "trigger": "while effect is visible",
            "actions": [
              {
                "action": "play subtle crackling and humming sounds"
              },
              {
                "action": "adjust audio volume based on aurora intensity"
              },
              {
                "action": "create immersive ambient atmosphere"
              }
            ]
          },
          {
            "name": "intensity_control",
            "trigger": "when intensity value changes",
            "actions": [
              {
                "action": "scale overall effect visibility"
              },
              {
                "action": "adjust particle emission rates"
              },
              {
                "action": "modify light brightness and color saturation"
              }
            ]
          },
          {
            "name": "nighttime_activation",
            "trigger": "when scene lighting becomes dark",
            "actions": [
              {
                "action": "gradually fade in aurora effect"
              },
              {
                "action": "increase particle system activity"
              },
              {
                "action": "enhance color vibrancy for night visibility"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class AuroraBorealis : MonoBehaviour\n{\n    [Header(\"Aurora Configuration\")]\n    [SerializeField] private Material auroraMaterial;\n    [SerializeField] private int auroraLayers = 3;\n    [SerializeField] private float auroraHeight = 50f;\n    [SerializeField] private float auroraWidth = 100f;\n    [SerializeField] private float auroraDepth = 20f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float waveSpeed = 0.5f;\n    [SerializeField] private float waveAmplitude = 2f;\n    [SerializeField] private float colorShiftSpeed = 0.3f;\n    [SerializeField] private float opacityPulseSpeed = 1f;\n    [SerializeField] private float verticalDrift = 0.2f;\n    \n    [Header(\"Visual Properties\")]\n    [SerializeField] private Gradient auroraColors;\n    [SerializeField] private AnimationCurve intensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float baseIntensity = 0.7f;\n    [SerializeField] private float maxIntensity = 1.2f;\n    [SerializeField] private bool useNoise = true;\n    [SerializeField] private float noiseScale = 0.1f;\n    \n    private List<AuroraLayer> _auroraLayers;\n    private float _timeOffset;\n    \n    [System.Serializable]\n    private class AuroraLayer\n    {\n        public GameObject gameObject;\n        public MeshRenderer renderer;\n        public Material material;\n        public float speedMultiplier;\n        public float heightOffset;\n        public float colorOffset;\n        public Vector3[] originalVertices;\n        public Mesh mesh;\n    }\n    \n    private void Start()\n    {\n        _timeOffset = Random.Range(0f, 100f);\n        InitializeAuroraColors();\n        CreateAuroraLayers();\n    }\n    \n    private void InitializeAuroraColors()\n    {\n        if (auroraColors.colorKeys.Length == 0)\n        {\n            GradientColorKey[] colorKeys = new GradientColorKey[4];\n            colorKeys[0] = new GradientColorKey(new Color(0.2f, 1f, 0.3f), 0f);\n            colorKeys[1] = new GradientColorKey(new Color(0.3f, 0.8f, 1f), 0.33f);\n            colorKeys[2] = new GradientColorKey(new Color(1f, 0.4f, 0.8f), 0.66f);\n            colorKeys[3] = new GradientColorKey(new Color(0.8f, 1f, 0.2f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(0.3f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(0.8f, 1f);\n            \n            auroraColors.SetKeys(colorKeys, alphaKeys);\n        }\n    }\n    \n    private void CreateAuroraLayers()\n    {\n        _auroraLayers = new List<AuroraLayer>();\n        \n        for (int i = 0; i < auroraLayers; i++)\n        {\n            GameObject layerObj = new GameObject($\"AuroraLayer_{i}\");\n            layerObj.transform.SetParent(transform);\n            \n            AuroraLayer layer = new AuroraLayer();\n            layer.gameObject = layerObj;\n            layer.speedMultiplier = Random.Range(0.5f, 1.5f);\n            layer.heightOffset = i * (auroraHeight / auroraLayers) + Random.Range(-5f, 5f);\n            layer.colorOffset = (float)i / auroraLayers;\n            \n            CreateAuroraMesh(layer, i);\n            _auroraLayers.Add(layer);\n        }\n    }\n    \n    private void CreateAuroraMesh(AuroraLayer layer, int layerIndex)\n    {\n        MeshFilter meshFilter = layer.gameObject.AddComponent<MeshFilter>();\n        layer.renderer = layer.gameObject.AddComponent<MeshRenderer>();\n        \n        if (auroraMaterial != null)\n        {\n            layer.material = new Material(auroraMaterial);\n        }\n        else\n        {\n            layer.material = CreateDefaultAuroraMaterial();\n        }\n        \n        layer.renderer.material = layer.material;\n        layer.renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n        layer.renderer.receiveShadows = false;\n        \n        Mesh mesh = new Mesh();\n        mesh.name = $\"AuroraMesh_{layerIndex}\";\n        \n        int segments = 50;\n        Vector3[] vertices = new Vector3[(segments + 1) * 2];\n        Vector2[] uvs = new Vector2[vertices.Length];\n        int[] triangles = new int[segments * 6];\n        \n        for (int i = 0; i <= segments; i++)\n        {\n            float t = (float)i / segments;\n            float x = (t - 0.5f) * auroraWidth;\n            float z = Random.Range(-auroraDepth * 0.5f, auroraDepth * 0.5f);\n            \n            vertices[i * 2] = new Vector3(x, layer.heightOffset, z);\n            vertices[i * 2 + 1] = new Vector3(x, layer.heightOffset + auroraHeight * 0.3f, z);\n            \n            uvs[i * 2] = new Vector2(t, 0f);\n            uvs[i * 2 + 1] = new Vector2(t, 1f);\n        }\n        \n        for (int i = 0; i < segments; i++)\n        {\n            int baseIndex = i * 6;\n            int vertIndex = i * 2;\n            \n            triangles[baseIndex] = vertIndex;\n            triangles[baseIndex + 1] = vertIndex + 2;\n            triangles[baseIndex + 2] = vertIndex + 1;\n            \n            triangles[baseIndex + 3] = vertIndex + 1;\n            triangles[baseIndex + 4] = vertIndex + 2;\n            triangles[baseIndex + 5] = vertIndex + 3;\n        }\n        \n        mesh.vertices = vertices;\n        mesh.uv = uvs;\n        mesh.triangles = triangles;\n        mesh.RecalculateNormals();\n        \n        layer.originalVertices = (Vector3[])vertices.Clone();\n        layer.mesh = mesh;\n        meshFilter.mesh = mesh;\n    }\n    \n    private Material CreateDefaultAuroraMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.SetFloat(\"_Mode\", 3);\n        mat.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        mat.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        mat.SetInt(\"_ZWrite\", 0);\n        mat.DisableKeyword(\"_ALPHATEST_ON\");\n        mat.EnableKeyword(\"_ALPHABLEND_ON\");\n        mat.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        mat.renderQueue = 3000;\n        return mat;\n    }\n    \n    private void Update()\n    {\n        float time = Time.time + _timeOffset;\n        \n        for (int i = 0; i < _auroraLayers.Count; i++)\n        {\n            UpdateAuroraLayer(_auroraLayers[i], time, i);\n        }\n    }\n    \n    private void UpdateAuroraLayer(AuroraLayer layer, float time, int layerIndex)\n    {\n        if (layer.mesh == null || layer.originalVertices == null) return;\n        \n        Vector3[] vertices = new Vector3[layer.originalVertices.Length];\n        float layerTime = time * layer.speedMultiplier;\n        \n        for (int i = 0; i < layer.originalVertices.Length; i++)\n        {\n            Vector3 originalPos = layer.originalVertices[i];\n            Vector3 newPos = originalPos;\n            \n            float waveX = Mathf.Sin(layerTime * waveSpeed + originalPos.x * 0.1f) * waveAmplitude;\n            float waveY = Mathf.Sin(layerTime * waveSpeed * 0.7f + originalPos.x * 0.05f) * waveAmplitude * 0.5f;\n            \n            if (useNoise)\n            {\n                float noiseX = Mathf.PerlinNoise(originalPos.x * noiseScale, layerTime * 0.1f) - 0.5f;\n                float noiseY = Mathf.PerlinNoise(originalPos.x * noiseScale + 100f, layerTime * 0.1f) - 0.5f;\n                waveX += noiseX * waveAmplitude * 0.5f;\n                waveY += noiseY * waveAmplitude * 0.3f;\n            }\n            \n            newPos.x += waveX;\n            newPos.y += waveY + Mathf.Sin(layerTime * verticalDrift) * 2f;\n            \n            vertices[i] = newPos;\n        }\n        \n        layer.mesh.vertices = vertices;\n        layer.mesh.RecalculateNormals();\n        \n        UpdateLayerMaterial(layer, time, layerIndex);\n    }\n    \n    private void UpdateLayerMaterial(AuroraLayer layer, float time, int layerIndex)\n    {\n        if (layer.material == null) return;\n        \n        float colorTime = (time * colorShiftSpeed + layer.colorOffset) % 1f;\n        Color auroraColor = auroraColors.Evaluate(colorTime);\n        \n        float intensityTime = time * opacityPulseSpeed + layerIndex * 0.5f;\n        float intensity = baseIntensity + (maxIntensity - baseIntensity) * intensityCurve.Evaluate((Mathf.Sin(intensityTime) + 1f) * 0.5f);\n        \n        auroraColor.a *= intensity;\n        layer.material.color = auroraColor;\n        \n        if (layer.material.HasProperty(\"_MainTex\"))\n        {\n            Vector2 offset = layer.material.mainTextureOffset;\n            offset.x = time * 0.1f * layer.speedMultiplier;\n            layer.material.mainTextureOffset = offset;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_auroraLayers != null)\n        {\n            foreach (var layer in _auroraLayers)\n            {\n                if (layer.material != null)\n                {\n                    DestroyImmediate(layer.material);\n                }\n            }\n        }\n    }\n    \n    private void OnValidate()\n    {\n        auroraLayers = Mathf.Clamp(auroraLayers, 1, 10);\n        auroraHeight = Mathf.Max(0f, auroraHeight);\n        auroraWidth = Mathf.Max(0f, auroraWidth);\n        baseIntensity = Mathf.Clamp01(baseIntensity);\n        maxIntensity = Mathf.Max(baseIntensity, maxIntensity);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "lens flare from sun",
      "ideal_ir": {
        "class_name": "SunLensFlare",
        "components": [
          "LensFlare",
          "Light"
        ],
        "fields": [
          {
            "name": "intensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "maxDistance",
            "type": "float",
            "default": 1000.0
          }
        ],
        "behaviors": [
          {
            "name": "adjust_flare_visibility",
            "trigger": "when camera looks toward sun position",
            "actions": [
              {
                "action": "increase lens flare brightness based on viewing angle"
              },
              {
                "action": "make flare more visible when directly facing sun"
              }
            ]
          },
          {
            "name": "fade_with_distance",
            "trigger": "when camera distance from sun changes",
            "actions": [
              {
                "action": "reduce flare intensity as distance increases"
              },
              {
                "action": "completely hide flare when beyond maximum distance"
              }
            ]
          },
          {
            "name": "handle_occlusion",
            "trigger": "when objects block line of sight to sun",
            "actions": [
              {
                "action": "fade out lens flare when sun is occluded"
              },
              {
                "action": "fade in lens flare when sun becomes visible again"
              }
            ]
          },
          {
            "name": "atmospheric_effects",
            "trigger": "when sun position changes throughout day",
            "actions": [
              {
                "action": "adjust flare color based on sun height"
              },
              {
                "action": "increase flare warmth when sun is low on horizon"
              },
              {
                "action": "reduce flare intensity during overcast conditions"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SunLensFlare : MonoBehaviour\n{\n    [Header(\"Lens Flare Settings\")]\n    [SerializeField] private LensFlare _lensFlare;\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Camera _playerCamera;\n    \n    [Header(\"Visibility Control\")]\n    [SerializeField] private bool _checkVisibility = true;\n    [SerializeField] private LayerMask _occlusionLayers = -1;\n    [SerializeField] private float _maxDistance = 1000f;\n    [SerializeField] private float _fadeSpeed = 5f;\n    \n    [Header(\"Dynamic Brightness\")]\n    [SerializeField] private bool _adjustBrightness = true;\n    [SerializeField] private float _maxBrightness = 1f;\n    [SerializeField] private float _minBrightness = 0.1f;\n    [SerializeField] private AnimationCurve _brightnessCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private bool _matchSunColor = true;\n    [SerializeField] private Color _customColor = Color.white;\n    [SerializeField] private Gradient _timeOfDayGradient;\n    [SerializeField] private bool _useTimeOfDay = false;\n    [SerializeField] private float _timeOfDaySpeed = 0.1f;\n    \n    private float _targetBrightness;\n    private float _currentBrightness;\n    private bool _isVisible;\n    private Vector3 _sunDirection;\n    private float _timeOfDay;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupLensFlare();\n    }\n    \n    void Update()\n    {\n        if (_lensFlare == null) return;\n        \n        UpdateSunDirection();\n        CheckVisibility();\n        UpdateBrightness();\n        UpdateColor();\n        ApplyLensFlareSettings();\n    }\n    \n    void InitializeComponents()\n    {\n        if (_lensFlare == null)\n            _lensFlare = GetComponent<LensFlare>();\n        \n        if (_lensFlare == null)\n            _lensFlare = gameObject.AddComponent<LensFlare>();\n        \n        if (_sunLight == null)\n            _sunLight = GetComponent<Light>();\n        \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n        \n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n    }\n    \n    void SetupLensFlare()\n    {\n        if (_lensFlare == null) return;\n        \n        _lensFlare.brightness = 0f;\n        _currentBrightness = 0f;\n        _targetBrightness = 0f;\n        \n        if (_timeOfDayGradient == null)\n        {\n            _timeOfDayGradient = new Gradient();\n            GradientColorKey[] colorKeys = new GradientColorKey[3];\n            colorKeys[0] = new GradientColorKey(new Color(1f, 0.5f, 0.2f), 0f);\n            colorKeys[1] = new GradientColorKey(Color.white, 0.5f);\n            colorKeys[2] = new GradientColorKey(new Color(1f, 0.7f, 0.4f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(1f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(1f, 1f);\n            \n            _timeOfDayGradient.SetKeys(colorKeys, alphaKeys);\n        }\n    }\n    \n    void UpdateSunDirection()\n    {\n        if (_playerCamera == null) return;\n        \n        _sunDirection = (transform.position - _playerCamera.transform.position).normalized;\n    }\n    \n    void CheckVisibility()\n    {\n        if (!_checkVisibility || _playerCamera == null)\n        {\n            _isVisible = true;\n            _targetBrightness = _maxBrightness;\n            return;\n        }\n        \n        Vector3 cameraPosition = _playerCamera.transform.position;\n        Vector3 sunPosition = transform.position;\n        Vector3 direction = (sunPosition - cameraPosition).normalized;\n        float distance = Vector3.Distance(cameraPosition, sunPosition);\n        \n        if (distance > _maxDistance)\n        {\n            _isVisible = false;\n            _targetBrightness = 0f;\n            return;\n        }\n        \n        Vector3 cameraForward = _playerCamera.transform.forward;\n        float dotProduct = Vector3.Dot(cameraForward, direction);\n        \n        if (dotProduct <= 0f)\n        {\n            _isVisible = false;\n            _targetBrightness = 0f;\n            return;\n        }\n        \n        RaycastHit hit;\n        if (Physics.Raycast(cameraPosition, direction, out hit, distance, _occlusionLayers))\n        {\n            if (hit.collider.transform != transform)\n            {\n                _isVisible = false;\n                _targetBrightness = 0f;\n                return;\n            }\n        }\n        \n        _isVisible = true;\n        \n        if (_adjustBrightness)\n        {\n            float normalizedDot = Mathf.Clamp01(dotProduct);\n            float curveValue = _brightnessCurve.Evaluate(normalizedDot);\n            _targetBrightness = Mathf.Lerp(_minBrightness, _maxBrightness, curveValue);\n        }\n        else\n        {\n            _targetBrightness = _maxBrightness;\n        }\n    }\n    \n    void UpdateBrightness()\n    {\n        _currentBrightness = Mathf.Lerp(_currentBrightness, _targetBrightness, Time.deltaTime * _fadeSpeed);\n    }\n    \n    void UpdateColor()\n    {\n        if (_lensFlare == null) return;\n        \n        Color targetColor = Color.white;\n        \n        if (_useTimeOfDay)\n        {\n            _timeOfDay += Time.deltaTime * _timeOfDaySpeed;\n            if (_timeOfDay > 1f) _timeOfDay = 0f;\n            targetColor = _timeOfDayGradient.Evaluate(_timeOfDay);\n        }\n        else if (_matchSunColor && _sunLight != null)\n        {\n            targetColor = _sunLight.color;\n        }\n        else\n        {\n            targetColor = _customColor;\n        }\n        \n        _lensFlare.color = targetColor;\n    }\n    \n    void ApplyLensFlareSettings()\n    {\n        if (_lensFlare == null) return;\n        \n        _lensFlare.brightness = _currentBrightness;\n        \n        if (_sunLight != null)\n        {\n            _lensFlare.enabled = _sunLight.enabled && _currentBrightness > 0.01f;\n        }\n        else\n        {\n            _lensFlare.enabled = _currentBrightness > 0.01f;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera == null) return;\n        \n        Gizmos.color = _isVisible ? Color.green : Color.red;\n        Gizmos.DrawLine(_playerCamera.transform.position, transform.position);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 5f);\n    }\n    \n    public void SetBrightness(float brightness)\n    {\n        _maxBrightness = Mathf.Clamp01(brightness);\n    }\n    \n    public void SetColor(Color color)\n    {\n        _customColor = color;\n        _matchSunColor = false;\n    }\n    \n    public void SetTimeOfDay(float normalizedTime)\n    {\n        _timeOfDay = Mathf.Clamp01(normalizedTime);\n    }\n    \n    public bool IsVisible()\n    {\n        return _isVisible;\n    }\n    \n    public float GetCurrentBrightness()\n    {\n        return _currentBrightness;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "motion blur on speed",
      "ideal_ir": {
        "class_name": "SpeedMotionBlur",
        "components": [
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "blurIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "speedThreshold",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "maxBlurAmount",
            "type": "float",
            "default": 0.8
          }
        ],
        "behaviors": [
          {
            "name": "apply_motion_blur_on_high_speed",
            "trigger": "when object velocity exceeds speed threshold",
            "actions": [
              {
                "action": "calculate blur amount based on current velocity"
              },
              {
                "action": "apply motion blur effect to camera or renderer"
              },
              {
                "action": "clamp blur amount to maximum blur limit"
              }
            ]
          },
          {
            "name": "reduce_motion_blur_on_slow_speed",
            "trigger": "when object velocity falls below speed threshold",
            "actions": [
              {
                "action": "gradually reduce motion blur intensity"
              },
              {
                "action": "disable motion blur effect when velocity is very low"
              }
            ]
          },
          {
            "name": "update_blur_direction",
            "trigger": "when object changes movement direction",
            "actions": [
              {
                "action": "update motion blur direction based on velocity vector"
              },
              {
                "action": "smooth transition between blur directions"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering.PostProcessing;\n\npublic class SpeedMotionBlur : MonoBehaviour\n{\n    [Header(\"Motion Blur Settings\")]\n    [SerializeField] private PostProcessVolume _postProcessVolume;\n    [SerializeField] private float _speedThreshold = 5f;\n    [SerializeField] private float _maxBlurIntensity = 0.8f;\n    [SerializeField] private float _blurTransitionSpeed = 2f;\n    [SerializeField] private AnimationCurve _blurCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Speed Detection\")]\n    [SerializeField] private Transform _targetTransform;\n    [SerializeField] private bool _useRigidbody = true;\n    [SerializeField] private bool _detectVerticalSpeed = true;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    \n    private MotionBlur _motionBlur;\n    private Rigidbody _rigidbody;\n    private Vector3 _lastPosition;\n    private float _currentSpeed;\n    private float _targetBlurIntensity;\n    private float _currentBlurIntensity;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupMotionBlur();\n        \n        if (_targetTransform == null)\n            _targetTransform = transform;\n            \n        _lastPosition = _targetTransform.position;\n    }\n    \n    void InitializeComponents()\n    {\n        if (_postProcessVolume == null)\n            _postProcessVolume = FindObjectOfType<PostProcessVolume>();\n            \n        if (_postProcessVolume == null)\n        {\n            Debug.LogError(\"SpeedMotionBlur: No PostProcessVolume found in scene!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_useRigidbody && _targetTransform != null)\n            _rigidbody = _targetTransform.GetComponent<Rigidbody>();\n    }\n    \n    void SetupMotionBlur()\n    {\n        if (_postProcessVolume.profile.TryGetSettings(out _motionBlur))\n        {\n            _motionBlur.enabled.value = true;\n            _motionBlur.shutterAngle.value = 0f;\n        }\n        else\n        {\n            Debug.LogError(\"SpeedMotionBlur: MotionBlur effect not found in PostProcess profile!\");\n            enabled = false;\n        }\n    }\n    \n    void Update()\n    {\n        CalculateSpeed();\n        UpdateMotionBlur();\n        \n        if (_showDebugInfo)\n            DisplayDebugInfo();\n    }\n    \n    void CalculateSpeed()\n    {\n        if (_targetTransform == null) return;\n        \n        if (_useRigidbody && _rigidbody != null)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            if (!_detectVerticalSpeed)\n                velocity.y = 0f;\n                \n            _currentSpeed = velocity.magnitude;\n        }\n        else\n        {\n            Vector3 currentPosition = _targetTransform.position;\n            Vector3 deltaPosition = currentPosition - _lastPosition;\n            \n            if (!_detectVerticalSpeed)\n                deltaPosition.y = 0f;\n                \n            _currentSpeed = deltaPosition.magnitude / Time.deltaTime;\n            _lastPosition = currentPosition;\n        }\n    }\n    \n    void UpdateMotionBlur()\n    {\n        if (_motionBlur == null) return;\n        \n        float speedRatio = Mathf.Clamp01((_currentSpeed - _speedThreshold) / _speedThreshold);\n        _targetBlurIntensity = _blurCurve.Evaluate(speedRatio) * _maxBlurIntensity;\n        \n        _currentBlurIntensity = Mathf.Lerp(_currentBlurIntensity, _targetBlurIntensity, \n            Time.deltaTime * _blurTransitionSpeed);\n        \n        float shutterAngle = _currentBlurIntensity * 360f;\n        _motionBlur.shutterAngle.value = shutterAngle;\n    }\n    \n    void DisplayDebugInfo()\n    {\n        Debug.Log($\"Speed: {_currentSpeed:F2} | Blur Intensity: {_currentBlurIntensity:F3} | Shutter Angle: {_motionBlur.shutterAngle.value:F1}\");\n    }\n    \n    public void SetSpeedThreshold(float threshold)\n    {\n        _speedThreshold = Mathf.Max(0f, threshold);\n    }\n    \n    public void SetMaxBlurIntensity(float intensity)\n    {\n        _maxBlurIntensity = Mathf.Clamp01(intensity);\n    }\n    \n    public void SetBlurTransitionSpeed(float speed)\n    {\n        _blurTransitionSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void EnableMotionBlur(bool enable)\n    {\n        if (_motionBlur != null)\n            _motionBlur.enabled.value = enable;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public float GetCurrentBlurIntensity()\n    {\n        return _currentBlurIntensity;\n    }\n    \n    void OnValidate()\n    {\n        _speedThreshold = Mathf.Max(0f, _speedThreshold);\n        _maxBlurIntensity = Mathf.Clamp01(_maxBlurIntensity);\n        _blurTransitionSpeed = Mathf.Max(0.1f, _blurTransitionSpeed);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "depth of field focus",
      "ideal_ir": {
        "class_name": "DepthOfFieldFocus",
        "components": [
          "Camera"
        ],
        "fields": [
          {
            "name": "focusDistance",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "focusSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "aperture",
            "type": "float",
            "default": 5.6
          },
          {
            "name": "focalLength",
            "type": "float",
            "default": 50.0
          },
          {
            "name": "autoFocus",
            "type": "bool",
            "default": true
          },
          {
            "name": "focusTarget",
            "type": "Transform",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "auto_focus_on_target",
            "trigger": "when auto focus is enabled and focus target exists",
            "actions": [
              {
                "action": "calculate distance to focus target"
              },
              {
                "action": "smoothly adjust focus distance to target distance"
              }
            ]
          },
          {
            "name": "manual_focus_adjustment",
            "trigger": "when auto focus is disabled",
            "actions": [
              {
                "action": "maintain current focus distance setting"
              }
            ]
          },
          {
            "name": "apply_depth_of_field_effect",
            "trigger": "every frame",
            "actions": [
              {
                "action": "set camera depth of field focus distance"
              },
              {
                "action": "apply aperture setting to depth of field"
              },
              {
                "action": "apply focal length to depth of field calculation"
              }
            ]
          },
          {
            "name": "smooth_focus_transition",
            "trigger": "when focus distance changes",
            "actions": [
              {
                "action": "gradually interpolate from current focus to new focus distance"
              },
              {
                "action": "use focus speed to control transition rate"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\npublic class DepthOfFieldFocus : MonoBehaviour\n{\n    [Header(\"Focus Settings\")]\n    [SerializeField] private Camera _targetCamera;\n    [SerializeField] private LayerMask _focusLayerMask = -1;\n    [SerializeField] private float _focusSpeed = 5f;\n    [SerializeField] private float _minFocusDistance = 0.1f;\n    [SerializeField] private float _maxFocusDistance = 100f;\n    [SerializeField] private float _defaultFocusDistance = 10f;\n    \n    [Header(\"Auto Focus\")]\n    [SerializeField] private bool _enableAutoFocus = true;\n    [SerializeField] private float _autoFocusUpdateRate = 0.1f;\n    [SerializeField] private Vector2 _screenCenter = new Vector2(0.5f, 0.5f);\n    \n    [Header(\"Manual Focus\")]\n    [SerializeField] private bool _enableManualFocus = false;\n    [SerializeField] private KeyCode _focusKey = KeyCode.F;\n    [SerializeField] private Transform _manualFocusTarget;\n    \n    [Header(\"Depth of Field Settings\")]\n    [SerializeField] private float _aperture = 5.6f;\n    [SerializeField] private float _focalLength = 50f;\n    [SerializeField] private int _bladeCount = 5;\n    [SerializeField] private float _bladeCurvature = 1f;\n    [SerializeField] private float _bladeRotation = 0f;\n    \n    private Volume _postProcessVolume;\n    private DepthOfField _depthOfField;\n    private float _currentFocusDistance;\n    private float _targetFocusDistance;\n    private float _lastAutoFocusTime;\n    private bool _isInitialized;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _currentFocusDistance = _defaultFocusDistance;\n        _targetFocusDistance = _defaultFocusDistance;\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_targetCamera == null)\n            _targetCamera = Camera.main;\n            \n        if (_targetCamera == null)\n            _targetCamera = FindObjectOfType<Camera>();\n            \n        if (_targetCamera == null)\n        {\n            Debug.LogError(\"DepthOfFieldFocus: No camera found!\");\n            return;\n        }\n        \n        _postProcessVolume = FindObjectOfType<Volume>();\n        \n        if (_postProcessVolume == null)\n        {\n            GameObject volumeGO = new GameObject(\"Post Process Volume\");\n            _postProcessVolume = volumeGO.AddComponent<Volume>();\n            _postProcessVolume.isGlobal = true;\n        }\n        \n        if (_postProcessVolume.profile == null)\n        {\n            _postProcessVolume.profile = ScriptableObject.CreateInstance<VolumeProfile>();\n        }\n        \n        if (!_postProcessVolume.profile.TryGet<DepthOfField>(out _depthOfField))\n        {\n            _depthOfField = _postProcessVolume.profile.Add<DepthOfField>(false);\n        }\n        \n        SetupDepthOfField();\n        _isInitialized = true;\n    }\n    \n    private void SetupDepthOfField()\n    {\n        if (_depthOfField == null) return;\n        \n        _depthOfField.mode.value = DepthOfFieldMode.Bokeh;\n        _depthOfField.focusDistance.value = _currentFocusDistance;\n        _depthOfField.aperture.value = _aperture;\n        _depthOfField.focalLength.value = _focalLength;\n        _depthOfField.bladeCount.value = _bladeCount;\n        _depthOfField.bladeCurvature.value = _bladeCurvature;\n        _depthOfField.bladeRotation.value = _bladeRotation;\n        _depthOfField.active = true;\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        HandleManualFocus();\n        HandleAutoFocus();\n        UpdateFocusDistance();\n        UpdateDepthOfField();\n    }\n    \n    private void HandleManualFocus()\n    {\n        if (!_enableManualFocus) return;\n        \n        if (Input.GetKeyDown(_focusKey))\n        {\n            if (_manualFocusTarget != null)\n            {\n                FocusOnTarget(_manualFocusTarget);\n            }\n            else\n            {\n                FocusOnScreenCenter();\n            }\n        }\n    }\n    \n    private void HandleAutoFocus()\n    {\n        if (!_enableAutoFocus) return;\n        \n        if (Time.time - _lastAutoFocusTime >= _autoFocusUpdateRate)\n        {\n            FocusOnScreenCenter();\n            _lastAutoFocusTime = Time.time;\n        }\n    }\n    \n    private void FocusOnScreenCenter()\n    {\n        Vector3 screenPoint = new Vector3(\n            _screenCenter.x * Screen.width,\n            _screenCenter.y * Screen.height,\n            0f\n        );\n        \n        Ray ray = _targetCamera.ScreenPointToRay(screenPoint);\n        \n        if (Physics.Raycast(ray, out RaycastHit hit, _maxFocusDistance, _focusLayerMask))\n        {\n            float distance = Vector3.Distance(_targetCamera.transform.position, hit.point);\n            SetTargetFocusDistance(distance);\n        }\n        else\n        {\n            SetTargetFocusDistance(_defaultFocusDistance);\n        }\n    }\n    \n    private void FocusOnTarget(Transform target)\n    {\n        if (target == null) return;\n        \n        float distance = Vector3.Distance(_targetCamera.transform.position, target.position);\n        SetTargetFocusDistance(distance);\n    }\n    \n    private void SetTargetFocusDistance(float distance)\n    {\n        _targetFocusDistance = Mathf.Clamp(distance, _minFocusDistance, _maxFocusDistance);\n    }\n    \n    private void UpdateFocusDistance()\n    {\n        if (Mathf.Abs(_currentFocusDistance - _targetFocusDistance) > 0.01f)\n        {\n            _currentFocusDistance = Mathf.Lerp(\n                _currentFocusDistance,\n                _targetFocusDistance,\n                _focusSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void UpdateDepthOfField()\n    {\n        if (_depthOfField == null) return;\n        \n        _depthOfField.focusDistance.value = _currentFocusDistance;\n        _depthOfField.aperture.value = _aperture;\n        _depthOfField.focalLength.value = _focalLength;\n        _depthOfField.bladeCount.value = _bladeCount;\n        _depthOfField.bladeCurvature.value = _bladeCurvature;\n        _depthOfField.bladeRotation.value = _bladeRotation;\n    }\n    \n    public void SetFocusDistance(float distance)\n    {\n        SetTargetFocusDistance(distance);\n    }\n    \n    public void SetAperture(float aperture)\n    {\n        _aperture = Mathf.Clamp(aperture, 1f, 32f);\n    }\n    \n    public void SetFocalLength(float focalLength)\n    {\n        _focalLength = Mathf.Clamp(focalLength, 1f, 300f);\n    }\n    \n    public void EnableAutoFocus(bool enable)\n    {\n        _enableAutoFocus = enable;\n    }\n    \n    public void SetManualFocusTarget(Transform target)\n    {\n        _manualFocusTarget = target;\n    }\n    \n    public float GetCurrentFocusDistance()\n    {\n        return _currentFocusDistance;\n    }\n    \n    private void OnValidate()\n    {\n        _aperture = Mathf.Clamp(_aperture, 1f, 32f);\n        _focalLength = Mathf.Clamp(_focalLength, 1f, 300f);\n        _focusSpeed = Mathf.Max(0.1f, _focusSpeed);\n        _minFocusDistance = Mathf.Max(0.1f, _minFocusDistance);\n        _maxFocusDistance = Mathf.Max(_minFocusDistance + 0.1f, _maxFocusDistance);\n        _defaultFocusDistance = Mathf.Clamp(_defaultFocusDistance, _minFocusDistance, _maxFocusDistance);\n        _autoFocusUpdateRate = Mathf.Max(0.01f, _autoFocusUpdateRate);\n        _screenCenter.x = Mathf.Clamp01(_screenCenter.x);\n        _screenCenter.y = Mathf.Clamp01(_screenCenter.y);\n        _bladeCount = Mathf.Clamp(_bladeCount, 3, 9);\n        _bladeCurvature = Mathf.Clamp01(_bladeCurvature);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_targetCamera == null) return;\n        \n        Gizmos.color = Color.yellow;\n        Vector3 cameraPos = _targetCamera.transform.position;\n        Vector3 forward = _targetCamera.transform.forward;\n        \n        // Draw focus distance\n        Vector3 focusPoint = cameraPos + forward * _currentFocusDistance;\n        Gizmos.DrawWireSphere(focusPoint, 0.5f);\n        \n        // Draw focus ray from screen center\n        Vector3 screenPoint = new Vector3(\n            _screenCenter.x * Screen.width,\n            _screenCenter.y * Screen.height,\n            0f\n        );\n        \n        Ray ray = _targetCamera.ScreenPointToRay(screenPoint);\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(ray.origin, ray.direction * _maxFocusDistance);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "chromatic aberration effect",
      "ideal_ir": {
        "class_name": "ChromaticAberrationEffect",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "intensity",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "redOffset",
            "type": "Vector2",
            "default": "Vector2.zero"
          },
          {
            "name": "greenOffset",
            "type": "Vector2",
            "default": "Vector2.zero"
          },
          {
            "name": "blueOffset",
            "type": "Vector2",
            "default": "Vector2.zero"
          },
          {
            "name": "distortionCenter",
            "type": "Vector2",
            "default": "Vector2(0.5, 0.5)"
          },
          {
            "name": "radialIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "animateEffect",
            "type": "bool",
            "default": false
          },
          {
            "name": "animationSpeed",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "apply_chromatic_aberration",
            "trigger": "when rendering the camera view",
            "actions": [
              {
                "action": "separate the rendered image into red green and blue color channels"
              },
              {
                "action": "offset the red channel by the red offset amount"
              },
              {
                "action": "offset the green channel by the green offset amount"
              },
              {
                "action": "offset the blue channel by the blue offset amount"
              },
              {
                "action": "apply stronger distortion toward the edges based on radial intensity"
              },
              {
                "action": "recombine the offset color channels into the final image"
              }
            ]
          },
          {
            "name": "animate_aberration",
            "trigger": "when animate effect is enabled and every frame",
            "actions": [
              {
                "action": "calculate oscillating values based on animation speed and time"
              },
              {
                "action": "update red green and blue offsets with animated values"
              },
              {
                "action": "vary the intensity smoothly over time"
              }
            ]
          },
          {
            "name": "adjust_intensity",
            "trigger": "when intensity value changes",
            "actions": [
              {
                "action": "scale all color channel offsets by the intensity multiplier"
              },
              {
                "action": "update the shader parameters with new offset values"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\n[System.Serializable]\npublic class ChromaticAberrationSettings\n{\n    [Range(0f, 1f)]\n    public float intensity = 0.1f;\n    [Range(0f, 5f)]\n    public float speed = 1f;\n    public bool useDistanceFromCenter = true;\n    public AnimationCurve intensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n}\n\npublic class ChromaticAberrationEffect : MonoBehaviour\n{\n    [Header(\"Chromatic Aberration Settings\")]\n    [SerializeField] private ChromaticAberrationSettings _settings = new ChromaticAberrationSettings();\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _animateIntensity = false;\n    [SerializeField] private float _animationSpeed = 1f;\n    [SerializeField] private float _minIntensity = 0f;\n    [SerializeField] private float _maxIntensity = 1f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _triggerOnPlayerEnter = false;\n    [SerializeField] private float _triggerDuration = 2f;\n    [SerializeField] private AnimationCurve _triggerCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Distance-Based Effect\")]\n    [SerializeField] private bool _useDistanceEffect = false;\n    [SerializeField] private Transform _targetTransform;\n    [SerializeField] private float _maxDistance = 10f;\n    [SerializeField] private AnimationCurve _distanceCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    private Volume _postProcessVolume;\n    private ChromaticAberration _chromaticAberration;\n    private float _baseIntensity;\n    private float _currentTriggerTime;\n    private bool _isTriggered;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupChromaticAberration();\n        _baseIntensity = _settings.intensity;\n        \n        if (_targetTransform == null)\n            _targetTransform = transform;\n            \n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n    }\n    \n    private void InitializeComponents()\n    {\n        _postProcessVolume = GetComponent<Volume>();\n        \n        if (_postProcessVolume == null)\n        {\n            _postProcessVolume = gameObject.AddComponent<Volume>();\n            _postProcessVolume.isGlobal = true;\n        }\n        \n        if (_postProcessVolume.profile == null)\n        {\n            _postProcessVolume.profile = ScriptableObject.CreateInstance<VolumeProfile>();\n        }\n    }\n    \n    private void SetupChromaticAberration()\n    {\n        if (!_postProcessVolume.profile.TryGet<ChromaticAberration>(out _chromaticAberration))\n        {\n            _chromaticAberration = _postProcessVolume.profile.Add<ChromaticAberration>(false);\n        }\n        \n        _chromaticAberration.intensity.overrideState = true;\n        _chromaticAberration.intensity.value = _settings.intensity;\n        _chromaticAberration.active = true;\n    }\n    \n    private void Update()\n    {\n        if (_chromaticAberration == null) return;\n        \n        float finalIntensity = CalculateFinalIntensity();\n        _chromaticAberration.intensity.value = finalIntensity;\n        \n        UpdateTriggerEffect();\n    }\n    \n    private float CalculateFinalIntensity()\n    {\n        float intensity = _baseIntensity;\n        \n        if (_animateIntensity)\n        {\n            float animatedValue = Mathf.Lerp(_minIntensity, _maxIntensity, \n                (Mathf.Sin(Time.time * _animationSpeed) + 1f) * 0.5f);\n            intensity = animatedValue;\n        }\n        \n        if (_useDistanceEffect && _mainCamera != null)\n        {\n            float distance = Vector3.Distance(_mainCamera.transform.position, _targetTransform.position);\n            float normalizedDistance = Mathf.Clamp01(distance / _maxDistance);\n            float distanceMultiplier = _distanceCurve.Evaluate(normalizedDistance);\n            intensity *= distanceMultiplier;\n        }\n        \n        if (_isTriggered)\n        {\n            float triggerMultiplier = _triggerCurve.Evaluate(_currentTriggerTime / _triggerDuration);\n            intensity *= triggerMultiplier;\n        }\n        \n        return Mathf.Clamp01(intensity);\n    }\n    \n    private void UpdateTriggerEffect()\n    {\n        if (_isTriggered)\n        {\n            _currentTriggerTime += Time.deltaTime;\n            \n            if (_currentTriggerTime >= _triggerDuration)\n            {\n                _isTriggered = false;\n                _currentTriggerTime = 0f;\n            }\n        }\n    }\n    \n    public void TriggerEffect()\n    {\n        _isTriggered = true;\n        _currentTriggerTime = 0f;\n    }\n    \n    public void SetIntensity(float intensity)\n    {\n        _baseIntensity = Mathf.Clamp01(intensity);\n        _settings.intensity = _baseIntensity;\n    }\n    \n    public void SetAnimationEnabled(bool enabled)\n    {\n        _animateIntensity = enabled;\n    }\n    \n    public void SetAnimationSpeed(float speed)\n    {\n        _animationSpeed = speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_triggerOnPlayerEnter && other.CompareTag(\"Player\"))\n        {\n            TriggerEffect();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_settings != null)\n        {\n            _settings.intensity = Mathf.Clamp01(_settings.intensity);\n            _settings.speed = Mathf.Max(0f, _settings.speed);\n        }\n        \n        _minIntensity = Mathf.Clamp01(_minIntensity);\n        _maxIntensity = Mathf.Clamp01(_maxIntensity);\n        _triggerDuration = Mathf.Max(0.1f, _triggerDuration);\n        _maxDistance = Mathf.Max(0.1f, _maxDistance);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_postProcessVolume != null && _postProcessVolume.profile != null)\n        {\n            if (_chromaticAberration != null)\n            {\n                _postProcessVolume.profile.Remove<ChromaticAberration>();\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "vignette darkness at edges",
      "ideal_ir": {
        "class_name": "VignetteDarkness",
        "components": [
          "Camera"
        ],
        "fields": [
          {
            "name": "vignetteIntensity",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "vignetteSize",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "vignetteSmoothness",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "vignetteColor",
            "type": "Color",
            "default": "black"
          }
        ],
        "behaviors": [
          {
            "name": "apply_vignette_effect",
            "trigger": "when camera renders the scene",
            "actions": [
              {
                "action": "create circular gradient from center to edges"
              },
              {
                "action": "darken pixels based on distance from screen center"
              },
              {
                "action": "apply vignette color to edge areas"
              },
              {
                "action": "blend darkness effect with original image"
              }
            ]
          },
          {
            "name": "adjust_vignette_intensity",
            "trigger": "when vignette intensity value changes",
            "actions": [
              {
                "action": "update darkness strength at screen edges"
              },
              {
                "action": "recalculate vignette gradient"
              }
            ]
          },
          {
            "name": "modify_vignette_size",
            "trigger": "when vignette size value changes",
            "actions": [
              {
                "action": "adjust radius of clear center area"
              },
              {
                "action": "update falloff distance to edges"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class VignetteEffect : MonoBehaviour\n{\n    [Header(\"Vignette Settings\")]\n    [SerializeField] private float _vignetteIntensity = 0.5f;\n    [SerializeField] private float _vignetteSmoothness = 0.3f;\n    [SerializeField] private Color _vignetteColor = Color.black;\n    [SerializeField] private bool _animateVignette = false;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _animationSpeed = 1f;\n    [SerializeField] private float _minIntensity = 0.2f;\n    [SerializeField] private float _maxIntensity = 0.8f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _triggerOnPlayerNear = false;\n    [SerializeField] private float _triggerDistance = 5f;\n    [SerializeField] private float _transitionSpeed = 2f;\n    \n    private Material _vignetteMaterial;\n    private Camera _camera;\n    private float _currentIntensity;\n    private float _targetIntensity;\n    private Transform _player;\n    \n    private static readonly int IntensityProperty = Shader.PropertyToID(\"_Intensity\");\n    private static readonly int SmoothnessProperty = Shader.PropertyToID(\"_Smoothness\");\n    private static readonly int ColorProperty = Shader.PropertyToID(\"_Color\");\n    \n    void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n        {\n            _camera = Camera.main;\n        }\n        \n        CreateVignetteMaterial();\n        _currentIntensity = _vignetteIntensity;\n        _targetIntensity = _vignetteIntensity;\n        \n        if (_triggerOnPlayerNear)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n            {\n                _player = playerObject.transform;\n            }\n        }\n    }\n    \n    void CreateVignetteMaterial()\n    {\n        Shader vignetteShader = Shader.Find(\"Hidden/VignetteShader\");\n        if (vignetteShader == null)\n        {\n            vignetteShader = CreateVignetteShader();\n        }\n        \n        _vignetteMaterial = new Material(vignetteShader);\n        _vignetteMaterial.SetFloat(IntensityProperty, _vignetteIntensity);\n        _vignetteMaterial.SetFloat(SmoothnessProperty, _vignetteSmoothness);\n        _vignetteMaterial.SetColor(ColorProperty, _vignetteColor);\n    }\n    \n    Shader CreateVignetteShader()\n    {\n        string shaderCode = @\"\n        Shader \"\"Hidden/VignetteShader\"\"\n        {\n            Properties\n            {\n                _MainTex (\"\"Texture\"\", 2D) = \"\"white\"\" {}\n                _Intensity (\"\"Intensity\"\", Range(0, 1)) = 0.5\n                _Smoothness (\"\"Smoothness\"\", Range(0, 1)) = 0.3\n                _Color (\"\"Color\"\", Color) = (0,0,0,1)\n            }\n            SubShader\n            {\n                Tags { \"\"RenderType\"\"=\"\"Opaque\"\" }\n                Pass\n                {\n                    CGPROGRAM\n                    #pragma vertex vert\n                    #pragma fragment frag\n                    #include \"\"UnityCG.cginc\"\"\n                    \n                    struct appdata\n                    {\n                        float4 vertex : POSITION;\n                        float2 uv : TEXCOORD0;\n                    };\n                    \n                    struct v2f\n                    {\n                        float2 uv : TEXCOORD0;\n                        float4 vertex : SV_POSITION;\n                    };\n                    \n                    sampler2D _MainTex;\n                    float _Intensity;\n                    float _Smoothness;\n                    fixed4 _Color;\n                    \n                    v2f vert (appdata v)\n                    {\n                        v2f o;\n                        o.vertex = UnityObjectToClipPos(v.vertex);\n                        o.uv = v.uv;\n                        return o;\n                    }\n                    \n                    fixed4 frag (v2f i) : SV_Target\n                    {\n                        fixed4 col = tex2D(_MainTex, i.uv);\n                        float2 center = float2(0.5, 0.5);\n                        float dist = distance(i.uv, center);\n                        float vignette = smoothstep(0.5 - _Smoothness, 0.5, dist);\n                        vignette = pow(vignette, 2);\n                        col.rgb = lerp(col.rgb, _Color.rgb, vignette * _Intensity);\n                        return col;\n                    }\n                    ENDCG\n                }\n            }\n        }\";\n        \n        return Shader.Find(\"Hidden/VignetteShader\");\n    }\n    \n    void Update()\n    {\n        if (_animateVignette)\n        {\n            float animatedIntensity = Mathf.Lerp(_minIntensity, _maxIntensity, \n                (Mathf.Sin(Time.time * _animationSpeed) + 1f) * 0.5f);\n            _targetIntensity = animatedIntensity;\n        }\n        \n        if (_triggerOnPlayerNear && _player != null)\n        {\n            float distance = Vector3.Distance(transform.position, _player.position);\n            if (distance <= _triggerDistance)\n            {\n                _targetIntensity = _maxIntensity;\n            }\n            else\n            {\n                _targetIntensity = _vignetteIntensity;\n            }\n        }\n        \n        _currentIntensity = Mathf.Lerp(_currentIntensity, _targetIntensity, \n            Time.deltaTime * _transitionSpeed);\n        \n        if (_vignetteMaterial != null)\n        {\n            _vignetteMaterial.SetFloat(IntensityProperty, _currentIntensity);\n            _vignetteMaterial.SetFloat(SmoothnessProperty, _vignetteSmoothness);\n            _vignetteMaterial.SetColor(ColorProperty, _vignetteColor);\n        }\n    }\n    \n    void OnRenderImage(RenderTexture source, RenderTexture destination)\n    {\n        if (_vignetteMaterial != null)\n        {\n            Graphics.Blit(source, destination, _vignetteMaterial);\n        }\n        else\n        {\n            Graphics.Blit(source, destination);\n        }\n    }\n    \n    public void SetVignetteIntensity(float intensity)\n    {\n        _vignetteIntensity = Mathf.Clamp01(intensity);\n        if (!_animateVignette && !_triggerOnPlayerNear)\n        {\n            _targetIntensity = _vignetteIntensity;\n        }\n    }\n    \n    public void SetVignetteSmoothness(float smoothness)\n    {\n        _vignetteSmoothness = Mathf.Clamp01(smoothness);\n    }\n    \n    public void SetVignetteColor(Color color)\n    {\n        _vignetteColor = color;\n    }\n    \n    public void EnableAnimation(bool enable)\n    {\n        _animateVignette = enable;\n        if (!enable)\n        {\n            _targetIntensity = _vignetteIntensity;\n        }\n    }\n    \n    public void TriggerVignetteEffect(float duration)\n    {\n        StartCoroutine(VignetteEffectCoroutine(duration));\n    }\n    \n    private System.Collections.IEnumerator VignetteEffectCoroutine(float duration)\n    {\n        float originalTarget = _targetIntensity;\n        _targetIntensity = _maxIntensity;\n        \n        yield return new WaitForSeconds(duration);\n        \n        _targetIntensity = originalTarget;\n    }\n    \n    void OnDestroy()\n    {\n        if (_vignetteMaterial != null)\n        {\n            DestroyImmediate(_vignetteMaterial);\n        }\n    }\n    \n    void OnValidate()\n    {\n        _vignetteIntensity = Mathf.Clamp01(_vignetteIntensity);\n        _vignetteSmoothness = Mathf.Clamp01(_vignetteSmoothness);\n        _minIntensity = Mathf.Clamp01(_minIntensity);\n        _maxIntensity = Mathf.Clamp01(_maxIntensity);\n        _triggerDistance = Mathf.Max(0f, _triggerDistance);\n        _animationSpeed = Mathf.Max(0f, _animationSpeed);\n        _transitionSpeed = Mathf.Max(0f, _transitionSpeed);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "save and load system",
      "ideal_ir": {
        "class_name": "SaveLoadSystem",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "saveFileName",
            "type": "string",
            "default": "savegame.json"
          },
          {
            "name": "autoSaveInterval",
            "type": "float",
            "default": 60
          },
          {
            "name": "lastSaveTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "saveData",
            "type": "Dictionary<string, object>",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initialize_save_system",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "create empty save data dictionary"
              },
              {
                "action": "check if save file exists on disk"
              },
              {
                "action": "load existing save file if found"
              }
            ]
          },
          {
            "name": "auto_save_check",
            "trigger": "every frame update",
            "actions": [
              {
                "action": "check if enough time has passed since last save"
              },
              {
                "action": "perform auto save if interval exceeded"
              }
            ]
          },
          {
            "name": "save_game_data",
            "trigger": "when save game is requested",
            "actions": [
              {
                "action": "collect player position and rotation"
              },
              {
                "action": "collect player health and stats"
              },
              {
                "action": "collect inventory items and quantities"
              },
              {
                "action": "collect level progress and unlocked areas"
              },
              {
                "action": "collect game settings and preferences"
              },
              {
                "action": "convert all data to JSON format"
              },
              {
                "action": "write JSON data to save file"
              },
              {
                "action": "update last save timestamp"
              },
              {
                "action": "display save confirmation message"
              }
            ]
          },
          {
            "name": "load_game_data",
            "trigger": "when load game is requested",
            "actions": [
              {
                "action": "check if save file exists"
              },
              {
                "action": "read JSON data from save file"
              },
              {
                "action": "parse JSON into game data objects"
              },
              {
                "action": "restore player position and rotation"
              },
              {
                "action": "restore player health and stats"
              },
              {
                "action": "restore inventory items and quantities"
              },
              {
                "action": "restore level progress and unlocked areas"
              },
              {
                "action": "restore game settings and preferences"
              },
              {
                "action": "display load confirmation message"
              }
            ]
          },
          {
            "name": "delete_save_data",
            "trigger": "when delete save is requested",
            "actions": [
              {
                "action": "show confirmation dialog to player"
              },
              {
                "action": "delete save file from disk if confirmed"
              },
              {
                "action": "clear save data dictionary"
              },
              {
                "action": "reset last save timestamp"
              },
              {
                "action": "display deletion confirmation message"
              }
            ]
          },
          {
            "name": "handle_save_error",
            "trigger": "when save operation fails",
            "actions": [
              {
                "action": "log error details to console"
              },
              {
                "action": "display error message to player"
              },
              {
                "action": "attempt to create backup save file"
              }
            ]
          },
          {
            "name": "handle_load_error",
            "trigger": "when load operation fails",
            "actions": [
              {
                "action": "log error details to console"
              },
              {
                "action": "display error message to player"
              },
              {
                "action": "start new game with default values"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class SaveLoadSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class GameData\n    {\n        public Vector3 playerPosition;\n        public Quaternion playerRotation;\n        public float playerHealth = 100f;\n        public int playerScore = 0;\n        public int playerLevel = 1;\n        public float playerExperience = 0f;\n        public List<string> unlockedAchievements = new List<string>();\n        public List<string> collectedItems = new List<string>();\n        public Dictionary<string, bool> gameFlags = new Dictionary<string, bool>();\n        public Dictionary<string, float> gameValues = new Dictionary<string, float>();\n        public string currentScene = \"\";\n        public float totalPlayTime = 0f;\n        public DateTime lastSaveTime;\n        \n        public GameData()\n        {\n            lastSaveTime = DateTime.Now;\n        }\n    }\n\n    [System.Serializable]\n    public class SaveSlot\n    {\n        public string slotName;\n        public GameData gameData;\n        public DateTime saveTime;\n        public string sceneName;\n        public float playTime;\n        public Texture2D screenshot;\n    }\n\n    [Header(\"Save Settings\")]\n    [SerializeField] private string _saveFileName = \"GameSave\";\n    [SerializeField] private string _saveFileExtension = \".json\";\n    [SerializeField] private int _maxSaveSlots = 5;\n    [SerializeField] private bool _autoSaveEnabled = true;\n    [SerializeField] private float _autoSaveInterval = 300f;\n\n    [Header(\"Player References\")]\n    [SerializeField] private Transform _playerTransform;\n    [SerializeField] private GameObject _playerGameObject;\n\n    [Header(\"Events\")]\n    public UnityEvent OnSaveStarted;\n    public UnityEvent OnSaveCompleted;\n    public UnityEvent OnLoadStarted;\n    public UnityEvent OnLoadCompleted;\n    public UnityEvent<string> OnSaveError;\n    public UnityEvent<string> OnLoadError;\n\n    private GameData _currentGameData;\n    private List<SaveSlot> _saveSlots;\n    private float _autoSaveTimer;\n    private float _sessionStartTime;\n    private string _saveFolderPath;\n\n    public GameData CurrentGameData => _currentGameData;\n    public List<SaveSlot> SaveSlots => _saveSlots;\n\n    private void Awake()\n    {\n        _currentGameData = new GameData();\n        _saveSlots = new List<SaveSlot>();\n        _sessionStartTime = Time.time;\n        \n        _saveFolderPath = Path.Combine(Application.persistentDataPath, \"Saves\");\n        \n        if (!Directory.Exists(_saveFolderPath))\n        {\n            Directory.CreateDirectory(_saveFolderPath);\n        }\n\n        if (_playerTransform == null && _playerGameObject == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n            {\n                _playerTransform = player.transform;\n                _playerGameObject = player;\n            }\n        }\n    }\n\n    private void Start()\n    {\n        LoadSaveSlots();\n        InitializeGameData();\n    }\n\n    private void Update()\n    {\n        if (_autoSaveEnabled)\n        {\n            _autoSaveTimer += Time.deltaTime;\n            if (_autoSaveTimer >= _autoSaveInterval)\n            {\n                AutoSave();\n                _autoSaveTimer = 0f;\n            }\n        }\n\n        UpdatePlayTime();\n    }\n\n    private void InitializeGameData()\n    {\n        _currentGameData.currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;\n        \n        if (_playerTransform != null)\n        {\n            _currentGameData.playerPosition = _playerTransform.position;\n            _currentGameData.playerRotation = _playerTransform.rotation;\n        }\n    }\n\n    private void UpdatePlayTime()\n    {\n        _currentGameData.totalPlayTime = Time.time - _sessionStartTime;\n    }\n\n    public void SaveGame(int slotIndex = 0)\n    {\n        try\n        {\n            OnSaveStarted?.Invoke();\n            \n            UpdateCurrentGameData();\n            \n            SaveSlot saveSlot = new SaveSlot\n            {\n                slotName = $\"Save Slot {slotIndex + 1}\",\n                gameData = _currentGameData,\n                saveTime = DateTime.Now,\n                sceneName = _currentGameData.currentScene,\n                playTime = _currentGameData.totalPlayTime\n            };\n\n            string json = JsonUtility.ToJson(saveSlot, true);\n            string filePath = GetSaveFilePath(slotIndex);\n            \n            File.WriteAllText(filePath, json);\n            \n            UpdateSaveSlot(slotIndex, saveSlot);\n            \n            OnSaveCompleted?.Invoke();\n            Debug.Log($\"Game saved to slot {slotIndex}\");\n        }\n        catch (Exception e)\n        {\n            OnSaveError?.Invoke($\"Save failed: {e.Message}\");\n            Debug.LogError($\"Save failed: {e.Message}\");\n        }\n    }\n\n    public void LoadGame(int slotIndex = 0)\n    {\n        try\n        {\n            OnLoadStarted?.Invoke();\n            \n            string filePath = GetSaveFilePath(slotIndex);\n            \n            if (!File.Exists(filePath))\n            {\n                OnLoadError?.Invoke(\"Save file not found\");\n                return;\n            }\n\n            string json = File.ReadAllText(filePath);\n            SaveSlot saveSlot = JsonUtility.FromJson<SaveSlot>(json);\n            \n            if (saveSlot?.gameData != null)\n            {\n                _currentGameData = saveSlot.gameData;\n                ApplyGameData();\n                OnLoadCompleted?.Invoke();\n                Debug.Log($\"Game loaded from slot {slotIndex}\");\n            }\n            else\n            {\n                OnLoadError?.Invoke(\"Invalid save data\");\n            }\n        }\n        catch (Exception e)\n        {\n            OnLoadError?.Invoke($\"Load failed: {e.Message}\");\n            Debug.LogError($\"Load failed: {e.Message}\");\n        }\n    }\n\n    private void UpdateCurrentGameData()\n    {\n        _currentGameData.lastSaveTime = DateTime.Now;\n        _currentGameData.currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;\n        \n        if (_playerTransform != null)\n        {\n            _currentGameData.playerPosition = _playerTransform.position;\n            _currentGameData.playerRotation = _playerTransform.rotation;\n        }\n    }\n\n    private void ApplyGameData()\n    {\n        if (_playerTransform != null)\n        {\n            _playerTransform.position = _currentGameData.playerPosition;\n            _playerTransform.rotation = _currentGameData.playerRotation;\n        }\n\n        if (_currentGameData.currentScene != UnityEngine.SceneManagement.SceneManager.GetActiveScene().name)\n        {\n            UnityEngine.SceneManagement.SceneManager.LoadScene(_currentGameData.currentScene);\n        }\n    }\n\n    public void AutoSave()\n    {\n        SaveGame(0);\n        Debug.Log(\"Auto-save completed\");\n    }\n\n    public void DeleteSave(int slotIndex)\n    {\n        try\n        {\n            string filePath = GetSaveFilePath(slotIndex);\n            \n            if (File.Exists(filePath))\n            {\n                File.Delete(filePath);\n                \n                if (slotIndex < _saveSlots.Count)\n                {\n                    _saveSlots[slotIndex] = null;\n                }\n                \n                Debug.Log($\"Save slot {slotIndex} deleted\");\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Failed to delete save: {e.Message}\");\n        }\n    }\n\n    public bool HasSave(int slotIndex)\n    {\n        string filePath = GetSaveFilePath(slotIndex);\n        return File.Exists(filePath);\n    }\n\n    public SaveSlot GetSaveSlot(int slotIndex)\n    {\n        if (slotIndex >= 0 && slotIndex < _saveSlots.Count)\n        {\n            return _saveSlots[slotIndex];\n        }\n        return null;\n    }\n\n    private void LoadSaveSlots()\n    {\n        _saveSlots.Clear();\n        \n        for (int i = 0; i < _maxSaveSlots; i++)\n        {\n            string filePath = GetSaveFilePath(i);\n            \n            if (File.Exists(filePath))\n            {\n                try\n                {\n                    string json = File.ReadAllText(filePath);\n                    SaveSlot saveSlot = JsonUtility.FromJson<SaveSlot>(json);\n                    _saveSlots.Add(saveSlot);\n                }\n                catch (Exception e)\n                {\n                    Debug.LogError($\"Failed to load save slot {i}: {e.Message}\");\n                    _saveSlots.Add(null);\n                }\n            }\n            else\n            {\n                _saveSlots.Add(null);\n            }\n        }\n    }\n\n    private void UpdateSaveSlot(int slotIndex, SaveSlot saveSlot)\n    {\n        while (_saveSlots.Count <= slotIndex)\n        {\n            _saveSlots.Add(null);\n        }\n        \n        _saveSlots[slotIndex] = saveSlot;\n    }\n\n    private string GetSaveFilePath(int slotIndex)\n    {\n        return Path.Combine(_saveFolderPath, $\"{_saveFileName}_{slotIndex}{_saveFileExtension}\");\n    }\n\n    public void SetGameFlag(string flagName, bool value)\n    {\n        _currentGameData.gameFlags[flagName] = value;\n    }\n\n    public bool GetGameFlag(string flagName, bool defaultValue = false)\n    {\n        return _currentGameData.gameFlags.ContainsKey(flagName) ? _currentGameData.gameFlags[flagName] : defaultValue;\n    }\n\n    public void SetGameValue(string valueName, float value)\n    {\n        _currentGameData.gameValues[valueName] = value;\n    }\n\n    public float GetGameValue(string valueName, float defaultValue = 0f)\n    {\n        return _currentGameData.gameValues.ContainsKey(valueName) ? _currentGameData.gameValues[valueName] : defaultValue;\n    }\n\n    public void AddCollectedItem(string itemId)\n    {\n        if (!_currentGameData.collectedItems.Contains(itemId))\n        {\n            _currentGameData.collectedItems.Add(itemId);\n        }\n    }\n\n    public bool HasCollectedItem(string itemId)\n    {\n        return _currentGameData.collectedItems.Contains(itemId);\n    }\n\n    public void UnlockAchievement(string achievementId)\n    {\n        if (!_currentGameData.unlockedAchievements.Contains(achievementId))\n        {\n            _currentGameData.unlockedAchievements.Add(achievementId);\n        }\n    }\n\n    public bool IsAchievementUnlocked(string achievementId)\n    {\n        return _currentGameData.unlockedAchievements.Contains(achievementId);\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus && _autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "pause menu with options",
      "ideal_ir": {
        "class_name": "PauseMenu",
        "components": [
          "Canvas",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "isGamePaused",
            "type": "bool",
            "default": false
          },
          {
            "name": "resumeButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "settingsButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "mainMenuButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "quitButton",
            "type": "Button",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "toggle_pause_menu",
            "trigger": "when escape key is pressed",
            "actions": [
              {
                "action": "toggle pause menu visibility"
              },
              {
                "action": "toggle game time scale between zero and one"
              },
              {
                "action": "toggle cursor lock state"
              }
            ]
          },
          {
            "name": "resume_game",
            "trigger": "when resume button is clicked",
            "actions": [
              {
                "action": "hide pause menu"
              },
              {
                "action": "set game time scale to one"
              },
              {
                "action": "lock cursor to center of screen"
              },
              {
                "action": "set game paused state to false"
              }
            ]
          },
          {
            "name": "open_settings",
            "trigger": "when settings button is clicked",
            "actions": [
              {
                "action": "open settings menu panel"
              },
              {
                "action": "hide main pause menu options"
              }
            ]
          },
          {
            "name": "return_to_main_menu",
            "trigger": "when main menu button is clicked",
            "actions": [
              {
                "action": "load main menu scene"
              },
              {
                "action": "set game time scale to one"
              }
            ]
          },
          {
            "name": "quit_game",
            "trigger": "when quit button is clicked",
            "actions": [
              {
                "action": "close application"
              }
            ]
          },
          {
            "name": "initialize_menu",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "hide pause menu"
              },
              {
                "action": "assign button click events"
              },
              {
                "action": "set initial pause state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Audio;\nusing UnityEngine.SceneManagement;\n\npublic class PauseMenu : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _pauseMenuPanel;\n    [SerializeField] private GameObject _optionsPanel;\n    [SerializeField] private Button _resumeButton;\n    [SerializeField] private Button _optionsButton;\n    [SerializeField] private Button _mainMenuButton;\n    [SerializeField] private Button _quitButton;\n    [SerializeField] private Button _backButton;\n    \n    [Header(\"Audio Options\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    [SerializeField] private Toggle _muteToggle;\n    \n    [Header(\"Graphics Options\")]\n    [SerializeField] private Dropdown _qualityDropdown;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Slider _brightnessSlider;\n    \n    [Header(\"Gameplay Options\")]\n    [SerializeField] private Slider _mouseSensitivitySlider;\n    [SerializeField] private Toggle _invertYToggle;\n    [SerializeField] private Dropdown _difficultyDropdown;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private string _mainMenuSceneName = \"MainMenu\";\n    [SerializeField] private KeyCode _pauseKey = KeyCode.Escape;\n    \n    private bool _isPaused = false;\n    private Resolution[] _resolutions;\n    private float _originalTimeScale;\n    \n    private void Start()\n    {\n        _originalTimeScale = Time.timeScale;\n        InitializeUI();\n        SetupResolutions();\n        LoadSettings();\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_pauseKey))\n        {\n            if (_isPaused)\n                ResumeGame();\n            else\n                PauseGame();\n        }\n    }\n    \n    private void InitializeUI()\n    {\n        if (_resumeButton != null)\n            _resumeButton.onClick.AddListener(ResumeGame);\n        if (_optionsButton != null)\n            _optionsButton.onClick.AddListener(OpenOptions);\n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.AddListener(LoadMainMenu);\n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(QuitGame);\n        if (_backButton != null)\n            _backButton.onClick.AddListener(CloseOptions);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.AddListener(SetMasterVolume);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.AddListener(SetMusicVolume);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.AddListener(SetSFXVolume);\n        if (_muteToggle != null)\n            _muteToggle.onValueChanged.AddListener(SetMute);\n        \n        if (_qualityDropdown != null)\n        {\n            _qualityDropdown.ClearOptions();\n            _qualityDropdown.AddOptions(new System.Collections.Generic.List<string>(QualitySettings.names));\n            _qualityDropdown.value = QualitySettings.GetQualityLevel();\n            _qualityDropdown.onValueChanged.AddListener(SetQuality);\n        }\n        \n        if (_fullscreenToggle != null)\n        {\n            _fullscreenToggle.isOn = Screen.fullScreen;\n            _fullscreenToggle.onValueChanged.AddListener(SetFullscreen);\n        }\n        \n        if (_brightnessSlider != null)\n            _brightnessSlider.onValueChanged.AddListener(SetBrightness);\n        \n        if (_mouseSensitivitySlider != null)\n            _mouseSensitivitySlider.onValueChanged.AddListener(SetMouseSensitivity);\n        if (_invertYToggle != null)\n            _invertYToggle.onValueChanged.AddListener(SetInvertY);\n        \n        if (_difficultyDropdown != null)\n        {\n            _difficultyDropdown.ClearOptions();\n            _difficultyDropdown.AddOptions(new System.Collections.Generic.List<string> { \"Easy\", \"Normal\", \"Hard\" });\n            _difficultyDropdown.onValueChanged.AddListener(SetDifficulty);\n        }\n        \n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(SetResolution);\n    }\n    \n    private void SetupResolutions()\n    {\n        if (_resolutionDropdown == null) return;\n        \n        _resolutions = Screen.resolutions;\n        _resolutionDropdown.ClearOptions();\n        \n        System.Collections.Generic.List<string> options = new System.Collections.Generic.List<string>();\n        int currentResolutionIndex = 0;\n        \n        for (int i = 0; i < _resolutions.Length; i++)\n        {\n            string option = _resolutions[i].width + \" x \" + _resolutions[i].height;\n            options.Add(option);\n            \n            if (_resolutions[i].width == Screen.currentResolution.width &&\n                _resolutions[i].height == Screen.currentResolution.height)\n            {\n                currentResolutionIndex = i;\n            }\n        }\n        \n        _resolutionDropdown.AddOptions(options);\n        _resolutionDropdown.value = currentResolutionIndex;\n        _resolutionDropdown.RefreshShownValue();\n    }\n    \n    public void PauseGame()\n    {\n        _isPaused = true;\n        Time.timeScale = 0f;\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(true);\n        \n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n    \n    public void ResumeGame()\n    {\n        _isPaused = false;\n        Time.timeScale = _originalTimeScale;\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n        \n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n    \n    public void OpenOptions()\n    {\n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(true);\n    }\n    \n    public void CloseOptions()\n    {\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(true);\n    }\n    \n    public void LoadMainMenu()\n    {\n        Time.timeScale = _originalTimeScale;\n        SceneManager.LoadScene(_mainMenuSceneName);\n    }\n    \n    public void QuitGame()\n    {\n        SaveSettings();\n        Application.Quit();\n    }\n    \n    public void SetMasterVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"MasterVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetMusicVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"MusicVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetSFXVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"SFXVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetMute(bool isMuted)\n    {\n        if (_audioMixer != null)\n        {\n            if (isMuted)\n                _audioMixer.SetFloat(\"MasterVolume\", -80f);\n            else if (_masterVolumeSlider != null)\n                SetMasterVolume(_masterVolumeSlider.value);\n        }\n    }\n    \n    public void SetQuality(int qualityIndex)\n    {\n        QualitySettings.SetQualityLevel(qualityIndex);\n    }\n    \n    public void SetFullscreen(bool isFullscreen)\n    {\n        Screen.fullScreen = isFullscreen;\n    }\n    \n    public void SetResolution(int resolutionIndex)\n    {\n        if (_resolutions != null && resolutionIndex < _resolutions.Length)\n        {\n            Resolution resolution = _resolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);\n        }\n    }\n    \n    public void SetBrightness(float brightness)\n    {\n        RenderSettings.ambientIntensity = brightness;\n    }\n    \n    public void SetMouseSensitivity(float sensitivity)\n    {\n        PlayerPrefs.SetFloat(\"MouseSensitivity\", sensitivity);\n    }\n    \n    public void SetInvertY(bool invert)\n    {\n        PlayerPrefs.SetInt(\"InvertY\", invert ? 1 : 0);\n    }\n    \n    public void SetDifficulty(int difficulty)\n    {\n        PlayerPrefs.SetInt(\"Difficulty\", difficulty);\n    }\n    \n    private void LoadSettings()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            float masterVolume = PlayerPrefs.GetFloat(\"MasterVolume\", 0.75f);\n            _masterVolumeSlider.value = masterVolume;\n            SetMasterVolume(masterVolume);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            float musicVolume = PlayerPrefs.GetFloat(\"MusicVolume\", 0.75f);\n            _musicVolumeSlider.value = musicVolume;\n            SetMusicVolume(musicVolume);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            float sfxVolume = PlayerPrefs.GetFloat(\"SFXVolume\", 0.75f);\n            _sfxVolumeSlider.value = sfxVolume;\n            SetSFXVolume(sfxVolume);\n        }\n        \n        if (_muteToggle != null)\n        {\n            bool isMuted = PlayerPrefs.GetInt(\"Mute\", 0) == 1;\n            _muteToggle.isOn = isMuted;\n            SetMute(isMuted);\n        }\n        \n        if (_brightnessSlider != null)\n        {\n            float brightness = PlayerPrefs.GetFloat(\"Brightness\", 1f);\n            _brightnessSlider.value = brightness;\n            SetBrightness(brightness);\n        }\n        \n        if (_mouseSensitivitySlider != null)\n        {\n            float sensitivity = PlayerPrefs.GetFloat(\"MouseSensitivity\", 2f);\n            _mouseSensitivitySlider.value = sensitivity;\n        }\n        \n        if (_invertYToggle != null)\n        {\n            bool invertY = PlayerPrefs.GetInt(\"InvertY\", 0) == 1;\n            _invertYToggle.isOn = invertY;\n        }\n        \n        if (_difficultyDropdown != null)\n        {\n            int difficulty = PlayerPrefs.GetInt(\"Difficulty\", 1);\n            _difficultyDropdown.value = difficulty;\n        }\n    }\n    \n    private void SaveSettings()\n    {\n        if (_masterVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MasterVolume\", _masterVolumeSlider.value);\n        if (_musicVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MusicVolume\", _musicVolumeSlider.value);\n        if (_sfxVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"SFXVolume\", _sfxVolumeSlider.value);\n        if (_muteToggle != null)\n            PlayerPrefs.SetInt(\"Mute\", _muteToggle.isOn ? 1 : 0);\n        if (_brightnessSlider != null)\n            PlayerPrefs.SetFloat(\"Brightness\", _brightnessSlider.value);\n        if (_mouseSensitivitySlider != null)\n            PlayerPrefs.SetFloat(\"MouseSensitivity\", _mouseSensitivitySlider.value);\n        if (_invertYToggle != null)\n            PlayerPrefs.SetInt(\"InvertY\", _invertYToggle.isOn ? 1 : 0);\n        if (_difficultyDropdown != null)\n            PlayerPrefs.SetInt(\"Difficulty\", _difficultyDropdown.value);\n        \n        PlayerPrefs.Save();\n    }\n    \n    private void OnDestroy()\n    {\n        SaveSettings();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "difficulty selection",
      "ideal_ir": {
        "class_name": "DifficultySelector",
        "components": [
          "Canvas",
          "GraphicRaycaster"
        ],
        "fields": [
          {
            "name": "selectedDifficulty",
            "type": "string",
            "default": "Normal"
          },
          {
            "name": "difficultyOptions",
            "type": "string[]",
            "default": [
              "Easy",
              "Normal",
              "Hard"
            ]
          },
          {
            "name": "easyButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "normalButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "hardButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "confirmButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "selectedIndicator",
            "type": "Image",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "select_easy_difficulty",
            "trigger": "when easy button is clicked",
            "actions": [
              {
                "action": "set selected difficulty to Easy"
              },
              {
                "action": "move selection indicator to easy button"
              },
              {
                "action": "highlight easy button"
              },
              {
                "action": "remove highlight from other buttons"
              }
            ]
          },
          {
            "name": "select_normal_difficulty",
            "trigger": "when normal button is clicked",
            "actions": [
              {
                "action": "set selected difficulty to Normal"
              },
              {
                "action": "move selection indicator to normal button"
              },
              {
                "action": "highlight normal button"
              },
              {
                "action": "remove highlight from other buttons"
              }
            ]
          },
          {
            "name": "select_hard_difficulty",
            "trigger": "when hard button is clicked",
            "actions": [
              {
                "action": "set selected difficulty to Hard"
              },
              {
                "action": "move selection indicator to hard button"
              },
              {
                "action": "highlight hard button"
              },
              {
                "action": "remove highlight from other buttons"
              }
            ]
          },
          {
            "name": "confirm_difficulty_selection",
            "trigger": "when confirm button is clicked",
            "actions": [
              {
                "action": "save selected difficulty to game settings"
              },
              {
                "action": "apply difficulty modifiers to game parameters"
              },
              {
                "action": "close difficulty selection menu"
              },
              {
                "action": "proceed to next game state"
              }
            ]
          },
          {
            "name": "initialize_difficulty_menu",
            "trigger": "when difficulty menu opens",
            "actions": [
              {
                "action": "set normal difficulty as default selection"
              },
              {
                "action": "position selection indicator on normal button"
              },
              {
                "action": "highlight normal button"
              },
              {
                "action": "display all difficulty options"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class DifficultySelector : MonoBehaviour\n{\n    [System.Serializable]\n    public class DifficultySettings\n    {\n        public string name;\n        public string description;\n        public float enemyHealthMultiplier = 1f;\n        public float enemyDamageMultiplier = 1f;\n        public float enemySpeedMultiplier = 1f;\n        public float playerHealthMultiplier = 1f;\n        public float experienceMultiplier = 1f;\n        public int maxLives = 3;\n        public Color difficultyColor = Color.white;\n    }\n\n    [System.Serializable]\n    public class DifficultySelectedEvent : UnityEvent<int, DifficultySettings> { }\n\n    [Header(\"Difficulty Configuration\")]\n    [SerializeField] private List<DifficultySettings> _difficulties = new List<DifficultySettings>();\n    [SerializeField] private int _defaultDifficultyIndex = 1;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _buttonContainer;\n    [SerializeField] private Button _difficultyButtonPrefab;\n    [SerializeField] private Text _difficultyNameText;\n    [SerializeField] private Text _difficultyDescriptionText;\n    [SerializeField] private Button _confirmButton;\n    [SerializeField] private Button _backButton;\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _selectedButtonColor = Color.green;\n    [SerializeField] private Color _normalButtonColor = Color.white;\n    [SerializeField] private float _buttonScaleOnHover = 1.1f;\n\n    [Header(\"Events\")]\n    public DifficultySelectedEvent OnDifficultySelected = new DifficultySelectedEvent();\n    public UnityEvent OnBackPressed = new UnityEvent();\n\n    private List<Button> _difficultyButtons = new List<Button>();\n    private int _selectedDifficultyIndex = -1;\n    private static int _savedDifficultyIndex = -1;\n\n    private void Start()\n    {\n        InitializeDefaultDifficulties();\n        CreateDifficultyButtons();\n        SetupUIEvents();\n        LoadSavedDifficulty();\n    }\n\n    private void InitializeDefaultDifficulties()\n    {\n        if (_difficulties.Count == 0)\n        {\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Easy\",\n                description = \"Relaxed gameplay with weaker enemies and more health\",\n                enemyHealthMultiplier = 0.7f,\n                enemyDamageMultiplier = 0.7f,\n                enemySpeedMultiplier = 0.8f,\n                playerHealthMultiplier = 1.5f,\n                experienceMultiplier = 1.2f,\n                maxLives = 5,\n                difficultyColor = Color.green\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Normal\",\n                description = \"Balanced gameplay for the intended experience\",\n                enemyHealthMultiplier = 1f,\n                enemyDamageMultiplier = 1f,\n                enemySpeedMultiplier = 1f,\n                playerHealthMultiplier = 1f,\n                experienceMultiplier = 1f,\n                maxLives = 3,\n                difficultyColor = Color.yellow\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Hard\",\n                description = \"Challenging gameplay with stronger enemies\",\n                enemyHealthMultiplier = 1.5f,\n                enemyDamageMultiplier = 1.3f,\n                enemySpeedMultiplier = 1.2f,\n                playerHealthMultiplier = 0.8f,\n                experienceMultiplier = 1.5f,\n                maxLives = 2,\n                difficultyColor = Color.red\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Nightmare\",\n                description = \"Extreme challenge for hardcore players only\",\n                enemyHealthMultiplier = 2f,\n                enemyDamageMultiplier = 1.8f,\n                enemySpeedMultiplier = 1.5f,\n                playerHealthMultiplier = 0.5f,\n                experienceMultiplier = 2f,\n                maxLives = 1,\n                difficultyColor = Color.magenta\n            });\n        }\n    }\n\n    private void CreateDifficultyButtons()\n    {\n        if (_buttonContainer == null || _difficultyButtonPrefab == null)\n            return;\n\n        ClearExistingButtons();\n\n        for (int i = 0; i < _difficulties.Count; i++)\n        {\n            CreateDifficultyButton(i);\n        }\n    }\n\n    private void ClearExistingButtons()\n    {\n        foreach (Button button in _difficultyButtons)\n        {\n            if (button != null)\n                DestroyImmediate(button.gameObject);\n        }\n        _difficultyButtons.Clear();\n    }\n\n    private void CreateDifficultyButton(int index)\n    {\n        Button button = Instantiate(_difficultyButtonPrefab, _buttonContainer);\n        Text buttonText = button.GetComponentInChildren<Text>();\n        \n        if (buttonText != null)\n        {\n            buttonText.text = _difficulties[index].name;\n            buttonText.color = _difficulties[index].difficultyColor;\n        }\n\n        int capturedIndex = index;\n        button.onClick.AddListener(() => SelectDifficulty(capturedIndex));\n\n        DifficultyButtonHover hoverEffect = button.gameObject.AddComponent<DifficultyButtonHover>();\n        hoverEffect.Initialize(_buttonScaleOnHover);\n\n        _difficultyButtons.Add(button);\n    }\n\n    private void SetupUIEvents()\n    {\n        if (_confirmButton != null)\n            _confirmButton.onClick.AddListener(ConfirmSelection);\n\n        if (_backButton != null)\n            _backButton.onClick.AddListener(() => OnBackPressed.Invoke());\n\n        UpdateConfirmButtonState();\n    }\n\n    private void LoadSavedDifficulty()\n    {\n        int savedIndex = PlayerPrefs.GetInt(\"SelectedDifficulty\", _defaultDifficultyIndex);\n        \n        if (_savedDifficultyIndex != -1)\n            savedIndex = _savedDifficultyIndex;\n\n        if (savedIndex >= 0 && savedIndex < _difficulties.Count)\n        {\n            SelectDifficulty(savedIndex);\n        }\n    }\n\n    public void SelectDifficulty(int index)\n    {\n        if (index < 0 || index >= _difficulties.Count)\n            return;\n\n        _selectedDifficultyIndex = index;\n        UpdateButtonVisuals();\n        UpdateDifficultyInfo();\n        UpdateConfirmButtonState();\n    }\n\n    private void UpdateButtonVisuals()\n    {\n        for (int i = 0; i < _difficultyButtons.Count; i++)\n        {\n            if (_difficultyButtons[i] != null)\n            {\n                ColorBlock colors = _difficultyButtons[i].colors;\n                colors.normalColor = (i == _selectedDifficultyIndex) ? _selectedButtonColor : _normalButtonColor;\n                _difficultyButtons[i].colors = colors;\n            }\n        }\n    }\n\n    private void UpdateDifficultyInfo()\n    {\n        if (_selectedDifficultyIndex < 0 || _selectedDifficultyIndex >= _difficulties.Count)\n            return;\n\n        DifficultySettings selected = _difficulties[_selectedDifficultyIndex];\n\n        if (_difficultyNameText != null)\n            _difficultyNameText.text = selected.name;\n\n        if (_difficultyDescriptionText != null)\n            _difficultyDescriptionText.text = selected.description;\n    }\n\n    private void UpdateConfirmButtonState()\n    {\n        if (_confirmButton != null)\n            _confirmButton.interactable = (_selectedDifficultyIndex >= 0);\n    }\n\n    private void ConfirmSelection()\n    {\n        if (_selectedDifficultyIndex < 0 || _selectedDifficultyIndex >= _difficulties.Count)\n            return;\n\n        PlayerPrefs.SetInt(\"SelectedDifficulty\", _selectedDifficultyIndex);\n        PlayerPrefs.Save();\n\n        _savedDifficultyIndex = _selectedDifficultyIndex;\n\n        OnDifficultySelected.Invoke(_selectedDifficultyIndex, _difficulties[_selectedDifficultyIndex]);\n    }\n\n    public DifficultySettings GetSelectedDifficulty()\n    {\n        if (_selectedDifficultyIndex >= 0 && _selectedDifficultyIndex < _difficulties.Count)\n            return _difficulties[_selectedDifficultyIndex];\n        \n        return _difficulties[_defaultDifficultyIndex];\n    }\n\n    public static DifficultySettings GetCurrentDifficulty()\n    {\n        int savedIndex = PlayerPrefs.GetInt(\"SelectedDifficulty\", 1);\n        \n        if (_savedDifficultyIndex != -1)\n            savedIndex = _savedDifficultyIndex;\n\n        DifficultySelector selector = FindObjectOfType<DifficultySelector>();\n        if (selector != null && savedIndex >= 0 && savedIndex < selector._difficulties.Count)\n            return selector._difficulties[savedIndex];\n\n        return new DifficultySettings\n        {\n            name = \"Normal\",\n            description = \"Default difficulty\",\n            enemyHealthMultiplier = 1f,\n            enemyDamageMultiplier = 1f,\n            enemySpeedMultiplier = 1f,\n            playerHealthMultiplier = 1f,\n            experienceMultiplier = 1f,\n            maxLives = 3,\n            difficultyColor = Color.white\n        };\n    }\n\n    public void ResetToDefault()\n    {\n        SelectDifficulty(_defaultDifficultyIndex);\n    }\n\n    private class DifficultyButtonHover : MonoBehaviour, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IPointerExitHandler\n    {\n        private Vector3 _originalScale;\n        private float _hoverScale;\n\n        public void Initialize(float hoverScale)\n        {\n            _originalScale = transform.localScale;\n            _hoverScale = hoverScale;\n        }\n\n        public void OnPointerEnter(UnityEngine.EventSystems.PointerEventData eventData)\n        {\n            transform.localScale = _originalScale * _hoverScale;\n        }\n\n        public void OnPointerExit(UnityEngine.EventSystems.PointerEventData eventData)\n        {\n            transform.localScale = _originalScale;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "tutorial message system",
      "ideal_ir": {
        "class_name": "TutorialMessageSystem",
        "components": [
          "Canvas",
          "Text"
        ],
        "fields": [
          {
            "name": "messageDisplayDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "currentMessageIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "isDisplayingMessage",
            "type": "bool",
            "default": false
          },
          {
            "name": "tutorialMessages",
            "type": "string[]",
            "default": []
          },
          {
            "name": "messageText",
            "type": "Text",
            "default": null
          },
          {
            "name": "autoAdvance",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "show_next_message",
            "trigger": "when tutorial system is activated or next message is requested",
            "actions": [
              {
                "action": "display current tutorial message from the message array"
              },
              {
                "action": "fade in the message text smoothly"
              },
              {
                "action": "mark system as currently displaying message"
              },
              {
                "action": "start timer for message display duration"
              }
            ]
          },
          {
            "name": "hide_current_message",
            "trigger": "when message display timer expires or skip input is received",
            "actions": [
              {
                "action": "fade out the message text smoothly"
              },
              {
                "action": "mark system as not displaying message"
              },
              {
                "action": "increment current message index"
              }
            ]
          },
          {
            "name": "auto_advance_messages",
            "trigger": "when auto advance is enabled and current message finishes displaying",
            "actions": [
              {
                "action": "automatically show next message in sequence"
              },
              {
                "action": "continue until all messages are shown"
              }
            ]
          },
          {
            "name": "skip_message",
            "trigger": "when player presses skip input while message is displaying",
            "actions": [
              {
                "action": "immediately hide current message"
              },
              {
                "action": "advance to next message if available"
              }
            ]
          },
          {
            "name": "complete_tutorial",
            "trigger": "when all tutorial messages have been displayed",
            "actions": [
              {
                "action": "hide tutorial message system"
              },
              {
                "action": "reset message index to beginning"
              },
              {
                "action": "notify other systems that tutorial is complete"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class TutorialMessageSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class TutorialMessage\n    {\n        [Header(\"Message Content\")]\n        public string title;\n        [TextArea(3, 6)]\n        public string description;\n        public Sprite icon;\n        \n        [Header(\"Display Settings\")]\n        public float displayDuration = 5f;\n        public bool requiresInput = false;\n        public KeyCode inputKey = KeyCode.Space;\n        \n        [Header(\"Trigger Settings\")]\n        public TriggerType triggerType = TriggerType.Manual;\n        public string triggerTag = \"Player\";\n        public float triggerDelay = 0f;\n        \n        [Header(\"Events\")]\n        public UnityEvent onMessageShow;\n        public UnityEvent onMessageHide;\n        \n        [HideInInspector]\n        public bool hasBeenShown = false;\n    }\n    \n    public enum TriggerType\n    {\n        Manual,\n        OnStart,\n        OnTriggerEnter,\n        OnCollisionEnter,\n        OnKeyPress,\n        Timed\n    }\n    \n    [Header(\"Tutorial Messages\")]\n    [SerializeField] private List<TutorialMessage> _tutorialMessages = new List<TutorialMessage>();\n    [SerializeField] private bool _showMessagesOnce = true;\n    [SerializeField] private bool _showInOrder = false;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _messagePanel;\n    [SerializeField] private Text _titleText;\n    [SerializeField] private Text _descriptionText;\n    [SerializeField] private Image _iconImage;\n    [SerializeField] private Button _continueButton;\n    [SerializeField] private Text _inputPromptText;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useAnimations = true;\n    [SerializeField] private float _fadeInDuration = 0.5f;\n    [SerializeField] private float _fadeOutDuration = 0.3f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _showMessageSound;\n    [SerializeField] private AudioClip _hideMessageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTutorialStart;\n    public UnityEvent OnTutorialComplete;\n    public UnityEvent<int> OnMessageChanged;\n    \n    private int _currentMessageIndex = 0;\n    private bool _isShowingMessage = false;\n    private Coroutine _currentDisplayCoroutine;\n    private Coroutine _currentAnimationCoroutine;\n    private CanvasGroup _panelCanvasGroup;\n    private float _startTime;\n    \n    private void Awake()\n    {\n        InitializeComponents();\n    }\n    \n    private void Start()\n    {\n        _startTime = Time.time;\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(false);\n            \n        CheckForStartTriggers();\n    }\n    \n    private void Update()\n    {\n        CheckForKeyPressTriggers();\n        CheckForTimedTriggers();\n        HandleInputDuringMessage();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        CheckForTriggerMessages(other.gameObject, TriggerType.OnTriggerEnter);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        CheckForTriggerMessages(collision.gameObject, TriggerType.OnCollisionEnter);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_messagePanel != null)\n        {\n            _panelCanvasGroup = _messagePanel.GetComponent<CanvasGroup>();\n            if (_panelCanvasGroup == null)\n                _panelCanvasGroup = _messagePanel.AddComponent<CanvasGroup>();\n        }\n        \n        if (_continueButton != null)\n            _continueButton.onClick.AddListener(HideCurrentMessage);\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void CheckForStartTriggers()\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            if (_tutorialMessages[i].triggerType == TriggerType.OnStart)\n            {\n                if (_tutorialMessages[i].triggerDelay > 0)\n                    StartCoroutine(ShowMessageDelayed(i, _tutorialMessages[i].triggerDelay));\n                else\n                    ShowMessage(i);\n                    \n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForKeyPressTriggers()\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == TriggerType.OnKeyPress && \n                Input.GetKeyDown(message.inputKey) &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                ShowMessage(i);\n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForTimedTriggers()\n    {\n        float currentTime = Time.time - _startTime;\n        \n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == TriggerType.Timed && \n                currentTime >= message.triggerDelay &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                ShowMessage(i);\n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForTriggerMessages(GameObject other, TriggerType triggerType)\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == triggerType &&\n                other.CompareTag(message.triggerTag) &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                if (message.triggerDelay > 0)\n                    StartCoroutine(ShowMessageDelayed(i, message.triggerDelay));\n                else\n                    ShowMessage(i);\n                    \n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void HandleInputDuringMessage()\n    {\n        if (!_isShowingMessage) return;\n        \n        var currentMessage = _tutorialMessages[_currentMessageIndex];\n        if (currentMessage.requiresInput && Input.GetKeyDown(currentMessage.inputKey))\n        {\n            HideCurrentMessage();\n        }\n    }\n    \n    public void ShowMessage(int messageIndex)\n    {\n        if (messageIndex < 0 || messageIndex >= _tutorialMessages.Count) return;\n        if (_isShowingMessage) return;\n        if (_showMessagesOnce && _tutorialMessages[messageIndex].hasBeenShown) return;\n        \n        _currentMessageIndex = messageIndex;\n        var message = _tutorialMessages[messageIndex];\n        \n        _isShowingMessage = true;\n        message.hasBeenShown = true;\n        \n        SetupMessageUI(message);\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(true);\n            \n        PlaySound(_showMessageSound);\n        \n        if (_useAnimations)\n        {\n            if (_currentAnimationCoroutine != null)\n                StopCoroutine(_currentAnimationCoroutine);\n            _currentAnimationCoroutine = StartCoroutine(AnimateMessageIn());\n        }\n        else if (_panelCanvasGroup != null)\n        {\n            _panelCanvasGroup.alpha = 1f;\n        }\n        \n        message.onMessageShow?.Invoke();\n        OnMessageChanged?.Invoke(messageIndex);\n        \n        if (!message.requiresInput && message.displayDuration > 0)\n        {\n            _currentDisplayCoroutine = StartCoroutine(HideMessageAfterDelay(message.displayDuration));\n        }\n    }\n    \n    public void ShowNextMessage()\n    {\n        if (_showInOrder && _currentMessageIndex + 1 < _tutorialMessages.Count)\n        {\n            ShowMessage(_currentMessageIndex + 1);\n        }\n    }\n    \n    public void HideCurrentMessage()\n    {\n        if (!_isShowingMessage) return;\n        \n        var message = _tutorialMessages[_currentMessageIndex];\n        \n        if (_currentDisplayCoroutine != null)\n        {\n            StopCoroutine(_currentDisplayCoroutine);\n            _currentDisplayCoroutine = null;\n        }\n        \n        PlaySound(_hideMessageSound);\n        \n        if (_useAnimations)\n        {\n            if (_currentAnimationCoroutine != null)\n                StopCoroutine(_currentAnimationCoroutine);\n            _currentAnimationCoroutine = StartCoroutine(AnimateMessageOut());\n        }\n        else\n        {\n            CompleteHideMessage();\n        }\n        \n        message.onMessageHide?.Invoke();\n    }\n    \n    private void CompleteHideMessage()\n    {\n        _isShowingMessage = false;\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(false);\n            \n        if (_showInOrder)\n            ShowNextMessage();\n            \n        CheckTutorialComplete();\n    }\n    \n    private void SetupMessageUI(TutorialMessage message)\n    {\n        if (_titleText != null)\n            _titleText.text = message.title;\n            \n        if (_descriptionText != null)\n            _descriptionText.text = message.description;\n            \n        if (_iconImage != null)\n        {\n            _iconImage.sprite = message.icon;\n            _iconImage.gameObject.SetActive(message.icon != null);\n        }\n        \n        if (_continueButton != null)\n            _continueButton.gameObject.SetActive(!message.requiresInput);\n            \n        if (_inputPromptText != null)\n        {\n            _inputPromptText.gameObject.SetActive(message.requiresInput);\n            if (message.requiresInput)\n                _inputPromptText.text = $\"Press {message.inputKey} to continue\";\n        }\n    }\n    \n    private void CheckTutorialComplete()\n    {\n        bool allShown = true;\n        foreach (var message in _tutorialMessages)\n        {\n            if (!message.hasBeenShown)\n            {\n                allShown = false;\n                break;\n            }\n        }\n        \n        if (allShown)\n            OnTutorialComplete?.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n    \n    private IEnumerator ShowMessageDelayed(int messageIndex, float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        ShowMessage(messageIndex);\n    }\n    \n    private IEnumerator HideMessageAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        HideCurrentMessage();\n    }\n    \n    private IEnumerator AnimateMessageIn()\n    {\n        if (_panelCanvasGroup == null) yield break;\n        \n        _panelCanvasGroup.alpha = 0f;\n        float elapsed = 0f;\n        \n        while (elapsed < _fadeInDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeInDuration;\n            _panelCanvasGroup.alpha = _animationCurve.Evaluate(progress);\n            yield return null;\n        }\n        \n        _panelCanvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator AnimateMessageOut()\n    {\n        if (_panelCanvasGroup == null)\n        {\n            CompleteHideMessage();\n            yield break;\n        }\n        \n        float startAlpha = _panelCanvasGroup.alpha;\n        float elapsed = 0f;\n        \n        while (elapsed < _fadeOutDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeOutDuration;\n            _panelCanvasGroup.alpha = startAlpha * (1f - _animationCurve.Evaluate(progress));\n            yield return null;\n        }\n        \n        _panelCanvasGroup.alpha = 0f;\n        CompleteHideMessage();\n    }\n    \n    public void ResetTutorial()\n    {\n        foreach (var message in _tutorialMessages)\n        {\n            message.hasBeenShown = false;\n        }\n        \n        if (_isShowingMessage)\n            HideCurrentMessage();\n            \n        _currentMessageIndex = 0;\n        _startTime = Time.time;\n    }\n    \n    public void SkipTutorial()\n    {\n        foreach (var message in _tutorialMessages)\n        {\n            message.hasBeenShown = true;\n        }\n        \n        if (_isShowingMessage)\n            HideCurrentMessage();\n            \n        OnTutorialComplete?.Invoke();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "checkpoint respawn",
      "ideal_ir": {
        "class_name": "CheckpointRespawn",
        "components": [
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "isActivated",
            "type": "bool",
            "default": false
          },
          {
            "name": "respawnHeight",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "activationEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "respawnEffect",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "activate_checkpoint",
            "trigger": "when player touches this checkpoint",
            "actions": [
              {
                "action": "mark this checkpoint as activated"
              },
              {
                "action": "set this as the current respawn point for the player"
              },
              {
                "action": "change visual appearance to show activation"
              },
              {
                "action": "play activation sound effect"
              },
              {
                "action": "spawn activation particle effect"
              }
            ]
          },
          {
            "name": "respawn_player",
            "trigger": "when player dies and this is the active checkpoint",
            "actions": [
              {
                "action": "move player to this checkpoint position"
              },
              {
                "action": "place player slightly above ground at respawn height"
              },
              {
                "action": "reset player health to full"
              },
              {
                "action": "reset player state to normal"
              },
              {
                "action": "spawn respawn particle effect"
              },
              {
                "action": "play respawn sound effect"
              }
            ]
          },
          {
            "name": "visual_feedback",
            "trigger": "when checkpoint becomes the active respawn point",
            "actions": [
              {
                "action": "emit glowing light"
              },
              {
                "action": "change material color to indicate active state"
              },
              {
                "action": "start gentle floating animation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class CheckpointRespawn : MonoBehaviour\n{\n    [Header(\"Checkpoint Settings\")]\n    [SerializeField] private Transform _respawnPoint;\n    [SerializeField] private bool _isActiveCheckpoint = false;\n    [SerializeField] private float _respawnDelay = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _activeIndicator;\n    [SerializeField] private GameObject _inactiveIndicator;\n    [SerializeField] private ParticleSystem _activationEffect;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _respawnSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCheckpointActivated;\n    public UnityEvent OnPlayerRespawned;\n    \n    private static CheckpointRespawn _currentActiveCheckpoint;\n    private static Dictionary<GameObject, Vector3> _playerLastPositions = new Dictionary<GameObject, Vector3>();\n    private AudioSource _audioSource;\n    private bool _hasBeenActivated = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_respawnPoint == null)\n            _respawnPoint = transform;\n            \n        UpdateVisuals();\n        \n        if (_isActiveCheckpoint && _currentActiveCheckpoint == null)\n        {\n            SetAsActiveCheckpoint();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsPlayer(other.gameObject) && !_hasBeenActivated)\n        {\n            ActivateCheckpoint(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (IsPlayer(other.gameObject) && !_hasBeenActivated)\n        {\n            ActivateCheckpoint(other.gameObject);\n        }\n    }\n    \n    private bool IsPlayer(GameObject obj)\n    {\n        return obj.CompareTag(\"Player\") && ((1 << obj.layer) & _playerLayer) != 0;\n    }\n    \n    private void ActivateCheckpoint(GameObject player)\n    {\n        if (_currentActiveCheckpoint != null && _currentActiveCheckpoint != this)\n        {\n            _currentActiveCheckpoint.DeactivateCheckpoint();\n        }\n        \n        SetAsActiveCheckpoint();\n        _playerLastPositions[player] = _respawnPoint.position;\n        \n        PlayActivationEffects();\n        OnCheckpointActivated?.Invoke();\n        \n        _hasBeenActivated = true;\n    }\n    \n    private void SetAsActiveCheckpoint()\n    {\n        _currentActiveCheckpoint = this;\n        _isActiveCheckpoint = true;\n        UpdateVisuals();\n    }\n    \n    private void DeactivateCheckpoint()\n    {\n        _isActiveCheckpoint = false;\n        UpdateVisuals();\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_activeIndicator != null)\n            _activeIndicator.SetActive(_isActiveCheckpoint);\n            \n        if (_inactiveIndicator != null)\n            _inactiveIndicator.SetActive(!_isActiveCheckpoint);\n    }\n    \n    private void PlayActivationEffects()\n    {\n        if (_activationEffect != null)\n            _activationEffect.Play();\n            \n        if (_activationSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_activationSound);\n    }\n    \n    public static void RespawnPlayer(GameObject player)\n    {\n        if (_currentActiveCheckpoint == null)\n        {\n            Debug.LogWarning(\"No active checkpoint found for respawn!\");\n            return;\n        }\n        \n        _currentActiveCheckpoint.StartCoroutine(_currentActiveCheckpoint.RespawnPlayerCoroutine(player));\n    }\n    \n    private System.Collections.IEnumerator RespawnPlayerCoroutine(GameObject player)\n    {\n        yield return new WaitForSeconds(_respawnDelay);\n        \n        Vector3 respawnPosition = _playerLastPositions.ContainsKey(player) \n            ? _playerLastPositions[player] \n            : _respawnPoint.position;\n        \n        // Reset player position\n        if (player.GetComponent<Rigidbody>() != null)\n        {\n            Rigidbody rb = player.GetComponent<Rigidbody>();\n            rb.velocity = Vector3.zero;\n            rb.angularVelocity = Vector3.zero;\n        }\n        \n        if (player.GetComponent<Rigidbody2D>() != null)\n        {\n            Rigidbody2D rb2d = player.GetComponent<Rigidbody2D>();\n            rb2d.velocity = Vector2.zero;\n            rb2d.angularVelocity = 0f;\n        }\n        \n        player.transform.position = respawnPosition;\n        player.transform.rotation = _respawnPoint.rotation;\n        \n        // Re-enable player if disabled\n        if (!player.activeInHierarchy)\n            player.SetActive(true);\n            \n        // Reset player components\n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null)\n            playerCollider.enabled = true;\n            \n        Collider2D playerCollider2D = player.GetComponent<Collider2D>();\n        if (playerCollider2D != null)\n            playerCollider2D.enabled = true;\n        \n        PlayRespawnEffects();\n        OnPlayerRespawned?.Invoke();\n    }\n    \n    private void PlayRespawnEffects()\n    {\n        if (_respawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_respawnSound);\n    }\n    \n    public static Vector3 GetCurrentRespawnPosition()\n    {\n        return _currentActiveCheckpoint != null ? _currentActiveCheckpoint._respawnPoint.position : Vector3.zero;\n    }\n    \n    public static CheckpointRespawn GetCurrentActiveCheckpoint()\n    {\n        return _currentActiveCheckpoint;\n    }\n    \n    public void ForceActivateCheckpoint()\n    {\n        if (_currentActiveCheckpoint != null && _currentActiveCheckpoint != this)\n        {\n            _currentActiveCheckpoint.DeactivateCheckpoint();\n        }\n        \n        SetAsActiveCheckpoint();\n        PlayActivationEffects();\n        OnCheckpointActivated?.Invoke();\n        _hasBeenActivated = true;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_respawnPoint != null)\n        {\n            Gizmos.color = _isActiveCheckpoint ? Color.green : Color.yellow;\n            Gizmos.DrawWireSphere(_respawnPoint.position, 1f);\n            Gizmos.DrawLine(_respawnPoint.position, _respawnPoint.position + _respawnPoint.forward * 2f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "game over screen",
      "ideal_ir": {
        "class_name": "GameOverScreen",
        "components": [
          "Canvas",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "restartButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "mainMenuButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "gameOverText",
            "type": "Text",
            "default": null
          },
          {
            "name": "finalScoreText",
            "type": "Text",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "show_game_over_screen",
            "trigger": "when game over event is received",
            "actions": [
              {
                "action": "make screen visible"
              },
              {
                "action": "fade in screen gradually over specified duration"
              },
              {
                "action": "display final score in score text"
              },
              {
                "action": "enable restart and main menu buttons"
              }
            ]
          },
          {
            "name": "restart_game",
            "trigger": "when restart button is clicked",
            "actions": [
              {
                "action": "reload current game scene"
              },
              {
                "action": "hide game over screen"
              }
            ]
          },
          {
            "name": "return_to_main_menu",
            "trigger": "when main menu button is clicked",
            "actions": [
              {
                "action": "load main menu scene"
              },
              {
                "action": "hide game over screen"
              }
            ]
          },
          {
            "name": "handle_input_shortcuts",
            "trigger": "when R key is pressed",
            "actions": [
              {
                "action": "restart game immediately"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class GameOverScreen : MonoBehaviour\n{\n    [Header(\"UI Elements\")]\n    [SerializeField] private GameObject _gameOverPanel;\n    [SerializeField] private Text _gameOverText;\n    [SerializeField] private Text _finalScoreText;\n    [SerializeField] private Text _highScoreText;\n    [SerializeField] private Button _restartButton;\n    [SerializeField] private Button _mainMenuButton;\n    [SerializeField] private Button _quitButton;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 1f;\n    [SerializeField] private float _delayBeforeShow = 0.5f;\n    [SerializeField] private AnimationCurve _fadeInCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _gameOverSound;\n    [SerializeField] private AudioClip _buttonClickSound;\n    \n    [Header(\"Scene Management\")]\n    [SerializeField] private string _gameSceneName = \"GameScene\";\n    [SerializeField] private string _mainMenuSceneName = \"MainMenu\";\n    \n    private CanvasGroup _canvasGroup;\n    private int _currentScore;\n    private int _highScore;\n    private bool _isShowing = false;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupButtons();\n        HideGameOverScreen();\n    }\n    \n    private void Start()\n    {\n        LoadHighScore();\n    }\n    \n    private void SetupButtons()\n    {\n        if (_restartButton != null)\n            _restartButton.onClick.AddListener(RestartGame);\n            \n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.AddListener(GoToMainMenu);\n            \n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(QuitGame);\n    }\n    \n    public void ShowGameOverScreen(int finalScore = 0)\n    {\n        if (_isShowing) return;\n        \n        _currentScore = finalScore;\n        UpdateHighScore();\n        StartCoroutine(ShowGameOverCoroutine());\n    }\n    \n    private IEnumerator ShowGameOverCoroutine()\n    {\n        _isShowing = true;\n        \n        yield return new WaitForSeconds(_delayBeforeShow);\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(true);\n            \n        PlayGameOverSound();\n        UpdateScoreTexts();\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.unscaledDeltaTime;\n            float normalizedTime = elapsedTime / _fadeInDuration;\n            float curveValue = _fadeInCurve.Evaluate(normalizedTime);\n            \n            _canvasGroup.alpha = curveValue;\n            \n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n        _canvasGroup.interactable = true;\n        _canvasGroup.blocksRaycasts = true;\n    }\n    \n    public void HideGameOverScreen()\n    {\n        _isShowing = false;\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n            \n        _canvasGroup.alpha = 0f;\n        _canvasGroup.interactable = false;\n        _canvasGroup.blocksRaycasts = false;\n    }\n    \n    private void UpdateScoreTexts()\n    {\n        if (_finalScoreText != null)\n            _finalScoreText.text = \"Final Score: \" + _currentScore.ToString();\n            \n        if (_highScoreText != null)\n            _highScoreText.text = \"High Score: \" + _highScore.ToString();\n            \n        if (_gameOverText != null && _currentScore >= _highScore && _currentScore > 0)\n            _gameOverText.text = \"NEW HIGH SCORE!\";\n    }\n    \n    private void UpdateHighScore()\n    {\n        if (_currentScore > _highScore)\n        {\n            _highScore = _currentScore;\n            SaveHighScore();\n        }\n    }\n    \n    private void LoadHighScore()\n    {\n        _highScore = PlayerPrefs.GetInt(\"HighScore\", 0);\n    }\n    \n    private void SaveHighScore()\n    {\n        PlayerPrefs.SetInt(\"HighScore\", _highScore);\n        PlayerPrefs.Save();\n    }\n    \n    private void PlayGameOverSound()\n    {\n        if (_audioSource != null && _gameOverSound != null)\n            _audioSource.PlayOneShot(_gameOverSound);\n    }\n    \n    private void PlayButtonClickSound()\n    {\n        if (_audioSource != null && _buttonClickSound != null)\n            _audioSource.PlayOneShot(_buttonClickSound);\n    }\n    \n    public void RestartGame()\n    {\n        PlayButtonClickSound();\n        Time.timeScale = 1f;\n        SceneManager.LoadScene(_gameSceneName);\n    }\n    \n    public void GoToMainMenu()\n    {\n        PlayButtonClickSound();\n        Time.timeScale = 1f;\n        SceneManager.LoadScene(_mainMenuSceneName);\n    }\n    \n    public void QuitGame()\n    {\n        PlayButtonClickSound();\n        \n#if UNITY_EDITOR\n        UnityEditor.EditorApplication.isPlaying = false;\n#else\n        Application.Quit();\n#endif\n    }\n    \n    private void OnDestroy()\n    {\n        if (_restartButton != null)\n            _restartButton.onClick.RemoveAllListeners();\n            \n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.RemoveAllListeners();\n            \n        if (_quitButton != null)\n            _quitButton.onClick.RemoveAllListeners();\n    }\n    \n    public void SetScore(int score)\n    {\n        _currentScore = score;\n    }\n    \n    public int GetHighScore()\n    {\n        return _highScore;\n    }\n    \n    public bool IsShowing()\n    {\n        return _isShowing;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "victory celebration",
      "ideal_ir": {
        "class_name": "VictoryCelebration",
        "components": [
          "Transform",
          "Animator",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "celebrationDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "jumpHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "spinSpeed",
            "type": "float",
            "default": 360.0
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_celebration",
            "trigger": "when victory condition is met",
            "actions": [
              {
                "action": "activate celebration mode"
              },
              {
                "action": "play victory animation"
              },
              {
                "action": "play celebration sound effect"
              },
              {
                "action": "start particle effects"
              }
            ]
          },
          {
            "name": "celebration_movement",
            "trigger": "while celebration is active",
            "actions": [
              {
                "action": "jump up and down repeatedly"
              },
              {
                "action": "spin around continuously"
              },
              {
                "action": "emit sparkle particles"
              }
            ]
          },
          {
            "name": "end_celebration",
            "trigger": "when celebration duration expires",
            "actions": [
              {
                "action": "stop victory animation"
              },
              {
                "action": "fade out particle effects"
              },
              {
                "action": "return to idle state"
              },
              {
                "action": "deactivate celebration mode"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class VictoryCelebration : MonoBehaviour\n{\n    [Header(\"Victory Trigger\")]\n    [SerializeField] private bool _triggerOnStart = false;\n    [SerializeField] private KeyCode _testKey = KeyCode.V;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem[] _confettiSystems;\n    [SerializeField] private ParticleSystem[] _fireworkSystems;\n    [SerializeField] private Light[] _celebrationLights;\n    [SerializeField] private Color _lightColor = Color.yellow;\n    [SerializeField] private float _lightIntensity = 2f;\n    [SerializeField] private float _lightFlashSpeed = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _victoryMusic;\n    [SerializeField] private AudioClip[] _cheerSounds;\n    [SerializeField] private float _musicVolume = 0.8f;\n    [SerializeField] private float _cheerVolume = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator[] _celebrationAnimators;\n    [SerializeField] private string _victoryTrigger = \"Victory\";\n    [SerializeField] private Transform[] _bouncingObjects;\n    [SerializeField] private float _bounceHeight = 2f;\n    [SerializeField] private float _bounceSpeed = 3f;\n    \n    [Header(\"Camera Effects\")]\n    [SerializeField] private Camera _mainCamera;\n    [SerializeField] private bool _enableCameraShake = true;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 2f;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private GameObject _victoryPanel;\n    [SerializeField] private CanvasGroup _victoryCanvasGroup;\n    [SerializeField] private float _uiFadeSpeed = 2f;\n    \n    [Header(\"Timing\")]\n    [SerializeField] private float _celebrationDuration = 10f;\n    [SerializeField] private float _delayBeforeStart = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnVictoryStart;\n    public UnityEvent OnVictoryEnd;\n    \n    private bool _isActive = false;\n    private Vector3[] _originalPositions;\n    private Color[] _originalLightColors;\n    private float[] _originalLightIntensities;\n    private Vector3 _originalCameraPosition;\n    private Coroutine _celebrationCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        \n        if (_triggerOnStart)\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_testKey))\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        StoreOriginalValues();\n        \n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(false);\n            \n        if (_victoryCanvasGroup != null)\n            _victoryCanvasGroup.alpha = 0f;\n    }\n    \n    private void StoreOriginalValues()\n    {\n        if (_bouncingObjects != null && _bouncingObjects.Length > 0)\n        {\n            _originalPositions = new Vector3[_bouncingObjects.Length];\n            for (int i = 0; i < _bouncingObjects.Length; i++)\n            {\n                if (_bouncingObjects[i] != null)\n                    _originalPositions[i] = _bouncingObjects[i].position;\n            }\n        }\n        \n        if (_celebrationLights != null && _celebrationLights.Length > 0)\n        {\n            _originalLightColors = new Color[_celebrationLights.Length];\n            _originalLightIntensities = new float[_celebrationLights.Length];\n            \n            for (int i = 0; i < _celebrationLights.Length; i++)\n            {\n                if (_celebrationLights[i] != null)\n                {\n                    _originalLightColors[i] = _celebrationLights[i].color;\n                    _originalLightIntensities[i] = _celebrationLights[i].intensity;\n                }\n            }\n        }\n        \n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n    }\n    \n    public void StartCelebration()\n    {\n        if (_isActive) return;\n        \n        _isActive = true;\n        \n        if (_celebrationCoroutine != null)\n            StopCoroutine(_celebrationCoroutine);\n            \n        _celebrationCoroutine = StartCoroutine(CelebrationSequence());\n    }\n    \n    public void StopCelebration()\n    {\n        if (!_isActive) return;\n        \n        if (_celebrationCoroutine != null)\n        {\n            StopCoroutine(_celebrationCoroutine);\n            _celebrationCoroutine = null;\n        }\n        \n        StartCoroutine(EndCelebration());\n    }\n    \n    private IEnumerator CelebrationSequence()\n    {\n        OnVictoryStart?.Invoke();\n        \n        yield return new WaitForSeconds(_delayBeforeStart);\n        \n        StartParticleEffects();\n        StartAudioEffects();\n        StartAnimations();\n        StartLightEffects();\n        StartUIEffects();\n        \n        if (_enableCameraShake && _mainCamera != null)\n            StartCoroutine(CameraShake());\n            \n        StartCoroutine(BouncingAnimation());\n        \n        yield return new WaitForSeconds(_celebrationDuration);\n        \n        yield return StartCoroutine(EndCelebration());\n    }\n    \n    private void StartParticleEffects()\n    {\n        if (_confettiSystems != null)\n        {\n            foreach (var system in _confettiSystems)\n            {\n                if (system != null)\n                    system.Play();\n            }\n        }\n        \n        if (_fireworkSystems != null)\n        {\n            foreach (var system in _fireworkSystems)\n            {\n                if (system != null)\n                    system.Play();\n            }\n        }\n    }\n    \n    private void StartAudioEffects()\n    {\n        if (_audioSource != null)\n        {\n            if (_victoryMusic != null)\n            {\n                _audioSource.clip = _victoryMusic;\n                _audioSource.volume = _musicVolume;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            if (_cheerSounds != null && _cheerSounds.Length > 0)\n            {\n                StartCoroutine(PlayRandomCheers());\n            }\n        }\n    }\n    \n    private IEnumerator PlayRandomCheers()\n    {\n        while (_isActive)\n        {\n            yield return new WaitForSeconds(Random.Range(1f, 3f));\n            \n            if (_cheerSounds.Length > 0 && _audioSource != null)\n            {\n                AudioClip randomCheer = _cheerSounds[Random.Range(0, _cheerSounds.Length)];\n                if (randomCheer != null)\n                {\n                    _audioSource.PlayOneShot(randomCheer, _cheerVolume);\n                }\n            }\n        }\n    }\n    \n    private void StartAnimations()\n    {\n        if (_celebrationAnimators != null)\n        {\n            foreach (var animator in _celebrationAnimators)\n            {\n                if (animator != null)\n                    animator.SetTrigger(_victoryTrigger);\n            }\n        }\n    }\n    \n    private void StartLightEffects()\n    {\n        if (_celebrationLights != null)\n        {\n            StartCoroutine(FlashLights());\n        }\n    }\n    \n    private IEnumerator FlashLights()\n    {\n        while (_isActive)\n        {\n            foreach (var light in _celebrationLights)\n            {\n                if (light != null)\n                {\n                    light.color = _lightColor;\n                    light.intensity = _lightIntensity * (0.5f + 0.5f * Mathf.Sin(Time.time * _lightFlashSpeed));\n                }\n            }\n            yield return null;\n        }\n    }\n    \n    private void StartUIEffects()\n    {\n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(true);\n            \n        if (_victoryCanvasGroup != null)\n            StartCoroutine(FadeInUI());\n    }\n    \n    private IEnumerator FadeInUI()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _victoryCanvasGroup.alpha;\n        \n        while (elapsedTime < 1f / _uiFadeSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime * _uiFadeSpeed;\n            _victoryCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, progress);\n            yield return null;\n        }\n        \n        _victoryCanvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator CameraShake()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _shakeDuration && _isActive)\n        {\n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.z = 0f;\n            \n            _mainCamera.transform.position = _originalCameraPosition + randomOffset;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.position = _originalCameraPosition;\n    }\n    \n    private IEnumerator BouncingAnimation()\n    {\n        if (_bouncingObjects == null || _originalPositions == null) yield break;\n        \n        while (_isActive)\n        {\n            for (int i = 0; i < _bouncingObjects.Length; i++)\n            {\n                if (_bouncingObjects[i] != null && i < _originalPositions.Length)\n                {\n                    float bounce = Mathf.Sin(Time.time * _bounceSpeed + i * 0.5f) * _bounceHeight;\n                    Vector3 newPosition = _originalPositions[i];\n                    newPosition.y += bounce;\n                    _bouncingObjects[i].position = newPosition;\n                }\n            }\n            yield return null;\n        }\n    }\n    \n    private IEnumerator EndCelebration()\n    {\n        _isActive = false;\n        \n        StopParticleEffects();\n        \n        if (_audioSource != null)\n        {\n            float startVolume = _audioSource.volume;\n            float elapsedTime = 0f;\n            float fadeDuration = 2f;\n            \n            while (elapsedTime < fadeDuration)\n            {\n                elapsedTime += Time.deltaTime;\n                _audioSource.volume = Mathf.Lerp(startVolume, 0f, elapsedTime / fadeDuration);\n                yield return null;\n            }\n            \n            _audioSource.Stop();\n            _audioSource.volume = startVolume;\n        }\n        \n        if (_victoryCanvasGroup != null)\n            yield return StartCoroutine(FadeOutUI());\n            \n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(false);\n        \n        RestoreOriginalValues();\n        \n        OnVictoryEnd?.Invoke();\n    }\n    \n    private void StopParticleEffects()\n    {\n        if (_confettiSystems != null)\n        {\n            foreach (var system in _confettiSystems)\n            {\n                if (system != null)\n                    system.Stop();\n            }\n        }\n        \n        if (_fireworkSystems != null)\n        {\n            foreach (var system in _fireworkSystems)\n            {\n                if (system != null)\n                    system.Stop();\n            }\n        }\n    }\n    \n    private IEnumerator FadeOutUI()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _victoryCanvasGroup.alpha;\n        \n        while (elapsedTime < 1f / _uiFadeSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime * _uiFadeSpeed;\n            _victoryCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, progress);\n            yield return null;\n        }\n        \n        _victoryCanvasGroup.alpha = 0f;\n    }\n    \n    private void RestoreOriginalValues()\n    {\n        if (_bouncingObjects != null && _originalPositions != null)\n        {\n            for (int i = 0; i < _bouncingObjects.Length && i < _originalPositions.Length; i++)\n            {\n                if (_bouncingObjects[i] != null)\n                    _bouncingObjects[i].position = _originalPositions[i];\n            }\n        }\n        \n        if (_celebrationLights != null && _originalLightColors != null && _originalLightIntensities != null)\n        {\n            for (int i = 0; i < _celebrationLights.Length && i < _originalLightColors.Length; i++)\n            {\n                if (_celebrationLights[i] != null)\n                {\n                    _celebrationLights[i].color = _originalLightColors[i];\n                    _celebrationLights[i].intensity = _originalLightIntensities[i];\n                }\n            }\n        }\n        \n        if (_mainCamera != null)\n            _mainCamera.transform.position = _originalCameraPosition;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_celebrationCoroutine != null)\n        {\n            StopCoroutine(_celebrationCoroutine);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "score submission to leaderboard",
      "ideal_ir": {
        "class_name": "LeaderboardSubmission",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "playerName",
            "type": "string",
            "default": "Player"
          },
          {
            "name": "currentScore",
            "type": "int",
            "default": 0
          },
          {
            "name": "leaderboardURL",
            "type": "string",
            "default": ""
          },
          {
            "name": "maxRetries",
            "type": "int",
            "default": 3
          },
          {
            "name": "submissionTimeout",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isSubmitting",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "submit_score",
            "trigger": "when submit score method is called",
            "actions": [
              {
                "action": "validate that score is greater than zero"
              },
              {
                "action": "validate that player name is not empty"
              },
              {
                "action": "set submission status to active"
              },
              {
                "action": "send score data to leaderboard server"
              },
              {
                "action": "start timeout timer for submission"
              }
            ]
          },
          {
            "name": "handle_successful_submission",
            "trigger": "when server responds with success confirmation",
            "actions": [
              {
                "action": "set submission status to inactive"
              },
              {
                "action": "display success message to player"
              },
              {
                "action": "clear timeout timer"
              },
              {
                "action": "trigger score submitted event"
              }
            ]
          },
          {
            "name": "handle_failed_submission",
            "trigger": "when server responds with error or timeout occurs",
            "actions": [
              {
                "action": "decrease retry counter"
              },
              {
                "action": "check if retries remain available"
              },
              {
                "action": "retry submission if attempts remain"
              },
              {
                "action": "display error message if no retries left"
              },
              {
                "action": "set submission status to inactive"
              }
            ]
          },
          {
            "name": "validate_connection",
            "trigger": "before attempting score submission",
            "actions": [
              {
                "action": "check internet connectivity status"
              },
              {
                "action": "verify leaderboard server availability"
              },
              {
                "action": "show connection error if offline"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\nusing TMPro;\n\npublic class LeaderboardManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class LeaderboardEntry\n    {\n        public string playerName;\n        public int score;\n        public string date;\n        \n        public LeaderboardEntry(string name, int playerScore)\n        {\n            playerName = name;\n            score = playerScore;\n            date = System.DateTime.Now.ToString(\"MM/dd/yyyy\");\n        }\n    }\n    \n    [System.Serializable]\n    public class ScoreSubmissionEvent : UnityEvent<string, int> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _leaderboardPanel;\n    [SerializeField] private GameObject _scoreSubmissionPanel;\n    [SerializeField] private TMP_InputField _playerNameInput;\n    [SerializeField] private Button _submitButton;\n    [SerializeField] private Button _cancelButton;\n    [SerializeField] private Transform _leaderboardContent;\n    [SerializeField] private GameObject _leaderboardEntryPrefab;\n    [SerializeField] private TextMeshProUGUI _currentScoreText;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private int _maxLeaderboardEntries = 10;\n    [SerializeField] private string _defaultPlayerName = \"Anonymous\";\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _leaderboardKey = \"Leaderboard\";\n    \n    [Header(\"Events\")]\n    public ScoreSubmissionEvent OnScoreSubmitted;\n    public UnityEvent OnLeaderboardUpdated;\n    \n    private List<LeaderboardEntry> _leaderboardEntries = new List<LeaderboardEntry>();\n    private int _currentScore = 0;\n    private bool _isSubmissionActive = false;\n    \n    private void Start()\n    {\n        InitializeUI();\n        LoadLeaderboard();\n        UpdateLeaderboardDisplay();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_submitButton != null)\n            _submitButton.onClick.AddListener(SubmitScore);\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.AddListener(CancelSubmission);\n            \n        if (_playerNameInput != null)\n        {\n            _playerNameInput.text = _defaultPlayerName;\n            _playerNameInput.onEndEdit.AddListener(OnNameInputChanged);\n        }\n        \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(false);\n            \n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(false);\n    }\n    \n    public void ShowScoreSubmission(int score)\n    {\n        if (_isSubmissionActive) return;\n        \n        _currentScore = score;\n        _isSubmissionActive = true;\n        \n        if (_currentScoreText != null)\n            _currentScoreText.text = \"Score: \" + score.ToString();\n            \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(true);\n            \n        if (_playerNameInput != null)\n        {\n            _playerNameInput.text = GetLastUsedPlayerName();\n            _playerNameInput.Select();\n            _playerNameInput.ActivateInputField();\n        }\n        \n        UpdateSubmitButtonState();\n    }\n    \n    public void ShowLeaderboard()\n    {\n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(true);\n            \n        UpdateLeaderboardDisplay();\n    }\n    \n    public void HideLeaderboard()\n    {\n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(false);\n    }\n    \n    private void SubmitScore()\n    {\n        if (!_isSubmissionActive || _playerNameInput == null) return;\n        \n        string playerName = _playerNameInput.text.Trim();\n        if (string.IsNullOrEmpty(playerName))\n            playerName = _defaultPlayerName;\n            \n        AddScoreToLeaderboard(playerName, _currentScore);\n        SaveLastUsedPlayerName(playerName);\n        \n        OnScoreSubmitted?.Invoke(playerName, _currentScore);\n        \n        CancelSubmission();\n        ShowLeaderboard();\n    }\n    \n    private void CancelSubmission()\n    {\n        _isSubmissionActive = false;\n        _currentScore = 0;\n        \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(false);\n    }\n    \n    private void OnNameInputChanged(string newName)\n    {\n        UpdateSubmitButtonState();\n    }\n    \n    private void UpdateSubmitButtonState()\n    {\n        if (_submitButton == null || _playerNameInput == null) return;\n        \n        bool canSubmit = !string.IsNullOrEmpty(_playerNameInput.text.Trim()) || \n                        !string.IsNullOrEmpty(_defaultPlayerName);\n        _submitButton.interactable = canSubmit;\n    }\n    \n    public void AddScoreToLeaderboard(string playerName, int score)\n    {\n        LeaderboardEntry newEntry = new LeaderboardEntry(playerName, score);\n        _leaderboardEntries.Add(newEntry);\n        \n        _leaderboardEntries = _leaderboardEntries\n            .OrderByDescending(entry => entry.score)\n            .Take(_maxLeaderboardEntries)\n            .ToList();\n            \n        SaveLeaderboard();\n        UpdateLeaderboardDisplay();\n        OnLeaderboardUpdated?.Invoke();\n    }\n    \n    public bool IsHighScore(int score)\n    {\n        if (_leaderboardEntries.Count < _maxLeaderboardEntries)\n            return true;\n            \n        return score > _leaderboardEntries.Last().score;\n    }\n    \n    public int GetHighScore()\n    {\n        if (_leaderboardEntries.Count == 0) return 0;\n        return _leaderboardEntries.First().score;\n    }\n    \n    public List<LeaderboardEntry> GetTopScores(int count = -1)\n    {\n        if (count == -1) count = _maxLeaderboardEntries;\n        return _leaderboardEntries.Take(count).ToList();\n    }\n    \n    private void UpdateLeaderboardDisplay()\n    {\n        if (_leaderboardContent == null || _leaderboardEntryPrefab == null) return;\n        \n        foreach (Transform child in _leaderboardContent)\n        {\n            if (child.gameObject != _leaderboardEntryPrefab)\n                DestroyImmediate(child.gameObject);\n        }\n        \n        for (int i = 0; i < _leaderboardEntries.Count; i++)\n        {\n            GameObject entryObj = Instantiate(_leaderboardEntryPrefab, _leaderboardContent);\n            entryObj.SetActive(true);\n            \n            LeaderboardEntryDisplay display = entryObj.GetComponent<LeaderboardEntryDisplay>();\n            if (display == null)\n                display = entryObj.AddComponent<LeaderboardEntryDisplay>();\n                \n            display.SetupEntry(i + 1, _leaderboardEntries[i]);\n        }\n    }\n    \n    private void SaveLeaderboard()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        string jsonData = JsonUtility.ToJson(new SerializableLeaderboard(_leaderboardEntries));\n        PlayerPrefs.SetString(_leaderboardKey, jsonData);\n        PlayerPrefs.Save();\n    }\n    \n    private void LoadLeaderboard()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        if (PlayerPrefs.HasKey(_leaderboardKey))\n        {\n            string jsonData = PlayerPrefs.GetString(_leaderboardKey);\n            try\n            {\n                SerializableLeaderboard loadedData = JsonUtility.FromJson<SerializableLeaderboard>(jsonData);\n                _leaderboardEntries = loadedData.entries ?? new List<LeaderboardEntry>();\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning(\"Failed to load leaderboard: \" + e.Message);\n                _leaderboardEntries = new List<LeaderboardEntry>();\n            }\n        }\n    }\n    \n    private void SaveLastUsedPlayerName(string playerName)\n    {\n        PlayerPrefs.SetString(\"LastPlayerName\", playerName);\n    }\n    \n    private string GetLastUsedPlayerName()\n    {\n        return PlayerPrefs.GetString(\"LastPlayerName\", _defaultPlayerName);\n    }\n    \n    public void ClearLeaderboard()\n    {\n        _leaderboardEntries.Clear();\n        SaveLeaderboard();\n        UpdateLeaderboardDisplay();\n        OnLeaderboardUpdated?.Invoke();\n    }\n    \n    [System.Serializable]\n    private class SerializableLeaderboard\n    {\n        public List<LeaderboardEntry> entries;\n        \n        public SerializableLeaderboard(List<LeaderboardEntry> leaderboardEntries)\n        {\n            entries = leaderboardEntries;\n        }\n    }\n}\n\npublic class LeaderboardEntryDisplay : MonoBehaviour\n{\n    [Header(\"UI Components\")]\n    [SerializeField] private TextMeshProUGUI _rankText;\n    [SerializeField] private TextMeshProUGUI _nameText;\n    [SerializeField] private TextMeshProUGUI _scoreText;\n    [SerializeField] private TextMeshProUGUI _dateText;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Styling\")]\n    [SerializeField] private Color _topRankColor = Color.yellow;\n    [SerializeField] private Color _normalColor = Color.white;\n    \n    public void SetupEntry(int rank, LeaderboardManager.LeaderboardEntry entry)\n    {\n        if (_rankText != null)\n            _rankText.text = rank.ToString();\n            \n        if (_nameText != null)\n            _nameText.text = entry.playerName;\n            \n        if (_scoreText != null)\n            _scoreText.text = entry.score.ToString();\n            \n        if (_dateText != null)\n            _dateText.text = entry.date;\n            \n        if (_backgroundImage != null)\n        {\n            _backgroundImage.color = rank == 1 ? _topRankColor : _normalColor;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "achievement tracking",
      "ideal_ir": {
        "class_name": "AchievementTracker",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "totalScore",
            "type": "int",
            "default": 0
          },
          {
            "name": "enemiesDefeated",
            "type": "int",
            "default": 0
          },
          {
            "name": "itemsCollected",
            "type": "int",
            "default": 0
          },
          {
            "name": "levelsCompleted",
            "type": "int",
            "default": 0
          },
          {
            "name": "playtimeMinutes",
            "type": "float",
            "default": 0
          },
          {
            "name": "achievementUnlocked",
            "type": "bool",
            "default": false
          },
          {
            "name": "firstKillAchievement",
            "type": "bool",
            "default": false
          },
          {
            "name": "speedrunAchievement",
            "type": "bool",
            "default": false
          },
          {
            "name": "collectorAchievement",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "track_score_increase",
            "trigger": "when player gains points",
            "actions": [
              {
                "action": "add points to total score"
              },
              {
                "action": "check if high score achievement threshold is reached"
              }
            ]
          },
          {
            "name": "track_enemy_defeat",
            "trigger": "when enemy is defeated by player",
            "actions": [
              {
                "action": "increment enemies defeated counter"
              },
              {
                "action": "unlock first kill achievement if this is the first enemy"
              },
              {
                "action": "check if enemy slayer achievement threshold is reached"
              }
            ]
          },
          {
            "name": "track_item_collection",
            "trigger": "when player collects an item",
            "actions": [
              {
                "action": "increment items collected counter"
              },
              {
                "action": "check if collector achievement threshold is reached"
              }
            ]
          },
          {
            "name": "track_level_completion",
            "trigger": "when player completes a level",
            "actions": [
              {
                "action": "increment levels completed counter"
              },
              {
                "action": "check completion time for speedrun achievement"
              },
              {
                "action": "check if level master achievement threshold is reached"
              }
            ]
          },
          {
            "name": "track_playtime",
            "trigger": "every frame while game is active",
            "actions": [
              {
                "action": "add elapsed time to total playtime"
              },
              {
                "action": "check if dedication achievement threshold is reached"
              }
            ]
          },
          {
            "name": "unlock_achievement",
            "trigger": "when achievement conditions are met",
            "actions": [
              {
                "action": "mark achievement as unlocked"
              },
              {
                "action": "display achievement notification to player"
              },
              {
                "action": "save achievement progress to persistent storage"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class AchievementTracker : MonoBehaviour\n{\n    [System.Serializable]\n    public class Achievement\n    {\n        [Header(\"Achievement Info\")]\n        public string id;\n        public string title;\n        [TextArea(2, 4)]\n        public string description;\n        public Sprite icon;\n        public int targetValue;\n        public bool isUnlocked;\n        public bool isHidden;\n        \n        [Header(\"Progress\")]\n        public int currentValue;\n        public DateTime unlockedDate;\n        \n        public float Progress => targetValue > 0 ? Mathf.Clamp01((float)currentValue / targetValue) : 0f;\n        public bool IsCompleted => currentValue >= targetValue;\n    }\n\n    [System.Serializable]\n    public class AchievementEvent : UnityEvent<Achievement> { }\n\n    [Header(\"Achievement Settings\")]\n    [SerializeField] private List<Achievement> _achievements = new List<Achievement>();\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _savePrefix = \"Achievement_\";\n\n    [Header(\"Events\")]\n    public AchievementEvent OnAchievementUnlocked;\n    public AchievementEvent OnAchievementProgress;\n    public UnityEvent<int> OnTotalAchievementsChanged;\n\n    [Header(\"Statistics\")]\n    [SerializeField] private int _totalKills;\n    [SerializeField] private int _totalDeaths;\n    [SerializeField] private int _totalCoinsCollected;\n    [SerializeField] private float _totalPlayTime;\n    [SerializeField] private int _levelsCompleted;\n    [SerializeField] private int _enemiesDefeated;\n    [SerializeField] private float _distanceTraveled;\n\n    private Dictionary<string, Achievement> _achievementDict;\n    private float _sessionStartTime;\n\n    private void Awake()\n    {\n        _achievementDict = new Dictionary<string, Achievement>();\n        \n        foreach (var achievement in _achievements)\n        {\n            if (!string.IsNullOrEmpty(achievement.id))\n            {\n                _achievementDict[achievement.id] = achievement;\n            }\n        }\n    }\n\n    private void Start()\n    {\n        _sessionStartTime = Time.time;\n        \n        if (_saveToPlayerPrefs)\n        {\n            LoadAchievements();\n        }\n        \n        InitializeDefaultAchievements();\n    }\n\n    private void Update()\n    {\n        _totalPlayTime += Time.deltaTime;\n        UpdatePlayTimeAchievements();\n    }\n\n    private void InitializeDefaultAchievements()\n    {\n        if (_achievements.Count == 0)\n        {\n            AddDefaultAchievements();\n        }\n    }\n\n    private void AddDefaultAchievements()\n    {\n        var defaultAchievements = new List<Achievement>\n        {\n            new Achievement\n            {\n                id = \"first_kill\",\n                title = \"First Blood\",\n                description = \"Defeat your first enemy\",\n                targetValue = 1,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"kill_streak_10\",\n                title = \"Killing Spree\",\n                description = \"Defeat 10 enemies\",\n                targetValue = 10,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"coin_collector\",\n                title = \"Coin Collector\",\n                description = \"Collect 100 coins\",\n                targetValue = 100,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"survivor\",\n                title = \"Survivor\",\n                description = \"Play for 10 minutes without dying\",\n                targetValue = 600,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"explorer\",\n                title = \"Explorer\",\n                description = \"Travel 1000 units\",\n                targetValue = 1000,\n                isHidden = false\n            }\n        };\n\n        foreach (var achievement in defaultAchievements)\n        {\n            AddAchievement(achievement);\n        }\n    }\n\n    public void AddAchievement(Achievement achievement)\n    {\n        if (string.IsNullOrEmpty(achievement.id)) return;\n        \n        if (!_achievementDict.ContainsKey(achievement.id))\n        {\n            _achievements.Add(achievement);\n            _achievementDict[achievement.id] = achievement;\n        }\n    }\n\n    public void IncrementStat(string statName, int value = 1)\n    {\n        switch (statName.ToLower())\n        {\n            case \"kills\":\n            case \"enemies_defeated\":\n                _totalKills += value;\n                _enemiesDefeated += value;\n                CheckKillAchievements();\n                break;\n            case \"deaths\":\n                _totalDeaths += value;\n                break;\n            case \"coins\":\n            case \"coins_collected\":\n                _totalCoinsCollected += value;\n                CheckCoinAchievements();\n                break;\n            case \"levels_completed\":\n                _levelsCompleted += value;\n                CheckLevelAchievements();\n                break;\n        }\n    }\n\n    public void AddDistance(float distance)\n    {\n        _distanceTraveled += distance;\n        CheckDistanceAchievements();\n    }\n\n    public void UnlockAchievement(string achievementId)\n    {\n        if (_achievementDict.TryGetValue(achievementId, out Achievement achievement))\n        {\n            if (!achievement.isUnlocked)\n            {\n                achievement.isUnlocked = true;\n                achievement.unlockedDate = DateTime.Now;\n                achievement.currentValue = achievement.targetValue;\n                \n                OnAchievementUnlocked?.Invoke(achievement);\n                \n                if (_saveToPlayerPrefs)\n                {\n                    SaveAchievement(achievement);\n                }\n                \n                Debug.Log($\"Achievement Unlocked: {achievement.title}\");\n            }\n        }\n    }\n\n    public void UpdateAchievementProgress(string achievementId, int currentValue)\n    {\n        if (_achievementDict.TryGetValue(achievementId, out Achievement achievement))\n        {\n            if (!achievement.isUnlocked)\n            {\n                int previousValue = achievement.currentValue;\n                achievement.currentValue = currentValue;\n                \n                OnAchievementProgress?.Invoke(achievement);\n                \n                if (achievement.IsCompleted && !achievement.isUnlocked)\n                {\n                    UnlockAchievement(achievementId);\n                }\n                else if (_saveToPlayerPrefs && previousValue != currentValue)\n                {\n                    SaveAchievement(achievement);\n                }\n            }\n        }\n    }\n\n    private void CheckKillAchievements()\n    {\n        UpdateAchievementProgress(\"first_kill\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_10\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_50\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_100\", _totalKills);\n    }\n\n    private void CheckCoinAchievements()\n    {\n        UpdateAchievementProgress(\"coin_collector\", _totalCoinsCollected);\n        UpdateAchievementProgress(\"rich_player\", _totalCoinsCollected);\n    }\n\n    private void CheckLevelAchievements()\n    {\n        UpdateAchievementProgress(\"level_complete\", _levelsCompleted);\n        UpdateAchievementProgress(\"master_player\", _levelsCompleted);\n    }\n\n    private void CheckDistanceAchievements()\n    {\n        UpdateAchievementProgress(\"explorer\", Mathf.FloorToInt(_distanceTraveled));\n        UpdateAchievementProgress(\"marathon_runner\", Mathf.FloorToInt(_distanceTraveled));\n    }\n\n    private void UpdatePlayTimeAchievements()\n    {\n        UpdateAchievementProgress(\"survivor\", Mathf.FloorToInt(_totalPlayTime));\n        UpdateAchievementProgress(\"dedicated_player\", Mathf.FloorToInt(_totalPlayTime));\n    }\n\n    public Achievement GetAchievement(string achievementId)\n    {\n        _achievementDict.TryGetValue(achievementId, out Achievement achievement);\n        return achievement;\n    }\n\n    public List<Achievement> GetAllAchievements()\n    {\n        return new List<Achievement>(_achievements);\n    }\n\n    public List<Achievement> GetUnlockedAchievements()\n    {\n        return _achievements.FindAll(a => a.isUnlocked);\n    }\n\n    public List<Achievement> GetLockedAchievements()\n    {\n        return _achievements.FindAll(a => !a.isUnlocked && !a.isHidden);\n    }\n\n    public int GetUnlockedCount()\n    {\n        return _achievements.FindAll(a => a.isUnlocked).Count;\n    }\n\n    public float GetCompletionPercentage()\n    {\n        if (_achievements.Count == 0) return 0f;\n        return (float)GetUnlockedCount() / _achievements.Count * 100f;\n    }\n\n    private void SaveAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            SaveAchievement(achievement);\n        }\n        \n        PlayerPrefs.SetInt(_savePrefix + \"TotalKills\", _totalKills);\n        PlayerPrefs.SetInt(_savePrefix + \"TotalDeaths\", _totalDeaths);\n        PlayerPrefs.SetInt(_savePrefix + \"TotalCoins\", _totalCoinsCollected);\n        PlayerPrefs.SetFloat(_savePrefix + \"TotalPlayTime\", _totalPlayTime);\n        PlayerPrefs.SetInt(_savePrefix + \"LevelsCompleted\", _levelsCompleted);\n        PlayerPrefs.SetFloat(_savePrefix + \"DistanceTraveled\", _distanceTraveled);\n        \n        PlayerPrefs.Save();\n    }\n\n    private void SaveAchievement(Achievement achievement)\n    {\n        string prefix = _savePrefix + achievement.id + \"_\";\n        PlayerPrefs.SetInt(prefix + \"Unlocked\", achievement.isUnlocked ? 1 : 0);\n        PlayerPrefs.SetInt(prefix + \"CurrentValue\", achievement.currentValue);\n        \n        if (achievement.isUnlocked)\n        {\n            PlayerPrefs.SetString(prefix + \"UnlockedDate\", achievement.unlockedDate.ToBinary().ToString());\n        }\n    }\n\n    private void LoadAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            LoadAchievement(achievement);\n        }\n        \n        _totalKills = PlayerPrefs.GetInt(_savePrefix + \"TotalKills\", 0);\n        _totalDeaths = PlayerPrefs.GetInt(_savePrefix + \"TotalDeaths\", 0);\n        _totalCoinsCollected = PlayerPrefs.GetInt(_savePrefix + \"TotalCoins\", 0);\n        _totalPlayTime = PlayerPrefs.GetFloat(_savePrefix + \"TotalPlayTime\", 0f);\n        _levelsCompleted = PlayerPrefs.GetInt(_savePrefix + \"LevelsCompleted\", 0);\n        _distanceTraveled = PlayerPrefs.GetFloat(_savePrefix + \"DistanceTraveled\", 0f);\n    }\n\n    private void LoadAchievement(Achievement achievement)\n    {\n        string prefix = _savePrefix + achievement.id + \"_\";\n        achievement.isUnlocked = PlayerPrefs.GetInt(prefix + \"Unlocked\", 0) == 1;\n        achievement.currentValue = PlayerPrefs.GetInt(prefix + \"CurrentValue\", 0);\n        \n        if (achievement.isUnlocked)\n        {\n            string dateString = PlayerPrefs.GetString(prefix + \"UnlockedDate\", \"\");\n            if (!string.IsNullOrEmpty(dateString) && long.TryParse(dateString, out long dateBinary))\n            {\n                achievement.unlockedDate = DateTime.FromBinary(dateBinary);\n            }\n        }\n    }\n\n    public void ResetAllAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            achievement.isUnlocked = false;\n            achievement.currentValue = 0;\n            achievement.unlockedDate = default(DateTime);\n        }\n        \n        _totalKills = 0;\n        _totalDeaths = 0;\n        _totalCoinsCollected = 0;\n        _totalPlayTime = 0f;\n        _levelsCompleted = 0;\n        _distanceTraveled = 0f;\n        \n        if (_saveToPlayerPrefs)\n        {\n            ClearSavedData();\n        }\n    }\n\n    private void ClearSavedData()\n    {\n        foreach (var achievement in _achievements)\n        {\n            string prefix = _savePrefix + achievement.id + \"_\";\n            PlayerPrefs.DeleteKey(prefix + \"Unlocked\");\n            PlayerPrefs.DeleteKey(prefix + \"CurrentValue\");\n            PlayerPrefs.DeleteKey(prefix + \"UnlockedDate\");\n        }\n        \n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalKills\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalDeaths\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalCoins\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalPlayTime\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"LevelsCompleted\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"DistanceTraveled\");\n        \n        PlayerPrefs.Save();\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus && _saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "statistics tracking",
      "ideal_ir": {
        "class_name": "StatisticsTracker",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "totalScore",
            "type": "int",
            "default": 0
          },
          {
            "name": "enemiesDefeated",
            "type": "int",
            "default": 0
          },
          {
            "name": "itemsCollected",
            "type": "int",
            "default": 0
          },
          {
            "name": "distanceTraveled",
            "type": "float",
            "default": 0
          },
          {
            "name": "timeAlive",
            "type": "float",
            "default": 0
          },
          {
            "name": "levelsCompleted",
            "type": "int",
            "default": 0
          },
          {
            "name": "deathCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "highScore",
            "type": "int",
            "default": 0
          },
          {
            "name": "sessionStartTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "lastPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          }
        ],
        "behaviors": [
          {
            "name": "initialize_session",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "record current time as session start"
              },
              {
                "action": "store current player position as starting position"
              }
            ]
          },
          {
            "name": "track_score_increase",
            "trigger": "when score increases",
            "actions": [
              {
                "action": "add score increase amount to total score"
              },
              {
                "action": "update high score if total score exceeds previous high score"
              }
            ]
          },
          {
            "name": "track_enemy_defeat",
            "trigger": "when enemy is defeated",
            "actions": [
              {
                "action": "increment enemies defeated counter by one"
              }
            ]
          },
          {
            "name": "track_item_collection",
            "trigger": "when item is collected",
            "actions": [
              {
                "action": "increment items collected counter by one"
              }
            ]
          },
          {
            "name": "track_distance_traveled",
            "trigger": "every frame while player is moving",
            "actions": [
              {
                "action": "calculate distance between current position and last recorded position"
              },
              {
                "action": "add calculated distance to total distance traveled"
              },
              {
                "action": "update last recorded position to current position"
              }
            ]
          },
          {
            "name": "track_survival_time",
            "trigger": "every frame while player is alive",
            "actions": [
              {
                "action": "calculate time elapsed since session start"
              },
              {
                "action": "update time alive with elapsed time"
              }
            ]
          },
          {
            "name": "track_level_completion",
            "trigger": "when level is completed",
            "actions": [
              {
                "action": "increment levels completed counter by one"
              }
            ]
          },
          {
            "name": "track_player_death",
            "trigger": "when player dies",
            "actions": [
              {
                "action": "increment death count by one"
              }
            ]
          },
          {
            "name": "save_statistics",
            "trigger": "when game session ends",
            "actions": [
              {
                "action": "save all tracked statistics to persistent storage"
              }
            ]
          },
          {
            "name": "reset_session_stats",
            "trigger": "when new game session begins",
            "actions": [
              {
                "action": "reset all session-specific statistics to zero"
              },
              {
                "action": "preserve persistent statistics like high score and total statistics"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System;\n\npublic class StatisticsTracker : MonoBehaviour\n{\n    [System.Serializable]\n    public class StatisticEntry\n    {\n        public string name;\n        public float value;\n        public float maxValue;\n        public bool trackMaximum;\n        \n        public StatisticEntry(string statName, float initialValue = 0f, bool trackMax = false)\n        {\n            name = statName;\n            value = initialValue;\n            maxValue = initialValue;\n            trackMaximum = trackMax;\n        }\n    }\n\n    [System.Serializable]\n    public class StatisticEvent : UnityEvent<string, float> { }\n\n    [Header(\"Statistics Configuration\")]\n    [SerializeField] private List<StatisticEntry> _statistics = new List<StatisticEntry>();\n    [SerializeField] private bool _persistBetweenScenes = true;\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _savePrefix = \"Stats_\";\n\n    [Header(\"Display Settings\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    [SerializeField] private Vector2 _debugPosition = new Vector2(10, 10);\n\n    [Header(\"Events\")]\n    public StatisticEvent OnStatisticChanged;\n    public StatisticEvent OnStatisticMaxReached;\n    public UnityEvent OnStatisticsReset;\n\n    private Dictionary<string, StatisticEntry> _statisticsDict = new Dictionary<string, StatisticEntry>();\n    private Dictionary<string, float> _sessionStartValues = new Dictionary<string, float>();\n\n    public static StatisticsTracker Instance { get; private set; }\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            if (_persistBetweenScenes)\n            {\n                DontDestroyOnLoad(gameObject);\n            }\n            InitializeStatistics();\n        }\n        else if (Instance != this)\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void Start()\n    {\n        LoadStatistics();\n        RecordSessionStartValues();\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (!pauseStatus && _saveToPlayerPrefs)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _saveToPlayerPrefs)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_saveToPlayerPrefs && Instance == this)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnGUI()\n    {\n        if (!_showDebugInfo) return;\n\n        GUILayout.BeginArea(new Rect(_debugPosition.x, _debugPosition.y, 300, 400));\n        GUILayout.Label(\"Statistics Tracker\", GUI.skin.box);\n        \n        foreach (var stat in _statistics)\n        {\n            string displayText = $\"{stat.name}: {stat.value:F2}\";\n            if (stat.trackMaximum)\n            {\n                displayText += $\" (Max: {stat.maxValue:F2})\";\n            }\n            GUILayout.Label(displayText);\n        }\n        \n        GUILayout.EndArea();\n    }\n\n    private void InitializeStatistics()\n    {\n        _statisticsDict.Clear();\n        \n        foreach (var stat in _statistics)\n        {\n            if (!_statisticsDict.ContainsKey(stat.name))\n            {\n                _statisticsDict[stat.name] = stat;\n            }\n        }\n\n        // Add common default statistics if not already present\n        AddDefaultStatistics();\n    }\n\n    private void AddDefaultStatistics()\n    {\n        string[] defaultStats = {\n            \"PlayTime\", \"Score\", \"Deaths\", \"Kills\", \"ItemsCollected\",\n            \"JumpsPerformed\", \"DistanceTraveled\", \"DamageTaken\", \"DamageDealt\"\n        };\n\n        foreach (string statName in defaultStats)\n        {\n            if (!_statisticsDict.ContainsKey(statName))\n            {\n                var newStat = new StatisticEntry(statName, 0f, true);\n                _statistics.Add(newStat);\n                _statisticsDict[statName] = newStat;\n            }\n        }\n    }\n\n    private void RecordSessionStartValues()\n    {\n        _sessionStartValues.Clear();\n        foreach (var kvp in _statisticsDict)\n        {\n            _sessionStartValues[kvp.Key] = kvp.Value.value;\n        }\n    }\n\n    public void AddStatistic(string statName, float initialValue = 0f, bool trackMaximum = false)\n    {\n        if (_statisticsDict.ContainsKey(statName)) return;\n\n        var newStat = new StatisticEntry(statName, initialValue, trackMaximum);\n        _statistics.Add(newStat);\n        _statisticsDict[statName] = newStat;\n    }\n\n    public void SetStatistic(string statName, float value)\n    {\n        if (!_statisticsDict.ContainsKey(statName))\n        {\n            AddStatistic(statName, value);\n            return;\n        }\n\n        var stat = _statisticsDict[statName];\n        float oldValue = stat.value;\n        stat.value = value;\n\n        if (stat.trackMaximum && value > stat.maxValue)\n        {\n            stat.maxValue = value;\n            OnStatisticMaxReached?.Invoke(statName, value);\n        }\n\n        if (Mathf.Abs(oldValue - value) > 0.001f)\n        {\n            OnStatisticChanged?.Invoke(statName, value);\n        }\n    }\n\n    public void IncrementStatistic(string statName, float amount = 1f)\n    {\n        if (!_statisticsDict.ContainsKey(statName))\n        {\n            AddStatistic(statName, amount);\n            return;\n        }\n\n        SetStatistic(statName, _statisticsDict[statName].value + amount);\n    }\n\n    public void DecrementStatistic(string statName, float amount = 1f)\n    {\n        IncrementStatistic(statName, -amount);\n    }\n\n    public float GetStatistic(string statName)\n    {\n        return _statisticsDict.ContainsKey(statName) ? _statisticsDict[statName].value : 0f;\n    }\n\n    public float GetMaxStatistic(string statName)\n    {\n        return _statisticsDict.ContainsKey(statName) ? _statisticsDict[statName].maxValue : 0f;\n    }\n\n    public float GetSessionChange(string statName)\n    {\n        if (!_statisticsDict.ContainsKey(statName) || !_sessionStartValues.ContainsKey(statName))\n            return 0f;\n\n        return _statisticsDict[statName].value - _sessionStartValues[statName];\n    }\n\n    public Dictionary<string, float> GetAllStatistics()\n    {\n        var result = new Dictionary<string, float>();\n        foreach (var kvp in _statisticsDict)\n        {\n            result[kvp.Key] = kvp.Value.value;\n        }\n        return result;\n    }\n\n    public void ResetStatistic(string statName)\n    {\n        if (_statisticsDict.ContainsKey(statName))\n        {\n            _statisticsDict[statName].value = 0f;\n            _statisticsDict[statName].maxValue = 0f;\n            OnStatisticChanged?.Invoke(statName, 0f);\n        }\n    }\n\n    public void ResetAllStatistics()\n    {\n        foreach (var stat in _statistics)\n        {\n            stat.value = 0f;\n            stat.maxValue = 0f;\n        }\n        \n        RecordSessionStartValues();\n        OnStatisticsReset?.Invoke();\n    }\n\n    public void TrackPlayTime()\n    {\n        IncrementStatistic(\"PlayTime\", Time.deltaTime);\n    }\n\n    private void Update()\n    {\n        TrackPlayTime();\n    }\n\n    public void SaveStatistics()\n    {\n        if (!_saveToPlayerPrefs) return;\n\n        foreach (var kvp in _statisticsDict)\n        {\n            PlayerPrefs.SetFloat(_savePrefix + kvp.Key, kvp.Value.value);\n            if (kvp.Value.trackMaximum)\n            {\n                PlayerPrefs.SetFloat(_savePrefix + kvp.Key + \"_Max\", kvp.Value.maxValue);\n            }\n        }\n        PlayerPrefs.Save();\n    }\n\n    public void LoadStatistics()\n    {\n        if (!_saveToPlayerPrefs) return;\n\n        foreach (var kvp in _statisticsDict)\n        {\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key))\n            {\n                kvp.Value.value = PlayerPrefs.GetFloat(_savePrefix + kvp.Key, 0f);\n            }\n            \n            if (kvp.Value.trackMaximum && PlayerPrefs.HasKey(_savePrefix + kvp.Key + \"_Max\"))\n            {\n                kvp.Value.maxValue = PlayerPrefs.GetFloat(_savePrefix + kvp.Key + \"_Max\", 0f);\n            }\n        }\n    }\n\n    public void DeleteSavedStatistics()\n    {\n        foreach (var kvp in _statisticsDict)\n        {\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key))\n            {\n                PlayerPrefs.DeleteKey(_savePrefix + kvp.Key);\n            }\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key + \"_Max\"))\n            {\n                PlayerPrefs.DeleteKey(_savePrefix + kvp.Key + \"_Max\");\n            }\n        }\n        PlayerPrefs.Save();\n    }\n\n    // Event handlers for common game events\n    public void OnPlayerDeath()\n    {\n        IncrementStatistic(\"Deaths\");\n    }\n\n    public void OnEnemyKilled()\n    {\n        IncrementStatistic(\"Kills\");\n    }\n\n    public void OnItemCollected()\n    {\n        IncrementStatistic(\"ItemsCollected\");\n    }\n\n    public void OnJumpPerformed()\n    {\n        IncrementStatistic(\"JumpsPerformed\");\n    }\n\n    public void OnDistanceTraveled(float distance)\n    {\n        IncrementStatistic(\"DistanceTraveled\", distance);\n    }\n\n    public void OnDamageTaken(float damage)\n    {\n        IncrementStatistic(\"DamageTaken\", damage);\n    }\n\n    public void OnDamageDealt(float damage)\n    {\n        IncrementStatistic(\"DamageDealt\", damage);\n    }\n\n    public void OnScoreChanged(float newScore)\n    {\n        SetStatistic(\"Score\", newScore);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "settings preferences save",
      "ideal_ir": {
        "class_name": "SettingsPreferences",
        "components": [],
        "fields": [
          {
            "name": "masterVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "musicVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "sfxVolume",
            "type": "float",
            "default": 0.9
          },
          {
            "name": "graphicsQuality",
            "type": "int",
            "default": 2
          },
          {
            "name": "fullscreen",
            "type": "bool",
            "default": true
          },
          {
            "name": "resolution",
            "type": "string",
            "default": "1920x1080"
          },
          {
            "name": "difficulty",
            "type": "int",
            "default": 1
          },
          {
            "name": "autoSave",
            "type": "bool",
            "default": true
          },
          {
            "name": "subtitles",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "save_settings",
            "trigger": "when save settings is requested",
            "actions": [
              {
                "action": "store all current setting values to persistent storage"
              },
              {
                "action": "confirm settings have been saved successfully"
              }
            ]
          },
          {
            "name": "load_settings",
            "trigger": "when game starts or settings need to be loaded",
            "actions": [
              {
                "action": "retrieve saved setting values from persistent storage"
              },
              {
                "action": "apply loaded values to current settings"
              },
              {
                "action": "use default values for any missing settings"
              }
            ]
          },
          {
            "name": "reset_to_defaults",
            "trigger": "when reset to default settings is requested",
            "actions": [
              {
                "action": "restore all settings to their default values"
              },
              {
                "action": "save the reset settings to persistent storage"
              }
            ]
          },
          {
            "name": "apply_settings",
            "trigger": "when settings values are changed",
            "actions": [
              {
                "action": "update game systems with new setting values"
              },
              {
                "action": "validate setting values are within acceptable ranges"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Audio;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class SettingsManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class SettingsData\n    {\n        public float masterVolume = 1f;\n        public float musicVolume = 1f;\n        public float sfxVolume = 1f;\n        public int qualityLevel = 3;\n        public bool fullscreen = true;\n        public int resolutionIndex = 0;\n        public float mouseSensitivity = 1f;\n        public bool invertMouseY = false;\n        public int vsyncCount = 1;\n        public float brightness = 1f;\n        public bool showFPS = false;\n        public string language = \"English\";\n        public KeyCode jumpKey = KeyCode.Space;\n        public KeyCode interactKey = KeyCode.E;\n        public KeyCode runKey = KeyCode.LeftShift;\n    }\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private string _masterVolumeParameter = \"MasterVolume\";\n    [SerializeField] private string _musicVolumeParameter = \"MusicVolume\";\n    [SerializeField] private string _sfxVolumeParameter = \"SFXVolume\";\n\n    [Header(\"Graphics Settings\")]\n    [SerializeField] private Camera _mainCamera;\n    [SerializeField] private Light _mainLight;\n\n    [Header(\"Events\")]\n    public UnityEvent<SettingsData> OnSettingsLoaded;\n    public UnityEvent<SettingsData> OnSettingsSaved;\n    public UnityEvent<float> OnVolumeChanged;\n    public UnityEvent<int> OnQualityChanged;\n    public UnityEvent<bool> OnFullscreenChanged;\n\n    private SettingsData _currentSettings;\n    private Resolution[] _availableResolutions;\n    private const string SETTINGS_KEY = \"GameSettings\";\n\n    public SettingsData CurrentSettings => _currentSettings;\n\n    private void Awake()\n    {\n        _currentSettings = new SettingsData();\n        _availableResolutions = Screen.resolutions;\n    }\n\n    private void Start()\n    {\n        LoadSettings();\n        ApplyAllSettings();\n    }\n\n    public void SaveSettings()\n    {\n        string jsonData = JsonUtility.ToJson(_currentSettings, true);\n        PlayerPrefs.SetString(SETTINGS_KEY, jsonData);\n        PlayerPrefs.Save();\n        \n        OnSettingsSaved?.Invoke(_currentSettings);\n        Debug.Log(\"Settings saved successfully\");\n    }\n\n    public void LoadSettings()\n    {\n        if (PlayerPrefs.HasKey(SETTINGS_KEY))\n        {\n            string jsonData = PlayerPrefs.GetString(SETTINGS_KEY);\n            try\n            {\n                _currentSettings = JsonUtility.FromJson<SettingsData>(jsonData);\n                OnSettingsLoaded?.Invoke(_currentSettings);\n                Debug.Log(\"Settings loaded successfully\");\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning($\"Failed to load settings: {e.Message}. Using defaults.\");\n                ResetToDefaults();\n            }\n        }\n        else\n        {\n            Debug.Log(\"No saved settings found. Using defaults.\");\n            ResetToDefaults();\n        }\n    }\n\n    public void ResetToDefaults()\n    {\n        _currentSettings = new SettingsData();\n        ApplyAllSettings();\n        SaveSettings();\n    }\n\n    private void ApplyAllSettings()\n    {\n        SetMasterVolume(_currentSettings.masterVolume);\n        SetMusicVolume(_currentSettings.musicVolume);\n        SetSFXVolume(_currentSettings.sfxVolume);\n        SetQualityLevel(_currentSettings.qualityLevel);\n        SetFullscreen(_currentSettings.fullscreen);\n        SetResolution(_currentSettings.resolutionIndex);\n        SetVSyncCount(_currentSettings.vsyncCount);\n        SetBrightness(_currentSettings.brightness);\n    }\n\n    public void SetMasterVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.masterVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_masterVolumeParameter, dbValue);\n        }\n        \n        OnVolumeChanged?.Invoke(volume);\n    }\n\n    public void SetMusicVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.musicVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_musicVolumeParameter, dbValue);\n        }\n    }\n\n    public void SetSFXVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.sfxVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_sfxVolumeParameter, dbValue);\n        }\n    }\n\n    public void SetQualityLevel(int qualityIndex)\n    {\n        qualityIndex = Mathf.Clamp(qualityIndex, 0, QualitySettings.names.Length - 1);\n        _currentSettings.qualityLevel = qualityIndex;\n        QualitySettings.SetQualityLevel(qualityIndex);\n        OnQualityChanged?.Invoke(qualityIndex);\n    }\n\n    public void SetFullscreen(bool isFullscreen)\n    {\n        _currentSettings.fullscreen = isFullscreen;\n        Screen.fullScreen = isFullscreen;\n        OnFullscreenChanged?.Invoke(isFullscreen);\n    }\n\n    public void SetResolution(int resolutionIndex)\n    {\n        if (_availableResolutions != null && resolutionIndex >= 0 && resolutionIndex < _availableResolutions.Length)\n        {\n            _currentSettings.resolutionIndex = resolutionIndex;\n            Resolution resolution = _availableResolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, _currentSettings.fullscreen);\n        }\n    }\n\n    public void SetMouseSensitivity(float sensitivity)\n    {\n        _currentSettings.mouseSensitivity = Mathf.Clamp(sensitivity, 0.1f, 5f);\n    }\n\n    public void SetInvertMouseY(bool invert)\n    {\n        _currentSettings.invertMouseY = invert;\n    }\n\n    public void SetVSyncCount(int vSyncCount)\n    {\n        vSyncCount = Mathf.Clamp(vSyncCount, 0, 4);\n        _currentSettings.vsyncCount = vSyncCount;\n        QualitySettings.vSyncCount = vSyncCount;\n    }\n\n    public void SetBrightness(float brightness)\n    {\n        brightness = Mathf.Clamp(brightness, 0.1f, 2f);\n        _currentSettings.brightness = brightness;\n        \n        if (_mainLight != null)\n        {\n            _mainLight.intensity = brightness;\n        }\n        \n        if (_mainCamera != null)\n        {\n            _mainCamera.backgroundColor = Color.black * brightness;\n        }\n    }\n\n    public void SetShowFPS(bool showFPS)\n    {\n        _currentSettings.showFPS = showFPS;\n    }\n\n    public void SetLanguage(string language)\n    {\n        _currentSettings.language = language;\n    }\n\n    public void SetJumpKey(KeyCode keyCode)\n    {\n        _currentSettings.jumpKey = keyCode;\n    }\n\n    public void SetInteractKey(KeyCode keyCode)\n    {\n        _currentSettings.interactKey = keyCode;\n    }\n\n    public void SetRunKey(KeyCode keyCode)\n    {\n        _currentSettings.runKey = keyCode;\n    }\n\n    public Resolution[] GetAvailableResolutions()\n    {\n        return _availableResolutions;\n    }\n\n    public string[] GetQualityLevels()\n    {\n        return QualitySettings.names;\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus)\n        {\n            SaveSettings();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus)\n        {\n            SaveSettings();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        SaveSettings();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "audio volume controls",
      "ideal_ir": {
        "class_name": "AudioVolumeController",
        "components": [
          "AudioSource"
        ],
        "fields": [
          {
            "name": "masterVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "musicVolume",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "sfxVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "minVolume",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "maxVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "volumeStep",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "isMuted",
            "type": "bool",
            "default": false
          },
          {
            "name": "previousVolume",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "increase_master_volume",
            "trigger": "when volume up input is pressed",
            "actions": [
              {
                "action": "increase master volume by volume step amount"
              },
              {
                "action": "clamp master volume between minimum and maximum values"
              },
              {
                "action": "update audio source volume to match master volume"
              }
            ]
          },
          {
            "name": "decrease_master_volume",
            "trigger": "when volume down input is pressed",
            "actions": [
              {
                "action": "decrease master volume by volume step amount"
              },
              {
                "action": "clamp master volume between minimum and maximum values"
              },
              {
                "action": "update audio source volume to match master volume"
              }
            ]
          },
          {
            "name": "toggle_mute",
            "trigger": "when mute input is pressed",
            "actions": [
              {
                "action": "toggle muted state"
              },
              {
                "action": "if now muted then store current volume and set audio volume to zero"
              },
              {
                "action": "if now unmuted then restore audio volume to previously stored value"
              }
            ]
          },
          {
            "name": "set_music_volume",
            "trigger": "when music volume slider value changes",
            "actions": [
              {
                "action": "update music volume to slider value"
              },
              {
                "action": "apply music volume to all music audio sources"
              }
            ]
          },
          {
            "name": "set_sfx_volume",
            "trigger": "when sound effects volume slider value changes",
            "actions": [
              {
                "action": "update sound effects volume to slider value"
              },
              {
                "action": "apply sound effects volume to all sound effect audio sources"
              }
            ]
          },
          {
            "name": "apply_volume_settings",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "set audio source volume to master volume"
              },
              {
                "action": "apply current volume settings to all audio sources"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Audio;\n\npublic class AudioVolumeControls : MonoBehaviour\n{\n    [Header(\"Audio Mixer\")]\n    [SerializeField] private AudioMixerGroup _masterMixerGroup;\n    [SerializeField] private AudioMixerGroup _musicMixerGroup;\n    [SerializeField] private AudioMixerGroup _sfxMixerGroup;\n    \n    [Header(\"Volume Sliders\")]\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    \n    [Header(\"Volume Labels\")]\n    [SerializeField] private Text _masterVolumeLabel;\n    [SerializeField] private Text _musicVolumeLabel;\n    [SerializeField] private Text _sfxVolumeLabel;\n    \n    [Header(\"Mute Toggles\")]\n    [SerializeField] private Toggle _masterMuteToggle;\n    [SerializeField] private Toggle _musicMuteToggle;\n    [SerializeField] private Toggle _sfxMuteToggle;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private float _minVolume = -80f;\n    [SerializeField] private float _maxVolume = 0f;\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    \n    private const string MASTER_VOLUME_KEY = \"MasterVolume\";\n    private const string MUSIC_VOLUME_KEY = \"MusicVolume\";\n    private const string SFX_VOLUME_KEY = \"SFXVolume\";\n    private const string MASTER_MUTE_KEY = \"MasterMute\";\n    private const string MUSIC_MUTE_KEY = \"MusicMute\";\n    private const string SFX_MUTE_KEY = \"SFXMute\";\n    \n    private const string MASTER_MIXER_PARAM = \"MasterVolume\";\n    private const string MUSIC_MIXER_PARAM = \"MusicVolume\";\n    private const string SFX_MIXER_PARAM = \"SFXVolume\";\n    \n    private float _masterVolume = 1f;\n    private float _musicVolume = 1f;\n    private float _sfxVolume = 1f;\n    \n    private bool _masterMuted = false;\n    private bool _musicMuted = false;\n    private bool _sfxMuted = false;\n    \n    private void Start()\n    {\n        LoadVolumeSettings();\n        InitializeSliders();\n        InitializeToggles();\n        ApplyVolumeSettings();\n    }\n    \n    private void LoadVolumeSettings()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            _masterVolume = PlayerPrefs.GetFloat(MASTER_VOLUME_KEY, 1f);\n            _musicVolume = PlayerPrefs.GetFloat(MUSIC_VOLUME_KEY, 1f);\n            _sfxVolume = PlayerPrefs.GetFloat(SFX_VOLUME_KEY, 1f);\n            \n            _masterMuted = PlayerPrefs.GetInt(MASTER_MUTE_KEY, 0) == 1;\n            _musicMuted = PlayerPrefs.GetInt(MUSIC_MUTE_KEY, 0) == 1;\n            _sfxMuted = PlayerPrefs.GetInt(SFX_MUTE_KEY, 0) == 1;\n        }\n    }\n    \n    private void InitializeSliders()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            _masterVolumeSlider.minValue = 0f;\n            _masterVolumeSlider.maxValue = 1f;\n            _masterVolumeSlider.value = _masterVolume;\n            _masterVolumeSlider.onValueChanged.AddListener(OnMasterVolumeChanged);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            _musicVolumeSlider.minValue = 0f;\n            _musicVolumeSlider.maxValue = 1f;\n            _musicVolumeSlider.value = _musicVolume;\n            _musicVolumeSlider.onValueChanged.AddListener(OnMusicVolumeChanged);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            _sfxVolumeSlider.minValue = 0f;\n            _sfxVolumeSlider.maxValue = 1f;\n            _sfxVolumeSlider.value = _sfxVolume;\n            _sfxVolumeSlider.onValueChanged.AddListener(OnSFXVolumeChanged);\n        }\n    }\n    \n    private void InitializeToggles()\n    {\n        if (_masterMuteToggle != null)\n        {\n            _masterMuteToggle.isOn = _masterMuted;\n            _masterMuteToggle.onValueChanged.AddListener(OnMasterMuteToggled);\n        }\n        \n        if (_musicMuteToggle != null)\n        {\n            _musicMuteToggle.isOn = _musicMuted;\n            _musicMuteToggle.onValueChanged.AddListener(OnMusicMuteToggled);\n        }\n        \n        if (_sfxMuteToggle != null)\n        {\n            _sfxMuteToggle.isOn = _sfxMuted;\n            _sfxMuteToggle.onValueChanged.AddListener(OnSFXMuteToggled);\n        }\n    }\n    \n    public void OnMasterVolumeChanged(float value)\n    {\n        _masterVolume = value;\n        SetMasterVolume(value);\n        UpdateVolumeLabel(_masterVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnMusicVolumeChanged(float value)\n    {\n        _musicVolume = value;\n        SetMusicVolume(value);\n        UpdateVolumeLabel(_musicVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnSFXVolumeChanged(float value)\n    {\n        _sfxVolume = value;\n        SetSFXVolume(value);\n        UpdateVolumeLabel(_sfxVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnMasterMuteToggled(bool muted)\n    {\n        _masterMuted = muted;\n        SetMasterVolume(muted ? 0f : _masterVolume);\n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    public void OnMusicMuteToggled(bool muted)\n    {\n        _musicMuted = muted;\n        SetMusicVolume(muted ? 0f : _musicVolume);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    public void OnSFXMuteToggled(bool muted)\n    {\n        _sfxMuted = muted;\n        SetSFXVolume(muted ? 0f : _sfxVolume);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    private void SetMasterVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_masterMixerGroup != null && _masterMixerGroup.audioMixer != null)\n        {\n            _masterMixerGroup.audioMixer.SetFloat(MASTER_MIXER_PARAM, dbVolume);\n        }\n        else\n        {\n            AudioListener.volume = volume;\n        }\n    }\n    \n    private void SetMusicVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_musicMixerGroup != null && _musicMixerGroup.audioMixer != null)\n        {\n            _musicMixerGroup.audioMixer.SetFloat(MUSIC_MIXER_PARAM, dbVolume);\n        }\n    }\n    \n    private void SetSFXVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_sfxMixerGroup != null && _sfxMixerGroup.audioMixer != null)\n        {\n            _sfxMixerGroup.audioMixer.SetFloat(SFX_MIXER_PARAM, dbVolume);\n        }\n    }\n    \n    private float ConvertToDecibels(float volume)\n    {\n        if (volume <= 0f)\n            return _minVolume;\n        \n        return Mathf.Lerp(_minVolume, _maxVolume, volume);\n    }\n    \n    private void UpdateVolumeLabel(Text label, float volume)\n    {\n        if (label != null)\n        {\n            label.text = Mathf.RoundToInt(volume * 100f) + \"%\";\n        }\n    }\n    \n    private void ApplyVolumeSettings()\n    {\n        SetMasterVolume(_masterMuted ? 0f : _masterVolume);\n        SetMusicVolume(_musicMuted ? 0f : _musicVolume);\n        SetSFXVolume(_sfxMuted ? 0f : _sfxVolume);\n        \n        UpdateVolumeLabel(_masterVolumeLabel, _masterVolume);\n        UpdateVolumeLabel(_musicVolumeLabel, _musicVolume);\n        UpdateVolumeLabel(_sfxVolumeLabel, _sfxVolume);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.interactable = !_masterMuted;\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.interactable = !_musicMuted;\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.interactable = !_sfxMuted;\n    }\n    \n    private void SaveVolumeSettings()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            PlayerPrefs.SetFloat(MASTER_VOLUME_KEY, _masterVolume);\n            PlayerPrefs.SetFloat(MUSIC_VOLUME_KEY, _musicVolume);\n            PlayerPrefs.SetFloat(SFX_VOLUME_KEY, _sfxVolume);\n            \n            PlayerPrefs.SetInt(MASTER_MUTE_KEY, _masterMuted ? 1 : 0);\n            PlayerPrefs.SetInt(MUSIC_MUTE_KEY, _musicMuted ? 1 : 0);\n            PlayerPrefs.SetInt(SFX_MUTE_KEY, _sfxMuted ? 1 : 0);\n            \n            PlayerPrefs.Save();\n        }\n    }\n    \n    public void ResetToDefaults()\n    {\n        _masterVolume = 1f;\n        _musicVolume = 1f;\n        _sfxVolume = 1f;\n        \n        _masterMuted = false;\n        _musicMuted = false;\n        _sfxMuted = false;\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.value = _masterVolume;\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.value = _musicVolume;\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.value = _sfxVolume;\n        \n        if (_masterMuteToggle != null)\n            _masterMuteToggle.isOn = _masterMuted;\n        if (_musicMuteToggle != null)\n            _musicMuteToggle.isOn = _musicMuted;\n        if (_sfxMuteToggle != null)\n            _sfxMuteToggle.isOn = _sfxMuted;\n        \n        ApplyVolumeSettings();\n        SaveVolumeSettings();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.RemoveListener(OnMasterVolumeChanged);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.RemoveListener(OnMusicVolumeChanged);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.RemoveListener(OnSFXVolumeChanged);\n        \n        if (_masterMuteToggle != null)\n            _masterMuteToggle.onValueChanged.RemoveListener(OnMasterMuteToggled);\n        if (_musicMuteToggle != null)\n            _musicMuteToggle.onValueChanged.RemoveListener(OnMusicMuteToggled);\n        if (_sfxMuteToggle != null)\n            _sfxMuteToggle.onValueChanged.RemoveListener(OnSFXMuteToggled);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "graphics quality settings",
      "ideal_ir": {
        "class_name": "GraphicsQualitySettings",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "currentQualityLevel",
            "type": "int",
            "default": 2
          },
          {
            "name": "maxQualityLevel",
            "type": "int",
            "default": 5
          },
          {
            "name": "autoDetectQuality",
            "type": "bool",
            "default": true
          },
          {
            "name": "targetFrameRate",
            "type": "int",
            "default": 60
          },
          {
            "name": "vsyncEnabled",
            "type": "bool",
            "default": true
          },
          {
            "name": "antiAliasingLevel",
            "type": "int",
            "default": 2
          },
          {
            "name": "shadowQuality",
            "type": "int",
            "default": 2
          },
          {
            "name": "textureQuality",
            "type": "int",
            "default": 0
          },
          {
            "name": "anisotropicFiltering",
            "type": "bool",
            "default": true
          },
          {
            "name": "realtimeReflections",
            "type": "bool",
            "default": true
          },
          {
            "name": "particleRaycastBudget",
            "type": "int",
            "default": 256
          },
          {
            "name": "lodBias",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "pixelLightCount",
            "type": "int",
            "default": 4
          }
        ],
        "behaviors": [
          {
            "name": "initialize_quality_settings",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "detect system hardware capabilities"
              },
              {
                "action": "set appropriate quality level based on hardware"
              },
              {
                "action": "apply initial graphics settings"
              }
            ]
          },
          {
            "name": "change_quality_level",
            "trigger": "when quality level is changed by user",
            "actions": [
              {
                "action": "update current quality level"
              },
              {
                "action": "apply new shadow quality settings"
              },
              {
                "action": "adjust texture resolution"
              },
              {
                "action": "modify anti-aliasing settings"
              },
              {
                "action": "update particle system limits"
              },
              {
                "action": "change lighting quality"
              }
            ]
          },
          {
            "name": "toggle_vsync",
            "trigger": "when vsync setting is toggled",
            "actions": [
              {
                "action": "enable or disable vertical synchronization"
              },
              {
                "action": "update target frame rate accordingly"
              }
            ]
          },
          {
            "name": "adjust_shadow_quality",
            "trigger": "when shadow quality is modified",
            "actions": [
              {
                "action": "change shadow resolution"
              },
              {
                "action": "update shadow distance"
              },
              {
                "action": "modify shadow cascade settings"
              }
            ]
          },
          {
            "name": "optimize_for_performance",
            "trigger": "when frame rate drops below target consistently",
            "actions": [
              {
                "action": "reduce quality level automatically"
              },
              {
                "action": "disable expensive visual effects"
              },
              {
                "action": "lower texture quality"
              },
              {
                "action": "reduce particle density"
              }
            ]
          },
          {
            "name": "apply_texture_settings",
            "trigger": "when texture quality is changed",
            "actions": [
              {
                "action": "set global texture quality level"
              },
              {
                "action": "update anisotropic filtering"
              },
              {
                "action": "refresh loaded textures"
              }
            ]
          },
          {
            "name": "update_lighting_settings",
            "trigger": "when lighting quality is adjusted",
            "actions": [
              {
                "action": "change pixel light count"
              },
              {
                "action": "update realtime reflection settings"
              },
              {
                "action": "modify light culling distance"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class GraphicsQualitySettings : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Dropdown _qualityDropdown;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Toggle _vsyncToggle;\n    [SerializeField] private Slider _shadowDistanceSlider;\n    [SerializeField] private Text _shadowDistanceText;\n    [SerializeField] private Dropdown _shadowQualityDropdown;\n    [SerializeField] private Dropdown _textureQualityDropdown;\n    [SerializeField] private Dropdown _antiAliasingDropdown;\n    [SerializeField] private Slider _renderScaleSlider;\n    [SerializeField] private Text _renderScaleText;\n    [SerializeField] private Button _applyButton;\n    [SerializeField] private Button _resetButton;\n\n    [Header(\"Settings\")]\n    [SerializeField] private bool _autoApplyChanges = true;\n    [SerializeField] private float _maxShadowDistance = 150f;\n\n    private Resolution[] _availableResolutions;\n    private int _currentResolutionIndex;\n    private bool _isInitialized = false;\n\n    private struct GraphicsSettings\n    {\n        public int qualityLevel;\n        public int resolutionIndex;\n        public bool fullscreen;\n        public bool vsync;\n        public float shadowDistance;\n        public ShadowQuality shadowQuality;\n        public int textureQuality;\n        public int antiAliasing;\n        public float renderScale;\n    }\n\n    private GraphicsSettings _currentSettings;\n    private GraphicsSettings _originalSettings;\n\n    private void Start()\n    {\n        InitializeResolutions();\n        InitializeDropdowns();\n        LoadCurrentSettings();\n        SetupUICallbacks();\n        _isInitialized = true;\n    }\n\n    private void InitializeResolutions()\n    {\n        _availableResolutions = Screen.resolutions;\n        List<string> resolutionOptions = new List<string>();\n\n        for (int i = 0; i < _availableResolutions.Length; i++)\n        {\n            string option = _availableResolutions[i].width + \" x \" + _availableResolutions[i].height + \" @ \" + _availableResolutions[i].refreshRate + \"Hz\";\n            resolutionOptions.Add(option);\n\n            if (_availableResolutions[i].width == Screen.currentResolution.width &&\n                _availableResolutions[i].height == Screen.currentResolution.height)\n            {\n                _currentResolutionIndex = i;\n            }\n        }\n\n        if (_resolutionDropdown != null)\n        {\n            _resolutionDropdown.ClearOptions();\n            _resolutionDropdown.AddOptions(resolutionOptions);\n            _resolutionDropdown.value = _currentResolutionIndex;\n        }\n    }\n\n    private void InitializeDropdowns()\n    {\n        if (_qualityDropdown != null)\n        {\n            _qualityDropdown.ClearOptions();\n            List<string> qualityOptions = new List<string>();\n            string[] qualityNames = QualitySettings.names;\n            for (int i = 0; i < qualityNames.Length; i++)\n            {\n                qualityOptions.Add(qualityNames[i]);\n            }\n            _qualityDropdown.AddOptions(qualityOptions);\n        }\n\n        if (_shadowQualityDropdown != null)\n        {\n            _shadowQualityDropdown.ClearOptions();\n            _shadowQualityDropdown.AddOptions(new List<string> { \"Disabled\", \"Hard Shadows\", \"Soft Shadows\" });\n        }\n\n        if (_textureQualityDropdown != null)\n        {\n            _textureQualityDropdown.ClearOptions();\n            _textureQualityDropdown.AddOptions(new List<string> { \"Full Res\", \"Half Res\", \"Quarter Res\", \"Eighth Res\" });\n        }\n\n        if (_antiAliasingDropdown != null)\n        {\n            _antiAliasingDropdown.ClearOptions();\n            _antiAliasingDropdown.AddOptions(new List<string> { \"Disabled\", \"2x Multi Sampling\", \"4x Multi Sampling\", \"8x Multi Sampling\" });\n        }\n    }\n\n    private void LoadCurrentSettings()\n    {\n        _currentSettings.qualityLevel = QualitySettings.GetQualityLevel();\n        _currentSettings.resolutionIndex = _currentResolutionIndex;\n        _currentSettings.fullscreen = Screen.fullScreen;\n        _currentSettings.vsync = QualitySettings.vSyncCount > 0;\n        _currentSettings.shadowDistance = QualitySettings.shadowDistance;\n        _currentSettings.shadowQuality = QualitySettings.shadows;\n        _currentSettings.textureQuality = QualitySettings.globalTextureMipmapLimit;\n        _currentSettings.antiAliasing = QualitySettings.antiAliasing;\n        _currentSettings.renderScale = QualitySettings.renderPipeline != null ? 1.0f : 1.0f;\n\n        _originalSettings = _currentSettings;\n\n        UpdateUI();\n    }\n\n    private void UpdateUI()\n    {\n        if (_qualityDropdown != null)\n            _qualityDropdown.value = _currentSettings.qualityLevel;\n\n        if (_resolutionDropdown != null)\n            _resolutionDropdown.value = _currentSettings.resolutionIndex;\n\n        if (_fullscreenToggle != null)\n            _fullscreenToggle.isOn = _currentSettings.fullscreen;\n\n        if (_vsyncToggle != null)\n            _vsyncToggle.isOn = _currentSettings.vsync;\n\n        if (_shadowDistanceSlider != null)\n        {\n            _shadowDistanceSlider.value = _currentSettings.shadowDistance / _maxShadowDistance;\n            if (_shadowDistanceText != null)\n                _shadowDistanceText.text = _currentSettings.shadowDistance.ToString(\"F0\") + \"m\";\n        }\n\n        if (_shadowQualityDropdown != null)\n            _shadowQualityDropdown.value = (int)_currentSettings.shadowQuality;\n\n        if (_textureQualityDropdown != null)\n            _textureQualityDropdown.value = _currentSettings.textureQuality;\n\n        if (_antiAliasingDropdown != null)\n        {\n            int aaIndex = 0;\n            switch (_currentSettings.antiAliasing)\n            {\n                case 0: aaIndex = 0; break;\n                case 2: aaIndex = 1; break;\n                case 4: aaIndex = 2; break;\n                case 8: aaIndex = 3; break;\n            }\n            _antiAliasingDropdown.value = aaIndex;\n        }\n\n        if (_renderScaleSlider != null)\n        {\n            _renderScaleSlider.value = _currentSettings.renderScale;\n            if (_renderScaleText != null)\n                _renderScaleText.text = (_currentSettings.renderScale * 100f).ToString(\"F0\") + \"%\";\n        }\n    }\n\n    private void SetupUICallbacks()\n    {\n        if (_qualityDropdown != null)\n            _qualityDropdown.onValueChanged.AddListener(OnQualityChanged);\n\n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(OnResolutionChanged);\n\n        if (_fullscreenToggle != null)\n            _fullscreenToggle.onValueChanged.AddListener(OnFullscreenChanged);\n\n        if (_vsyncToggle != null)\n            _vsyncToggle.onValueChanged.AddListener(OnVSyncChanged);\n\n        if (_shadowDistanceSlider != null)\n            _shadowDistanceSlider.onValueChanged.AddListener(OnShadowDistanceChanged);\n\n        if (_shadowQualityDropdown != null)\n            _shadowQualityDropdown.onValueChanged.AddListener(OnShadowQualityChanged);\n\n        if (_textureQualityDropdown != null)\n            _textureQualityDropdown.onValueChanged.AddListener(OnTextureQualityChanged);\n\n        if (_antiAliasingDropdown != null)\n            _antiAliasingDropdown.onValueChanged.AddListener(OnAntiAliasingChanged);\n\n        if (_renderScaleSlider != null)\n            _renderScaleSlider.onValueChanged.AddListener(OnRenderScaleChanged);\n\n        if (_applyButton != null)\n            _applyButton.onClick.AddListener(ApplySettings);\n\n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetToDefaults);\n    }\n\n    private void OnQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.qualityLevel = value;\n        if (_autoApplyChanges) ApplyQualityLevel();\n    }\n\n    private void OnResolutionChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.resolutionIndex = value;\n        if (_autoApplyChanges) ApplyResolution();\n    }\n\n    private void OnFullscreenChanged(bool value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.fullscreen = value;\n        if (_autoApplyChanges) ApplyFullscreen();\n    }\n\n    private void OnVSyncChanged(bool value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.vsync = value;\n        if (_autoApplyChanges) ApplyVSync();\n    }\n\n    private void OnShadowDistanceChanged(float value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.shadowDistance = value * _maxShadowDistance;\n        if (_shadowDistanceText != null)\n            _shadowDistanceText.text = _currentSettings.shadowDistance.ToString(\"F0\") + \"m\";\n        if (_autoApplyChanges) ApplyShadowDistance();\n    }\n\n    private void OnShadowQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.shadowQuality = (ShadowQuality)value;\n        if (_autoApplyChanges) ApplyShadowQuality();\n    }\n\n    private void OnTextureQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.textureQuality = value;\n        if (_autoApplyChanges) ApplyTextureQuality();\n    }\n\n    private void OnAntiAliasingChanged(int value)\n    {\n        if (!_isInitialized) return;\n        int[] aaValues = { 0, 2, 4, 8 };\n        _currentSettings.antiAliasing = aaValues[Mathf.Clamp(value, 0, aaValues.Length - 1)];\n        if (_autoApplyChanges) ApplyAntiAliasing();\n    }\n\n    private void OnRenderScaleChanged(float value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.renderScale = value;\n        if (_renderScaleText != null)\n            _renderScaleText.text = (value * 100f).ToString(\"F0\") + \"%\";\n        if (_autoApplyChanges) ApplyRenderScale();\n    }\n\n    public void ApplySettings()\n    {\n        ApplyQualityLevel();\n        ApplyResolution();\n        ApplyFullscreen();\n        ApplyVSync();\n        ApplyShadowDistance();\n        ApplyShadowQuality();\n        ApplyTextureQuality();\n        ApplyAntiAliasing();\n        ApplyRenderScale();\n    }\n\n    private void ApplyQualityLevel()\n    {\n        QualitySettings.SetQualityLevel(_currentSettings.qualityLevel, true);\n    }\n\n    private void ApplyResolution()\n    {\n        if (_currentSettings.resolutionIndex >= 0 && _currentSettings.resolutionIndex < _availableResolutions.Length)\n        {\n            Resolution resolution = _availableResolutions[_currentSettings.resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, _currentSettings.fullscreen, resolution.refreshRate);\n        }\n    }\n\n    private void ApplyFullscreen()\n    {\n        Screen.fullScreen = _currentSettings.fullscreen;\n    }\n\n    private void ApplyVSync()\n    {\n        QualitySettings.vSyncCount = _currentSettings.vsync ? 1 : 0;\n    }\n\n    private void ApplyShadowDistance()\n    {\n        QualitySettings.shadowDistance = _currentSettings.shadowDistance;\n    }\n\n    private void ApplyShadowQuality()\n    {\n        QualitySettings.shadows = _currentSettings.shadowQuality;\n    }\n\n    private void ApplyTextureQuality()\n    {\n        QualitySettings.globalTextureMipmapLimit = _currentSettings.textureQuality;\n    }\n\n    private void ApplyAntiAliasing()\n    {\n        QualitySettings.antiAliasing = _currentSettings.antiAliasing;\n    }\n\n    private void ApplyRenderScale()\n    {\n        // Note: Render scale implementation depends on render pipeline\n        // This is a placeholder for custom render scale logic\n    }\n\n    public void ResetToDefaults()\n    {\n        _currentSettings = _originalSettings;\n        UpdateUI();\n        if (_autoApplyChanges) ApplySettings();\n    }\n\n    public void SaveSettings()\n    {\n        PlayerPrefs.SetInt(\"QualityLevel\", _currentSettings.qualityLevel);\n        PlayerPrefs.SetInt(\"ResolutionIndex\", _currentSettings.resolutionIndex);\n        PlayerPrefs.SetInt(\"Fullscreen\", _currentSettings.fullscreen ? 1 : 0);\n        PlayerPrefs.SetInt(\"VSync\", _currentSettings.vsync ? 1 : 0);\n        PlayerPrefs.SetFloat(\"ShadowDistance\", _currentSettings.shadowDistance);\n        PlayerPrefs.SetInt(\"ShadowQuality\", (int)_currentSettings.shadowQuality);\n        PlayerPrefs.SetInt(\"TextureQuality\", _currentSettings.textureQuality);\n        PlayerPrefs.SetInt(\"AntiAliasing\", _currentSettings.antiAliasing);\n        PlayerPrefs.SetFloat(\"RenderScale\", _currentSettings.renderScale);\n        PlayerPrefs.Save();\n    }\n\n    public void LoadSettings()\n    {\n        if (PlayerPrefs.HasKey(\"QualityLevel\"))\n        {\n            _currentSettings.qualityLevel = PlayerPrefs.GetInt(\"QualityLevel\");\n            _currentSettings.resolutionIndex = PlayerPrefs.GetInt(\"ResolutionIndex\", _currentResolutionIndex);\n            _currentSettings.fullscreen = PlayerPrefs.GetInt(\"Fullscreen\", 1) == 1;\n            _currentSettings.vsync = PlayerPrefs.GetInt(\"VSync\", 1) == 1;\n            _currentSettings.shadowDistance = PlayerPrefs.GetFloat(\"ShadowDistance\", 50f);\n            _currentSettings.shadowQuality = (ShadowQuality)PlayerPrefs.GetInt(\"ShadowQuality\", 2);\n            _currentSettings.textureQuality = PlayerPrefs.GetInt(\"TextureQuality\", 0);\n            _currentSettings.antiAliasing = PlayerPrefs.GetInt(\"AntiAliasing\", 0);\n            _currentSettings.renderScale = PlayerPrefs.GetFloat(\"RenderScale\", 1.0f);\n\n            UpdateUI();\n            ApplySettings();\n        }\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus) SaveSettings();\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus) SaveSettings();\n    }",
      "behavior_type": "general"
    },
    {
      "prompt": "control remapping",
      "ideal_ir": {
        "class_name": "ControlRemapper",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "currentControlScheme",
            "type": "string",
            "default": "default"
          },
          {
            "name": "isRemapping",
            "type": "bool",
            "default": false
          },
          {
            "name": "remapTimeLimit",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "controlMappings",
            "type": "Dictionary",
            "default": "empty"
          },
          {
            "name": "defaultMappings",
            "type": "Dictionary",
            "default": "empty"
          }
        ],
        "behaviors": [
          {
            "name": "initialize_default_controls",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "load default control mappings from settings"
              },
              {
                "action": "apply current control scheme to input system"
              },
              {
                "action": "display current control bindings in UI"
              }
            ]
          },
          {
            "name": "start_control_remapping",
            "trigger": "when remap button is pressed",
            "actions": [
              {
                "action": "enter remapping mode"
              },
              {
                "action": "highlight the control being remapped"
              },
              {
                "action": "display instruction to press new key"
              },
              {
                "action": "start countdown timer for input timeout"
              }
            ]
          },
          {
            "name": "capture_new_input",
            "trigger": "when any key is pressed during remapping mode",
            "actions": [
              {
                "action": "check if new key is already assigned to another action"
              },
              {
                "action": "warn user about conflicting key assignments"
              },
              {
                "action": "assign new key to selected control action"
              },
              {
                "action": "update control mapping dictionary"
              },
              {
                "action": "exit remapping mode"
              }
            ]
          },
          {
            "name": "handle_remapping_timeout",
            "trigger": "when remapping timer expires without input",
            "actions": [
              {
                "action": "cancel remapping operation"
              },
              {
                "action": "restore previous key binding"
              },
              {
                "action": "exit remapping mode"
              },
              {
                "action": "display timeout message to user"
              }
            ]
          },
          {
            "name": "reset_to_defaults",
            "trigger": "when reset defaults button is pressed",
            "actions": [
              {
                "action": "restore all controls to default mappings"
              },
              {
                "action": "clear any custom key assignments"
              },
              {
                "action": "update UI to show default bindings"
              },
              {
                "action": "save default settings to persistent storage"
              }
            ]
          },
          {
            "name": "save_control_settings",
            "trigger": "when apply or save button is pressed",
            "actions": [
              {
                "action": "validate all control mappings for conflicts"
              },
              {
                "action": "save current mappings to player preferences"
              },
              {
                "action": "apply new control scheme to game systems"
              },
              {
                "action": "display confirmation message"
              }
            ]
          },
          {
            "name": "handle_duplicate_assignment",
            "trigger": "when attempting to assign already used key",
            "actions": [
              {
                "action": "show conflict resolution dialog"
              },
              {
                "action": "offer to swap key assignments"
              },
              {
                "action": "allow user to choose different key"
              },
              {
                "action": "highlight conflicting control actions"
              }
            ]
          },
          {
            "name": "update_control_display",
            "trigger": "when control mappings change",
            "actions": [
              {
                "action": "refresh UI elements showing key bindings"
              },
              {
                "action": "update button labels with new key names"
              },
              {
                "action": "highlight recently changed controls"
              },
              {
                "action": "validate control scheme completeness"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class InputRemapper : MonoBehaviour\n{\n    [System.Serializable]\n    public class InputAction\n    {\n        public string actionName;\n        public KeyCode defaultKey;\n        public KeyCode currentKey;\n        public string description;\n        \n        public InputAction(string name, KeyCode key, string desc)\n        {\n            actionName = name;\n            defaultKey = key;\n            currentKey = key;\n            description = desc;\n        }\n    }\n\n    [System.Serializable]\n    public class InputBinding\n    {\n        public Button remapButton;\n        public Text actionLabel;\n        public Text keyLabel;\n        public string actionName;\n    }\n\n    [Header(\"Input Actions\")]\n    [SerializeField] private List<InputAction> _inputActions = new List<InputAction>();\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _remapPanel;\n    [SerializeField] private List<InputBinding> _inputBindings = new List<InputBinding>();\n    [SerializeField] private Button _resetButton;\n    [SerializeField] private Button _saveButton;\n    [SerializeField] private Button _cancelButton;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private GameObject _listeningOverlay;\n    [SerializeField] private Text _listeningText;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private string _saveKey = \"InputMappings\";\n    [SerializeField] private float _listeningTimeout = 10f;\n    \n    private Dictionary<string, KeyCode> _keyMappings = new Dictionary<string, KeyCode>();\n    private bool _isListening = false;\n    private string _currentRemappingAction = \"\";\n    private float _listeningTimer = 0f;\n    private Dictionary<string, KeyCode> _originalMappings = new Dictionary<string, KeyCode>();\n    \n    public UnityEvent<string, KeyCode> OnKeyRemapped = new UnityEvent<string, KeyCode>();\n    public UnityEvent OnMappingsReset = new UnityEvent();\n    public UnityEvent OnMappingsSaved = new UnityEvent();\n\n    private void Start()\n    {\n        InitializeDefaultActions();\n        LoadMappings();\n        SetupUI();\n        UpdateUI();\n    }\n\n    private void Update()\n    {\n        if (_isListening)\n        {\n            HandleKeyListening();\n        }\n        \n        HandleInputActions();\n    }\n\n    private void InitializeDefaultActions()\n    {\n        if (_inputActions.Count == 0)\n        {\n            _inputActions.Add(new InputAction(\"Move Forward\", KeyCode.W, \"Move character forward\"));\n            _inputActions.Add(new InputAction(\"Move Backward\", KeyCode.S, \"Move character backward\"));\n            _inputActions.Add(new InputAction(\"Move Left\", KeyCode.A, \"Move character left\"));\n            _inputActions.Add(new InputAction(\"Move Right\", KeyCode.D, \"Move character right\"));\n            _inputActions.Add(new InputAction(\"Jump\", KeyCode.Space, \"Make character jump\"));\n            _inputActions.Add(new InputAction(\"Run\", KeyCode.LeftShift, \"Make character run\"));\n            _inputActions.Add(new InputAction(\"Interact\", KeyCode.E, \"Interact with objects\"));\n            _inputActions.Add(new InputAction(\"Inventory\", KeyCode.Tab, \"Open inventory\"));\n            _inputActions.Add(new InputAction(\"Pause\", KeyCode.Escape, \"Pause the game\"));\n        }\n\n        foreach (var action in _inputActions)\n        {\n            _keyMappings[action.actionName] = action.currentKey;\n            _originalMappings[action.actionName] = action.currentKey;\n        }\n    }\n\n    private void SetupUI()\n    {\n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetToDefaults);\n            \n        if (_saveButton != null)\n            _saveButton.onClick.AddListener(SaveMappings);\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.AddListener(CancelRemapping);\n\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.remapButton != null)\n            {\n                string actionName = binding.actionName;\n                binding.remapButton.onClick.AddListener(() => StartRemapping(actionName));\n            }\n        }\n    }\n\n    private void HandleKeyListening()\n    {\n        _listeningTimer += Time.unscaledDeltaTime;\n        \n        if (_listeningTimer >= _listeningTimeout)\n        {\n            CancelRemapping();\n            return;\n        }\n\n        if (_listeningText != null)\n        {\n            float remainingTime = _listeningTimeout - _listeningTimer;\n            _listeningText.text = $\"Press a key for '{_currentRemappingAction}'\\nTimeout: {remainingTime:F1}s\";\n        }\n\n        foreach (KeyCode key in System.Enum.GetValues(typeof(KeyCode)))\n        {\n            if (Input.GetKeyDown(key))\n            {\n                if (key == KeyCode.Escape)\n                {\n                    CancelRemapping();\n                    return;\n                }\n\n                if (IsValidKey(key))\n                {\n                    RemapKey(_currentRemappingAction, key);\n                    StopListening();\n                }\n                else\n                {\n                    ShowStatus(\"Invalid key selected\", Color.red);\n                }\n                return;\n            }\n        }\n    }\n\n    private void HandleInputActions()\n    {\n        // This method can be used by other scripts to check for input\n        // Example usage in other scripts: if (inputRemapper.IsActionPressed(\"Jump\"))\n    }\n\n    public bool IsActionPressed(string actionName)\n    {\n        if (_keyMappings.ContainsKey(actionName))\n        {\n            return Input.GetKeyDown(_keyMappings[actionName]);\n        }\n        return false;\n    }\n\n    public bool IsActionHeld(string actionName)\n    {\n        if (_keyMappings.ContainsKey(actionName))\n        {\n            return Input.GetKey(_keyMappings[actionName]);\n        }\n        return false;\n    }\n\n    public KeyCode GetKeyForAction(string actionName)\n    {\n        return _keyMappings.ContainsKey(actionName) ? _keyMappings[actionName] : KeyCode.None;\n    }\n\n    public void StartRemapping(string actionName)\n    {\n        if (_isListening) return;\n\n        _currentRemappingAction = actionName;\n        _isListening = true;\n        _listeningTimer = 0f;\n\n        if (_listeningOverlay != null)\n            _listeningOverlay.SetActive(true);\n\n        ShowStatus($\"Listening for new key for '{actionName}'...\", Color.yellow);\n    }\n\n    private void RemapKey(string actionName, KeyCode newKey)\n    {\n        if (IsKeyAlreadyMapped(newKey, actionName))\n        {\n            ShowStatus($\"Key '{newKey}' is already mapped to another action\", Color.red);\n            return;\n        }\n\n        KeyCode oldKey = _keyMappings[actionName];\n        _keyMappings[actionName] = newKey;\n\n        var action = _inputActions.Find(a => a.actionName == actionName);\n        if (action != null)\n        {\n            action.currentKey = newKey;\n        }\n\n        OnKeyRemapped.Invoke(actionName, newKey);\n        ShowStatus($\"'{actionName}' remapped to '{newKey}'\", Color.green);\n        UpdateUI();\n    }\n\n    private void StopListening()\n    {\n        _isListening = false;\n        _currentRemappingAction = \"\";\n        _listeningTimer = 0f;\n\n        if (_listeningOverlay != null)\n            _listeningOverlay.SetActive(false);\n    }\n\n    private void CancelRemapping()\n    {\n        StopListening();\n        ShowStatus(\"Remapping cancelled\", Color.gray);\n    }\n\n    private bool IsValidKey(KeyCode key)\n    {\n        return key != KeyCode.None && \n               key != KeyCode.Mouse0 && \n               key != KeyCode.Mouse1 && \n               key != KeyCode.Mouse2;\n    }\n\n    private bool IsKeyAlreadyMapped(KeyCode key, string excludeAction = \"\")\n    {\n        foreach (var mapping in _keyMappings)\n        {\n            if (mapping.Value == key && mapping.Key != excludeAction)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void UpdateUI()\n    {\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.actionLabel != null)\n            {\n                var action = _inputActions.Find(a => a.actionName == binding.actionName);\n                if (action != null)\n                {\n                    binding.actionLabel.text = action.description;\n                }\n            }\n\n            if (binding.keyLabel != null && _keyMappings.ContainsKey(binding.actionName))\n            {\n                binding.keyLabel.text = _keyMappings[binding.actionName].ToString();\n            }\n        }\n    }\n\n    public void ResetToDefaults()\n    {\n        foreach (var action in _inputActions)\n        {\n            action.currentKey = action.defaultKey;\n            _keyMappings[action.actionName] = action.defaultKey;\n        }\n\n        OnMappingsReset.Invoke();\n        ShowStatus(\"Controls reset to defaults\", Color.green);\n        UpdateUI();\n    }\n\n    public void SaveMappings()\n    {\n        string json = JsonUtility.ToJson(new SerializableKeyMappings(_keyMappings));\n        PlayerPrefs.SetString(_saveKey, json);\n        PlayerPrefs.Save();\n\n        foreach (var mapping in _keyMappings)\n        {\n            _originalMappings[mapping.Key] = mapping.Value;\n        }\n\n        OnMappingsSaved.Invoke();\n        ShowStatus(\"Controls saved successfully\", Color.green);\n    }\n\n    private void LoadMappings()\n    {\n        if (PlayerPrefs.HasKey(_saveKey))\n        {\n            string json = PlayerPrefs.GetString(_saveKey);\n            try\n            {\n                var loadedMappings = JsonUtility.FromJson<SerializableKeyMappings>(json);\n                if (loadedMappings != null && loadedMappings.keys != null)\n                {\n                    for (int i = 0; i < loadedMappings.keys.Count; i++)\n                    {\n                        string actionName = loadedMappings.keys[i];\n                        KeyCode keyCode = loadedMappings.values[i];\n                        \n                        if (_keyMappings.ContainsKey(actionName))\n                        {\n                            _keyMappings[actionName] = keyCode;\n                            var action = _inputActions.Find(a => a.actionName == actionName);\n                            if (action != null)\n                            {\n                                action.currentKey = keyCode;\n                            }\n                        }\n                    }\n                }\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning($\"Failed to load input mappings: {e.Message}\");\n            }\n        }\n    }\n\n    public void OpenRemapPanel()\n    {\n        if (_remapPanel != null)\n        {\n            _remapPanel.SetActive(true);\n            UpdateUI();\n        }\n    }\n\n    public void CloseRemapPanel()\n    {\n        if (_remapPanel != null)\n        {\n            _remapPanel.SetActive(false);\n        }\n        \n        if (_isListening)\n        {\n            CancelRemapping();\n        }\n    }\n\n    private void ShowStatus(string message, Color color)\n    {\n        if (_statusText != null)\n        {\n            _statusText.text = message;\n            _statusText.color = color;\n            CancelInvoke(nameof(ClearStatus));\n            Invoke(nameof(ClearStatus), 3f);\n        }\n    }\n\n    private void ClearStatus()\n    {\n        if (_statusText != null)\n        {\n            _statusText.text = \"\";\n        }\n    }\n\n    [System.Serializable]\n    private class SerializableKeyMappings\n    {\n        public List<string> keys = new List<string>();\n        public List<KeyCode> values = new List<KeyCode>();\n\n        public SerializableKeyMappings(Dictionary<string, KeyCode> mappings)\n        {\n            foreach (var mapping in mappings)\n            {\n                keys.Add(mapping.Key);\n                values.Add(mapping.Value);\n            }\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_resetButton != null)\n            _resetButton.onClick.RemoveAllListeners();\n            \n        if (_saveButton != null)\n            _saveButton.onClick.RemoveAllListeners();\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.RemoveAllListeners();\n\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.remapButton != null)\n                binding.remapButton.onClick.RemoveAllListeners();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "language localization",
      "ideal_ir": {
        "class_name": "LanguageLocalization",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "currentLanguage",
            "type": "string",
            "default": "English"
          },
          {
            "name": "supportedLanguages",
            "type": "string[]",
            "default": [
              "English",
              "Spanish",
              "French",
              "German",
              "Japanese"
            ]
          },
          {
            "name": "textDatabase",
            "type": "Dictionary<string, Dictionary<string, string>>",
            "default": null
          },
          {
            "name": "fallbackLanguage",
            "type": "string",
            "default": "English"
          },
          {
            "name": "autoDetectSystemLanguage",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "initialize_localization",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "load text database from resources"
              },
              {
                "action": "detect system language if auto detect is enabled"
              },
              {
                "action": "set current language to detected language if supported"
              },
              {
                "action": "set current language to fallback if detection fails"
              },
              {
                "action": "notify all localized text components of language change"
              }
            ]
          },
          {
            "name": "change_language",
            "trigger": "when language change is requested",
            "actions": [
              {
                "action": "check if requested language is supported"
              },
              {
                "action": "update current language to requested language"
              },
              {
                "action": "save language preference to player preferences"
              },
              {
                "action": "broadcast language changed event to all listeners"
              },
              {
                "action": "refresh all localized text in scene"
              }
            ]
          },
          {
            "name": "get_localized_text",
            "trigger": "when localized text is requested with key",
            "actions": [
              {
                "action": "look up text key in current language dictionary"
              },
              {
                "action": "return localized text if key exists"
              },
              {
                "action": "fallback to default language if key not found in current language"
              },
              {
                "action": "return key itself if not found in any language"
              },
              {
                "action": "log warning if key is missing from all languages"
              }
            ]
          },
          {
            "name": "load_language_data",
            "trigger": "when language data needs to be loaded",
            "actions": [
              {
                "action": "read localization files from streaming assets"
              },
              {
                "action": "parse JSON or CSV language data"
              },
              {
                "action": "populate text database with key value pairs"
              },
              {
                "action": "validate all supported languages have required keys"
              },
              {
                "action": "cache loaded data for quick access"
              }
            ]
          },
          {
            "name": "handle_missing_translation",
            "trigger": "when translation key is not found",
            "actions": [
              {
                "action": "attempt to use fallback language translation"
              },
              {
                "action": "display original key as placeholder text"
              },
              {
                "action": "log missing translation for debugging"
              },
              {
                "action": "add missing key to translation report"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\n[System.Serializable]\npublic class LocalizedString\n{\n    public string key;\n    public string defaultValue;\n    \n    public LocalizedString(string key, string defaultValue = \"\")\n    {\n        this.key = key;\n        this.defaultValue = defaultValue;\n    }\n}\n\n[System.Serializable]\npublic class LanguageData\n{\n    public string languageCode;\n    public string languageName;\n    public Dictionary<string, string> translations = new Dictionary<string, string>();\n}\n\n[System.Serializable]\npublic class TranslationEntry\n{\n    public string key;\n    public string value;\n}\n\n[System.Serializable]\npublic class LanguageFile\n{\n    public string languageCode;\n    public string languageName;\n    public List<TranslationEntry> translations = new List<TranslationEntry>();\n}\n\npublic class LocalizationManager : MonoBehaviour\n{\n    [Header(\"Language Settings\")]\n    [SerializeField] private string _currentLanguageCode = \"en\";\n    [SerializeField] private string _fallbackLanguageCode = \"en\";\n    [SerializeField] private bool _autoDetectSystemLanguage = true;\n    \n    [Header(\"Language Files\")]\n    [SerializeField] private List<TextAsset> _languageFiles = new List<TextAsset>();\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnLanguageChanged = new UnityEvent<string>();\n    \n    private Dictionary<string, LanguageData> _languages = new Dictionary<string, LanguageData>();\n    private Dictionary<string, string> _currentTranslations = new Dictionary<string, string>();\n    \n    public static LocalizationManager Instance { get; private set; }\n    \n    public string CurrentLanguage => _currentLanguageCode;\n    public List<string> AvailableLanguages => new List<string>(_languages.Keys);\n    \n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n            InitializeLocalization();\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void Start()\n    {\n        LoadLanguageFiles();\n        \n        if (_autoDetectSystemLanguage)\n        {\n            DetectSystemLanguage();\n        }\n        \n        SetLanguage(_currentLanguageCode);\n    }\n    \n    private void InitializeLocalization()\n    {\n        _languages.Clear();\n        _currentTranslations.Clear();\n        \n        // Load saved language preference\n        string savedLanguage = PlayerPrefs.GetString(\"LocalizationLanguage\", \"\");\n        if (!string.IsNullOrEmpty(savedLanguage))\n        {\n            _currentLanguageCode = savedLanguage;\n        }\n    }\n    \n    private void LoadLanguageFiles()\n    {\n        foreach (TextAsset languageFile in _languageFiles)\n        {\n            if (languageFile == null) continue;\n            \n            try\n            {\n                LanguageFile langFile = JsonUtility.FromJson<LanguageFile>(languageFile.text);\n                \n                if (!_languages.ContainsKey(langFile.languageCode))\n                {\n                    _languages[langFile.languageCode] = new LanguageData\n                    {\n                        languageCode = langFile.languageCode,\n                        languageName = langFile.languageName\n                    };\n                }\n                \n                foreach (TranslationEntry entry in langFile.translations)\n                {\n                    _languages[langFile.languageCode].translations[entry.key] = entry.value;\n                }\n                \n                Debug.Log($\"Loaded language: {langFile.languageName} ({langFile.languageCode}) with {langFile.translations.Count} translations\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"Failed to load language file {languageFile.name}: {e.Message}\");\n            }\n        }\n    }\n    \n    private void DetectSystemLanguage()\n    {\n        SystemLanguage systemLang = Application.systemLanguage;\n        string detectedCode = GetLanguageCode(systemLang);\n        \n        if (_languages.ContainsKey(detectedCode))\n        {\n            _currentLanguageCode = detectedCode;\n        }\n    }\n    \n    private string GetLanguageCode(SystemLanguage systemLanguage)\n    {\n        switch (systemLanguage)\n        {\n            case SystemLanguage.English: return \"en\";\n            case SystemLanguage.Spanish: return \"es\";\n            case SystemLanguage.French: return \"fr\";\n            case SystemLanguage.German: return \"de\";\n            case SystemLanguage.Italian: return \"it\";\n            case SystemLanguage.Portuguese: return \"pt\";\n            case SystemLanguage.Russian: return \"ru\";\n            case SystemLanguage.Japanese: return \"ja\";\n            case SystemLanguage.Korean: return \"ko\";\n            case SystemLanguage.Chinese: return \"zh\";\n            case SystemLanguage.ChineseSimplified: return \"zh-CN\";\n            case SystemLanguage.ChineseTraditional: return \"zh-TW\";\n            case SystemLanguage.Dutch: return \"nl\";\n            case SystemLanguage.Polish: return \"pl\";\n            case SystemLanguage.Swedish: return \"sv\";\n            case SystemLanguage.Norwegian: return \"no\";\n            case SystemLanguage.Danish: return \"da\";\n            case SystemLanguage.Finnish: return \"fi\";\n            case SystemLanguage.Turkish: return \"tr\";\n            case SystemLanguage.Arabic: return \"ar\";\n            case SystemLanguage.Hebrew: return \"he\";\n            case SystemLanguage.Thai: return \"th\";\n            case SystemLanguage.Vietnamese: return \"vi\";\n            default: return \"en\";\n        }\n    }\n    \n    public bool SetLanguage(string languageCode)\n    {\n        if (!_languages.ContainsKey(languageCode))\n        {\n            Debug.LogWarning($\"Language '{languageCode}' not found. Using fallback language '{_fallbackLanguageCode}'\");\n            languageCode = _fallbackLanguageCode;\n            \n            if (!_languages.ContainsKey(languageCode))\n            {\n                Debug.LogError($\"Fallback language '{_fallbackLanguageCode}' not found!\");\n                return false;\n            }\n        }\n        \n        _currentLanguageCode = languageCode;\n        _currentTranslations = new Dictionary<string, string>(_languages[languageCode].translations);\n        \n        // Save language preference\n        PlayerPrefs.SetString(\"LocalizationLanguage\", languageCode);\n        PlayerPrefs.Save();\n        \n        OnLanguageChanged.Invoke(languageCode);\n        \n        Debug.Log($\"Language changed to: {GetLanguageName(languageCode)} ({languageCode})\");\n        return true;\n    }\n    \n    public string GetLocalizedString(string key, params object[] args)\n    {\n        if (string.IsNullOrEmpty(key))\n        {\n            return \"\";\n        }\n        \n        string localizedText = \"\";\n        \n        // Try current language\n        if (_currentTranslations.ContainsKey(key))\n        {\n            localizedText = _currentTranslations[key];\n        }\n        // Try fallback language\n        else if (_languages.ContainsKey(_fallbackLanguageCode) && \n                 _languages[_fallbackLanguageCode].translations.ContainsKey(key))\n        {\n            localizedText = _languages[_fallbackLanguageCode].translations[key];\n        }\n        // Return key if no translation found\n        else\n        {\n            Debug.LogWarning($\"Translation not found for key: {key}\");\n            return $\"[{key}]\";\n        }\n        \n        // Format string with arguments if provided\n        if (args != null && args.Length > 0)\n        {\n            try\n            {\n                localizedText = string.Format(localizedText, args);\n            }\n            catch (FormatException e)\n            {\n                Debug.LogError($\"String formatting error for key '{key}': {e.Message}\");\n                return localizedText;\n            }\n        }\n        \n        return localizedText;\n    }\n    \n    public string GetLocalizedString(LocalizedString localizedString, params object[] args)\n    {\n        if (localizedString == null)\n        {\n            return \"\";\n        }\n        \n        string result = GetLocalizedString(localizedString.key, args);\n        \n        // Return default value if translation not found and default is provided\n        if (result.StartsWith(\"[\") && result.EndsWith(\"]\") && !string.IsNullOrEmpty(localizedString.defaultValue))\n        {\n            return localizedString.defaultValue;\n        }\n        \n        return result;\n    }\n    \n    public string GetLanguageName(string languageCode)\n    {\n        if (_languages.ContainsKey(languageCode))\n        {\n            return _languages[languageCode].languageName;\n        }\n        return languageCode;\n    }\n    \n    public bool HasTranslation(string key)\n    {\n        return _currentTranslations.ContainsKey(key) || \n               (_languages.ContainsKey(_fallbackLanguageCode) && \n                _languages[_fallbackLanguageCode].translations.ContainsKey(key));\n    }\n    \n    public void AddTranslation(string languageCode, string key, string value)\n    {\n        if (!_languages.ContainsKey(languageCode))\n        {\n            _languages[languageCode] = new LanguageData\n            {\n                languageCode = languageCode,\n                languageName = languageCode\n            };\n        }\n        \n        _languages[languageCode].translations[key] = value;\n        \n        // Update current translations if this is the active language\n        if (languageCode == _currentLanguageCode)\n        {\n            _currentTranslations[key] = value;\n        }\n    }\n    \n    public void RemoveTranslation(string key)\n    {\n        foreach (var language in _languages.Values)\n        {\n            language.translations.Remove(key);\n        }\n        \n        _currentTranslations.Remove(key);\n    }\n    \n    public Dictionary<string, string> GetAllTranslations(string languageCode)\n    {\n        if (_languages.ContainsKey(languageCode))\n        {\n            return new Dictionary<string, string>(_languages[languageCode].translations);\n        }\n        return new Dictionary<string, string>();\n    }\n    \n    public void RefreshAllLocalizedComponents()\n    {\n        LocalizedText[] localizedTexts = FindObjectsOfType<LocalizedText>();\n        foreach (LocalizedText localizedText in localizedTexts)\n        {\n            localizedText.UpdateText();\n        }\n    }\n    \n    [ContextMenu(\"Reload Language Files\")]\n    private void ReloadLanguageFiles()\n    {\n        LoadLanguageFiles();\n        SetLanguage(_currentLanguageCode);\n        RefreshAllLocalizedComponents();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "credits scroll",
      "ideal_ir": {
        "class_name": "CreditsScroll",
        "components": [
          "RectTransform",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "scrollSpeed",
            "type": "float",
            "default": 50
          },
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 1
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "default": 1
          },
          {
            "name": "startDelay",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "start_credits_sequence",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "set initial transparency to zero"
              },
              {
                "action": "wait for start delay duration"
              },
              {
                "action": "fade in credits text over fade in duration"
              }
            ]
          },
          {
            "name": "scroll_credits_upward",
            "trigger": "continuously while credits are visible",
            "actions": [
              {
                "action": "move credits text upward at scroll speed"
              }
            ]
          },
          {
            "name": "fade_out_when_complete",
            "trigger": "when credits text has scrolled completely off screen",
            "actions": [
              {
                "action": "fade out credits text over fade out duration"
              },
              {
                "action": "disable credits display when fade out completes"
              }
            ]
          },
          {
            "name": "skip_credits",
            "trigger": "when any key is pressed or screen is touched",
            "actions": [
              {
                "action": "immediately fade out credits"
              },
              {
                "action": "disable credits display"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class CreditsScroll : MonoBehaviour\n{\n    [Header(\"Scroll Settings\")]\n    [SerializeField] private float _scrollSpeed = 50f;\n    [SerializeField] private float _startDelay = 1f;\n    [SerializeField] private bool _autoStart = true;\n    [SerializeField] private bool _loopCredits = false;\n    \n    [Header(\"Boundaries\")]\n    [SerializeField] private float _startYPosition = -500f;\n    [SerializeField] private float _endYPosition = 1000f;\n    [SerializeField] private bool _useScreenBounds = true;\n    \n    [Header(\"Control Settings\")]\n    [SerializeField] private KeyCode _skipKey = KeyCode.Escape;\n    [SerializeField] private KeyCode _pauseKey = KeyCode.Space;\n    [SerializeField] private float _mouseScrollSensitivity = 100f;\n    [SerializeField] private bool _allowManualControl = true;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onCreditsStart = new UnityEvent();\n    [SerializeField] private UnityEvent _onCreditsComplete = new UnityEvent();\n    [SerializeField] private UnityEvent _onCreditsSkipped = new UnityEvent();\n    \n    private RectTransform _rectTransform;\n    private Canvas _parentCanvas;\n    private bool _isScrolling = false;\n    private bool _isPaused = false;\n    private float _currentSpeed;\n    private Vector3 _initialPosition;\n    private Coroutine _scrollCoroutine;\n    \n    private void Awake()\n    {\n        _rectTransform = GetComponent<RectTransform>();\n        if (_rectTransform == null)\n        {\n            Debug.LogError(\"CreditsScroll requires a RectTransform component!\");\n            enabled = false;\n            return;\n        }\n        \n        _parentCanvas = GetComponentInParent<Canvas>();\n        _currentSpeed = _scrollSpeed;\n        _initialPosition = _rectTransform.anchoredPosition;\n    }\n    \n    private void Start()\n    {\n        SetupInitialPosition();\n        \n        if (_autoStart)\n        {\n            StartCredits();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isScrolling) return;\n        \n        HandleInput();\n        \n        if (_allowManualControl && !_isPaused)\n        {\n            HandleManualScroll();\n        }\n    }\n    \n    private void SetupInitialPosition()\n    {\n        if (_useScreenBounds && _parentCanvas != null)\n        {\n            RectTransform canvasRect = _parentCanvas.GetComponent<RectTransform>();\n            if (canvasRect != null)\n            {\n                _startYPosition = -canvasRect.rect.height / 2 - _rectTransform.rect.height / 2;\n                _endYPosition = canvasRect.rect.height / 2 + _rectTransform.rect.height / 2;\n            }\n        }\n        \n        Vector3 startPos = _rectTransform.anchoredPosition;\n        startPos.y = _startYPosition;\n        _rectTransform.anchoredPosition = startPos;\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_skipKey))\n        {\n            SkipCredits();\n        }\n        \n        if (Input.GetKeyDown(_pauseKey))\n        {\n            TogglePause();\n        }\n    }\n    \n    private void HandleManualScroll()\n    {\n        float scrollInput = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scrollInput) > 0.01f)\n        {\n            Vector3 currentPos = _rectTransform.anchoredPosition;\n            currentPos.y += scrollInput * _mouseScrollSensitivity;\n            currentPos.y = Mathf.Clamp(currentPos.y, _startYPosition, _endYPosition);\n            _rectTransform.anchoredPosition = currentPos;\n        }\n    }\n    \n    public void StartCredits()\n    {\n        if (_isScrolling) return;\n        \n        _isScrolling = true;\n        _isPaused = false;\n        _onCreditsStart.Invoke();\n        \n        if (_scrollCoroutine != null)\n        {\n            StopCoroutine(_scrollCoroutine);\n        }\n        \n        _scrollCoroutine = StartCoroutine(ScrollCreditsCoroutine());\n    }\n    \n    public void StopCredits()\n    {\n        if (_scrollCoroutine != null)\n        {\n            StopCoroutine(_scrollCoroutine);\n            _scrollCoroutine = null;\n        }\n        \n        _isScrolling = false;\n        _isPaused = false;\n    }\n    \n    public void SkipCredits()\n    {\n        if (!_isScrolling) return;\n        \n        StopCredits();\n        _onCreditsSkipped.Invoke();\n        \n        if (_loopCredits)\n        {\n            ResetPosition();\n            StartCredits();\n        }\n    }\n    \n    public void TogglePause()\n    {\n        if (!_isScrolling) return;\n        \n        _isPaused = !_isPaused;\n    }\n    \n    public void SetScrollSpeed(float speed)\n    {\n        _scrollSpeed = Mathf.Max(0f, speed);\n        _currentSpeed = _scrollSpeed;\n    }\n    \n    public void ResetPosition()\n    {\n        Vector3 resetPos = _rectTransform.anchoredPosition;\n        resetPos.y = _startYPosition;\n        _rectTransform.anchoredPosition = resetPos;\n    }\n    \n    private IEnumerator ScrollCreditsCoroutine()\n    {\n        yield return new WaitForSeconds(_startDelay);\n        \n        while (_isScrolling)\n        {\n            if (!_isPaused)\n            {\n                Vector3 currentPos = _rectTransform.anchoredPosition;\n                currentPos.y += _currentSpeed * Time.deltaTime;\n                _rectTransform.anchoredPosition = currentPos;\n                \n                if (currentPos.y >= _endYPosition)\n                {\n                    _onCreditsComplete.Invoke();\n                    \n                    if (_loopCredits)\n                    {\n                        ResetPosition();\n                        yield return new WaitForSeconds(_startDelay);\n                    }\n                    else\n                    {\n                        StopCredits();\n                        break;\n                    }\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_scrollSpeed < 0f)\n            _scrollSpeed = 0f;\n            \n        if (_mouseScrollSensitivity < 0f)\n            _mouseScrollSensitivity = 0f;\n            \n        if (_startDelay < 0f)\n            _startDelay = 0f;\n    }\n    \n    private void OnDisable()\n    {\n        StopCredits();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "main menu navigation",
      "ideal_ir": {
        "class_name": "MainMenuNavigation",
        "components": [
          "Canvas",
          "GraphicRaycaster",
          "EventSystem"
        ],
        "fields": [
          {
            "name": "selectedButtonIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "totalButtons",
            "type": "int",
            "default": 4
          },
          {
            "name": "navigationSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "selectionSound",
            "type": "AudioClip",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "navigate_up",
            "trigger": "when up arrow key or gamepad up is pressed",
            "actions": [
              {
                "action": "move selection to previous button in list"
              },
              {
                "action": "wrap to last button if at first button"
              },
              {
                "action": "play navigation sound"
              },
              {
                "action": "highlight selected button"
              }
            ]
          },
          {
            "name": "navigate_down",
            "trigger": "when down arrow key or gamepad down is pressed",
            "actions": [
              {
                "action": "move selection to next button in list"
              },
              {
                "action": "wrap to first button if at last button"
              },
              {
                "action": "play navigation sound"
              },
              {
                "action": "highlight selected button"
              }
            ]
          },
          {
            "name": "confirm_selection",
            "trigger": "when enter key or gamepad A button is pressed",
            "actions": [
              {
                "action": "play selection sound"
              },
              {
                "action": "execute action of currently selected button"
              },
              {
                "action": "add button press visual feedback"
              }
            ]
          },
          {
            "name": "mouse_hover",
            "trigger": "when mouse cursor hovers over any menu button",
            "actions": [
              {
                "action": "update selected button index to hovered button"
              },
              {
                "action": "highlight hovered button"
              },
              {
                "action": "play navigation sound"
              }
            ]
          },
          {
            "name": "initialize_menu",
            "trigger": "when menu becomes active",
            "actions": [
              {
                "action": "set first button as selected"
              },
              {
                "action": "highlight first button"
              },
              {
                "action": "ensure all other buttons are unhighlighted"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing UnityEngine.Audio;\nusing System.Collections;\n\npublic class MainMenuNavigation : MonoBehaviour\n{\n    [Header(\"Menu Panels\")]\n    [SerializeField] private GameObject _mainMenuPanel;\n    [SerializeField] private GameObject _settingsPanel;\n    [SerializeField] private GameObject _creditsPanel;\n    [SerializeField] private GameObject _loadingPanel;\n    \n    [Header(\"Main Menu Buttons\")]\n    [SerializeField] private Button _playButton;\n    [SerializeField] private Button _settingsButton;\n    [SerializeField] private Button _creditsButton;\n    [SerializeField] private Button _quitButton;\n    \n    [Header(\"Settings UI\")]\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Button _settingsBackButton;\n    \n    [Header(\"Credits UI\")]\n    [SerializeField] private Button _creditsBackButton;\n    [SerializeField] private ScrollRect _creditsScrollRect;\n    \n    [Header(\"Loading UI\")]\n    [SerializeField] private Slider _loadingProgressBar;\n    [SerializeField] private Text _loadingText;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private AudioSource _buttonClickSound;\n    [SerializeField] private AudioSource _backgroundMusic;\n    \n    [Header(\"Scene Management\")]\n    [SerializeField] private string _gameSceneName = \"GameScene\";\n    [SerializeField] private float _loadingDelay = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _panelTransitionSpeed = 0.3f;\n    [SerializeField] private AnimationCurve _transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Resolution[] _availableResolutions;\n    private bool _isTransitioning = false;\n    \n    private void Start()\n    {\n        InitializeMenu();\n        SetupButtonListeners();\n        LoadSettings();\n        SetupResolutions();\n    }\n    \n    private void InitializeMenu()\n    {\n        ShowPanel(_mainMenuPanel);\n        HidePanel(_settingsPanel);\n        HidePanel(_creditsPanel);\n        HidePanel(_loadingPanel);\n        \n        if (_backgroundMusic != null && !_backgroundMusic.isPlaying)\n        {\n            _backgroundMusic.Play();\n        }\n    }\n    \n    private void SetupButtonListeners()\n    {\n        if (_playButton != null)\n            _playButton.onClick.AddListener(OnPlayButtonClicked);\n        \n        if (_settingsButton != null)\n            _settingsButton.onClick.AddListener(OnSettingsButtonClicked);\n        \n        if (_creditsButton != null)\n            _creditsButton.onClick.AddListener(OnCreditsButtonClicked);\n        \n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(OnQuitButtonClicked);\n        \n        if (_settingsBackButton != null)\n            _settingsBackButton.onClick.AddListener(OnSettingsBackButtonClicked);\n        \n        if (_creditsBackButton != null)\n            _creditsBackButton.onClick.AddListener(OnCreditsBackButtonClicked);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.AddListener(OnMasterVolumeChanged);\n        \n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.AddListener(OnMusicVolumeChanged);\n        \n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.AddListener(OnSFXVolumeChanged);\n        \n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(OnResolutionChanged);\n        \n        if (_fullscreenToggle != null)\n            _fullscreenToggle.onValueChanged.AddListener(OnFullscreenToggled);\n    }\n    \n    private void SetupResolutions()\n    {\n        if (_resolutionDropdown == null) return;\n        \n        _availableResolutions = Screen.resolutions;\n        _resolutionDropdown.ClearOptions();\n        \n        var options = new System.Collections.Generic.List<string>();\n        int currentResolutionIndex = 0;\n        \n        for (int i = 0; i < _availableResolutions.Length; i++)\n        {\n            string option = _availableResolutions[i].width + \" x \" + _availableResolutions[i].height;\n            options.Add(option);\n            \n            if (_availableResolutions[i].width == Screen.currentResolution.width &&\n                _availableResolutions[i].height == Screen.currentResolution.height)\n            {\n                currentResolutionIndex = i;\n            }\n        }\n        \n        _resolutionDropdown.AddOptions(options);\n        _resolutionDropdown.value = currentResolutionIndex;\n        _resolutionDropdown.RefreshShownValue();\n    }\n    \n    private void LoadSettings()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            float masterVolume = PlayerPrefs.GetFloat(\"MasterVolume\", 0.75f);\n            _masterVolumeSlider.value = masterVolume;\n            OnMasterVolumeChanged(masterVolume);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            float musicVolume = PlayerPrefs.GetFloat(\"MusicVolume\", 0.75f);\n            _musicVolumeSlider.value = musicVolume;\n            OnMusicVolumeChanged(musicVolume);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            float sfxVolume = PlayerPrefs.GetFloat(\"SFXVolume\", 0.75f);\n            _sfxVolumeSlider.value = sfxVolume;\n            OnSFXVolumeChanged(sfxVolume);\n        }\n        \n        if (_fullscreenToggle != null)\n        {\n            bool isFullscreen = PlayerPrefs.GetInt(\"Fullscreen\", 1) == 1;\n            _fullscreenToggle.isOn = isFullscreen;\n        }\n    }\n    \n    private void SaveSettings()\n    {\n        if (_masterVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MasterVolume\", _masterVolumeSlider.value);\n        \n        if (_musicVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MusicVolume\", _musicVolumeSlider.value);\n        \n        if (_sfxVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"SFXVolume\", _sfxVolumeSlider.value);\n        \n        if (_fullscreenToggle != null)\n            PlayerPrefs.SetInt(\"Fullscreen\", _fullscreenToggle.isOn ? 1 : 0);\n        \n        PlayerPrefs.Save();\n    }\n    \n    public void OnPlayButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(LoadGameScene());\n    }\n    \n    public void OnSettingsButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_settingsPanel));\n    }\n    \n    public void OnCreditsButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_creditsPanel));\n    }\n    \n    public void OnQuitButtonClicked()\n    {\n        PlayButtonSound();\n        \n        #if UNITY_EDITOR\n            UnityEditor.EditorApplication.isPlaying = false;\n        #else\n            Application.Quit();\n        #endif\n    }\n    \n    public void OnSettingsBackButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        SaveSettings();\n        StartCoroutine(TransitionToPanel(_mainMenuPanel));\n    }\n    \n    public void OnCreditsBackButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_mainMenuPanel));\n    }\n    \n    public void OnMasterVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"MasterVolume\", dbValue);\n        }\n    }\n    \n    public void OnMusicVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"MusicVolume\", dbValue);\n        }\n    }\n    \n    public void OnSFXVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"SFXVolume\", dbValue);\n        }\n    }\n    \n    public void OnResolutionChanged(int resolutionIndex)\n    {\n        if (_availableResolutions != null && resolutionIndex < _availableResolutions.Length)\n        {\n            Resolution resolution = _availableResolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);\n        }\n    }\n    \n    public void OnFullscreenToggled(bool isFullscreen)\n    {\n        Screen.fullScreen = isFullscreen;\n    }\n    \n    private void PlayButtonSound()\n    {\n        if (_buttonClickSound != null)\n        {\n            _buttonClickSound.Play();\n        }\n    }\n    \n    private void ShowPanel(GameObject panel)\n    {\n        if (panel != null)\n        {\n            panel.SetActive(true);\n            var canvasGroup = panel.GetComponent<CanvasGroup>();\n            if (canvasGroup != null)\n            {\n                canvasGroup.alpha = 1f;\n                canvasGroup.interactable = true;\n                canvasGroup.blocksRaycasts = true;\n            }\n        }\n    }\n    \n    private void HidePanel(GameObject panel)\n    {\n        if (panel != null)\n        {\n            var canvasGroup = panel.GetComponent<CanvasGroup>();\n            if (canvasGroup != null)\n            {\n                canvasGroup.alpha = 0f;\n                canvasGroup.interactable = false;\n                canvasGroup.blocksRaycasts = false;\n            }\n            panel.SetActive(false);\n        }\n    }\n    \n    private IEnumerator TransitionToPanel(GameObject targetPanel)\n    {\n        _isTransitioning = true;\n        \n        GameObject currentPanel = GetCurrentActivePanel();\n        \n        if (currentPanel != null)\n        {\n            yield return StartCoroutine(FadeOutPanel(currentPanel));\n        }\n        \n        if (targetPanel != null)\n        {\n            yield return StartCoroutine(FadeInPanel(targetPanel));\n        }\n        \n        _isTransitioning = false;\n    }\n    \n    private GameObject GetCurrentActivePanel()\n    {\n        if (_mainMenuPanel != null && _mainMenuPanel.activeInHierarchy) return _mainMenuPanel;\n        if (_settingsPanel != null && _settingsPanel.activeInHierarchy) return _settingsPanel;\n        if (_creditsPanel != null && _creditsPanel.activeInHierarchy) return _creditsPanel;\n        return null;\n    }\n    \n    private IEnumerator FadeOutPanel(GameObject panel)\n    {\n        var canvasGroup = panel.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = panel.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.interactable = false;\n        \n        float elapsedTime = 0f;\n        float startAlpha = canvasGroup.alpha;\n        \n        while (elapsedTime < _panelTransitionSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _panelTransitionSpeed;\n            canvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, _transitionCurve.Evaluate(progress));\n            yield return null;\n        }\n        \n        canvasGroup.alpha = 0f;\n        canvasGroup.blocksRaycasts = false;\n        panel.SetActive(false);\n    }\n    \n    private IEnumerator FadeInPanel(GameObject panel)\n    {\n        panel.SetActive(true);\n        \n        var canvasGroup = panel.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = panel.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.alpha = 0f;\n        canvasGroup.blocksRaycasts = true;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _panelTransitionSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _panelTransitionSpeed;\n            canvasGroup.alpha = _transitionCurve.Evaluate(progress);\n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        canvasGroup.interactable = true;\n    }\n    \n    private IEnumerator LoadGameScene()\n    {\n        ShowPanel(_loadingPanel);\n        HidePanel(_mainMenuPanel);\n        \n        yield return new WaitForSeconds(_loadingDelay);\n        \n        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(_gameSceneName);\n        asyncLoad.allowSceneActivation = false;\n        \n        while (!asyncLoad.isDone)\n        {\n            float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f);\n            \n            if (_loadingProgressBar != null)\n            {\n                _loadingProgressBar.value = progress;\n            }\n            \n            if (_loadingText != null)\n            {\n                _loadingText.text = \"Loading... \" + Mathf.Round(progress * 100f) + \"%\";\n            }\n            \n            if (asyncLoad.progress >= 0.9f)\n            {\n                if (_loadingText != null)\n                {\n                    _loadingText.text = \"Press any key to continue...\";\n                }\n                \n                if (Input.anyKeyDown)\n                {\n                    asyncLoad.allowSceneActivation = true;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            HandleEscapeKey();\n        }\n    }\n    \n    private void HandleEscapeKey()\n    {\n        if (_isTransitioning) return;\n        \n        if (_settingsPanel != null && _settingsPanel.activeInHier",
      "behavior_type": "combat"
    },
    {
      "prompt": "loading screen with progress",
      "ideal_ir": {
        "class_name": "LoadingScreen",
        "components": [
          "Canvas",
          "Image",
          "Slider",
          "Text"
        ],
        "fields": [
          {
            "name": "progressBar",
            "type": "Slider",
            "default": null
          },
          {
            "name": "progressText",
            "type": "Text",
            "default": null
          },
          {
            "name": "backgroundImage",
            "type": "Image",
            "default": null
          },
          {
            "name": "loadingSpeed",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "currentProgress",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "targetProgress",
            "type": "float",
            "default": 0.0
          }
        ],
        "behaviors": [
          {
            "name": "initialize_loading_screen",
            "trigger": "when loading screen starts",
            "actions": [
              {
                "action": "set progress bar value to zero"
              },
              {
                "action": "set progress text to show zero percent"
              },
              {
                "action": "make loading screen visible"
              }
            ]
          },
          {
            "name": "update_progress",
            "trigger": "when target progress value changes",
            "actions": [
              {
                "action": "smoothly animate progress bar toward target value"
              },
              {
                "action": "update progress text to show current percentage"
              },
              {
                "action": "display loading status message"
              }
            ]
          },
          {
            "name": "complete_loading",
            "trigger": "when progress reaches one hundred percent",
            "actions": [
              {
                "action": "show completion message"
              },
              {
                "action": "wait for brief moment"
              },
              {
                "action": "fade out loading screen"
              },
              {
                "action": "hide loading screen completely"
              }
            ]
          },
          {
            "name": "animate_progress_bar",
            "trigger": "every frame while loading is active",
            "actions": [
              {
                "action": "gradually increase current progress toward target progress"
              },
              {
                "action": "update progress bar fill amount"
              },
              {
                "action": "ensure smooth visual transition"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class LoadingScreen : MonoBehaviour\n{\n    [Header(\"UI Elements\")]\n    [SerializeField] private Slider _progressBar;\n    [SerializeField] private Text _progressText;\n    [SerializeField] private Text _loadingStatusText;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private GameObject _loadingPanel;\n    \n    [Header(\"Loading Settings\")]\n    [SerializeField] private string _sceneToLoad = \"MainScene\";\n    [SerializeField] private float _minimumLoadTime = 2f;\n    [SerializeField] private float _progressUpdateSpeed = 2f;\n    [SerializeField] private bool _allowSceneActivation = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private AnimationCurve _progressCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private Color _progressBarColor = Color.green;\n    [SerializeField] private Color _backgroundColor = Color.black;\n    \n    [Header(\"Loading Messages\")]\n    [SerializeField] private string[] _loadingMessages = {\n        \"Loading assets...\",\n        \"Preparing scene...\",\n        \"Initializing systems...\",\n        \"Almost ready...\"\n    };\n    \n    private AsyncOperation _loadOperation;\n    private float _targetProgress;\n    private float _currentProgress;\n    private float _loadStartTime;\n    private bool _isLoading;\n    private int _currentMessageIndex;\n    private Coroutine _messageUpdateCoroutine;\n    \n    private void Start()\n    {\n        InitializeLoadingScreen();\n        StartLoading();\n    }\n    \n    private void Update()\n    {\n        if (_isLoading)\n        {\n            UpdateProgress();\n            UpdateLoadingStatus();\n        }\n    }\n    \n    private void InitializeLoadingScreen()\n    {\n        if (_loadingPanel != null)\n            _loadingPanel.SetActive(true);\n            \n        if (_backgroundImage != null)\n            _backgroundImage.color = _backgroundColor;\n            \n        if (_progressBar != null)\n        {\n            _progressBar.value = 0f;\n            if (_progressBar.fillRect != null)\n                _progressBar.fillRect.GetComponent<Image>().color = _progressBarColor;\n        }\n        \n        if (_progressText != null)\n            _progressText.text = \"0%\";\n            \n        if (_loadingStatusText != null && _loadingMessages.Length > 0)\n            _loadingStatusText.text = _loadingMessages[0];\n            \n        _currentProgress = 0f;\n        _targetProgress = 0f;\n        _loadStartTime = Time.time;\n        _currentMessageIndex = 0;\n    }\n    \n    public void StartLoading()\n    {\n        if (_isLoading) return;\n        \n        _isLoading = true;\n        _loadStartTime = Time.time;\n        \n        StartCoroutine(LoadSceneAsync());\n        \n        if (_loadingMessages.Length > 1)\n            _messageUpdateCoroutine = StartCoroutine(UpdateLoadingMessages());\n    }\n    \n    public void LoadScene(string sceneName)\n    {\n        _sceneToLoad = sceneName;\n        StartLoading();\n    }\n    \n    private IEnumerator LoadSceneAsync()\n    {\n        yield return new WaitForEndOfFrame();\n        \n        _loadOperation = SceneManager.LoadSceneAsync(_sceneToLoad);\n        _loadOperation.allowSceneActivation = false;\n        \n        while (!_loadOperation.isDone)\n        {\n            float progress = Mathf.Clamp01(_loadOperation.progress / 0.9f);\n            _targetProgress = progress;\n            \n            if (_loadOperation.progress >= 0.9f)\n            {\n                _targetProgress = 1f;\n                \n                float elapsedTime = Time.time - _loadStartTime;\n                if (elapsedTime >= _minimumLoadTime && _allowSceneActivation)\n                {\n                    yield return new WaitForSeconds(0.5f);\n                    _loadOperation.allowSceneActivation = true;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void UpdateProgress()\n    {\n        if (_currentProgress < _targetProgress)\n        {\n            _currentProgress = Mathf.MoveTowards(_currentProgress, _targetProgress, \n                Time.deltaTime * _progressUpdateSpeed);\n        }\n        \n        float curvedProgress = _progressCurve.Evaluate(_currentProgress);\n        \n        if (_progressBar != null)\n            _progressBar.value = curvedProgress;\n            \n        if (_progressText != null)\n        {\n            int percentage = Mathf.RoundToInt(curvedProgress * 100f);\n            _progressText.text = percentage + \"%\";\n        }\n    }\n    \n    private void UpdateLoadingStatus()\n    {\n        if (_loadingStatusText == null || _loadingMessages.Length == 0) return;\n        \n        int expectedMessageIndex = Mathf.FloorToInt(_currentProgress * (_loadingMessages.Length - 1));\n        expectedMessageIndex = Mathf.Clamp(expectedMessageIndex, 0, _loadingMessages.Length - 1);\n        \n        if (expectedMessageIndex != _currentMessageIndex)\n        {\n            _currentMessageIndex = expectedMessageIndex;\n            _loadingStatusText.text = _loadingMessages[_currentMessageIndex];\n        }\n    }\n    \n    private IEnumerator UpdateLoadingMessages()\n    {\n        while (_isLoading && _currentProgress < 1f)\n        {\n            yield return new WaitForSeconds(Random.Range(1f, 3f));\n            \n            if (_loadingStatusText != null && _loadingMessages.Length > 0)\n            {\n                int nextIndex = (_currentMessageIndex + 1) % _loadingMessages.Length;\n                if (_currentProgress >= (float)nextIndex / _loadingMessages.Length)\n                {\n                    _currentMessageIndex = nextIndex;\n                    _loadingStatusText.text = _loadingMessages[_currentMessageIndex];\n                }\n            }\n        }\n    }\n    \n    public void SetMinimumLoadTime(float time)\n    {\n        _minimumLoadTime = Mathf.Max(0f, time);\n    }\n    \n    public void SetProgressUpdateSpeed(float speed)\n    {\n        _progressUpdateSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void SetAllowSceneActivation(bool allow)\n    {\n        _allowSceneActivation = allow;\n        if (_loadOperation != null && allow && _loadOperation.progress >= 0.9f)\n        {\n            _loadOperation.allowSceneActivation = true;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_messageUpdateCoroutine != null)\n        {\n            StopCoroutine(_messageUpdateCoroutine);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _minimumLoadTime = Mathf.Max(0f, _minimumLoadTime);\n        _progressUpdateSpeed = Mathf.Max(0.1f, _progressUpdateSpeed);\n        \n        if (_loadingMessages == null || _loadingMessages.Length == 0)\n        {\n            _loadingMessages = new string[] { \"Loading...\" };\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "splash screen display",
      "ideal_ir": {
        "class_name": "SplashScreenDisplay",
        "components": [
          "Canvas",
          "Image",
          "CanvasGroup"
        ],
        "fields": [
          {
            "name": "splashDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "fadeInDuration",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "nextSceneName",
            "type": "string",
            "default": "MainMenu"
          }
        ],
        "behaviors": [
          {
            "name": "initialize_splash",
            "trigger": "when the game starts",
            "actions": [
              {
                "action": "set the splash screen image to fully transparent"
              },
              {
                "action": "display the splash screen canvas"
              }
            ]
          },
          {
            "name": "fade_in_splash",
            "trigger": "immediately after initialization",
            "actions": [
              {
                "action": "gradually increase the transparency of the splash screen over the fade in duration"
              },
              {
                "action": "make the splash screen fully visible when fade in completes"
              }
            ]
          },
          {
            "name": "hold_splash_display",
            "trigger": "when fade in animation completes",
            "actions": [
              {
                "action": "keep the splash screen visible for the specified splash duration"
              }
            ]
          },
          {
            "name": "fade_out_splash",
            "trigger": "when the splash display duration expires",
            "actions": [
              {
                "action": "gradually decrease the transparency of the splash screen over the fade out duration"
              },
              {
                "action": "make the splash screen fully transparent when fade out completes"
              }
            ]
          },
          {
            "name": "transition_to_next_scene",
            "trigger": "when fade out animation completes",
            "actions": [
              {
                "action": "load the next scene specified by the scene name"
              },
              {
                "action": "destroy the splash screen canvas"
              }
            ]
          },
          {
            "name": "skip_splash_on_input",
            "trigger": "when player presses any key or clicks during splash display",
            "actions": [
              {
                "action": "immediately start the fade out animation"
              },
              {
                "action": "skip any remaining splash display time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class SplashScreen : MonoBehaviour\n{\n    [Header(\"Splash Screen Settings\")]\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _fadeInDuration = 1f;\n    [SerializeField] private float _fadeOutDuration = 1f;\n    [SerializeField] private bool _skipOnInput = true;\n    [SerializeField] private string _nextSceneName = \"MainMenu\";\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Image _splashImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    [SerializeField] private Text _skipText;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Multiple Splash Screens\")]\n    [SerializeField] private Sprite[] _splashSprites;\n    [SerializeField] private float _timeBetweenSplashes = 0.5f;\n    \n    private bool _isTransitioning = false;\n    private int _currentSplashIndex = 0;\n    private Coroutine _splashCoroutine;\n    \n    private void Start()\n    {\n        InitializeSplashScreen();\n        _splashCoroutine = StartCoroutine(SplashSequence());\n    }\n    \n    private void Update()\n    {\n        if (_skipOnInput && !_isTransitioning && Input.anyKeyDown)\n        {\n            SkipSplashScreen();\n        }\n    }\n    \n    private void InitializeSplashScreen()\n    {\n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n        \n        if (_canvasGroup != null)\n            _canvasGroup.alpha = 0f;\n        \n        if (_skipText != null)\n            _skipText.gameObject.SetActive(_skipOnInput);\n        \n        if (_splashImage != null && _splashSprites != null && _splashSprites.Length > 0)\n            _splashImage.sprite = _splashSprites[0];\n    }\n    \n    private IEnumerator SplashSequence()\n    {\n        if (_splashSprites != null && _splashSprites.Length > 1)\n        {\n            yield return StartCoroutine(MultipleSplashSequence());\n        }\n        else\n        {\n            yield return StartCoroutine(SingleSplashSequence());\n        }\n        \n        LoadNextScene();\n    }\n    \n    private IEnumerator SingleSplashSequence()\n    {\n        // Fade in\n        yield return StartCoroutine(FadeCanvasGroup(0f, 1f, _fadeInDuration));\n        \n        // Display\n        yield return new WaitForSeconds(_displayDuration);\n        \n        // Fade out\n        yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n    }\n    \n    private IEnumerator MultipleSplashSequence()\n    {\n        for (_currentSplashIndex = 0; _currentSplashIndex < _splashSprites.Length; _currentSplashIndex++)\n        {\n            if (_splashImage != null)\n                _splashImage.sprite = _splashSprites[_currentSplashIndex];\n            \n            // Fade in\n            yield return StartCoroutine(FadeCanvasGroup(0f, 1f, _fadeInDuration));\n            \n            // Display\n            yield return new WaitForSeconds(_displayDuration);\n            \n            // Fade out (except for last splash)\n            if (_currentSplashIndex < _splashSprites.Length - 1)\n            {\n                yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n                yield return new WaitForSeconds(_timeBetweenSplashes);\n            }\n        }\n        \n        // Final fade out\n        yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n    }\n    \n    private IEnumerator FadeCanvasGroup(float startAlpha, float endAlpha, float duration)\n    {\n        if (_canvasGroup == null)\n            yield break;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / duration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, endAlpha, normalizedTime);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = endAlpha;\n    }\n    \n    private void SkipSplashScreen()\n    {\n        if (_splashCoroutine != null)\n        {\n            StopCoroutine(_splashCoroutine);\n            _splashCoroutine = null;\n        }\n        \n        _isTransitioning = true;\n        StartCoroutine(QuickFadeOut());\n    }\n    \n    private IEnumerator QuickFadeOut()\n    {\n        yield return StartCoroutine(FadeCanvasGroup(_canvasGroup != null ? _canvasGroup.alpha : 1f, 0f, 0.3f));\n        LoadNextScene();\n    }\n    \n    private void LoadNextScene()\n    {\n        if (_isTransitioning)\n            return;\n        \n        _isTransitioning = true;\n        \n        if (string.IsNullOrEmpty(_nextSceneName))\n        {\n            int currentSceneIndex = SceneManager.GetActiveScene().buildIndex;\n            int nextSceneIndex = currentSceneIndex + 1;\n            \n            if (nextSceneIndex < SceneManager.sceneCountInBuildSettings)\n            {\n                SceneManager.LoadScene(nextSceneIndex);\n            }\n            else\n            {\n                Debug.LogWarning(\"No next scene available. Staying on current scene.\");\n            }\n        }\n        else\n        {\n            SceneManager.LoadScene(_nextSceneName);\n        }\n    }\n    \n    private void PlayAudio()\n    {\n        if (_audioSource != null && _audioSource.clip != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _displayDuration = Mathf.Max(0f, _displayDuration);\n        _fadeInDuration = Mathf.Max(0f, _fadeInDuration);\n        _fadeOutDuration = Mathf.Max(0f, _fadeOutDuration);\n        _timeBetweenSplashes = Mathf.Max(0f, _timeBetweenSplashes);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "input prompt icons",
      "ideal_ir": {
        "class_name": "InputPromptIcons",
        "components": [
          "Canvas",
          "CanvasGroup",
          "Image"
        ],
        "fields": [
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "pulseSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "iconScale",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_prompt_icon",
            "trigger": "when player enters interaction zone",
            "actions": [
              {
                "action": "make icon visible"
              },
              {
                "action": "fade icon in smoothly"
              },
              {
                "action": "start pulsing animation"
              }
            ]
          },
          {
            "name": "hide_prompt_icon",
            "trigger": "when player leaves interaction zone",
            "actions": [
              {
                "action": "fade icon out smoothly"
              },
              {
                "action": "stop pulsing animation"
              },
              {
                "action": "make icon invisible"
              }
            ]
          },
          {
            "name": "pulse_animation",
            "trigger": "continuously while icon is visible",
            "actions": [
              {
                "action": "scale icon up and down rhythmically"
              },
              {
                "action": "create breathing effect with size changes"
              }
            ]
          },
          {
            "name": "update_icon_type",
            "trigger": "when interaction type changes",
            "actions": [
              {
                "action": "switch to appropriate input icon sprite"
              },
              {
                "action": "adjust icon size for new type"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.InputSystem;\nusing System.Collections.Generic;\n\npublic class InputPromptIcons : MonoBehaviour\n{\n    [System.Serializable]\n    public class InputPrompt\n    {\n        [Header(\"Input Configuration\")]\n        public string actionName;\n        public InputActionReference inputAction;\n        \n        [Header(\"Visual Elements\")]\n        public Image iconImage;\n        public Text promptText;\n        public GameObject promptContainer;\n        \n        [Header(\"Icon Sprites\")]\n        public Sprite keyboardSprite;\n        public Sprite gamepadSprite;\n        public Sprite mouseSprite;\n        \n        [Header(\"Settings\")]\n        public bool showOnlyWhenRelevant = true;\n        public float fadeSpeed = 2f;\n        \n        [HideInInspector]\n        public CanvasGroup canvasGroup;\n        [HideInInspector]\n        public bool isVisible;\n    }\n    \n    [Header(\"Input Prompts\")]\n    [SerializeField] private List<InputPrompt> _inputPrompts = new List<InputPrompt>();\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _deviceCheckInterval = 0.5f;\n    [SerializeField] private bool _autoDetectInputDevice = true;\n    [SerializeField] private bool _hideInactivePrompts = true;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _enableFadeAnimation = true;\n    [SerializeField] private float _defaultFadeSpeed = 3f;\n    [SerializeField] private AnimationCurve _fadeCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Layout Settings\")]\n    [SerializeField] private bool _autoArrangePrompts = true;\n    [SerializeField] private float _promptSpacing = 10f;\n    [SerializeField] private bool _useHorizontalLayout = true;\n    \n    private enum InputDeviceType\n    {\n        Keyboard,\n        Gamepad,\n        Mouse\n    }\n    \n    private InputDeviceType _currentDeviceType = InputDeviceType.Keyboard;\n    private float _lastDeviceCheckTime;\n    private Dictionary<string, InputPrompt> _promptLookup = new Dictionary<string, InputPrompt>();\n    \n    private void Start()\n    {\n        InitializePrompts();\n        SetupCanvasGroups();\n        \n        if (_autoDetectInputDevice)\n        {\n            DetectInputDevice();\n        }\n        \n        UpdateAllPrompts();\n        \n        if (_autoArrangePrompts)\n        {\n            ArrangePrompts();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_autoDetectInputDevice && Time.time - _lastDeviceCheckTime >= _deviceCheckInterval)\n        {\n            DetectInputDevice();\n            _lastDeviceCheckTime = Time.time;\n        }\n        \n        UpdatePromptVisibility();\n        HandleFadeAnimations();\n    }\n    \n    private void InitializePrompts()\n    {\n        _promptLookup.Clear();\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (!string.IsNullOrEmpty(prompt.actionName))\n            {\n                _promptLookup[prompt.actionName] = prompt;\n            }\n            \n            if (prompt.promptContainer != null && prompt.canvasGroup == null)\n            {\n                prompt.canvasGroup = prompt.promptContainer.GetComponent<CanvasGroup>();\n                if (prompt.canvasGroup == null)\n                {\n                    prompt.canvasGroup = prompt.promptContainer.AddComponent<CanvasGroup>();\n                }\n            }\n        }\n    }\n    \n    private void SetupCanvasGroups()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.canvasGroup != null)\n            {\n                prompt.canvasGroup.alpha = prompt.isVisible ? 1f : 0f;\n                prompt.canvasGroup.interactable = false;\n                prompt.canvasGroup.blocksRaycasts = false;\n            }\n        }\n    }\n    \n    private void DetectInputDevice()\n    {\n        InputDeviceType newDeviceType = _currentDeviceType;\n        \n        if (Gamepad.current != null && Gamepad.current.wasUpdatedThisFrame)\n        {\n            newDeviceType = InputDeviceType.Gamepad;\n        }\n        else if (Keyboard.current != null && Keyboard.current.anyKey.wasPressedThisFrame)\n        {\n            newDeviceType = InputDeviceType.Keyboard;\n        }\n        else if (Mouse.current != null && (Mouse.current.leftButton.wasPressedThisFrame || \n                 Mouse.current.rightButton.wasPressedThisFrame || Mouse.current.middleButton.wasPressedThisFrame))\n        {\n            newDeviceType = InputDeviceType.Mouse;\n        }\n        \n        if (newDeviceType != _currentDeviceType)\n        {\n            _currentDeviceType = newDeviceType;\n            UpdateAllPrompts();\n        }\n    }\n    \n    private void UpdateAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            UpdatePromptIcon(prompt);\n            UpdatePromptText(prompt);\n        }\n    }\n    \n    private void UpdatePromptIcon(InputPrompt prompt)\n    {\n        if (prompt.iconImage == null) return;\n        \n        Sprite targetSprite = null;\n        \n        switch (_currentDeviceType)\n        {\n            case InputDeviceType.Keyboard:\n                targetSprite = prompt.keyboardSprite;\n                break;\n            case InputDeviceType.Gamepad:\n                targetSprite = prompt.gamepadSprite;\n                break;\n            case InputDeviceType.Mouse:\n                targetSprite = prompt.mouseSprite;\n                break;\n        }\n        \n        if (targetSprite != null)\n        {\n            prompt.iconImage.sprite = targetSprite;\n            prompt.iconImage.gameObject.SetActive(true);\n        }\n        else\n        {\n            prompt.iconImage.gameObject.SetActive(false);\n        }\n    }\n    \n    private void UpdatePromptText(InputPrompt prompt)\n    {\n        if (prompt.promptText == null || prompt.inputAction == null) return;\n        \n        string bindingText = GetBindingDisplayString(prompt.inputAction);\n        prompt.promptText.text = bindingText;\n    }\n    \n    private string GetBindingDisplayString(InputActionReference actionRef)\n    {\n        if (actionRef == null || actionRef.action == null) return \"\";\n        \n        var action = actionRef.action;\n        int bindingIndex = GetBindingIndexForCurrentDevice(action);\n        \n        if (bindingIndex >= 0)\n        {\n            return action.GetBindingDisplayString(bindingIndex);\n        }\n        \n        return action.GetBindingDisplayString();\n    }\n    \n    private int GetBindingIndexForCurrentDevice(InputAction action)\n    {\n        for (int i = 0; i < action.bindings.Count; i++)\n        {\n            var binding = action.bindings[i];\n            \n            switch (_currentDeviceType)\n            {\n                case InputDeviceType.Keyboard:\n                    if (binding.path.Contains(\"Keyboard\"))\n                        return i;\n                    break;\n                case InputDeviceType.Gamepad:\n                    if (binding.path.Contains(\"Gamepad\"))\n                        return i;\n                    break;\n                case InputDeviceType.Mouse:\n                    if (binding.path.Contains(\"Mouse\"))\n                        return i;\n                    break;\n            }\n        }\n        \n        return -1;\n    }\n    \n    private void UpdatePromptVisibility()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            bool shouldBeVisible = ShouldPromptBeVisible(prompt);\n            \n            if (prompt.isVisible != shouldBeVisible)\n            {\n                prompt.isVisible = shouldBeVisible;\n            }\n        }\n    }\n    \n    private bool ShouldPromptBeVisible(InputPrompt prompt)\n    {\n        if (!prompt.showOnlyWhenRelevant) return true;\n        if (prompt.inputAction == null) return false;\n        \n        var action = prompt.inputAction.action;\n        if (action == null) return false;\n        \n        return action.enabled && HasValidBindingForCurrentDevice(action);\n    }\n    \n    private bool HasValidBindingForCurrentDevice(InputAction action)\n    {\n        return GetBindingIndexForCurrentDevice(action) >= 0;\n    }\n    \n    private void HandleFadeAnimations()\n    {\n        if (!_enableFadeAnimation) return;\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.canvasGroup == null) continue;\n            \n            float targetAlpha = prompt.isVisible ? 1f : 0f;\n            float fadeSpeed = prompt.fadeSpeed > 0 ? prompt.fadeSpeed : _defaultFadeSpeed;\n            \n            if (Mathf.Abs(prompt.canvasGroup.alpha - targetAlpha) > 0.01f)\n            {\n                float newAlpha = Mathf.MoveTowards(prompt.canvasGroup.alpha, targetAlpha, fadeSpeed * Time.deltaTime);\n                newAlpha = _fadeCurve.Evaluate(newAlpha);\n                prompt.canvasGroup.alpha = newAlpha;\n            }\n            \n            if (_hideInactivePrompts && prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(prompt.canvasGroup.alpha > 0.01f);\n            }\n        }\n    }\n    \n    private void ArrangePrompts()\n    {\n        Vector3 currentPosition = transform.position;\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.promptContainer == null) continue;\n            \n            prompt.promptContainer.transform.position = currentPosition;\n            \n            if (_useHorizontalLayout)\n            {\n                RectTransform rectTransform = prompt.promptContainer.GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    currentPosition.x += rectTransform.rect.width + _promptSpacing;\n                }\n                else\n                {\n                    currentPosition.x += _promptSpacing;\n                }\n            }\n            else\n            {\n                RectTransform rectTransform = prompt.promptContainer.GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    currentPosition.y -= rectTransform.rect.height + _promptSpacing;\n                }\n                else\n                {\n                    currentPosition.y -= _promptSpacing;\n                }\n            }\n        }\n    }\n    \n    public void ShowPrompt(string actionName)\n    {\n        if (_promptLookup.TryGetValue(actionName, out InputPrompt prompt))\n        {\n            prompt.isVisible = true;\n            if (prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(true);\n            }\n        }\n    }\n    \n    public void HidePrompt(string actionName)\n    {\n        if (_promptLookup.TryGetValue(actionName, out InputPrompt prompt))\n        {\n            prompt.isVisible = false;\n        }\n    }\n    \n    public void ShowAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            prompt.isVisible = true;\n            if (prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(true);\n            }\n        }\n    }\n    \n    public void HideAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            prompt.isVisible = false;\n        }\n    }\n    \n    public void SetDeviceType(int deviceType)\n    {\n        if (deviceType >= 0 && deviceType < System.Enum.GetValues(typeof(InputDeviceType)).Length)\n        {\n            _currentDeviceType = (InputDeviceType)deviceType;\n            UpdateAllPrompts();\n        }\n    }\n    \n    public void RefreshPrompts()\n    {\n        InitializePrompts();\n        UpdateAllPrompts();\n        \n        if (_autoArrangePrompts)\n        {\n            ArrangePrompts();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "player name tag above head",
      "ideal_ir": {
        "class_name": "PlayerNameTag",
        "components": [
          "Canvas",
          "Text"
        ],
        "fields": [
          {
            "name": "playerName",
            "type": "string",
            "default": "Player"
          },
          {
            "name": "offsetHeight",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "followSpeed",
            "type": "float",
            "default": 5.0
          }
        ],
        "behaviors": [
          {
            "name": "initialize_name_tag",
            "trigger": "when game starts",
            "actions": [
              {
                "action": "display player name in text component"
              },
              {
                "action": "position canvas above player head at offset height"
              },
              {
                "action": "make canvas face camera"
              }
            ]
          },
          {
            "name": "follow_player",
            "trigger": "every frame",
            "actions": [
              {
                "action": "move smoothly to position above player head"
              },
              {
                "action": "rotate to always face camera"
              }
            ]
          },
          {
            "name": "update_name",
            "trigger": "when player name changes",
            "actions": [
              {
                "action": "update displayed text with new player name"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class PlayerNameTag : MonoBehaviour\n{\n    [Header(\"Name Tag Settings\")]\n    [SerializeField] private string _playerName = \"Player\";\n    [SerializeField] private float _heightOffset = 2.0f;\n    [SerializeField] private bool _alwaysFaceCamera = true;\n    [SerializeField] private float _fadeDistance = 20.0f;\n    [SerializeField] private bool _hideWhenTooClose = true;\n    [SerializeField] private float _minDistance = 2.0f;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Canvas _nameTagCanvas;\n    [SerializeField] private Text _nameText;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _nameColor = Color.white;\n    [SerializeField] private int _fontSize = 24;\n    [SerializeField] private Font _font;\n    \n    private Camera _mainCamera;\n    private Transform _playerTransform;\n    private Vector3 _originalScale;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        _playerTransform = transform;\n        \n        CreateNameTagUI();\n        SetupCanvas();\n        UpdateNameDisplay();\n        \n        if (_nameTagCanvas != null)\n            _originalScale = _nameTagCanvas.transform.localScale;\n    }\n    \n    private void CreateNameTagUI()\n    {\n        if (_nameTagCanvas == null)\n        {\n            GameObject canvasGO = new GameObject(\"NameTagCanvas\");\n            canvasGO.transform.SetParent(transform);\n            canvasGO.transform.localPosition = Vector3.up * _heightOffset;\n            \n            _nameTagCanvas = canvasGO.AddComponent<Canvas>();\n            _canvasGroup = canvasGO.AddComponent<CanvasGroup>();\n            canvasGO.AddComponent<CanvasScaler>();\n        }\n        \n        if (_nameText == null)\n        {\n            GameObject textGO = new GameObject(\"NameText\");\n            textGO.transform.SetParent(_nameTagCanvas.transform);\n            \n            _nameText = textGO.AddComponent<Text>();\n            \n            RectTransform rectTransform = _nameText.GetComponent<RectTransform>();\n            rectTransform.anchorMin = Vector2.zero;\n            rectTransform.anchorMax = Vector2.one;\n            rectTransform.offsetMin = Vector2.zero;\n            rectTransform.offsetMax = Vector2.zero;\n        }\n    }\n    \n    private void SetupCanvas()\n    {\n        if (_nameTagCanvas == null) return;\n        \n        _nameTagCanvas.renderMode = RenderMode.WorldSpace;\n        _nameTagCanvas.worldCamera = _mainCamera;\n        \n        RectTransform canvasRect = _nameTagCanvas.GetComponent<RectTransform>();\n        canvasRect.sizeDelta = new Vector2(200, 50);\n        canvasRect.localScale = Vector3.one * 0.01f;\n    }\n    \n    private void UpdateNameDisplay()\n    {\n        if (_nameText == null) return;\n        \n        _nameText.text = _playerName;\n        _nameText.color = _nameColor;\n        _nameText.fontSize = _fontSize;\n        _nameText.alignment = TextAnchor.MiddleCenter;\n        \n        if (_font != null)\n            _nameText.font = _font;\n    }\n    \n    private void Update()\n    {\n        if (_mainCamera == null || _nameTagCanvas == null) return;\n        \n        HandleCameraFacing();\n        HandleDistanceFading();\n        UpdatePosition();\n    }\n    \n    private void HandleCameraFacing()\n    {\n        if (!_alwaysFaceCamera) return;\n        \n        Vector3 directionToCamera = _mainCamera.transform.position - _nameTagCanvas.transform.position;\n        directionToCamera.y = 0;\n        \n        if (directionToCamera != Vector3.zero)\n        {\n            Quaternion lookRotation = Quaternion.LookRotation(-directionToCamera);\n            _nameTagCanvas.transform.rotation = lookRotation;\n        }\n    }\n    \n    private void HandleDistanceFading()\n    {\n        if (_canvasGroup == null) return;\n        \n        float distance = Vector3.Distance(_mainCamera.transform.position, _playerTransform.position);\n        \n        if (_hideWhenTooClose && distance < _minDistance)\n        {\n            _canvasGroup.alpha = 0f;\n            return;\n        }\n        \n        if (distance > _fadeDistance)\n        {\n            _canvasGroup.alpha = 0f;\n        }\n        else\n        {\n            float fadeRatio = 1f - (distance / _fadeDistance);\n            _canvasGroup.alpha = Mathf.Clamp01(fadeRatio);\n        }\n    }\n    \n    private void UpdatePosition()\n    {\n        if (_nameTagCanvas == null) return;\n        \n        Vector3 targetPosition = _playerTransform.position + Vector3.up * _heightOffset;\n        _nameTagCanvas.transform.position = targetPosition;\n    }\n    \n    public void SetPlayerName(string newName)\n    {\n        _playerName = newName;\n        UpdateNameDisplay();\n    }\n    \n    public void SetNameColor(Color newColor)\n    {\n        _nameColor = newColor;\n        UpdateNameDisplay();\n    }\n    \n    public void SetHeightOffset(float newOffset)\n    {\n        _heightOffset = newOffset;\n    }\n    \n    public void ShowNameTag()\n    {\n        if (_nameTagCanvas != null)\n            _nameTagCanvas.gameObject.SetActive(true);\n    }\n    \n    public void HideNameTag()\n    {\n        if (_nameTagCanvas != null)\n            _nameTagCanvas.gameObject.SetActive(false);\n    }\n    \n    private void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            UpdateNameDisplay();\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "chat message bubble",
      "ideal_ir": {
        "class_name": "ChatMessageBubble",
        "components": [
          "Canvas",
          "Image",
          "Text"
        ],
        "fields": [
          {
            "name": "displayDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "messageText",
            "type": "string",
            "default": ""
          },
          {
            "name": "isVisible",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "show_message",
            "trigger": "when message text is set",
            "actions": [
              {
                "action": "make bubble visible"
              },
              {
                "action": "display the message text"
              },
              {
                "action": "set bubble to full opacity"
              },
              {
                "action": "start display timer"
              }
            ]
          },
          {
            "name": "auto_hide",
            "trigger": "when display duration expires",
            "actions": [
              {
                "action": "begin fading out the bubble"
              },
              {
                "action": "gradually reduce opacity to zero"
              },
              {
                "action": "hide bubble when fully transparent"
              }
            ]
          },
          {
            "name": "follow_speaker",
            "trigger": "while bubble is visible",
            "actions": [
              {
                "action": "position bubble above speaker"
              },
              {
                "action": "maintain offset from speaker position"
              }
            ]
          },
          {
            "name": "adjust_size",
            "trigger": "when message text changes",
            "actions": [
              {
                "action": "resize bubble to fit text content"
              },
              {
                "action": "maintain minimum bubble size"
              },
              {
                "action": "center text within bubble"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\n\npublic class ChatMessageBubble : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private TextMeshProUGUI _messageText;\n    [SerializeField] private TextMeshProUGUI _senderNameText;\n    [SerializeField] private Image _bubbleBackground;\n    [SerializeField] private Image _avatarImage;\n    [SerializeField] private RectTransform _bubbleRect;\n    \n    [Header(\"Bubble Settings\")]\n    [SerializeField] private Color _playerBubbleColor = new Color(0.2f, 0.6f, 1f, 0.8f);\n    [SerializeField] private Color _otherBubbleColor = new Color(0.8f, 0.8f, 0.8f, 0.8f);\n    [SerializeField] private Color _playerTextColor = Color.white;\n    [SerializeField] private Color _otherTextColor = Color.black;\n    [SerializeField] private float _maxBubbleWidth = 300f;\n    [SerializeField] private float _minBubbleWidth = 100f;\n    [SerializeField] private Vector2 _bubblePadding = new Vector2(20f, 15f);\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _scaleInDuration = 0.2f;\n    [SerializeField] private AnimationCurve _scaleInCurve = AnimationCurve.EaseOutQuart(0, 0, 1, 1);\n    [SerializeField] private bool _animateOnStart = true;\n    \n    [Header(\"Auto Destroy\")]\n    [SerializeField] private bool _autoDestroy = false;\n    [SerializeField] private float _destroyDelay = 5f;\n    \n    private CanvasGroup _canvasGroup;\n    private bool _isPlayerMessage;\n    private string _messageContent;\n    private string _senderName;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n        {\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n        }\n        \n        if (_bubbleRect == null)\n        {\n            _bubbleRect = GetComponent<RectTransform>();\n        }\n    }\n    \n    private void Start()\n    {\n        if (_animateOnStart)\n        {\n            AnimateIn();\n        }\n        \n        if (_autoDestroy)\n        {\n            StartCoroutine(AutoDestroyCoroutine());\n        }\n    }\n    \n    public void SetMessage(string message, string senderName, bool isPlayerMessage, Sprite avatarSprite = null)\n    {\n        _messageContent = message;\n        _senderName = senderName;\n        _isPlayerMessage = isPlayerMessage;\n        \n        UpdateMessageDisplay();\n        UpdateBubbleAppearance();\n        UpdateBubbleSize();\n        \n        if (avatarSprite != null && _avatarImage != null)\n        {\n            _avatarImage.sprite = avatarSprite;\n        }\n    }\n    \n    private void UpdateMessageDisplay()\n    {\n        if (_messageText != null)\n        {\n            _messageText.text = _messageContent;\n            _messageText.color = _isPlayerMessage ? _playerTextColor : _otherTextColor;\n        }\n        \n        if (_senderNameText != null)\n        {\n            _senderNameText.text = _senderName;\n            _senderNameText.color = _isPlayerMessage ? _playerTextColor : _otherTextColor;\n        }\n    }\n    \n    private void UpdateBubbleAppearance()\n    {\n        if (_bubbleBackground != null)\n        {\n            _bubbleBackground.color = _isPlayerMessage ? _playerBubbleColor : _otherBubbleColor;\n        }\n        \n        // Flip bubble alignment for player vs other messages\n        if (_bubbleRect != null)\n        {\n            Vector2 anchorMin = _bubbleRect.anchorMin;\n            Vector2 anchorMax = _bubbleRect.anchorMax;\n            Vector2 pivot = _bubbleRect.pivot;\n            \n            if (_isPlayerMessage)\n            {\n                // Align to right\n                anchorMin.x = 1f;\n                anchorMax.x = 1f;\n                pivot.x = 1f;\n            }\n            else\n            {\n                // Align to left\n                anchorMin.x = 0f;\n                anchorMax.x = 0f;\n                pivot.x = 0f;\n            }\n            \n            _bubbleRect.anchorMin = anchorMin;\n            _bubbleRect.anchorMax = anchorMax;\n            _bubbleRect.pivot = pivot;\n        }\n    }\n    \n    private void UpdateBubbleSize()\n    {\n        if (_messageText == null || _bubbleRect == null) return;\n        \n        // Force text to update\n        _messageText.ForceMeshUpdate();\n        \n        // Calculate preferred width based on text\n        float preferredWidth = _messageText.preferredWidth + _bubblePadding.x * 2;\n        preferredWidth = Mathf.Clamp(preferredWidth, _minBubbleWidth, _maxBubbleWidth);\n        \n        // Calculate preferred height based on text\n        float preferredHeight = _messageText.preferredHeight + _bubblePadding.y * 2;\n        \n        // Add height for sender name if present\n        if (_senderNameText != null && !string.IsNullOrEmpty(_senderName))\n        {\n            preferredHeight += _senderNameText.preferredHeight + 5f;\n        }\n        \n        // Set the bubble size\n        _bubbleRect.sizeDelta = new Vector2(preferredWidth, preferredHeight);\n    }\n    \n    public void AnimateIn()\n    {\n        if (_canvasGroup != null)\n        {\n            StartCoroutine(FadeInCoroutine());\n        }\n        \n        StartCoroutine(ScaleInCoroutine());\n    }\n    \n    public void AnimateOut(System.Action onComplete = null)\n    {\n        StartCoroutine(AnimateOutCoroutine(onComplete));\n    }\n    \n    private IEnumerator FadeInCoroutine()\n    {\n        _canvasGroup.alpha = 0f;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            _canvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / _fadeInDuration);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator ScaleInCoroutine()\n    {\n        Vector3 originalScale = transform.localScale;\n        transform.localScale = Vector3.zero;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _scaleInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _scaleInDuration;\n            float curveValue = _scaleInCurve.Evaluate(progress);\n            transform.localScale = Vector3.Lerp(Vector3.zero, originalScale, curveValue);\n            yield return null;\n        }\n        \n        transform.localScale = originalScale;\n    }\n    \n    private IEnumerator AnimateOutCoroutine(System.Action onComplete)\n    {\n        float duration = 0.2f;\n        Vector3 originalScale = transform.localScale;\n        float originalAlpha = _canvasGroup != null ? _canvasGroup.alpha : 1f;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / duration;\n            \n            transform.localScale = Vector3.Lerp(originalScale, Vector3.zero, progress);\n            \n            if (_canvasGroup != null)\n            {\n                _canvasGroup.alpha = Mathf.Lerp(originalAlpha, 0f, progress);\n            }\n            \n            yield return null;\n        }\n        \n        onComplete?.Invoke();\n    }\n    \n    private IEnumerator AutoDestroyCoroutine()\n    {\n        yield return new WaitForSeconds(_destroyDelay);\n        \n        AnimateOut(() => {\n            if (gameObject != null)\n            {\n                Destroy(gameObject);\n            }\n        });\n    }\n    \n    public void SetAutoDestroy(bool enable, float delay = 5f)\n    {\n        _autoDestroy = enable;\n        _destroyDelay = delay;\n        \n        if (enable)\n        {\n            StopCoroutine(AutoDestroyCoroutine());\n            StartCoroutine(AutoDestroyCoroutine());\n        }\n    }\n    \n    public void UpdateBubbleColors(Color bubbleColor, Color textColor)\n    {\n        if (_bubbleBackground != null)\n        {\n            _bubbleBackground.color = bubbleColor;\n        }\n        \n        if (_messageText != null)\n        {\n            _messageText.color = textColor;\n        }\n        \n        if (_senderNameText != null)\n        {\n            _senderNameText.color = textColor;\n        }\n    }\n    \n    public string GetMessage()\n    {\n        return _messageContent;\n    }\n    \n    public string GetSenderName()\n    {\n        return _senderName;\n    }\n    \n    public bool IsPlayerMessage()\n    {\n        return _isPlayerMessage;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "emote animation system",
      "ideal_ir": {
        "class_name": "EmoteAnimationSystem",
        "components": [
          "Animator"
        ],
        "fields": [
          {
            "name": "emoteAnimations",
            "type": "AnimationClip[]",
            "default": "null"
          },
          {
            "name": "emoteDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "canEmote",
            "type": "bool",
            "default": true
          },
          {
            "name": "currentEmoteIndex",
            "type": "int",
            "default": -1
          },
          {
            "name": "emoteNames",
            "type": "string[]",
            "default": "null"
          },
          {
            "name": "emoteCooldown",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "trigger_emote",
            "trigger": "when emote input is received",
            "actions": [
              {
                "action": "check if emoting is currently allowed"
              },
              {
                "action": "select random emote animation from available emotes"
              },
              {
                "action": "play selected emote animation"
              },
              {
                "action": "disable emote ability temporarily"
              },
              {
                "action": "store current emote index"
              }
            ]
          },
          {
            "name": "trigger_specific_emote",
            "trigger": "when specific emote number is requested",
            "actions": [
              {
                "action": "check if emoting is currently allowed"
              },
              {
                "action": "validate emote index is within valid range"
              },
              {
                "action": "play emote animation at specified index"
              },
              {
                "action": "disable emote ability temporarily"
              }
            ]
          },
          {
            "name": "end_emote",
            "trigger": "when emote animation duration completes",
            "actions": [
              {
                "action": "return to idle animation state"
              },
              {
                "action": "reset current emote index to none"
              },
              {
                "action": "start cooldown timer"
              }
            ]
          },
          {
            "name": "enable_emoting",
            "trigger": "when cooldown period expires",
            "actions": [
              {
                "action": "enable emote ability"
              },
              {
                "action": "allow new emote inputs"
              }
            ]
          },
          {
            "name": "interrupt_emote",
            "trigger": "when movement input is detected during emote",
            "actions": [
              {
                "action": "stop current emote animation"
              },
              {
                "action": "return to movement animation state"
              },
              {
                "action": "enable emote ability immediately"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class EmoteAnimationSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class EmoteData\n    {\n        [Header(\"Emote Settings\")]\n        public string emoteName;\n        public KeyCode triggerKey;\n        public AnimationClip animationClip;\n        public float duration = 2f;\n        public bool canInterrupt = true;\n        public bool lockMovement = false;\n        \n        [Header(\"Audio\")]\n        public AudioClip soundEffect;\n        [Range(0f, 1f)]\n        public float volume = 1f;\n        \n        [Header(\"Effects\")]\n        public GameObject particleEffect;\n        public Transform effectSpawnPoint;\n    }\n\n    [Header(\"Emote Configuration\")]\n    [SerializeField] private List<EmoteData> _availableEmotes = new List<EmoteData>();\n    [SerializeField] private bool _enableKeyboardInput = true;\n    [SerializeField] private float _cooldownTime = 0.5f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _emoteParameterName = \"EmoteTrigger\";\n    [SerializeField] private string _emoteIndexParameterName = \"EmoteIndex\";\n    [SerializeField] private bool _useAnimatorParameters = true;\n    \n    [Header(\"Movement Control\")]\n    [SerializeField] private Rigidbody _rigidbody;\n    [SerializeField] private CharacterController _characterController;\n    [SerializeField] private bool _freezePositionDuringEmote = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnEmoteStarted;\n    public UnityEvent<string> OnEmoteFinished;\n    public UnityEvent OnEmoteInterrupted;\n\n    private EmoteData _currentEmote;\n    private bool _isEmoting = false;\n    private float _lastEmoteTime = 0f;\n    private Coroutine _emoteCoroutine;\n    private Vector3 _originalPosition;\n    private bool _wasKinematic = false;\n    private Dictionary<string, int> _emoteIndexMap = new Dictionary<string, int>();\n\n    private void Start()\n    {\n        InitializeComponents();\n        BuildEmoteIndexMap();\n    }\n\n    private void InitializeComponents()\n    {\n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rigidbody == null)\n            _rigidbody = GetComponent<Rigidbody>();\n            \n        if (_characterController == null)\n            _characterController = GetComponent<CharacterController>();\n    }\n\n    private void BuildEmoteIndexMap()\n    {\n        _emoteIndexMap.Clear();\n        for (int i = 0; i < _availableEmotes.Count; i++)\n        {\n            if (!string.IsNullOrEmpty(_availableEmotes[i].emoteName))\n            {\n                _emoteIndexMap[_availableEmotes[i].emoteName] = i;\n            }\n        }\n    }\n\n    private void Update()\n    {\n        if (_enableKeyboardInput)\n        {\n            HandleKeyboardInput();\n        }\n    }\n\n    private void HandleKeyboardInput()\n    {\n        if (Time.time - _lastEmoteTime < _cooldownTime)\n            return;\n\n        foreach (var emote in _availableEmotes)\n        {\n            if (Input.GetKeyDown(emote.triggerKey))\n            {\n                PlayEmote(emote.emoteName);\n                break;\n            }\n        }\n    }\n\n    public void PlayEmote(string emoteName)\n    {\n        if (string.IsNullOrEmpty(emoteName))\n            return;\n\n        var emoteData = GetEmoteByName(emoteName);\n        if (emoteData == null)\n        {\n            Debug.LogWarning($\"Emote '{emoteName}' not found!\");\n            return;\n        }\n\n        PlayEmote(emoteData);\n    }\n\n    public void PlayEmoteByIndex(int index)\n    {\n        if (index < 0 || index >= _availableEmotes.Count)\n        {\n            Debug.LogWarning($\"Emote index {index} is out of range!\");\n            return;\n        }\n\n        PlayEmote(_availableEmotes[index]);\n    }\n\n    private void PlayEmote(EmoteData emoteData)\n    {\n        if (emoteData == null)\n            return;\n\n        if (Time.time - _lastEmoteTime < _cooldownTime)\n            return;\n\n        if (_isEmoting && !_currentEmote.canInterrupt)\n            return;\n\n        if (_isEmoting)\n        {\n            StopCurrentEmote(true);\n        }\n\n        StartEmote(emoteData);\n    }\n\n    private void StartEmote(EmoteData emoteData)\n    {\n        _currentEmote = emoteData;\n        _isEmoting = true;\n        _lastEmoteTime = Time.time;\n\n        if (_freezePositionDuringEmote && emoteData.lockMovement)\n        {\n            FreezeMovement();\n        }\n\n        PlayEmoteAnimation(emoteData);\n        PlayEmoteAudio(emoteData);\n        SpawnEmoteEffect(emoteData);\n\n        OnEmoteStarted?.Invoke(emoteData.emoteName);\n\n        _emoteCoroutine = StartCoroutine(EmoteCoroutine(emoteData));\n    }\n\n    private void PlayEmoteAnimation(EmoteData emoteData)\n    {\n        if (_animator == null)\n            return;\n\n        if (_useAnimatorParameters)\n        {\n            if (_animator.parameters != null)\n            {\n                foreach (var param in _animator.parameters)\n                {\n                    if (param.name == _emoteParameterName && param.type == AnimatorControllerParameterType.Trigger)\n                    {\n                        _animator.SetTrigger(_emoteParameterName);\n                    }\n                    else if (param.name == _emoteIndexParameterName && param.type == AnimatorControllerParameterType.Int)\n                    {\n                        if (_emoteIndexMap.ContainsKey(emoteData.emoteName))\n                        {\n                            _animator.SetInteger(_emoteIndexParameterName, _emoteIndexMap[emoteData.emoteName]);\n                        }\n                    }\n                }\n            }\n        }\n        else if (emoteData.animationClip != null)\n        {\n            _animator.Play(emoteData.animationClip.name);\n        }\n    }\n\n    private void PlayEmoteAudio(EmoteData emoteData)\n    {\n        if (_audioSource != null && emoteData.soundEffect != null)\n        {\n            _audioSource.clip = emoteData.soundEffect;\n            _audioSource.volume = emoteData.volume;\n            _audioSource.Play();\n        }\n    }\n\n    private void SpawnEmoteEffect(EmoteData emoteData)\n    {\n        if (emoteData.particleEffect != null)\n        {\n            Transform spawnPoint = emoteData.effectSpawnPoint != null ? emoteData.effectSpawnPoint : transform;\n            GameObject effect = Instantiate(emoteData.particleEffect, spawnPoint.position, spawnPoint.rotation);\n            \n            if (emoteData.duration > 0)\n            {\n                Destroy(effect, emoteData.duration + 1f);\n            }\n        }\n    }\n\n    private void FreezeMovement()\n    {\n        _originalPosition = transform.position;\n\n        if (_rigidbody != null)\n        {\n            _wasKinematic = _rigidbody.isKinematic;\n            _rigidbody.isKinematic = true;\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n        }\n    }\n\n    private void UnfreezeMovement()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = _wasKinematic;\n        }\n    }\n\n    private IEnumerator EmoteCoroutine(EmoteData emoteData)\n    {\n        yield return new WaitForSeconds(emoteData.duration);\n        FinishEmote();\n    }\n\n    private void FinishEmote()\n    {\n        if (!_isEmoting)\n            return;\n\n        string emoteName = _currentEmote != null ? _currentEmote.emoteName : \"\";\n        \n        if (_currentEmote != null && _currentEmote.lockMovement)\n        {\n            UnfreezeMovement();\n        }\n\n        _isEmoting = false;\n        _currentEmote = null;\n\n        OnEmoteFinished?.Invoke(emoteName);\n    }\n\n    public void StopCurrentEmote(bool wasInterrupted = false)\n    {\n        if (!_isEmoting)\n            return;\n\n        if (_emoteCoroutine != null)\n        {\n            StopCoroutine(_emoteCoroutine);\n            _emoteCoroutine = null;\n        }\n\n        if (_currentEmote != null && _currentEmote.lockMovement)\n        {\n            UnfreezeMovement();\n        }\n\n        if (wasInterrupted)\n        {\n            OnEmoteInterrupted?.Invoke();\n        }\n\n        _isEmoting = false;\n        _currentEmote = null;\n    }\n\n    private EmoteData GetEmoteByName(string emoteName)\n    {\n        foreach (var emote in _availableEmotes)\n        {\n            if (emote.emoteName.Equals(emoteName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                return emote;\n            }\n        }\n        return null;\n    }\n\n    public bool IsEmoting()\n    {\n        return _isEmoting;\n    }\n\n    public string GetCurrentEmoteName()\n    {\n        return _currentEmote != null ? _currentEmote.emoteName : \"\";\n    }\n\n    public List<string> GetAvailableEmoteNames()\n    {\n        List<string> names = new List<string>();\n        foreach (var emote in _availableEmotes)\n        {\n            if (!string.IsNullOrEmpty(emote.emoteName))\n            {\n                names.Add(emote.emoteName);\n            }\n        }\n        return names;\n    }\n\n    public void AddEmote(EmoteData newEmote)\n    {\n        if (newEmote != null && !string.IsNullOrEmpty(newEmote.emoteName))\n        {\n            _availableEmotes.Add(newEmote);\n            BuildEmoteIndexMap();\n        }\n    }\n\n    public void RemoveEmote(string emoteName)\n    {\n        for (int i = _availableEmotes.Count - 1; i >= 0; i--)\n        {\n            if (_availableEmotes[i].emoteName.Equals(emoteName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                _availableEmotes.RemoveAt(i);\n                BuildEmoteIndexMap();\n                break;\n            }\n        }\n    }\n\n    private void OnDisable()\n    {\n        StopCurrentEmote();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "team color indicator",
      "ideal_ir": {
        "class_name": "TeamColorIndicator",
        "components": [
          "Renderer"
        ],
        "fields": [
          {
            "name": "teamColor",
            "type": "Color",
            "default": "Color.white"
          },
          {
            "name": "isFlashing",
            "type": "bool",
            "default": false
          },
          {
            "name": "flashSpeed",
            "type": "float",
            "default": 2.0
          }
        ],
        "behaviors": [
          {
            "name": "initialize_team_color",
            "trigger": "when object starts",
            "actions": [
              {
                "action": "set renderer material color to team color"
              }
            ]
          },
          {
            "name": "update_team_color",
            "trigger": "when team color changes",
            "actions": [
              {
                "action": "set renderer material color to new team color"
              }
            ]
          },
          {
            "name": "flash_indicator",
            "trigger": "when flashing is enabled",
            "actions": [
              {
                "action": "alternate between team color and transparent at flash speed"
              }
            ]
          },
          {
            "name": "stop_flashing",
            "trigger": "when flashing is disabled",
            "actions": [
              {
                "action": "set renderer material color to solid team color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class TeamColorIndicator : MonoBehaviour\n{\n    [System.Serializable]\n    public class TeamData\n    {\n        public string teamName;\n        public Color teamColor;\n        public Sprite teamIcon;\n    }\n\n    [Header(\"Team Configuration\")]\n    [SerializeField] private TeamData[] _teams = new TeamData[]\n    {\n        new TeamData { teamName = \"Red Team\", teamColor = Color.red },\n        new TeamData { teamName = \"Blue Team\", teamColor = Color.blue },\n        new TeamData { teamName = \"Green Team\", teamColor = Color.green },\n        new TeamData { teamName = \"Yellow Team\", teamColor = Color.yellow }\n    };\n    \n    [SerializeField] private int _currentTeamIndex = 0;\n\n    [Header(\"Visual Components\")]\n    [SerializeField] private Renderer _meshRenderer;\n    [SerializeField] private SpriteRenderer _spriteRenderer;\n    [SerializeField] private Image _uiImage;\n    [SerializeField] private Text _teamNameText;\n    [SerializeField] private Light _indicatorLight;\n    [SerializeField] private ParticleSystem _particleEffect;\n\n    [Header(\"Material Properties\")]\n    [SerializeField] private string _colorPropertyName = \"_Color\";\n    [SerializeField] private string _emissionPropertyName = \"_EmissionColor\";\n    [SerializeField] private bool _useEmission = false;\n    [SerializeField] private float _emissionIntensity = 1.0f;\n\n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulse = false;\n    [SerializeField] private float _pulseSpeed = 2.0f;\n    [SerializeField] private float _pulseMinIntensity = 0.5f;\n    [SerializeField] private float _pulseMaxIntensity = 1.0f;\n\n    [Header(\"Events\")]\n    public UnityEngine.Events.UnityEvent<int> OnTeamChanged;\n    public UnityEngine.Events.UnityEvent<string> OnTeamNameChanged;\n    public UnityEngine.Events.UnityEvent<Color> OnTeamColorChanged;\n\n    private Material _originalMaterial;\n    private Material _instanceMaterial;\n    private Color _originalColor;\n    private float _pulseTimer;\n\n    public int CurrentTeamIndex \n    { \n        get => _currentTeamIndex; \n        set => SetTeam(value); \n    }\n\n    public TeamData CurrentTeam \n    { \n        get => _teams[_currentTeamIndex]; \n    }\n\n    public Color CurrentTeamColor \n    { \n        get => _teams[_currentTeamIndex].teamColor; \n    }\n\n    public string CurrentTeamName \n    { \n        get => _teams[_currentTeamIndex].teamName; \n    }\n\n    private void Start()\n    {\n        InitializeMaterials();\n        ApplyTeamColor();\n    }\n\n    private void Update()\n    {\n        if (_enablePulse)\n        {\n            UpdatePulseEffect();\n        }\n    }\n\n    private void InitializeMaterials()\n    {\n        if (_meshRenderer != null && _meshRenderer.material != null)\n        {\n            _originalMaterial = _meshRenderer.material;\n            _instanceMaterial = new Material(_originalMaterial);\n            _meshRenderer.material = _instanceMaterial;\n            _originalColor = _instanceMaterial.color;\n        }\n    }\n\n    public void SetTeam(int teamIndex)\n    {\n        if (teamIndex < 0 || teamIndex >= _teams.Length)\n        {\n            Debug.LogWarning($\"Invalid team index: {teamIndex}. Must be between 0 and {_teams.Length - 1}\");\n            return;\n        }\n\n        _currentTeamIndex = teamIndex;\n        ApplyTeamColor();\n        \n        OnTeamChanged?.Invoke(_currentTeamIndex);\n        OnTeamNameChanged?.Invoke(CurrentTeamName);\n        OnTeamColorChanged?.Invoke(CurrentTeamColor);\n    }\n\n    public void SetTeamByName(string teamName)\n    {\n        for (int i = 0; i < _teams.Length; i++)\n        {\n            if (_teams[i].teamName.Equals(teamName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                SetTeam(i);\n                return;\n            }\n        }\n        Debug.LogWarning($\"Team with name '{teamName}' not found\");\n    }\n\n    public void NextTeam()\n    {\n        SetTeam((_currentTeamIndex + 1) % _teams.Length);\n    }\n\n    public void PreviousTeam()\n    {\n        SetTeam((_currentTeamIndex - 1 + _teams.Length) % _teams.Length);\n    }\n\n    private void ApplyTeamColor()\n    {\n        if (_currentTeamIndex >= _teams.Length) return;\n\n        Color teamColor = _teams[_currentTeamIndex].teamColor;\n        Sprite teamIcon = _teams[_currentTeamIndex].teamIcon;\n\n        // Apply to mesh renderer\n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.SetColor(_colorPropertyName, teamColor);\n            \n            if (_useEmission && _instanceMaterial.HasProperty(_emissionPropertyName))\n            {\n                _instanceMaterial.SetColor(_emissionPropertyName, teamColor * _emissionIntensity);\n                _instanceMaterial.EnableKeyword(\"_EMISSION\");\n            }\n        }\n\n        // Apply to sprite renderer\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = teamColor;\n            if (teamIcon != null)\n            {\n                _spriteRenderer.sprite = teamIcon;\n            }\n        }\n\n        // Apply to UI image\n        if (_uiImage != null)\n        {\n            _uiImage.color = teamColor;\n            if (teamIcon != null)\n            {\n                _uiImage.sprite = teamIcon;\n            }\n        }\n\n        // Apply to text\n        if (_teamNameText != null)\n        {\n            _teamNameText.text = _teams[_currentTeamIndex].teamName;\n            _teamNameText.color = teamColor;\n        }\n\n        // Apply to light\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.color = teamColor;\n        }\n\n        // Apply to particle system\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            main.startColor = teamColor;\n        }\n    }\n\n    private void UpdatePulseEffect()\n    {\n        _pulseTimer += Time.deltaTime * _pulseSpeed;\n        float pulseValue = Mathf.Lerp(_pulseMinIntensity, _pulseMaxIntensity, \n            (Mathf.Sin(_pulseTimer) + 1.0f) * 0.5f);\n\n        Color baseColor = _teams[_currentTeamIndex].teamColor;\n        Color pulsedColor = baseColor * pulseValue;\n\n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.SetColor(_colorPropertyName, pulsedColor);\n        }\n\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = pulsedColor;\n        }\n\n        if (_uiImage != null)\n        {\n            _uiImage.color = pulsedColor;\n        }\n\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.intensity = pulseValue;\n        }\n    }\n\n    public void TogglePulse()\n    {\n        _enablePulse = !_enablePulse;\n        if (!_enablePulse)\n        {\n            ApplyTeamColor();\n        }\n    }\n\n    public void SetPulseEnabled(bool enabled)\n    {\n        _enablePulse = enabled;\n        if (!_enablePulse)\n        {\n            ApplyTeamColor();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_instanceMaterial != null)\n        {\n            DestroyImmediate(_instanceMaterial);\n        }\n    }\n\n    private void OnValidate()\n    {\n        if (_teams == null || _teams.Length == 0)\n        {\n            _teams = new TeamData[]\n            {\n                new TeamData { teamName = \"Red Team\", teamColor = Color.red },\n                new TeamData { teamName = \"Blue Team\", teamColor = Color.blue }\n            };\n        }\n\n        _currentTeamIndex = Mathf.Clamp(_currentTeamIndex, 0, _teams.Length - 1);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "voice chat proximity",
      "ideal_ir": {
        "class_name": "VoiceChatProximity",
        "components": [
          "AudioSource",
          "AudioListener"
        ],
        "fields": [
          {
            "name": "maxHearingDistance",
            "type": "float",
            "default": 20
          },
          {
            "name": "minHearingDistance",
            "type": "float",
            "default": 1
          },
          {
            "name": "volumeFalloffCurve",
            "type": "AnimationCurve",
            "default": null
          },
          {
            "name": "isTransmitting",
            "type": "bool",
            "default": false
          },
          {
            "name": "voiceChannel",
            "type": "int",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "adjust_voice_volume_by_distance",
            "trigger": "when distance to other players changes",
            "actions": [
              {
                "action": "calculate volume based on distance between players"
              },
              {
                "action": "apply volume falloff curve to audio source"
              },
              {
                "action": "set audio source volume to calculated value"
              }
            ]
          },
          {
            "name": "enable_voice_transmission",
            "trigger": "when push to talk key is pressed",
            "actions": [
              {
                "action": "start recording microphone input"
              },
              {
                "action": "set transmission state to active"
              },
              {
                "action": "broadcast voice data to nearby players"
              }
            ]
          },
          {
            "name": "disable_voice_transmission",
            "trigger": "when push to talk key is released",
            "actions": [
              {
                "action": "stop recording microphone input"
              },
              {
                "action": "set transmission state to inactive"
              },
              {
                "action": "stop broadcasting voice data"
              }
            ]
          },
          {
            "name": "filter_audio_by_range",
            "trigger": "when receiving voice data from other players",
            "actions": [
              {
                "action": "check if transmitting player is within hearing range"
              },
              {
                "action": "play received audio if player is close enough"
              },
              {
                "action": "ignore audio if player is too far away"
              }
            ]
          },
          {
            "name": "apply_spatial_audio",
            "trigger": "when playing voice audio from other players",
            "actions": [
              {
                "action": "position audio source at transmitting player location"
              },
              {
                "action": "apply directional audio based on player orientation"
              },
              {
                "action": "adjust stereo panning based on relative position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class ProximityVoiceChat : MonoBehaviour\n{\n    [System.Serializable]\n    public class VoiceSettings\n    {\n        [Range(0f, 100f)]\n        public float maxHearingDistance = 20f;\n        [Range(0f, 100f)]\n        public float whisperDistance = 5f;\n        [Range(0f, 100f)]\n        public float shoutDistance = 50f;\n        [Range(0f, 1f)]\n        public float minVolume = 0.1f;\n        [Range(0f, 1f)]\n        public float maxVolume = 1f;\n        public AnimationCurve volumeFalloffCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    }\n\n    [System.Serializable]\n    public class PlayerVoiceData\n    {\n        public Transform playerTransform;\n        public AudioSource audioSource;\n        public AudioClip voiceClip;\n        public bool isTalking;\n        public float talkingVolume;\n        public VoiceMode currentMode;\n        \n        public PlayerVoiceData(Transform transform, AudioSource source)\n        {\n            playerTransform = transform;\n            audioSource = source;\n            isTalking = false;\n            talkingVolume = 1f;\n            currentMode = VoiceMode.Normal;\n        }\n    }\n\n    public enum VoiceMode\n    {\n        Whisper,\n        Normal,\n        Shout\n    }\n\n    [Header(\"Voice Settings\")]\n    [SerializeField] private VoiceSettings _voiceSettings = new VoiceSettings();\n    \n    [Header(\"Audio Configuration\")]\n    [SerializeField] private AudioMixerGroup _voiceMixerGroup;\n    [SerializeField] private bool _use3DAudio = true;\n    [SerializeField] private AudioRolloffMode _rolloffMode = AudioRolloffMode.Linear;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private bool _checkLineOfSight = true;\n    [SerializeField] private float _updateRate = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform, float> OnPlayerVoiceHeard;\n    public UnityEvent<Transform> OnPlayerStartedTalking;\n    public UnityEvent<Transform> OnPlayerStoppedTalking;\n\n    private Dictionary<Transform, PlayerVoiceData> _nearbyPlayers = new Dictionary<Transform, PlayerVoiceData>();\n    private Transform _localPlayer;\n    private float _updateTimer;\n    private bool _isLocalPlayerTalking;\n    private VoiceMode _currentVoiceMode = VoiceMode.Normal;\n\n    private void Start()\n    {\n        _localPlayer = transform;\n        _updateTimer = 0f;\n        \n        if (_voiceSettings.volumeFalloffCurve.keys.Length == 0)\n        {\n            _voiceSettings.volumeFalloffCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n        }\n    }\n\n    private void Update()\n    {\n        _updateTimer += Time.deltaTime;\n        \n        if (_updateTimer >= 1f / _updateRate)\n        {\n            UpdateProximityVoice();\n            _updateTimer = 0f;\n        }\n\n        HandleVoiceInput();\n        UpdateVoiceVisualization();\n    }\n\n    private void HandleVoiceInput()\n    {\n        bool wasTalking = _isLocalPlayerTalking;\n        \n        // Simulate voice input detection (replace with actual microphone input)\n        _isLocalPlayerTalking = Input.GetKey(KeyCode.V) || Input.GetKey(KeyCode.T);\n        \n        // Voice mode switching\n        if (Input.GetKeyDown(KeyCode.Alpha1))\n            _currentVoiceMode = VoiceMode.Whisper;\n        else if (Input.GetKeyDown(KeyCode.Alpha2))\n            _currentVoiceMode = VoiceMode.Normal;\n        else if (Input.GetKeyDown(KeyCode.Alpha3))\n            _currentVoiceMode = VoiceMode.Shout;\n\n        if (_isLocalPlayerTalking && !wasTalking)\n        {\n            OnPlayerStartedTalking?.Invoke(_localPlayer);\n            BroadcastVoiceToNearbyPlayers(true);\n        }\n        else if (!_isLocalPlayerTalking && wasTalking)\n        {\n            OnPlayerStoppedTalking?.Invoke(_localPlayer);\n            BroadcastVoiceToNearbyPlayers(false);\n        }\n    }\n\n    private void UpdateProximityVoice()\n    {\n        DetectNearbyPlayers();\n        UpdatePlayerVoiceVolumes();\n        CleanupDistantPlayers();\n    }\n\n    private void DetectNearbyPlayers()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(\n            _localPlayer.position, \n            _voiceSettings.maxHearingDistance, \n            _playerLayer\n        );\n\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.transform == _localPlayer) continue;\n            \n            if (!col.CompareTag(\"Player\")) continue;\n\n            if (!_nearbyPlayers.ContainsKey(col.transform))\n            {\n                AddNewPlayer(col.transform);\n            }\n        }\n    }\n\n    private void AddNewPlayer(Transform playerTransform)\n    {\n        AudioSource audioSource = playerTransform.GetComponent<AudioSource>();\n        \n        if (audioSource == null)\n        {\n            audioSource = playerTransform.gameObject.AddComponent<AudioSource>();\n        }\n\n        ConfigureAudioSource(audioSource);\n        \n        PlayerVoiceData voiceData = new PlayerVoiceData(playerTransform, audioSource);\n        _nearbyPlayers.Add(playerTransform, voiceData);\n    }\n\n    private void ConfigureAudioSource(AudioSource audioSource)\n    {\n        audioSource.spatialBlend = _use3DAudio ? 1f : 0f;\n        audioSource.rolloffMode = _rolloffMode;\n        audioSource.maxDistance = _voiceSettings.maxHearingDistance;\n        audioSource.minDistance = 1f;\n        audioSource.loop = false;\n        audioSource.playOnAwake = false;\n        \n        if (_voiceMixerGroup != null)\n        {\n            audioSource.outputAudioMixerGroup = _voiceMixerGroup;\n        }\n    }\n\n    private void UpdatePlayerVoiceVolumes()\n    {\n        List<Transform> playersToRemove = new List<Transform>();\n\n        foreach (var kvp in _nearbyPlayers)\n        {\n            Transform playerTransform = kvp.Key;\n            PlayerVoiceData voiceData = kvp.Value;\n\n            if (playerTransform == null)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float distance = Vector3.Distance(_localPlayer.position, playerTransform.position);\n            float maxDistance = GetMaxDistanceForMode(voiceData.currentMode);\n\n            if (distance > maxDistance)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float volume = CalculateVoiceVolume(distance, voiceData.currentMode);\n            \n            if (_checkLineOfSight && !HasLineOfSight(playerTransform.position))\n            {\n                volume *= 0.5f; // Muffle voice through obstacles\n            }\n\n            voiceData.audioSource.volume = volume * voiceData.talkingVolume;\n            \n            if (voiceData.isTalking && volume > 0f)\n            {\n                OnPlayerVoiceHeard?.Invoke(playerTransform, volume);\n            }\n        }\n\n        foreach (Transform player in playersToRemove)\n        {\n            RemovePlayer(player);\n        }\n    }\n\n    private float GetMaxDistanceForMode(VoiceMode mode)\n    {\n        switch (mode)\n        {\n            case VoiceMode.Whisper:\n                return _voiceSettings.whisperDistance;\n            case VoiceMode.Shout:\n                return _voiceSettings.shoutDistance;\n            default:\n                return _voiceSettings.maxHearingDistance;\n        }\n    }\n\n    private float CalculateVoiceVolume(float distance, VoiceMode mode)\n    {\n        float maxDistance = GetMaxDistanceForMode(mode);\n        \n        if (distance >= maxDistance)\n            return 0f;\n\n        float normalizedDistance = distance / maxDistance;\n        float volumeMultiplier = _voiceSettings.volumeFalloffCurve.Evaluate(1f - normalizedDistance);\n        \n        return Mathf.Lerp(_voiceSettings.minVolume, _voiceSettings.maxVolume, volumeMultiplier);\n    }\n\n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - _localPlayer.position;\n        float distance = direction.magnitude;\n        \n        if (Physics.Raycast(_localPlayer.position + Vector3.up * 0.5f, direction.normalized, distance, _obstacleLayer))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private void CleanupDistantPlayers()\n    {\n        List<Transform> playersToRemove = new List<Transform>();\n\n        foreach (var kvp in _nearbyPlayers)\n        {\n            Transform playerTransform = kvp.Key;\n            \n            if (playerTransform == null)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float distance = Vector3.Distance(_localPlayer.position, playerTransform.position);\n            \n            if (distance > _voiceSettings.maxHearingDistance * 1.2f) // Add buffer to prevent flickering\n            {\n                playersToRemove.Add(playerTransform);\n            }\n        }\n\n        foreach (Transform player in playersToRemove)\n        {\n            RemovePlayer(player);\n        }\n    }\n\n    private void RemovePlayer(Transform playerTransform)\n    {\n        if (_nearbyPlayers.ContainsKey(playerTransform))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[playerTransform];\n            \n            if (voiceData.audioSource != null && voiceData.audioSource.isPlaying)\n            {\n                voiceData.audioSource.Stop();\n            }\n            \n            _nearbyPlayers.Remove(playerTransform);\n        }\n    }\n\n    private void BroadcastVoiceToNearbyPlayers(bool isTalking)\n    {\n        // This would typically send network messages to other players\n        // For now, we'll simulate by updating local data\n        foreach (var kvp in _nearbyPlayers)\n        {\n            PlayerVoiceData voiceData = kvp.Value;\n            // In a real implementation, this would be received from network\n        }\n    }\n\n    private void UpdateVoiceVisualization()\n    {\n        // Visual feedback for current voice mode and talking state\n        // This could update UI elements or particle effects\n    }\n\n    public void SetPlayerTalking(Transform player, bool isTalking, VoiceMode mode = VoiceMode.Normal)\n    {\n        if (_nearbyPlayers.ContainsKey(player))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[player];\n            voiceData.isTalking = isTalking;\n            voiceData.currentMode = mode;\n\n            if (isTalking)\n            {\n                OnPlayerStartedTalking?.Invoke(player);\n            }\n            else\n            {\n                OnPlayerStoppedTalking?.Invoke(player);\n                if (voiceData.audioSource.isPlaying)\n                {\n                    voiceData.audioSource.Stop();\n                }\n            }\n        }\n    }\n\n    public void PlayVoiceClip(Transform player, AudioClip clip, float volume = 1f)\n    {\n        if (_nearbyPlayers.ContainsKey(player))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[player];\n            voiceData.audioSource.clip = clip;\n            voiceData.talkingVolume = volume;\n            voiceData.audioSource.Play();\n        }\n    }\n\n    public void SetVoiceMode(VoiceMode mode)\n    {\n        _currentVoiceMode = mode;\n    }\n\n    public VoiceMode GetCurrentVoiceMode()\n    {\n        return _currentVoiceMode;\n    }\n\n    public bool IsPlayerInRange(Transform player)\n    {\n        return _nearbyPlayers.ContainsKey(player);\n    }\n\n    public float GetPlayerDistance(Transform player)\n    {\n        if (player == null) return float.MaxValue;\n        return Vector3.Distance(_localPlayer.position, player.position);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_localPlayer == null) return;\n\n        // Draw hearing ranges\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.whisperDistance);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.maxHearingDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.shoutDistance);\n\n        // Draw connections to nearby players\n        Gizmos.color = Color.cyan;\n        foreach (var kvp in _nearbyPlayers)\n        {\n            if (kvp.Key != null)\n            {\n                Gizmos.DrawLine(_localPlayer.position, kvp.Key.position);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "lobby room system",
      "ideal_ir": {
        "class_name": "LobbyRoomSystem",
        "components": [
          "NetworkBehaviour",
          "Canvas",
          "Button"
        ],
        "fields": [
          {
            "name": "maxPlayersPerRoom",
            "type": "int",
            "default": 4
          },
          {
            "name": "roomListUpdateInterval",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "roomNamePrefix",
            "type": "string",
            "default": "Room"
          },
          {
            "name": "isHost",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentRoomName",
            "type": "string",
            "default": ""
          },
          {
            "name": "playerCount",
            "type": "int",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "create_new_room",
            "trigger": "when create room button is clicked",
            "actions": [
              {
                "action": "generate unique room name with prefix and random number"
              },
              {
                "action": "create new multiplayer room with generated name"
              },
              {
                "action": "set local player as room host"
              },
              {
                "action": "join the newly created room"
              },
              {
                "action": "update room display with current room info"
              }
            ]
          },
          {
            "name": "join_existing_room",
            "trigger": "when room from list is selected and join button clicked",
            "actions": [
              {
                "action": "attempt to join selected room"
              },
              {
                "action": "check if room has available slots"
              },
              {
                "action": "add local player to room if space available"
              },
              {
                "action": "update player count display"
              },
              {
                "action": "show room full message if no space available"
              }
            ]
          },
          {
            "name": "refresh_room_list",
            "trigger": "when refresh interval timer expires or refresh button clicked",
            "actions": [
              {
                "action": "query server for available rooms"
              },
              {
                "action": "update room list display with current rooms"
              },
              {
                "action": "show player count for each room"
              },
              {
                "action": "highlight rooms that are not full"
              }
            ]
          },
          {
            "name": "leave_current_room",
            "trigger": "when leave room button is clicked",
            "actions": [
              {
                "action": "remove local player from current room"
              },
              {
                "action": "update room player count"
              },
              {
                "action": "return to main lobby interface"
              },
              {
                "action": "clear current room information"
              }
            ]
          },
          {
            "name": "start_game_session",
            "trigger": "when host clicks start game and minimum players present",
            "actions": [
              {
                "action": "check if minimum player count is met"
              },
              {
                "action": "lock room to prevent new players joining"
              },
              {
                "action": "send start game signal to all room members"
              },
              {
                "action": "transition all players to game scene"
              }
            ]
          },
          {
            "name": "handle_player_disconnect",
            "trigger": "when any player in room disconnects",
            "actions": [
              {
                "action": "remove disconnected player from room"
              },
              {
                "action": "update player count display"
              },
              {
                "action": "reassign host if disconnected player was host"
              },
              {
                "action": "notify remaining players of disconnection"
              }
            ]
          },
          {
            "name": "update_room_status",
            "trigger": "when room state changes or new player joins",
            "actions": [
              {
                "action": "refresh current player list in room"
              },
              {
                "action": "update ready status indicators for each player"
              },
              {
                "action": "enable or disable start button based on player readiness"
              },
              {
                "action": "broadcast room status to all connected players"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class LobbyRoomSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class Room\n    {\n        public string roomName;\n        public string roomId;\n        public int currentPlayers;\n        public int maxPlayers;\n        public bool isPrivate;\n        public string password;\n        public bool isInGame;\n        public List<string> playerNames;\n\n        public Room(string name, string id, int maxPlayers, bool isPrivate = false, string password = \"\")\n        {\n            this.roomName = name;\n            this.roomId = id;\n            this.maxPlayers = maxPlayers;\n            this.isPrivate = isPrivate;\n            this.password = password;\n            this.currentPlayers = 0;\n            this.isInGame = false;\n            this.playerNames = new List<string>();\n        }\n\n        public bool CanJoin()\n        {\n            return currentPlayers < maxPlayers && !isInGame;\n        }\n\n        public bool AddPlayer(string playerName)\n        {\n            if (CanJoin() && !playerNames.Contains(playerName))\n            {\n                playerNames.Add(playerName);\n                currentPlayers++;\n                return true;\n            }\n            return false;\n        }\n\n        public bool RemovePlayer(string playerName)\n        {\n            if (playerNames.Contains(playerName))\n            {\n                playerNames.Remove(playerName);\n                currentPlayers--;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    [System.Serializable]\n    public class RoomEvents\n    {\n        public UnityEvent<Room> OnRoomCreated;\n        public UnityEvent<Room> OnRoomJoined;\n        public UnityEvent<Room> OnRoomLeft;\n        public UnityEvent<Room> OnRoomUpdated;\n        public UnityEvent<string> OnRoomDeleted;\n        public UnityEvent<string> OnError;\n    }\n\n    [Header(\"Room Settings\")]\n    [SerializeField] private int _maxRoomsCount = 50;\n    [SerializeField] private int _defaultMaxPlayers = 4;\n    [SerializeField] private float _roomUpdateInterval = 1f;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _roomListParent;\n    [SerializeField] private GameObject _roomItemPrefab;\n    [SerializeField] private Button _createRoomButton;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private InputField _roomNameInput;\n    [SerializeField] private InputField _maxPlayersInput;\n    [SerializeField] private Toggle _privateRoomToggle;\n    [SerializeField] private InputField _passwordInput;\n    [SerializeField] private GameObject _createRoomPanel;\n    [SerializeField] private GameObject _passwordPanel;\n    [SerializeField] private InputField _passwordEntryInput;\n    [SerializeField] private Button _joinWithPasswordButton;\n    [SerializeField] private Button _cancelPasswordButton;\n\n    [Header(\"Current Room UI\")]\n    [SerializeField] private GameObject _currentRoomPanel;\n    [SerializeField] private Text _currentRoomNameText;\n    [SerializeField] private Text _currentRoomPlayersText;\n    [SerializeField] private Transform _playerListParent;\n    [SerializeField] private GameObject _playerItemPrefab;\n    [SerializeField] private Button _leaveRoomButton;\n    [SerializeField] private Button _startGameButton;\n\n    [Header(\"Events\")]\n    [SerializeField] private RoomEvents _roomEvents;\n\n    private Dictionary<string, Room> _rooms = new Dictionary<string, Room>();\n    private List<GameObject> _roomUIItems = new List<GameObject>();\n    private List<GameObject> _playerUIItems = new List<GameObject>();\n    private Room _currentRoom;\n    private string _currentPlayerName = \"Player\";\n    private Room _pendingJoinRoom;\n    private float _lastUpdateTime;\n\n    private void Start()\n    {\n        InitializeUI();\n        SetCurrentPlayerName();\n        RefreshRoomList();\n    }\n\n    private void Update()\n    {\n        if (Time.time - _lastUpdateTime >= _roomUpdateInterval)\n        {\n            UpdateRoomList();\n            _lastUpdateTime = Time.time;\n        }\n    }\n\n    private void InitializeUI()\n    {\n        if (_createRoomButton != null)\n            _createRoomButton.onClick.AddListener(ShowCreateRoomPanel);\n\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshRoomList);\n\n        if (_leaveRoomButton != null)\n            _leaveRoomButton.onClick.AddListener(LeaveCurrentRoom);\n\n        if (_startGameButton != null)\n            _startGameButton.onClick.AddListener(StartGame);\n\n        if (_joinWithPasswordButton != null)\n            _joinWithPasswordButton.onClick.AddListener(JoinRoomWithPassword);\n\n        if (_cancelPasswordButton != null)\n            _cancelPasswordButton.onClick.AddListener(CancelPasswordEntry);\n\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(false);\n\n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(false);\n    }\n\n    private void SetCurrentPlayerName()\n    {\n        _currentPlayerName = \"Player_\" + Random.Range(1000, 9999);\n    }\n\n    public void ShowCreateRoomPanel()\n    {\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(true);\n    }\n\n    public void HideCreateRoomPanel()\n    {\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(false);\n    }\n\n    public void CreateRoom()\n    {\n        string roomName = _roomNameInput != null ? _roomNameInput.text : \"New Room\";\n        int maxPlayers = _defaultMaxPlayers;\n\n        if (_maxPlayersInput != null && !string.IsNullOrEmpty(_maxPlayersInput.text))\n        {\n            if (!int.TryParse(_maxPlayersInput.text, out maxPlayers))\n                maxPlayers = _defaultMaxPlayers;\n        }\n\n        maxPlayers = Mathf.Clamp(maxPlayers, 1, 8);\n\n        bool isPrivate = _privateRoomToggle != null && _privateRoomToggle.isOn;\n        string password = isPrivate && _passwordInput != null ? _passwordInput.text : \"\";\n\n        if (string.IsNullOrEmpty(roomName.Trim()))\n        {\n            _roomEvents.OnError?.Invoke(\"Room name cannot be empty\");\n            return;\n        }\n\n        if (_rooms.Count >= _maxRoomsCount)\n        {\n            _roomEvents.OnError?.Invoke(\"Maximum number of rooms reached\");\n            return;\n        }\n\n        string roomId = System.Guid.NewGuid().ToString();\n        Room newRoom = new Room(roomName.Trim(), roomId, maxPlayers, isPrivate, password);\n\n        _rooms[roomId] = newRoom;\n        newRoom.AddPlayer(_currentPlayerName);\n        _currentRoom = newRoom;\n\n        _roomEvents.OnRoomCreated?.Invoke(newRoom);\n        UpdateCurrentRoomUI();\n        HideCreateRoomPanel();\n        RefreshRoomList();\n    }\n\n    public void JoinRoom(string roomId)\n    {\n        if (!_rooms.ContainsKey(roomId))\n        {\n            _roomEvents.OnError?.Invoke(\"Room not found\");\n            return;\n        }\n\n        Room room = _rooms[roomId];\n\n        if (!room.CanJoin())\n        {\n            _roomEvents.OnError?.Invoke(\"Cannot join room\");\n            return;\n        }\n\n        if (room.isPrivate)\n        {\n            _pendingJoinRoom = room;\n            ShowPasswordPanel();\n            return;\n        }\n\n        JoinRoomInternal(room);\n    }\n\n    private void JoinRoomInternal(Room room)\n    {\n        if (_currentRoom != null)\n            LeaveCurrentRoom();\n\n        if (room.AddPlayer(_currentPlayerName))\n        {\n            _currentRoom = room;\n            _roomEvents.OnRoomJoined?.Invoke(room);\n            UpdateCurrentRoomUI();\n            RefreshRoomList();\n        }\n        else\n        {\n            _roomEvents.OnError?.Invoke(\"Failed to join room\");\n        }\n    }\n\n    private void ShowPasswordPanel()\n    {\n        if (_passwordPanel != null)\n        {\n            _passwordPanel.SetActive(true);\n            if (_passwordEntryInput != null)\n                _passwordEntryInput.text = \"\";\n        }\n    }\n\n    private void JoinRoomWithPassword()\n    {\n        if (_pendingJoinRoom == null)\n            return;\n\n        string enteredPassword = _passwordEntryInput != null ? _passwordEntryInput.text : \"\";\n\n        if (_pendingJoinRoom.password == enteredPassword)\n        {\n            JoinRoomInternal(_pendingJoinRoom);\n            _passwordPanel.SetActive(false);\n            _pendingJoinRoom = null;\n        }\n        else\n        {\n            _roomEvents.OnError?.Invoke(\"Incorrect password\");\n        }\n    }\n\n    private void CancelPasswordEntry()\n    {\n        _pendingJoinRoom = null;\n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n    }\n\n    public void LeaveCurrentRoom()\n    {\n        if (_currentRoom == null)\n            return;\n\n        _currentRoom.RemovePlayer(_currentPlayerName);\n\n        if (_currentRoom.currentPlayers == 0)\n        {\n            _rooms.Remove(_currentRoom.roomId);\n            _roomEvents.OnRoomDeleted?.Invoke(_currentRoom.roomId);\n        }\n        else\n        {\n            _roomEvents.OnRoomUpdated?.Invoke(_currentRoom);\n        }\n\n        _roomEvents.OnRoomLeft?.Invoke(_currentRoom);\n        _currentRoom = null;\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(false);\n\n        RefreshRoomList();\n    }\n\n    public void StartGame()\n    {\n        if (_currentRoom == null)\n            return;\n\n        _currentRoom.isInGame = true;\n        _roomEvents.OnRoomUpdated?.Invoke(_currentRoom);\n        RefreshRoomList();\n    }\n\n    public void RefreshRoomList()\n    {\n        ClearRoomUI();\n        CreateRoomUIItems();\n    }\n\n    private void UpdateRoomList()\n    {\n        if (_currentRoom != null)\n            UpdateCurrentRoomUI();\n    }\n\n    private void ClearRoomUI()\n    {\n        foreach (GameObject item in _roomUIItems)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _roomUIItems.Clear();\n    }\n\n    private void CreateRoomUIItems()\n    {\n        if (_roomListParent == null || _roomItemPrefab == null)\n            return;\n\n        foreach (Room room in _rooms.Values)\n        {\n            GameObject roomItem = Instantiate(_roomItemPrefab, _roomListParent);\n            _roomUIItems.Add(roomItem);\n\n            Text[] texts = roomItem.GetComponentsInChildren<Text>();\n            if (texts.Length >= 3)\n            {\n                texts[0].text = room.roomName;\n                texts[1].text = $\"{room.currentPlayers}/{room.maxPlayers}\";\n                texts[2].text = room.isInGame ? \"In Game\" : \"Waiting\";\n            }\n\n            Button joinButton = roomItem.GetComponentInChildren<Button>();\n            if (joinButton != null)\n            {\n                string roomId = room.roomId;\n                joinButton.onClick.RemoveAllListeners();\n                joinButton.onClick.AddListener(() => JoinRoom(roomId));\n                joinButton.interactable = room.CanJoin();\n            }\n\n            Image lockIcon = roomItem.transform.Find(\"LockIcon\")?.GetComponent<Image>();\n            if (lockIcon != null)\n                lockIcon.gameObject.SetActive(room.isPrivate);\n        }\n    }\n\n    private void UpdateCurrentRoomUI()\n    {\n        if (_currentRoom == null)\n        {\n            if (_currentRoomPanel != null)\n                _currentRoomPanel.SetActive(false);\n            return;\n        }\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(true);\n\n        if (_currentRoomNameText != null)\n            _currentRoomNameText.text = _currentRoom.roomName;\n\n        if (_currentRoomPlayersText != null)\n            _currentRoomPlayersText.text = $\"Players: {_currentRoom.currentPlayers}/{_currentRoom.maxPlayers}\";\n\n        UpdatePlayerList();\n\n        if (_startGameButton != null)\n            _startGameButton.interactable = _currentRoom.currentPlayers > 1 && !_currentRoom.isInGame;\n    }\n\n    private void UpdatePlayerList()\n    {\n        ClearPlayerUI();\n\n        if (_playerListParent == null || _playerItemPrefab == null || _currentRoom == null)\n            return;\n\n        foreach (string playerName in _currentRoom.playerNames)\n        {\n            GameObject playerItem = Instantiate(_playerItemPrefab, _playerListParent);\n            _playerUIItems.Add(playerItem);\n\n            Text playerText = playerItem.GetComponentInChildren<Text>();\n            if (playerText != null)\n                playerText.text = playerName;\n        }\n    }\n\n    private void ClearPlayerUI()\n    {\n        foreach (GameObject item in _playerUIItems)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _playerUIItems.Clear();\n    }\n\n    public Room GetCurrentRoom()\n    {\n        return _currentRoom;\n    }\n\n    public Dictionary<string, Room> GetAllRooms()\n    {\n        return new Dictionary<string, Room>(_rooms);\n    }\n\n    public void SetPlayerName(string playerName)\n    {\n        if (!string.IsNullOrEmpty(playerName))\n            _currentPlayerName = playerName;\n    }\n\n    public string GetPlayerName()\n    {\n        return _currentPlayerName;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "matchmaking queue",
      "ideal_ir": {
        "class_name": "MatchmakingQueue",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "maxPlayersPerMatch",
            "type": "int",
            "default": 4
          },
          {
            "name": "queueTimeoutSeconds",
            "type": "float",
            "default": 60
          },
          {
            "name": "skillRangeThreshold",
            "type": "float",
            "default": 100
          },
          {
            "name": "waitingPlayers",
            "type": "List<Player>",
            "default": null
          },
          {
            "name": "currentQueueTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "isSearchingForMatch",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "join_queue",
            "trigger": "when player requests to join matchmaking",
            "actions": [
              {
                "action": "add player to waiting players list"
              },
              {
                "action": "set searching for match to true"
              },
              {
                "action": "reset current queue time to zero"
              },
              {
                "action": "display queue status to player"
              }
            ]
          },
          {
            "name": "leave_queue",
            "trigger": "when player cancels matchmaking or leaves",
            "actions": [
              {
                "action": "remove player from waiting players list"
              },
              {
                "action": "set searching for match to false"
              },
              {
                "action": "hide queue status display"
              }
            ]
          },
          {
            "name": "find_match",
            "trigger": "when enough players with similar skill levels are in queue",
            "actions": [
              {
                "action": "group compatible players together"
              },
              {
                "action": "remove matched players from waiting list"
              },
              {
                "action": "create new match session"
              },
              {
                "action": "notify all matched players"
              },
              {
                "action": "transfer players to game lobby"
              }
            ]
          },
          {
            "name": "update_queue_time",
            "trigger": "every frame while searching for match",
            "actions": [
              {
                "action": "increase current queue time"
              },
              {
                "action": "update queue timer display"
              }
            ]
          },
          {
            "name": "handle_queue_timeout",
            "trigger": "when queue time exceeds timeout limit",
            "actions": [
              {
                "action": "expand skill range threshold"
              },
              {
                "action": "notify player of extended search"
              },
              {
                "action": "reset queue time if still no match found"
              }
            ]
          },
          {
            "name": "check_skill_compatibility",
            "trigger": "when evaluating potential player matches",
            "actions": [
              {
                "action": "compare player skill ratings"
              },
              {
                "action": "determine if players fall within acceptable range"
              },
              {
                "action": "prioritize closer skill matches"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.UI;\n\npublic class MatchmakingQueue : MonoBehaviour\n{\n    [System.Serializable]\n    public class PlayerData\n    {\n        public string playerId;\n        public string playerName;\n        public int skillRating;\n        public float queueTime;\n        public bool isReady;\n        \n        public PlayerData(string id, string name, int rating)\n        {\n            playerId = id;\n            playerName = name;\n            skillRating = rating;\n            queueTime = 0f;\n            isReady = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class Match\n    {\n        public List<PlayerData> players;\n        public string matchId;\n        public float averageSkillRating;\n        \n        public Match()\n        {\n            players = new List<PlayerData>();\n            matchId = System.Guid.NewGuid().ToString();\n        }\n    }\n    \n    [System.Serializable]\n    public class MatchmakingEvents\n    {\n        public UnityEvent<PlayerData> OnPlayerJoinedQueue;\n        public UnityEvent<PlayerData> OnPlayerLeftQueue;\n        public UnityEvent<Match> OnMatchFound;\n        public UnityEvent<string> OnMatchmakingStatusChanged;\n    }\n    \n    [Header(\"Queue Settings\")]\n    [SerializeField] private int _maxPlayersPerMatch = 4;\n    [SerializeField] private int _minPlayersPerMatch = 2;\n    [SerializeField] private float _maxSkillRatingDifference = 200f;\n    [SerializeField] private float _queueTimeExpansionRate = 50f;\n    [SerializeField] private float _maxQueueTime = 300f;\n    \n    [Header(\"Matchmaking Intervals\")]\n    [SerializeField] private float _matchmakingInterval = 2f;\n    [SerializeField] private float _queueUpdateInterval = 1f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _queueStatusText;\n    [SerializeField] private Text _playersInQueueText;\n    [SerializeField] private Text _estimatedWaitTimeText;\n    [SerializeField] private Button _joinQueueButton;\n    [SerializeField] private Button _leaveQueueButton;\n    [SerializeField] private Slider _queueProgressSlider;\n    \n    [Header(\"Events\")]\n    [SerializeField] private MatchmakingEvents _events;\n    \n    private List<PlayerData> _queuedPlayers = new List<PlayerData>();\n    private List<Match> _activeMatches = new List<Match>();\n    private PlayerData _localPlayer;\n    private bool _isInQueue = false;\n    private bool _isMatchmakingActive = true;\n    private Coroutine _matchmakingCoroutine;\n    private Coroutine _queueUpdateCoroutine;\n    \n    public bool IsInQueue => _isInQueue;\n    public int PlayersInQueue => _queuedPlayers.Count;\n    public float LocalPlayerQueueTime => _localPlayer?.queueTime ?? 0f;\n    \n    private void Start()\n    {\n        InitializeUI();\n        StartMatchmaking();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_joinQueueButton != null)\n            _joinQueueButton.onClick.AddListener(JoinQueue);\n            \n        if (_leaveQueueButton != null)\n            _leaveQueueButton.onClick.AddListener(LeaveQueue);\n            \n        UpdateUI();\n    }\n    \n    private void StartMatchmaking()\n    {\n        if (_matchmakingCoroutine != null)\n            StopCoroutine(_matchmakingCoroutine);\n            \n        if (_queueUpdateCoroutine != null)\n            StopCoroutine(_queueUpdateCoroutine);\n            \n        _matchmakingCoroutine = StartCoroutine(MatchmakingLoop());\n        _queueUpdateCoroutine = StartCoroutine(QueueUpdateLoop());\n    }\n    \n    public void JoinQueue()\n    {\n        if (_isInQueue) return;\n        \n        string playerId = SystemInfo.deviceUniqueIdentifier;\n        string playerName = \"Player_\" + UnityEngine.Random.Range(1000, 9999);\n        int skillRating = UnityEngine.Random.Range(1000, 2000);\n        \n        JoinQueue(playerId, playerName, skillRating);\n    }\n    \n    public void JoinQueue(string playerId, string playerName, int skillRating)\n    {\n        if (_isInQueue) return;\n        \n        _localPlayer = new PlayerData(playerId, playerName, skillRating);\n        _queuedPlayers.Add(_localPlayer);\n        _isInQueue = true;\n        \n        _events.OnPlayerJoinedQueue?.Invoke(_localPlayer);\n        _events.OnMatchmakingStatusChanged?.Invoke(\"Joined queue\");\n        \n        UpdateUI();\n    }\n    \n    public void LeaveQueue()\n    {\n        if (!_isInQueue || _localPlayer == null) return;\n        \n        _queuedPlayers.Remove(_localPlayer);\n        _events.OnPlayerLeftQueue?.Invoke(_localPlayer);\n        _events.OnMatchmakingStatusChanged?.Invoke(\"Left queue\");\n        \n        _localPlayer = null;\n        _isInQueue = false;\n        \n        UpdateUI();\n    }\n    \n    public void AddBotToQueue()\n    {\n        string botId = \"Bot_\" + System.Guid.NewGuid().ToString();\n        string botName = \"Bot_\" + UnityEngine.Random.Range(100, 999);\n        int botRating = UnityEngine.Random.Range(1000, 2000);\n        \n        PlayerData bot = new PlayerData(botId, botName, botRating);\n        _queuedPlayers.Add(bot);\n        \n        _events.OnPlayerJoinedQueue?.Invoke(bot);\n        UpdateUI();\n    }\n    \n    private IEnumerator MatchmakingLoop()\n    {\n        while (_isMatchmakingActive)\n        {\n            if (_queuedPlayers.Count >= _minPlayersPerMatch)\n            {\n                TryCreateMatches();\n            }\n            \n            yield return new WaitForSeconds(_matchmakingInterval);\n        }\n    }\n    \n    private IEnumerator QueueUpdateLoop()\n    {\n        while (_isMatchmakingActive)\n        {\n            UpdateQueueTimes();\n            UpdateUI();\n            \n            yield return new WaitForSeconds(_queueUpdateInterval);\n        }\n    }\n    \n    private void UpdateQueueTimes()\n    {\n        for (int i = 0; i < _queuedPlayers.Count; i++)\n        {\n            _queuedPlayers[i].queueTime += _queueUpdateInterval;\n            \n            if (_queuedPlayers[i].queueTime > _maxQueueTime)\n            {\n                RemovePlayerFromQueue(_queuedPlayers[i]);\n                i--;\n            }\n        }\n    }\n    \n    private void TryCreateMatches()\n    {\n        List<PlayerData> availablePlayers = new List<PlayerData>(_queuedPlayers);\n        availablePlayers.Sort((a, b) => a.queueTime.CompareTo(b.queueTime));\n        \n        while (availablePlayers.Count >= _minPlayersPerMatch)\n        {\n            Match match = CreateMatch(availablePlayers);\n            if (match != null && match.players.Count >= _minPlayersPerMatch)\n            {\n                _activeMatches.Add(match);\n                \n                foreach (PlayerData player in match.players)\n                {\n                    _queuedPlayers.Remove(player);\n                    availablePlayers.Remove(player);\n                }\n                \n                _events.OnMatchFound?.Invoke(match);\n                _events.OnMatchmakingStatusChanged?.Invoke($\"Match found with {match.players.Count} players\");\n                \n                if (_localPlayer != null && match.players.Contains(_localPlayer))\n                {\n                    _isInQueue = false;\n                    _localPlayer = null;\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    \n    private Match CreateMatch(List<PlayerData> availablePlayers)\n    {\n        if (availablePlayers.Count < _minPlayersPerMatch) return null;\n        \n        Match match = new Match();\n        PlayerData anchor = availablePlayers[0];\n        match.players.Add(anchor);\n        availablePlayers.RemoveAt(0);\n        \n        float expandedSkillRange = _maxSkillRatingDifference + (anchor.queueTime * _queueTimeExpansionRate);\n        \n        for (int i = availablePlayers.Count - 1; i >= 0 && match.players.Count < _maxPlayersPerMatch; i--)\n        {\n            PlayerData candidate = availablePlayers[i];\n            \n            if (IsPlayerCompatible(match, candidate, expandedSkillRange))\n            {\n                match.players.Add(candidate);\n                availablePlayers.RemoveAt(i);\n            }\n        }\n        \n        if (match.players.Count >= _minPlayersPerMatch)\n        {\n            CalculateMatchAverageRating(match);\n            return match;\n        }\n        \n        return null;\n    }\n    \n    private bool IsPlayerCompatible(Match match, PlayerData candidate, float skillRange)\n    {\n        foreach (PlayerData player in match.players)\n        {\n            if (Mathf.Abs(player.skillRating - candidate.skillRating) > skillRange)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private void CalculateMatchAverageRating(Match match)\n    {\n        float totalRating = 0f;\n        foreach (PlayerData player in match.players)\n        {\n            totalRating += player.skillRating;\n        }\n        match.averageSkillRating = totalRating / match.players.Count;\n    }\n    \n    private void RemovePlayerFromQueue(PlayerData player)\n    {\n        if (_queuedPlayers.Remove(player))\n        {\n            _events.OnPlayerLeftQueue?.Invoke(player);\n            \n            if (player == _localPlayer)\n            {\n                _isInQueue = false;\n                _localPlayer = null;\n                _events.OnMatchmakingStatusChanged?.Invoke(\"Removed from queue (timeout)\");\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_queueStatusText != null)\n        {\n            if (_isInQueue)\n            {\n                _queueStatusText.text = $\"In Queue ({LocalPlayerQueueTime:F0}s)\";\n            }\n            else\n            {\n                _queueStatusText.text = \"Not in queue\";\n            }\n        }\n        \n        if (_playersInQueueText != null)\n        {\n            _playersInQueueText.text = $\"Players in queue: {PlayersInQueue}\";\n        }\n        \n        if (_estimatedWaitTimeText != null)\n        {\n            float estimatedWait = CalculateEstimatedWaitTime();\n            _estimatedWaitTimeText.text = $\"Estimated wait: {estimatedWait:F0}s\";\n        }\n        \n        if (_joinQueueButton != null)\n        {\n            _joinQueueButton.interactable = !_isInQueue;\n        }\n        \n        if (_leaveQueueButton != null)\n        {\n            _leaveQueueButton.interactable = _isInQueue;\n        }\n        \n        if (_queueProgressSlider != null)\n        {\n            if (_isInQueue && _localPlayer != null)\n            {\n                _queueProgressSlider.value = Mathf.Clamp01(_localPlayer.queueTime / _maxQueueTime);\n            }\n            else\n            {\n                _queueProgressSlider.value = 0f;\n            }\n        }\n    }\n    \n    private float CalculateEstimatedWaitTime()\n    {\n        if (PlayersInQueue < _minPlayersPerMatch)\n        {\n            return 60f;\n        }\n        \n        float averageQueueTime = 0f;\n        foreach (PlayerData player in _queuedPlayers)\n        {\n            averageQueueTime += player.queueTime;\n        }\n        averageQueueTime /= _queuedPlayers.Count;\n        \n        return Mathf.Max(10f, 30f - (PlayersInQueue * 2f));\n    }\n    \n    public void SetMatchmakingActive(bool active)\n    {\n        _isMatchmakingActive = active;\n        \n        if (active)\n        {\n            StartMatchmaking();\n        }\n        else\n        {\n            if (_matchmakingCoroutine != null)\n                StopCoroutine(_matchmakingCoroutine);\n            if (_queueUpdateCoroutine != null)\n                StopCoroutine(_queueUpdateCoroutine);\n        }\n    }\n    \n    public List<PlayerData> GetQueuedPlayers()\n    {\n        return new List<PlayerData>(_queuedPlayers);\n    }\n    \n    public List<Match> GetActiveMatches()\n    {\n        return new List<Match>(_activeMatches);\n    }\n    \n    private void OnDestroy()\n    {\n        SetMatchmakingActive(false);\n        \n        if (_joinQueueButton != null)\n            _joinQueueButton.onClick.RemoveAllListeners();\n        if (_leaveQueueButton != null)\n            _leaveQueueButton.onClick.RemoveAllListeners();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "player ready state",
      "ideal_ir": {
        "class_name": "PlayerReadyState",
        "components": [
          "Transform",
          "Rigidbody",
          "Collider"
        ],
        "fields": [
          {
            "name": "isReady",
            "type": "bool",
            "default": false
          },
          {
            "name": "readyDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "idleAnimationName",
            "type": "string",
            "default": "Idle"
          },
          {
            "name": "readyAnimationName",
            "type": "string",
            "default": "Ready"
          }
        ],
        "behaviors": [
          {
            "name": "enter_ready_state",
            "trigger": "when ready input is pressed",
            "actions": [
              {
                "action": "set ready status to true"
              },
              {
                "action": "play ready animation"
              },
              {
                "action": "start ready timer"
              }
            ]
          },
          {
            "name": "maintain_ready_stance",
            "trigger": "while in ready state",
            "actions": [
              {
                "action": "prevent movement"
              },
              {
                "action": "face forward direction"
              },
              {
                "action": "maintain ready animation loop"
              }
            ]
          },
          {
            "name": "exit_ready_state",
            "trigger": "when ready duration expires or input is released",
            "actions": [
              {
                "action": "set ready status to false"
              },
              {
                "action": "return to idle animation"
              },
              {
                "action": "restore normal movement"
              }
            ]
          },
          {
            "name": "cancel_ready_state",
            "trigger": "when movement input is detected while ready",
            "actions": [
              {
                "action": "immediately exit ready state"
              },
              {
                "action": "transition to movement state"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class PlayerReadyState : MonoBehaviour\n{\n    [Header(\"Ready State Settings\")]\n    [SerializeField] private bool _isReady = false;\n    [SerializeField] private float _readyCheckInterval = 0.1f;\n    [SerializeField] private bool _requireGrounded = true;\n    [SerializeField] private bool _requireMinHealth = false;\n    [SerializeField] private float _minHealthThreshold = 50f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _readyKey = KeyCode.R;\n    [SerializeField] private string _readyButton = \"Fire1\";\n    [SerializeField] private bool _useKeyInput = true;\n    [SerializeField] private bool _useButtonInput = false;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Health Check\")]\n    [SerializeField] private float _currentHealth = 100f;\n    [SerializeField] private float _maxHealth = 100f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _readyIndicator;\n    [SerializeField] private Color _readyColor = Color.green;\n    [SerializeField] private Color _notReadyColor = Color.red;\n    [SerializeField] private Renderer _playerRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _readySound;\n    [SerializeField] private AudioClip _notReadySound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBecomeReady;\n    public UnityEvent OnBecomeNotReady;\n    public UnityEvent OnReadyStateChanged;\n    \n    private bool _wasReady = false;\n    private Rigidbody _rigidbody;\n    private CharacterController _characterController;\n    private Material _originalMaterial;\n    private Color _originalColor;\n    \n    public bool IsReady => _isReady;\n    public float CurrentHealth => _currentHealth;\n    public float HealthPercentage => _currentHealth / _maxHealth;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        InitializeVisuals();\n        StartCoroutine(ReadyStateCheckCoroutine());\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _characterController = GetComponent<CharacterController>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_groundCheckPoint == null)\n            _groundCheckPoint = transform;\n    }\n    \n    private void InitializeVisuals()\n    {\n        if (_playerRenderer != null)\n        {\n            _originalMaterial = _playerRenderer.material;\n            _originalColor = _originalMaterial.color;\n        }\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n    }\n    \n    private void HandleInput()\n    {\n        bool inputPressed = false;\n        \n        if (_useKeyInput && Input.GetKeyDown(_readyKey))\n            inputPressed = true;\n            \n        if (_useButtonInput && Input.GetButtonDown(_readyButton))\n            inputPressed = true;\n            \n        if (inputPressed)\n        {\n            ToggleReadyState();\n        }\n    }\n    \n    private IEnumerator ReadyStateCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckReadyConditions();\n            yield return new WaitForSeconds(_readyCheckInterval);\n        }\n    }\n    \n    private void CheckReadyConditions()\n    {\n        bool canBeReady = true;\n        \n        if (_requireGrounded && !IsGrounded())\n            canBeReady = false;\n            \n        if (_requireMinHealth && _currentHealth < _minHealthThreshold)\n            canBeReady = false;\n            \n        bool newReadyState = _isReady && canBeReady;\n        \n        if (newReadyState != _wasReady)\n        {\n            _isReady = newReadyState;\n            OnReadyStateChange();\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        if (_groundCheckPoint == null) return true;\n        \n        return Physics.CheckSphere(_groundCheckPoint.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    public void ToggleReadyState()\n    {\n        SetReadyState(!_isReady);\n    }\n    \n    public void SetReadyState(bool ready)\n    {\n        bool canBeReady = true;\n        \n        if (ready)\n        {\n            if (_requireGrounded && !IsGrounded())\n                canBeReady = false;\n                \n            if (_requireMinHealth && _currentHealth < _minHealthThreshold)\n                canBeReady = false;\n        }\n        \n        bool newState = ready && canBeReady;\n        \n        if (newState != _isReady)\n        {\n            _isReady = newState;\n            OnReadyStateChange();\n        }\n    }\n    \n    private void OnReadyStateChange()\n    {\n        if (_isReady != _wasReady)\n        {\n            if (_isReady)\n            {\n                OnBecomeReady?.Invoke();\n                PlayReadySound();\n            }\n            else\n            {\n                OnBecomeNotReady?.Invoke();\n                PlayNotReadySound();\n            }\n            \n            OnReadyStateChanged?.Invoke();\n            UpdateVisualFeedback();\n            _wasReady = _isReady;\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_readyIndicator != null)\n        {\n            _readyIndicator.SetActive(_isReady);\n        }\n        \n        if (_playerRenderer != null)\n        {\n            Color targetColor = _isReady ? _readyColor : _notReadyColor;\n            _playerRenderer.material.color = Color.Lerp(_originalColor, targetColor, 0.5f);\n        }\n    }\n    \n    private void PlayReadySound()\n    {\n        if (_audioSource != null && _readySound != null)\n        {\n            _audioSource.PlayOneShot(_readySound);\n        }\n    }\n    \n    private void PlayNotReadySound()\n    {\n        if (_audioSource != null && _notReadySound != null)\n        {\n            _audioSource.PlayOneShot(_notReadySound);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        CheckReadyConditions();\n    }\n    \n    public void Heal(float healAmount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        CheckReadyConditions();\n    }\n    \n    public void SetHealth(float health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        CheckReadyConditions();\n    }\n    \n    public void ResetReadyState()\n    {\n        _isReady = false;\n        _wasReady = false;\n        UpdateVisualFeedback();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = IsGrounded() ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, _groundCheckRadius);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _minHealthThreshold = Mathf.Clamp(_minHealthThreshold, 0f, _maxHealth);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "sync transform over network",
      "ideal_ir": {
        "class_name": "NetworkTransformSync",
        "components": [
          "NetworkBehaviour"
        ],
        "fields": [
          {
            "name": "syncPosition",
            "type": "bool",
            "default": true
          },
          {
            "name": "syncRotation",
            "type": "bool",
            "default": true
          },
          {
            "name": "syncScale",
            "type": "bool",
            "default": false
          },
          {
            "name": "sendRate",
            "type": "float",
            "default": 20
          },
          {
            "name": "interpolationSpeed",
            "type": "float",
            "default": 10
          }
        ],
        "behaviors": [
          {
            "name": "send_transform_data",
            "trigger": "when this client has authority and transform changes",
            "actions": [
              {
                "action": "send current position rotation and scale to all other clients"
              }
            ]
          },
          {
            "name": "receive_transform_data",
            "trigger": "when transform data is received from network",
            "actions": [
              {
                "action": "store received position rotation and scale as target values"
              }
            ]
          },
          {
            "name": "interpolate_to_target",
            "trigger": "every frame when not having authority",
            "actions": [
              {
                "action": "smoothly move position toward target position"
              },
              {
                "action": "smoothly rotate toward target rotation"
              },
              {
                "action": "smoothly scale toward target scale"
              }
            ]
          },
          {
            "name": "authority_check",
            "trigger": "when network authority changes",
            "actions": [
              {
                "action": "enable or disable transform sending based on authority status"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Networking;\nusing System.Collections;\n\npublic class NetworkTransformSync : NetworkBehaviour\n{\n    [Header(\"Sync Settings\")]\n    [SerializeField] private bool _syncPosition = true;\n    [SerializeField] private bool _syncRotation = true;\n    [SerializeField] private bool _syncScale = false;\n    \n    [Header(\"Interpolation\")]\n    [SerializeField] private float _lerpRate = 15f;\n    [SerializeField] private float _snapThreshold = 5f;\n    [SerializeField] private bool _useInterpolation = true;\n    \n    [Header(\"Network Settings\")]\n    [SerializeField] private float _sendRate = 20f;\n    [SerializeField] private bool _compressRotation = true;\n    \n    private Vector3 _networkPosition;\n    private Quaternion _networkRotation;\n    private Vector3 _networkScale;\n    \n    private Vector3 _lastSentPosition;\n    private Quaternion _lastSentRotation;\n    private Vector3 _lastSentScale;\n    \n    private float _lastSendTime;\n    private float _sendInterval;\n    \n    private bool _hasReceivedData = false;\n\n    void Start()\n    {\n        _sendInterval = 1f / _sendRate;\n        \n        if (isLocalPlayer)\n        {\n            _networkPosition = transform.position;\n            _networkRotation = transform.rotation;\n            _networkScale = transform.localScale;\n        }\n    }\n\n    void Update()\n    {\n        if (isLocalPlayer)\n        {\n            CheckForChangesAndSend();\n        }\n        else if (_hasReceivedData && _useInterpolation)\n        {\n            InterpolateTransform();\n        }\n    }\n\n    private void CheckForChangesAndSend()\n    {\n        if (Time.time - _lastSendTime < _sendInterval)\n            return;\n\n        bool hasChanged = false;\n\n        if (_syncPosition && Vector3.Distance(transform.position, _lastSentPosition) > 0.01f)\n        {\n            hasChanged = true;\n        }\n\n        if (_syncRotation && Quaternion.Angle(transform.rotation, _lastSentRotation) > 0.1f)\n        {\n            hasChanged = true;\n        }\n\n        if (_syncScale && Vector3.Distance(transform.localScale, _lastSentScale) > 0.01f)\n        {\n            hasChanged = true;\n        }\n\n        if (hasChanged)\n        {\n            CmdSendTransform(transform.position, transform.rotation, transform.localScale);\n            _lastSendTime = Time.time;\n            _lastSentPosition = transform.position;\n            _lastSentRotation = transform.rotation;\n            _lastSentScale = transform.localScale;\n        }\n    }\n\n    [Command]\n    private void CmdSendTransform(Vector3 position, Quaternion rotation, Vector3 scale)\n    {\n        RpcReceiveTransform(position, rotation, scale);\n    }\n\n    [ClientRpc]\n    private void RpcReceiveTransform(Vector3 position, Quaternion rotation, Vector3 scale)\n    {\n        if (isLocalPlayer)\n            return;\n\n        _networkPosition = position;\n        _networkRotation = rotation;\n        _networkScale = scale;\n        _hasReceivedData = true;\n\n        if (!_useInterpolation)\n        {\n            ApplyTransformDirectly();\n        }\n        else\n        {\n            // Check if we need to snap due to large distance\n            if (_syncPosition && Vector3.Distance(transform.position, _networkPosition) > _snapThreshold)\n            {\n                transform.position = _networkPosition;\n            }\n        }\n    }\n\n    private void InterpolateTransform()\n    {\n        if (_syncPosition)\n        {\n            transform.position = Vector3.Lerp(transform.position, _networkPosition, _lerpRate * Time.deltaTime);\n        }\n\n        if (_syncRotation)\n        {\n            transform.rotation = Quaternion.Lerp(transform.rotation, _networkRotation, _lerpRate * Time.deltaTime);\n        }\n\n        if (_syncScale)\n        {\n            transform.localScale = Vector3.Lerp(transform.localScale, _networkScale, _lerpRate * Time.deltaTime);\n        }\n    }\n\n    private void ApplyTransformDirectly()\n    {\n        if (_syncPosition)\n        {\n            transform.position = _networkPosition;\n        }\n\n        if (_syncRotation)\n        {\n            transform.rotation = _networkRotation;\n        }\n\n        if (_syncScale)\n        {\n            transform.localScale = _networkScale;\n        }\n    }\n\n    public override void OnStartLocalPlayer()\n    {\n        // Initialize network values for local player\n        _networkPosition = transform.position;\n        _networkRotation = transform.rotation;\n        _networkScale = transform.localScale;\n        \n        _lastSentPosition = transform.position;\n        _lastSentRotation = transform.rotation;\n        _lastSentScale = transform.localScale;\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        if (!isLocalPlayer && _hasReceivedData)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_networkPosition, 0.1f);\n            \n            Gizmos.color = Color.blue;\n            Gizmos.DrawRay(_networkPosition, _networkRotation * Vector3.forward);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "interpolate remote player",
      "ideal_ir": {
        "class_name": "RemotePlayerInterpolator",
        "components": [
          "Transform",
          "NetworkBehaviour"
        ],
        "fields": [
          {
            "name": "interpolationSpeed",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "targetPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "targetRotation",
            "type": "Quaternion",
            "default": "Quaternion.identity"
          },
          {
            "name": "positionThreshold",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "rotationThreshold",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "receive_network_position",
            "trigger": "when network position data is received from remote player",
            "actions": [
              {
                "action": "store received position as target position"
              },
              {
                "action": "store received rotation as target rotation"
              }
            ]
          },
          {
            "name": "interpolate_position",
            "trigger": "every frame when current position differs from target position by more than threshold",
            "actions": [
              {
                "action": "smoothly move current position toward target position using interpolation speed"
              },
              {
                "action": "update transform position with interpolated value"
              }
            ]
          },
          {
            "name": "interpolate_rotation",
            "trigger": "every frame when current rotation differs from target rotation by more than threshold",
            "actions": [
              {
                "action": "smoothly rotate current rotation toward target rotation using interpolation speed"
              },
              {
                "action": "update transform rotation with interpolated value"
              }
            ]
          },
          {
            "name": "snap_when_too_far",
            "trigger": "when distance between current position and target position is very large",
            "actions": [
              {
                "action": "instantly set position to target position"
              },
              {
                "action": "instantly set rotation to target rotation"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RemotePlayerInterpolator : MonoBehaviour\n{\n    [Header(\"Interpolation Settings\")]\n    [SerializeField] private float _interpolationRate = 15f;\n    [SerializeField] private float _extrapolationLimit = 0.5f;\n    [SerializeField] private bool _useExtrapolation = true;\n    [SerializeField] private float _maxInterpolationDistance = 10f;\n    \n    [Header(\"Network Settings\")]\n    [SerializeField] private float _sendRate = 20f;\n    [SerializeField] private float _networkDelay = 0.1f;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    [SerializeField] private Color _debugLineColor = Color.red;\n\n    private struct NetworkState\n    {\n        public float timestamp;\n        public Vector3 position;\n        public Quaternion rotation;\n        public Vector3 velocity;\n    }\n\n    private Queue<NetworkState> _stateBuffer = new Queue<NetworkState>();\n    private NetworkState _currentState;\n    private NetworkState _previousState;\n    private Vector3 _lastPosition;\n    private float _lastUpdateTime;\n    private bool _hasReceivedData = false;\n\n    private void Start()\n    {\n        _lastPosition = transform.position;\n        _lastUpdateTime = Time.time;\n        \n        _currentState = new NetworkState\n        {\n            timestamp = Time.time,\n            position = transform.position,\n            rotation = transform.rotation,\n            velocity = Vector3.zero\n        };\n        \n        _previousState = _currentState;\n    }\n\n    private void Update()\n    {\n        if (!_hasReceivedData) return;\n\n        float renderTime = Time.time - _networkDelay;\n        InterpolatePosition(renderTime);\n        \n        if (_showDebugInfo)\n        {\n            DrawDebugInfo();\n        }\n    }\n\n    public void ReceiveNetworkUpdate(Vector3 position, Quaternion rotation, float timestamp)\n    {\n        Vector3 velocity = Vector3.zero;\n        \n        if (_hasReceivedData)\n        {\n            float deltaTime = timestamp - _currentState.timestamp;\n            if (deltaTime > 0)\n            {\n                velocity = (position - _currentState.position) / deltaTime;\n            }\n        }\n\n        NetworkState newState = new NetworkState\n        {\n            timestamp = timestamp,\n            position = position,\n            rotation = rotation,\n            velocity = velocity\n        };\n\n        _stateBuffer.Enqueue(newState);\n        \n        // Keep buffer size reasonable\n        while (_stateBuffer.Count > 10)\n        {\n            _stateBuffer.Dequeue();\n        }\n        \n        _hasReceivedData = true;\n    }\n\n    private void InterpolatePosition(float renderTime)\n    {\n        // Find the two states to interpolate between\n        NetworkState from = new NetworkState();\n        NetworkState to = new NetworkState();\n        bool foundStates = false;\n\n        NetworkState[] states = _stateBuffer.ToArray();\n        \n        for (int i = 0; i < states.Length - 1; i++)\n        {\n            if (states[i].timestamp <= renderTime && renderTime <= states[i + 1].timestamp)\n            {\n                from = states[i];\n                to = states[i + 1];\n                foundStates = true;\n                break;\n            }\n        }\n\n        if (!foundStates)\n        {\n            // Use extrapolation if enabled\n            if (_useExtrapolation && states.Length > 0)\n            {\n                NetworkState latest = states[states.Length - 1];\n                float extrapolationTime = renderTime - latest.timestamp;\n                \n                if (extrapolationTime <= _extrapolationLimit)\n                {\n                    Vector3 extrapolatedPosition = latest.position + latest.velocity * extrapolationTime;\n                    \n                    // Check if extrapolation distance is reasonable\n                    float distance = Vector3.Distance(transform.position, extrapolatedPosition);\n                    if (distance <= _maxInterpolationDistance)\n                    {\n                        transform.position = Vector3.Lerp(transform.position, extrapolatedPosition, Time.deltaTime * _interpolationRate);\n                        transform.rotation = Quaternion.Lerp(transform.rotation, latest.rotation, Time.deltaTime * _interpolationRate);\n                    }\n                }\n            }\n            return;\n        }\n\n        // Interpolate between the two states\n        float lerpAmount = 0f;\n        if (to.timestamp != from.timestamp)\n        {\n            lerpAmount = (renderTime - from.timestamp) / (to.timestamp - from.timestamp);\n        }\n\n        Vector3 targetPosition = Vector3.Lerp(from.position, to.position, lerpAmount);\n        Quaternion targetRotation = Quaternion.Lerp(from.rotation, to.rotation, lerpAmount);\n\n        // Check interpolation distance\n        float interpolationDistance = Vector3.Distance(transform.position, targetPosition);\n        if (interpolationDistance <= _maxInterpolationDistance)\n        {\n            transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * _interpolationRate);\n            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * _interpolationRate);\n        }\n        else\n        {\n            // Teleport if too far\n            transform.position = targetPosition;\n            transform.rotation = targetRotation;\n        }\n\n        // Clean up old states\n        CleanupOldStates(renderTime);\n    }\n\n    private void CleanupOldStates(float renderTime)\n    {\n        while (_stateBuffer.Count > 2)\n        {\n            NetworkState oldest = _stateBuffer.Peek();\n            if (oldest.timestamp < renderTime - 1f) // Keep 1 second of history\n            {\n                _stateBuffer.Dequeue();\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void DrawDebugInfo()\n    {\n        if (_stateBuffer.Count < 2) return;\n\n        NetworkState[] states = _stateBuffer.ToArray();\n        \n        // Draw interpolation path\n        for (int i = 0; i < states.Length - 1; i++)\n        {\n            Debug.DrawLine(states[i].position, states[i + 1].position, _debugLineColor, 0.1f);\n        }\n\n        // Draw current position\n        Debug.DrawWireSphere(transform.position, 0.2f, Color.green, 0.1f);\n        \n        // Draw velocity vector\n        if (states.Length > 0)\n        {\n            NetworkState latest = states[states.Length - 1];\n            Debug.DrawRay(transform.position, latest.velocity, Color.blue, 0.1f);\n        }\n    }\n\n    public void SetInterpolationRate(float rate)\n    {\n        _interpolationRate = Mathf.Clamp(rate, 1f, 50f);\n    }\n\n    public void SetNetworkDelay(float delay)\n    {\n        _networkDelay = Mathf.Clamp(delay, 0f, 1f);\n    }\n\n    public bool HasReceivedData()\n    {\n        return _hasReceivedData;\n    }\n\n    public int GetBufferSize()\n    {\n        return _stateBuffer.Count;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (!_showDebugInfo) return;\n\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxInterpolationDistance);\n        \n        if (_stateBuffer != null && _stateBuffer.Count > 0)\n        {\n            NetworkState[] states = _stateBuffer.ToArray();\n            Gizmos.color = Color.red;\n            \n            foreach (NetworkState state in states)\n            {\n                Gizmos.DrawWireCube(state.position, Vector3.one * 0.1f);\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "spawn point assignment",
      "ideal_ir": {
        "class_name": "SpawnPointAssignment",
        "components": [
          "Transform"
        ],
        "fields": [
          {
            "name": "spawnPoints",
            "type": "Transform[]",
            "default": null
          },
          {
            "name": "assignmentMode",
            "type": "string",
            "default": "sequential"
          },
          {
            "name": "currentIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "isOccupied",
            "type": "bool[]",
            "default": null
          },
          {
            "name": "maxPlayersPerPoint",
            "type": "int",
            "default": 1
          }
        ],
        "behaviors": [
          {
            "name": "assign_spawn_point",
            "trigger": "when player requests spawn location",
            "actions": [
              {
                "action": "find next available spawn point based on assignment mode"
              },
              {
                "action": "mark spawn point as occupied"
              },
              {
                "action": "return spawn point position and rotation to requesting player"
              }
            ]
          },
          {
            "name": "release_spawn_point",
            "trigger": "when player leaves spawn area or dies",
            "actions": [
              {
                "action": "mark previously assigned spawn point as available"
              },
              {
                "action": "reset occupation status for that spawn point"
              }
            ]
          },
          {
            "name": "cycle_sequential_assignment",
            "trigger": "when using sequential assignment mode and current spawn point is occupied",
            "actions": [
              {
                "action": "increment current index to next spawn point"
              },
              {
                "action": "wrap around to first spawn point if reached end of list"
              }
            ]
          },
          {
            "name": "find_random_spawn_point",
            "trigger": "when using random assignment mode",
            "actions": [
              {
                "action": "select random spawn point from available points"
              },
              {
                "action": "verify selected point is not at maximum capacity"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SpawnPointManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class SpawnPoint\n    {\n        public Transform transform;\n        public bool isOccupied;\n        public float occupiedRadius = 2f;\n        public string teamTag = \"\";\n        public int priority = 0;\n        public bool isActive = true;\n        \n        public SpawnPoint(Transform t)\n        {\n            transform = t;\n            isOccupied = false;\n        }\n    }\n\n    [Header(\"Spawn Configuration\")]\n    [SerializeField] private Transform[] _spawnTransforms;\n    [SerializeField] private bool _autoFindSpawnPoints = true;\n    [SerializeField] private string _spawnPointTag = \"SpawnPoint\";\n    \n    [Header(\"Assignment Rules\")]\n    [SerializeField] private bool _useTeamBasedSpawning = false;\n    [SerializeField] private bool _avoidOccupiedSpawns = true;\n    [SerializeField] private float _occupiedCheckRadius = 2f;\n    [SerializeField] private LayerMask _obstacleCheckLayers = -1;\n    \n    [Header(\"Spawn Modes\")]\n    [SerializeField] private SpawnMode _spawnMode = SpawnMode.Random;\n    [SerializeField] private bool _usePrioritySystem = false;\n    [SerializeField] private float _respawnCooldown = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnSpawnPointAssigned;\n    public UnityEvent<Transform> OnSpawnPointOccupied;\n    public UnityEvent<Transform> OnSpawnPointFreed;\n\n    public enum SpawnMode\n    {\n        Random,\n        Sequential,\n        Nearest,\n        Furthest,\n        Priority\n    }\n\n    private List<SpawnPoint> _spawnPoints = new List<SpawnPoint>();\n    private Dictionary<string, List<SpawnPoint>> _teamSpawnPoints = new Dictionary<string, List<SpawnPoint>>();\n    private int _sequentialIndex = 0;\n    private Dictionary<Transform, float> _spawnCooldowns = new Dictionary<Transform, float>();\n\n    private void Start()\n    {\n        InitializeSpawnPoints();\n        InvokeRepeating(nameof(UpdateOccupiedStates), 0f, 0.5f);\n        InvokeRepeating(nameof(UpdateCooldowns), 0f, 0.1f);\n    }\n\n    private void InitializeSpawnPoints()\n    {\n        _spawnPoints.Clear();\n        _teamSpawnPoints.Clear();\n\n        if (_autoFindSpawnPoints)\n        {\n            GameObject[] spawnObjects = GameObject.FindGameObjectsWithTag(_spawnPointTag);\n            _spawnTransforms = spawnObjects.Select(go => go.transform).ToArray();\n        }\n\n        foreach (Transform spawnTransform in _spawnTransforms)\n        {\n            if (spawnTransform == null) continue;\n\n            SpawnPoint spawnPoint = new SpawnPoint(spawnTransform);\n            \n            SpawnPointData spawnData = spawnTransform.GetComponent<SpawnPointData>();\n            if (spawnData != null)\n            {\n                spawnPoint.teamTag = spawnData.teamTag;\n                spawnPoint.priority = spawnData.priority;\n                spawnPoint.occupiedRadius = spawnData.occupiedRadius;\n                spawnPoint.isActive = spawnData.isActive;\n            }\n\n            _spawnPoints.Add(spawnPoint);\n\n            if (_useTeamBasedSpawning && !string.IsNullOrEmpty(spawnPoint.teamTag))\n            {\n                if (!_teamSpawnPoints.ContainsKey(spawnPoint.teamTag))\n                {\n                    _teamSpawnPoints[spawnPoint.teamTag] = new List<SpawnPoint>();\n                }\n                _teamSpawnPoints[spawnPoint.teamTag].Add(spawnPoint);\n            }\n        }\n\n        if (_usePrioritySystem)\n        {\n            _spawnPoints = _spawnPoints.OrderByDescending(sp => sp.priority).ToList();\n        }\n    }\n\n    public Transform AssignSpawnPoint(string teamTag = \"\", Vector3 referencePosition = default)\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0)\n        {\n            Debug.LogWarning(\"No available spawn points found!\");\n            return null;\n        }\n\n        SpawnPoint selectedSpawn = SelectSpawnPoint(availableSpawns, referencePosition);\n        \n        if (selectedSpawn != null)\n        {\n            selectedSpawn.isOccupied = true;\n            _spawnCooldowns[selectedSpawn.transform] = Time.time + _respawnCooldown;\n            OnSpawnPointAssigned?.Invoke(selectedSpawn.transform);\n            OnSpawnPointOccupied?.Invoke(selectedSpawn.transform);\n            return selectedSpawn.transform;\n        }\n\n        return null;\n    }\n\n    public Transform GetNearestSpawnPoint(Vector3 position, string teamTag = \"\")\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0) return null;\n\n        SpawnPoint nearest = availableSpawns\n            .OrderBy(sp => Vector3.Distance(sp.transform.position, position))\n            .FirstOrDefault();\n\n        return nearest?.transform;\n    }\n\n    public Transform GetRandomSpawnPoint(string teamTag = \"\")\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0) return null;\n\n        int randomIndex = Random.Range(0, availableSpawns.Count);\n        return availableSpawns[randomIndex].transform;\n    }\n\n    public void FreeSpawnPoint(Transform spawnTransform)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint != null)\n        {\n            spawnPoint.isOccupied = false;\n            OnSpawnPointFreed?.Invoke(spawnTransform);\n        }\n    }\n\n    public void SetSpawnPointActive(Transform spawnTransform, bool active)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint != null)\n        {\n            spawnPoint.isActive = active;\n        }\n    }\n\n    public bool IsSpawnPointAvailable(Transform spawnTransform)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint == null) return false;\n\n        return spawnPoint.isActive && \n               !spawnPoint.isOccupied && \n               !IsOnCooldown(spawnTransform) &&\n               !IsObstructed(spawnTransform);\n    }\n\n    private List<SpawnPoint> GetAvailableSpawnPoints(string teamTag)\n    {\n        List<SpawnPoint> spawnsToCheck = _spawnPoints;\n\n        if (_useTeamBasedSpawning && !string.IsNullOrEmpty(teamTag) && _teamSpawnPoints.ContainsKey(teamTag))\n        {\n            spawnsToCheck = _teamSpawnPoints[teamTag];\n        }\n\n        return spawnsToCheck.Where(sp => \n            sp.isActive && \n            (!_avoidOccupiedSpawns || !sp.isOccupied) &&\n            !IsOnCooldown(sp.transform) &&\n            !IsObstructed(sp.transform)\n        ).ToList();\n    }\n\n    private SpawnPoint SelectSpawnPoint(List<SpawnPoint> availableSpawns, Vector3 referencePosition)\n    {\n        switch (_spawnMode)\n        {\n            case SpawnMode.Random:\n                return availableSpawns[Random.Range(0, availableSpawns.Count)];\n\n            case SpawnMode.Sequential:\n                SpawnPoint sequential = availableSpawns[_sequentialIndex % availableSpawns.Count];\n                _sequentialIndex++;\n                return sequential;\n\n            case SpawnMode.Nearest:\n                if (referencePosition == default) referencePosition = Vector3.zero;\n                return availableSpawns.OrderBy(sp => Vector3.Distance(sp.transform.position, referencePosition)).FirstOrDefault();\n\n            case SpawnMode.Furthest:\n                if (referencePosition == default) referencePosition = Vector3.zero;\n                return availableSpawns.OrderByDescending(sp => Vector3.Distance(sp.transform.position, referencePosition)).FirstOrDefault();\n\n            case SpawnMode.Priority:\n                return availableSpawns.OrderByDescending(sp => sp.priority).FirstOrDefault();\n\n            default:\n                return availableSpawns[0];\n        }\n    }\n\n    private bool IsOnCooldown(Transform spawnTransform)\n    {\n        return _spawnCooldowns.ContainsKey(spawnTransform) && \n               Time.time < _spawnCooldowns[spawnTransform];\n    }\n\n    private bool IsObstructed(Transform spawnTransform)\n    {\n        Collider[] colliders = Physics.OverlapSphere(spawnTransform.position, _occupiedCheckRadius, _obstacleCheckLayers);\n        return colliders.Length > 0;\n    }\n\n    private void UpdateOccupiedStates()\n    {\n        foreach (SpawnPoint spawnPoint in _spawnPoints)\n        {\n            bool wasOccupied = spawnPoint.isOccupied;\n            \n            Collider[] colliders = Physics.OverlapSphere(\n                spawnPoint.transform.position, \n                spawnPoint.occupiedRadius\n            );\n\n            spawnPoint.isOccupied = colliders.Any(col => col.CompareTag(\"Player\"));\n\n            if (wasOccupied && !spawnPoint.isOccupied)\n            {\n                OnSpawnPointFreed?.Invoke(spawnPoint.transform);\n            }\n            else if (!wasOccupied && spawnPoint.isOccupied)\n            {\n                OnSpawnPointOccupied?.Invoke(spawnPoint.transform);\n            }\n        }\n    }\n\n    private void UpdateCooldowns()\n    {\n        List<Transform> expiredCooldowns = new List<Transform>();\n        \n        foreach (var kvp in _spawnCooldowns)\n        {\n            if (Time.time >= kvp.Value)\n            {\n                expiredCooldowns.Add(kvp.Key);\n            }\n        }\n\n        foreach (Transform expired in expiredCooldowns)\n        {\n            _spawnCooldowns.Remove(expired);\n        }\n    }\n\n    private void OnDrawGizmos()\n    {\n        if (_spawnPoints == null) return;\n\n        foreach (SpawnPoint spawnPoint in _spawnPoints)\n        {\n            if (spawnPoint.transform == null) continue;\n\n            Gizmos.color = spawnPoint.isActive ? \n                (spawnPoint.isOccupied ? Color.red : Color.green) : \n                Color.gray;\n\n            Gizmos.DrawWireSphere(spawnPoint.transform.position, spawnPoint.occupiedRadius);\n            Gizmos.DrawWireCube(spawnPoint.transform.position, Vector3.one * 0.5f);\n        }\n    }\n}\n\n[System.Serializable]\npublic class SpawnPointData : MonoBehaviour\n{\n    [Header(\"Spawn Point Settings\")]\n    public string teamTag = \"\";\n    public int priority = 0;\n    public float occupiedRadius = 2f;\n    public bool isActive = true;\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "kill death score tracking",
      "ideal_ir": {
        "class_name": "KillDeathScoreTracker",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "kills",
            "type": "int",
            "default": 0
          },
          {
            "name": "deaths",
            "type": "int",
            "default": 0
          },
          {
            "name": "score",
            "type": "int",
            "default": 0
          },
          {
            "name": "killPoints",
            "type": "int",
            "default": 100
          },
          {
            "name": "deathPenalty",
            "type": "int",
            "default": 50
          }
        ],
        "behaviors": [
          {
            "name": "record_kill",
            "trigger": "when this player kills another player",
            "actions": [
              {
                "action": "increase kill count by one"
              },
              {
                "action": "add kill points to total score"
              },
              {
                "action": "display kill notification on screen"
              }
            ]
          },
          {
            "name": "record_death",
            "trigger": "when this player dies",
            "actions": [
              {
                "action": "increase death count by one"
              },
              {
                "action": "subtract death penalty from total score"
              },
              {
                "action": "display death notification on screen"
              }
            ]
          },
          {
            "name": "calculate_kd_ratio",
            "trigger": "when stats are requested",
            "actions": [
              {
                "action": "calculate kill to death ratio"
              },
              {
                "action": "return ratio value avoiding division by zero"
              }
            ]
          },
          {
            "name": "reset_stats",
            "trigger": "when reset command is received",
            "actions": [
              {
                "action": "set kills back to zero"
              },
              {
                "action": "set deaths back to zero"
              },
              {
                "action": "set score back to zero"
              }
            ]
          },
          {
            "name": "display_current_stats",
            "trigger": "when UI update is needed",
            "actions": [
              {
                "action": "show current kill count on interface"
              },
              {
                "action": "show current death count on interface"
              },
              {
                "action": "show current score on interface"
              },
              {
                "action": "show kill death ratio on interface"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class ScoreTracker : MonoBehaviour\n{\n    [Header(\"Score Settings\")]\n    [SerializeField] private int _killScore = 100;\n    [SerializeField] private int _deathPenalty = 50;\n    [SerializeField] private bool _allowNegativeScore = false;\n    \n    [Header(\"Score Display\")]\n    [SerializeField] private UnityEngine.UI.Text _scoreText;\n    [SerializeField] private UnityEngine.UI.Text _killsText;\n    [SerializeField] private UnityEngine.UI.Text _deathsText;\n    [SerializeField] private string _scorePrefix = \"Score: \";\n    [SerializeField] private string _killsPrefix = \"Kills: \";\n    [SerializeField] private string _deathsPrefix = \"Deaths: \";\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnScoreChanged;\n    public UnityEvent<int> OnKillCountChanged;\n    public UnityEvent<int> OnDeathCountChanged;\n    public UnityEvent<PlayerStats> OnStatsUpdated;\n    \n    [Header(\"Persistence\")]\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _scoreKey = \"PlayerScore\";\n    [SerializeField] private string _killsKey = \"PlayerKills\";\n    [SerializeField] private string _deathsKey = \"PlayerDeaths\";\n    \n    private int _currentScore;\n    private int _totalKills;\n    private int _totalDeaths;\n    private Dictionary<string, int> _killsByType = new Dictionary<string, int>();\n    \n    public int CurrentScore => _currentScore;\n    public int TotalKills => _totalKills;\n    public int TotalDeaths => _totalDeaths;\n    public float KillDeathRatio => _totalDeaths > 0 ? (float)_totalKills / _totalDeaths : _totalKills;\n    \n    [System.Serializable]\n    public class PlayerStats\n    {\n        public int score;\n        public int kills;\n        public int deaths;\n        public float killDeathRatio;\n        \n        public PlayerStats(int score, int kills, int deaths, float kdr)\n        {\n            this.score = score;\n            this.kills = kills;\n            this.deaths = deaths;\n            this.killDeathRatio = kdr;\n        }\n    }\n    \n    private void Start()\n    {\n        LoadStats();\n        UpdateUI();\n    }\n    \n    private void OnEnable()\n    {\n        FindAndSubscribeToHealthComponents();\n    }\n    \n    private void OnDisable()\n    {\n        UnsubscribeFromHealthComponents();\n    }\n    \n    private void FindAndSubscribeToHealthComponents()\n    {\n        HealthComponent[] healthComponents = FindObjectsOfType<HealthComponent>();\n        foreach (var health in healthComponents)\n        {\n            health.OnDeath.AddListener(OnEntityDeath);\n        }\n    }\n    \n    private void UnsubscribeFromHealthComponents()\n    {\n        HealthComponent[] healthComponents = FindObjectsOfType<HealthComponent>();\n        foreach (var health in healthComponents)\n        {\n            if (health != null)\n                health.OnDeath.RemoveListener(OnEntityDeath);\n        }\n    }\n    \n    public void RegisterKill(string killedEntityTag = \"Enemy\", string killerTag = \"Player\")\n    {\n        if (killerTag == \"Player\")\n        {\n            _totalKills++;\n            _currentScore += _killScore;\n            \n            if (!_killsByType.ContainsKey(killedEntityTag))\n                _killsByType[killedEntityTag] = 0;\n            _killsByType[killedEntityTag]++;\n            \n            OnKillCountChanged?.Invoke(_totalKills);\n            OnScoreChanged?.Invoke(_currentScore);\n            \n            UpdateUI();\n            SaveStats();\n            \n            OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n        }\n    }\n    \n    public void RegisterDeath(string deadEntityTag = \"Player\")\n    {\n        if (deadEntityTag == \"Player\")\n        {\n            _totalDeaths++;\n            _currentScore -= _deathPenalty;\n            \n            if (!_allowNegativeScore && _currentScore < 0)\n                _currentScore = 0;\n            \n            OnDeathCountChanged?.Invoke(_totalDeaths);\n            OnScoreChanged?.Invoke(_currentScore);\n            \n            UpdateUI();\n            SaveStats();\n            \n            OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n        }\n    }\n    \n    private void OnEntityDeath(GameObject deadEntity, GameObject killer)\n    {\n        if (killer != null && killer.CompareTag(\"Player\") && !deadEntity.CompareTag(\"Player\"))\n        {\n            RegisterKill(deadEntity.tag, killer.tag);\n        }\n        else if (deadEntity.CompareTag(\"Player\"))\n        {\n            RegisterDeath(deadEntity.tag);\n        }\n    }\n    \n    public void AddScore(int points)\n    {\n        _currentScore += points;\n        if (!_allowNegativeScore && _currentScore < 0)\n            _currentScore = 0;\n        \n        OnScoreChanged?.Invoke(_currentScore);\n        UpdateUI();\n        SaveStats();\n    }\n    \n    public void ResetStats()\n    {\n        _currentScore = 0;\n        _totalKills = 0;\n        _totalDeaths = 0;\n        _killsByType.Clear();\n        \n        OnScoreChanged?.Invoke(_currentScore);\n        OnKillCountChanged?.Invoke(_totalKills);\n        OnDeathCountChanged?.Invoke(_totalDeaths);\n        \n        UpdateUI();\n        SaveStats();\n        \n        OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n    }\n    \n    public int GetKillsByType(string entityType)\n    {\n        return _killsByType.ContainsKey(entityType) ? _killsByType[entityType] : 0;\n    }\n    \n    private void UpdateUI()\n    {\n        if (_scoreText != null)\n            _scoreText.text = _scorePrefix + _currentScore.ToString();\n        \n        if (_killsText != null)\n            _killsText.text = _killsPrefix + _totalKills.ToString();\n        \n        if (_deathsText != null)\n            _deathsText.text = _deathsPrefix + _totalDeaths.ToString();\n    }\n    \n    private void SaveStats()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        PlayerPrefs.SetInt(_scoreKey, _currentScore);\n        PlayerPrefs.SetInt(_killsKey, _totalKills);\n        PlayerPrefs.SetInt(_deathsKey, _totalDeaths);\n        \n        foreach (var kvp in _killsByType)\n        {\n            PlayerPrefs.SetInt(\"Kills_\" + kvp.Key, kvp.Value);\n        }\n        \n        PlayerPrefs.Save();\n    }\n    \n    private void LoadStats()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        _currentScore = PlayerPrefs.GetInt(_scoreKey, 0);\n        _totalKills = PlayerPrefs.GetInt(_killsKey, 0);\n        _totalDeaths = PlayerPrefs.GetInt(_deathsKey, 0);\n        \n        string[] enemyTypes = { \"Enemy\", \"Boss\", \"Minion\", \"Elite\" };\n        foreach (string type in enemyTypes)\n        {\n            int kills = PlayerPrefs.GetInt(\"Kills_\" + type, 0);\n            if (kills > 0)\n                _killsByType[type] = kills;\n        }\n    }\n}\n\n[System.Serializable]\npublic class HealthComponent : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private int _currentHealth;\n    [SerializeField] private bool _destroyOnDeath = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnHealthChanged;\n    public UnityEvent<GameObject, GameObject> OnDeath;\n    public UnityEvent<int> OnDamageTaken;\n    \n    public int MaxHealth => _maxHealth;\n    public int CurrentHealth => _currentHealth;\n    public bool IsDead => _currentHealth <= 0;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public void TakeDamage(int damage, GameObject attacker = null)\n    {\n        if (IsDead) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        OnDamageTaken?.Invoke(damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0)\n        {\n            Die(attacker);\n        }\n    }\n    \n    public void Heal(int amount)\n    {\n        if (IsDead) return;\n        \n        _currentHealth += amount;\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Die(GameObject killer)\n    {\n        OnDeath?.Invoke(gameObject, killer);\n        \n        if (_destroyOnDeath)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Damage\"))\n        {\n            DamageDealer dealer = other.GetComponent<DamageDealer>();\n            if (dealer != null)\n            {\n                TakeDamage(dealer.Damage, dealer.Owner);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class DamageDealer : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 10;\n    [SerializeField] private GameObject _owner;\n    [SerializeField] private bool _destroyOnHit = true;\n    \n    public int Damage => _damage;\n    public GameObject Owner => _owner;\n    \n    public void SetOwner(GameObject owner)\n    {\n        _owner = owner;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HealthComponent health = other.GetComponent<HealthComponent>();\n        if (health != null && other.gameObject != _owner)\n        {\n            health.TakeDamage(_damage, _owner);\n            \n            if (_destroyOnHit)\n            {\n                Destroy(gameObject);\n            }\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "respawn countdown",
      "ideal_ir": {
        "class_name": "RespawnCountdown",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "countdownTime",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "currentTime",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "isCountingDown",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "start_countdown",
            "trigger": "when respawn countdown is initiated",
            "actions": [
              {
                "action": "set countdown timer to full countdown time"
              },
              {
                "action": "enable countdown state"
              },
              {
                "action": "display countdown UI"
              }
            ]
          },
          {
            "name": "update_countdown",
            "trigger": "every frame while countdown is active",
            "actions": [
              {
                "action": "decrease countdown timer by elapsed time"
              },
              {
                "action": "update countdown display with remaining time"
              },
              {
                "action": "play countdown sound effect"
              }
            ]
          },
          {
            "name": "complete_countdown",
            "trigger": "when countdown timer reaches zero",
            "actions": [
              {
                "action": "disable countdown state"
              },
              {
                "action": "hide countdown UI"
              },
              {
                "action": "trigger respawn event"
              },
              {
                "action": "play respawn sound effect"
              }
            ]
          },
          {
            "name": "cancel_countdown",
            "trigger": "when countdown is cancelled",
            "actions": [
              {
                "action": "stop countdown timer"
              },
              {
                "action": "disable countdown state"
              },
              {
                "action": "hide countdown UI"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RespawnCountdown : MonoBehaviour\n{\n    [Header(\"Countdown Settings\")]\n    [SerializeField] private float _countdownDuration = 5f;\n    [SerializeField] private bool _startOnAwake = false;\n    [SerializeField] private bool _hideUIWhenNotActive = true;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _countdownText;\n    [SerializeField] private Image _countdownFillImage;\n    [SerializeField] private GameObject _countdownPanel;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private bool _enablePulseEffect = true;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1.2f);\n    [SerializeField] private Color _startColor = Color.red;\n    [SerializeField] private Color _endColor = Color.green;\n    [SerializeField] private bool _enableColorTransition = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _tickSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private bool _playTickOnEachSecond = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCountdownStart;\n    public UnityEvent OnCountdownTick;\n    public UnityEvent OnCountdownComplete;\n    public UnityEvent OnCountdownCancelled;\n    \n    private float _currentTime;\n    private bool _isCountingDown = false;\n    private Coroutine _countdownCoroutine;\n    private Vector3 _originalScale;\n    private int _lastSecond = -1;\n    \n    private void Awake()\n    {\n        if (_countdownText != null)\n            _originalScale = _countdownText.transform.localScale;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetUIVisibility(false);\n    }\n    \n    private void Start()\n    {\n        if (_startOnAwake)\n            StartCountdown();\n    }\n    \n    public void StartCountdown()\n    {\n        StartCountdown(_countdownDuration);\n    }\n    \n    public void StartCountdown(float duration)\n    {\n        if (_isCountingDown)\n            StopCountdown();\n            \n        _countdownDuration = duration;\n        _currentTime = _countdownDuration;\n        _isCountingDown = true;\n        _lastSecond = -1;\n        \n        SetUIVisibility(true);\n        OnCountdownStart?.Invoke();\n        \n        _countdownCoroutine = StartCoroutine(CountdownRoutine());\n    }\n    \n    public void StopCountdown()\n    {\n        if (_countdownCoroutine != null)\n        {\n            StopCoroutine(_countdownCoroutine);\n            _countdownCoroutine = null;\n        }\n        \n        _isCountingDown = false;\n        SetUIVisibility(false);\n        OnCountdownCancelled?.Invoke();\n    }\n    \n    public void PauseCountdown()\n    {\n        if (_countdownCoroutine != null)\n        {\n            StopCoroutine(_countdownCoroutine);\n            _countdownCoroutine = null;\n        }\n    }\n    \n    public void ResumeCountdown()\n    {\n        if (_isCountingDown && _countdownCoroutine == null)\n        {\n            _countdownCoroutine = StartCoroutine(CountdownRoutine());\n        }\n    }\n    \n    private IEnumerator CountdownRoutine()\n    {\n        while (_currentTime > 0f)\n        {\n            UpdateUI();\n            CheckForSecondTick();\n            \n            _currentTime -= Time.deltaTime;\n            yield return null;\n        }\n        \n        _currentTime = 0f;\n        _isCountingDown = false;\n        UpdateUI();\n        \n        PlaySound(_completeSound);\n        OnCountdownComplete?.Invoke();\n        \n        if (_hideUIWhenNotActive)\n        {\n            yield return new WaitForSeconds(0.5f);\n            SetUIVisibility(false);\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        float normalizedTime = _currentTime / _countdownDuration;\n        \n        if (_countdownText != null)\n        {\n            int displaySeconds = Mathf.CeilToInt(_currentTime);\n            _countdownText.text = displaySeconds.ToString();\n            \n            if (_enableColorTransition)\n            {\n                _countdownText.color = Color.Lerp(_endColor, _startColor, normalizedTime);\n            }\n            \n            if (_enablePulseEffect)\n            {\n                float pulseValue = _pulseCurve.Evaluate(Time.time % 1f);\n                _countdownText.transform.localScale = _originalScale * pulseValue;\n            }\n        }\n        \n        if (_countdownFillImage != null)\n        {\n            _countdownFillImage.fillAmount = normalizedTime;\n            \n            if (_enableColorTransition)\n            {\n                _countdownFillImage.color = Color.Lerp(_endColor, _startColor, normalizedTime);\n            }\n        }\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(0.5f, 1f, normalizedTime);\n        }\n    }\n    \n    private void CheckForSecondTick()\n    {\n        int currentSecond = Mathf.CeilToInt(_currentTime);\n        \n        if (currentSecond != _lastSecond && currentSecond > 0)\n        {\n            _lastSecond = currentSecond;\n            OnCountdownTick?.Invoke();\n            \n            if (_playTickOnEachSecond)\n                PlaySound(_tickSound);\n        }\n    }\n    \n    private void SetUIVisibility(bool visible)\n    {\n        if (_countdownPanel != null)\n            _countdownPanel.SetActive(visible);\n        else if (_countdownText != null)\n            _countdownText.gameObject.SetActive(visible);\n            \n        if (_canvasGroup != null)\n            _canvasGroup.alpha = visible ? 1f : 0f;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetRemainingTime()\n    {\n        return _currentTime;\n    }\n    \n    public float GetNormalizedTime()\n    {\n        return _countdownDuration > 0 ? _currentTime / _countdownDuration : 0f;\n    }\n    \n    public bool IsCountingDown()\n    {\n        return _isCountingDown;\n    }\n    \n    public void AddTime(float additionalTime)\n    {\n        _currentTime += additionalTime;\n        _currentTime = Mathf.Max(0f, _currentTime);\n    }\n    \n    public void SetRemainingTime(float time)\n    {\n        _currentTime = Mathf.Max(0f, time);\n    }\n    \n    private void OnValidate()\n    {\n        _countdownDuration = Mathf.Max(0.1f, _countdownDuration);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "spectator camera",
      "ideal_ir": {
        "class_name": "SpectatorCamera",
        "components": [
          "Camera"
        ],
        "fields": [
          {
            "name": "moveSpeed",
            "type": "float",
            "default": 10
          },
          {
            "name": "lookSensitivity",
            "type": "float",
            "default": 2
          },
          {
            "name": "fastMoveMultiplier",
            "type": "float",
            "default": 3
          }
        ],
        "behaviors": [
          {
            "name": "free_look_movement",
            "trigger": "when mouse moves",
            "actions": [
              {
                "action": "rotate camera horizontally based on mouse horizontal movement"
              },
              {
                "action": "rotate camera vertically based on mouse vertical movement"
              },
              {
                "action": "clamp vertical rotation to prevent over-rotation"
              }
            ]
          },
          {
            "name": "forward_movement",
            "trigger": "when W key is held down",
            "actions": [
              {
                "action": "move camera forward in the direction it is facing"
              }
            ]
          },
          {
            "name": "backward_movement",
            "trigger": "when S key is held down",
            "actions": [
              {
                "action": "move camera backward opposite to the direction it is facing"
              }
            ]
          },
          {
            "name": "left_strafe",
            "trigger": "when A key is held down",
            "actions": [
              {
                "action": "move camera left perpendicular to facing direction"
              }
            ]
          },
          {
            "name": "right_strafe",
            "trigger": "when D key is held down",
            "actions": [
              {
                "action": "move camera right perpendicular to facing direction"
              }
            ]
          },
          {
            "name": "upward_movement",
            "trigger": "when Q key is held down",
            "actions": [
              {
                "action": "move camera upward in world space"
              }
            ]
          },
          {
            "name": "downward_movement",
            "trigger": "when E key is held down",
            "actions": [
              {
                "action": "move camera downward in world space"
              }
            ]
          },
          {
            "name": "fast_movement",
            "trigger": "when shift key is held while moving",
            "actions": [
              {
                "action": "multiply movement speed by fast move multiplier"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SpectatorCamera : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 10f;\n    [SerializeField] private float _fastMoveSpeed = 20f;\n    [SerializeField] private float _smoothTime = 0.1f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _mouseSensitivity = 2f;\n    [SerializeField] private float _maxLookAngle = 80f;\n    \n    [Header(\"Zoom Settings\")]\n    [SerializeField] private float _zoomSpeed = 2f;\n    [SerializeField] private float _minFOV = 10f;\n    [SerializeField] private float _maxFOV = 90f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _fastMoveKey = KeyCode.LeftShift;\n    [SerializeField] private KeyCode _upKey = KeyCode.E;\n    [SerializeField] private KeyCode _downKey = KeyCode.Q;\n    [SerializeField] private bool _invertY = false;\n    \n    private Camera _camera;\n    private Vector3 _velocity;\n    private float _rotationX = 0f;\n    private float _rotationY = 0f;\n    private bool _isMouseLocked = true;\n    \n    private void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n        {\n            _camera = Camera.main;\n        }\n        \n        Vector3 eulerAngles = transform.eulerAngles;\n        _rotationX = eulerAngles.x;\n        _rotationY = eulerAngles.y;\n        \n        LockCursor();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleMouseLook();\n        HandleMovement();\n        HandleZoom();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            ToggleCursorLock();\n        }\n    }\n    \n    private void HandleMouseLook()\n    {\n        if (!_isMouseLocked) return;\n        \n        float mouseX = Input.GetAxis(\"Mouse X\") * _mouseSensitivity;\n        float mouseY = Input.GetAxis(\"Mouse Y\") * _mouseSensitivity;\n        \n        if (_invertY)\n            mouseY = -mouseY;\n        \n        _rotationY += mouseX;\n        _rotationX -= mouseY;\n        _rotationX = Mathf.Clamp(_rotationX, -_maxLookAngle, _maxLookAngle);\n        \n        transform.rotation = Quaternion.Euler(_rotationX, _rotationY, 0f);\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 inputDirection = Vector3.zero;\n        \n        if (Input.GetKey(KeyCode.W)) inputDirection += Vector3.forward;\n        if (Input.GetKey(KeyCode.S)) inputDirection += Vector3.back;\n        if (Input.GetKey(KeyCode.A)) inputDirection += Vector3.left;\n        if (Input.GetKey(KeyCode.D)) inputDirection += Vector3.right;\n        if (Input.GetKey(_upKey)) inputDirection += Vector3.up;\n        if (Input.GetKey(_downKey)) inputDirection += Vector3.down;\n        \n        inputDirection = transform.TransformDirection(inputDirection);\n        inputDirection.Normalize();\n        \n        float currentSpeed = Input.GetKey(_fastMoveKey) ? _fastMoveSpeed : _moveSpeed;\n        Vector3 targetVelocity = inputDirection * currentSpeed;\n        \n        _velocity = Vector3.Lerp(_velocity, targetVelocity, Time.deltaTime / _smoothTime);\n        transform.position += _velocity * Time.deltaTime;\n    }\n    \n    private void HandleZoom()\n    {\n        if (_camera == null) return;\n        \n        float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scroll) > 0.01f)\n        {\n            float newFOV = _camera.fieldOfView - scroll * _zoomSpeed * 10f;\n            _camera.fieldOfView = Mathf.Clamp(newFOV, _minFOV, _maxFOV);\n        }\n    }\n    \n    private void LockCursor()\n    {\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n        _isMouseLocked = true;\n    }\n    \n    private void UnlockCursor()\n    {\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n        _isMouseLocked = false;\n    }\n    \n    private void ToggleCursorLock()\n    {\n        if (_isMouseLocked)\n        {\n            UnlockCursor();\n        }\n        else\n        {\n            LockCursor();\n        }\n    }\n    \n    public void SetPosition(Vector3 position)\n    {\n        transform.position = position;\n        _velocity = Vector3.zero;\n    }\n    \n    public void SetRotation(Vector3 eulerAngles)\n    {\n        transform.eulerAngles = eulerAngles;\n        _rotationX = eulerAngles.x;\n        _rotationY = eulerAngles.y;\n    }\n    \n    public void SetMoveSpeed(float speed)\n    {\n        _moveSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetMouseSensitivity(float sensitivity)\n    {\n        _mouseSensitivity = Mathf.Max(0.1f, sensitivity);\n    }\n    \n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (hasFocus && _isMouseLocked)\n        {\n            LockCursor();\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "vote kick system",
      "ideal_ir": {
        "class_name": "VoteKickSystem",
        "components": [
          "NetworkBehaviour"
        ],
        "fields": [
          {
            "name": "votesRequired",
            "type": "int",
            "default": 3
          },
          {
            "name": "voteTimeLimit",
            "type": "float",
            "default": 30
          },
          {
            "name": "cooldownTime",
            "type": "float",
            "default": 60
          },
          {
            "name": "currentVotes",
            "type": "int",
            "default": 0
          },
          {
            "name": "targetPlayer",
            "type": "string",
            "default": ""
          },
          {
            "name": "voteActive",
            "type": "bool",
            "default": false
          },
          {
            "name": "votedPlayers",
            "type": "List<string>",
            "default": null
          },
          {
            "name": "voteStartTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "lastVoteTime",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "initiate_vote_kick",
            "trigger": "when player requests to kick another player and no vote is currently active and cooldown period has passed",
            "actions": [
              {
                "action": "set target player to the player being voted against"
              },
              {
                "action": "mark vote as active"
              },
              {
                "action": "reset current vote count to zero"
              },
              {
                "action": "clear the list of players who have voted"
              },
              {
                "action": "record the current time as vote start time"
              },
              {
                "action": "notify all players that a vote kick has been initiated"
              },
              {
                "action": "display vote kick UI to all players"
              }
            ]
          },
          {
            "name": "cast_vote",
            "trigger": "when player votes yes on an active vote kick and player has not already voted",
            "actions": [
              {
                "action": "add player to the list of players who have voted"
              },
              {
                "action": "increase current vote count by one"
              },
              {
                "action": "update vote display for all players"
              },
              {
                "action": "notify all players of the new vote count"
              }
            ]
          },
          {
            "name": "execute_kick",
            "trigger": "when current vote count reaches or exceeds required votes",
            "actions": [
              {
                "action": "kick the target player from the game"
              },
              {
                "action": "notify all players that the vote kick was successful"
              },
              {
                "action": "mark vote as inactive"
              },
              {
                "action": "record current time as last vote time for cooldown"
              },
              {
                "action": "hide vote kick UI"
              },
              {
                "action": "clear target player and vote data"
              }
            ]
          },
          {
            "name": "timeout_vote",
            "trigger": "when vote time limit has been exceeded and vote is still active",
            "actions": [
              {
                "action": "notify all players that the vote kick has failed due to timeout"
              },
              {
                "action": "mark vote as inactive"
              },
              {
                "action": "record current time as last vote time for cooldown"
              },
              {
                "action": "hide vote kick UI"
              },
              {
                "action": "clear target player and vote data"
              }
            ]
          },
          {
            "name": "cancel_vote_target_left",
            "trigger": "when target player leaves the game during an active vote",
            "actions": [
              {
                "action": "notify all players that the vote has been cancelled because target left"
              },
              {
                "action": "mark vote as inactive"
              },
              {
                "action": "hide vote kick UI"
              },
              {
                "action": "clear target player and vote data"
              }
            ]
          },
          {
            "name": "update_vote_display",
            "trigger": "when vote status changes or time remaining changes",
            "actions": [
              {
                "action": "update UI to show current vote count and required votes"
              },
              {
                "action": "update UI to show time remaining for the vote"
              },
              {
                "action": "update UI to show which player is being voted against"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class VoteKickSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class Player\n    {\n        public string playerName;\n        public int playerId;\n        public bool isConnected;\n        public bool hasVoted;\n        public bool votedYes;\n        \n        public Player(string name, int id)\n        {\n            playerName = name;\n            playerId = id;\n            isConnected = true;\n            hasVoted = false;\n            votedYes = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class VoteKickEvent : UnityEvent<string, bool> { }\n    \n    [Header(\"Vote Settings\")]\n    [SerializeField] private float _voteDuration = 30f;\n    [SerializeField] private float _votePassThreshold = 0.6f;\n    [SerializeField] private int _minimumPlayersRequired = 3;\n    [SerializeField] private float _cooldownBetweenVotes = 60f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _voteKickPanel;\n    [SerializeField] private Text _voteTargetText;\n    [SerializeField] private Text _voteTimerText;\n    [SerializeField] private Text _voteCountText;\n    [SerializeField] private Button _yesButton;\n    [SerializeField] private Button _noButton;\n    [SerializeField] private Button _initiateVoteButton;\n    [SerializeField] private Dropdown _playerDropdown;\n    [SerializeField] private Text _statusText;\n    \n    [Header(\"Events\")]\n    public VoteKickEvent OnVoteKickComplete;\n    public UnityEvent OnVoteKickStarted;\n    public UnityEvent OnVoteKickCancelled;\n    \n    private List<Player> _players = new List<Player>();\n    private bool _voteInProgress = false;\n    private float _voteTimer = 0f;\n    private string _targetPlayerName = \"\";\n    private int _targetPlayerId = -1;\n    private int _yesVotes = 0;\n    private int _noVotes = 0;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private int _localPlayerId = 0;\n    \n    private void Start()\n    {\n        InitializeUI();\n        InitializePlayers();\n        UpdatePlayerDropdown();\n    }\n    \n    private void Update()\n    {\n        HandleVoteTimer();\n        HandleCooldownTimer();\n        UpdateUI();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(false);\n            \n        if (_yesButton != null)\n            _yesButton.onClick.AddListener(() => CastVote(true));\n            \n        if (_noButton != null)\n            _noButton.onClick.AddListener(() => CastVote(false));\n            \n        if (_initiateVoteButton != null)\n            _initiateVoteButton.onClick.AddListener(InitiateVoteKick);\n    }\n    \n    private void InitializePlayers()\n    {\n        _players.Clear();\n        _players.Add(new Player(\"Player1\", 0));\n        _players.Add(new Player(\"Player2\", 1));\n        _players.Add(new Player(\"Player3\", 2));\n        _players.Add(new Player(\"Player4\", 3));\n        \n        _localPlayerId = 0;\n    }\n    \n    private void UpdatePlayerDropdown()\n    {\n        if (_playerDropdown == null) return;\n        \n        _playerDropdown.ClearOptions();\n        List<string> playerNames = new List<string>();\n        \n        foreach (Player player in _players)\n        {\n            if (player.isConnected && player.playerId != _localPlayerId)\n            {\n                playerNames.Add(player.playerName);\n            }\n        }\n        \n        _playerDropdown.AddOptions(playerNames);\n    }\n    \n    public void InitiateVoteKick()\n    {\n        if (_voteInProgress)\n        {\n            UpdateStatusText(\"Vote already in progress!\");\n            return;\n        }\n        \n        if (_isOnCooldown)\n        {\n            UpdateStatusText($\"Vote cooldown active: {_cooldownTimer:F0}s remaining\");\n            return;\n        }\n        \n        if (GetConnectedPlayerCount() < _minimumPlayersRequired)\n        {\n            UpdateStatusText($\"Need at least {_minimumPlayersRequired} players to vote\");\n            return;\n        }\n        \n        if (_playerDropdown != null && _playerDropdown.options.Count > 0)\n        {\n            string selectedPlayerName = _playerDropdown.options[_playerDropdown.value].text;\n            Player targetPlayer = GetPlayerByName(selectedPlayerName);\n            \n            if (targetPlayer != null)\n            {\n                StartVoteKick(targetPlayer.playerName, targetPlayer.playerId);\n            }\n        }\n    }\n    \n    public void StartVoteKick(string targetName, int targetId)\n    {\n        if (_voteInProgress) return;\n        \n        _voteInProgress = true;\n        _targetPlayerName = targetName;\n        _targetPlayerId = targetId;\n        _voteTimer = _voteDuration;\n        _yesVotes = 0;\n        _noVotes = 0;\n        \n        ResetPlayerVotes();\n        \n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(true);\n            \n        UpdateStatusText($\"Vote to kick {targetName} started!\");\n        OnVoteKickStarted?.Invoke();\n    }\n    \n    public void CastVote(bool voteYes)\n    {\n        if (!_voteInProgress) return;\n        \n        Player localPlayer = GetPlayerById(_localPlayerId);\n        if (localPlayer == null || localPlayer.hasVoted) return;\n        \n        localPlayer.hasVoted = true;\n        localPlayer.votedYes = voteYes;\n        \n        if (voteYes)\n            _yesVotes++;\n        else\n            _noVotes++;\n            \n        UpdateStatusText($\"Vote cast: {(voteYes ? \"Yes\" : \"No\")}\");\n        \n        if (_yesButton != null)\n            _yesButton.interactable = false;\n        if (_noButton != null)\n            _noButton.interactable = false;\n            \n        CheckVoteCompletion();\n    }\n    \n    private void HandleVoteTimer()\n    {\n        if (!_voteInProgress) return;\n        \n        _voteTimer -= Time.deltaTime;\n        \n        if (_voteTimer <= 0f)\n        {\n            CompleteVote();\n        }\n    }\n    \n    private void HandleCooldownTimer()\n    {\n        if (!_isOnCooldown) return;\n        \n        _cooldownTimer -= Time.deltaTime;\n        \n        if (_cooldownTimer <= 0f)\n        {\n            _isOnCooldown = false;\n            UpdateStatusText(\"Vote cooldown expired. You can initiate votes again.\");\n        }\n    }\n    \n    private void CheckVoteCompletion()\n    {\n        int connectedPlayers = GetConnectedPlayerCount();\n        int totalVotes = _yesVotes + _noVotes;\n        \n        if (totalVotes >= connectedPlayers - 1)\n        {\n            CompleteVote();\n        }\n        else\n        {\n            float requiredYesVotes = (connectedPlayers - 1) * _votePassThreshold;\n            if (_yesVotes >= requiredYesVotes)\n            {\n                CompleteVote();\n            }\n        }\n    }\n    \n    private void CompleteVote()\n    {\n        if (!_voteInProgress) return;\n        \n        int connectedPlayers = GetConnectedPlayerCount();\n        float yesPercentage = (float)_yesVotes / (connectedPlayers - 1);\n        bool votesPassed = yesPercentage >= _votePassThreshold;\n        \n        if (votesPassed)\n        {\n            UpdateStatusText($\"{_targetPlayerName} has been kicked!\");\n            KickPlayer(_targetPlayerId);\n        }\n        else\n        {\n            UpdateStatusText($\"Vote to kick {_targetPlayerName} failed.\");\n        }\n        \n        OnVoteKickComplete?.Invoke(_targetPlayerName, votesPassed);\n        EndVote();\n        StartCooldown();\n    }\n    \n    private void KickPlayer(int playerId)\n    {\n        Player playerToKick = GetPlayerById(playerId);\n        if (playerToKick != null)\n        {\n            playerToKick.isConnected = false;\n            UpdatePlayerDropdown();\n        }\n    }\n    \n    private void EndVote()\n    {\n        _voteInProgress = false;\n        _targetPlayerName = \"\";\n        _targetPlayerId = -1;\n        _yesVotes = 0;\n        _noVotes = 0;\n        \n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(false);\n            \n        if (_yesButton != null)\n            _yesButton.interactable = true;\n        if (_noButton != null)\n            _noButton.interactable = true;\n            \n        ResetPlayerVotes();\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownBetweenVotes;\n    }\n    \n    private void ResetPlayerVotes()\n    {\n        foreach (Player player in _players)\n        {\n            player.hasVoted = false;\n            player.votedYes = false;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_voteTargetText != null && _voteInProgress)\n            _voteTargetText.text = $\"Kick {_targetPlayerName}?\";\n            \n        if (_voteTimerText != null && _voteInProgress)\n            _voteTimerText.text = $\"Time: {_voteTimer:F0}s\";\n            \n        if (_voteCountText != null && _voteInProgress)\n        {\n            int totalEligibleVoters = GetConnectedPlayerCount() - 1;\n            _voteCountText.text = $\"Yes: {_yesVotes} | No: {_noVotes} | Total: {totalEligibleVoters}\";\n        }\n        \n        if (_initiateVoteButton != null)\n        {\n            _initiateVoteButton.interactable = !_voteInProgress && !_isOnCooldown && \n                                             GetConnectedPlayerCount() >= _minimumPlayersRequired;\n        }\n    }\n    \n    private void UpdateStatusText(string message)\n    {\n        if (_statusText != null)\n            _statusText.text = message;\n            \n        StartCoroutine(ClearStatusAfterDelay(3f));\n    }\n    \n    private IEnumerator ClearStatusAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        if (_statusText != null && !_voteInProgress)\n            _statusText.text = \"\";\n    }\n    \n    private Player GetPlayerById(int id)\n    {\n        return _players.Find(p => p.playerId == id);\n    }\n    \n    private Player GetPlayerByName(string name)\n    {\n        return _players.Find(p => p.playerName == name);\n    }\n    \n    private int GetConnectedPlayerCount()\n    {\n        int count = 0;\n        foreach (Player player in _players)\n        {\n            if (player.isConnected)\n                count++;\n        }\n        return count;\n    }\n    \n    public void AddPlayer(string playerName, int playerId)\n    {\n        if (GetPlayerById(playerId) == null)\n        {\n            _players.Add(new Player(playerName, playerId));\n            UpdatePlayerDropdown();\n        }\n    }\n    \n    public void RemovePlayer(int playerId)\n    {\n        Player player = GetPlayerById(playerId);\n        if (player != null)\n        {\n            player.isConnected = false;\n            UpdatePlayerDropdown();\n            \n            if (_voteInProgress && playerId == _targetPlayerId)\n            {\n                UpdateStatusText(\"Target player disconnected. Vote cancelled.\");\n                OnVoteKickCancelled?.Invoke();\n                EndVote();\n            }\n        }\n    }\n    \n    public void CancelCurrentVote()\n    {\n        if (_voteInProgress)\n        {\n            UpdateStatusText(\"Vote cancelled by administrator.\");\n            OnVoteKickCancelled?.Invoke();\n            EndVote();\n        }\n    }\n    \n    public bool IsVoteInProgress()\n    {\n        return _voteInProgress;\n    }\n    \n    public float GetRemainingVoteTime()\n    {\n        return _voteInProgress ? _voteTimer : 0f;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetRemainingCooldownTime()\n    {\n        return _isOnCooldown ? _cooldownTimer : 0f;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "friend list display",
      "ideal_ir": {
        "class_name": "FriendListDisplay",
        "components": [
          "Canvas",
          "VerticalLayoutGroup"
        ],
        "fields": [
          {
            "name": "friendItemPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "scrollView",
            "type": "ScrollRect",
            "default": null
          },
          {
            "name": "emptyListMessage",
            "type": "Text",
            "default": null
          },
          {
            "name": "refreshButton",
            "type": "Button",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "initialize_friend_list",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "load friend data from storage"
              },
              {
                "action": "create friend item UI elements for each friend"
              },
              {
                "action": "arrange friend items in vertical layout"
              }
            ]
          },
          {
            "name": "show_empty_message",
            "trigger": "when friend list is empty",
            "actions": [
              {
                "action": "display empty friends list message"
              },
              {
                "action": "hide scroll view container"
              }
            ]
          },
          {
            "name": "refresh_friend_list",
            "trigger": "when refresh button is clicked",
            "actions": [
              {
                "action": "clear existing friend item displays"
              },
              {
                "action": "reload friend data from server"
              },
              {
                "action": "recreate friend item UI elements"
              },
              {
                "action": "update scroll view content"
              }
            ]
          },
          {
            "name": "handle_friend_item_click",
            "trigger": "when any friend item is clicked",
            "actions": [
              {
                "action": "open friend profile view"
              },
              {
                "action": "pass selected friend data to profile"
              }
            ]
          },
          {
            "name": "update_online_status",
            "trigger": "when friend online status changes",
            "actions": [
              {
                "action": "find corresponding friend item display"
              },
              {
                "action": "update online indicator visual state"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class FriendListDisplay : MonoBehaviour\n{\n    [System.Serializable]\n    public class Friend\n    {\n        public string username;\n        public string displayName;\n        public bool isOnline;\n        public DateTime lastSeen;\n        public Sprite avatar;\n        public int level;\n        \n        public Friend(string username, string displayName)\n        {\n            this.username = username;\n            this.displayName = displayName;\n            this.isOnline = false;\n            this.lastSeen = DateTime.Now;\n            this.level = 1;\n        }\n    }\n    \n    [System.Serializable]\n    public class FriendSelectedEvent : UnityEvent<Friend> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _friendListParent;\n    [SerializeField] private GameObject _friendItemPrefab;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private Text _friendCountText;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private InputField _searchField;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private bool _showOnlineFirst = true;\n    [SerializeField] private bool _showLastSeen = true;\n    [SerializeField] private Color _onlineColor = Color.green;\n    [SerializeField] private Color _offlineColor = Color.gray;\n    [SerializeField] private int _maxDisplayedFriends = 100;\n    \n    [Header(\"Events\")]\n    [SerializeField] private FriendSelectedEvent _onFriendSelected;\n    [SerializeField] private UnityEvent _onFriendListRefreshed;\n    \n    private List<Friend> _allFriends = new List<Friend>();\n    private List<Friend> _filteredFriends = new List<Friend>();\n    private List<GameObject> _friendItemObjects = new List<GameObject>();\n    private string _currentSearchFilter = \"\";\n    \n    private void Start()\n    {\n        InitializeUI();\n        LoadSampleFriends();\n        RefreshFriendList();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshFriendList);\n            \n        if (_searchField != null)\n            _searchField.onValueChanged.AddListener(OnSearchChanged);\n    }\n    \n    private void LoadSampleFriends()\n    {\n        _allFriends.Clear();\n        \n        // Add sample friends for demonstration\n        AddFriend(\"player1\", \"Alex Thunder\", true, 25);\n        AddFriend(\"player2\", \"Sarah Storm\", false, 18);\n        AddFriend(\"player3\", \"Mike Lightning\", true, 32);\n        AddFriend(\"player4\", \"Emma Frost\", false, 12);\n        AddFriend(\"player5\", \"Jake Fire\", true, 45);\n        AddFriend(\"player6\", \"Luna Moon\", false, 8);\n        AddFriend(\"player7\", \"Rex Dragon\", true, 67);\n        AddFriend(\"player8\", \"Zoe Star\", false, 23);\n    }\n    \n    public void AddFriend(string username, string displayName, bool isOnline = false, int level = 1)\n    {\n        Friend newFriend = new Friend(username, displayName)\n        {\n            isOnline = isOnline,\n            level = level,\n            lastSeen = isOnline ? DateTime.Now : DateTime.Now.AddHours(-UnityEngine.Random.Range(1, 72))\n        };\n        \n        _allFriends.Add(newFriend);\n    }\n    \n    public void RemoveFriend(string username)\n    {\n        _allFriends.RemoveAll(f => f.username == username);\n        RefreshFriendList();\n    }\n    \n    public void RefreshFriendList()\n    {\n        FilterFriends();\n        SortFriends();\n        UpdateFriendDisplay();\n        UpdateFriendCount();\n        _onFriendListRefreshed?.Invoke();\n    }\n    \n    private void FilterFriends()\n    {\n        _filteredFriends.Clear();\n        \n        foreach (Friend friend in _allFriends)\n        {\n            if (string.IsNullOrEmpty(_currentSearchFilter) || \n                friend.displayName.ToLower().Contains(_currentSearchFilter.ToLower()) ||\n                friend.username.ToLower().Contains(_currentSearchFilter.ToLower()))\n            {\n                _filteredFriends.Add(friend);\n            }\n        }\n        \n        if (_filteredFriends.Count > _maxDisplayedFriends)\n        {\n            _filteredFriends = _filteredFriends.GetRange(0, _maxDisplayedFriends);\n        }\n    }\n    \n    private void SortFriends()\n    {\n        if (_showOnlineFirst)\n        {\n            _filteredFriends.Sort((a, b) =>\n            {\n                if (a.isOnline && !b.isOnline) return -1;\n                if (!a.isOnline && b.isOnline) return 1;\n                return string.Compare(a.displayName, b.displayName, StringComparison.OrdinalIgnoreCase);\n            });\n        }\n        else\n        {\n            _filteredFriends.Sort((a, b) => \n                string.Compare(a.displayName, b.displayName, StringComparison.OrdinalIgnoreCase));\n        }\n    }\n    \n    private void UpdateFriendDisplay()\n    {\n        ClearFriendItems();\n        \n        if (_friendListParent == null || _friendItemPrefab == null)\n            return;\n            \n        foreach (Friend friend in _filteredFriends)\n        {\n            GameObject friendItem = Instantiate(_friendItemPrefab, _friendListParent);\n            SetupFriendItem(friendItem, friend);\n            _friendItemObjects.Add(friendItem);\n        }\n        \n        if (_scrollRect != null)\n        {\n            Canvas.ForceUpdateCanvases();\n            _scrollRect.verticalNormalizedPosition = 1f;\n        }\n    }\n    \n    private void SetupFriendItem(GameObject friendItem, Friend friend)\n    {\n        // Setup display name\n        Text nameText = friendItem.transform.Find(\"NameText\")?.GetComponent<Text>();\n        if (nameText != null)\n            nameText.text = friend.displayName;\n            \n        // Setup online status\n        Image statusImage = friendItem.transform.Find(\"StatusImage\")?.GetComponent<Image>();\n        if (statusImage != null)\n            statusImage.color = friend.isOnline ? _onlineColor : _offlineColor;\n            \n        // Setup level text\n        Text levelText = friendItem.transform.Find(\"LevelText\")?.GetComponent<Text>();\n        if (levelText != null)\n            levelText.text = $\"Lv.{friend.level}\";\n            \n        // Setup last seen text\n        if (_showLastSeen)\n        {\n            Text lastSeenText = friendItem.transform.Find(\"LastSeenText\")?.GetComponent<Text>();\n            if (lastSeenText != null)\n            {\n                if (friend.isOnline)\n                {\n                    lastSeenText.text = \"Online\";\n                    lastSeenText.color = _onlineColor;\n                }\n                else\n                {\n                    TimeSpan timeDiff = DateTime.Now - friend.lastSeen;\n                    lastSeenText.text = FormatLastSeen(timeDiff);\n                    lastSeenText.color = _offlineColor;\n                }\n            }\n        }\n        \n        // Setup avatar\n        Image avatarImage = friendItem.transform.Find(\"AvatarImage\")?.GetComponent<Image>();\n        if (avatarImage != null && friend.avatar != null)\n            avatarImage.sprite = friend.avatar;\n            \n        // Setup click handler\n        Button friendButton = friendItem.GetComponent<Button>();\n        if (friendButton != null)\n        {\n            friendButton.onClick.AddListener(() => OnFriendSelected(friend));\n        }\n    }\n    \n    private string FormatLastSeen(TimeSpan timeDiff)\n    {\n        if (timeDiff.TotalMinutes < 1)\n            return \"Just now\";\n        else if (timeDiff.TotalHours < 1)\n            return $\"{(int)timeDiff.TotalMinutes}m ago\";\n        else if (timeDiff.TotalDays < 1)\n            return $\"{(int)timeDiff.TotalHours}h ago\";\n        else if (timeDiff.TotalDays < 7)\n            return $\"{(int)timeDiff.TotalDays}d ago\";\n        else\n            return \"Long ago\";\n    }\n    \n    private void ClearFriendItems()\n    {\n        foreach (GameObject item in _friendItemObjects)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _friendItemObjects.Clear();\n    }\n    \n    private void UpdateFriendCount()\n    {\n        if (_friendCountText != null)\n        {\n            int onlineCount = 0;\n            foreach (Friend friend in _allFriends)\n            {\n                if (friend.isOnline) onlineCount++;\n            }\n            \n            _friendCountText.text = $\"Friends ({onlineCount}/{_allFriends.Count})\";\n        }\n    }\n    \n    private void OnSearchChanged(string searchText)\n    {\n        _currentSearchFilter = searchText;\n        RefreshFriendList();\n    }\n    \n    private void OnFriendSelected(Friend friend)\n    {\n        _onFriendSelected?.Invoke(friend);\n    }\n    \n    public void SetFriendOnlineStatus(string username, bool isOnline)\n    {\n        Friend friend = _allFriends.Find(f => f.username == username);\n        if (friend != null)\n        {\n            friend.isOnline = isOnline;\n            if (!isOnline)\n                friend.lastSeen = DateTime.Now;\n            RefreshFriendList();\n        }\n    }\n    \n    public void UpdateFriendLevel(string username, int newLevel)\n    {\n        Friend friend = _allFriends.Find(f => f.username == username);\n        if (friend != null)\n        {\n            friend.level = newLevel;\n            RefreshFriendList();\n        }\n    }\n    \n    public Friend GetFriend(string username)\n    {\n        return _allFriends.Find(f => f.username == username);\n    }\n    \n    public List<Friend> GetOnlineFriends()\n    {\n        return _allFriends.FindAll(f => f.isOnline);\n    }\n    \n    public int GetFriendCount()\n    {\n        return _allFriends.Count;\n    }\n    \n    public int GetOnlineFriendCount()\n    {\n        return _allFriends.FindAll(f => f.isOnline).Count;\n    }\n    \n    private void OnDestroy()\n    {\n        ClearFriendItems();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "party invite system",
      "ideal_ir": {
        "class_name": "PartyInviteSystem",
        "components": [
          "MonoBehaviour"
        ],
        "fields": [
          {
            "name": "maxPartySize",
            "type": "int",
            "default": 4
          },
          {
            "name": "inviteTimeout",
            "type": "float",
            "default": 30.0
          },
          {
            "name": "currentPartyMembers",
            "type": "List<GameObject>",
            "default": null
          },
          {
            "name": "pendingInvites",
            "type": "Dictionary<GameObject, float>",
            "default": null
          },
          {
            "name": "partyLeader",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "inviteUI",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "partyListUI",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "send_party_invite",
            "trigger": "when player sends invite to another player",
            "actions": [
              {
                "action": "check if target player is already in a party"
              },
              {
                "action": "check if current party has available slots"
              },
              {
                "action": "add invite to pending invites with timestamp"
              },
              {
                "action": "display invite notification to target player"
              },
              {
                "action": "show invite sent confirmation to sender"
              }
            ]
          },
          {
            "name": "accept_party_invite",
            "trigger": "when player accepts a party invite",
            "actions": [
              {
                "action": "remove invite from pending invites"
              },
              {
                "action": "add accepting player to party members list"
              },
              {
                "action": "notify all party members of new member"
              },
              {
                "action": "update party UI for all members"
              },
              {
                "action": "hide invite notification"
              }
            ]
          },
          {
            "name": "decline_party_invite",
            "trigger": "when player declines a party invite",
            "actions": [
              {
                "action": "remove invite from pending invites"
              },
              {
                "action": "notify sender that invite was declined"
              },
              {
                "action": "hide invite notification"
              }
            ]
          },
          {
            "name": "check_invite_timeouts",
            "trigger": "every second while system is active",
            "actions": [
              {
                "action": "check all pending invites for expired timestamps"
              },
              {
                "action": "remove expired invites from pending list"
              },
              {
                "action": "notify players when their sent invites expire"
              }
            ]
          },
          {
            "name": "leave_party",
            "trigger": "when player chooses to leave party",
            "actions": [
              {
                "action": "remove player from party members list"
              },
              {
                "action": "notify remaining party members of departure"
              },
              {
                "action": "transfer party leadership if leaving player was leader"
              },
              {
                "action": "update party UI for all remaining members"
              }
            ]
          },
          {
            "name": "kick_party_member",
            "trigger": "when party leader kicks a member",
            "actions": [
              {
                "action": "check if requesting player is party leader"
              },
              {
                "action": "remove target player from party members list"
              },
              {
                "action": "notify kicked player they were removed"
              },
              {
                "action": "notify remaining party members of removal"
              },
              {
                "action": "update party UI for all members"
              }
            ]
          },
          {
            "name": "disband_party",
            "trigger": "when party leader disbands the party",
            "actions": [
              {
                "action": "clear all party members from list"
              },
              {
                "action": "notify all members that party was disbanded"
              },
              {
                "action": "reset party leader to null"
              },
              {
                "action": "hide party UI for all former members"
              }
            ]
          }
        ]
      },
      "good_code": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class PartyInviteSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class PartyMember\n    {\n        public string playerId;\n        public string playerName;\n        public bool isLeader;\n        public bool isOnline;\n        public DateTime joinTime;\n\n        public PartyMember(string id, string name, bool leader = false)\n        {\n            playerId = id;\n            playerName = name;\n            isLeader = leader;\n            isOnline = true;\n            joinTime = DateTime.Now;\n        }\n    }\n\n    [System.Serializable]\n    public class PartyInvite\n    {\n        public string inviteId;\n        public string fromPlayerId;\n        public string fromPlayerName;\n        public string toPlayerId;\n        public string toPlayerName;\n        public DateTime sentTime;\n        public float expireTime;\n\n        public PartyInvite(string from, string fromName, string to, string toName, float expire)\n        {\n            inviteId = Guid.NewGuid().ToString();\n            fromPlayerId = from;\n            fromPlayerName = fromName;\n            toPlayerId = to;\n            toPlayerName = toName;\n            sentTime = DateTime.Now;\n            expireTime = expire;\n        }\n\n        public bool IsExpired => (DateTime.Now - sentTime).TotalSeconds > expireTime;\n    }\n\n    [System.Serializable]\n    public class PartyInviteEvent : UnityEvent<PartyInvite> { }\n\n    [System.Serializable]\n    public class PartyMemberEvent : UnityEvent<PartyMember> { }\n\n    [System.Serializable]\n    public class PartyEvent : UnityEvent<List<PartyMember>> { }\n\n    [Header(\"Party Settings\")]\n    [SerializeField] private int _maxPartySize = 4;\n    [SerializeField] private float _inviteExpireTime = 30f;\n    [SerializeField] private bool _allowPublicJoin = false;\n    [SerializeField] private string _currentPlayerId = \"Player1\";\n    [SerializeField] private string _currentPlayerName = \"LocalPlayer\";\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _invitePanel;\n    [SerializeField] private Text _inviteText;\n    [SerializeField] private Button _acceptButton;\n    [SerializeField] private Button _declineButton;\n    [SerializeField] private GameObject _partyPanel;\n    [SerializeField] private Transform _memberListParent;\n    [SerializeField] private GameObject _memberPrefab;\n    [SerializeField] private Button _leavePartyButton;\n    [SerializeField] private InputField _invitePlayerInput;\n    [SerializeField] private Button _sendInviteButton;\n\n    [Header(\"Events\")]\n    public PartyInviteEvent OnInviteReceived;\n    public PartyInviteEvent OnInviteSent;\n    public PartyMemberEvent OnMemberJoined;\n    public PartyMemberEvent OnMemberLeft;\n    public PartyEvent OnPartyUpdated;\n    public UnityEvent OnPartyDisbanded;\n\n    private List<PartyMember> _currentParty = new List<PartyMember>();\n    private List<PartyInvite> _pendingInvites = new List<PartyInvite>();\n    private List<PartyInvite> _sentInvites = new List<PartyInvite>();\n    private PartyInvite _currentInviteDisplay;\n    private Dictionary<string, GameObject> _memberUIElements = new Dictionary<string, GameObject>();\n\n    public bool IsInParty => _currentParty.Count > 0;\n    public bool IsPartyLeader => IsInParty && _currentParty.Find(m => m.playerId == _currentPlayerId)?.isLeader == true;\n    public int PartySize => _currentParty.Count;\n    public bool IsPartyFull => PartySize >= _maxPartySize;\n\n    private void Start()\n    {\n        InitializeUI();\n        StartCoroutine(CleanupExpiredInvites());\n    }\n\n    private void InitializeUI()\n    {\n        if (_invitePanel != null)\n            _invitePanel.SetActive(false);\n\n        if (_partyPanel != null)\n            _partyPanel.SetActive(false);\n\n        if (_acceptButton != null)\n            _acceptButton.onClick.AddListener(AcceptCurrentInvite);\n\n        if (_declineButton != null)\n            _declineButton.onClick.AddListener(DeclineCurrentInvite);\n\n        if (_leavePartyButton != null)\n            _leavePartyButton.onClick.AddListener(LeaveParty);\n\n        if (_sendInviteButton != null)\n            _sendInviteButton.onClick.AddListener(SendInviteFromInput);\n\n        UpdatePartyUI();\n    }\n\n    public void SendInvite(string targetPlayerId, string targetPlayerName)\n    {\n        if (string.IsNullOrEmpty(targetPlayerId) || string.IsNullOrEmpty(targetPlayerName))\n        {\n            Debug.LogWarning(\"Cannot send invite: Invalid target player information\");\n            return;\n        }\n\n        if (targetPlayerId == _currentPlayerId)\n        {\n            Debug.LogWarning(\"Cannot invite yourself to party\");\n            return;\n        }\n\n        if (IsPartyFull)\n        {\n            Debug.LogWarning(\"Cannot send invite: Party is full\");\n            return;\n        }\n\n        if (IsInParty && !IsPartyLeader)\n        {\n            Debug.LogWarning(\"Cannot send invite: Only party leader can invite members\");\n            return;\n        }\n\n        if (_currentParty.Exists(m => m.playerId == targetPlayerId))\n        {\n            Debug.LogWarning(\"Player is already in the party\");\n            return;\n        }\n\n        if (_sentInvites.Exists(i => i.toPlayerId == targetPlayerId && !i.IsExpired))\n        {\n            Debug.LogWarning(\"Invite already sent to this player\");\n            return;\n        }\n\n        PartyInvite invite = new PartyInvite(_currentPlayerId, _currentPlayerName, targetPlayerId, targetPlayerName, _inviteExpireTime);\n        _sentInvites.Add(invite);\n\n        OnInviteSent?.Invoke(invite);\n        Debug.Log($\"Party invite sent to {targetPlayerName}\");\n\n        // Simulate receiving invite on target (for demo purposes)\n        if (targetPlayerId == \"DemoPlayer\")\n        {\n            SimulateReceiveInvite(invite);\n        }\n    }\n\n    public void ReceiveInvite(PartyInvite invite)\n    {\n        if (invite == null || invite.IsExpired)\n        {\n            Debug.LogWarning(\"Received invalid or expired invite\");\n            return;\n        }\n\n        if (invite.toPlayerId != _currentPlayerId)\n        {\n            Debug.LogWarning(\"Received invite not intended for this player\");\n            return;\n        }\n\n        if (IsPartyFull)\n        {\n            Debug.LogWarning(\"Cannot accept invite: Already in a full party\");\n            return;\n        }\n\n        _pendingInvites.Add(invite);\n        OnInviteReceived?.Invoke(invite);\n        ShowInviteUI(invite);\n    }\n\n    public void AcceptInvite(string inviteId)\n    {\n        PartyInvite invite = _pendingInvites.Find(i => i.inviteId == inviteId);\n        if (invite == null)\n        {\n            Debug.LogWarning(\"Invite not found\");\n            return;\n        }\n\n        if (invite.IsExpired)\n        {\n            Debug.LogWarning(\"Cannot accept expired invite\");\n            _pendingInvites.Remove(invite);\n            return;\n        }\n\n        // Leave current party if in one\n        if (IsInParty)\n        {\n            LeaveParty();\n        }\n\n        // Join the party\n        JoinParty(invite.fromPlayerId, invite.fromPlayerName);\n        _pendingInvites.Remove(invite);\n        HideInviteUI();\n\n        Debug.Log($\"Accepted party invite from {invite.fromPlayerName}\");\n    }\n\n    public void DeclineInvite(string inviteId)\n    {\n        PartyInvite invite = _pendingInvites.Find(i => i.inviteId == inviteId);\n        if (invite != null)\n        {\n            _pendingInvites.Remove(invite);\n            Debug.Log($\"Declined party invite from {invite.fromPlayerName}\");\n        }\n        HideInviteUI();\n    }\n\n    public void CreateParty()\n    {\n        if (IsInParty)\n        {\n            Debug.LogWarning(\"Already in a party\");\n            return;\n        }\n\n        _currentParty.Clear();\n        PartyMember leader = new PartyMember(_currentPlayerId, _currentPlayerName, true);\n        _currentParty.Add(leader);\n\n        OnMemberJoined?.Invoke(leader);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log(\"Party created\");\n    }\n\n    public void JoinParty(string leaderId, string leaderName)\n    {\n        if (IsInParty)\n        {\n            LeaveParty();\n        }\n\n        _currentParty.Clear();\n        \n        // Add leader\n        PartyMember leader = new PartyMember(leaderId, leaderName, true);\n        _currentParty.Add(leader);\n\n        // Add self\n        PartyMember self = new PartyMember(_currentPlayerId, _currentPlayerName, false);\n        _currentParty.Add(self);\n\n        OnMemberJoined?.Invoke(self);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log($\"Joined party led by {leaderName}\");\n    }\n\n    public void LeaveParty()\n    {\n        if (!IsInParty)\n        {\n            Debug.LogWarning(\"Not in a party\");\n            return;\n        }\n\n        PartyMember leavingMember = _currentParty.Find(m => m.playerId == _currentPlayerId);\n        bool wasLeader = leavingMember?.isLeader == true;\n\n        _currentParty.RemoveAll(m => m.playerId == _currentPlayerId);\n\n        if (wasLeader && _currentParty.Count > 0)\n        {\n            // Transfer leadership to next member\n            _currentParty[0].isLeader = true;\n            Debug.Log($\"Leadership transferred to {_currentParty[0].playerName}\");\n        }\n\n        if (leavingMember != null)\n        {\n            OnMemberLeft?.Invoke(leavingMember);\n        }\n\n        if (_currentParty.Count == 0)\n        {\n            OnPartyDisbanded?.Invoke();\n            Debug.Log(\"Party disbanded\");\n        }\n        else\n        {\n            OnPartyUpdated?.Invoke(_currentParty);\n        }\n\n        UpdatePartyUI();\n        Debug.Log(\"Left party\");\n    }\n\n    public void KickMember(string playerId)\n    {\n        if (!IsPartyLeader)\n        {\n            Debug.LogWarning(\"Only party leader can kick members\");\n            return;\n        }\n\n        if (playerId == _currentPlayerId)\n        {\n            Debug.LogWarning(\"Cannot kick yourself\");\n            return;\n        }\n\n        PartyMember memberToKick = _currentParty.Find(m => m.playerId == playerId);\n        if (memberToKick == null)\n        {\n            Debug.LogWarning(\"Member not found in party\");\n            return;\n        }\n\n        _currentParty.Remove(memberToKick);\n        OnMemberLeft?.Invoke(memberToKick);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log($\"Kicked {memberToKick.playerName} from party\");\n    }\n\n    private void SendInviteFromInput()\n    {\n        if (_invitePlayerInput != null && !string.IsNullOrEmpty(_invitePlayerInput.text))\n        {\n            string targetName = _invitePlayerInput.text.Trim();\n            string targetId = \"Player_\" + targetName; // Simple ID generation\n            SendInvite(targetId, targetName);\n            _invitePlayerInput.text = \"\";\n        }\n    }\n\n    private void AcceptCurrentInvite()\n    {\n        if (_currentInviteDisplay != null)\n        {\n            AcceptInvite(_currentInviteDisplay.inviteId);\n        }\n    }\n\n    private void DeclineCurrentInvite()\n    {\n        if (_currentInviteDisplay != null)\n        {\n            DeclineInvite(_currentInviteDisplay.inviteId);\n        }\n    }\n\n    private void ShowInviteUI(PartyInvite invite)\n    {\n        _currentInviteDisplay = invite;\n        \n        if (_invitePanel != null)\n        {\n            _invitePanel.SetActive(true);\n        }\n\n        if (_inviteText != null)\n        {\n            _inviteText.text = $\"{invite.fromPlayerName} invited you to join their party\";\n        }\n    }\n\n    private void HideInviteUI()\n    {\n        _currentInviteDisplay = null;\n        \n        if (_invitePanel != null)\n        {\n            _invitePanel.SetActive(false);\n        }\n    }\n\n    private void UpdatePartyUI()\n    {\n        if (_partyPanel != null)\n        {\n            _partyPanel.SetActive(IsInParty);\n        }\n\n        if (_leavePartyButton != null)\n        {\n            _leavePartyButton.gameObject.SetActive(IsInParty);\n        }\n\n        UpdateMemberList();\n    }\n\n    private void UpdateMemberList()\n    {\n        if (_memberListParent == null || _memberPrefab == null)\n            return;\n\n        // Clear existing UI elements\n        foreach (var kvp in _memberUIElements)\n        {\n            if (kvp.Value != null)\n                DestroyImmediate(kvp.Value);\n        }\n        _memberUIElements.Clear();\n\n        // Create UI elements for current party members\n        foreach (PartyMember member in _currentParty)\n        {\n            GameObject memberUI = Instantiate(_memberPrefab, _memberListParent);\n            _memberUIElements[member.playerId] = memberUI;\n\n            Text memberText = memberUI.GetComponentInChildren<Text>();\n            if (memberText != null)\n            {\n                string displayText = member.playerName;\n                if (member.isLeader)\n                    displayText += \" (Leader)\";\n                if (member.playerId == _currentPlayerId)\n                    displayText += \" (You)\";\n                \n                memberText.text = displayText;\n            }\n\n            Button kickButton = memberUI.GetComponentInChildren<Button>();\n            if (kickButton != null)\n            {\n                bool canKick = IsPartyLeader && member.playerId != _currentPlayerId;\n                kickButton.gameObject.SetActive(canKick);\n                \n                if (canKick)\n                {\n                    string memberIdToKick = member.playerId;\n                    kickButton.onClick.RemoveAllListeners();\n                    kickButton.onClick.AddListener(() => KickMember(memberIdToKick));\n                }\n            }\n        }\n    }\n\n    private System.Collections.IEnumerator CleanupExpiredInvites()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(5f);\n\n            _pendingInvites.RemoveAll(i => i.IsExpired);\n            _sentInvites.RemoveAll(i => i.IsExpired);",
      "behavior_type": "general"
    },
    {
      "prompt": "ping indicator",
      "ideal_ir": {
        "class_name": "PingIndicator",
        "components": [
          "Transform",
          "Renderer",
          "Animator"
        ],
        "fields": [
          {
            "name": "pingDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "fadeSpeed",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "pulseScale",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_ping",
            "trigger": "when ping is triggered",
            "actions": [
              {
                "action": "make indicator visible"
              },
              {
                "action": "set active state to true"
              },
              {
                "action": "start fade in animation"
              },
              {
                "action": "begin pulse scaling effect"
              }
            ]
          },
          {
            "name": "pulse_animation",
            "trigger": "while ping is active",
            "actions": [
              {
                "action": "scale up to pulse scale size"
              },
              {
                "action": "scale back down to normal size"
              },
              {
                "action": "repeat pulsing motion smoothly"
              }
            ]
          },
          {
            "name": "fade_out",
            "trigger": "when ping duration time has elapsed",
            "actions": [
              {
                "action": "gradually reduce opacity"
              },
              {
                "action": "fade out at specified fade speed"
              },
              {
                "action": "stop pulsing animation"
              }
            ]
          },
          {
            "name": "deactivate_ping",
            "trigger": "when fade out is complete",
            "actions": [
              {
                "action": "make indicator invisible"
              },
              {
                "action": "set active state to false"
              },
              {
                "action": "reset scale to normal size"
              },
              {
                "action": "reset opacity to full"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\n\npublic class PingIndicator : MonoBehaviour\n{\n    [Header(\"Ping Display\")]\n    [SerializeField] private Text _pingText;\n    [SerializeField] private Image _pingIcon;\n    [SerializeField] private string _pingPrefix = \"Ping: \";\n    [SerializeField] private string _pingSuffix = \"ms\";\n    \n    [Header(\"Update Settings\")]\n    [SerializeField] private float _updateInterval = 1f;\n    [SerializeField] private int _sampleCount = 10;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _goodPingColor = Color.green;\n    [SerializeField] private Color _averagePingColor = Color.yellow;\n    [SerializeField] private Color _badPingColor = Color.red;\n    [SerializeField] private int _goodPingThreshold = 50;\n    [SerializeField] private int _badPingThreshold = 150;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulseAnimation = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    private float[] _pingSamples;\n    private int _currentSampleIndex;\n    private float _currentPing;\n    private float _averagePing;\n    private Coroutine _updateCoroutine;\n    private Vector3 _originalScale;\n    \n    private void Start()\n    {\n        InitializePingIndicator();\n        StartPingUpdates();\n    }\n    \n    private void Update()\n    {\n        if (_enablePulseAnimation && _pingIcon != null)\n        {\n            UpdatePulseAnimation();\n        }\n    }\n    \n    private void InitializePingIndicator()\n    {\n        _pingSamples = new float[_sampleCount];\n        _currentSampleIndex = 0;\n        _currentPing = 0f;\n        _averagePing = 0f;\n        \n        if (_pingIcon != null)\n        {\n            _originalScale = _pingIcon.transform.localScale;\n        }\n        \n        if (_pingText != null)\n        {\n            _pingText.text = _pingPrefix + \"...\" + _pingSuffix;\n        }\n    }\n    \n    private void StartPingUpdates()\n    {\n        if (_updateCoroutine != null)\n        {\n            StopCoroutine(_updateCoroutine);\n        }\n        \n        _updateCoroutine = StartCoroutine(UpdatePingRoutine());\n    }\n    \n    private IEnumerator UpdatePingRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_updateInterval);\n            UpdatePing();\n        }\n    }\n    \n    private void UpdatePing()\n    {\n        _currentPing = SimulatePing();\n        \n        _pingSamples[_currentSampleIndex] = _currentPing;\n        _currentSampleIndex = (_currentSampleIndex + 1) % _sampleCount;\n        \n        CalculateAveragePing();\n        UpdateDisplay();\n        UpdateVisualFeedback();\n    }\n    \n    private float SimulatePing()\n    {\n        float basePing = Random.Range(20f, 200f);\n        float variation = Random.Range(-10f, 10f);\n        return Mathf.Max(1f, basePing + variation);\n    }\n    \n    private void CalculateAveragePing()\n    {\n        float sum = 0f;\n        int validSamples = 0;\n        \n        for (int i = 0; i < _pingSamples.Length; i++)\n        {\n            if (_pingSamples[i] > 0f)\n            {\n                sum += _pingSamples[i];\n                validSamples++;\n            }\n        }\n        \n        _averagePing = validSamples > 0 ? sum / validSamples : _currentPing;\n    }\n    \n    private void UpdateDisplay()\n    {\n        if (_pingText != null)\n        {\n            int displayPing = Mathf.RoundToInt(_averagePing);\n            _pingText.text = _pingPrefix + displayPing.ToString() + _pingSuffix;\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        Color targetColor = GetPingColor(_averagePing);\n        \n        if (_pingText != null)\n        {\n            _pingText.color = targetColor;\n        }\n        \n        if (_pingIcon != null)\n        {\n            _pingIcon.color = targetColor;\n        }\n    }\n    \n    private Color GetPingColor(float ping)\n    {\n        if (ping <= _goodPingThreshold)\n        {\n            return _goodPingColor;\n        }\n        else if (ping <= _badPingThreshold)\n        {\n            float t = (ping - _goodPingThreshold) / (_badPingThreshold - _goodPingThreshold);\n            return Color.Lerp(_goodPingColor, _averagePingColor, t);\n        }\n        else\n        {\n            float t = Mathf.Clamp01((ping - _badPingThreshold) / 100f);\n            return Color.Lerp(_averagePingColor, _badPingColor, t);\n        }\n    }\n    \n    private void UpdatePulseAnimation()\n    {\n        if (_originalScale == Vector3.zero) return;\n        \n        float pulseValue = 1f + Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n        _pingIcon.transform.localScale = _originalScale * pulseValue;\n    }\n    \n    public void SetPingValue(float ping)\n    {\n        _currentPing = Mathf.Max(1f, ping);\n        _pingSamples[_currentSampleIndex] = _currentPing;\n        _currentSampleIndex = (_currentSampleIndex + 1) % _sampleCount;\n        \n        CalculateAveragePing();\n        UpdateDisplay();\n        UpdateVisualFeedback();\n    }\n    \n    public float GetCurrentPing()\n    {\n        return _currentPing;\n    }\n    \n    public float GetAveragePing()\n    {\n        return _averagePing;\n    }\n    \n    public void ResetPingHistory()\n    {\n        for (int i = 0; i < _pingSamples.Length; i++)\n        {\n            _pingSamples[i] = 0f;\n        }\n        _currentSampleIndex = 0;\n        _averagePing = 0f;\n    }\n    \n    public void SetUpdateInterval(float interval)\n    {\n        _updateInterval = Mathf.Max(0.1f, interval);\n        StartPingUpdates();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_updateCoroutine != null)\n        {\n            StopCoroutine(_updateCoroutine);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "server browser list",
      "ideal_ir": {
        "class_name": "ServerBrowserList",
        "components": [
          "ScrollRect",
          "VerticalLayoutGroup",
          "ContentSizeFitter"
        ],
        "fields": [
          {
            "name": "serverEntryPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "contentParent",
            "type": "Transform",
            "default": null
          },
          {
            "name": "refreshButton",
            "type": "Button",
            "default": null
          },
          {
            "name": "loadingIndicator",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "emptyListMessage",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "refreshInterval",
            "type": "float",
            "default": 30
          },
          {
            "name": "maxServersDisplayed",
            "type": "int",
            "default": 100
          }
        ],
        "behaviors": [
          {
            "name": "initialize_server_list",
            "trigger": "when component starts",
            "actions": [
              {
                "action": "show loading indicator"
              },
              {
                "action": "hide empty list message"
              },
              {
                "action": "request server list from master server"
              }
            ]
          },
          {
            "name": "refresh_server_list",
            "trigger": "when refresh button is clicked",
            "actions": [
              {
                "action": "clear existing server entries"
              },
              {
                "action": "show loading indicator"
              },
              {
                "action": "request updated server list from master server"
              }
            ]
          },
          {
            "name": "populate_server_list",
            "trigger": "when server data is received",
            "actions": [
              {
                "action": "hide loading indicator"
              },
              {
                "action": "create server entry for each received server"
              },
              {
                "action": "display server name, player count, ping, and game mode"
              },
              {
                "action": "sort servers by player count or ping"
              }
            ]
          },
          {
            "name": "handle_empty_list",
            "trigger": "when no servers are found",
            "actions": [
              {
                "action": "hide loading indicator"
              },
              {
                "action": "show empty list message"
              },
              {
                "action": "display no servers available text"
              }
            ]
          },
          {
            "name": "auto_refresh_list",
            "trigger": "when refresh interval time has passed",
            "actions": [
              {
                "action": "automatically request updated server list"
              },
              {
                "action": "update existing server entries with new data"
              }
            ]
          },
          {
            "name": "filter_full_servers",
            "trigger": "when filter option is enabled",
            "actions": [
              {
                "action": "hide server entries that are at maximum capacity"
              },
              {
                "action": "update list display to show only available servers"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System;\n\npublic class ServerBrowserList : MonoBehaviour\n{\n    [System.Serializable]\n    public class ServerInfo\n    {\n        public string serverName;\n        public string ipAddress;\n        public int port;\n        public int currentPlayers;\n        public int maxPlayers;\n        public int ping;\n        public string gameMode;\n        public string mapName;\n        public bool isPasswordProtected;\n        \n        public ServerInfo(string name, string ip, int p, int current, int max, string mode, string map, bool password = false)\n        {\n            serverName = name;\n            ipAddress = ip;\n            port = p;\n            currentPlayers = current;\n            maxPlayers = max;\n            ping = 0;\n            gameMode = mode;\n            mapName = map;\n            isPasswordProtected = password;\n        }\n    }\n    \n    [System.Serializable]\n    public class ServerSelectedEvent : UnityEvent<ServerInfo> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _serverListParent;\n    [SerializeField] private GameObject _serverItemPrefab;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private Button _joinButton;\n    [SerializeField] private InputField _passwordInputField;\n    [SerializeField] private GameObject _passwordPanel;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private ScrollRect _scrollRect;\n    \n    [Header(\"Server Discovery\")]\n    [SerializeField] private int _broadcastPort = 7777;\n    [SerializeField] private int _discoveryTimeout = 3000;\n    [SerializeField] private string _discoveryMessage = \"SERVER_DISCOVERY\";\n    \n    [Header(\"Filters\")]\n    [SerializeField] private Toggle _showFullServersToggle;\n    [SerializeField] private Toggle _showPasswordProtectedToggle;\n    [SerializeField] private InputField _serverNameFilter;\n    [SerializeField] private Dropdown _gameModeFilter;\n    \n    [Header(\"Events\")]\n    public ServerSelectedEvent OnServerSelected;\n    public UnityEvent OnRefreshStarted;\n    public UnityEvent OnRefreshCompleted;\n    \n    private List<ServerInfo> _allServers = new List<ServerInfo>();\n    private List<ServerInfo> _filteredServers = new List<ServerInfo>();\n    private List<GameObject> _serverItemObjects = new List<GameObject>();\n    private ServerInfo _selectedServer;\n    private UdpClient _udpClient;\n    private Thread _discoveryThread;\n    private bool _isRefreshing = false;\n    private bool _shouldStopDiscovery = false;\n    \n    private void Start()\n    {\n        InitializeUI();\n        AddDummyServers();\n        RefreshServerList();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshServerList);\n            \n        if (_joinButton != null)\n        {\n            _joinButton.onClick.AddListener(JoinSelectedServer);\n            _joinButton.interactable = false;\n        }\n        \n        if (_showFullServersToggle != null)\n            _showFullServersToggle.onValueChanged.AddListener(OnFilterChanged);\n            \n        if (_showPasswordProtectedToggle != null)\n            _showPasswordProtectedToggle.onValueChanged.AddListener(OnFilterChanged);\n            \n        if (_serverNameFilter != null)\n            _serverNameFilter.onValueChanged.AddListener(OnServerNameFilterChanged);\n            \n        if (_gameModeFilter != null)\n            _gameModeFilter.onValueChanged.AddListener(OnGameModeFilterChanged);\n            \n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n            \n        UpdateStatusText(\"Ready\");\n    }\n    \n    private void AddDummyServers()\n    {\n        _allServers.Add(new ServerInfo(\"Official Server #1\", \"192.168.1.100\", 7777, 12, 16, \"Deathmatch\", \"Desert_Map\"));\n        _allServers.Add(new ServerInfo(\"Community Server\", \"192.168.1.101\", 7778, 8, 12, \"Team Deathmatch\", \"City_Map\", true));\n        _allServers.Add(new ServerInfo(\"Noob Friendly\", \"192.168.1.102\", 7779, 4, 8, \"Capture Flag\", \"Forest_Map\"));\n        _allServers.Add(new ServerInfo(\"Pro Players Only\", \"192.168.1.103\", 7780, 16, 16, \"Battle Royale\", \"Island_Map\", true));\n        _allServers.Add(new ServerInfo(\"Training Ground\", \"192.168.1.104\", 7781, 2, 10, \"Practice\", \"Training_Map\"));\n    }\n    \n    public void RefreshServerList()\n    {\n        if (_isRefreshing) return;\n        \n        _isRefreshing = true;\n        OnRefreshStarted?.Invoke();\n        UpdateStatusText(\"Searching for servers...\");\n        \n        if (_refreshButton != null)\n            _refreshButton.interactable = false;\n            \n        StartServerDiscovery();\n    }\n    \n    private void StartServerDiscovery()\n    {\n        _shouldStopDiscovery = false;\n        _discoveryThread = new Thread(DiscoverServers);\n        _discoveryThread.Start();\n        \n        Invoke(nameof(StopServerDiscovery), _discoveryTimeout / 1000f);\n    }\n    \n    private void DiscoverServers()\n    {\n        try\n        {\n            _udpClient = new UdpClient();\n            _udpClient.EnableBroadcast = true;\n            \n            IPEndPoint broadcastEndPoint = new IPEndPoint(IPAddress.Broadcast, _broadcastPort);\n            byte[] data = Encoding.UTF8.GetBytes(_discoveryMessage);\n            \n            _udpClient.Send(data, data.Length, broadcastEndPoint);\n            \n            IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n            _udpClient.Client.ReceiveTimeout = 1000;\n            \n            while (!_shouldStopDiscovery)\n            {\n                try\n                {\n                    byte[] receivedData = _udpClient.Receive(ref remoteEndPoint);\n                    string response = Encoding.UTF8.GetString(receivedData);\n                    \n                    ParseServerResponse(response, remoteEndPoint.Address.ToString());\n                }\n                catch (SocketException)\n                {\n                    // Timeout or other socket exception, continue listening\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError(\"Server discovery error: \" + ex.Message);\n        }\n        finally\n        {\n            _udpClient?.Close();\n        }\n    }\n    \n    private void ParseServerResponse(string response, string ipAddress)\n    {\n        try\n        {\n            string[] parts = response.Split('|');\n            if (parts.Length >= 6)\n            {\n                string serverName = parts[0];\n                int port = int.Parse(parts[1]);\n                int currentPlayers = int.Parse(parts[2]);\n                int maxPlayers = int.Parse(parts[3]);\n                string gameMode = parts[4];\n                string mapName = parts[5];\n                bool isPasswordProtected = parts.Length > 6 && bool.Parse(parts[6]);\n                \n                ServerInfo serverInfo = new ServerInfo(serverName, ipAddress, port, currentPlayers, maxPlayers, gameMode, mapName, isPasswordProtected);\n                \n                // Calculate ping (simplified)\n                serverInfo.ping = UnityEngine.Random.Range(20, 200);\n                \n                lock (_allServers)\n                {\n                    _allServers.Add(serverInfo);\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError(\"Error parsing server response: \" + ex.Message);\n        }\n    }\n    \n    private void StopServerDiscovery()\n    {\n        _shouldStopDiscovery = true;\n        \n        if (_discoveryThread != null && _discoveryThread.IsAlive)\n        {\n            _discoveryThread.Join(1000);\n        }\n        \n        _isRefreshing = false;\n        OnRefreshCompleted?.Invoke();\n        \n        if (_refreshButton != null)\n            _refreshButton.interactable = true;\n            \n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void ApplyFilters()\n    {\n        _filteredServers.Clear();\n        \n        foreach (ServerInfo server in _allServers)\n        {\n            bool passesFilter = true;\n            \n            // Show full servers filter\n            if (_showFullServersToggle != null && !_showFullServersToggle.isOn)\n            {\n                if (server.currentPlayers >= server.maxPlayers)\n                    passesFilter = false;\n            }\n            \n            // Show password protected filter\n            if (_showPasswordProtectedToggle != null && !_showPasswordProtectedToggle.isOn)\n            {\n                if (server.isPasswordProtected)\n                    passesFilter = false;\n            }\n            \n            // Server name filter\n            if (_serverNameFilter != null && !string.IsNullOrEmpty(_serverNameFilter.text))\n            {\n                if (!server.serverName.ToLower().Contains(_serverNameFilter.text.ToLower()))\n                    passesFilter = false;\n            }\n            \n            // Game mode filter\n            if (_gameModeFilter != null && _gameModeFilter.value > 0)\n            {\n                string selectedMode = _gameModeFilter.options[_gameModeFilter.value].text;\n                if (server.gameMode != selectedMode)\n                    passesFilter = false;\n            }\n            \n            if (passesFilter)\n                _filteredServers.Add(server);\n        }\n        \n        // Sort by ping\n        _filteredServers.Sort((a, b) => a.ping.CompareTo(b.ping));\n    }\n    \n    private void UpdateServerListUI()\n    {\n        ClearServerList();\n        \n        foreach (ServerInfo server in _filteredServers)\n        {\n            CreateServerItem(server);\n        }\n        \n        if (_scrollRect != null)\n            _scrollRect.verticalNormalizedPosition = 1f;\n    }\n    \n    private void ClearServerList()\n    {\n        foreach (GameObject item in _serverItemObjects)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _serverItemObjects.Clear();\n    }\n    \n    private void CreateServerItem(ServerInfo server)\n    {\n        if (_serverItemPrefab == null || _serverListParent == null) return;\n        \n        GameObject serverItem = Instantiate(_serverItemPrefab, _serverListParent);\n        _serverItemObjects.Add(serverItem);\n        \n        ServerListItem itemComponent = serverItem.GetComponent<ServerListItem>();\n        if (itemComponent == null)\n            itemComponent = serverItem.AddComponent<ServerListItem>();\n            \n        itemComponent.Initialize(server, OnServerItemClicked);\n    }\n    \n    private void OnServerItemClicked(ServerInfo server)\n    {\n        _selectedServer = server;\n        \n        // Update selection visual\n        foreach (GameObject item in _serverItemObjects)\n        {\n            ServerListItem itemComponent = item.GetComponent<ServerListItem>();\n            if (itemComponent != null)\n            {\n                itemComponent.SetSelected(itemComponent.ServerInfo == server);\n            }\n        }\n        \n        if (_joinButton != null)\n            _joinButton.interactable = true;\n            \n        OnServerSelected?.Invoke(server);\n    }\n    \n    private void JoinSelectedServer()\n    {\n        if (_selectedServer == null) return;\n        \n        if (_selectedServer.isPasswordProtected)\n        {\n            ShowPasswordPanel();\n        }\n        else\n        {\n            ConnectToServer(_selectedServer, \"\");\n        }\n    }\n    \n    private void ShowPasswordPanel()\n    {\n        if (_passwordPanel != null)\n        {\n            _passwordPanel.SetActive(true);\n            \n            Button confirmButton = _passwordPanel.GetComponentInChildren<Button>();\n            if (confirmButton != null)\n            {\n                confirmButton.onClick.RemoveAllListeners();\n                confirmButton.onClick.AddListener(() => {\n                    string password = _passwordInputField != null ? _passwordInputField.text : \"\";\n                    ConnectToServer(_selectedServer, password);\n                    _passwordPanel.SetActive(false);\n                });\n            }\n        }\n    }\n    \n    private void ConnectToServer(ServerInfo server, string password)\n    {\n        UpdateStatusText($\"Connecting to {server.serverName}...\");\n        Debug.Log($\"Connecting to server: {server.serverName} at {server.ipAddress}:{server.port}\");\n        \n        // Here you would implement actual connection logic\n        // For now, just simulate connection\n        Invoke(nameof(SimulateConnectionResult), 2f);\n    }\n    \n    private void SimulateConnectionResult()\n    {\n        bool success = UnityEngine.Random.Range(0f, 1f) > 0.2f; // 80% success rate\n        \n        if (success)\n        {\n            UpdateStatusText(\"Connected successfully!\");\n            Debug.Log(\"Successfully connected to server\");\n        }\n        else\n        {\n            UpdateStatusText(\"Connection failed\");\n            Debug.LogError(\"Failed to connect to server\");\n        }\n    }\n    \n    private void OnFilterChanged(bool value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void OnServerNameFilterChanged(string value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void OnGameModeFilterChanged(int value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void UpdateStatusText(string message)\n    {\n        if (_statusText != null)\n            _statusText.text = message;\n    }\n    \n    private void OnDestroy()\n    {\n        _shouldStopDiscovery = true;\n        \n        if (_discoveryThread != null && _discoveryThread.IsAlive)\n        {\n            _discoveryThread.Join(1000);\n        }\n        \n        _udpClient?.Close();\n    }\n}\n\npublic class ServerListItem : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Text _serverNameText;\n    [SerializeField] private Text _playersText;\n    [SerializeField] private Text _pingText;\n    [SerializeField] private Text _gameModeText;\n    [SerializeField] private Text _mapNameText;\n    [SerializeField] private GameObject _passwordIcon;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Button _itemButton;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _selectedColor = Color.cyan;\n    [SerializeField] private Color _fullServerColor = Color.red;\n    \n    public ServerBrowserList.ServerInfo ServerInfo { get; private set; }\n    private System.Action<ServerBrowserList.ServerInfo> _onClick",
      "behavior_type": "general"
    },
    {
      "prompt": "host migration handling",
      "ideal_ir": {
        "class_name": "HostMigrationHandler",
        "components": [
          "NetworkBehaviour",
          "NetworkManager"
        ],
        "fields": [
          {
            "name": "migrationTimeout",
            "type": "float",
            "default": 30
          },
          {
            "name": "isHostMigrationInProgress",
            "type": "bool",
            "default": false
          },
          {
            "name": "candidateHosts",
            "type": "List<NetworkPlayer>",
            "default": null
          },
          {
            "name": "migrationStartTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "hostSelectionCriteria",
            "type": "string",
            "default": "lowest_ping"
          },
          {
            "name": "backupGameState",
            "type": "GameStateData",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_host_disconnection",
            "trigger": "when current host player disconnects unexpectedly",
            "actions": [
              {
                "action": "mark host migration as in progress"
              },
              {
                "action": "record the time migration started"
              },
              {
                "action": "pause all game simulation"
              },
              {
                "action": "notify all remaining clients about host migration"
              }
            ]
          },
          {
            "name": "select_new_host",
            "trigger": "when host migration begins",
            "actions": [
              {
                "action": "gather list of eligible host candidates from remaining players"
              },
              {
                "action": "evaluate each candidate based on connection quality and system specs"
              },
              {
                "action": "select the most suitable player as new host"
              },
              {
                "action": "send host assignment message to selected player"
              }
            ]
          },
          {
            "name": "backup_game_state",
            "trigger": "when host migration is detected",
            "actions": [
              {
                "action": "capture current game state including player positions and scores"
              },
              {
                "action": "store critical gameplay data temporarily"
              },
              {
                "action": "preserve match timer and round information"
              },
              {
                "action": "save pending player actions and inputs"
              }
            ]
          },
          {
            "name": "establish_new_host",
            "trigger": "when selected player accepts host role",
            "actions": [
              {
                "action": "transfer network authority to new host"
              },
              {
                "action": "restore backed up game state on new host"
              },
              {
                "action": "reconnect all clients to new host"
              },
              {
                "action": "synchronize game state across all players"
              }
            ]
          },
          {
            "name": "handle_migration_timeout",
            "trigger": "when host migration takes longer than timeout duration",
            "actions": [
              {
                "action": "abort current migration attempt"
              },
              {
                "action": "try selecting alternative host candidate"
              },
              {
                "action": "if no candidates available disconnect all players gracefully"
              },
              {
                "action": "display migration failed message to players"
              }
            ]
          },
          {
            "name": "resume_gameplay",
            "trigger": "when new host is successfully established and synchronized",
            "actions": [
              {
                "action": "mark host migration as completed"
              },
              {
                "action": "resume game simulation and player input processing"
              },
              {
                "action": "clear migration progress flags"
              },
              {
                "action": "notify players that migration is complete"
              }
            ]
          },
          {
            "name": "handle_migration_failure",
            "trigger": "when host migration cannot be completed successfully",
            "actions": [
              {
                "action": "save player progress and match statistics"
              },
              {
                "action": "gracefully disconnect all remaining players"
              },
              {
                "action": "return players to main menu with appropriate error message"
              },
              {
                "action": "log migration failure details for debugging"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Networking;\n\npublic class HostMigrationManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class HostMigrationEvent : UnityEvent<bool> { }\n    \n    [System.Serializable]\n    public class PlayerData\n    {\n        public string playerId;\n        public string playerName;\n        public Vector3 position;\n        public Quaternion rotation;\n        public float health;\n        public int score;\n        public bool isActive;\n        \n        public PlayerData(string id, string name, Vector3 pos, Quaternion rot, float hp, int sc)\n        {\n            playerId = id;\n            playerName = name;\n            position = pos;\n            rotation = rot;\n            health = hp;\n            score = sc;\n            isActive = true;\n        }\n    }\n    \n    [System.Serializable]\n    public class GameStateData\n    {\n        public float gameTime;\n        public int gamePhase;\n        public List<PlayerData> players;\n        public Dictionary<string, object> customData;\n        \n        public GameStateData()\n        {\n            players = new List<PlayerData>();\n            customData = new Dictionary<string, object>();\n        }\n    }\n    \n    [Header(\"Host Migration Settings\")]\n    [SerializeField] private float _migrationTimeout = 10f;\n    [SerializeField] private float _heartbeatInterval = 2f;\n    [SerializeField] private int _maxMigrationAttempts = 3;\n    [SerializeField] private bool _enableAutomaticMigration = true;\n    \n    [Header(\"Events\")]\n    public HostMigrationEvent OnHostMigrationStarted;\n    public HostMigrationEvent OnHostMigrationCompleted;\n    public UnityEvent OnHostDisconnected;\n    public UnityEvent OnBecameNewHost;\n    public UnityEvent OnMigrationFailed;\n    \n    private bool _isHost;\n    private bool _isMigrating;\n    private string _currentHostId;\n    private List<string> _connectedClients;\n    private GameStateData _gameState;\n    private Coroutine _heartbeatCoroutine;\n    private Coroutine _migrationCoroutine;\n    private float _lastHeartbeatTime;\n    private int _migrationAttempts;\n    private Dictionary<string, float> _clientPriorities;\n    \n    private void Start()\n    {\n        InitializeHostMigration();\n    }\n    \n    private void Update()\n    {\n        if (!_isMigrating)\n        {\n            CheckHostConnection();\n            UpdateGameState();\n        }\n    }\n    \n    private void InitializeHostMigration()\n    {\n        _connectedClients = new List<string>();\n        _gameState = new GameStateData();\n        _clientPriorities = new Dictionary<string, float>();\n        _lastHeartbeatTime = Time.time;\n        _migrationAttempts = 0;\n        \n        DetermineHostStatus();\n        \n        if (_isHost)\n        {\n            StartHostHeartbeat();\n        }\n    }\n    \n    private void DetermineHostStatus()\n    {\n        _isHost = Network.isServer || (Network.connections.Length == 0);\n        _currentHostId = _isHost ? Network.player.ToString() : \"\";\n        \n        if (_isHost)\n        {\n            Debug.Log(\"This client is the host\");\n        }\n    }\n    \n    private void StartHostHeartbeat()\n    {\n        if (_heartbeatCoroutine != null)\n        {\n            StopCoroutine(_heartbeatCoroutine);\n        }\n        _heartbeatCoroutine = StartCoroutine(HostHeartbeatCoroutine());\n    }\n    \n    private IEnumerator HostHeartbeatCoroutine()\n    {\n        while (_isHost && !_isMigrating)\n        {\n            SendHeartbeat();\n            yield return new WaitForSeconds(_heartbeatInterval);\n        }\n    }\n    \n    private void SendHeartbeat()\n    {\n        if (!_isHost) return;\n        \n        // Simulate sending heartbeat to all clients\n        foreach (string clientId in _connectedClients)\n        {\n            // In a real implementation, this would send network messages\n            Debug.Log($\"Sending heartbeat to client: {clientId}\");\n        }\n        \n        _lastHeartbeatTime = Time.time;\n    }\n    \n    private void CheckHostConnection()\n    {\n        if (_isHost) return;\n        \n        float timeSinceLastHeartbeat = Time.time - _lastHeartbeatTime;\n        \n        if (timeSinceLastHeartbeat > _migrationTimeout && !_isMigrating)\n        {\n            Debug.Log(\"Host connection lost, initiating migration\");\n            OnHostDisconnected?.Invoke();\n            \n            if (_enableAutomaticMigration)\n            {\n                StartHostMigration();\n            }\n        }\n    }\n    \n    public void StartHostMigration()\n    {\n        if (_isMigrating) return;\n        \n        _isMigrating = true;\n        _migrationAttempts++;\n        \n        Debug.Log($\"Starting host migration (attempt {_migrationAttempts})\");\n        OnHostMigrationStarted?.Invoke(true);\n        \n        if (_migrationCoroutine != null)\n        {\n            StopCoroutine(_migrationCoroutine);\n        }\n        _migrationCoroutine = StartCoroutine(HostMigrationCoroutine());\n    }\n    \n    private IEnumerator HostMigrationCoroutine()\n    {\n        yield return new WaitForSeconds(1f); // Brief pause for network stabilization\n        \n        // Collect game state from all clients\n        yield return StartCoroutine(CollectGameStateCoroutine());\n        \n        // Determine new host based on priority\n        string newHostId = DetermineNewHost();\n        \n        if (newHostId == Network.player.ToString())\n        {\n            // This client becomes the new host\n            yield return StartCoroutine(BecomeNewHostCoroutine());\n        }\n        else\n        {\n            // Wait for new host to be established\n            yield return StartCoroutine(WaitForNewHostCoroutine(newHostId));\n        }\n        \n        CompleteMigration();\n    }\n    \n    private IEnumerator CollectGameStateCoroutine()\n    {\n        Debug.Log(\"Collecting game state from all clients\");\n        \n        // Simulate collecting game state\n        _gameState.gameTime = Time.time;\n        _gameState.gamePhase = 1;\n        \n        // Collect player data\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        _gameState.players.Clear();\n        \n        foreach (GameObject player in players)\n        {\n            if (player != null)\n            {\n                PlayerData playerData = new PlayerData(\n                    player.name,\n                    player.name,\n                    player.transform.position,\n                    player.transform.rotation,\n                    100f, // Default health\n                    0     // Default score\n                );\n                _gameState.players.Add(playerData);\n            }\n        }\n        \n        yield return new WaitForSeconds(0.5f);\n    }\n    \n    private string DetermineNewHost()\n    {\n        string newHostId = \"\";\n        float highestPriority = -1f;\n        \n        // Calculate priorities for all connected clients\n        foreach (string clientId in _connectedClients)\n        {\n            float priority = CalculateClientPriority(clientId);\n            _clientPriorities[clientId] = priority;\n            \n            if (priority > highestPriority)\n            {\n                highestPriority = priority;\n                newHostId = clientId;\n            }\n        }\n        \n        // Include self in consideration\n        string selfId = Network.player.ToString();\n        float selfPriority = CalculateClientPriority(selfId);\n        \n        if (selfPriority > highestPriority)\n        {\n            newHostId = selfId;\n        }\n        \n        Debug.Log($\"New host determined: {newHostId} with priority: {highestPriority}\");\n        return newHostId;\n    }\n    \n    private float CalculateClientPriority(string clientId)\n    {\n        float priority = 0f;\n        \n        // Base priority on connection stability\n        priority += Random.Range(0.5f, 1f);\n        \n        // Bonus for lower ping (simulated)\n        priority += Random.Range(0f, 0.3f);\n        \n        // Bonus for being the original host\n        if (clientId == _currentHostId)\n        {\n            priority += 0.2f;\n        }\n        \n        return priority;\n    }\n    \n    private IEnumerator BecomeNewHostCoroutine()\n    {\n        Debug.Log(\"Becoming new host\");\n        \n        _isHost = true;\n        _currentHostId = Network.player.ToString();\n        \n        // Restore game state\n        yield return StartCoroutine(RestoreGameStateCoroutine());\n        \n        // Notify all clients of new host\n        NotifyClientsOfNewHost();\n        \n        // Start host responsibilities\n        StartHostHeartbeat();\n        \n        OnBecameNewHost?.Invoke();\n        yield return null;\n    }\n    \n    private IEnumerator WaitForNewHostCoroutine(string newHostId)\n    {\n        Debug.Log($\"Waiting for new host: {newHostId}\");\n        \n        float waitTime = 0f;\n        bool hostEstablished = false;\n        \n        while (waitTime < _migrationTimeout && !hostEstablished)\n        {\n            // Check if new host is responding\n            hostEstablished = CheckNewHostResponse(newHostId);\n            \n            if (!hostEstablished)\n            {\n                yield return new WaitForSeconds(0.5f);\n                waitTime += 0.5f;\n            }\n        }\n        \n        if (!hostEstablished)\n        {\n            Debug.Log(\"New host failed to establish, retrying migration\");\n            if (_migrationAttempts < _maxMigrationAttempts)\n            {\n                yield return new WaitForSeconds(1f);\n                StartHostMigration();\n            }\n            else\n            {\n                OnMigrationFailed?.Invoke();\n            }\n        }\n        else\n        {\n            _currentHostId = newHostId;\n            _lastHeartbeatTime = Time.time;\n        }\n    }\n    \n    private bool CheckNewHostResponse(string hostId)\n    {\n        // Simulate checking for new host response\n        return Random.Range(0f, 1f) > 0.3f; // 70% chance of success\n    }\n    \n    private IEnumerator RestoreGameStateCoroutine()\n    {\n        Debug.Log(\"Restoring game state\");\n        \n        // Restore player positions and data\n        foreach (PlayerData playerData in _gameState.players)\n        {\n            GameObject player = GameObject.Find(playerData.playerId);\n            if (player != null)\n            {\n                player.transform.position = playerData.position;\n                player.transform.rotation = playerData.rotation;\n            }\n        }\n        \n        yield return new WaitForSeconds(0.2f);\n    }\n    \n    private void NotifyClientsOfNewHost()\n    {\n        Debug.Log(\"Notifying clients of new host\");\n        \n        // In a real implementation, this would send network messages\n        foreach (string clientId in _connectedClients)\n        {\n            Debug.Log($\"Notifying client {clientId} of new host\");\n        }\n    }\n    \n    private void CompleteMigration()\n    {\n        _isMigrating = false;\n        _migrationAttempts = 0;\n        \n        Debug.Log(\"Host migration completed successfully\");\n        OnHostMigrationCompleted?.Invoke(true);\n    }\n    \n    private void UpdateGameState()\n    {\n        if (!_isHost) return;\n        \n        _gameState.gameTime = Time.time;\n        \n        // Update player data\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        _gameState.players.Clear();\n        \n        foreach (GameObject player in players)\n        {\n            if (player != null)\n            {\n                PlayerData playerData = new PlayerData(\n                    player.name,\n                    player.name,\n                    player.transform.position,\n                    player.transform.rotation,\n                    100f,\n                    0\n                );\n                _gameState.players.Add(playerData);\n            }\n        }\n    }\n    \n    public void AddClient(string clientId)\n    {\n        if (!_connectedClients.Contains(clientId))\n        {\n            _connectedClients.Add(clientId);\n            Debug.Log($\"Client added: {clientId}\");\n        }\n    }\n    \n    public void RemoveClient(string clientId)\n    {\n        if (_connectedClients.Contains(clientId))\n        {\n            _connectedClients.Remove(clientId);\n            Debug.Log($\"Client removed: {clientId}\");\n            \n            if (clientId == _currentHostId && !_isMigrating)\n            {\n                OnHostDisconnected?.Invoke();\n                if (_enableAutomaticMigration)\n                {\n                    StartHostMigration();\n                }\n            }\n        }\n    }\n    \n    public void ForceHostMigration()\n    {\n        if (!_isMigrating)\n        {\n            StartHostMigration();\n        }\n    }\n    \n    public bool IsHost()\n    {\n        return _isHost;\n    }\n    \n    public bool IsMigrating()\n    {\n        return _isMigrating;\n    }\n    \n    public string GetCurrentHostId()\n    {\n        return _currentHostId;\n    }\n    \n    public GameStateData GetGameState()\n    {\n        return _gameState;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_heartbeatCoroutine != null)\n        {\n            StopCoroutine(_heartbeatCoroutine);\n        }\n        \n        if (_migrationCoroutine != null)\n        {\n            StopCoroutine(_migrationCoroutine);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "object that spins faster and faster while playing a sound that gets louder, and when it reaches maximum speed it explodes into 10 smaller pieces that each bounce around randomly while playing their own unique sound effects, and the original object's material color shifts from blue to red during the spin-up phase",
      "ideal_ir": {
        "class_name": "SpinningExploder",
        "components": [
          "Rigidbody",
          "AudioSource",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "spinAcceleration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "maxSpinSpeed",
            "type": "float",
            "default": 20.0
          },
          {
            "name": "currentSpinSpeed",
            "type": "float",
            "default": 0.0
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 500.0
          },
          {
            "name": "pieceCount",
            "type": "int",
            "default": 10
          },
          {
            "name": "piecePrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "explosionSounds",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "baseVolume",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "maxVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "startColor",
            "type": "Color",
            "default": "blue"
          },
          {
            "name": "endColor",
            "type": "Color",
            "default": "red"
          }
        ],
        "behaviors": [
          {
            "name": "continuous_spin_acceleration",
            "trigger": "every frame while spinning speed is below maximum",
            "actions": [
              {
                "action": "increase spinning speed by acceleration amount"
              },
              {
                "action": "rotate object around vertical axis at current spinning speed"
              }
            ]
          },
          {
            "name": "volume_increase_with_speed",
            "trigger": "every frame while spinning speed changes",
            "actions": [
              {
                "action": "calculate volume based on current speed relative to maximum speed"
              },
              {
                "action": "set audio source volume to calculated volume between base and maximum"
              }
            ]
          },
          {
            "name": "color_transition_during_spinup",
            "trigger": "every frame while spinning speed is below maximum",
            "actions": [
              {
                "action": "calculate color blend ratio based on current speed relative to maximum speed"
              },
              {
                "action": "blend material color from start color to end color using calculated ratio"
              }
            ]
          },
          {
            "name": "explode_at_maximum_speed",
            "trigger": "when spinning speed reaches or exceeds maximum speed",
            "actions": [
              {
                "action": "stop spinning and audio"
              },
              {
                "action": "create ten smaller piece objects at current position"
              },
              {
                "action": "apply random explosive force to each piece in different directions"
              },
              {
                "action": "assign unique random sound effect to each piece"
              },
              {
                "action": "destroy original object"
              }
            ]
          },
          {
            "name": "piece_bouncing_behavior",
            "trigger": "when piece object collides with any surface",
            "actions": [
              {
                "action": "bounce off surface with physics"
              },
              {
                "action": "play assigned unique sound effect"
              },
              {
                "action": "apply small random force for continued random movement"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class SpinningExploder : MonoBehaviour\n{\n    [Header(\"Spin Settings\")]\n    [SerializeField] private float _maxSpinSpeed = 1000f;\n    [SerializeField] private float _spinAcceleration = 50f;\n    [SerializeField] private float _timeToMaxSpeed = 5f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _spinSound;\n    [SerializeField] private float _maxVolume = 1f;\n    [SerializeField] private AudioClip[] _explosionSounds;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private int _fragmentCount = 10;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _fragmentLifetime = 5f;\n    [SerializeField] private GameObject _fragmentPrefab;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _startColor = Color.blue;\n    [SerializeField] private Color _endColor = Color.red;\n    \n    private float _currentSpinSpeed = 0f;\n    private float _spinTimer = 0f;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _material;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        SetupComponents();\n        StartSpinning();\n    }\n    \n    private void SetupComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _originalColor = _material.color;\n        }\n        \n        if (_fragmentPrefab == null)\n        {\n            _fragmentPrefab = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            _fragmentPrefab.transform.localScale = Vector3.one * 0.3f;\n        }\n    }\n    \n    private void StartSpinning()\n    {\n        if (_spinSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _spinSound;\n            _audioSource.loop = true;\n            _audioSource.volume = 0f;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasExploded) return;\n        \n        UpdateSpin();\n        UpdateAudio();\n        UpdateColor();\n        \n        if (_spinTimer >= _timeToMaxSpeed)\n        {\n            Explode();\n        }\n    }\n    \n    private void UpdateSpin()\n    {\n        _spinTimer += Time.deltaTime;\n        float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n        _currentSpinSpeed = Mathf.Lerp(0f, _maxSpinSpeed, progress * progress);\n        \n        transform.Rotate(0f, _currentSpinSpeed * Time.deltaTime, 0f);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _spinSound != null)\n        {\n            float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n            _audioSource.volume = Mathf.Lerp(0f, _maxVolume, progress);\n            _audioSource.pitch = Mathf.Lerp(0.5f, 2f, progress);\n        }\n    }\n    \n    private void UpdateColor()\n    {\n        if (_material != null)\n        {\n            float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n            Color currentColor = Color.Lerp(_startColor, _endColor, progress);\n            _material.color = currentColor;\n        }\n    }\n    \n    private void Explode()\n    {\n        _hasExploded = true;\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        CreateFragments();\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.enabled = false;\n        }\n        \n        StartCoroutine(DestroyAfterDelay(1f));\n    }\n    \n    private void CreateFragments()\n    {\n        for (int i = 0; i < _fragmentCount; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere.normalized;\n            Vector3 spawnPosition = transform.position + randomDirection * 0.5f;\n            \n            GameObject fragment = Instantiate(_fragmentPrefab, spawnPosition, Random.rotation);\n            \n            SetupFragment(fragment, randomDirection, i);\n        }\n    }\n    \n    private void SetupFragment(GameObject fragment, Vector3 direction, int index)\n    {\n        Rigidbody rb = fragment.GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            rb = fragment.AddComponent<Rigidbody>();\n        }\n        \n        rb.AddForce(direction * _explosionForce);\n        rb.AddTorque(Random.insideUnitSphere * _explosionForce * 0.1f);\n        \n        AudioSource fragmentAudio = fragment.GetComponent<AudioSource>();\n        if (fragmentAudio == null)\n        {\n            fragmentAudio = fragment.AddComponent<AudioSource>();\n        }\n        \n        if (_explosionSounds != null && _explosionSounds.Length > 0)\n        {\n            int soundIndex = index % _explosionSounds.Length;\n            if (_explosionSounds[soundIndex] != null)\n            {\n                fragmentAudio.clip = _explosionSounds[soundIndex];\n                fragmentAudio.volume = Random.Range(0.3f, 0.8f);\n                fragmentAudio.pitch = Random.Range(0.8f, 1.5f);\n                fragmentAudio.Play();\n            }\n        }\n        \n        FragmentBehavior fragmentBehavior = fragment.AddComponent<FragmentBehavior>();\n        fragmentBehavior.Initialize(_fragmentLifetime);\n        \n        Renderer fragmentRenderer = fragment.GetComponent<Renderer>();\n        if (fragmentRenderer != null)\n        {\n            fragmentRenderer.material.color = Random.ColorHSV();\n        }\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_material != null)\n        {\n            Destroy(_material);\n        }\n    }\n}\n\npublic class FragmentBehavior : MonoBehaviour\n{\n    private float _lifetime;\n    private float _timer;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    \n    public void Initialize(float lifetime)\n    {\n        _lifetime = lifetime;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.drag = 0.5f;\n            _rigidbody.angularDrag = 0.5f;\n        }\n    }\n    \n    private void Update()\n    {\n        _timer += Time.deltaTime;\n        \n        if (_timer >= _lifetime)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        \n        float fadeProgress = _timer / _lifetime;\n        if (fadeProgress > 0.7f)\n        {\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Color color = renderer.material.color;\n                color.a = Mathf.Lerp(1f, 0f, (fadeProgress - 0.7f) / 0.3f);\n                renderer.material.color = color;\n            }\n            \n            if (_audioSource != null)\n            {\n                _audioSource.volume = Mathf.Lerp(_audioSource.volume, 0f, Time.deltaTime * 2f);\n            }\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n            _rigidbody.velocity = bounceDirection * _rigidbody.velocity.magnitude * 0.8f;\n        }\n        \n        if (_audioSource != null && _audioSource.clip != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.5f);\n            _audioSource.PlayOneShot(_audioSource.clip, 0.5f);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "gravity well that pulls nearby rigidbodies toward it with increasing force based on distance, plays a low-frequency rumble that gets louder as objects get closer, changes the light intensity based on how many objects are currently being pulled, and creates particle effects at the point where objects collide with the center",
      "ideal_ir": {
        "class_name": "GravityWell",
        "components": [
          "Rigidbody",
          "SphereCollider",
          "AudioSource",
          "Light",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "pullForce",
            "type": "float",
            "default": 100
          },
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 20
          },
          {
            "name": "baseRumbleVolume",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "maxRumbleVolume",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "baseLightIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "lightIntensityMultiplier",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "collisionParticleCount",
            "type": "int",
            "default": 50
          }
        ],
        "behaviors": [
          {
            "name": "pull_nearby_rigidbodies",
            "trigger": "when rigidbody objects are within detection radius",
            "actions": [
              {
                "action": "apply force toward gravity well center with strength inversely proportional to distance"
              },
              {
                "action": "increase force strength as objects get closer to center"
              }
            ]
          },
          {
            "name": "adjust_rumble_volume",
            "trigger": "when objects are being pulled by gravity well",
            "actions": [
              {
                "action": "calculate average distance of all pulled objects"
              },
              {
                "action": "increase rumble volume as average distance decreases"
              },
              {
                "action": "play low frequency rumble sound at calculated volume level"
              }
            ]
          },
          {
            "name": "modify_light_intensity",
            "trigger": "when number of objects being pulled changes",
            "actions": [
              {
                "action": "count total number of objects currently being affected"
              },
              {
                "action": "increase light intensity based on object count using multiplier"
              },
              {
                "action": "set light intensity to base value plus calculated bonus"
              }
            ]
          },
          {
            "name": "create_collision_particles",
            "trigger": "when rigidbody object collides with gravity well center",
            "actions": [
              {
                "action": "spawn particle effect at collision point"
              },
              {
                "action": "emit specified number of particles in burst pattern"
              },
              {
                "action": "orient particles to spread outward from collision location"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class GravityWell : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _gravitationalForce = 100f;\n    [SerializeField] private float _maxRange = 20f;\n    [SerializeField] private AnimationCurve _forceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rumbleClip;\n    [SerializeField] private float _baseVolume = 0.1f;\n    [SerializeField] private float _maxVolume = 0.8f;\n    [SerializeField] private float _basePitch = 0.5f;\n    [SerializeField] private float _maxPitch = 1.2f;\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _wellLight;\n    [SerializeField] private float _baseLightIntensity = 1f;\n    [SerializeField] private float _intensityPerObject = 0.5f;\n    [SerializeField] private float _maxLightIntensity = 10f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _collisionParticles;\n    [SerializeField] private float _collisionThreshold = 2f;\n    [SerializeField] private float _particleEmissionRate = 50f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _centerPoint;\n    [SerializeField] private bool _showGizmos = true;\n    \n    private List<Rigidbody> _affectedBodies = new List<Rigidbody>();\n    private Dictionary<Rigidbody, float> _lastDistances = new Dictionary<Rigidbody, float>();\n    private Collider[] _nearbyColliders = new Collider[50];\n    private float _currentAverageDistance = 0f;\n    \n    private void Start()\n    {\n        if (_centerPoint == null)\n            _centerPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        SetupAudioSource();\n        \n        if (_wellLight == null)\n            _wellLight = GetComponent<Light>();\n            \n        if (_collisionParticles == null)\n            _collisionParticles = GetComponentInChildren<ParticleSystem>();\n            \n        SetupParticleSystem();\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource.clip = _rumbleClip;\n        _audioSource.loop = true;\n        _audioSource.volume = 0f;\n        _audioSource.pitch = _basePitch;\n        _audioSource.spatialBlend = 1f;\n        _audioSource.rolloffMode = AudioRolloffMode.Logarithmic;\n        _audioSource.maxDistance = _maxRange * 2f;\n        \n        if (_rumbleClip != null)\n            _audioSource.Play();\n    }\n    \n    private void SetupParticleSystem()\n    {\n        if (_collisionParticles != null)\n        {\n            var emission = _collisionParticles.emission;\n            emission.enabled = false;\n            \n            var shape = _collisionParticles.shape;\n            shape.shapeType = ParticleSystemShapeType.Sphere;\n            shape.radius = 0.5f;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        UpdateAffectedBodies();\n        ApplyGravitationalForces();\n        UpdateAudioEffects();\n        UpdateLightIntensity();\n        CheckForCollisions();\n    }\n    \n    private void UpdateAffectedBodies()\n    {\n        _affectedBodies.Clear();\n        \n        int numColliders = Physics.OverlapSphereNonAlloc(\n            _centerPoint.position, \n            _maxRange, \n            _nearbyColliders, \n            _affectedLayers\n        );\n        \n        for (int i = 0; i < numColliders; i++)\n        {\n            Rigidbody rb = _nearbyColliders[i].GetComponent<Rigidbody>();\n            if (rb != null && rb.gameObject != gameObject)\n            {\n                _affectedBodies.Add(rb);\n            }\n        }\n    }\n    \n    private void ApplyGravitationalForces()\n    {\n        float totalDistance = 0f;\n        int validBodies = 0;\n        \n        foreach (Rigidbody rb in _affectedBodies)\n        {\n            if (rb == null) continue;\n            \n            Vector3 direction = _centerPoint.position - rb.position;\n            float distance = direction.magnitude;\n            \n            if (distance > _maxRange) continue;\n            \n            float normalizedDistance = distance / _maxRange;\n            float forceMultiplier = _forceCurve.Evaluate(1f - normalizedDistance);\n            \n            Vector3 force = direction.normalized * (_gravitationalForce * forceMultiplier * rb.mass);\n            rb.AddForce(force, ForceMode.Force);\n            \n            _lastDistances[rb] = distance;\n            totalDistance += distance;\n            validBodies++;\n        }\n        \n        _currentAverageDistance = validBodies > 0 ? totalDistance / validBodies : _maxRange;\n    }\n    \n    private void UpdateAudioEffects()\n    {\n        if (_audioSource == null || _rumbleClip == null) return;\n        \n        int objectCount = _affectedBodies.Count;\n        \n        if (objectCount > 0)\n        {\n            float normalizedDistance = Mathf.Clamp01(_currentAverageDistance / _maxRange);\n            float volumeMultiplier = 1f - normalizedDistance;\n            \n            float targetVolume = Mathf.Lerp(_baseVolume, _maxVolume, volumeMultiplier);\n            targetVolume *= Mathf.Clamp01(objectCount / 5f);\n            \n            float targetPitch = Mathf.Lerp(_basePitch, _maxPitch, volumeMultiplier);\n            \n            _audioSource.volume = Mathf.Lerp(_audioSource.volume, targetVolume, Time.fixedDeltaTime * 2f);\n            _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, targetPitch, Time.fixedDeltaTime * 2f);\n        }\n        else\n        {\n            _audioSource.volume = Mathf.Lerp(_audioSource.volume, 0f, Time.fixedDeltaTime * 3f);\n            _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, _basePitch, Time.fixedDeltaTime * 2f);\n        }\n    }\n    \n    private void UpdateLightIntensity()\n    {\n        if (_wellLight == null) return;\n        \n        float targetIntensity = _baseLightIntensity + (_affectedBodies.Count * _intensityPerObject);\n        targetIntensity = Mathf.Clamp(targetIntensity, _baseLightIntensity, _maxLightIntensity);\n        \n        _wellLight.intensity = Mathf.Lerp(_wellLight.intensity, targetIntensity, Time.fixedDeltaTime * 2f);\n    }\n    \n    private void CheckForCollisions()\n    {\n        foreach (Rigidbody rb in _affectedBodies)\n        {\n            if (rb == null) continue;\n            \n            float distance = Vector3.Distance(rb.position, _centerPoint.position);\n            \n            if (distance <= _collisionThreshold)\n            {\n                TriggerCollisionEffect(rb.position);\n            }\n        }\n    }\n    \n    private void TriggerCollisionEffect(Vector3 collisionPoint)\n    {\n        if (_collisionParticles == null) return;\n        \n        _collisionParticles.transform.position = collisionPoint;\n        \n        var emission = _collisionParticles.emission;\n        emission.enabled = true;\n        \n        var emissionRate = _collisionParticles.emission;\n        emissionRate.rateOverTime = _particleEmissionRate;\n        \n        _collisionParticles.Emit((int)(_particleEmissionRate * Time.fixedDeltaTime));\n        \n        Invoke(nameof(StopParticleEmission), 0.1f);\n    }\n    \n    private void StopParticleEmission()\n    {\n        if (_collisionParticles != null)\n        {\n            var emission = _collisionParticles.emission;\n            emission.enabled = false;\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Vector3 center = _centerPoint != null ? _centerPoint.position : transform.position;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(center, _maxRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, _collisionThreshold);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(center, 0.2f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (!_showGizmos) return;\n        \n        Vector3 center = _centerPoint != null ? _centerPoint.position : transform.position;\n        \n        Gizmos.color = new Color(1f, 1f, 0f, 0.1f);\n        Gizmos.DrawSphere(center, _maxRange);\n        \n        Gizmos.color = new Color(1f, 0f, 0f, 0.2f);\n        Gizmos.DrawSphere(center, _collisionThreshold);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "object that becomes a musical instrument - when you collide with it, it plays a note based on where you hit it (top plays high notes, bottom plays low notes), the object's color shifts to match the note's frequency, it vibrates with the sound, and leaves a trail of particles that fade out",
      "ideal_ir": {
        "class_name": "MusicalInstrumentObject",
        "components": [
          "Collider",
          "AudioSource",
          "Renderer",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "highNote",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "midNote",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "lowNote",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "vibrationIntensity",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "vibrationDuration",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "colorShiftSpeed",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "particleCount",
            "type": "int",
            "default": 20
          },
          {
            "name": "particleFadeTime",
            "type": "float",
            "default": 1.0
          }
        ],
        "behaviors": [
          {
            "name": "play_note_on_collision",
            "trigger": "when another object collides with this object",
            "actions": [
              {
                "action": "determine collision point height relative to object bounds"
              },
              {
                "action": "play high note if collision is in upper third of object"
              },
              {
                "action": "play mid note if collision is in middle third of object"
              },
              {
                "action": "play low note if collision is in lower third of object"
              }
            ]
          },
          {
            "name": "change_color_with_note",
            "trigger": "when a note starts playing",
            "actions": [
              {
                "action": "shift object color to red if high note is playing"
              },
              {
                "action": "shift object color to yellow if mid note is playing"
              },
              {
                "action": "shift object color to blue if low note is playing"
              },
              {
                "action": "smoothly transition color over time"
              }
            ]
          },
          {
            "name": "vibrate_with_sound",
            "trigger": "when a note starts playing",
            "actions": [
              {
                "action": "shake object position randomly with vibration intensity"
              },
              {
                "action": "gradually reduce vibration over vibration duration"
              },
              {
                "action": "return to original position when vibration ends"
              }
            ]
          },
          {
            "name": "emit_particle_trail",
            "trigger": "when a note starts playing",
            "actions": [
              {
                "action": "spawn particles at collision point"
              },
              {
                "action": "set particle color to match current object color"
              },
              {
                "action": "make particles move outward from collision point"
              },
              {
                "action": "fade particles out over particle fade time"
              }
            ]
          },
          {
            "name": "reset_appearance",
            "trigger": "when note finishes playing and vibration stops",
            "actions": [
              {
                "action": "gradually return object color to original color"
              },
              {
                "action": "ensure object is at rest position"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class MusicalInstrument : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _baseFrequency = 220f;\n    [SerializeField] private float _frequencyRange = 880f;\n    [SerializeField] private float _noteDuration = 1f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _objectRenderer;\n    [SerializeField] private Color _lowNoteColor = Color.red;\n    [SerializeField] private Color _highNoteColor = Color.blue;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Vibration Settings\")]\n    [SerializeField] private float _vibrationIntensity = 0.1f;\n    [SerializeField] private float _vibrationFrequency = 20f;\n    [SerializeField] private AnimationCurve _vibrationCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Particle Settings\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private int _particleCount = 50;\n    [SerializeField] private float _particleLifetime = 2f;\n    [SerializeField] private float _particleSpeed = 5f;\n    [SerializeField] private Gradient _particleColorGradient;\n    \n    private Collider _collider;\n    private Vector3 _originalPosition;\n    private Color _originalColor;\n    private Color _targetColor;\n    private float _currentColorLerp = 0f;\n    private bool _isPlaying = false;\n    private Coroutine _playNoteCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupAudioSource();\n        SetupParticleSystem();\n        _originalPosition = transform.position;\n        _originalColor = _objectRenderer.material.color;\n        _targetColor = _originalColor;\n    }\n    \n    private void InitializeComponents()\n    {\n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        if (_objectRenderer == null)\n            _objectRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_particleSystem == null)\n        {\n            GameObject particleObj = new GameObject(\"ParticleSystem\");\n            particleObj.transform.SetParent(transform);\n            particleObj.transform.localPosition = Vector3.zero;\n            _particleSystem = particleObj.AddComponent<ParticleSystem>();\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource.clip = null;\n        _audioSource.loop = false;\n        _audioSource.playOnAwake = false;\n        _audioSource.volume = 0.5f;\n    }\n    \n    private void SetupParticleSystem()\n    {\n        var main = _particleSystem.main;\n        main.startLifetime = _particleLifetime;\n        main.startSpeed = _particleSpeed;\n        main.maxParticles = _particleCount;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Sphere;\n        shape.radius = 0.5f;\n        \n        var colorOverLifetime = _particleSystem.colorOverLifetime;\n        colorOverLifetime.enabled = true;\n        if (_particleColorGradient == null)\n        {\n            _particleColorGradient = new Gradient();\n            _particleColorGradient.SetKeys(\n                new GradientColorKey[] { new GradientColorKey(Color.white, 0.0f), new GradientColorKey(Color.white, 1.0f) },\n                new GradientAlphaKey[] { new GradientAlphaKey(1.0f, 0.0f), new GradientAlphaKey(0.0f, 1.0f) }\n            );\n        }\n        colorOverLifetime.color = _particleColorGradient;\n    }\n    \n    private void Update()\n    {\n        UpdateColorTransition();\n    }\n    \n    private void UpdateColorTransition()\n    {\n        if (_currentColorLerp > 0f)\n        {\n            _currentColorLerp -= Time.deltaTime * _colorTransitionSpeed;\n            _currentColorLerp = Mathf.Max(0f, _currentColorLerp);\n            \n            Color currentColor = Color.Lerp(_originalColor, _targetColor, _currentColorLerp);\n            _objectRenderer.material.color = currentColor;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Vector3 hitPoint = other.ClosestPoint(transform.position);\n            PlayNoteAtPosition(hitPoint);\n        }\n    }\n    \n    private void PlayNoteAtPosition(Vector3 hitPosition)\n    {\n        if (_isPlaying)\n        {\n            if (_playNoteCoroutine != null)\n                StopCoroutine(_playNoteCoroutine);\n        }\n        \n        float normalizedHeight = CalculateNormalizedHeight(hitPosition);\n        float frequency = _baseFrequency + (normalizedHeight * _frequencyRange);\n        \n        _playNoteCoroutine = StartCoroutine(PlayNoteCoroutine(frequency, normalizedHeight));\n    }\n    \n    private float CalculateNormalizedHeight(Vector3 hitPosition)\n    {\n        Bounds bounds = _collider.bounds;\n        float relativeY = hitPosition.y - bounds.min.y;\n        float normalizedHeight = relativeY / bounds.size.y;\n        return Mathf.Clamp01(normalizedHeight);\n    }\n    \n    private IEnumerator PlayNoteCoroutine(float frequency, float normalizedHeight)\n    {\n        _isPlaying = true;\n        \n        // Set color based on frequency\n        _targetColor = Color.Lerp(_lowNoteColor, _highNoteColor, normalizedHeight);\n        _currentColorLerp = 1f;\n        \n        // Generate and play audio\n        AudioClip noteClip = GenerateTone(frequency, _noteDuration);\n        _audioSource.clip = noteClip;\n        _audioSource.Play();\n        \n        // Emit particles\n        EmitParticles(normalizedHeight);\n        \n        // Start vibration\n        StartCoroutine(VibrateObject());\n        \n        yield return new WaitForSeconds(_noteDuration);\n        \n        _isPlaying = false;\n        \n        // Cleanup\n        if (noteClip != null)\n            DestroyImmediate(noteClip);\n    }\n    \n    private AudioClip GenerateTone(float frequency, float duration)\n    {\n        int sampleRate = 44100;\n        int sampleCount = Mathf.RoundToInt(sampleRate * duration);\n        float[] samples = new float[sampleCount];\n        \n        for (int i = 0; i < sampleCount; i++)\n        {\n            float time = (float)i / sampleRate;\n            float volume = _volumeCurve.Evaluate(time / duration);\n            samples[i] = Mathf.Sin(2 * Mathf.PI * frequency * time) * volume;\n        }\n        \n        AudioClip clip = AudioClip.Create(\"GeneratedTone\", sampleCount, 1, sampleRate, false);\n        clip.SetData(samples, 0);\n        return clip;\n    }\n    \n    private void EmitParticles(float normalizedHeight)\n    {\n        var emission = _particleSystem.emission;\n        emission.enabled = true;\n        \n        // Update particle color based on note\n        var main = _particleSystem.main;\n        Color particleColor = Color.Lerp(_lowNoteColor, _highNoteColor, normalizedHeight);\n        main.startColor = particleColor;\n        \n        // Emit burst\n        _particleSystem.Emit(_particleCount);\n        \n        StartCoroutine(DisableEmissionAfterDelay());\n    }\n    \n    private IEnumerator DisableEmissionAfterDelay()\n    {\n        yield return new WaitForSeconds(0.1f);\n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n    }\n    \n    private IEnumerator VibrateObject()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _noteDuration)\n        {\n            float normalizedTime = elapsedTime / _noteDuration;\n            float vibrationAmount = _vibrationCurve.Evaluate(normalizedTime) * _vibrationIntensity;\n            \n            Vector3 randomOffset = new Vector3(\n                Mathf.Sin(Time.time * _vibrationFrequency) * vibrationAmount,\n                Mathf.Cos(Time.time * _vibrationFrequency * 1.1f) * vibrationAmount,\n                Mathf.Sin(Time.time * _vibrationFrequency * 0.9f) * vibrationAmount\n            );\n            \n            transform.position = _originalPosition + randomOffset;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_playNoteCoroutine != null)\n            StopCoroutine(_playNoteCoroutine);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "creature with 5 states: idle (sits still, plays ambient breathing), curious (slowly approaches player if within 10 units, plays questioning sound), scared (runs away from player, plays panic sound, color turns red), aggressive (chases player, plays roar, color turns dark), and exhausted (stops moving, plays tired sound, color fades to gray)",
      "ideal_ir": {
        "class_name": "CreatureStateMachine",
        "components": [
          "AudioSource",
          "Renderer"
        ],
        "fields": [
          {
            "name": "currentState",
            "type": "string",
            "default": "idle"
          },
          {
            "name": "detectionRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "walkSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "runSpeed",
            "type": "float",
            "default": 6
          },
          {
            "name": "chaseSpeed",
            "type": "float",
            "default": 8
          },
          {
            "name": "energy",
            "type": "float",
            "default": 100
          },
          {
            "name": "fearThreshold",
            "type": "float",
            "default": 30
          },
          {
            "name": "aggressionThreshold",
            "type": "float",
            "default": 70
          },
          {
            "name": "exhaustionThreshold",
            "type": "float",
            "default": 10
          },
          {
            "name": "breathingSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "questioningSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "panicSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "roarSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "tiredSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "normalColor",
            "type": "Color",
            "default": "white"
          },
          {
            "name": "redColor",
            "type": "Color",
            "default": "red"
          },
          {
            "name": "darkColor",
            "type": "Color",
            "default": "black"
          },
          {
            "name": "grayColor",
            "type": "Color",
            "default": "gray"
          }
        ],
        "behaviors": [
          {
            "name": "idle_behavior",
            "trigger": "when current state is idle",
            "actions": [
              {
                "action": "remain stationary"
              },
              {
                "action": "play breathing sound on loop"
              },
              {
                "action": "set color to normal color"
              }
            ]
          },
          {
            "name": "transition_to_curious",
            "trigger": "when current state is idle and player is within detection range and energy is above exhaustion threshold",
            "actions": [
              {
                "action": "change current state to curious"
              },
              {
                "action": "stop breathing sound"
              },
              {
                "action": "play questioning sound"
              }
            ]
          },
          {
            "name": "curious_behavior",
            "trigger": "when current state is curious",
            "actions": [
              {
                "action": "slowly move toward player at walk speed"
              },
              {
                "action": "decrease energy gradually"
              }
            ]
          },
          {
            "name": "transition_to_scared",
            "trigger": "when current state is curious and energy is below fear threshold",
            "actions": [
              {
                "action": "change current state to scared"
              },
              {
                "action": "play panic sound"
              },
              {
                "action": "set color to red color"
              }
            ]
          },
          {
            "name": "scared_behavior",
            "trigger": "when current state is scared",
            "actions": [
              {
                "action": "run away from player at run speed"
              },
              {
                "action": "decrease energy rapidly"
              }
            ]
          },
          {
            "name": "transition_to_aggressive",
            "trigger": "when current state is curious and energy is above aggression threshold",
            "actions": [
              {
                "action": "change current state to aggressive"
              },
              {
                "action": "play roar sound"
              },
              {
                "action": "set color to dark color"
              }
            ]
          },
          {
            "name": "aggressive_behavior",
            "trigger": "when current state is aggressive",
            "actions": [
              {
                "action": "chase player at chase speed"
              },
              {
                "action": "decrease energy rapidly"
              }
            ]
          },
          {
            "name": "transition_to_exhausted",
            "trigger": "when energy falls below exhaustion threshold",
            "actions": [
              {
                "action": "change current state to exhausted"
              },
              {
                "action": "stop all movement"
              },
              {
                "action": "play tired sound"
              },
              {
                "action": "set color to gray color"
              }
            ]
          },
          {
            "name": "exhausted_behavior",
            "trigger": "when current state is exhausted",
            "actions": [
              {
                "action": "remain completely still"
              },
              {
                "action": "slowly recover energy over time"
              }
            ]
          },
          {
            "name": "recover_from_exhaustion",
            "trigger": "when current state is exhausted and energy is above fear threshold",
            "actions": [
              {
                "action": "change current state to idle"
              },
              {
                "action": "set color to normal color"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class CreatureStateMachine : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _scareRange = 5f;\n    [SerializeField] private float _aggressionRange = 3f;\n    [SerializeField] private LayerMask _playerLayerMask = -1;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _curiousSpeed = 2f;\n    [SerializeField] private float _scaredSpeed = 8f;\n    [SerializeField] private float _aggressiveSpeed = 6f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    \n    [Header(\"State Duration Settings\")]\n    [SerializeField] private float _curiousStateDuration = 5f;\n    [SerializeField] private float _scaredStateDuration = 3f;\n    [SerializeField] private float _aggressiveStateDuration = 8f;\n    [SerializeField] private float _exhaustedStateDuration = 4f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _questioningSound;\n    [SerializeField] private AudioClip _panicSound;\n    [SerializeField] private AudioClip _roarSound;\n    [SerializeField] private AudioClip _tiredSound;\n    [SerializeField] private float _ambientBreathingInterval = 3f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _creatureRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _scaredColor = Color.red;\n    [SerializeField] private Color _aggressiveColor = Color.black;\n    [SerializeField] private Color _exhaustedColor = Color.gray;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStateChanged;\n    public UnityEvent<CreatureState> OnSpecificStateEntered;\n    \n    public enum CreatureState\n    {\n        Idle,\n        Curious,\n        Scared,\n        Aggressive,\n        Exhausted\n    }\n    \n    private CreatureState _currentState = CreatureState.Idle;\n    private Transform _player;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Vector3 _initialPosition;\n    private float _stateTimer;\n    private float _breathingTimer;\n    private Color _targetColor;\n    private Color _currentColor;\n    private bool _hasPlayedStateSound;\n    \n    public CreatureState CurrentState => _currentState;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_creatureRenderer == null)\n        {\n            _creatureRenderer = GetComponent<Renderer>();\n        }\n        \n        _initialPosition = transform.position;\n        _targetColor = _normalColor;\n        _currentColor = _normalColor;\n        \n        if (_creatureRenderer != null)\n        {\n            _creatureRenderer.material.color = _currentColor;\n        }\n        \n        FindPlayer();\n        ChangeState(CreatureState.Idle);\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n        }\n        \n        UpdateStateLogic();\n        UpdateVisuals();\n        UpdateAudio();\n        \n        _stateTimer += Time.deltaTime;\n        _breathingTimer += Time.deltaTime;\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateStateLogic()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        switch (_currentState)\n        {\n            case CreatureState.Idle:\n                HandleIdleState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Curious:\n                HandleCuriousState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Scared:\n                HandleScaredState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Aggressive:\n                HandleAggressiveState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Exhausted:\n                HandleExhaustedState();\n                break;\n        }\n    }\n    \n    void HandleIdleState(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _detectionRange && distanceToPlayer > _scareRange)\n        {\n            ChangeState(CreatureState.Curious);\n        }\n        else if (distanceToPlayer <= _scareRange && distanceToPlayer > _aggressionRange)\n        {\n            ChangeState(CreatureState.Scared);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n    }\n    \n    void HandleCuriousState(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _scareRange && distanceToPlayer > _aggressionRange)\n        {\n            ChangeState(CreatureState.Scared);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n        else if (distanceToPlayer > _detectionRange || _stateTimer >= _curiousStateDuration)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n        else\n        {\n            MoveTowardsPlayer(_curiousSpeed);\n        }\n    }\n    \n    void HandleScaredState(float distanceToPlayer)\n    {\n        if (_stateTimer >= _scaredStateDuration)\n        {\n            ChangeState(CreatureState.Exhausted);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n        else\n        {\n            MoveAwayFromPlayer(_scaredSpeed);\n        }\n    }\n    \n    void HandleAggressiveState(float distanceToPlayer)\n    {\n        if (_stateTimer >= _aggressiveStateDuration)\n        {\n            ChangeState(CreatureState.Exhausted);\n        }\n        else if (distanceToPlayer > _detectionRange)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n        else\n        {\n            MoveTowardsPlayer(_aggressiveSpeed);\n        }\n    }\n    \n    void HandleExhaustedState()\n    {\n        if (_stateTimer >= _exhaustedStateDuration)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n    }\n    \n    void MoveTowardsPlayer(float speed)\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void MoveAwayFromPlayer(float speed)\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (transform.position - _player.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_creatureRenderer == null) return;\n        \n        _currentColor = Color.Lerp(_currentColor, _targetColor, _colorTransitionSpeed * Time.deltaTime);\n        _creatureRenderer.material.color = _currentColor;\n    }\n    \n    void UpdateAudio()\n    {\n        if (_currentState == CreatureState.Idle && _breathingTimer >= _ambientBreathingInterval)\n        {\n            PlaySound(_breathingSound);\n            _breathingTimer = 0f;\n        }\n    }\n    \n    void ChangeState(CreatureState newState)\n    {\n        if (_currentState == newState) return;\n        \n        _currentState = newState;\n        _stateTimer = 0f;\n        _hasPlayedStateSound = false;\n        \n        switch (newState)\n        {\n            case CreatureState.Idle:\n                _targetColor = _normalColor;\n                _rigidbody.velocity = Vector3.zero;\n                break;\n                \n            case CreatureState.Curious:\n                _targetColor = _normalColor;\n                PlaySound(_questioningSound);\n                break;\n                \n            case CreatureState.Scared:\n                _targetColor = _scaredColor;\n                PlaySound(_panicSound);\n                break;\n                \n            case CreatureState.Aggressive:\n                _targetColor = _aggressiveColor;\n                PlaySound(_roarSound);\n                break;\n                \n            case CreatureState.Exhausted:\n                _targetColor = _exhaustedColor;\n                _rigidbody.velocity = Vector3.zero;\n                PlaySound(_tiredSound);\n                break;\n        }\n        \n        OnStateChanged?.Invoke();\n        OnSpecificStateEntered?.Invoke(newState);\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.orange;\n        Gizmos.DrawWireSphere(transform.position, _scareRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _aggressionRange);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "door with locked, unlocking, open, and closing states - when locked it shakes slightly, when unlocking it plays key-turning sound for 3 seconds, when open it stays for 10 seconds then auto-closes, the door's material emission color changes with each state",
      "ideal_ir": {
        "class_name": "StatefulDoor",
        "components": [
          "Renderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "isLocked",
            "type": "bool",
            "default": true
          },
          {
            "name": "isUnlocking",
            "type": "bool",
            "default": false
          },
          {
            "name": "isOpen",
            "type": "bool",
            "default": false
          },
          {
            "name": "isClosing",
            "type": "bool",
            "default": false
          },
          {
            "name": "shakeIntensity",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "unlockDuration",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "openDuration",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "unlockTimer",
            "type": "float",
            "default": 0
          },
          {
            "name": "openTimer",
            "type": "float",
            "default": 0
          },
          {
            "name": "lockedColor",
            "type": "Color",
            "default": "red"
          },
          {
            "name": "unlockingColor",
            "type": "Color",
            "default": "yellow"
          },
          {
            "name": "openColor",
            "type": "Color",
            "default": "green"
          },
          {
            "name": "closingColor",
            "type": "Color",
            "default": "blue"
          }
        ],
        "behaviors": [
          {
            "name": "shake_when_locked",
            "trigger": "when door is in locked state",
            "actions": [
              {
                "action": "shake door slightly with random small movements"
              },
              {
                "action": "set material emission color to red"
              }
            ]
          },
          {
            "name": "start_unlocking",
            "trigger": "when unlock key is used on locked door",
            "actions": [
              {
                "action": "set door state to unlocking"
              },
              {
                "action": "play key turning sound"
              },
              {
                "action": "set material emission color to yellow"
              },
              {
                "action": "start unlock timer"
              }
            ]
          },
          {
            "name": "complete_unlocking",
            "trigger": "when unlock timer reaches three seconds",
            "actions": [
              {
                "action": "set door state to open"
              },
              {
                "action": "stop key turning sound"
              },
              {
                "action": "rotate door to open position"
              },
              {
                "action": "set material emission color to green"
              },
              {
                "action": "start open timer"
              }
            ]
          },
          {
            "name": "auto_close_door",
            "trigger": "when open timer reaches ten seconds",
            "actions": [
              {
                "action": "set door state to closing"
              },
              {
                "action": "set material emission color to blue"
              },
              {
                "action": "rotate door back to closed position"
              }
            ]
          },
          {
            "name": "finish_closing",
            "trigger": "when door rotation reaches closed position",
            "actions": [
              {
                "action": "set door state to locked"
              },
              {
                "action": "reset all timers"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Door : MonoBehaviour\n{\n    public enum DoorState\n    {\n        Locked,\n        Unlocking,\n        Open,\n        Closing\n    }\n\n    [Header(\"Door Settings\")]\n    [SerializeField] private DoorState _currentState = DoorState.Locked;\n    [SerializeField] private float _unlockDuration = 3f;\n    [SerializeField] private float _openDuration = 10f;\n    [SerializeField] private float _openAngle = 90f;\n    [SerializeField] private float _openSpeed = 2f;\n\n    [Header(\"Shake Settings\")]\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeSpeed = 10f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _unlockingSound;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _doorRenderer;\n    [SerializeField] private string _emissionProperty = \"_EmissionColor\";\n    [SerializeField] private Color _lockedColor = Color.red;\n    [SerializeField] private Color _unlockingColor = Color.yellow;\n    [SerializeField] private Color _openColor = Color.green;\n    [SerializeField] private Color _closingColor = Color.blue;\n\n    [Header(\"Events\")]\n    public UnityEvent OnDoorUnlocked;\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorClosed;\n\n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private Quaternion _openRotation;\n    private Material _doorMaterial;\n    private Coroutine _currentStateCoroutine;\n    private bool _isPlayerNear = false;\n\n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        _openRotation = _originalRotation * Quaternion.Euler(0, _openAngle, 0);\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_doorRenderer == null)\n            _doorRenderer = GetComponent<Renderer>();\n\n        if (_doorRenderer != null)\n        {\n            _doorMaterial = _doorRenderer.material;\n            UpdateEmissionColor();\n        }\n\n        SetState(_currentState);\n    }\n\n    private void Update()\n    {\n        if (_currentState == DoorState.Locked)\n        {\n            ApplyShake();\n        }\n\n        if (_isPlayerNear && Input.GetKeyDown(KeyCode.E))\n        {\n            TryInteract();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerNear = true;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerNear = false;\n        }\n    }\n\n    public void TryInteract()\n    {\n        if (_currentState == DoorState.Locked)\n        {\n            SetState(DoorState.Unlocking);\n        }\n    }\n\n    public void SetState(DoorState newState)\n    {\n        if (_currentState == newState) return;\n\n        if (_currentStateCoroutine != null)\n        {\n            StopCoroutine(_currentStateCoroutine);\n        }\n\n        _currentState = newState;\n        UpdateEmissionColor();\n\n        switch (_currentState)\n        {\n            case DoorState.Locked:\n                break;\n            case DoorState.Unlocking:\n                _currentStateCoroutine = StartCoroutine(UnlockingSequence());\n                break;\n            case DoorState.Open:\n                _currentStateCoroutine = StartCoroutine(OpenSequence());\n                break;\n            case DoorState.Closing:\n                _currentStateCoroutine = StartCoroutine(ClosingSequence());\n                break;\n        }\n    }\n\n    private void ApplyShake()\n    {\n        if (_shakeIntensity <= 0) return;\n\n        float shakeX = Mathf.Sin(Time.time * _shakeSpeed) * _shakeIntensity;\n        float shakeZ = Mathf.Cos(Time.time * _shakeSpeed * 1.1f) * _shakeIntensity;\n        \n        transform.position = _originalPosition + new Vector3(shakeX, 0, shakeZ);\n    }\n\n    private IEnumerator UnlockingSequence()\n    {\n        if (_unlockingSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _unlockingSound;\n            _audioSource.Play();\n        }\n\n        yield return new WaitForSeconds(_unlockDuration);\n\n        OnDoorUnlocked?.Invoke();\n        SetState(DoorState.Open);\n    }\n\n    private IEnumerator OpenSequence()\n    {\n        if (_openSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _openSound;\n            _audioSource.Play();\n        }\n\n        // Reset position from shake\n        transform.position = _originalPosition;\n\n        // Rotate door to open position\n        float elapsedTime = 0f;\n        while (elapsedTime < 1f / _openSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime * _openSpeed;\n            transform.rotation = Quaternion.Lerp(_originalRotation, _openRotation, t);\n            yield return null;\n        }\n\n        transform.rotation = _openRotation;\n        OnDoorOpened?.Invoke();\n\n        // Wait for open duration\n        yield return new WaitForSeconds(_openDuration);\n\n        SetState(DoorState.Closing);\n    }\n\n    private IEnumerator ClosingSequence()\n    {\n        if (_closeSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _closeSound;\n            _audioSource.Play();\n        }\n\n        // Rotate door back to closed position\n        float elapsedTime = 0f;\n        while (elapsedTime < 1f / _openSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime * _openSpeed;\n            transform.rotation = Quaternion.Lerp(_openRotation, _originalRotation, t);\n            yield return null;\n        }\n\n        transform.rotation = _originalRotation;\n        OnDoorClosed?.Invoke();\n        SetState(DoorState.Locked);\n    }\n\n    private void UpdateEmissionColor()\n    {\n        if (_doorMaterial == null) return;\n\n        Color targetColor = _currentState switch\n        {\n            DoorState.Locked => _lockedColor,\n            DoorState.Unlocking => _unlockingColor,\n            DoorState.Open => _openColor,\n            DoorState.Closing => _closingColor,\n            _ => _lockedColor\n        };\n\n        _doorMaterial.SetColor(_emissionProperty, targetColor);\n    }\n\n    public DoorState GetCurrentState()\n    {\n        return _currentState;\n    }\n\n    public bool IsLocked()\n    {\n        return _currentState == DoorState.Locked;\n    }\n\n    public bool IsOpen()\n    {\n        return _currentState == DoorState.Open;\n    }\n\n    private void OnDestroy()\n    {\n        if (_currentStateCoroutine != null)\n        {\n            StopCoroutine(_currentStateCoroutine);\n        }\n    }\n}",
      "behavior_type": "environment"
    },
    {
      "prompt": "bouncy ball that every time it hits a surface bounces higher than the previous bounce, plays a pitch that increases with each bounce, changes color based on bounce count, and leaves a temporary trail - after 10 bounces it explodes into confetti particles",
      "ideal_ir": {
        "class_name": "BouncyBall",
        "components": [
          "Rigidbody",
          "SphereCollider",
          "AudioSource",
          "TrailRenderer",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "bounceCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "baseBounceForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "bounceMultiplier",
            "type": "float",
            "default": 1.2
          },
          {
            "name": "basePitch",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "pitchIncrement",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "maxBounces",
            "type": "int",
            "default": 10
          },
          {
            "name": "trailDuration",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "bounceColors",
            "type": "Color[]",
            "default": "rainbow array"
          },
          {
            "name": "bounceSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "confettiPrefab",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "bounce_on_collision",
            "trigger": "when ball collides with any surface",
            "actions": [
              {
                "action": "increase bounce count by one"
              },
              {
                "action": "apply upward bounce force multiplied by bounce count and bounce multiplier"
              },
              {
                "action": "play bounce sound with pitch increased by bounce count times pitch increment"
              },
              {
                "action": "change ball color based on current bounce count using color array"
              },
              {
                "action": "activate trail renderer for trail duration"
              }
            ]
          },
          {
            "name": "explode_after_max_bounces",
            "trigger": "when bounce count reaches maximum bounces",
            "actions": [
              {
                "action": "spawn confetti particle explosion at ball position"
              },
              {
                "action": "play explosion sound effect"
              },
              {
                "action": "destroy the ball object"
              },
              {
                "action": "stop trail renderer"
              }
            ]
          },
          {
            "name": "fade_trail",
            "trigger": "continuously while trail is active",
            "actions": [
              {
                "action": "gradually fade trail opacity over trail duration"
              },
              {
                "action": "disable trail renderer when fully faded"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class BouncyBall : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _initialBounceForce = 10f;\n    [SerializeField] private float _bounceMultiplier = 1.2f;\n    [SerializeField] private int _maxBounces = 10;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _bounceSound;\n    [SerializeField] private float _basePitch = 0.5f;\n    [SerializeField] private float _pitchIncrement = 0.15f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color[] _bounceColors = new Color[]\n    {\n        Color.white, Color.yellow, Color.orange, Color.red, \n        Color.magenta, Color.blue, Color.cyan, Color.green,\n        Color.gray, Color.black\n    };\n    \n    [Header(\"Trail Settings\")]\n    [SerializeField] private float _trailTime = 0.5f;\n    [SerializeField] private float _trailWidth = 0.1f;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private int _confettiCount = 50;\n    [SerializeField] private float _explosionForce = 15f;\n    [SerializeField] private float _confettiLifetime = 3f;\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private TrailRenderer _trailRenderer;\n    private int _bounceCount = 0;\n    private float _currentBounceForce;\n    private bool _hasExploded = false;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupTrail();\n        _currentBounceForce = _initialBounceForce;\n    }\n    \n    void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n        {\n            gameObject.AddComponent<MeshRenderer>();\n            _renderer = GetComponent<Renderer>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (GetComponent<Collider>() == null)\n            gameObject.AddComponent<SphereCollider>();\n    }\n    \n    void SetupTrail()\n    {\n        _trailRenderer = GetComponent<TrailRenderer>();\n        if (_trailRenderer == null)\n            _trailRenderer = gameObject.AddComponent<TrailRenderer>();\n            \n        _trailRenderer.time = _trailTime;\n        _trailRenderer.startWidth = _trailWidth;\n        _trailRenderer.endWidth = 0f;\n        _trailRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _trailRenderer.color = Color.white;\n    }\n    \n    void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded) return;\n        \n        _bounceCount++;\n        \n        if (_bounceCount >= _maxBounces)\n        {\n            ExplodeIntoConfetti();\n            return;\n        }\n        \n        PerformBounce(collision);\n        PlayBounceSound();\n        UpdateVisuals();\n    }\n    \n    void PerformBounce(Collision collision)\n    {\n        Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n        _currentBounceForce *= _bounceMultiplier;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.AddForce(bounceDirection * _currentBounceForce, ForceMode.Impulse);\n    }\n    \n    void PlayBounceSound()\n    {\n        if (_bounceSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _bounceSound;\n            _audioSource.pitch = _basePitch + (_pitchIncrement * _bounceCount);\n            _audioSource.Play();\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_renderer != null && _bounceColors.Length > 0)\n        {\n            int colorIndex = Mathf.Clamp(_bounceCount - 1, 0, _bounceColors.Length - 1);\n            _renderer.material.color = _bounceColors[colorIndex];\n            \n            if (_trailRenderer != null)\n                _trailRenderer.color = _bounceColors[colorIndex];\n        }\n    }\n    \n    void ExplodeIntoConfetti()\n    {\n        _hasExploded = true;\n        \n        for (int i = 0; i < _confettiCount; i++)\n        {\n            CreateConfettiPiece();\n        }\n        \n        if (_audioSource != null && _bounceSound != null)\n        {\n            _audioSource.pitch = _basePitch + (_pitchIncrement * _maxBounces);\n            _audioSource.Play();\n        }\n        \n        StartCoroutine(DestroyAfterExplosion());\n    }\n    \n    void CreateConfettiPiece()\n    {\n        GameObject confetti = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        confetti.transform.position = transform.position + Random.insideUnitSphere * 0.5f;\n        confetti.transform.localScale = Vector3.one * Random.Range(0.05f, 0.15f);\n        \n        Renderer confettiRenderer = confetti.GetComponent<Renderer>();\n        if (confettiRenderer != null && _bounceColors.Length > 0)\n        {\n            confettiRenderer.material.color = _bounceColors[Random.Range(0, _bounceColors.Length)];\n        }\n        \n        Rigidbody confettiRb = confetti.AddComponent<Rigidbody>();\n        Vector3 explosionDirection = Random.insideUnitSphere;\n        confettiRb.AddForce(explosionDirection * _explosionForce, ForceMode.Impulse);\n        confettiRb.AddTorque(Random.insideUnitSphere * 10f, ForceMode.Impulse);\n        \n        StartCoroutine(DestroyConfetti(confetti));\n    }\n    \n    IEnumerator DestroyConfetti(GameObject confetti)\n    {\n        yield return new WaitForSeconds(_confettiLifetime);\n        if (confetti != null)\n            Destroy(confetti);\n    }\n    \n    IEnumerator DestroyAfterExplosion()\n    {\n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        yield return new WaitForSeconds(1f);\n        Destroy(gameObject);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "object that floats upward when player is near (within 5 units) but falls faster when player is far away, plays a humming sound that gets higher pitched as it rises and lower as it falls, rotates opposite to its vertical movement direction",
      "ideal_ir": {
        "class_name": "FloatingObject",
        "components": [
          "Rigidbody",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 5
          },
          {
            "name": "floatSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "fallSpeed",
            "type": "float",
            "default": 4
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 30
          },
          {
            "name": "basePitch",
            "type": "float",
            "default": 1
          },
          {
            "name": "pitchRange",
            "type": "float",
            "default": 0.5
          }
        ],
        "behaviors": [
          {
            "name": "float_when_player_near",
            "trigger": "when player is within detection range",
            "actions": [
              {
                "action": "apply upward force at float speed"
              },
              {
                "action": "rotate clockwise around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "fall_when_player_far",
            "trigger": "when player is outside detection range",
            "actions": [
              {
                "action": "apply downward force at fall speed"
              },
              {
                "action": "rotate counterclockwise around vertical axis at rotation speed"
              }
            ]
          },
          {
            "name": "adjust_sound_pitch_rising",
            "trigger": "when moving upward",
            "actions": [
              {
                "action": "increase audio pitch above base pitch based on upward velocity"
              },
              {
                "action": "play humming sound continuously"
              }
            ]
          },
          {
            "name": "adjust_sound_pitch_falling",
            "trigger": "when moving downward",
            "actions": [
              {
                "action": "decrease audio pitch below base pitch based on downward velocity"
              },
              {
                "action": "play humming sound continuously"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class FloatingObject : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _fallSpeed = 4f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchRange = 0.5f;\n    [SerializeField] private float _pitchSmoothSpeed = 2f;\n    \n    [Header(\"References\")]\n    [SerializeField] private Transform _playerTransform;\n    \n    private Vector3 _startPosition;\n    private float _currentVerticalVelocity;\n    private float _targetPitch;\n    private bool _isPlayerNear;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.loop = true;\n            _audioSource.volume = 0.5f;\n        }\n        \n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n        \n        _audioSource.pitch = _basePitch;\n        if (!_audioSource.isPlaying)\n            _audioSource.Play();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerDistance();\n        HandleMovement();\n        HandleRotation();\n        HandleAudio();\n    }\n    \n    private void CheckPlayerDistance()\n    {\n        if (_playerTransform == null)\n            return;\n            \n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        _isPlayerNear = distance <= _detectionRange;\n    }\n    \n    private void HandleMovement()\n    {\n        if (_isPlayerNear)\n        {\n            _currentVerticalVelocity = _floatSpeed;\n        }\n        else\n        {\n            _currentVerticalVelocity = -_fallSpeed;\n        }\n        \n        Vector3 movement = Vector3.up * _currentVerticalVelocity * Time.deltaTime;\n        transform.Translate(movement, Space.World);\n    }\n    \n    private void HandleRotation()\n    {\n        float rotationDirection = _currentVerticalVelocity > 0 ? -1f : 1f;\n        float rotationAmount = rotationDirection * _rotationSpeed * Time.deltaTime;\n        transform.Rotate(0, 0, rotationAmount);\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null)\n            return;\n            \n        if (_currentVerticalVelocity > 0)\n        {\n            _targetPitch = _basePitch + _pitchRange;\n        }\n        else\n        {\n            _targetPitch = _basePitch - _pitchRange;\n        }\n        \n        _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, _targetPitch, _pitchSmoothSpeed * Time.deltaTime);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "physics-based pendulum that swings naturally but when it reaches the bottom of its swing it applies an explosive force to any rigidbody it touches, plays a bell sound, and creates a shockwave particle effect",
      "ideal_ir": {
        "class_name": "ExplosivePendulum",
        "components": [
          "Rigidbody",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "explosionForce",
            "type": "float",
            "default": 500
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "bellSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "shockwaveEffect",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "bottomThreshold",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "hasTriggeredExplosion",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "natural_pendulum_swing",
            "trigger": "always active",
            "actions": [
              {
                "action": "allow physics to naturally swing the pendulum using gravity and momentum"
              }
            ]
          },
          {
            "name": "detect_bottom_position",
            "trigger": "when pendulum reaches the bottom of its swing arc",
            "actions": [
              {
                "action": "check if pendulum is at lowest point and moving slowly"
              },
              {
                "action": "prepare to trigger explosion if not already triggered this swing"
              }
            ]
          },
          {
            "name": "explosive_impact",
            "trigger": "when pendulum is at bottom position and has not exploded this swing",
            "actions": [
              {
                "action": "find all rigidbodies within explosion radius"
              },
              {
                "action": "apply explosive force outward from pendulum position to each rigidbody"
              },
              {
                "action": "play bell sound effect"
              },
              {
                "action": "trigger shockwave particle effect at pendulum position"
              },
              {
                "action": "mark explosion as triggered for this swing"
              }
            ]
          },
          {
            "name": "reset_explosion_trigger",
            "trigger": "when pendulum swings away from bottom position after explosion",
            "actions": [
              {
                "action": "reset explosion trigger flag to allow next swing to explode"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplosivePendulum : MonoBehaviour\n{\n    [Header(\"Pendulum Physics\")]\n    [SerializeField] private Transform _pivotPoint;\n    [SerializeField] private float _pendulumLength = 5f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _damping = 0.995f;\n    [SerializeField] private float _initialAngle = 45f;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _explosionRadius = 10f;\n    [SerializeField] private float _upwardModifier = 3f;\n    [SerializeField] private float _bottomThreshold = 0.1f;\n    [SerializeField] private float _explosionCooldown = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _bellSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _shockwaveEffect;\n    [SerializeField] private GameObject _shockwavePrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnExplosion;\n    \n    private float _currentAngle;\n    private float _angularVelocity;\n    private bool _canExplode = true;\n    private float _lastExplosionTime;\n    private Vector3 _restPosition;\n    private bool _wasAtBottom;\n    \n    private void Start()\n    {\n        InitializePendulum();\n        SetupAudio();\n        SetupEffects();\n    }\n    \n    private void InitializePendulum()\n    {\n        if (_pivotPoint == null)\n            _pivotPoint = transform.parent != null ? transform.parent : transform;\n            \n        _currentAngle = _initialAngle * Mathf.Deg2Rad;\n        _angularVelocity = 0f;\n        _restPosition = _pivotPoint.position + Vector3.down * _pendulumLength;\n        \n        UpdatePendulumPosition();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n                _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.volume = _volume;\n    }\n    \n    private void SetupEffects()\n    {\n        if (_shockwaveEffect == null)\n        {\n            _shockwaveEffect = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        UpdatePendulumPhysics();\n        UpdatePendulumPosition();\n        CheckForExplosion();\n    }\n    \n    private void UpdatePendulumPhysics()\n    {\n        float angularAcceleration = -(_gravity / _pendulumLength) * Mathf.Sin(_currentAngle);\n        _angularVelocity += angularAcceleration * Time.fixedDeltaTime;\n        _angularVelocity *= _damping;\n        _currentAngle += _angularVelocity * Time.fixedDeltaTime;\n    }\n    \n    private void UpdatePendulumPosition()\n    {\n        Vector3 pendulumPosition = _pivotPoint.position + new Vector3(\n            Mathf.Sin(_currentAngle) * _pendulumLength,\n            -Mathf.Cos(_currentAngle) * _pendulumLength,\n            0f\n        );\n        \n        transform.position = pendulumPosition;\n        \n        Vector3 direction = (transform.position - _pivotPoint.position).normalized;\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, -direction);\n    }\n    \n    private void CheckForExplosion()\n    {\n        bool isAtBottom = IsAtBottomOfSwing();\n        \n        if (isAtBottom && !_wasAtBottom && _canExplode && Time.time - _lastExplosionTime > _explosionCooldown)\n        {\n            TriggerExplosion();\n        }\n        \n        _wasAtBottom = isAtBottom;\n    }\n    \n    private bool IsAtBottomOfSwing()\n    {\n        return Mathf.Abs(_currentAngle) < _bottomThreshold;\n    }\n    \n    private void TriggerExplosion()\n    {\n        _canExplode = false;\n        _lastExplosionTime = Time.time;\n        \n        ApplyExplosiveForce();\n        PlayBellSound();\n        CreateShockwaveEffect();\n        OnExplosion?.Invoke();\n        \n        Invoke(nameof(ResetExplosionCooldown), _explosionCooldown);\n    }\n    \n    private void ApplyExplosiveForce()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            Rigidbody rb = col.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, _upwardModifier, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void PlayBellSound()\n    {\n        if (_audioSource != null && _bellSound != null)\n        {\n            _audioSource.PlayOneShot(_bellSound, _volume);\n        }\n    }\n    \n    private void CreateShockwaveEffect()\n    {\n        if (_shockwaveEffect != null)\n        {\n            _shockwaveEffect.transform.position = transform.position;\n            _shockwaveEffect.Play();\n        }\n        \n        if (_shockwavePrefab != null)\n        {\n            GameObject shockwave = Instantiate(_shockwavePrefab, transform.position, Quaternion.identity);\n            Destroy(shockwave, 5f);\n        }\n    }\n    \n    private void ResetExplosionCooldown()\n    {\n        _canExplode = true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsAtBottomOfSwing() && _canExplode)\n        {\n            Rigidbody otherRb = other.GetComponent<Rigidbody>();\n            if (otherRb != null)\n            {\n                TriggerExplosion();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_pivotPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_pivotPoint.position, 0.1f);\n            Gizmos.DrawLine(_pivotPoint.position, transform.position);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n            \n            Gizmos.color = Color.green;\n            Vector3 bottomPosition = _pivotPoint.position + Vector3.down * _pendulumLength;\n            Gizmos.DrawWireSphere(bottomPosition, _bottomThreshold * _pendulumLength);\n        }\n    }\n    \n    public void SetPendulumAngle(float angleInDegrees)\n    {\n        _currentAngle = angleInDegrees * Mathf.Deg2Rad;\n        _angularVelocity = 0f;\n        UpdatePendulumPosition();\n    }\n    \n    public void AddImpulse(float impulse)\n    {\n        _angularVelocity += impulse;\n    }\n    \n    public float GetCurrentAngle()\n    {\n        return _currentAngle * Mathf.Rad2Deg;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "time bomb that beeps every second with the beep frequency increasing as time runs down, the object's color pulses red in sync with beeps and shakes more violently as time decreases, after 10 seconds it explodes with massive force affecting all rigidbodies in a 20-unit radius",
      "ideal_ir": {
        "class_name": "TimeBomb",
        "components": [
          "AudioSource",
          "Renderer",
          "Rigidbody"
        ],
        "fields": [
          {
            "name": "totalTime",
            "type": "float",
            "default": 10
          },
          {
            "name": "explosionRadius",
            "type": "float",
            "default": 20
          },
          {
            "name": "explosionForce",
            "type": "float",
            "default": 1000
          },
          {
            "name": "beepSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "explosionSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "currentTime",
            "type": "float",
            "default": 10
          },
          {
            "name": "lastBeepTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "originalColor",
            "type": "Color",
            "default": "Color.white"
          },
          {
            "name": "isActive",
            "type": "bool",
            "default": true
          }
        ],
        "behaviors": [
          {
            "name": "countdown_timer",
            "trigger": "every frame while bomb is active",
            "actions": [
              {
                "action": "decrease current time by frame time"
              }
            ]
          },
          {
            "name": "beep_timing",
            "trigger": "when enough time has passed since last beep based on remaining time",
            "actions": [
              {
                "action": "play beep sound"
              },
              {
                "action": "record current time as last beep time"
              }
            ]
          },
          {
            "name": "color_pulse",
            "trigger": "when beep sound plays",
            "actions": [
              {
                "action": "flash object color to bright red"
              },
              {
                "action": "fade color back to original over short duration"
              }
            ]
          },
          {
            "name": "shake_effect",
            "trigger": "every frame while bomb is active",
            "actions": [
              {
                "action": "shake object position randomly with intensity based on how little time remains"
              }
            ]
          },
          {
            "name": "explode",
            "trigger": "when countdown reaches zero",
            "actions": [
              {
                "action": "play explosion sound"
              },
              {
                "action": "find all rigidbodies within explosion radius"
              },
              {
                "action": "apply massive outward force to each found rigidbody"
              },
              {
                "action": "destroy this bomb object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeBomb : MonoBehaviour\n{\n    [Header(\"Bomb Settings\")]\n    [SerializeField] private float _countdownTime = 10f;\n    [SerializeField] private float _explosionRadius = 20f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _warningColor = Color.red;\n    [SerializeField] private float _pulseDuration = 0.1f;\n    [SerializeField] private AnimationCurve _shakeIntensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _maxShakeIntensity = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _beepSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _minBeepInterval = 0.1f;\n    [SerializeField] private float _maxBeepInterval = 1f;\n    \n    [Header(\"Explosion Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private bool _destroyOnExplode = true;\n    \n    private float _timeRemaining;\n    private bool _isActive = false;\n    private bool _hasExploded = false;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    private Material _material;\n    \n    private Coroutine _countdownCoroutine;\n    private Coroutine _pulseCoroutine;\n    private Coroutine _shakeCoroutine;\n\n    private void Awake()\n    {\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n        }\n        \n        _originalPosition = transform.position;\n        _timeRemaining = _countdownTime;\n    }\n\n    private void Start()\n    {\n        StartBomb();\n    }\n\n    public void StartBomb()\n    {\n        if (_isActive || _hasExploded) return;\n        \n        _isActive = true;\n        _timeRemaining = _countdownTime;\n        \n        _countdownCoroutine = StartCoroutine(CountdownRoutine());\n        _shakeCoroutine = StartCoroutine(ShakeRoutine());\n    }\n\n    public void DefuseBomb()\n    {\n        if (_hasExploded) return;\n        \n        _isActive = false;\n        \n        if (_countdownCoroutine != null) StopCoroutine(_countdownCoroutine);\n        if (_pulseCoroutine != null) StopCoroutine(_pulseCoroutine);\n        if (_shakeCoroutine != null) StopCoroutine(_shakeCoroutine);\n        \n        ResetVisuals();\n    }\n\n    private IEnumerator CountdownRoutine()\n    {\n        while (_timeRemaining > 0 && _isActive)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            float beepInterval = Mathf.Lerp(_maxBeepInterval, _minBeepInterval, progress);\n            \n            PlayBeep();\n            StartPulse();\n            \n            yield return new WaitForSeconds(beepInterval);\n            _timeRemaining -= beepInterval;\n        }\n        \n        if (_isActive)\n        {\n            Explode();\n        }\n    }\n\n    private IEnumerator ShakeRoutine()\n    {\n        while (_isActive && !_hasExploded)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            float shakeIntensity = _shakeIntensityCurve.Evaluate(progress) * _maxShakeIntensity;\n            \n            Vector3 randomOffset = Random.insideUnitSphere * shakeIntensity;\n            transform.position = _originalPosition + randomOffset;\n            \n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n    }\n\n    private void PlayBeep()\n    {\n        if (_audioSource != null && _beepSound != null)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            _audioSource.pitch = Mathf.Lerp(0.8f, 2f, progress);\n            _audioSource.PlayOneShot(_beepSound);\n        }\n    }\n\n    private void StartPulse()\n    {\n        if (_pulseCoroutine != null)\n        {\n            StopCoroutine(_pulseCoroutine);\n        }\n        _pulseCoroutine = StartCoroutine(PulseRoutine());\n    }\n\n    private IEnumerator PulseRoutine()\n    {\n        if (_material == null) yield break;\n        \n        Color originalColor = _material.color;\n        float elapsed = 0f;\n        \n        while (elapsed < _pulseDuration)\n        {\n            float t = elapsed / _pulseDuration;\n            float pulseValue = Mathf.Sin(t * Mathf.PI);\n            \n            _material.color = Color.Lerp(originalColor, _warningColor, pulseValue);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _material.color = originalColor;\n    }\n\n    private void Explode()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        _isActive = false;\n        \n        // Stop all coroutines\n        if (_countdownCoroutine != null) StopCoroutine(_countdownCoroutine);\n        if (_pulseCoroutine != null) StopCoroutine(_pulseCoroutine);\n        if (_shakeCoroutine != null) StopCoroutine(_shakeCoroutine);\n        \n        // Play explosion sound\n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n        \n        // Spawn explosion effect\n        if (_explosionPrefab != null)\n        {\n            Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n        }\n        \n        // Apply explosion force\n        ApplyExplosionForce();\n        \n        // Destroy or disable the bomb\n        if (_destroyOnExplode)\n        {\n            Destroy(gameObject, _explosionSound != null ? _explosionSound.length : 0f);\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n\n    private void ApplyExplosionForce()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            Rigidbody rb = col.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            // Damage players or other objects\n            if (col.CompareTag(\"Player\"))\n            {\n                // Send damage message if the object can receive it\n                col.SendMessage(\"TakeDamage\", 100f, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n\n    private void ResetVisuals()\n    {\n        if (_material != null)\n        {\n            _material.color = _normalColor;\n        }\n        \n        transform.position = _originalPosition;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n\n    private void OnDestroy()\n    {\n        if (_material != null)\n        {\n            Destroy(_material);\n        }\n    }\n\n    // Public methods for external control\n    public float TimeRemaining => _timeRemaining;\n    public bool IsActive => _isActive;\n    public bool HasExploded => _hasExploded;\n    \n    public void SetCountdownTime(float time)\n    {\n        if (!_isActive)\n        {\n            _countdownTime = time;\n            _timeRemaining = time;\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "object that gradually transforms over 30 seconds: smoothly rotates 360 degrees, scales from 1x to 2x and back, changes color through the rainbow spectrum, moves in a figure-8 pattern, and plays a continuous musical note that shifts pitch based on transformation phase",
      "ideal_ir": {
        "class_name": "TransformingObject",
        "components": [
          "Transform",
          "Renderer",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "transformationDuration",
            "type": "float",
            "default": 30
          },
          {
            "name": "figureEightRadius",
            "type": "float",
            "default": 5
          },
          {
            "name": "basePitch",
            "type": "float",
            "default": 440
          },
          {
            "name": "pitchRange",
            "type": "float",
            "default": 200
          },
          {
            "name": "startingPosition",
            "type": "Vector3",
            "default": "Vector3.zero"
          },
          {
            "name": "transformationProgress",
            "type": "float",
            "default": 0
          }
        ],
        "behaviors": [
          {
            "name": "continuous_transformation",
            "trigger": "every frame while transformation is active",
            "actions": [
              {
                "action": "calculate transformation progress as percentage of total duration"
              },
              {
                "action": "smoothly rotate object based on transformation progress completing full 360 degree rotation"
              },
              {
                "action": "smoothly scale object from original size to double size and back based on transformation progress using sine wave pattern"
              },
              {
                "action": "change object color through rainbow spectrum based on transformation progress cycling through red orange yellow green blue indigo violet"
              },
              {
                "action": "move object in figure-8 pattern around starting position based on transformation progress"
              },
              {
                "action": "adjust audio pitch from base pitch within pitch range based on transformation progress"
              }
            ]
          },
          {
            "name": "start_transformation",
            "trigger": "when object becomes active",
            "actions": [
              {
                "action": "record starting position"
              },
              {
                "action": "reset transformation progress to zero"
              },
              {
                "action": "start playing continuous audio tone at base pitch"
              }
            ]
          },
          {
            "name": "complete_transformation_cycle",
            "trigger": "when transformation progress reaches full duration",
            "actions": [
              {
                "action": "reset transformation progress to zero to loop the cycle"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class TransformingObject : MonoBehaviour\n{\n    [Header(\"Transformation Settings\")]\n    [SerializeField] private float _transformationDuration = 30f;\n    [SerializeField] private bool _loopTransformation = true;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _figure8Width = 5f;\n    [SerializeField] private float _figure8Height = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchRange = 2f;\n    [SerializeField] private float _baseFrequency = 440f;\n    \n    private Vector3 _startPosition;\n    private Vector3 _startScale;\n    private Quaternion _startRotation;\n    private Color _startColor;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private float _currentTime;\n    private bool _isTransforming;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _startScale = transform.localScale;\n        _startRotation = transform.rotation;\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n        {\n            _renderer = GetComponentInChildren<Renderer>();\n        }\n        \n        if (_renderer != null)\n        {\n            _startColor = _renderer.material.color;\n        }\n        \n        SetupAudio();\n        StartTransformation();\n    }\n    \n    private void SetupAudio()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = GenerateToneClip(_baseFrequency, 1f);\n        _audioSource.loop = true;\n        _audioSource.volume = 0.3f;\n        _audioSource.pitch = _basePitch;\n        _audioSource.Play();\n    }\n    \n    private AudioClip GenerateToneClip(float frequency, float duration)\n    {\n        int sampleRate = 44100;\n        int sampleCount = Mathf.RoundToInt(sampleRate * duration);\n        float[] samples = new float[sampleCount];\n        \n        for (int i = 0; i < sampleCount; i++)\n        {\n            float time = (float)i / sampleRate;\n            samples[i] = Mathf.Sin(2 * Mathf.PI * frequency * time) * 0.5f;\n        }\n        \n        AudioClip clip = AudioClip.Create(\"GeneratedTone\", sampleCount, 1, sampleRate, false);\n        clip.SetData(samples, 0);\n        return clip;\n    }\n    \n    private void Update()\n    {\n        if (!_isTransforming) return;\n        \n        _currentTime += Time.deltaTime;\n        float normalizedTime = _currentTime / _transformationDuration;\n        \n        if (normalizedTime >= 1f)\n        {\n            if (_loopTransformation)\n            {\n                _currentTime = 0f;\n                normalizedTime = 0f;\n            }\n            else\n            {\n                normalizedTime = 1f;\n                _isTransforming = false;\n            }\n        }\n        \n        ApplyTransformations(normalizedTime);\n    }\n    \n    private void ApplyTransformations(float t)\n    {\n        // Rotation - 360 degrees over duration\n        float rotationAngle = t * 360f;\n        transform.rotation = _startRotation * Quaternion.Euler(0, rotationAngle, 0);\n        \n        // Scale - 1x to 2x and back (sine wave)\n        float scaleMultiplier = 1f + Mathf.Sin(t * Mathf.PI);\n        transform.localScale = _startScale * scaleMultiplier;\n        \n        // Color - rainbow spectrum\n        Color rainbowColor = GetRainbowColor(t);\n        if (_renderer != null)\n        {\n            _renderer.material.color = rainbowColor;\n        }\n        \n        // Movement - figure-8 pattern\n        Vector3 figure8Position = GetFigure8Position(t);\n        transform.position = _startPosition + figure8Position;\n        \n        // Audio pitch based on transformation phase\n        if (_audioSource != null)\n        {\n            float pitchMultiplier = _basePitch + (Mathf.Sin(t * 2 * Mathf.PI) * _pitchRange * 0.5f);\n            _audioSource.pitch = Mathf.Clamp(pitchMultiplier, 0.1f, 3f);\n        }\n    }\n    \n    private Color GetRainbowColor(float t)\n    {\n        float hue = t;\n        return Color.HSVToRGB(hue, 1f, 1f);\n    }\n    \n    private Vector3 GetFigure8Position(float t)\n    {\n        float angle = t * 2 * Mathf.PI;\n        float x = _figure8Width * Mathf.Sin(angle);\n        float z = _figure8Height * Mathf.Sin(2 * angle);\n        return new Vector3(x, 0, z);\n    }\n    \n    public void StartTransformation()\n    {\n        _isTransforming = true;\n        _currentTime = 0f;\n    }\n    \n    public void StopTransformation()\n    {\n        _isTransforming = false;\n    }\n    \n    public void ResetToStart()\n    {\n        _currentTime = 0f;\n        transform.position = _startPosition;\n        transform.localScale = _startScale;\n        transform.rotation = _startRotation;\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = _startColor;\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.pitch = _basePitch;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_transformationDuration <= 0f)\n        {\n            _transformationDuration = 30f;\n        }\n        \n        if (_figure8Width < 0f)\n        {\n            _figure8Width = 0f;\n        }\n        \n        if (_figure8Height < 0f)\n        {\n            _figure8Height = 0f;\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "visualizer that reacts to audio: object's scale increases proportionally to audio volume, color shifts based on audio frequency (low red, mid green, high blue), rotates based on audio waveform, spawns particles that move outward in sync with beat",
      "ideal_ir": {
        "class_name": "AudioVisualizer",
        "components": [
          "AudioSource",
          "MeshRenderer",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "baseScale",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "scaleMultiplier",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "rotationSpeed",
            "type": "float",
            "default": 100.0
          },
          {
            "name": "particleSpawnRate",
            "type": "int",
            "default": 50
          },
          {
            "name": "particleSpeed",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "lowFrequencyThreshold",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "highFrequencyThreshold",
            "type": "float",
            "default": 0.7
          }
        ],
        "behaviors": [
          {
            "name": "scale_with_volume",
            "trigger": "when audio volume changes",
            "actions": [
              {
                "action": "increase object scale proportionally to current audio volume level"
              }
            ]
          },
          {
            "name": "color_shift_frequency",
            "trigger": "when audio frequency data updates",
            "actions": [
              {
                "action": "shift color to red when low frequencies dominate"
              },
              {
                "action": "shift color to green when mid frequencies dominate"
              },
              {
                "action": "shift color to blue when high frequencies dominate"
              }
            ]
          },
          {
            "name": "rotate_with_waveform",
            "trigger": "when audio waveform data changes",
            "actions": [
              {
                "action": "rotate object based on audio waveform intensity and pattern"
              }
            ]
          },
          {
            "name": "spawn_beat_particles",
            "trigger": "when audio beat is detected",
            "actions": [
              {
                "action": "spawn particles from object center"
              },
              {
                "action": "make particles move outward in all directions"
              },
              {
                "action": "synchronize particle emission timing with detected beat"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\n[System.Serializable]\npublic class AudioVisualizerSettings\n{\n    [Header(\"Scale Settings\")]\n    public float baseScale = 1f;\n    public float scaleMultiplier = 2f;\n    public float scaleSmoothing = 5f;\n    \n    [Header(\"Color Settings\")]\n    public float colorSensitivity = 1f;\n    public float colorSmoothing = 3f;\n    \n    [Header(\"Rotation Settings\")]\n    public float rotationSpeed = 100f;\n    public Vector3 rotationAxis = Vector3.up;\n    \n    [Header(\"Particle Settings\")]\n    public int maxParticles = 50;\n    public float particleSpeed = 5f;\n    public float particleLifetime = 2f;\n    public float beatThreshold = 0.7f;\n    public float beatCooldown = 0.2f;\n}\n\npublic class AudioVisualizer : MonoBehaviour\n{\n    [Header(\"Audio Source\")]\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Visualization Settings\")]\n    [SerializeField] private AudioVisualizerSettings _settings = new AudioVisualizerSettings();\n    \n    [Header(\"Components\")]\n    [SerializeField] private Renderer _renderer;\n    [SerializeField] private ParticleSystem _particleSystem;\n    \n    [Header(\"Audio Analysis\")]\n    [SerializeField] private int _sampleSize = 1024;\n    [SerializeField] private FFTWindow _fftWindow = FFTWindow.Blackman;\n    \n    private float[] _audioSamples;\n    private float[] _frequencyBands;\n    private float _currentVolume;\n    private Color _targetColor;\n    private Color _currentColor;\n    private float _targetScale;\n    private float _currentScale;\n    private float _lastBeatTime;\n    private Material _material;\n    private Vector3 _baseScale;\n    private float _rotationAccumulator;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        InitializeAudioAnalysis();\n        InitializeVisualization();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer == null)\n            _renderer = GetComponent<Renderer>();\n        \n        if (_particleSystem == null)\n            _particleSystem = GetComponent<ParticleSystem>();\n        \n        if (_audioSource == null)\n        {\n            Debug.LogError(\"AudioSource component required for AudioVisualizer\");\n            enabled = false;\n            return;\n        }\n        \n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _baseScale = transform.localScale;\n        }\n    }\n    \n    private void InitializeAudioAnalysis()\n    {\n        _audioSamples = new float[_sampleSize];\n        _frequencyBands = new float[3]; // Low, Mid, High\n        _currentScale = _settings.baseScale;\n        _targetScale = _settings.baseScale;\n        _currentColor = Color.white;\n        _targetColor = Color.white;\n    }\n    \n    private void InitializeVisualization()\n    {\n        if (_particleSystem != null)\n        {\n            var main = _particleSystem.main;\n            main.maxParticles = _settings.maxParticles;\n            main.startLifetime = _settings.particleLifetime;\n            main.startSpeed = _settings.particleSpeed;\n            \n            var emission = _particleSystem.emission;\n            emission.enabled = false;\n            \n            var shape = _particleSystem.shape;\n            shape.enabled = true;\n            shape.shapeType = ParticleSystemShapeType.Sphere;\n            shape.radius = 0.1f;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_audioSource == null || !_audioSource.isPlaying)\n            return;\n        \n        AnalyzeAudio();\n        UpdateScale();\n        UpdateColor();\n        UpdateRotation();\n        CheckForBeat();\n    }\n    \n    private void AnalyzeAudio()\n    {\n        _audioSource.GetSpectrumData(_audioSamples, 0, _fftWindow);\n        \n        // Calculate volume\n        float sum = 0f;\n        for (int i = 0; i < _audioSamples.Length; i++)\n        {\n            sum += _audioSamples[i] * _audioSamples[i];\n        }\n        _currentVolume = Mathf.Sqrt(sum / _audioSamples.Length);\n        \n        // Calculate frequency bands\n        CalculateFrequencyBands();\n    }\n    \n    private void CalculateFrequencyBands()\n    {\n        int count = 0;\n        \n        // Low frequencies (0-170 Hz approximately)\n        for (int i = 0; i < 8; i++)\n        {\n            _frequencyBands[0] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[0] /= count;\n        \n        count = 0;\n        // Mid frequencies (170-4000 Hz approximately)\n        for (int i = 8; i < 128; i++)\n        {\n            _frequencyBands[1] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[1] /= count;\n        \n        count = 0;\n        // High frequencies (4000+ Hz approximately)\n        for (int i = 128; i < _audioSamples.Length / 4; i++)\n        {\n            _frequencyBands[2] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[2] /= count;\n    }\n    \n    private void UpdateScale()\n    {\n        _targetScale = _settings.baseScale + (_currentVolume * _settings.scaleMultiplier);\n        _currentScale = Mathf.Lerp(_currentScale, _targetScale, Time.deltaTime * _settings.scaleSmoothing);\n        \n        if (_renderer != null)\n        {\n            transform.localScale = _baseScale * _currentScale;\n        }\n    }\n    \n    private void UpdateColor()\n    {\n        float red = _frequencyBands[0] * _settings.colorSensitivity;\n        float green = _frequencyBands[1] * _settings.colorSensitivity;\n        float blue = _frequencyBands[2] * _settings.colorSensitivity;\n        \n        _targetColor = new Color(red, green, blue, 1f);\n        _currentColor = Color.Lerp(_currentColor, _targetColor, Time.deltaTime * _settings.colorSmoothing);\n        \n        if (_material != null)\n        {\n            _material.color = _currentColor;\n        }\n    }\n    \n    private void UpdateRotation()\n    {\n        float waveformIntensity = 0f;\n        for (int i = 0; i < _audioSamples.Length; i += 10)\n        {\n            waveformIntensity += Mathf.Abs(_audioSamples[i]);\n        }\n        waveformIntensity /= (_audioSamples.Length / 10);\n        \n        _rotationAccumulator += waveformIntensity * _settings.rotationSpeed * Time.deltaTime;\n        transform.rotation = Quaternion.AngleAxis(_rotationAccumulator, _settings.rotationAxis);\n    }\n    \n    private void CheckForBeat()\n    {\n        if (_currentVolume > _settings.beatThreshold && \n            Time.time - _lastBeatTime > _settings.beatCooldown)\n        {\n            TriggerBeatEffect();\n            _lastBeatTime = Time.time;\n        }\n    }\n    \n    private void TriggerBeatEffect()\n    {\n        if (_particleSystem != null)\n        {\n            var emission = _particleSystem.emission;\n            emission.Emit(10);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_settings.baseScale <= 0f)\n            _settings.baseScale = 1f;\n        \n        if (_settings.scaleMultiplier < 0f)\n            _settings.scaleMultiplier = 0f;\n        \n        if (_settings.beatThreshold < 0f)\n            _settings.beatThreshold = 0f;\n        \n        if (_settings.beatThreshold > 1f)\n            _settings.beatThreshold = 1f;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_material != null && Application.isPlaying)\n        {\n            Destroy(_material);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "singing crystal that when touched plays a sequence of 5 musical notes in a chord progression, each note lights up a different part of the crystal, the entire crystal pulses with the rhythm, after the sequence completes it creates a burst of light particles",
      "ideal_ir": {
        "class_name": "SingingCrystal",
        "components": [
          "AudioSource",
          "ParticleSystem",
          "Collider"
        ],
        "fields": [
          {
            "name": "noteSequence",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "crystalParts",
            "type": "GameObject[]",
            "default": null
          },
          {
            "name": "pulseIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "noteDuration",
            "type": "float",
            "default": 0.8
          },
          {
            "name": "isPlaying",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentNoteIndex",
            "type": "int",
            "default": 0
          },
          {
            "name": "burstParticles",
            "type": "ParticleSystem",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "start_musical_sequence",
            "trigger": "when player touches the crystal and sequence is not already playing",
            "actions": [
              {
                "action": "set playing state to true"
              },
              {
                "action": "reset note index to zero"
              },
              {
                "action": "begin playing the first musical note"
              }
            ]
          },
          {
            "name": "play_current_note",
            "trigger": "when it is time to play the current note in sequence",
            "actions": [
              {
                "action": "play the audio clip for current note"
              },
              {
                "action": "light up the crystal part corresponding to current note"
              },
              {
                "action": "make entire crystal pulse with rhythm"
              },
              {
                "action": "schedule next note to play after note duration"
              }
            ]
          },
          {
            "name": "advance_to_next_note",
            "trigger": "when current note duration has elapsed",
            "actions": [
              {
                "action": "dim the previously lit crystal part"
              },
              {
                "action": "increase note index by one"
              },
              {
                "action": "check if more notes remain in sequence"
              }
            ]
          },
          {
            "name": "complete_sequence",
            "trigger": "when all five notes have been played",
            "actions": [
              {
                "action": "create burst of light particles around crystal"
              },
              {
                "action": "stop crystal pulsing"
              },
              {
                "action": "dim all crystal parts"
              },
              {
                "action": "set playing state to false"
              },
              {
                "action": "reset note index for next activation"
              }
            ]
          },
          {
            "name": "pulse_crystal",
            "trigger": "when crystal should pulse with rhythm during note playback",
            "actions": [
              {
                "action": "increase crystal brightness smoothly"
              },
              {
                "action": "scale crystal size slightly larger"
              },
              {
                "action": "return to normal brightness and size smoothly"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class SingingCrystal : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _musicalNotes = new AudioClip[5];\n    [SerializeField] private float _noteDuration = 0.8f;\n    [SerializeField] private float _noteInterval = 0.1f;\n\n    [Header(\"Visual Components\")]\n    [SerializeField] private Renderer[] _crystalParts = new Renderer[5];\n    [SerializeField] private Renderer _mainCrystalRenderer;\n    [SerializeField] private ParticleSystem _burstParticles;\n\n    [Header(\"Lighting Effects\")]\n    [SerializeField] private Color[] _noteColors = new Color[5];\n    [SerializeField] private Color _pulseColor = Color.white;\n    [SerializeField] private float _pulseIntensity = 2f;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n\n    [Header(\"Interaction Settings\")]\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _requirePlayerTag = true;\n\n    private Material[] _originalMaterials;\n    private Color[] _originalColors;\n    private Material _mainMaterial;\n    private Color _originalMainColor;\n    private bool _isPlaying = false;\n    private bool _onCooldown = false;\n    private Coroutine _sequenceCoroutine;\n\n    private void Start()\n    {\n        InitializeComponents();\n        CacheOriginalMaterials();\n        SetupDefaultColors();\n    }\n\n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        if (_mainCrystalRenderer == null)\n            _mainCrystalRenderer = GetComponent<Renderer>();\n\n        if (_burstParticles == null)\n            _burstParticles = GetComponentInChildren<ParticleSystem>();\n    }\n\n    private void CacheOriginalMaterials()\n    {\n        _originalMaterials = new Material[_crystalParts.Length];\n        _originalColors = new Color[_crystalParts.Length];\n\n        for (int i = 0; i < _crystalParts.Length; i++)\n        {\n            if (_crystalParts[i] != null)\n            {\n                _originalMaterials[i] = _crystalParts[i].material;\n                _originalColors[i] = _originalMaterials[i].color;\n            }\n        }\n\n        if (_mainCrystalRenderer != null)\n        {\n            _mainMaterial = _mainCrystalRenderer.material;\n            _originalMainColor = _mainMaterial.color;\n        }\n    }\n\n    private void SetupDefaultColors()\n    {\n        if (_noteColors.Length != 5)\n        {\n            _noteColors = new Color[5]\n            {\n                Color.red,\n                Color.yellow,\n                Color.green,\n                Color.cyan,\n                Color.magenta\n            };\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPlaying || _onCooldown)\n            return;\n\n        if (_requirePlayerTag && !other.CompareTag(\"Player\"))\n            return;\n\n        StartMusicalSequence();\n    }\n\n    private void StartMusicalSequence()\n    {\n        if (_sequenceCoroutine != null)\n            StopCoroutine(_sequenceCoroutine);\n\n        _sequenceCoroutine = StartCoroutine(PlayMusicalSequence());\n    }\n\n    private IEnumerator PlayMusicalSequence()\n    {\n        _isPlaying = true;\n\n        for (int i = 0; i < 5; i++)\n        {\n            yield return StartCoroutine(PlayNote(i));\n            yield return new WaitForSeconds(_noteInterval);\n        }\n\n        yield return StartCoroutine(CreateLightBurst());\n        \n        _isPlaying = false;\n        yield return StartCoroutine(CooldownTimer());\n    }\n\n    private IEnumerator PlayNote(int noteIndex)\n    {\n        if (noteIndex >= _musicalNotes.Length || _musicalNotes[noteIndex] == null)\n            yield break;\n\n        _audioSource.PlayOneShot(_musicalNotes[noteIndex]);\n\n        StartCoroutine(LightUpCrystalPart(noteIndex));\n        StartCoroutine(PulseCrystal());\n\n        yield return new WaitForSeconds(_noteDuration);\n    }\n\n    private IEnumerator LightUpCrystalPart(int partIndex)\n    {\n        if (partIndex >= _crystalParts.Length || _crystalParts[partIndex] == null)\n            yield break;\n\n        Material partMaterial = _crystalParts[partIndex].material;\n        Color targetColor = _noteColors[partIndex];\n        Color originalColor = _originalColors[partIndex];\n\n        float elapsed = 0f;\n        float duration = _noteDuration * 0.8f;\n\n        while (elapsed < duration)\n        {\n            float t = elapsed / duration;\n            float intensity = _pulseCurve.Evaluate(t);\n            \n            partMaterial.color = Color.Lerp(originalColor, targetColor * _pulseIntensity, intensity);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        partMaterial.color = originalColor;\n    }\n\n    private IEnumerator PulseCrystal()\n    {\n        if (_mainMaterial == null)\n            yield break;\n\n        float elapsed = 0f;\n        float duration = _noteDuration;\n\n        while (elapsed < duration)\n        {\n            float t = elapsed / duration;\n            float intensity = _pulseCurve.Evaluate(t);\n            \n            _mainMaterial.color = Color.Lerp(_originalMainColor, _pulseColor * _pulseIntensity, intensity);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        _mainMaterial.color = _originalMainColor;\n    }\n\n    private IEnumerator CreateLightBurst()\n    {\n        if (_burstParticles != null)\n        {\n            _burstParticles.Play();\n        }\n\n        StartCoroutine(FinalCrystalFlash());\n        \n        yield return new WaitForSeconds(1f);\n    }\n\n    private IEnumerator FinalCrystalFlash()\n    {\n        float flashDuration = 0.5f;\n        float elapsed = 0f;\n\n        while (elapsed < flashDuration)\n        {\n            float t = elapsed / flashDuration;\n            float intensity = Mathf.Sin(t * Mathf.PI);\n            \n            if (_mainMaterial != null)\n            {\n                _mainMaterial.color = Color.Lerp(_originalMainColor, Color.white * _pulseIntensity, intensity);\n            }\n\n            for (int i = 0; i < _crystalParts.Length; i++)\n            {\n                if (_crystalParts[i] != null)\n                {\n                    _crystalParts[i].material.color = Color.Lerp(_originalColors[i], Color.white * _pulseIntensity, intensity);\n                }\n            }\n\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        ResetCrystalColors();\n    }\n\n    private void ResetCrystalColors()\n    {\n        if (_mainMaterial != null)\n            _mainMaterial.color = _originalMainColor;\n\n        for (int i = 0; i < _crystalParts.Length; i++)\n        {\n            if (_crystalParts[i] != null)\n                _crystalParts[i].material.color = _originalColors[i];\n        }\n    }\n\n    private IEnumerator CooldownTimer()\n    {\n        _onCooldown = true;\n        yield return new WaitForSeconds(_cooldownTime);\n        _onCooldown = false;\n    }\n\n    private void OnDestroy()\n    {\n        if (_sequenceCoroutine != null)\n            StopCoroutine(_sequenceCoroutine);\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "pressure plate system: when weight is applied it plays click sound, changes color to green, starts 5-second timer - if weight stays for 5 seconds it plays success sound and spawns reward object, each pressure plate remembers how many times it's been activated",
      "ideal_ir": {
        "class_name": "PressurePlate",
        "components": [
          "AudioSource",
          "Renderer"
        ],
        "fields": [
          {
            "name": "detectionRadius",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "timerDuration",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "rewardPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "clickSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "successSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "normalColor",
            "type": "Color",
            "default": "Color.gray"
          },
          {
            "name": "activatedColor",
            "type": "Color",
            "default": "Color.green"
          },
          {
            "name": "activationCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "isWeightApplied",
            "type": "bool",
            "default": false
          },
          {
            "name": "currentTimer",
            "type": "float",
            "default": 0
          },
          {
            "name": "isTimerRunning",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_weight_applied",
            "trigger": "when object with weight enters detection area",
            "actions": [
              {
                "action": "set weight applied status to true"
              },
              {
                "action": "play click sound"
              },
              {
                "action": "change plate color to green"
              },
              {
                "action": "start five second timer"
              },
              {
                "action": "set timer running status to true"
              }
            ]
          },
          {
            "name": "detect_weight_removed",
            "trigger": "when object with weight leaves detection area",
            "actions": [
              {
                "action": "set weight applied status to false"
              },
              {
                "action": "change plate color back to normal"
              },
              {
                "action": "stop timer"
              },
              {
                "action": "reset timer to zero"
              },
              {
                "action": "set timer running status to false"
              }
            ]
          },
          {
            "name": "timer_countdown",
            "trigger": "when timer is running and weight is still applied",
            "actions": [
              {
                "action": "decrease timer by elapsed time"
              }
            ]
          },
          {
            "name": "timer_completion",
            "trigger": "when timer reaches zero and weight is still applied",
            "actions": [
              {
                "action": "play success sound"
              },
              {
                "action": "spawn reward object at plate location"
              },
              {
                "action": "increment activation count by one"
              },
              {
                "action": "stop timer"
              },
              {
                "action": "set timer running status to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _plateRenderer;\n    [SerializeField] private Color _defaultColor = Color.gray;\n    [SerializeField] private Color _pressedColor = Color.green;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _clickSound;\n    [SerializeField] private AudioClip _successSound;\n    \n    [Header(\"Reward Settings\")]\n    [SerializeField] private GameObject _rewardPrefab;\n    [SerializeField] private Transform _rewardSpawnPoint;\n    [SerializeField] private float _activationTime = 5f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private LayerMask _detectionLayers = -1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlatePressed;\n    public UnityEvent OnPlateReleased;\n    public UnityEvent OnActivationComplete;\n    \n    private bool _isPressed = false;\n    private bool _isActivating = false;\n    private int _activationCount = 0;\n    private Coroutine _activationCoroutine;\n    private Collider _plateCollider;\n    private Material _plateMaterial;\n    \n    public int ActivationCount => _activationCount;\n    public bool IsPressed => _isPressed;\n    public bool IsActivating => _isActivating;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetPlateColor(_defaultColor);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_plateRenderer == null)\n            _plateRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_plateCollider == null)\n            _plateCollider = GetComponent<Collider>();\n            \n        if (_rewardSpawnPoint == null)\n            _rewardSpawnPoint = transform;\n            \n        if (_plateRenderer != null)\n        {\n            _plateMaterial = _plateRenderer.material;\n        }\n        \n        if (_plateCollider != null && !_plateCollider.isTrigger)\n        {\n            Debug.LogWarning($\"PressurePlate '{gameObject.name}' collider should be set as trigger!\");\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (ShouldDetectObject(other))\n        {\n            PressPlate();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (ShouldDetectObject(other))\n        {\n            if (!HasAnyValidObjectsOnPlate())\n            {\n                ReleasePlate();\n            }\n        }\n    }\n    \n    private bool ShouldDetectObject(Collider other)\n    {\n        if (string.IsNullOrEmpty(_targetTag))\n            return IsInDetectionLayer(other.gameObject);\n            \n        return other.CompareTag(_targetTag) && IsInDetectionLayer(other.gameObject);\n    }\n    \n    private bool IsInDetectionLayer(GameObject obj)\n    {\n        return (_detectionLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    private bool HasAnyValidObjectsOnPlate()\n    {\n        Collider[] overlapping = Physics.OverlapBox(\n            _plateCollider.bounds.center,\n            _plateCollider.bounds.extents,\n            transform.rotation,\n            _detectionLayers\n        );\n        \n        foreach (var collider in overlapping)\n        {\n            if (ShouldDetectObject(collider))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    private void PressPlate()\n    {\n        if (_isPressed) return;\n        \n        _isPressed = true;\n        SetPlateColor(_pressedColor);\n        PlayClickSound();\n        OnPlatePressed?.Invoke();\n        \n        StartActivationTimer();\n    }\n    \n    private void ReleasePlate()\n    {\n        if (!_isPressed) return;\n        \n        _isPressed = false;\n        _isActivating = false;\n        SetPlateColor(_defaultColor);\n        OnPlateReleased?.Invoke();\n        \n        StopActivationTimer();\n    }\n    \n    private void StartActivationTimer()\n    {\n        if (_activationCoroutine != null)\n            StopCoroutine(_activationCoroutine);\n            \n        _activationCoroutine = StartCoroutine(ActivationCountdown());\n    }\n    \n    private void StopActivationTimer()\n    {\n        if (_activationCoroutine != null)\n        {\n            StopCoroutine(_activationCoroutine);\n            _activationCoroutine = null;\n        }\n    }\n    \n    private IEnumerator ActivationCountdown()\n    {\n        _isActivating = true;\n        yield return new WaitForSeconds(_activationTime);\n        \n        if (_isPressed)\n        {\n            CompleteActivation();\n        }\n        \n        _isActivating = false;\n    }\n    \n    private void CompleteActivation()\n    {\n        _activationCount++;\n        PlaySuccessSound();\n        SpawnReward();\n        OnActivationComplete?.Invoke();\n    }\n    \n    private void SetPlateColor(Color color)\n    {\n        if (_plateMaterial != null)\n        {\n            _plateMaterial.color = color;\n        }\n    }\n    \n    private void PlayClickSound()\n    {\n        if (_audioSource != null && _clickSound != null)\n        {\n            _audioSource.PlayOneShot(_clickSound);\n        }\n    }\n    \n    private void PlaySuccessSound()\n    {\n        if (_audioSource != null && _successSound != null)\n        {\n            _audioSource.PlayOneShot(_successSound);\n        }\n    }\n    \n    private void SpawnReward()\n    {\n        if (_rewardPrefab != null && _rewardSpawnPoint != null)\n        {\n            Vector3 spawnPosition = _rewardSpawnPoint.position + Vector3.up * 0.5f;\n            Instantiate(_rewardPrefab, spawnPosition, _rewardSpawnPoint.rotation);\n        }\n    }\n    \n    public void ResetActivationCount()\n    {\n        _activationCount = 0;\n    }\n    \n    public void ForcePress()\n    {\n        PressPlate();\n    }\n    \n    public void ForceRelease()\n    {\n        ReleasePlate();\n    }\n    \n    private void OnValidate()\n    {\n        if (_activationTime < 0f)\n            _activationTime = 0f;\n    }\n    \n    private void OnDestroy()\n    {\n        StopActivationTimer();\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "combo system: hitting object once makes it glow yellow and play low note, second hit within 2 seconds makes it glow orange and play higher note, third hit makes it glow red, fourth hit creates explosion effect and spawns 5 bonus objects - missing the 2-second window resets combo",
      "ideal_ir": {
        "class_name": "ComboSystem",
        "components": [
          "Renderer",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "comboCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "comboTimer",
            "type": "float",
            "default": 0
          },
          {
            "name": "comboWindow",
            "type": "float",
            "default": 2
          },
          {
            "name": "lowNote",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "higherNote",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "explosionEffect",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "bonusObjectPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "yellowColor",
            "type": "Color",
            "default": "Color.yellow"
          },
          {
            "name": "orangeColor",
            "type": "Color",
            "default": "Color.orange"
          },
          {
            "name": "redColor",
            "type": "Color",
            "default": "Color.red"
          },
          {
            "name": "originalColor",
            "type": "Color",
            "default": "Color.white"
          }
        ],
        "behaviors": [
          {
            "name": "first_hit",
            "trigger": "when object is hit and combo count is zero",
            "actions": [
              {
                "action": "set combo count to one"
              },
              {
                "action": "change object color to yellow"
              },
              {
                "action": "play low note sound"
              },
              {
                "action": "start combo timer at two seconds"
              }
            ]
          },
          {
            "name": "second_hit",
            "trigger": "when object is hit and combo count is one and within combo window",
            "actions": [
              {
                "action": "set combo count to two"
              },
              {
                "action": "change object color to orange"
              },
              {
                "action": "play higher note sound"
              },
              {
                "action": "reset combo timer to two seconds"
              }
            ]
          },
          {
            "name": "third_hit",
            "trigger": "when object is hit and combo count is two and within combo window",
            "actions": [
              {
                "action": "set combo count to three"
              },
              {
                "action": "change object color to red"
              },
              {
                "action": "reset combo timer to two seconds"
              }
            ]
          },
          {
            "name": "fourth_hit_explosion",
            "trigger": "when object is hit and combo count is three and within combo window",
            "actions": [
              {
                "action": "create explosion particle effect"
              },
              {
                "action": "spawn five bonus objects around this position"
              },
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "restore original object color"
              },
              {
                "action": "stop combo timer"
              }
            ]
          },
          {
            "name": "combo_timeout",
            "trigger": "when combo timer reaches zero and combo count is greater than zero",
            "actions": [
              {
                "action": "reset combo count to zero"
              },
              {
                "action": "restore original object color"
              },
              {
                "action": "stop combo timer"
              }
            ]
          },
          {
            "name": "update_timer",
            "trigger": "every frame when combo timer is active",
            "actions": [
              {
                "action": "decrease combo timer by frame time"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ComboSystem : MonoBehaviour\n{\n    [Header(\"Combo Settings\")]\n    [SerializeField] private float _comboWindow = 2f;\n    [SerializeField] private int _maxComboLevel = 4;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Renderer _targetRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _combo1Color = Color.yellow;\n    [SerializeField] private Color _combo2Color = new Color(1f, 0.5f, 0f);\n    [SerializeField] private Color _combo3Color = Color.red;\n    [SerializeField] private ParticleSystem _explosionEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _lowNote;\n    [SerializeField] private AudioClip _midNote;\n    [SerializeField] private AudioClip _highNote;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    [Header(\"Bonus Objects\")]\n    [SerializeField] private GameObject _bonusObjectPrefab;\n    [SerializeField] private int _bonusObjectCount = 5;\n    [SerializeField] private float _spawnRadius = 3f;\n    [SerializeField] private float _spawnForce = 5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnComboReset;\n    public UnityEvent OnComboComplete;\n    \n    private int _currentComboLevel = 0;\n    private Coroutine _comboResetCoroutine;\n    private Material _originalMaterial;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        ResetCombo();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_targetRenderer != null)\n        {\n            _originalMaterial = _targetRenderer.material;\n        }\n    }\n    \n    private void OnMouseDown()\n    {\n        ProcessHit();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ProcessHit();\n        }\n    }\n    \n    private void ProcessHit()\n    {\n        _currentComboLevel++;\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n        \n        switch (_currentComboLevel)\n        {\n            case 1:\n                HandleCombo1();\n                break;\n            case 2:\n                HandleCombo2();\n                break;\n            case 3:\n                HandleCombo3();\n                break;\n            case 4:\n                HandleCombo4();\n                return;\n        }\n        \n        _comboResetCoroutine = StartCoroutine(ComboResetTimer());\n    }\n    \n    private void HandleCombo1()\n    {\n        SetObjectColor(_combo1Color);\n        PlaySound(_lowNote, 0.8f);\n    }\n    \n    private void HandleCombo2()\n    {\n        SetObjectColor(_combo2Color);\n        PlaySound(_midNote, 1.0f);\n    }\n    \n    private void HandleCombo3()\n    {\n        SetObjectColor(_combo3Color);\n        PlaySound(_highNote, 1.2f);\n    }\n    \n    private void HandleCombo4()\n    {\n        CreateExplosionEffect();\n        PlaySound(_explosionSound, 1.0f);\n        SpawnBonusObjects();\n        OnComboComplete?.Invoke();\n        ResetCombo();\n    }\n    \n    private void SetObjectColor(Color color)\n    {\n        if (_targetRenderer != null && _originalMaterial != null)\n        {\n            _targetRenderer.material.color = color;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip, float pitch)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.pitch = pitch;\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void CreateExplosionEffect()\n    {\n        if (_explosionEffect != null)\n        {\n            _explosionEffect.Play();\n        }\n    }\n    \n    private void SpawnBonusObjects()\n    {\n        if (_bonusObjectPrefab == null) return;\n        \n        for (int i = 0; i < _bonusObjectCount; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere.normalized;\n            Vector3 spawnPosition = transform.position + randomDirection * _spawnRadius;\n            \n            GameObject bonusObject = Instantiate(_bonusObjectPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody rb = bonusObject.GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = bonusObject.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 forceDirection = (spawnPosition - transform.position).normalized;\n            rb.AddForce(forceDirection * _spawnForce, ForceMode.Impulse);\n            \n            StartCoroutine(DestroyBonusObjectAfterTime(bonusObject, 10f));\n        }\n    }\n    \n    private IEnumerator DestroyBonusObjectAfterTime(GameObject obj, float time)\n    {\n        yield return new WaitForSeconds(time);\n        if (obj != null)\n        {\n            Destroy(obj);\n        }\n    }\n    \n    private IEnumerator ComboResetTimer()\n    {\n        yield return new WaitForSeconds(_comboWindow);\n        ResetCombo();\n    }\n    \n    private void ResetCombo()\n    {\n        _currentComboLevel = 0;\n        SetObjectColor(_normalColor);\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n            _comboResetCoroutine = null;\n        }\n        \n        OnComboReset?.Invoke();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "portal that when entered plays whoosh sound, rotates player 180 degrees instantly, reverses velocity, changes color to random hue, scales to 0.5x size, and teleports to random location within 50 units while creating visual distortion effect",
      "ideal_ir": {
        "class_name": "Portal",
        "components": [
          "AudioSource",
          "Collider",
          "Renderer"
        ],
        "fields": [
          {
            "name": "whooshSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "teleportRange",
            "type": "float",
            "default": 50
          },
          {
            "name": "scaleMultiplier",
            "type": "float",
            "default": 0.5
          },
          {
            "name": "distortionEffect",
            "type": "GameObject",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "portal_entry",
            "trigger": "when player enters portal collider",
            "actions": [
              {
                "action": "play whoosh sound effect"
              },
              {
                "action": "rotate player 180 degrees instantly around vertical axis"
              },
              {
                "action": "reverse player velocity direction"
              },
              {
                "action": "change portal color to random hue"
              },
              {
                "action": "scale portal to half its current size"
              },
              {
                "action": "teleport portal to random location within 50 units"
              },
              {
                "action": "create visual distortion effect at portal location"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Portal : MonoBehaviour\n{\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whooshSound;\n    \n    [Header(\"Portal Settings\")]\n    [SerializeField] private float _teleportRadius = 50f;\n    [SerializeField] private float _scaleMultiplier = 0.5f;\n    [SerializeField] private float _distortionDuration = 1f;\n    [SerializeField] private AnimationCurve _distortionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _portalEffect;\n    [SerializeField] private Material _distortionMaterial;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerTeleported;\n    \n    private Camera _mainCamera;\n    private Material _originalCameraMaterial;\n    private bool _isDistorting = false;\n    private float _distortionTimer = 0f;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        if (_portalEffect == null)\n            _portalEffect = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (_isDistorting)\n        {\n            _distortionTimer += Time.deltaTime;\n            float normalizedTime = _distortionTimer / _distortionDuration;\n            \n            if (normalizedTime >= 1f)\n            {\n                _isDistorting = false;\n                _distortionTimer = 0f;\n                RemoveDistortionEffect();\n            }\n            else\n            {\n                UpdateDistortionEffect(normalizedTime);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            TeleportPlayer(other.gameObject);\n        }\n    }\n    \n    private void TeleportPlayer(GameObject player)\n    {\n        PlayWhooshSound();\n        RotatePlayer180(player);\n        ReversePlayerVelocity(player);\n        ChangePlayerColor(player);\n        ScalePlayer(player);\n        TeleportToRandomLocation(player);\n        CreateDistortionEffect();\n        \n        if (_portalEffect != null)\n            _portalEffect.Play();\n            \n        OnPlayerTeleported?.Invoke();\n    }\n    \n    private void PlayWhooshSound()\n    {\n        if (_audioSource != null && _whooshSound != null)\n        {\n            _audioSource.PlayOneShot(_whooshSound);\n        }\n    }\n    \n    private void RotatePlayer180(GameObject player)\n    {\n        Transform playerTransform = player.transform;\n        playerTransform.rotation = Quaternion.Euler(\n            playerTransform.eulerAngles.x,\n            playerTransform.eulerAngles.y + 180f,\n            playerTransform.eulerAngles.z\n        );\n    }\n    \n    private void ReversePlayerVelocity(GameObject player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.velocity = -playerRb.velocity;\n            playerRb.angularVelocity = -playerRb.angularVelocity;\n        }\n        \n        CharacterController characterController = player.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            Vector3 reversedVelocity = -characterController.velocity;\n            characterController.Move(reversedVelocity * Time.fixedDeltaTime);\n        }\n    }\n    \n    private void ChangePlayerColor(GameObject player)\n    {\n        Renderer playerRenderer = player.GetComponent<Renderer>();\n        if (playerRenderer == null)\n            playerRenderer = player.GetComponentInChildren<Renderer>();\n            \n        if (playerRenderer != null)\n        {\n            Material playerMaterial = playerRenderer.material;\n            Color randomColor = Color.HSVToRGB(Random.Range(0f, 1f), 1f, 1f);\n            playerMaterial.color = randomColor;\n        }\n        \n        Renderer[] childRenderers = player.GetComponentsInChildren<Renderer>();\n        foreach (Renderer renderer in childRenderers)\n        {\n            Color randomColor = Color.HSVToRGB(Random.Range(0f, 1f), 1f, 1f);\n            renderer.material.color = randomColor;\n        }\n    }\n    \n    private void ScalePlayer(GameObject player)\n    {\n        player.transform.localScale *= _scaleMultiplier;\n    }\n    \n    private void TeleportToRandomLocation(GameObject player)\n    {\n        Vector3 randomDirection = Random.insideUnitSphere * _teleportRadius;\n        randomDirection.y = Mathf.Abs(randomDirection.y);\n        \n        Vector3 newPosition = transform.position + randomDirection;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(newPosition + Vector3.up * 100f, Vector3.down, out hit, 200f))\n        {\n            newPosition.y = hit.point.y + 1f;\n        }\n        \n        CharacterController characterController = player.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            player.transform.position = newPosition;\n            characterController.enabled = true;\n        }\n        else\n        {\n            player.transform.position = newPosition;\n        }\n    }\n    \n    private void CreateDistortionEffect()\n    {\n        if (_mainCamera == null) return;\n        \n        _isDistorting = true;\n        _distortionTimer = 0f;\n        \n        if (_distortionMaterial != null)\n        {\n            ApplyDistortionMaterial();\n        }\n        else\n        {\n            CreateScreenShake();\n        }\n    }\n    \n    private void ApplyDistortionMaterial()\n    {\n        if (_mainCamera != null && _distortionMaterial != null)\n        {\n            _mainCamera.GetComponent<Renderer>().material = _distortionMaterial;\n        }\n    }\n    \n    private void UpdateDistortionEffect(float normalizedTime)\n    {\n        float distortionStrength = _distortionCurve.Evaluate(normalizedTime);\n        \n        if (_distortionMaterial != null)\n        {\n            _distortionMaterial.SetFloat(\"_DistortionStrength\", distortionStrength);\n        }\n        \n        CreateScreenShake(distortionStrength * 0.1f);\n    }\n    \n    private void CreateScreenShake(float intensity = 0.1f)\n    {\n        if (_mainCamera != null)\n        {\n            Vector3 originalPosition = _mainCamera.transform.position;\n            Vector3 shakeOffset = Random.insideUnitSphere * intensity;\n            _mainCamera.transform.position = originalPosition + shakeOffset;\n            \n            StartCoroutine(ResetCameraPosition(originalPosition));\n        }\n    }\n    \n    private System.Collections.IEnumerator ResetCameraPosition(Vector3 originalPosition)\n    {\n        yield return new WaitForEndOfFrame();\n        if (_mainCamera != null)\n        {\n            _mainCamera.transform.position = Vector3.Lerp(\n                _mainCamera.transform.position, \n                originalPosition, \n                Time.deltaTime * 10f\n            );\n        }\n    }\n    \n    private void RemoveDistortionEffect()\n    {\n        if (_mainCamera != null && _originalCameraMaterial != null)\n        {\n            _mainCamera.GetComponent<Renderer>().material = _originalCameraMaterial;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _teleportRadius);\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "mimic chest that looks normal until player gets within 3 units, then opens its lid, reveals glowing eyes - if touched it snaps shut, applies strong force pushing player away, and spawns 3 smaller mimic objects that chase player",
      "ideal_ir": {
        "class_name": "MimicChest",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 3.0
          },
          {
            "name": "pushForce",
            "type": "float",
            "default": 15.0
          },
          {
            "name": "smallMimicPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "lidObject",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "eyesObject",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "isRevealed",
            "type": "bool",
            "default": false
          },
          {
            "name": "hasBeenTriggered",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "reveal_mimic",
            "trigger": "when player enters detection range and mimic has not been revealed",
            "actions": [
              {
                "action": "slowly open the chest lid"
              },
              {
                "action": "make glowing eyes visible and start glowing animation"
              },
              {
                "action": "play ominous reveal sound"
              },
              {
                "action": "set revealed state to true"
              }
            ]
          },
          {
            "name": "snap_and_push",
            "trigger": "when player touches the mimic chest",
            "actions": [
              {
                "action": "quickly snap the lid shut"
              },
              {
                "action": "hide the glowing eyes"
              },
              {
                "action": "apply strong pushing force away from chest toward player"
              },
              {
                "action": "play loud snapping sound"
              },
              {
                "action": "set triggered state to true"
              }
            ]
          },
          {
            "name": "spawn_mini_mimics",
            "trigger": "when mimic has been triggered and touched",
            "actions": [
              {
                "action": "spawn three smaller mimic objects around the chest"
              },
              {
                "action": "make each spawned mimic start chasing the player"
              },
              {
                "action": "play spawning sound effect"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MimicChest : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _lidTransform;\n    [SerializeField] private GameObject _eyesObject;\n    [SerializeField] private Light _eyeGlow;\n    [SerializeField] private float _lidOpenAngle = 45f;\n    [SerializeField] private float _lidAnimationSpeed = 2f;\n    \n    [Header(\"Attack\")]\n    [SerializeField] private float _pushForce = 15f;\n    [SerializeField] private float _pushRadius = 2f;\n    [SerializeField] private float _snapSpeed = 5f;\n    \n    [Header(\"Minion Spawning\")]\n    [SerializeField] private GameObject _miniMimicPrefab;\n    [SerializeField] private int _spawnCount = 3;\n    [SerializeField] private float _spawnRadius = 2f;\n    [SerializeField] private float _spawnHeight = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _revealSound;\n    [SerializeField] private AudioClip _snapSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    private bool _isRevealed = false;\n    private bool _hasAttacked = false;\n    private Transform _playerTransform;\n    private Quaternion _lidClosedRotation;\n    private Quaternion _lidOpenRotation;\n    private Coroutine _lidAnimationCoroutine;\n    private List<GameObject> _spawnedMinions = new List<GameObject>();\n    \n    private void Start()\n    {\n        if (_lidTransform != null)\n        {\n            _lidClosedRotation = _lidTransform.localRotation;\n            _lidOpenRotation = _lidClosedRotation * Quaternion.Euler(-_lidOpenAngle, 0, 0);\n        }\n        \n        if (_eyesObject != null)\n            _eyesObject.SetActive(false);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = false;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        if (_hasAttacked) return;\n        \n        FindPlayer();\n        \n        if (_playerTransform != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n            \n            if (!_isRevealed && distanceToPlayer <= _detectionRange)\n            {\n                RevealMimic();\n            }\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n    }\n    \n    private void RevealMimic()\n    {\n        _isRevealed = true;\n        \n        if (_eyesObject != null)\n            _eyesObject.SetActive(true);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = true;\n            \n        if (_lidAnimationCoroutine != null)\n            StopCoroutine(_lidAnimationCoroutine);\n            \n        _lidAnimationCoroutine = StartCoroutine(AnimateLid(_lidOpenRotation));\n        \n        PlaySound(_revealSound);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasAttacked) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            Attack(other);\n        }\n    }\n    \n    private void OnMouseDown()\n    {\n        if (_hasAttacked) return;\n        \n        Collider playerCollider = FindObjectOfType<Collider>();\n        if (playerCollider != null && playerCollider.CompareTag(\"Player\"))\n        {\n            Attack(playerCollider);\n        }\n    }\n    \n    private void Attack(Collider playerCollider)\n    {\n        _hasAttacked = true;\n        \n        StartCoroutine(AttackSequence(playerCollider));\n    }\n    \n    private IEnumerator AttackSequence(Collider playerCollider)\n    {\n        // Snap shut\n        if (_lidAnimationCoroutine != null)\n            StopCoroutine(_lidAnimationCoroutine);\n            \n        _lidAnimationCoroutine = StartCoroutine(AnimateLid(_lidClosedRotation, _snapSpeed));\n        \n        PlaySound(_snapSound);\n        \n        // Hide eyes\n        if (_eyesObject != null)\n            _eyesObject.SetActive(false);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = false;\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        // Push player away\n        PushPlayerAway(playerCollider);\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        // Spawn minions\n        SpawnMinions();\n    }\n    \n    private void PushPlayerAway(Collider playerCollider)\n    {\n        Rigidbody playerRb = playerCollider.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            Vector3 pushDirection = (playerCollider.transform.position - transform.position).normalized;\n            pushDirection.y = 0.3f; // Add slight upward force\n            \n            playerRb.AddForce(pushDirection * _pushForce, ForceMode.Impulse);\n        }\n        \n        // Also push any other rigidbodies in range\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _pushRadius);\n        foreach (Collider col in nearbyObjects)\n        {\n            if (col != playerCollider && col.attachedRigidbody != null && !col.CompareTag(\"MiniMimic\"))\n            {\n                Vector3 pushDirection = (col.transform.position - transform.position).normalized;\n                col.attachedRigidbody.AddForce(pushDirection * (_pushForce * 0.5f), ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void SpawnMinions()\n    {\n        if (_miniMimicPrefab == null) return;\n        \n        PlaySound(_spawnSound);\n        \n        for (int i = 0; i < _spawnCount; i++)\n        {\n            float angle = (360f / _spawnCount) * i;\n            Vector3 spawnOffset = new Vector3(\n                Mathf.Cos(angle * Mathf.Deg2Rad) * _spawnRadius,\n                _spawnHeight,\n                Mathf.Sin(angle * Mathf.Deg2Rad) * _spawnRadius\n            );\n            \n            Vector3 spawnPosition = transform.position + spawnOffset;\n            \n            GameObject minion = Instantiate(_miniMimicPrefab, spawnPosition, Quaternion.identity);\n            _spawnedMinions.Add(minion);\n            \n            // Add chase behavior to minion\n            MiniMimicChaser chaser = minion.GetComponent<MiniMimicChaser>();\n            if (chaser == null)\n                chaser = minion.AddComponent<MiniMimicChaser>();\n        }\n    }\n    \n    private IEnumerator AnimateLid(Quaternion targetRotation, float speed = -1f)\n    {\n        if (_lidTransform == null) yield break;\n        \n        float animSpeed = speed > 0 ? speed : _lidAnimationSpeed;\n        Quaternion startRotation = _lidTransform.localRotation;\n        float elapsed = 0f;\n        float duration = 1f / animSpeed;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            _lidTransform.localRotation = Quaternion.Slerp(startRotation, targetRotation, t);\n            yield return null;\n        }\n        \n        _lidTransform.localRotation = targetRotation;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _pushRadius);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n    }\n}\n\npublic class MiniMimicChaser : MonoBehaviour\n{\n    [Header(\"Chase Behavior\")]\n    [SerializeField] private float _chaseSpeed = 3f;\n    [SerializeField] private float _jumpForce = 5f;\n    [SerializeField] private float _jumpCooldown = 2f;\n    [SerializeField] private float _attackRange = 1f;\n    [SerializeField] private float _lifetime = 30f;\n    \n    private Transform _playerTransform;\n    private Rigidbody _rigidbody;\n    private float _lastJumpTime;\n    private bool _isGrounded = true;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        gameObject.tag = \"MiniMimic\";\n        \n        FindPlayer();\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void Update()\n    {\n        FindPlayer();\n        \n        if (_playerTransform != null)\n        {\n            ChasePlayer();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n    }\n    \n    private void ChasePlayer()\n    {\n        Vector3 directionToPlayer = (_playerTransform.position - transform.position).normalized;\n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer > _attackRange)\n        {\n            // Move towards player\n            Vector3 moveDirection = new Vector3(directionToPlayer.x, 0, directionToPlayer.z);\n            transform.position += moveDirection * _chaseSpeed * Time.deltaTime;\n            \n            // Look at player\n            transform.LookAt(new Vector3(_playerTransform.position.x, transform.position.y, _playerTransform.position.z));\n            \n            // Jump if grounded and cooldown elapsed\n            if (_isGrounded && Time.time - _lastJumpTime > _jumpCooldown)\n            {\n                Jump();\n            }\n        }\n    }\n    \n    private void Jump()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n            _lastJumpTime = Time.time;\n            _isGrounded = false;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Ground\") || collision.contacts[0].normal.y > 0.7f)\n        {\n            _isGrounded = true;\n        }\n        \n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            // Mini attack - small push\n            Rigidbody playerRb = collision.rigidbody;\n            if (playerRb != null)\n            {\n                Vector3 pushDirection = (collision.transform.position - transform.position).normalized;\n                playerRb.AddForce(pushDirection * 3f, ForceMode.Impulse);\n            }\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "weather controller that when activated spawns rain particles falling downward, plays rain sound effects, makes all objects dampen (reduce bounce), changes ambient lighting to darker, and after 10 seconds spawns lightning bolts with thunder sounds",
      "ideal_ir": {
        "class_name": "WeatherController",
        "components": [
          "ParticleSystem",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "rainParticles",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "rainAudioSource",
            "type": "AudioSource",
            "default": null
          },
          {
            "name": "thunderAudioSource",
            "type": "AudioSource",
            "default": null
          },
          {
            "name": "lightningParticles",
            "type": "ParticleSystem",
            "default": null
          },
          {
            "name": "ambientLight",
            "type": "Light",
            "default": null
          },
          {
            "name": "originalLightIntensity",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "darkenedLightIntensity",
            "type": "float",
            "default": 0.3
          },
          {
            "name": "weatherDuration",
            "type": "float",
            "default": 10.0
          },
          {
            "name": "isWeatherActive",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "activate_weather",
            "trigger": "when weather controller is activated",
            "actions": [
              {
                "action": "start rain particle system with downward falling particles"
              },
              {
                "action": "play rain sound effects on loop"
              },
              {
                "action": "reduce bounce properties of all physics materials in scene"
              },
              {
                "action": "darken ambient lighting to create stormy atmosphere"
              },
              {
                "action": "set weather active state to true"
              },
              {
                "action": "start countdown timer for lightning phase"
              }
            ]
          },
          {
            "name": "spawn_lightning",
            "trigger": "when weather has been active for specified duration",
            "actions": [
              {
                "action": "spawn lightning bolt particle effects at random sky positions"
              },
              {
                "action": "play thunder sound effects with dramatic volume"
              },
              {
                "action": "briefly flash ambient lighting to simulate lightning illumination"
              }
            ]
          },
          {
            "name": "deactivate_weather",
            "trigger": "when weather controller is deactivated",
            "actions": [
              {
                "action": "stop rain particle system"
              },
              {
                "action": "stop rain sound effects"
              },
              {
                "action": "restore original bounce properties to all physics materials"
              },
              {
                "action": "restore original ambient lighting intensity"
              },
              {
                "action": "stop lightning and thunder effects"
              },
              {
                "action": "set weather active state to false"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class WeatherController : MonoBehaviour\n{\n    [Header(\"Rain Settings\")]\n    [SerializeField] private ParticleSystem _rainParticles;\n    [SerializeField] private AudioSource _rainAudioSource;\n    [SerializeField] private AudioClip _rainSoundClip;\n    [SerializeField] private float _rainIntensity = 1000f;\n    [SerializeField] private float _rainArea = 50f;\n    \n    [Header(\"Lightning Settings\")]\n    [SerializeField] private GameObject _lightningBoltPrefab;\n    [SerializeField] private AudioSource _thunderAudioSource;\n    [SerializeField] private AudioClip[] _thunderSoundClips;\n    [SerializeField] private float _lightningDelay = 10f;\n    [SerializeField] private float _lightningInterval = 3f;\n    [SerializeField] private int _lightningCount = 5;\n    [SerializeField] private float _lightningHeight = 20f;\n    \n    [Header(\"Lighting Settings\")]\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _stormLightColor = new Color(0.3f, 0.3f, 0.4f, 1f);\n    [SerializeField] private float _normalLightIntensity = 1f;\n    [SerializeField] private float _stormLightIntensity = 0.3f;\n    [SerializeField] private float _lightTransitionSpeed = 2f;\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _normalBounciness = 0.6f;\n    [SerializeField] private float _wetBounciness = 0.2f;\n    [SerializeField] private string[] _affectedTags = { \"Ground\", \"Wall\", \"Platform\" };\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWeatherStart;\n    public UnityEvent OnLightningStrike;\n    public UnityEvent OnWeatherEnd;\n    \n    private bool _isWeatherActive = false;\n    private List<PhysicMaterial> _originalMaterials = new List<PhysicMaterial>();\n    private List<Collider> _affectedColliders = new List<Collider>();\n    private Coroutine _weatherCoroutine;\n    private Coroutine _lightningCoroutine;\n    private Coroutine _lightTransitionCoroutine;\n    \n    private void Start()\n    {\n        SetupComponents();\n        StoreOriginalMaterials();\n    }\n    \n    private void SetupComponents()\n    {\n        if (_rainParticles == null)\n        {\n            GameObject rainObj = new GameObject(\"RainParticles\");\n            rainObj.transform.SetParent(transform);\n            _rainParticles = rainObj.AddComponent<ParticleSystem>();\n            SetupRainParticles();\n        }\n        \n        if (_rainAudioSource == null)\n        {\n            _rainAudioSource = gameObject.AddComponent<AudioSource>();\n            _rainAudioSource.loop = true;\n            _rainAudioSource.volume = 0.5f;\n        }\n        \n        if (_thunderAudioSource == null)\n        {\n            _thunderAudioSource = gameObject.AddComponent<AudioSource>();\n            _thunderAudioSource.volume = 0.8f;\n        }\n        \n        if (_sunLight == null)\n        {\n            _sunLight = FindObjectOfType<Light>();\n        }\n        \n        if (_lightningBoltPrefab == null)\n        {\n            CreateLightningBoltPrefab();\n        }\n    }\n    \n    private void SetupRainParticles()\n    {\n        var main = _rainParticles.main;\n        main.startLifetime = 2f;\n        main.startSpeed = 10f;\n        main.startSize = 0.1f;\n        main.startColor = new Color(0.7f, 0.8f, 1f, 0.8f);\n        main.maxParticles = (int)_rainIntensity;\n        \n        var emission = _rainParticles.emission;\n        emission.rateOverTime = _rainIntensity / 2f;\n        \n        var shape = _rainParticles.shape;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(_rainArea, 1f, _rainArea);\n        \n        var velocityOverLifetime = _rainParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = -15f;\n        \n        _rainParticles.transform.position = transform.position + Vector3.up * 15f;\n    }\n    \n    private void CreateLightningBoltPrefab()\n    {\n        GameObject lightningObj = new GameObject(\"LightningBolt\");\n        LineRenderer lr = lightningObj.AddComponent<LineRenderer>();\n        lr.material = new Material(Shader.Find(\"Sprites/Default\"));\n        lr.color = Color.white;\n        lr.startWidth = 0.3f;\n        lr.endWidth = 0.1f;\n        lr.positionCount = 10;\n        \n        Light lightningLight = lightningObj.AddComponent<Light>();\n        lightningLight.type = LightType.Point;\n        lightningLight.color = Color.white;\n        lightningLight.intensity = 8f;\n        lightningLight.range = 30f;\n        \n        lightningObj.AddComponent<LightningBolt>();\n        _lightningBoltPrefab = lightningObj;\n    }\n    \n    private void StoreOriginalMaterials()\n    {\n        foreach (string tag in _affectedTags)\n        {\n            GameObject[] objects = GameObject.FindGameObjectsWithTag(tag);\n            foreach (GameObject obj in objects)\n            {\n                Collider col = obj.GetComponent<Collider>();\n                if (col != null)\n                {\n                    _affectedColliders.Add(col);\n                    if (col.material != null)\n                    {\n                        _originalMaterials.Add(col.material);\n                    }\n                    else\n                    {\n                        _originalMaterials.Add(null);\n                    }\n                }\n            }\n        }\n    }\n    \n    public void ActivateWeather()\n    {\n        if (_isWeatherActive) return;\n        \n        _isWeatherActive = true;\n        _weatherCoroutine = StartCoroutine(WeatherSequence());\n        OnWeatherStart?.Invoke();\n    }\n    \n    public void DeactivateWeather()\n    {\n        if (!_isWeatherActive) return;\n        \n        _isWeatherActive = false;\n        \n        if (_weatherCoroutine != null)\n            StopCoroutine(_weatherCoroutine);\n        \n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        StopRain();\n        RestorePhysics();\n        RestoreLighting();\n        \n        OnWeatherEnd?.Invoke();\n    }\n    \n    private IEnumerator WeatherSequence()\n    {\n        StartRain();\n        DampenPhysics();\n        DarkenLighting();\n        \n        yield return new WaitForSeconds(_lightningDelay);\n        \n        _lightningCoroutine = StartCoroutine(LightningSequence());\n    }\n    \n    private void StartRain()\n    {\n        if (_rainParticles != null)\n        {\n            _rainParticles.Play();\n        }\n        \n        if (_rainAudioSource != null && _rainSoundClip != null)\n        {\n            _rainAudioSource.clip = _rainSoundClip;\n            _rainAudioSource.Play();\n        }\n    }\n    \n    private void StopRain()\n    {\n        if (_rainParticles != null)\n        {\n            _rainParticles.Stop();\n        }\n        \n        if (_rainAudioSource != null)\n        {\n            _rainAudioSource.Stop();\n        }\n    }\n    \n    private void DampenPhysics()\n    {\n        PhysicMaterial wetMaterial = new PhysicMaterial(\"WetMaterial\");\n        wetMaterial.bounciness = _wetBounciness;\n        wetMaterial.dynamicFriction = 0.8f;\n        wetMaterial.staticFriction = 0.9f;\n        \n        foreach (Collider col in _affectedColliders)\n        {\n            if (col != null)\n            {\n                col.material = wetMaterial;\n            }\n        }\n    }\n    \n    private void RestorePhysics()\n    {\n        for (int i = 0; i < _affectedColliders.Count && i < _originalMaterials.Count; i++)\n        {\n            if (_affectedColliders[i] != null)\n            {\n                _affectedColliders[i].material = _originalMaterials[i];\n            }\n        }\n    }\n    \n    private void DarkenLighting()\n    {\n        if (_lightTransitionCoroutine != null)\n            StopCoroutine(_lightTransitionCoroutine);\n        \n        _lightTransitionCoroutine = StartCoroutine(TransitionLighting(_stormLightColor, _stormLightIntensity));\n    }\n    \n    private void RestoreLighting()\n    {\n        if (_lightTransitionCoroutine != null)\n            StopCoroutine(_lightTransitionCoroutine);\n        \n        _lightTransitionCoroutine = StartCoroutine(TransitionLighting(_normalLightColor, _normalLightIntensity));\n    }\n    \n    private IEnumerator TransitionLighting(Color targetColor, float targetIntensity)\n    {\n        if (_sunLight == null) yield break;\n        \n        Color startColor = _sunLight.color;\n        float startIntensity = _sunLight.intensity;\n        float elapsed = 0f;\n        \n        while (elapsed < 1f)\n        {\n            elapsed += Time.deltaTime * _lightTransitionSpeed;\n            float t = Mathf.SmoothStep(0f, 1f, elapsed);\n            \n            _sunLight.color = Color.Lerp(startColor, targetColor, t);\n            _sunLight.intensity = Mathf.Lerp(startIntensity, targetIntensity, t);\n            \n            yield return null;\n        }\n        \n        _sunLight.color = targetColor;\n        _sunLight.intensity = targetIntensity;\n    }\n    \n    private IEnumerator LightningSequence()\n    {\n        for (int i = 0; i < _lightningCount; i++)\n        {\n            if (!_isWeatherActive) yield break;\n            \n            SpawnLightning();\n            yield return new WaitForSeconds(_lightningInterval + Random.Range(-1f, 1f));\n        }\n    }\n    \n    private void SpawnLightning()\n    {\n        if (_lightningBoltPrefab == null) return;\n        \n        Vector3 spawnPos = transform.position + new Vector3(\n            Random.Range(-_rainArea / 2f, _rainArea / 2f),\n            _lightningHeight,\n            Random.Range(-_rainArea / 2f, _rainArea / 2f)\n        );\n        \n        GameObject lightning = Instantiate(_lightningBoltPrefab, spawnPos, Quaternion.identity);\n        \n        if (_thunderAudioSource != null && _thunderSoundClips.Length > 0)\n        {\n            AudioClip thunderClip = _thunderSoundClips[Random.Range(0, _thunderSoundClips.Length)];\n            _thunderAudioSource.PlayOneShot(thunderClip);\n        }\n        \n        OnLightningStrike?.Invoke();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ActivateWeather();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position, new Vector3(_rainArea, 1f, _rainArea));\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.up * _lightningHeight, 2f);\n    }\n}\n\npublic class LightningBolt : MonoBehaviour\n{\n    private LineRenderer _lineRenderer;\n    private Light _lightningLight;\n    private float _duration = 0.2f;\n    private float _flickerTime = 0.05f;\n    \n    private void Start()\n    {\n        _lineRenderer = GetComponent<LineRenderer>();\n        _lightningLight = GetComponent<Light>();\n        \n        GenerateLightningPath();\n        StartCoroutine(LightningEffect());\n    }\n    \n    private void GenerateLightningPath()\n    {\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + Vector3.down * 20f;\n        \n        Vector3[] positions = new Vector3[_lineRenderer.positionCount];\n        \n        for (int i = 0; i < positions.Length; i++)\n        {\n            float t = (float)i / (positions.Length - 1);\n            Vector3 basePos = Vector3.Lerp(startPos, endPos, t);\n            \n            if (i > 0 && i < positions.Length - 1)\n            {\n                basePos += new Vector3(\n                    Random.Range(-2f, 2f),\n                    0f,\n                    Random.Range(-2f, 2f)\n                );\n            }\n            \n            positions[i] = basePos;\n        }\n        \n        _lineRenderer.SetPositions(positions);\n    }\n    \n    private IEnumerator LightningEffect()\n    {\n        float elapsed = 0f;\n        \n        while (elapsed < _duration)\n        {\n            bool isVisible = (elapsed % _flickerTime) < (_flickerTime * 0.7f);\n            _lineRenderer.enabled = isVisible;\n            _lightningLight.enabled = isVisible;\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        Destroy(gameObject);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "gravity field that inverts gravity for all objects within its radius, plays space-warp sound, creates visual distortion effect - objects entering should smoothly transition gravity direction over 1 second",
      "ideal_ir": {
        "class_name": "GravityField",
        "components": [
          "SphereCollider",
          "AudioSource",
          "ParticleSystem"
        ],
        "fields": [
          {
            "name": "fieldRadius",
            "type": "float",
            "default": 10
          },
          {
            "name": "transitionDuration",
            "type": "float",
            "default": 1
          },
          {
            "name": "spaceWarpSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "distortionEffect",
            "type": "ParticleSystem",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "detect_object_entry",
            "trigger": "when rigidbody object enters the gravity field trigger zone",
            "actions": [
              {
                "action": "play space warp sound effect"
              },
              {
                "action": "activate visual distortion particle effect"
              },
              {
                "action": "begin smooth gravity inversion transition for the entering object over one second duration"
              }
            ]
          },
          {
            "name": "detect_object_exit",
            "trigger": "when rigidbody object exits the gravity field trigger zone",
            "actions": [
              {
                "action": "begin smooth gravity restoration transition for the exiting object over one second duration"
              },
              {
                "action": "deactivate visual distortion effect for that object"
              }
            ]
          },
          {
            "name": "maintain_inverted_gravity",
            "trigger": "while rigidbody object remains within the gravity field",
            "actions": [
              {
                "action": "apply inverted gravity force to the object"
              },
              {
                "action": "maintain visual distortion effect around the object"
              }
            ]
          },
          {
            "name": "update_transition_progress",
            "trigger": "during gravity transition period for any object",
            "actions": [
              {
                "action": "smoothly interpolate gravity direction from normal to inverted or vice versa"
              },
              {
                "action": "update visual effect intensity based on transition progress"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class GravityField : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _fieldRadius = 5f;\n    [SerializeField] private float _transitionDuration = 1f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _spaceWarpSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _distortionMaterial;\n    [SerializeField] private float _distortionStrength = 0.1f;\n    [SerializeField] private float _distortionSpeed = 2f;\n    [SerializeField] private Color _fieldColor = Color.cyan;\n    [SerializeField] private float _fieldAlpha = 0.3f;\n    \n    private AudioSource _audioSource;\n    private SphereCollider _triggerCollider;\n    private Dictionary<Rigidbody, GravityTransition> _affectedObjects = new Dictionary<Rigidbody, GravityTransition>();\n    private MeshRenderer _fieldRenderer;\n    private Material _fieldMaterial;\n    private float _distortionTime;\n    \n    [System.Serializable]\n    private class GravityTransition\n    {\n        public Rigidbody rigidbody;\n        public bool isInField;\n        public float transitionProgress;\n        public Vector3 originalGravity;\n        public Vector3 targetGravity;\n        public Coroutine transitionCoroutine;\n        \n        public GravityTransition(Rigidbody rb)\n        {\n            rigidbody = rb;\n            isInField = false;\n            transitionProgress = 0f;\n            originalGravity = Physics.gravity;\n            targetGravity = -Physics.gravity;\n        }\n    }\n    \n    void Start()\n    {\n        SetupAudioSource();\n        SetupTriggerCollider();\n        SetupVisualField();\n    }\n    \n    void Update()\n    {\n        UpdateDistortionEffect();\n        UpdateGravityTransitions();\n    }\n    \n    void SetupAudioSource()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _spaceWarpSound;\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n        _audioSource.rolloffMode = AudioRolloffMode.Linear;\n        _audioSource.maxDistance = _fieldRadius * 2f;\n    }\n    \n    void SetupTriggerCollider()\n    {\n        _triggerCollider = GetComponent<SphereCollider>();\n        if (_triggerCollider == null)\n        {\n            _triggerCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _triggerCollider.isTrigger = true;\n        _triggerCollider.radius = _fieldRadius;\n    }\n    \n    void SetupVisualField()\n    {\n        GameObject fieldSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        DestroyImmediate(fieldSphere.GetComponent<SphereCollider>());\n        \n        fieldSphere.transform.SetParent(transform);\n        fieldSphere.transform.localPosition = Vector3.zero;\n        fieldSphere.transform.localScale = Vector3.one * (_fieldRadius * 2f);\n        \n        _fieldRenderer = fieldSphere.GetComponent<MeshRenderer>();\n        \n        if (_distortionMaterial != null)\n        {\n            _fieldMaterial = new Material(_distortionMaterial);\n        }\n        else\n        {\n            _fieldMaterial = new Material(Shader.Find(\"Standard\"));\n            _fieldMaterial.SetFloat(\"_Mode\", 3);\n            _fieldMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            _fieldMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            _fieldMaterial.SetInt(\"_ZWrite\", 0);\n            _fieldMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            _fieldMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            _fieldMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            _fieldMaterial.renderQueue = 3000;\n        }\n        \n        Color fieldColor = _fieldColor;\n        fieldColor.a = _fieldAlpha;\n        _fieldMaterial.color = fieldColor;\n        _fieldRenderer.material = _fieldMaterial;\n    }\n    \n    void UpdateDistortionEffect()\n    {\n        if (_fieldMaterial == null) return;\n        \n        _distortionTime += Time.deltaTime * _distortionSpeed;\n        \n        float distortion = Mathf.Sin(_distortionTime) * _distortionStrength;\n        Vector2 offset = new Vector2(distortion, distortion * 0.5f);\n        \n        if (_fieldMaterial.HasProperty(\"_MainTex\"))\n        {\n            _fieldMaterial.SetTextureOffset(\"_MainTex\", offset);\n        }\n        \n        float pulse = (Mathf.Sin(_distortionTime * 2f) + 1f) * 0.5f;\n        Color currentColor = _fieldColor;\n        currentColor.a = _fieldAlpha * (0.7f + pulse * 0.3f);\n        _fieldMaterial.color = currentColor;\n    }\n    \n    void UpdateGravityTransitions()\n    {\n        List<Rigidbody> toRemove = new List<Rigidbody>();\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            var transition = kvp.Value;\n            if (transition.rigidbody == null)\n            {\n                toRemove.Add(kvp.Key);\n                continue;\n            }\n            \n            if (transition.transitionCoroutine == null && transition.transitionProgress < 1f)\n            {\n                Vector3 currentGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, transition.transitionProgress);\n                ApplyGravityToRigidbody(transition.rigidbody, currentGravity);\n            }\n        }\n        \n        foreach (var rb in toRemove)\n        {\n            _affectedObjects.Remove(rb);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!IsValidTarget(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        if (!_affectedObjects.ContainsKey(rb))\n        {\n            _affectedObjects[rb] = new GravityTransition(rb);\n        }\n        \n        var transition = _affectedObjects[rb];\n        if (!transition.isInField)\n        {\n            transition.isInField = true;\n            transition.targetGravity = -Physics.gravity;\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n            \n            transition.transitionCoroutine = StartCoroutine(TransitionGravity(transition, true));\n            PlaySpaceWarpSound();\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (!IsValidTarget(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null || !_affectedObjects.ContainsKey(rb)) return;\n        \n        var transition = _affectedObjects[rb];\n        if (transition.isInField)\n        {\n            transition.isInField = false;\n            transition.targetGravity = Physics.gravity;\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n            \n            transition.transitionCoroutine = StartCoroutine(TransitionGravity(transition, false));\n        }\n    }\n    \n    bool IsValidTarget(Collider other)\n    {\n        return (_affectedLayers.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    IEnumerator TransitionGravity(GravityTransition transition, bool enteringField)\n    {\n        float startProgress = transition.transitionProgress;\n        float targetProgress = enteringField ? 1f : 0f;\n        float elapsedTime = 0f;\n        \n        Vector3 startGravity = Vector3.Lerp(transition.originalGravity, -transition.originalGravity, startProgress);\n        \n        while (elapsedTime < _transitionDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / _transitionDuration;\n            float smoothProgress = Mathf.SmoothStep(startProgress, targetProgress, normalizedTime);\n            \n            transition.transitionProgress = smoothProgress;\n            \n            Vector3 currentGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, smoothProgress);\n            ApplyGravityToRigidbody(transition.rigidbody, currentGravity);\n            \n            yield return null;\n        }\n        \n        transition.transitionProgress = targetProgress;\n        Vector3 finalGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, targetProgress);\n        ApplyGravityToRigidbody(transition.rigidbody, finalGravity);\n        \n        transition.transitionCoroutine = null;\n        \n        if (!enteringField && targetProgress <= 0f)\n        {\n            _affectedObjects.Remove(transition.rigidbody);\n        }\n    }\n    \n    void ApplyGravityToRigidbody(Rigidbody rb, Vector3 gravity)\n    {\n        if (rb == null) return;\n        \n        rb.useGravity = false;\n        rb.AddForce(gravity * rb.mass, ForceMode.Force);\n    }\n    \n    void PlaySpaceWarpSound()\n    {\n        if (_audioSource != null && _spaceWarpSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_spaceWarpSound, _audioVolume);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _fieldColor;\n        Gizmos.DrawWireSphere(transform.position, _fieldRadius);\n        \n        Gizmos.color = new Color(_fieldColor.r, _fieldColor.g, _fieldColor.b, 0.1f);\n        Gizmos.DrawSphere(transform.position, _fieldRadius);\n    }\n    \n    void OnDestroy()\n    {\n        foreach (var kvp in _affectedObjects)\n        {\n            var transition = kvp.Value;\n            if (transition.rigidbody != null)\n            {\n                transition.rigidbody.useGravity = true;\n            }\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n        }\n        \n        _affectedObjects.Clear();\n        \n        if (_fieldMaterial != null)\n        {\n            DestroyImmediate(_fieldMaterial);\n        }\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "script that counts its own Update calls and every 1000 calls plays a different sound, changes its material, and spawns a clone of itself - each generation plays slightly higher-pitched sound than parent",
      "ideal_ir": {
        "class_name": "GenerationalCounter",
        "components": [
          "AudioSource",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "updateCallCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "generation",
            "type": "int",
            "default": 0
          },
          {
            "name": "soundClips",
            "type": "AudioClip[]",
            "default": null
          },
          {
            "name": "materials",
            "type": "Material[]",
            "default": null
          },
          {
            "name": "basePitch",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "pitchIncrement",
            "type": "float",
            "default": 0.1
          }
        ],
        "behaviors": [
          {
            "name": "count_updates",
            "trigger": "every frame during Update",
            "actions": [
              {
                "action": "increment the update call counter by one"
              }
            ]
          },
          {
            "name": "thousand_call_milestone",
            "trigger": "when update call count reaches exactly one thousand",
            "actions": [
              {
                "action": "play a random sound from the sound clips array"
              },
              {
                "action": "set audio source pitch to base pitch plus generation multiplied by pitch increment"
              },
              {
                "action": "change mesh renderer material to a random material from the materials array"
              },
              {
                "action": "create a clone of this game object at the same position"
              },
              {
                "action": "set the clone's generation to current generation plus one"
              },
              {
                "action": "reset update call count to zero"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\n\npublic class SelfReplicatingCounter : MonoBehaviour\n{\n    [Header(\"Counter Settings\")]\n    [SerializeField] private int _updateCallsPerGeneration = 1000;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _baseSound;\n    [SerializeField] private float _pitchIncrement = 0.2f;\n    [SerializeField] private float _basePitch = 1.0f;\n    \n    [Header(\"Material Settings\")]\n    [SerializeField] private Material[] _generationMaterials;\n    [SerializeField] private Color[] _generationColors;\n    \n    [Header(\"Spawning Settings\")]\n    [SerializeField] private Vector3 _spawnOffset = Vector3.right * 2f;\n    [SerializeField] private int _maxGenerations = 10;\n    \n    private int _updateCallCount = 0;\n    private int _generation = 0;\n    private float _currentPitch;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _materialInstance;\n\n    private void Start()\n    {\n        InitializeComponents();\n        SetupGeneration();\n    }\n\n    private void Update()\n    {\n        _updateCallCount++;\n        \n        if (_updateCallCount >= _updateCallsPerGeneration)\n        {\n            ProcessGeneration();\n            _updateCallCount = 0;\n        }\n    }\n\n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null && _renderer.material != null)\n        {\n            _materialInstance = new Material(_renderer.material);\n            _renderer.material = _materialInstance;\n        }\n    }\n\n    private void SetupGeneration()\n    {\n        _currentPitch = _basePitch + (_generation * _pitchIncrement);\n        \n        if (_audioSource != null)\n        {\n            _audioSource.pitch = _currentPitch;\n            _audioSource.clip = _baseSound;\n        }\n        \n        UpdateVisuals();\n    }\n\n    private void ProcessGeneration()\n    {\n        PlayGenerationSound();\n        ChangeMaterial();\n        \n        if (_generation < _maxGenerations)\n        {\n            SpawnClone();\n        }\n    }\n\n    private void PlayGenerationSound()\n    {\n        if (_audioSource != null && _baseSound != null)\n        {\n            _audioSource.pitch = _currentPitch;\n            _audioSource.PlayOneShot(_baseSound);\n        }\n    }\n\n    private void ChangeMaterial()\n    {\n        if (_renderer == null) return;\n\n        if (_generationMaterials != null && _generationMaterials.Length > 0)\n        {\n            int materialIndex = _generation % _generationMaterials.Length;\n            if (_generationMaterials[materialIndex] != null)\n            {\n                if (_materialInstance != null)\n                {\n                    DestroyImmediate(_materialInstance);\n                }\n                _materialInstance = new Material(_generationMaterials[materialIndex]);\n                _renderer.material = _materialInstance;\n            }\n        }\n        else if (_generationColors != null && _generationColors.Length > 0)\n        {\n            int colorIndex = _generation % _generationColors.Length;\n            if (_materialInstance != null)\n            {\n                _materialInstance.color = _generationColors[colorIndex];\n            }\n        }\n        else\n        {\n            // Fallback: Generate random color based on generation\n            if (_materialInstance != null)\n            {\n                float hue = (_generation * 0.1f) % 1.0f;\n                _materialInstance.color = Color.HSVToRGB(hue, 0.8f, 1.0f);\n            }\n        }\n    }\n\n    private void SpawnClone()\n    {\n        Vector3 spawnPosition = transform.position + _spawnOffset;\n        GameObject clone = Instantiate(gameObject, spawnPosition, transform.rotation);\n        \n        SelfReplicatingCounter cloneScript = clone.GetComponent<SelfReplicatingCounter>();\n        if (cloneScript != null)\n        {\n            cloneScript._generation = _generation + 1;\n            cloneScript.SetupGeneration();\n        }\n    }\n\n    private void UpdateVisuals()\n    {\n        // Scale slightly based on generation for visual feedback\n        float scaleMultiplier = 1.0f + (_generation * 0.05f);\n        transform.localScale = Vector3.one * scaleMultiplier;\n        \n        // Update name for debugging\n        gameObject.name = $\"SelfReplicatingCounter_Gen{_generation}\";\n    }\n\n    private void OnDestroy()\n    {\n        if (_materialInstance != null)\n        {\n            DestroyImmediate(_materialInstance);\n        }\n    }\n\n    // Public method to manually set generation (useful for spawned clones)\n    public void SetGeneration(int generation)\n    {\n        _generation = Mathf.Clamp(generation, 0, _maxGenerations);\n        SetupGeneration();\n    }\n\n    // Public getter for current generation\n    public int GetGeneration()\n    {\n        return _generation;\n    }\n\n    // Public getter for update call count\n    public int GetUpdateCallCount()\n    {\n        return _updateCallCount;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "self-modifying object that every collision increases its mass by 10%, plays growth sound, scales up by 5%, adds random color tint - after 10 collisions it splits into two objects with half the accumulated properties",
      "ideal_ir": {
        "class_name": "SelfModifyingObject",
        "components": [
          "Rigidbody",
          "Collider",
          "AudioSource",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "baseMass",
            "type": "float",
            "default": 1.0
          },
          {
            "name": "baseScale",
            "type": "Vector3",
            "default": "Vector3.one"
          },
          {
            "name": "collisionCount",
            "type": "int",
            "default": 0
          },
          {
            "name": "growthSoundClip",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "splitThreshold",
            "type": "int",
            "default": 10
          },
          {
            "name": "massMultiplier",
            "type": "float",
            "default": 1.1
          },
          {
            "name": "scaleMultiplier",
            "type": "float",
            "default": 1.05
          },
          {
            "name": "originalColor",
            "type": "Color",
            "default": "Color.white"
          }
        ],
        "behaviors": [
          {
            "name": "initialize_properties",
            "trigger": "when object starts",
            "actions": [
              {
                "action": "store original mass as base mass"
              },
              {
                "action": "store original scale as base scale"
              },
              {
                "action": "store original material color as original color"
              }
            ]
          },
          {
            "name": "handle_collision",
            "trigger": "when object collides with another object",
            "actions": [
              {
                "action": "increment collision count by one"
              },
              {
                "action": "increase mass by ten percent of current mass"
              },
              {
                "action": "scale up object by five percent of current scale"
              },
              {
                "action": "play growth sound effect"
              },
              {
                "action": "add random color tint to material"
              },
              {
                "action": "check if collision count reaches split threshold"
              }
            ]
          },
          {
            "name": "split_object",
            "trigger": "when collision count reaches ten",
            "actions": [
              {
                "action": "create first child object at slightly offset position"
              },
              {
                "action": "create second child object at opposite offset position"
              },
              {
                "action": "set each child mass to half of current accumulated mass"
              },
              {
                "action": "set each child scale to half of current accumulated scale"
              },
              {
                "action": "copy current color tint to both child objects"
              },
              {
                "action": "reset collision count to zero for both children"
              },
              {
                "action": "destroy original object"
              }
            ]
          },
          {
            "name": "apply_random_tint",
            "trigger": "when adding color tint after collision",
            "actions": [
              {
                "action": "generate random color values for red green and blue"
              },
              {
                "action": "blend random color with current material color"
              },
              {
                "action": "apply blended color to object material"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class SelfModifyingObject : MonoBehaviour\n{\n    [Header(\"Growth Settings\")]\n    [SerializeField] private float _massIncreasePercent = 0.1f;\n    [SerializeField] private float _scaleIncreasePercent = 0.05f;\n    [SerializeField] private int _splitThreshold = 10;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _growthSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private float _colorIntensity = 0.3f;\n    [SerializeField] private GameObject _splitPrefab;\n    \n    [Header(\"Split Settings\")]\n    [SerializeField] private float _splitForce = 5f;\n    [SerializeField] private float _splitDistance = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Material _instanceMaterial;\n    \n    private int _collisionCount = 0;\n    private float _originalMass;\n    private Vector3 _originalScale;\n    private Color _accumulatedTint = Color.white;\n    private float _totalMassGained = 0f;\n    private Vector3 _totalScaleGained = Vector3.zero;\n    \n    [System.Serializable]\n    public class SplitEvent : UnityEvent<GameObject, GameObject> { }\n    \n    [Header(\"Events\")]\n    public SplitEvent OnSplit = new SplitEvent();\n    public UnityEvent<int> OnCollisionCountChanged = new UnityEvent<int>();\n    \n    private void Start()\n    {\n        InitializeComponents();\n        StoreOriginalValues();\n        CreateInstanceMaterial();\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.volume = _audioVolume;\n        }\n        \n        if (_renderer == null)\n        {\n            Debug.LogWarning(\"No Renderer found on \" + gameObject.name);\n        }\n    }\n    \n    private void StoreOriginalValues()\n    {\n        _originalMass = _rigidbody.mass;\n        _originalScale = transform.localScale;\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n    }\n    \n    private void CreateInstanceMaterial()\n    {\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _instanceMaterial = new Material(_originalMaterial);\n            _renderer.material = _instanceMaterial;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        ProcessCollision();\n    }\n    \n    private void ProcessCollision()\n    {\n        _collisionCount++;\n        \n        IncreaseMass();\n        ScaleUp();\n        AddRandomColorTint();\n        PlayGrowthSound();\n        \n        OnCollisionCountChanged.Invoke(_collisionCount);\n        \n        if (_collisionCount >= _splitThreshold)\n        {\n            StartCoroutine(SplitObject());\n        }\n    }\n    \n    private void IncreaseMass()\n    {\n        float massIncrease = _rigidbody.mass * _massIncreasePercent;\n        _rigidbody.mass += massIncrease;\n        _totalMassGained += massIncrease;\n    }\n    \n    private void ScaleUp()\n    {\n        Vector3 scaleIncrease = transform.localScale * _scaleIncreasePercent;\n        transform.localScale += scaleIncrease;\n        _totalScaleGained += scaleIncrease;\n    }\n    \n    private void AddRandomColorTint()\n    {\n        if (_instanceMaterial == null) return;\n        \n        Color randomTint = new Color(\n            Random.Range(0f, 1f),\n            Random.Range(0f, 1f),\n            Random.Range(0f, 1f),\n            1f\n        );\n        \n        _accumulatedTint = Color.Lerp(_accumulatedTint, randomTint, _colorIntensity);\n        _instanceMaterial.color = _accumulatedTint;\n    }\n    \n    private void PlayGrowthSound()\n    {\n        if (_audioSource != null && _growthSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_growthSound);\n        }\n    }\n    \n    private IEnumerator SplitObject()\n    {\n        yield return new WaitForFixedUpdate();\n        \n        GameObject splitObject1 = CreateSplitObject();\n        GameObject splitObject2 = CreateSplitObject();\n        \n        PositionSplitObjects(splitObject1, splitObject2);\n        ApplySplitForces(splitObject1, splitObject2);\n        \n        OnSplit.Invoke(splitObject1, splitObject2);\n        \n        Destroy(gameObject);\n    }\n    \n    private GameObject CreateSplitObject()\n    {\n        GameObject splitObj;\n        \n        if (_splitPrefab != null)\n        {\n            splitObj = Instantiate(_splitPrefab, transform.position, transform.rotation);\n        }\n        else\n        {\n            splitObj = Instantiate(gameObject);\n        }\n        \n        SelfModifyingObject splitComponent = splitObj.GetComponent<SelfModifyingObject>();\n        if (splitComponent != null)\n        {\n            splitComponent.InitializeAsSplit(this);\n        }\n        \n        return splitObj;\n    }\n    \n    private void PositionSplitObjects(GameObject obj1, GameObject obj2)\n    {\n        Vector3 randomDirection = Random.onUnitSphere;\n        randomDirection.y = Mathf.Abs(randomDirection.y);\n        \n        obj1.transform.position = transform.position + randomDirection * _splitDistance;\n        obj2.transform.position = transform.position - randomDirection * _splitDistance;\n    }\n    \n    private void ApplySplitForces(GameObject obj1, GameObject obj2)\n    {\n        Rigidbody rb1 = obj1.GetComponent<Rigidbody>();\n        Rigidbody rb2 = obj2.GetComponent<Rigidbody>();\n        \n        if (rb1 != null && rb2 != null)\n        {\n            Vector3 force1 = (obj1.transform.position - transform.position).normalized * _splitForce;\n            Vector3 force2 = (obj2.transform.position - transform.position).normalized * _splitForce;\n            \n            rb1.AddForce(force1, ForceMode.Impulse);\n            rb2.AddForce(force2, ForceMode.Impulse);\n        }\n    }\n    \n    public void InitializeAsSplit(SelfModifyingObject parent)\n    {\n        _collisionCount = 0;\n        \n        float halfMass = parent._originalMass + (parent._totalMassGained * 0.5f);\n        Vector3 halfScale = parent._originalScale + (parent._totalScaleGained * 0.5f);\n        Color halfTint = Color.Lerp(Color.white, parent._accumulatedTint, 0.5f);\n        \n        _rigidbody.mass = halfMass;\n        transform.localScale = halfScale;\n        \n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.color = halfTint;\n            _accumulatedTint = halfTint;\n        }\n        \n        _totalMassGained = halfMass - _originalMass;\n        _totalScaleGained = halfScale - _originalScale;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_instanceMaterial != null)\n        {\n            DestroyImmediate(_instanceMaterial);\n        }\n    }\n    \n    public int GetCollisionCount()\n    {\n        return _collisionCount;\n    }\n    \n    public float GetCurrentMass()\n    {\n        return _rigidbody != null ? _rigidbody.mass : 0f;\n    }\n    \n    public Vector3 GetCurrentScale()\n    {\n        return transform.localScale;\n    }\n    \n    public Color GetCurrentTint()\n    {\n        return _accumulatedTint;\n    }\n}",
      "behavior_type": "general"
    },
    {
      "prompt": "object that checks if current time is between 2 AM and 4 AM, if true makes object glow, play spooky sounds, and move erratically - also checks if exactly 7 other Rigidbody objects exist in scene",
      "ideal_ir": {
        "class_name": "SpookyNightObject",
        "components": [
          "Rigidbody",
          "AudioSource",
          "Renderer"
        ],
        "fields": [
          {
            "name": "glowIntensity",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "erraticMoveForce",
            "type": "float",
            "default": 5.0
          },
          {
            "name": "spookyAudioClip",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "normalMaterial",
            "type": "Material",
            "default": null
          },
          {
            "name": "glowMaterial",
            "type": "Material",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "spooky_time_activation",
            "trigger": "when current system time is between 2 AM and 4 AM and exactly 7 other Rigidbody objects exist in the scene",
            "actions": [
              {
                "action": "switch renderer material to glow material"
              },
              {
                "action": "increase material emission intensity to glow level"
              },
              {
                "action": "start playing spooky audio clip on loop"
              },
              {
                "action": "apply random erratic forces to rigidbody in all directions"
              },
              {
                "action": "randomly change movement direction every few seconds"
              }
            ]
          },
          {
            "name": "normal_time_deactivation",
            "trigger": "when current system time is not between 2 AM and 4 AM or exactly 7 other Rigidbody objects do not exist in the scene",
            "actions": [
              {
                "action": "switch renderer material back to normal material"
              },
              {
                "action": "reset material emission to normal levels"
              },
              {
                "action": "stop playing spooky audio"
              },
              {
                "action": "stop applying erratic forces to rigidbody"
              },
              {
                "action": "return to normal physics behavior"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System;\nusing System.Collections;\n\npublic class SpookyTimeObject : MonoBehaviour\n{\n    [Header(\"Time Settings\")]\n    [SerializeField] private int _startHour = 2;\n    [SerializeField] private int _endHour = 4;\n    [SerializeField] private bool _useSystemTime = true;\n    [SerializeField] private float _simulatedTimeSpeed = 1f;\n    \n    [Header(\"Glow Effect\")]\n    [SerializeField] private Material _glowMaterial;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Color _glowColor = Color.red;\n    [SerializeField] private float _glowIntensity = 2f;\n    [SerializeField] private float _glowPulseSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _spookySounds;\n    [SerializeField] private float _soundInterval = 3f;\n    [SerializeField] private float _soundVolume = 0.5f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _movementIntensity = 2f;\n    [SerializeField] private float _movementSpeed = 1f;\n    [SerializeField] private Vector3 _movementRange = new Vector3(5f, 2f, 5f);\n    \n    [Header(\"Rigidbody Check\")]\n    [SerializeField] private int _requiredRigidbodyCount = 7;\n    [SerializeField] private float _rigidbodyCheckInterval = 1f;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    private bool _isSpookyTime = false;\n    private bool _hasCorrectRigidbodyCount = false;\n    private bool _isActive = false;\n    private float _simulatedTime = 0f;\n    private Coroutine _movementCoroutine;\n    private Coroutine _soundCoroutine;\n    private Coroutine _rigidbodyCheckCoroutine;\n    private Material _originalMaterial;\n    \n    void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _soundVolume;\n        _audioSource.playOnAwake = false;\n        \n        _originalPosition = transform.position;\n        \n        if (_renderer != null && _normalMaterial != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n        \n        _simulatedTime = (float)(DateTime.Now.Hour * 3600 + DateTime.Now.Minute * 60 + DateTime.Now.Second);\n        \n        StartCoroutine(TimeCheckCoroutine());\n        _rigidbodyCheckCoroutine = StartCoroutine(RigidbodyCheckCoroutine());\n    }\n    \n    void Update()\n    {\n        if (!_useSystemTime)\n        {\n            _simulatedTime += Time.deltaTime * _simulatedTimeSpeed * 3600f;\n            if (_simulatedTime >= 86400f)\n            {\n                _simulatedTime -= 86400f;\n            }\n        }\n        \n        UpdateGlowEffect();\n    }\n    \n    IEnumerator TimeCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckSpookyTime();\n            yield return new WaitForSeconds(1f);\n        }\n    }\n    \n    IEnumerator RigidbodyCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckRigidbodyCount();\n            yield return new WaitForSeconds(_rigidbodyCheckInterval);\n        }\n    }\n    \n    void CheckSpookyTime()\n    {\n        int currentHour;\n        \n        if (_useSystemTime)\n        {\n            currentHour = DateTime.Now.Hour;\n        }\n        else\n        {\n            currentHour = Mathf.FloorToInt(_simulatedTime / 3600f) % 24;\n        }\n        \n        bool wasSpookyTime = _isSpookyTime;\n        _isSpookyTime = (currentHour >= _startHour && currentHour < _endHour);\n        \n        if (_isSpookyTime != wasSpookyTime)\n        {\n            UpdateActiveState();\n        }\n    }\n    \n    void CheckRigidbodyCount()\n    {\n        Rigidbody[] allRigidbodies = FindObjectsOfType<Rigidbody>();\n        int count = 0;\n        \n        foreach (Rigidbody rb in allRigidbodies)\n        {\n            if (rb.gameObject != gameObject)\n            {\n                count++;\n            }\n        }\n        \n        bool wasCorrect = _hasCorrectRigidbodyCount;\n        _hasCorrectRigidbodyCount = (count == _requiredRigidbodyCount);\n        \n        if (_hasCorrectRigidbodyCount != wasCorrect)\n        {\n            UpdateActiveState();\n        }\n    }\n    \n    void UpdateActiveState()\n    {\n        bool shouldBeActive = _isSpookyTime && _hasCorrectRigidbodyCount;\n        \n        if (shouldBeActive && !_isActive)\n        {\n            ActivateSpookyBehavior();\n        }\n        else if (!shouldBeActive && _isActive)\n        {\n            DeactivateSpookyBehavior();\n        }\n        \n        _isActive = shouldBeActive;\n    }\n    \n    void ActivateSpookyBehavior()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n        }\n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n        }\n        \n        _movementCoroutine = StartCoroutine(ErraticMovementCoroutine());\n        _soundCoroutine = StartCoroutine(SpookySoundCoroutine());\n        \n        SetGlowMaterial(true);\n    }\n    \n    void DeactivateSpookyBehavior()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n            _movementCoroutine = null;\n        }\n        \n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n            _soundCoroutine = null;\n        }\n        \n        if (_audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        transform.position = _originalPosition;\n        SetGlowMaterial(false);\n    }\n    \n    void SetGlowMaterial(bool useGlow)\n    {\n        if (_renderer == null) return;\n        \n        if (useGlow && _glowMaterial != null)\n        {\n            _renderer.material = _glowMaterial;\n        }\n        else if (!useGlow)\n        {\n            if (_normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n            }\n            else if (_originalMaterial != null)\n            {\n                _renderer.material = _originalMaterial;\n            }\n        }\n    }\n    \n    void UpdateGlowEffect()\n    {\n        if (!_isActive || _renderer == null) return;\n        \n        float pulse = Mathf.Sin(Time.time * _glowPulseSpeed) * 0.5f + 0.5f;\n        Color currentColor = _glowColor * (_glowIntensity * pulse);\n        \n        if (_renderer.material.HasProperty(\"_EmissionColor\"))\n        {\n            _renderer.material.SetColor(\"_EmissionColor\", currentColor);\n        }\n        else if (_renderer.material.HasProperty(\"_Color\"))\n        {\n            _renderer.material.color = Color.Lerp(Color.white, _glowColor, pulse);\n        }\n    }\n    \n    IEnumerator ErraticMovementCoroutine()\n    {\n        while (_isActive)\n        {\n            Vector3 randomOffset = new Vector3(\n                UnityEngine.Random.Range(-_movementRange.x, _movementRange.x),\n                UnityEngine.Random.Range(-_movementRange.y, _movementRange.y),\n                UnityEngine.Random.Range(-_movementRange.z, _movementRange.z)\n            ) * _movementIntensity;\n            \n            Vector3 targetPosition = _originalPosition + randomOffset;\n            \n            float duration = UnityEngine.Random.Range(0.5f, 2f) / _movementSpeed;\n            float elapsed = 0f;\n            Vector3 startPos = transform.position;\n            \n            while (elapsed < duration && _isActive)\n            {\n                elapsed += Time.deltaTime;\n                float t = elapsed / duration;\n                t = Mathf.SmoothStep(0f, 1f, t);\n                \n                transform.position = Vector3.Lerp(startPos, targetPosition, t);\n                yield return null;\n            }\n            \n            yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 0.5f));\n        }\n    }\n    \n    IEnumerator SpookySoundCoroutine()\n    {\n        while (_isActive)\n        {\n            if (_spookySounds != null && _spookySounds.Length > 0)\n            {\n                AudioClip randomClip = _spookySounds[UnityEngine.Random.Range(0, _spookySounds.Length)];\n                if (randomClip != null)\n                {\n                    _audioSource.clip = randomClip;\n                    _audioSource.Play();\n                }\n            }\n            \n            yield return new WaitForSeconds(_soundInterval + UnityEngine.Random.Range(-1f, 1f));\n        }\n    }\n    \n    void OnDestroy()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n        }\n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n        }\n        if (_rigidbodyCheckCoroutine != null)\n        {\n            StopCoroutine(_rigidbodyCheckCoroutine);\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "quantum object that when observed (player looking at it via raycast) collapses to one state (visible, plays observation sound), when not observed exists in superposition (flickers between positions, plays quantum hum, translucent material)",
      "ideal_ir": {
        "class_name": "QuantumObject",
        "components": [
          "MeshRenderer",
          "AudioSource",
          "Collider"
        ],
        "fields": [
          {
            "name": "detectionRange",
            "type": "float",
            "default": 50
          },
          {
            "name": "flickerSpeed",
            "type": "float",
            "default": 2
          },
          {
            "name": "superpositionPositions",
            "type": "Vector3[]",
            "default": []
          },
          {
            "name": "observationSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "quantumHumSound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "normalMaterial",
            "type": "Material",
            "default": null
          },
          {
            "name": "translucentMaterial",
            "type": "Material",
            "default": null
          },
          {
            "name": "isObserved",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "detect_observation",
            "trigger": "player is looking at this object with raycast hit within detection range",
            "actions": [
              {
                "action": "set observed state to true"
              },
              {
                "action": "collapse to single visible state"
              },
              {
                "action": "apply normal material to make fully opaque"
              },
              {
                "action": "stop quantum hum sound"
              },
              {
                "action": "play observation sound once"
              },
              {
                "action": "stop flickering between positions"
              }
            ]
          },
          {
            "name": "enter_superposition",
            "trigger": "player is not looking at this object or raycast does not hit",
            "actions": [
              {
                "action": "set observed state to false"
              },
              {
                "action": "apply translucent material"
              },
              {
                "action": "start flickering between multiple positions from superposition array"
              },
              {
                "action": "play quantum hum sound continuously"
              },
              {
                "action": "stop observation sound"
              }
            ]
          },
          {
            "name": "flicker_positions",
            "trigger": "object is in superposition state and flicker timer expires",
            "actions": [
              {
                "action": "move to next position in superposition positions array"
              },
              {
                "action": "reset flicker timer based on flicker speed"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections;\n\npublic class QuantumObject : MonoBehaviour\n{\n    [Header(\"Quantum States\")]\n    [SerializeField] private float _observationDistance = 10f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Superposition Settings\")]\n    [SerializeField] private float _flickerSpeed = 2f;\n    [SerializeField] private float _positionVariance = 0.5f;\n    [SerializeField] private int _superpositionCount = 3;\n    [SerializeField] private float _transparencyInSuperposition = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _observationSound;\n    [SerializeField] private AudioClip _quantumHumSound;\n    [SerializeField] private float _humVolume = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _collapseEffect;\n    [SerializeField] private float _materialTransitionSpeed = 2f;\n    \n    private Camera _playerCamera;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Material _quantumMaterial;\n    \n    private bool _isObserved = false;\n    private bool _wasObservedLastFrame = false;\n    private Vector3 _originalPosition;\n    private Vector3[] _superpositionPositions;\n    private int _currentSuperpositionIndex = 0;\n    private float _flickerTimer = 0f;\n    private float _currentTransparency = 1f;\n    private Coroutine _humCoroutine;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.spatialBlend = 1f;\n        }\n        \n        _originalPosition = transform.position;\n        _originalMaterial = _renderer.material;\n        _quantumMaterial = new Material(_originalMaterial);\n        \n        GenerateSuperpositionPositions();\n        StartQuantumHum();\n    }\n    \n    private void Update()\n    {\n        CheckObservationState();\n        UpdateQuantumBehavior();\n    }\n    \n    private void CheckObservationState()\n    {\n        _wasObservedLastFrame = _isObserved;\n        _isObserved = false;\n        \n        if (_playerCamera == null) return;\n        \n        Vector3 directionToObject = (transform.position - _playerCamera.transform.position).normalized;\n        float distanceToObject = Vector3.Distance(_playerCamera.transform.position, transform.position);\n        \n        if (distanceToObject <= _observationDistance)\n        {\n            float dotProduct = Vector3.Dot(_playerCamera.transform.forward, directionToObject);\n            \n            if (dotProduct > 0.5f)\n            {\n                Ray observationRay = new Ray(_playerCamera.transform.position, directionToObject);\n                \n                if (Physics.Raycast(observationRay, out RaycastHit hit, distanceToObject, _obstacleLayerMask))\n                {\n                    if (hit.collider.gameObject == gameObject)\n                    {\n                        _isObserved = true;\n                    }\n                }\n            }\n        }\n        \n        if (_isObserved != _wasObservedLastFrame)\n        {\n            OnObservationStateChanged();\n        }\n    }\n    \n    private void UpdateQuantumBehavior()\n    {\n        if (_isObserved)\n        {\n            UpdateObservedState();\n        }\n        else\n        {\n            UpdateSuperpositionState();\n        }\n        \n        UpdateMaterialTransparency();\n    }\n    \n    private void UpdateObservedState()\n    {\n        transform.position = Vector3.Lerp(transform.position, _originalPosition, Time.deltaTime * 5f);\n        _currentTransparency = Mathf.Lerp(_currentTransparency, 1f, Time.deltaTime * _materialTransitionSpeed);\n    }\n    \n    private void UpdateSuperpositionState()\n    {\n        _flickerTimer += Time.deltaTime * _flickerSpeed;\n        \n        if (_flickerTimer >= 1f)\n        {\n            _flickerTimer = 0f;\n            _currentSuperpositionIndex = (_currentSuperpositionIndex + 1) % _superpositionCount;\n        }\n        \n        Vector3 targetPosition = Vector3.Lerp(\n            _superpositionPositions[_currentSuperpositionIndex],\n            _superpositionPositions[(_currentSuperpositionIndex + 1) % _superpositionCount],\n            _flickerTimer\n        );\n        \n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 3f);\n        _currentTransparency = Mathf.Lerp(_currentTransparency, _transparencyInSuperposition, Time.deltaTime * _materialTransitionSpeed);\n    }\n    \n    private void UpdateMaterialTransparency()\n    {\n        Color materialColor = _quantumMaterial.color;\n        materialColor.a = _currentTransparency;\n        _quantumMaterial.color = materialColor;\n        _renderer.material = _quantumMaterial;\n    }\n    \n    private void OnObservationStateChanged()\n    {\n        if (_isObserved)\n        {\n            OnCollapse();\n        }\n        else\n        {\n            OnEnterSuperposition();\n        }\n    }\n    \n    private void OnCollapse()\n    {\n        if (_observationSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_observationSound);\n        }\n        \n        if (_collapseEffect != null)\n        {\n            _collapseEffect.Play();\n        }\n        \n        StopQuantumHum();\n    }\n    \n    private void OnEnterSuperposition()\n    {\n        GenerateSuperpositionPositions();\n        StartQuantumHum();\n    }\n    \n    private void GenerateSuperpositionPositions()\n    {\n        _superpositionPositions = new Vector3[_superpositionCount];\n        \n        for (int i = 0; i < _superpositionCount; i++)\n        {\n            Vector3 randomOffset = new Vector3(\n                Random.Range(-_positionVariance, _positionVariance),\n                Random.Range(-_positionVariance * 0.5f, _positionVariance * 0.5f),\n                Random.Range(-_positionVariance, _positionVariance)\n            );\n            \n            _superpositionPositions[i] = _originalPosition + randomOffset;\n        }\n    }\n    \n    private void StartQuantumHum()\n    {\n        if (_quantumHumSound != null && _audioSource != null && _humCoroutine == null)\n        {\n            _humCoroutine = StartCoroutine(PlayQuantumHum());\n        }\n    }\n    \n    private void StopQuantumHum()\n    {\n        if (_humCoroutine != null)\n        {\n            StopCoroutine(_humCoroutine);\n            _humCoroutine = null;\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _quantumHumSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private IEnumerator PlayQuantumHum()\n    {\n        while (!_isObserved)\n        {\n            if (_audioSource != null && _quantumHumSound != null)\n            {\n                _audioSource.clip = _quantumHumSound;\n                _audioSource.volume = _humVolume;\n                _audioSource.loop = true;\n                _audioSource.Play();\n                \n                yield return new WaitWhile(() => !_isObserved && _audioSource.isPlaying);\n            }\n            else\n            {\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_quantumMaterial != null)\n        {\n            DestroyImmediate(_quantumMaterial);\n        }\n        \n        StopQuantumHum();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _observationDistance);\n        \n        if (_superpositionPositions != null)\n        {\n            Gizmos.color = Color.red;\n            foreach (Vector3 pos in _superpositionPositions)\n            {\n                Gizmos.DrawWireCube(pos, Vector3.one * 0.1f);\n            }\n        }\n    }\n}",
      "behavior_type": "movement"
    },
    {
      "prompt": "particle fountain that spawns 100 particles per second each with own physics, unique color based on spawn time - each particle tracks nearest other particle and creates visual line if within 2 units",
      "ideal_ir": {
        "class_name": "ParticleFountain",
        "components": [
          "ParticleSystem",
          "LineRenderer"
        ],
        "fields": [
          {
            "name": "spawnRate",
            "type": "float",
            "default": 100
          },
          {
            "name": "connectionDistance",
            "type": "float",
            "default": 2
          },
          {
            "name": "particleLifetime",
            "type": "float",
            "default": 5
          },
          {
            "name": "fountainForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "activeParticles",
            "type": "List<ParticleData>",
            "default": null
          },
          {
            "name": "connectionLines",
            "type": "List<LineRenderer>",
            "default": null
          }
        ],
        "behaviors": [
          {
            "name": "spawn_particles_continuously",
            "trigger": "every frame based on spawn rate timing",
            "actions": [
              {
                "action": "create new particle with physics rigidbody"
              },
              {
                "action": "apply upward fountain force to particle"
              },
              {
                "action": "assign unique color based on current spawn time"
              },
              {
                "action": "add particle to active particles list"
              },
              {
                "action": "set particle lifetime countdown"
              }
            ]
          },
          {
            "name": "track_nearest_particles",
            "trigger": "every frame for each active particle",
            "actions": [
              {
                "action": "find closest other particle to current particle"
              },
              {
                "action": "calculate distance to nearest particle"
              },
              {
                "action": "store nearest particle reference for current particle"
              }
            ]
          },
          {
            "name": "create_connection_lines",
            "trigger": "when particle has nearest neighbor within connection distance",
            "actions": [
              {
                "action": "create visual line between particle and nearest neighbor"
              },
              {
                "action": "update line position to follow both particles"
              },
              {
                "action": "set line color based on average of both particle colors"
              }
            ]
          },
          {
            "name": "remove_distant_connections",
            "trigger": "when particles move beyond connection distance",
            "actions": [
              {
                "action": "destroy visual line between particles"
              },
              {
                "action": "remove line from active connections list"
              }
            ]
          },
          {
            "name": "cleanup_expired_particles",
            "trigger": "when particle lifetime reaches zero",
            "actions": [
              {
                "action": "destroy particle and its physics body"
              },
              {
                "action": "remove all connection lines involving this particle"
              },
              {
                "action": "remove particle from active particles list"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ParticleFountain : MonoBehaviour\n{\n    [Header(\"Fountain Settings\")]\n    [SerializeField] private float _spawnRate = 100f;\n    [SerializeField] private float _fountainForce = 10f;\n    [SerializeField] private float _spawnRadius = 0.5f;\n    [SerializeField] private float _particleLifetime = 5f;\n    \n    [Header(\"Connection Settings\")]\n    [SerializeField] private float _connectionDistance = 2f;\n    [SerializeField] private Material _lineMaterial;\n    [SerializeField] private float _lineWidth = 0.02f;\n    \n    [Header(\"Particle Prefab\")]\n    [SerializeField] private GameObject _particlePrefab;\n    \n    private List<FountainParticle> _activeParticles = new List<FountainParticle>();\n    private float _lastSpawnTime;\n    private float _spawnInterval;\n    private LineRenderer _lineRenderer;\n    \n    [System.Serializable]\n    public class FountainParticle\n    {\n        public GameObject gameObject;\n        public Rigidbody rigidbody;\n        public Renderer renderer;\n        public float spawnTime;\n        public float lifetime;\n        public FountainParticle nearestParticle;\n        public float distanceToNearest;\n        \n        public FountainParticle(GameObject go, float time)\n        {\n            gameObject = go;\n            rigidbody = go.GetComponent<Rigidbody>();\n            renderer = go.GetComponent<Renderer>();\n            spawnTime = time;\n            lifetime = 0f;\n            distanceToNearest = float.MaxValue;\n        }\n        \n        public bool IsValid()\n        {\n            return gameObject != null;\n        }\n        \n        public Vector3 Position\n        {\n            get { return gameObject != null ? gameObject.transform.position : Vector3.zero; }\n        }\n    }\n    \n    void Start()\n    {\n        _spawnInterval = 1f / _spawnRate;\n        _lastSpawnTime = Time.time;\n        \n        SetupLineRenderer();\n        CreateParticlePrefabIfNeeded();\n    }\n    \n    void Update()\n    {\n        SpawnParticles();\n        UpdateParticles();\n        FindNearestParticles();\n        DrawConnections();\n        CleanupDeadParticles();\n    }\n    \n    void SetupLineRenderer()\n    {\n        _lineRenderer = GetComponent<LineRenderer>();\n        if (_lineRenderer == null)\n        {\n            _lineRenderer = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _lineRenderer.material = _lineMaterial != null ? _lineMaterial : CreateDefaultLineMaterial();\n        _lineRenderer.startWidth = _lineWidth;\n        _lineRenderer.endWidth = _lineWidth;\n        _lineRenderer.useWorldSpace = true;\n        _lineRenderer.positionCount = 0;\n    }\n    \n    Material CreateDefaultLineMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.color = Color.white;\n        return mat;\n    }\n    \n    void CreateParticlePrefabIfNeeded()\n    {\n        if (_particlePrefab == null)\n        {\n            _particlePrefab = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            _particlePrefab.transform.localScale = Vector3.one * 0.1f;\n            \n            Rigidbody rb = _particlePrefab.GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = _particlePrefab.AddComponent<Rigidbody>();\n            }\n            rb.mass = 0.1f;\n            rb.drag = 0.5f;\n            \n            _particlePrefab.SetActive(false);\n        }\n    }\n    \n    void SpawnParticles()\n    {\n        while (Time.time - _lastSpawnTime >= _spawnInterval)\n        {\n            SpawnSingleParticle();\n            _lastSpawnTime += _spawnInterval;\n        }\n    }\n    \n    void SpawnSingleParticle()\n    {\n        Vector3 spawnPosition = transform.position + Random.insideUnitSphere * _spawnRadius;\n        GameObject particle = Instantiate(_particlePrefab, spawnPosition, Random.rotation);\n        particle.SetActive(true);\n        \n        Rigidbody rb = particle.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 force = (Vector3.up + Random.insideUnitSphere * 0.3f).normalized * _fountainForce;\n            rb.AddForce(force, ForceMode.Impulse);\n        }\n        \n        FountainParticle fountainParticle = new FountainParticle(particle, Time.time);\n        SetParticleColor(fountainParticle);\n        _activeParticles.Add(fountainParticle);\n    }\n    \n    void SetParticleColor(FountainParticle particle)\n    {\n        if (particle.renderer != null)\n        {\n            float hue = (particle.spawnTime * 0.1f) % 1f;\n            Color color = Color.HSVToRGB(hue, 0.8f, 1f);\n            particle.renderer.material.color = color;\n        }\n    }\n    \n    void UpdateParticles()\n    {\n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            if (_activeParticles[i].IsValid())\n            {\n                _activeParticles[i].lifetime = Time.time - _activeParticles[i].spawnTime;\n            }\n        }\n    }\n    \n    void FindNearestParticles()\n    {\n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            FountainParticle current = _activeParticles[i];\n            if (!current.IsValid()) continue;\n            \n            current.nearestParticle = null;\n            current.distanceToNearest = float.MaxValue;\n            \n            for (int j = 0; j < _activeParticles.Count; j++)\n            {\n                if (i == j) continue;\n                \n                FountainParticle other = _activeParticles[j];\n                if (!other.IsValid()) continue;\n                \n                float distance = Vector3.Distance(current.Position, other.Position);\n                \n                if (distance < current.distanceToNearest && distance <= _connectionDistance)\n                {\n                    current.distanceToNearest = distance;\n                    current.nearestParticle = other;\n                }\n            }\n        }\n    }\n    \n    void DrawConnections()\n    {\n        List<Vector3> linePositions = new List<Vector3>();\n        \n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            FountainParticle particle = _activeParticles[i];\n            if (!particle.IsValid() || particle.nearestParticle == null || !particle.nearestParticle.IsValid())\n                continue;\n            \n            linePositions.Add(particle.Position);\n            linePositions.Add(particle.nearestParticle.Position);\n        }\n        \n        _lineRenderer.positionCount = linePositions.Count;\n        if (linePositions.Count > 0)\n        {\n            _lineRenderer.SetPositions(linePositions.ToArray());\n        }\n    }\n    \n    void CleanupDeadParticles()\n    {\n        for (int i = _activeParticles.Count - 1; i >= 0; i--)\n        {\n            FountainParticle particle = _activeParticles[i];\n            \n            if (!particle.IsValid() || particle.lifetime > _particleLifetime)\n            {\n                if (particle.IsValid())\n                {\n                    DestroyImmediate(particle.gameObject);\n                }\n                _activeParticles.RemoveAt(i);\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _connectionDistance);\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "chain reaction system: touching object A explodes and spawns 5 objects of type B in circle, each B when touched spawns 3 objects of type C, each C spawns 2 of type D, each D spawns 1 of type E which plays victory sound",
      "ideal_ir": {
        "class_name": "ChainReactionSystem",
        "components": [
          "Collider",
          "AudioSource"
        ],
        "fields": [
          {
            "name": "objectBPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "objectCPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "objectDPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "objectEPrefab",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "victorySound",
            "type": "AudioClip",
            "default": null
          },
          {
            "name": "explosionEffect",
            "type": "GameObject",
            "default": null
          },
          {
            "name": "reactionType",
            "type": "string",
            "default": "A"
          },
          {
            "name": "spawnRadius",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "hasExploded",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "explode_object_a",
            "trigger": "when this object is touched and reaction type is A and has not exploded",
            "actions": [
              {
                "action": "mark as exploded"
              },
              {
                "action": "play explosion effect at current position"
              },
              {
                "action": "spawn 5 objects of type B in circular pattern around current position"
              },
              {
                "action": "destroy this object"
              }
            ]
          },
          {
            "name": "explode_object_b",
            "trigger": "when this object is touched and reaction type is B and has not exploded",
            "actions": [
              {
                "action": "mark as exploded"
              },
              {
                "action": "play explosion effect at current position"
              },
              {
                "action": "spawn 3 objects of type C in circular pattern around current position"
              },
              {
                "action": "destroy this object"
              }
            ]
          },
          {
            "name": "explode_object_c",
            "trigger": "when this object is touched and reaction type is C and has not exploded",
            "actions": [
              {
                "action": "mark as exploded"
              },
              {
                "action": "play explosion effect at current position"
              },
              {
                "action": "spawn 2 objects of type D in circular pattern around current position"
              },
              {
                "action": "destroy this object"
              }
            ]
          },
          {
            "name": "explode_object_d",
            "trigger": "when this object is touched and reaction type is D and has not exploded",
            "actions": [
              {
                "action": "mark as exploded"
              },
              {
                "action": "play explosion effect at current position"
              },
              {
                "action": "spawn 1 object of type E at current position"
              },
              {
                "action": "destroy this object"
              }
            ]
          },
          {
            "name": "victory_object_e",
            "trigger": "when this object is touched and reaction type is E and has not exploded",
            "actions": [
              {
                "action": "mark as exploded"
              },
              {
                "action": "play victory sound"
              },
              {
                "action": "play explosion effect at current position"
              },
              {
                "action": "destroy this object"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ChainReactionSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class ReactionLevel\n    {\n        [Header(\"Spawn Settings\")]\n        public GameObject prefab;\n        public int spawnCount;\n        public float spawnRadius = 2f;\n        public float spawnForce = 5f;\n        \n        [Header(\"Visual Effects\")]\n        public GameObject explosionEffect;\n        public AudioClip explosionSound;\n        \n        [Header(\"Timing\")]\n        public float destructionDelay = 0.1f;\n    }\n    \n    [Header(\"Chain Reaction Configuration\")]\n    [SerializeField] private ReactionLevel[] _reactionLevels = new ReactionLevel[5];\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _victorySound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    [SerializeField] private string _triggerTag = \"Player\";\n    \n    [Header(\"Current Level\")]\n    [SerializeField] private int _currentLevel = 0;\n    \n    private bool _hasTriggered = false;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    public UnityEvent OnChainReactionTriggered;\n    public UnityEvent OnVictoryReached;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        SetupCollider();\n        InitializeReactionLevels();\n    }\n    \n    private void SetupCollider()\n    {\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        if (!_collider.isTrigger)\n            _collider.isTrigger = true;\n    }\n    \n    private void InitializeReactionLevels()\n    {\n        if (_reactionLevels == null || _reactionLevels.Length == 0)\n        {\n            _reactionLevels = new ReactionLevel[5];\n            for (int i = 0; i < _reactionLevels.Length; i++)\n            {\n                _reactionLevels[i] = new ReactionLevel();\n            }\n        }\n        \n        // Set default spawn counts if not configured\n        if (_reactionLevels.Length >= 1 && _reactionLevels[0].spawnCount == 0)\n            _reactionLevels[0].spawnCount = 5; // A spawns 5 B\n            \n        if (_reactionLevels.Length >= 2 && _reactionLevels[1].spawnCount == 0)\n            _reactionLevels[1].spawnCount = 3; // B spawns 3 C\n            \n        if (_reactionLevels.Length >= 3 && _reactionLevels[2].spawnCount == 0)\n            _reactionLevels[2].spawnCount = 2; // C spawns 2 D\n            \n        if (_reactionLevels.Length >= 4 && _reactionLevels[3].spawnCount == 0)\n            _reactionLevels[3].spawnCount = 1; // D spawns 1 E\n            \n        if (_reactionLevels.Length >= 5 && _reactionLevels[4].spawnCount == 0)\n            _reactionLevels[4].spawnCount = 0; // E is final level\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasTriggered)\n            return;\n            \n        if (!IsValidTrigger(other))\n            return;\n            \n        TriggerChainReaction();\n    }\n    \n    private bool IsValidTrigger(Collider other)\n    {\n        // Check layer mask\n        int otherLayer = 1 << other.gameObject.layer;\n        if ((_triggerLayers.value & otherLayer) == 0)\n            return false;\n            \n        // Check tag if specified\n        if (!string.IsNullOrEmpty(_triggerTag) && !other.CompareTag(_triggerTag))\n            return false;\n            \n        return true;\n    }\n    \n    private void TriggerChainReaction()\n    {\n        if (_hasTriggered)\n            return;\n            \n        _hasTriggered = true;\n        \n        OnChainReactionTriggered?.Invoke();\n        \n        // Check if this is the final level (E)\n        if (_currentLevel >= _reactionLevels.Length - 1 || _reactionLevels[_currentLevel].spawnCount == 0)\n        {\n            PlayVictorySound();\n            OnVictoryReached?.Invoke();\n        }\n        else\n        {\n            StartCoroutine(ExecuteReaction());\n        }\n    }\n    \n    private IEnumerator ExecuteReaction()\n    {\n        ReactionLevel currentReaction = _reactionLevels[_currentLevel];\n        \n        // Play explosion sound\n        if (currentReaction.explosionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(currentReaction.explosionSound);\n        }\n        \n        // Spawn explosion effect\n        if (currentReaction.explosionEffect != null)\n        {\n            Instantiate(currentReaction.explosionEffect, transform.position, transform.rotation);\n        }\n        \n        // Spawn next level objects\n        if (currentReaction.prefab != null && currentReaction.spawnCount > 0)\n        {\n            SpawnNextLevelObjects(currentReaction);\n        }\n        \n        // Wait before destroying this object\n        yield return new WaitForSeconds(currentReaction.destructionDelay);\n        \n        Destroy(gameObject);\n    }\n    \n    private void SpawnNextLevelObjects(ReactionLevel reaction)\n    {\n        float angleStep = 360f / reaction.spawnCount;\n        \n        for (int i = 0; i < reaction.spawnCount; i++)\n        {\n            float angle = i * angleStep * Mathf.Deg2Rad;\n            Vector3 spawnDirection = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\n            Vector3 spawnPosition = transform.position + spawnDirection * reaction.spawnRadius;\n            \n            GameObject spawnedObject = Instantiate(reaction.prefab, spawnPosition, Quaternion.identity);\n            \n            // Set up the spawned object's chain reaction component\n            ChainReactionSystem chainReaction = spawnedObject.GetComponent<ChainReactionSystem>();\n            if (chainReaction == null)\n            {\n                chainReaction = spawnedObject.AddComponent<ChainReactionSystem>();\n            }\n            \n            // Configure the next level\n            chainReaction.SetupAsNextLevel(_currentLevel + 1, _reactionLevels, _victorySound);\n            \n            // Apply spawn force\n            Rigidbody spawnedRb = spawnedObject.GetComponent<Rigidbody>();\n            if (spawnedRb != null && reaction.spawnForce > 0)\n            {\n                Vector3 forceDirection = spawnDirection + Vector3.up * 0.3f;\n                spawnedRb.AddForce(forceDirection.normalized * reaction.spawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public void SetupAsNextLevel(int level, ReactionLevel[] reactionLevels, AudioClip victorySound)\n    {\n        _currentLevel = level;\n        _reactionLevels = reactionLevels;\n        _victorySound = victorySound;\n        _hasTriggered = false;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void PlayVictorySound()\n    {\n        if (_victorySound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_victorySound);\n        }\n    }\n    \n    public void ResetChainReaction()\n    {\n        _hasTriggered = false;\n    }\n    \n    public void SetCurrentLevel(int level)\n    {\n        _currentLevel = Mathf.Clamp(level, 0, _reactionLevels.Length - 1);\n    }\n    \n    public int GetCurrentLevel()\n    {\n        return _currentLevel;\n    }\n    \n    public bool HasTriggered()\n    {\n        return _hasTriggered;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_currentLevel < _reactionLevels.Length)\n        {\n            ReactionLevel currentReaction = _reactionLevels[_currentLevel];\n            \n            // Draw spawn radius\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCircle(transform.position, currentReaction.spawnRadius);\n            \n            // Draw spawn positions\n            if (currentReaction.spawnCount > 0)\n            {\n                Gizmos.color = Color.green;\n                float angleStep = 360f / currentReaction.spawnCount;\n                \n                for (int i = 0; i < currentReaction.spawnCount; i++)\n                {\n                    float angle = i * angleStep * Mathf.Deg2Rad;\n                    Vector3 spawnDirection = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\n                    Vector3 spawnPosition = transform.position + spawnDirection * currentReaction.spawnRadius;\n                    \n                    Gizmos.DrawWireSphere(spawnPosition, 0.2f);\n                }\n            }\n        }\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "recursive reality object that contains miniature version of entire scene inside it as texture on material, when zooming in it reveals the miniature scene also contains same object creating infinite recursion, each level plays different musical note",
      "ideal_ir": {
        "class_name": "RecursiveRealityObject",
        "components": [
          "MeshRenderer",
          "AudioSource",
          "Camera"
        ],
        "fields": [
          {
            "name": "recursionDepth",
            "type": "int",
            "default": 5
          },
          {
            "name": "miniatureScale",
            "type": "float",
            "default": 0.1
          },
          {
            "name": "zoomThreshold",
            "type": "float",
            "default": 2.0
          },
          {
            "name": "baseFrequency",
            "type": "float",
            "default": 440.0
          },
          {
            "name": "frequencyMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "renderTexture",
            "type": "RenderTexture",
            "default": null
          },
          {
            "name": "recursiveCamera",
            "type": "Camera",
            "default": null
          },
          {
            "name": "currentDepthLevel",
            "type": "int",
            "default": 0
          },
          {
            "name": "isZoomedIn",
            "type": "bool",
            "default": false
          }
        ],
        "behaviors": [
          {
            "name": "initialize_recursive_scene",
            "trigger": "when object starts",
            "actions": [
              {
                "action": "create render texture for miniature scene"
              },
              {
                "action": "setup recursive camera to capture entire scene"
              },
              {
                "action": "apply render texture to object material"
              },
              {
                "action": "create miniature version of entire scene at reduced scale"
              },
              {
                "action": "position miniature scene inside this object"
              }
            ]
          },
          {
            "name": "detect_zoom_level",
            "trigger": "when main camera distance to object changes",
            "actions": [
              {
                "action": "calculate camera proximity to object surface"
              },
              {
                "action": "determine current zoom level based on distance"
              },
              {
                "action": "update zoom state when threshold is crossed"
              }
            ]
          },
          {
            "name": "reveal_recursive_layer",
            "trigger": "when zoom level exceeds threshold",
            "actions": [
              {
                "action": "increase recursion depth level"
              },
              {
                "action": "make miniature scene visible and interactive"
              },
              {
                "action": "create another recursive object inside miniature scene"
              },
              {
                "action": "scale down all elements in revealed layer"
              }
            ]
          },
          {
            "name": "play_depth_musical_note",
            "trigger": "when recursion depth level changes",
            "actions": [
              {
                "action": "calculate musical frequency based on current depth"
              },
              {
                "action": "multiply base frequency by depth multiplier"
              },
              {
                "action": "play musical note at calculated frequency"
              },
              {
                "action": "adjust note duration based on zoom speed"
              }
            ]
          },
          {
            "name": "update_recursive_texture",
            "trigger": "every frame while active",
            "actions": [
              {
                "action": "render current scene state to texture"
              },
              {
                "action": "apply updated texture to material"
              },
              {
                "action": "ensure recursive camera captures all scene elements"
              },
              {
                "action": "maintain texture resolution across recursion levels"
              }
            ]
          },
          {
            "name": "manage_infinite_recursion",
            "trigger": "when maximum recursion depth is reached",
            "actions": [
              {
                "action": "loop back to first recursion level"
              },
              {
                "action": "create seamless transition between deepest and surface level"
              },
              {
                "action": "reset musical note sequence to beginning"
              },
              {
                "action": "maintain visual continuity during loop"
              }
            ]
          }
        ]
      },
      "good_code": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class RecursiveRealityObject : MonoBehaviour\n{\n    [System.Serializable]\n    public class RecursionLevel\n    {\n        public Camera levelCamera;\n        public RenderTexture renderTexture;\n        public Transform miniatureScene;\n        public AudioSource audioSource;\n        public float pitch = 1f;\n        public bool isActive = false;\n    }\n\n    [Header(\"Recursion Settings\")]\n    [SerializeField] private int _maxRecursionDepth = 5;\n    [SerializeField] private float _scaleReduction = 0.1f;\n    [SerializeField] private Vector3 _miniatureOffset = Vector3.zero;\n    [SerializeField] private LayerMask _renderLayers = -1;\n\n    [Header(\"Render Settings\")]\n    [SerializeField] private int _textureResolution = 512;\n    [SerializeField] private Material _displayMaterial;\n    [SerializeField] private Renderer _targetRenderer;\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _baseNote;\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchMultiplier = 1.5f;\n    [SerializeField] private float _volumeReduction = 0.7f;\n    [SerializeField] private float _maxAudioDistance = 50f;\n\n    [Header(\"Zoom Detection\")]\n    [SerializeField] private float _zoomThreshold = 5f;\n    [SerializeField] private Transform _viewerTransform;\n    [SerializeField] private bool _autoDetectMainCamera = true;\n\n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.1f;\n    [SerializeField] private bool _enableLOD = true;\n    [SerializeField] private float _lodDistance = 100f;\n\n    private List<RecursionLevel> _recursionLevels = new List<RecursionLevel>();\n    private Transform _originalScene;\n    private float _lastUpdateTime;\n    private int _currentActiveDepth = 0;\n    private bool _isInitialized = false;\n\n    private void Start()\n    {\n        InitializeRecursion();\n    }\n\n    private void Update()\n    {\n        if (!_isInitialized) return;\n\n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            UpdateRecursionLevels();\n            _lastUpdateTime = Time.time;\n        }\n    }\n\n    private void InitializeRecursion()\n    {\n        if (_autoDetectMainCamera && _viewerTransform == null)\n        {\n            Camera mainCam = Camera.main;\n            if (mainCam != null)\n                _viewerTransform = mainCam.transform;\n        }\n\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n\n        if (_displayMaterial == null && _targetRenderer != null)\n            _displayMaterial = _targetRenderer.material;\n\n        CreateOriginalSceneReference();\n        SetupRecursionLevels();\n        _isInitialized = true;\n    }\n\n    private void CreateOriginalSceneReference()\n    {\n        GameObject sceneRoot = new GameObject(\"OriginalSceneReference\");\n        _originalScene = sceneRoot.transform;\n\n        Transform[] allObjects = FindObjectsOfType<Transform>();\n        foreach (Transform obj in allObjects)\n        {\n            if (obj.parent == null && obj != transform && obj != sceneRoot.transform)\n            {\n                GameObject copy = Instantiate(obj.gameObject, _originalScene);\n                copy.name = obj.name + \"_Reference\";\n            }\n        }\n    }\n\n    private void SetupRecursionLevels()\n    {\n        for (int i = 0; i < _maxRecursionDepth; i++)\n        {\n            RecursionLevel level = CreateRecursionLevel(i);\n            _recursionLevels.Add(level);\n        }\n    }\n\n    private RecursionLevel CreateRecursionLevel(int depth)\n    {\n        RecursionLevel level = new RecursionLevel();\n\n        // Create render texture\n        level.renderTexture = new RenderTexture(_textureResolution, _textureResolution, 16);\n        level.renderTexture.name = $\"RecursionTexture_Level_{depth}\";\n\n        // Create camera for this level\n        GameObject cameraObj = new GameObject($\"RecursionCamera_Level_{depth}\");\n        cameraObj.transform.SetParent(transform);\n        level.levelCamera = cameraObj.AddComponent<Camera>();\n        \n        ConfigureCamera(level.levelCamera, depth);\n        level.levelCamera.targetTexture = level.renderTexture;\n\n        // Create miniature scene\n        level.miniatureScene = CreateMiniatureScene(depth);\n\n        // Setup audio\n        level.audioSource = gameObject.AddComponent<AudioSource>();\n        ConfigureAudio(level.audioSource, depth);\n        level.pitch = _basePitch * Mathf.Pow(_pitchMultiplier, depth);\n\n        return level;\n    }\n\n    private void ConfigureCamera(Camera cam, int depth)\n    {\n        Camera mainCam = Camera.main;\n        if (mainCam != null)\n        {\n            cam.fieldOfView = mainCam.fieldOfView;\n            cam.nearClipPlane = mainCam.nearClipPlane;\n            cam.farClipPlane = mainCam.farClipPlane;\n        }\n\n        cam.cullingMask = _renderLayers;\n        cam.enabled = false;\n    }\n\n    private Transform CreateMiniatureScene(int depth)\n    {\n        if (_originalScene == null) return null;\n\n        GameObject miniature = new GameObject($\"MiniatureScene_Level_{depth}\");\n        miniature.transform.SetParent(transform);\n\n        float scale = Mathf.Pow(_scaleReduction, depth + 1);\n        miniature.transform.localScale = Vector3.one * scale;\n        miniature.transform.localPosition = _miniatureOffset * (depth + 1);\n\n        // Copy scene objects\n        foreach (Transform child in _originalScene)\n        {\n            GameObject copy = Instantiate(child.gameObject, miniature.transform);\n            \n            // Ensure recursive objects in miniature also have this script\n            RecursiveRealityObject recursiveScript = copy.GetComponent<RecursiveRealityObject>();\n            if (recursiveScript != null && recursiveScript != this)\n            {\n                recursiveScript._maxRecursionDepth = Mathf.Max(0, _maxRecursionDepth - depth - 1);\n            }\n        }\n\n        return miniature.transform;\n    }\n\n    private void ConfigureAudio(AudioSource audioSource, int depth)\n    {\n        audioSource.clip = _baseNote;\n        audioSource.volume = Mathf.Pow(_volumeReduction, depth);\n        audioSource.pitch = _basePitch * Mathf.Pow(_pitchMultiplier, depth);\n        audioSource.spatialBlend = 1f;\n        audioSource.maxDistance = _maxAudioDistance;\n        audioSource.rolloffMode = AudioRolloffMode.Linear;\n        audioSource.playOnAwake = false;\n        audioSource.loop = true;\n    }\n\n    private void UpdateRecursionLevels()\n    {\n        if (_viewerTransform == null) return;\n\n        float distanceToViewer = Vector3.Distance(_viewerTransform.position, transform.position);\n        int targetDepth = CalculateTargetDepth(distanceToViewer);\n\n        UpdateActiveDepth(targetDepth);\n        UpdateCameraPositions();\n        UpdateRenderTextures();\n        UpdateAudio();\n    }\n\n    private int CalculateTargetDepth(float distance)\n    {\n        if (_enableLOD && distance > _lodDistance)\n            return 0;\n\n        float zoomFactor = _zoomThreshold / Mathf.Max(distance, 0.1f);\n        int depth = Mathf.FloorToInt(Mathf.Log(zoomFactor, 2f));\n        return Mathf.Clamp(depth, 0, _maxRecursionDepth - 1);\n    }\n\n    private void UpdateActiveDepth(int targetDepth)\n    {\n        if (targetDepth == _currentActiveDepth) return;\n\n        // Deactivate old levels\n        for (int i = _currentActiveDepth; i < _recursionLevels.Count; i++)\n        {\n            if (i < _recursionLevels.Count)\n            {\n                _recursionLevels[i].isActive = false;\n                _recursionLevels[i].levelCamera.enabled = false;\n                if (_recursionLevels[i].audioSource.isPlaying)\n                    _recursionLevels[i].audioSource.Stop();\n            }\n        }\n\n        // Activate new levels\n        for (int i = 0; i <= targetDepth && i < _recursionLevels.Count; i++)\n        {\n            _recursionLevels[i].isActive = true;\n            _recursionLevels[i].levelCamera.enabled = true;\n        }\n\n        _currentActiveDepth = targetDepth;\n    }\n\n    private void UpdateCameraPositions()\n    {\n        if (_viewerTransform == null) return;\n\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            if (!_recursionLevels[i].isActive) continue;\n\n            RecursionLevel level = _recursionLevels[i];\n            \n            // Position camera to look at miniature scene\n            Vector3 cameraOffset = _viewerTransform.position - transform.position;\n            float scale = Mathf.Pow(_scaleReduction, i + 1);\n            \n            level.levelCamera.transform.position = level.miniatureScene.position + cameraOffset * scale;\n            level.levelCamera.transform.LookAt(level.miniatureScene.position);\n        }\n    }\n\n    private void UpdateRenderTextures()\n    {\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            if (!_recursionLevels[i].isActive) continue;\n\n            RecursionLevel level = _recursionLevels[i];\n            level.levelCamera.Render();\n\n            // Apply texture to material\n            if (_displayMaterial != null && i == 0)\n            {\n                _displayMaterial.mainTexture = level.renderTexture;\n            }\n        }\n    }\n\n    private void UpdateAudio()\n    {\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            RecursionLevel level = _recursionLevels[i];\n            \n            if (level.isActive && !level.audioSource.isPlaying)\n            {\n                level.audioSource.Play();\n            }\n            else if (!level.isActive && level.audioSource.isPlaying)\n            {\n                level.audioSource.Stop();\n            }\n        }\n    }\n\n    private void OnDestroy()\n    {\n        foreach (RecursionLevel level in _recursionLevels)\n        {\n            if (level.renderTexture != null)\n            {\n                level.renderTexture.Release();\n                DestroyImmediate(level.renderTexture);\n            }\n        }\n    }\n\n    private void OnValidate()\n    {\n        _maxRecursionDepth = Mathf.Clamp(_maxRecursionDepth, 1, 10);\n        _scaleReduction = Mathf.Clamp01(_scaleReduction);\n        _textureResolution = Mathf.ClosestPowerOfTwo(Mathf.Clamp(_textureResolution, 64, 2048));\n        _updateInterval = Mathf.Max(0.01f, _updateInterval);\n    }\n\n    public void SetRecursionDepth(int depth)\n    {\n        _maxRecursionDepth = Mathf.Clamp(depth, 1, 10);\n        if (_isInitialized)\n        {\n            ClearRecursionLevels();\n            SetupRecursionLevels();\n        }\n    }\n\n    private void ClearRecursionLevels()\n    {\n        foreach (RecursionLevel level in _recursionLevels)\n        {\n            if (level.levelCamera != null)\n                DestroyImmediate(level.levelCamera.gameObject);\n            if (level.renderTexture != null)\n            {\n                level.renderTexture.Release();\n                DestroyImmediate(level.renderTexture);\n            }\n            if (level.miniatureScene != null)\n                DestroyImmediate(level.miniatureScene.gameObject);\n        }\n        _recursionLevels.Clear();\n    }\n}",
      "behavior_type": "combat"
    },
    {
      "prompt": "chaos engine that randomly selects from 20 different behaviors every 3 seconds (spin, bounce, scale pulse, color shift, audio play, particle burst, force application, teleport, rotation etc) - never repeats same behavior twice in a row, after 60 seconds settles into calm meditative state",
      "ideal_ir": {
        "class_name": "ChaosEngine",
        "components": [
          "Rigidbody",
          "AudioSource",
          "ParticleSystem",
          "MeshRenderer"
        ],
        "fields": [
          {
            "name": "behaviorTimer",
            "type": "float",
            "default": 0
          },
          {
            "name": "behaviorInterval",
            "type": "float",
            "default": 3
          },
          {
            "name": "totalChaosTime",
            "type": "float",
            "default": 0
          },
          {
            "name": "chaosDuration",
            "type": "float",
            "default": 60
          },
          {
            "name": "lastBehaviorIndex",
            "type": "int",
            "default": -1
          },
          {
            "name": "isInCalmState",
            "type": "bool",
            "default": false
          },
          {
            "name": "spinSpeed",
            "type": "float",
            "default": 180
          },
          {
            "name": "bounceForce",
            "type": "float",
            "default": 10
          },
          {
            "name": "scaleMultiplier",
            "type": "float",
            "default": 1.5
          },
          {
            "name": "teleportRange",
            "type": "float",
            "default": 10
          },
          {
            "name": "forceStrength",
            "type": "float",
            "default": 15
          }
        ],
        "behaviors": [
          {
            "name": "chaos_behavior_timer",
            "trigger": "every frame during chaos mode",
            "actions": [
              {
                "action": "increment behavior timer by frame time"
              },
              {
                "action": "increment total chaos time by frame time"
              }
            ]
          },
          {
            "name": "select_random_behavior",
            "trigger": "when behavior timer exceeds interval and not in calm state",
            "actions": [
              {
                "action": "generate random number from zero to nineteen excluding last behavior index"
              },
              {
                "action": "store new behavior index as last behavior index"
              },
              {
                "action": "reset behavior timer to zero"
              },
              {
                "action": "execute behavior based on random index"
              }
            ]
          },
          {
            "name": "spin_behavior",
            "trigger": "when behavior index is zero",
            "actions": [
              {
                "action": "rotate object around random axis at spin speed for duration"
              }
            ]
          },
          {
            "name": "bounce_behavior",
            "trigger": "when behavior index is one",
            "actions": [
              {
                "action": "apply upward force with bounce force strength"
              },
              {
                "action": "add random horizontal force component"
              }
            ]
          },
          {
            "name": "scale_pulse_behavior",
            "trigger": "when behavior index is two",
            "actions": [
              {
                "action": "animate scale from current size to scale multiplier and back over duration"
              }
            ]
          },
          {
            "name": "color_shift_behavior",
            "trigger": "when behavior index is three",
            "actions": [
              {
                "action": "change material color to random bright color"
              },
              {
                "action": "animate color transition over half the duration"
              }
            ]
          },
          {
            "name": "audio_play_behavior",
            "trigger": "when behavior index is four",
            "actions": [
              {
                "action": "play random audio clip from collection"
              },
              {
                "action": "set random pitch between half and double speed"
              }
            ]
          },
          {
            "name": "particle_burst_behavior",
            "trigger": "when behavior index is five",
            "actions": [
              {
                "action": "emit burst of particles with random colors"
              },
              {
                "action": "set particle velocity in random directions"
              }
            ]
          },
          {
            "name": "force_application_behavior",
            "trigger": "when behavior index is six",
            "actions": [
              {
                "action": "apply force in random direction with force strength"
              },
              {
                "action": "add random torque for spinning effect"
              }
            ]
          },
          {
            "name": "teleport_behavior",
            "trigger": "when behavior index is seven",
            "actions": [
              {
                "action": "move object to random position within teleport range"
              },
              {
                "action": "create visual effect at old and new positions"
              }
            ]
          },
          {
            "name": "rapid_rotation_behavior",
            "trigger": "when behavior index is eight",
            "actions": [
              {
                "action": "rotate rapidly around all three axes simultaneously"
              }
            ]
          },
          {
            "name": "gravity_flip_behavior",
            "trigger": "when behavior index is nine",
            "actions": [
              {
                "action": "reverse gravity direction for the object temporarily"
              }
            ]
          },
          {
            "name": "size_randomize_behavior",
            "trigger": "when behavior index is ten",
            "actions": [
              {
                "action": "set scale to random value between half and triple size"
              }
            ]
          },
          {
            "name": "material_swap_behavior",
            "trigger": "when behavior index is eleven",
            "actions": [
              {
                "action": "change to random material from predefined collection"
              }
            ]
          },
          {
            "name": "vibration_behavior",
            "trigger": "when behavior index is twelve",
            "actions": [
              {
                "action": "shake position rapidly in small random movements"
              }
            ]
          },
          {
            "name": "trail_behavior",
            "trigger": "when behavior index is thirteen",
            "actions": [
              {
                "action": "enable trail renderer with random color"
              },
              {
                "action": "move in curved path to create visible trail"
              }
            ]
          },
          {
            "name": "phase_behavior",
            "trigger": "when behavior index is fourteen",
            "actions": [
              {
                "action": "make object semi-transparent and disable collisions temporarily"
              }
            ]
          },
          {
            "name": "magnetic_behavior",
            "trigger": "when behavior index is fifteen",
            "actions": [
              {
                "action": "attract or repel nearby objects with invisible force"
              }
            ]
          },
          {
            "name": "clone_behavior",
            "trigger": "when behavior index is sixteen",
            "actions": [
              {
                "action": "create temporary duplicate at random nearby position"
              },
              {
                "action": "destroy duplicate after short delay"
              }
            ]
          },
          {
            "name": "orbit_behavior",
            "trigger": "when behavior index is seventeen",
            "actions": [
              {
                "action": "move in circular orbit around original position"
              }
            ]
          },
          {
            "name": "strobe_behavior",
            "trigger": "when behavior index is eighteen",
            "actions": [
              {
                "action": "rapidly toggle visibility on and off"
              }
            ]
          },
          {
            "name": "explosion_behavior",
            "trigger": "when behavior index is nineteen",
            "actions": [
              {
                "action": "create expanding sphere effect around object"
              },
              {
                "action": "push away nearby objects with force"
              }
            ]
          },
          {
            "name": "enter_calm_state",
            "trigger": "when total chaos time exceeds chaos duration",
            "actions": [
              {
                "action": "set calm state flag to true"
              },
              {
                "action": "stop all chaotic movements"
              },
              {
                "action": "gradually return to original scale and rotation"
              },
              {
                "action": "fade to peaceful blue color"
              },
              {
                "action": "play soft ambient sound"
              }
            ]
          },
          {
            "name": "maintain_calm_state",
            "trigger": "when in calm state",
            "actions": [
              {
                "action": "gently float up and down with slow breathing motion"
              },
              {
                "action": "emit soft particle effects occasionally"
              },
              {
                "action": "maintain peaceful blue color"
              }
            ]
          }
        ]
      },
      "good_code": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class ChaosEngine : MonoBehaviour\n{\n    [Header(\"Chaos Settings\")]\n    [SerializeField] private float _behaviorInterval = 3f;\n    [SerializeField] private float _chaosModeDuration = 60f;\n    [SerializeField] private bool _startInChaosMode = true;\n    \n    [Header(\"Movement Behaviors\")]\n    [SerializeField] private float _spinSpeed = 360f;\n    [SerializeField] private float _bounceForce = 10f;\n    [SerializeField] private float _teleportRadius = 20f;\n    [SerializeField] private float _forceStrength = 500f;\n    \n    [Header(\"Visual Behaviors\")]\n    [SerializeField] private AnimationCurve _scalePulseCurve = AnimationCurve.EaseInOut(0, 1, 1, 2);\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private Color[] _colorShiftColors = { Color.red, Color.blue, Color.green, Color.yellow, Color.magenta };\n    [SerializeField] private float _colorShiftDuration = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _chaosAudioClips;\n    [SerializeField] private AudioClip _meditativeAudioClip;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Particles\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private int _burstParticleCount = 50;\n    \n    [Header(\"Meditative State\")]\n    [SerializeField] private float _meditativeRotationSpeed = 30f;\n    [SerializeField] private Color _meditativeColor = Color.white;\n    [SerializeField] private float _meditativeTransitionDuration = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnChaosStart;\n    public UnityEvent OnMeditativeStateEnter;\n    \n    private enum ChaoseBehavior\n    {\n        Spin, Bounce, ScalePulse, ColorShift, AudioPlay, ParticleBurst,\n        ForceApplication, Teleport, RotationFlip, Shake, Orbit, Wobble,\n        FlashScale, RandomJump, ColorCycle, SpeedBurst, GravityFlip,\n        Vibrate, SizeOscillate, DirectionalSpin\n    }\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Vector3 _originalScale;\n    private Vector3 _originalPosition;\n    private Color _originalColor;\n    \n    private bool _isInChaosMode = true;\n    private bool _isInMeditativeState = false;\n    private float _chaosTimer = 0f;\n    private ChaoseBehavior _lastBehavior = ChaoseBehavior.Spin;\n    private Coroutine _currentBehaviorCoroutine;\n    private Coroutine _meditativeTransitionCoroutine;\n    \n    private List<ChaoseBehavior> _availableBehaviors;\n    \n    void Start()\n    {\n        InitializeComponents();\n        InitializeBehaviors();\n        \n        if (_startInChaosMode)\n        {\n            StartChaosMode();\n        }\n    }\n    \n    void Update()\n    {\n        if (_isInChaosMode && !_isInMeditativeState)\n        {\n            _chaosTimer += Time.deltaTime;\n            \n            if (_chaosTimer >= _chaosModeDuration)\n            {\n                EnterMeditativeState();\n            }\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n            _renderer = GetComponentInChildren<Renderer>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_particleSystem == null)\n            _particleSystem = GetComponentInChildren<ParticleSystem>();\n        \n        _originalScale = transform.localScale;\n        _originalPosition = transform.position;\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _originalColor = _renderer.material.color;\n        }\n    }\n    \n    private void InitializeBehaviors()\n    {\n        _availableBehaviors = new List<ChaoseBehavior>();\n        for (int i = 0; i < System.Enum.GetValues(typeof(ChaoseBehavior)).Length; i++)\n        {\n            _availableBehaviors.Add((ChaoseBehavior)i);\n        }\n    }\n    \n    private void StartChaosMode()\n    {\n        _isInChaosMode = true;\n        _chaosTimer = 0f;\n        OnChaosStart?.Invoke();\n        StartCoroutine(ChaosLoop());\n    }\n    \n    private IEnumerator ChaosLoop()\n    {\n        while (_isInChaosMode && !_isInMeditativeState)\n        {\n            ChaoseBehavior nextBehavior = GetRandomBehavior();\n            ExecuteBehavior(nextBehavior);\n            _lastBehavior = nextBehavior;\n            \n            yield return new WaitForSeconds(_behaviorInterval);\n        }\n    }\n    \n    private ChaoseBehavior GetRandomBehavior()\n    {\n        List<ChaoseBehavior> availableChoices = new List<ChaoseBehavior>(_availableBehaviors);\n        availableChoices.Remove(_lastBehavior);\n        \n        return availableChoices[Random.Range(0, availableChoices.Count)];\n    }\n    \n    private void ExecuteBehavior(ChaoseBehavior behavior)\n    {\n        if (_currentBehaviorCoroutine != null)\n            StopCoroutine(_currentBehaviorCoroutine);\n            \n        switch (behavior)\n        {\n            case ChaoseBehavior.Spin:\n                _currentBehaviorCoroutine = StartCoroutine(SpinBehavior());\n                break;\n            case ChaoseBehavior.Bounce:\n                _currentBehaviorCoroutine = StartCoroutine(BounceBehavior());\n                break;\n            case ChaoseBehavior.ScalePulse:\n                _currentBehaviorCoroutine = StartCoroutine(ScalePulseBehavior());\n                break;\n            case ChaoseBehavior.ColorShift:\n                _currentBehaviorCoroutine = StartCoroutine(ColorShiftBehavior());\n                break;\n            case ChaoseBehavior.AudioPlay:\n                _currentBehaviorCoroutine = StartCoroutine(AudioPlayBehavior());\n                break;\n            case ChaoseBehavior.ParticleBurst:\n                _currentBehaviorCoroutine = StartCoroutine(ParticleBurstBehavior());\n                break;\n            case ChaoseBehavior.ForceApplication:\n                _currentBehaviorCoroutine = StartCoroutine(ForceApplicationBehavior());\n                break;\n            case ChaoseBehavior.Teleport:\n                _currentBehaviorCoroutine = StartCoroutine(TeleportBehavior());\n                break;\n            case ChaoseBehavior.RotationFlip:\n                _currentBehaviorCoroutine = StartCoroutine(RotationFlipBehavior());\n                break;\n            case ChaoseBehavior.Shake:\n                _currentBehaviorCoroutine = StartCoroutine(ShakeBehavior());\n                break;\n            case ChaoseBehavior.Orbit:\n                _currentBehaviorCoroutine = StartCoroutine(OrbitBehavior());\n                break;\n            case ChaoseBehavior.Wobble:\n                _currentBehaviorCoroutine = StartCoroutine(WobbleBehavior());\n                break;\n            case ChaoseBehavior.FlashScale:\n                _currentBehaviorCoroutine = StartCoroutine(FlashScaleBehavior());\n                break;\n            case ChaoseBehavior.RandomJump:\n                _currentBehaviorCoroutine = StartCoroutine(RandomJumpBehavior());\n                break;\n            case ChaoseBehavior.ColorCycle:\n                _currentBehaviorCoroutine = StartCoroutine(ColorCycleBehavior());\n                break;\n            case ChaoseBehavior.SpeedBurst:\n                _currentBehaviorCoroutine = StartCoroutine(SpeedBurstBehavior());\n                break;\n            case ChaoseBehavior.GravityFlip:\n                _currentBehaviorCoroutine = StartCoroutine(GravityFlipBehavior());\n                break;\n            case ChaoseBehavior.Vibrate:\n                _currentBehaviorCoroutine = StartCoroutine(VibrateBehavior());\n                break;\n            case ChaoseBehavior.SizeOscillate:\n                _currentBehaviorCoroutine = StartCoroutine(SizeOscillateBehavior());\n                break;\n            case ChaoseBehavior.DirectionalSpin:\n                _currentBehaviorCoroutine = StartCoroutine(DirectionalSpinBehavior());\n                break;\n        }\n    }\n    \n    private IEnumerator SpinBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        Vector3 spinAxis = Random.insideUnitSphere.normalized;\n        \n        while (elapsed < duration)\n        {\n            transform.Rotate(spinAxis * _spinSpeed * Time.deltaTime);\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n    }\n    \n    private IEnumerator BounceBehavior()\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 bounceDirection = Vector3.up + Random.insideUnitSphere * 0.5f;\n            _rigidbody.AddForce(bounceDirection.normalized * _bounceForce, ForceMode.Impulse);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ScalePulseBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float normalizedTime = elapsed / duration;\n            float scaleMultiplier = _scalePulseCurve.Evaluate(normalizedTime * _pulseSpeed % 1f);\n            transform.localScale = _originalScale * scaleMultiplier;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n    }\n    \n    private IEnumerator ColorShiftBehavior()\n    {\n        if (_renderer != null && _colorShiftColors.Length > 0)\n        {\n            Color targetColor = _colorShiftColors[Random.Range(0, _colorShiftColors.Length)];\n            Color startColor = _renderer.material.color;\n            float elapsed = 0f;\n            \n            while (elapsed < _colorShiftDuration)\n            {\n                _renderer.material.color = Color.Lerp(startColor, targetColor, elapsed / _colorShiftDuration);\n                elapsed += Time.deltaTime;\n                yield return null;\n            }\n        }\n        yield return null;\n    }\n    \n    private IEnumerator AudioPlayBehavior()\n    {\n        if (_audioSource != null && _chaosAudioClips.Length > 0)\n        {\n            AudioClip clip = _chaosAudioClips[Random.Range(0, _chaosAudioClips.Length)];\n            _audioSource.clip = clip;\n            _audioSource.volume = _audioVolume;\n            _audioSource.Play();\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ParticleBurstBehavior()\n    {\n        if (_particleSystem != null)\n        {\n            _particleSystem.Emit(_burstParticleCount);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ForceApplicationBehavior()\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 randomForce = Random.insideUnitSphere * _forceStrength;\n            _rigidbody.AddForce(randomForce, ForceMode.Impulse);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator TeleportBehavior()\n    {\n        Vector3 randomOffset = Random.insideUnitSphere * _teleportRadius;\n        randomOffset.y = Mathf.Abs(randomOffset.y);\n        transform.position = _originalPosition + randomOffset;\n        yield return null;\n    }\n    \n    private IEnumerator RotationFlipBehavior()\n    {\n        Vector3 randomRotation = new Vector3(\n            Random.Range(0, 360),\n            Random.Range(0, 360),\n            Random.Range(0, 360)\n        );\n        transform.rotation = Quaternion.Euler(randomRotation);\n        yield return null;\n    }\n    \n    private IEnumerator ShakeBehavior()\n    {\n        float duration = _behaviorInterval * 0.6f;\n        float elapsed = 0f;\n        Vector3 originalPos = transform.position;\n        \n        while (elapsed < duration)\n        {\n            Vector3 shakeOffset = Random.insideUnitSphere * 0.5f;\n            transform.position = originalPos + shakeOffset;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.position = originalPos;\n    }\n    \n    private IEnumerator OrbitBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        Vector3 center = _originalPosition;\n        float radius = 5f;\n        \n        while (elapsed < duration)\n        {\n            float angle = (elapsed / duration) * 360f * 2f;\n            Vector3 offset = new Vector3(\n                Mathf.Cos(angle * Mathf.Deg2Rad) * radius,\n                Mathf.Sin(angle * Mathf.Deg2Rad) * radius * 0.5f,\n                Mathf.Sin(angle * Mathf.Deg2Rad * 0.5f) * radius\n            );\n            transform.position = center + offset;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n    }\n    \n    private IEnumerator WobbleBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float wobbleX = Mathf.Sin(elapsed * 10f) * 0.3f;\n            float wobbleZ = Mathf.Cos(elapsed * 8f) * 0.3f;\n            transform.localScale = _originalScale + new Vector3(wobbleX, 0, wobbleZ);\n            elapsed += Time.deltaTime;\n            yield return null;",
      "behavior_type": "general"
    }
  ]
}