{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"NetLauncher\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"launchForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"netPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"launchPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isReloaded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"launchSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"launch_net\",\n      \"trigger\": \"when fire input is pressed and launcher is reloaded\",\n      \"actions\": [\n        {\n          \"action\": \"play launch sound effect\"\n        },\n        {\n          \"action\": \"instantiate net prefab at launch point\"\n        },\n        {\n          \"action\": \"apply launch force to net in forward direction\"\n        },\n        {\n          \"action\": \"set launcher to not reloaded state\"\n        },\n        {\n          \"action\": \"start reload timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_launcher\",\n      \"trigger\": \"when reload time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set launcher to reloaded state\"\n        },\n        {\n          \"action\": \"play reload complete sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"aim_launcher\",\n      \"trigger\": \"when aiming input is active\",\n      \"actions\": [\n        {\n          \"action\": \"rotate launcher to follow crosshair or mouse position\"\n        },\n        {\n          \"action\": \"show trajectory preview line\"\n        },\n        {\n          \"action\": \"highlight potential targets within range\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_ready_indicator\",\n      \"trigger\": \"when launcher is reloaded\",\n      \"actions\": [\n        {\n          \"action\": \"display ready indicator light or UI element\"\n        },\n        {\n          \"action\": \"enable aiming assistance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class NetLauncher : MonoBehaviour\n{\n    [Header(\"Net Projectile\")]\n    [SerializeField] private GameObject _netPrefab;\n    [SerializeField] private Transform _launchPoint;\n    [SerializeField] private float _launchForce = 15f;\n    [SerializeField] private float _launchAngle = 45f;\n    \n    [Header(\"Capture Settings\")]\n    [SerializeField] private LayerMask _capturableLayers = -1;\n    [SerializeField] private float _captureRadius = 3f;\n    [SerializeField] private float _captureDuration = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _launchKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseAiming = true;\n    \n    [Header(\"Cooldown\")]\n    [SerializeField] private float _cooldownTime = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _launchSound;\n    [SerializeField] private AudioClip _captureSound;\n    \n    private Camera _playerCamera;\n    private AudioSource _audioSource;\n    private float _lastLaunchTime;\n    private bool _canLaunch = true;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_launchPoint == null)\n            _launchPoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_launchKey) && _canLaunch)\n        {\n            LaunchNet();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canLaunch && Time.time >= _lastLaunchTime + _cooldownTime)\n        {\n            _canLaunch = true;\n        }\n    }\n    \n    private void LaunchNet()\n    {\n        if (_netPrefab == null) return;\n        \n        Vector3 launchDirection = GetLaunchDirection();\n        GameObject netInstance = Instantiate(_netPrefab, _launchPoint.position, Quaternion.LookRotation(launchDirection));\n        \n        NetProjectile netProjectile = netInstance.GetComponent<NetProjectile>();\n        if (netProjectile == null)\n            netProjectile = netInstance.AddComponent<NetProjectile>();\n            \n        netProjectile.Initialize(launchDirection, _launchForce, _capturableLayers, _captureRadius, _captureDuration, _captureSound);\n        \n        PlayLaunchSound();\n        \n        _canLaunch = false;\n        _lastLaunchTime = Time.time;\n    }\n    \n    private Vector3 GetLaunchDirection()\n    {\n        Vector3 direction;\n        \n        if (_useMouseAiming && _playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            direction = ray.direction;\n        }\n        else\n        {\n            direction = transform.forward;\n        }\n        \n        float angleInRadians = _launchAngle * Mathf.Deg2Rad;\n        Vector3 horizontalDirection = new Vector3(direction.x, 0, direction.z).normalized;\n        direction = horizontalDirection + Vector3.up * Mathf.Tan(angleInRadians);\n        \n        return direction.normalized;\n    }\n    \n    private void PlayLaunchSound()\n    {\n        if (_audioSource != null && _launchSound != null)\n        {\n            _audioSource.PlayOneShot(_launchSound);\n        }\n    }\n}\n\npublic class NetProjectile : MonoBehaviour\n{\n    private Vector3 _velocity;\n    private LayerMask _capturableLayers;\n    private float _captureRadius;\n    private float _captureDuration;\n    private AudioClip _captureSound;\n    private bool _hasLanded;\n    private List<GameObject> _capturedObjects = new List<GameObject>();\n    private AudioSource _audioSource;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _drag = 0.1f;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private GameObject _netMesh;\n    [SerializeField] private ParticleSystem _captureEffect;\n    \n    public void Initialize(Vector3 direction, float force, LayerMask capturableLayers, float captureRadius, float captureDuration, AudioClip captureSound)\n    {\n        _velocity = direction * force;\n        _capturableLayers = capturableLayers;\n        _captureRadius = captureRadius;\n        _captureDuration = captureDuration;\n        _captureSound = captureSound;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, 10f);\n    }\n    \n    private void Update()\n    {\n        if (!_hasLanded)\n        {\n            UpdateProjectileMovement();\n            CheckGroundHit();\n        }\n    }\n    \n    private void UpdateProjectileMovement()\n    {\n        _velocity.y -= _gravity * Time.deltaTime;\n        _velocity *= (1f - _drag * Time.deltaTime);\n        transform.position += _velocity * Time.deltaTime;\n        \n        if (_velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_velocity);\n        }\n    }\n    \n    private void CheckGroundHit()\n    {\n        if (transform.position.y <= 0.1f || _velocity.y < 0 && Physics.Raycast(transform.position, Vector3.down, 0.5f))\n        {\n            LandNet();\n        }\n    }\n    \n    private void LandNet()\n    {\n        _hasLanded = true;\n        _velocity = Vector3.zero;\n        \n        if (_netMesh != null)\n        {\n            _netMesh.SetActive(true);\n            _netMesh.transform.localScale = Vector3.one * _captureRadius;\n        }\n        \n        CaptureNearbyObjects();\n        StartCoroutine(ReleaseAfterDuration());\n    }\n    \n    private void CaptureNearbyObjects()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _captureRadius, _capturableLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject != gameObject)\n            {\n                CaptureObject(col.gameObject);\n            }\n        }\n        \n        if (_capturedObjects.Count > 0)\n        {\n            PlayCaptureSound();\n            PlayCaptureEffect();\n        }\n    }\n    \n    private void CaptureObject(GameObject target)\n    {\n        if (_capturedObjects.Contains(target)) return;\n        \n        _capturedObjects.Add(target);\n        \n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.isKinematic = true;\n        }\n        \n        CapturedObject capturedComponent = target.GetComponent<CapturedObject>();\n        if (capturedComponent == null)\n            capturedComponent = target.AddComponent<CapturedObject>();\n            \n        capturedComponent.SetCaptured(true, transform.position);\n    }\n    \n    private void PlayCaptureSound()\n    {\n        if (_audioSource != null && _captureSound != null)\n        {\n            _audioSource.PlayOneShot(_captureSound);\n        }\n    }\n    \n    private void PlayCaptureEffect()\n    {\n        if (_captureEffect != null)\n        {\n            _captureEffect.Play();\n        }\n    }\n    \n    private IEnumerator ReleaseAfterDuration()\n    {\n        yield return new WaitForSeconds(_captureDuration);\n        ReleaseAllObjects();\n        Destroy(gameObject);\n    }\n    \n    private void ReleaseAllObjects()\n    {\n        foreach (GameObject capturedObj in _capturedObjects)\n        {\n            if (capturedObj != null)\n            {\n                Rigidbody rb = capturedObj.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    rb.isKinematic = false;\n                }\n                \n                CapturedObject capturedComponent = capturedObj.GetComponent<CapturedObject>();\n                if (capturedComponent != null)\n                {\n                    capturedComponent.SetCaptured(false, Vector3.zero);\n                }\n            }\n        }\n        _capturedObjects.Clear();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_hasLanded)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, _captureRadius);\n        }\n    }\n}\n\npublic class CapturedObject : MonoBehaviour\n{\n    private bool _isCaptured;\n    private Vector3 _captureCenter;\n    private Vector3 _originalPosition;\n    private Rigidbody _rigidbody;\n    \n    [Header(\"Capture Behavior\")]\n    [SerializeField] private float _pullStrength = 5f;\n    [SerializeField] private float _maxDistanceFromCenter = 2f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _originalPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        if (_isCaptured)\n        {\n            ApplyCaptureForces();\n        }\n    }\n    \n    public void SetCaptured(bool captured, Vector3 captureCenter)\n    {\n        _isCaptured = captured;\n        _captureCenter = captureCenter;\n        \n        if (!captured && _rigidbody != null)\n        {\n            _rigidbody.AddForce(Vector3.up * 2f, ForceMode.Impulse);\n        }\n    }\n    \n    private void ApplyCaptureForces()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector3 directionToCenter = (_captureCenter - transform.position);\n        float distanceToCenter = directionToCenter.magnitude;\n        \n        if (distanceToCenter > _maxDistanceFromCenter)\n        {\n            Vector3 pullForce = directionToCenter.normalized * _pullStrength;\n            _rigidbody.AddForce(pullForce, ForceMode.Force);\n        }\n        \n        _rigidbody.drag = 5f;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.drag = 0f;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ClimbableLadder\",\n  \"components\": [\n    \"BoxCollider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"ladderHeight\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isPlayerClimbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_climbing\",\n      \"trigger\": \"when player enters ladder trigger area and presses climb input\",\n      \"actions\": [\n        {\n          \"action\": \"disable player gravity\"\n        },\n        {\n          \"action\": \"set player climbing state to true\"\n        },\n        {\n          \"action\": \"align player position to ladder center\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_up\",\n      \"trigger\": \"when player is climbing and presses up input\",\n      \"actions\": [\n        {\n          \"action\": \"move player upward at climb speed\"\n        },\n        {\n          \"action\": \"play climbing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_down\",\n      \"trigger\": \"when player is climbing and presses down input\",\n      \"actions\": [\n        {\n          \"action\": \"move player downward at climb speed\"\n        },\n        {\n          \"action\": \"play climbing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_climbing\",\n      \"trigger\": \"when player is climbing and presses jump input or reaches ladder top or bottom\",\n      \"actions\": [\n        {\n          \"action\": \"enable player gravity\"\n        },\n        {\n          \"action\": \"set player climbing state to false\"\n        },\n        {\n          \"action\": \"restore normal player movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_ladder_area\",\n      \"trigger\": \"when player leaves ladder trigger area while climbing\",\n      \"actions\": [\n        {\n          \"action\": \"enable player gravity\"\n        },\n        {\n          \"action\": \"set player climbing state to false\"\n        },\n        {\n          \"action\": \"restore normal player movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Ladder : MonoBehaviour\n{\n    [Header(\"Ladder Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private bool _requireInputToClimb = true;\n    [SerializeField] private string _climbInputAxis = \"Vertical\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _climbSound;\n    [SerializeField] private float _climbSoundVolume = 0.5f;\n    \n    private Collider _ladderCollider;\n    private AudioSource _audioSource;\n    private GameObject _currentPlayer;\n    private Rigidbody _playerRigidbody;\n    private bool _isPlayerOnLadder = false;\n    private float _originalGravityScale;\n    private bool _wasKinematic;\n\n    private void Start()\n    {\n        _ladderCollider = GetComponent<Collider>();\n        if (_ladderCollider == null)\n        {\n            Debug.LogError(\"Ladder requires a Collider component!\");\n            return;\n        }\n        \n        if (!_ladderCollider.isTrigger)\n        {\n            _ladderCollider.isTrigger = true;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _climbSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.clip = _climbSound;\n            _audioSource.volume = _climbSoundVolume;\n            _audioSource.loop = true;\n            _audioSource.playOnAwake = false;\n        }\n    }\n\n    private void Update()\n    {\n        if (_isPlayerOnLadder && _currentPlayer != null)\n        {\n            HandleClimbing();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && IsInLayerMask(other.gameObject.layer, _playerLayer))\n        {\n            _currentPlayer = other.gameObject;\n            _playerRigidbody = other.GetComponent<Rigidbody>();\n            \n            if (_playerRigidbody != null)\n            {\n                _isPlayerOnLadder = true;\n                _wasKinematic = _playerRigidbody.isKinematic;\n                _playerRigidbody.useGravity = false;\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            ExitLadder();\n        }\n    }\n\n    private void HandleClimbing()\n    {\n        if (_playerRigidbody == null) return;\n\n        float climbInput = _requireInputToClimb ? Input.GetAxis(_climbInputAxis) : 0f;\n        \n        if (!_requireInputToClimb)\n        {\n            if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n                climbInput = 1f;\n            else if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n                climbInput = -1f;\n        }\n\n        Vector3 climbVelocity = new Vector3(\n            _playerRigidbody.velocity.x,\n            climbInput * _climbSpeed,\n            _playerRigidbody.velocity.z\n        );\n\n        _playerRigidbody.velocity = climbVelocity;\n\n        HandleClimbingAudio(climbInput);\n    }\n\n    private void HandleClimbingAudio(float climbInput)\n    {\n        if (_audioSource == null || _climbSound == null) return;\n\n        bool shouldPlaySound = Mathf.Abs(climbInput) > 0.1f;\n        \n        if (shouldPlaySound && !_audioSource.isPlaying)\n        {\n            _audioSource.Play();\n        }\n        else if (!shouldPlaySound && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n\n    private void ExitLadder()\n    {\n        if (_playerRigidbody != null)\n        {\n            _playerRigidbody.useGravity = true;\n            _playerRigidbody.isKinematic = _wasKinematic;\n        }\n\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n\n        _isPlayerOnLadder = false;\n        _currentPlayer = null;\n        _playerRigidbody = null;\n    }\n\n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n\n    private void OnDisable()\n    {\n        if (_isPlayerOnLadder)\n        {\n            ExitLadder();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(transform.position + col.bounds.center, col.bounds.size);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DifficultySelector\",\n  \"components\": [\n    \"Canvas\",\n    \"GraphicRaycaster\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"selectedDifficulty\",\n      \"type\": \"string\",\n      \"default\": \"Normal\"\n    },\n    {\n      \"name\": \"difficultyOptions\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"Easy\",\n        \"Normal\",\n        \"Hard\"\n      ]\n    },\n    {\n      \"name\": \"easyButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"hardButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"confirmButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"selectedIndicator\",\n      \"type\": \"Image\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"select_easy_difficulty\",\n      \"trigger\": \"when easy button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"set selected difficulty to Easy\"\n        },\n        {\n          \"action\": \"move selection indicator to easy button\"\n        },\n        {\n          \"action\": \"highlight easy button\"\n        },\n        {\n          \"action\": \"remove highlight from other buttons\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_normal_difficulty\",\n      \"trigger\": \"when normal button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"set selected difficulty to Normal\"\n        },\n        {\n          \"action\": \"move selection indicator to normal button\"\n        },\n        {\n          \"action\": \"highlight normal button\"\n        },\n        {\n          \"action\": \"remove highlight from other buttons\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_hard_difficulty\",\n      \"trigger\": \"when hard button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"set selected difficulty to Hard\"\n        },\n        {\n          \"action\": \"move selection indicator to hard button\"\n        },\n        {\n          \"action\": \"highlight hard button\"\n        },\n        {\n          \"action\": \"remove highlight from other buttons\"\n        }\n      ]\n    },\n    {\n      \"name\": \"confirm_difficulty_selection\",\n      \"trigger\": \"when confirm button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"save selected difficulty to game settings\"\n        },\n        {\n          \"action\": \"apply difficulty modifiers to game parameters\"\n        },\n        {\n          \"action\": \"close difficulty selection menu\"\n        },\n        {\n          \"action\": \"proceed to next game state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_difficulty_menu\",\n      \"trigger\": \"when difficulty menu opens\",\n      \"actions\": [\n        {\n          \"action\": \"set normal difficulty as default selection\"\n        },\n        {\n          \"action\": \"position selection indicator on normal button\"\n        },\n        {\n          \"action\": \"highlight normal button\"\n        },\n        {\n          \"action\": \"display all difficulty options\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class DifficultySelector : MonoBehaviour\n{\n    [System.Serializable]\n    public class DifficultySettings\n    {\n        public string name;\n        public string description;\n        public float enemyHealthMultiplier = 1f;\n        public float enemyDamageMultiplier = 1f;\n        public float enemySpeedMultiplier = 1f;\n        public float playerHealthMultiplier = 1f;\n        public float experienceMultiplier = 1f;\n        public int maxLives = 3;\n        public Color difficultyColor = Color.white;\n    }\n\n    [System.Serializable]\n    public class DifficultySelectedEvent : UnityEvent<int, DifficultySettings> { }\n\n    [Header(\"Difficulty Configuration\")]\n    [SerializeField] private List<DifficultySettings> _difficulties = new List<DifficultySettings>();\n    [SerializeField] private int _defaultDifficultyIndex = 1;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _buttonContainer;\n    [SerializeField] private Button _difficultyButtonPrefab;\n    [SerializeField] private Text _difficultyNameText;\n    [SerializeField] private Text _difficultyDescriptionText;\n    [SerializeField] private Button _confirmButton;\n    [SerializeField] private Button _backButton;\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _selectedButtonColor = Color.green;\n    [SerializeField] private Color _normalButtonColor = Color.white;\n    [SerializeField] private float _buttonScaleOnHover = 1.1f;\n\n    [Header(\"Events\")]\n    public DifficultySelectedEvent OnDifficultySelected = new DifficultySelectedEvent();\n    public UnityEvent OnBackPressed = new UnityEvent();\n\n    private List<Button> _difficultyButtons = new List<Button>();\n    private int _selectedDifficultyIndex = -1;\n    private static int _savedDifficultyIndex = -1;\n\n    private void Start()\n    {\n        InitializeDefaultDifficulties();\n        CreateDifficultyButtons();\n        SetupUIEvents();\n        LoadSavedDifficulty();\n    }\n\n    private void InitializeDefaultDifficulties()\n    {\n        if (_difficulties.Count == 0)\n        {\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Easy\",\n                description = \"Relaxed gameplay with weaker enemies and more health\",\n                enemyHealthMultiplier = 0.7f,\n                enemyDamageMultiplier = 0.7f,\n                enemySpeedMultiplier = 0.8f,\n                playerHealthMultiplier = 1.5f,\n                experienceMultiplier = 1.2f,\n                maxLives = 5,\n                difficultyColor = Color.green\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Normal\",\n                description = \"Balanced gameplay for the intended experience\",\n                enemyHealthMultiplier = 1f,\n                enemyDamageMultiplier = 1f,\n                enemySpeedMultiplier = 1f,\n                playerHealthMultiplier = 1f,\n                experienceMultiplier = 1f,\n                maxLives = 3,\n                difficultyColor = Color.yellow\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Hard\",\n                description = \"Challenging gameplay with stronger enemies\",\n                enemyHealthMultiplier = 1.5f,\n                enemyDamageMultiplier = 1.3f,\n                enemySpeedMultiplier = 1.2f,\n                playerHealthMultiplier = 0.8f,\n                experienceMultiplier = 1.5f,\n                maxLives = 2,\n                difficultyColor = Color.red\n            });\n\n            _difficulties.Add(new DifficultySettings\n            {\n                name = \"Nightmare\",\n                description = \"Extreme challenge for hardcore players only\",\n                enemyHealthMultiplier = 2f,\n                enemyDamageMultiplier = 1.8f,\n                enemySpeedMultiplier = 1.5f,\n                playerHealthMultiplier = 0.5f,\n                experienceMultiplier = 2f,\n                maxLives = 1,\n                difficultyColor = Color.magenta\n            });\n        }\n    }\n\n    private void CreateDifficultyButtons()\n    {\n        if (_buttonContainer == null || _difficultyButtonPrefab == null)\n            return;\n\n        ClearExistingButtons();\n\n        for (int i = 0; i < _difficulties.Count; i++)\n        {\n            CreateDifficultyButton(i);\n        }\n    }\n\n    private void ClearExistingButtons()\n    {\n        foreach (Button button in _difficultyButtons)\n        {\n            if (button != null)\n                DestroyImmediate(button.gameObject);\n        }\n        _difficultyButtons.Clear();\n    }\n\n    private void CreateDifficultyButton(int index)\n    {\n        Button button = Instantiate(_difficultyButtonPrefab, _buttonContainer);\n        Text buttonText = button.GetComponentInChildren<Text>();\n        \n        if (buttonText != null)\n        {\n            buttonText.text = _difficulties[index].name;\n            buttonText.color = _difficulties[index].difficultyColor;\n        }\n\n        int capturedIndex = index;\n        button.onClick.AddListener(() => SelectDifficulty(capturedIndex));\n\n        DifficultyButtonHover hoverEffect = button.gameObject.AddComponent<DifficultyButtonHover>();\n        hoverEffect.Initialize(_buttonScaleOnHover);\n\n        _difficultyButtons.Add(button);\n    }\n\n    private void SetupUIEvents()\n    {\n        if (_confirmButton != null)\n            _confirmButton.onClick.AddListener(ConfirmSelection);\n\n        if (_backButton != null)\n            _backButton.onClick.AddListener(() => OnBackPressed.Invoke());\n\n        UpdateConfirmButtonState();\n    }\n\n    private void LoadSavedDifficulty()\n    {\n        int savedIndex = PlayerPrefs.GetInt(\"SelectedDifficulty\", _defaultDifficultyIndex);\n        \n        if (_savedDifficultyIndex != -1)\n            savedIndex = _savedDifficultyIndex;\n\n        if (savedIndex >= 0 && savedIndex < _difficulties.Count)\n        {\n            SelectDifficulty(savedIndex);\n        }\n    }\n\n    public void SelectDifficulty(int index)\n    {\n        if (index < 0 || index >= _difficulties.Count)\n            return;\n\n        _selectedDifficultyIndex = index;\n        UpdateButtonVisuals();\n        UpdateDifficultyInfo();\n        UpdateConfirmButtonState();\n    }\n\n    private void UpdateButtonVisuals()\n    {\n        for (int i = 0; i < _difficultyButtons.Count; i++)\n        {\n            if (_difficultyButtons[i] != null)\n            {\n                ColorBlock colors = _difficultyButtons[i].colors;\n                colors.normalColor = (i == _selectedDifficultyIndex) ? _selectedButtonColor : _normalButtonColor;\n                _difficultyButtons[i].colors = colors;\n            }\n        }\n    }\n\n    private void UpdateDifficultyInfo()\n    {\n        if (_selectedDifficultyIndex < 0 || _selectedDifficultyIndex >= _difficulties.Count)\n            return;\n\n        DifficultySettings selected = _difficulties[_selectedDifficultyIndex];\n\n        if (_difficultyNameText != null)\n            _difficultyNameText.text = selected.name;\n\n        if (_difficultyDescriptionText != null)\n            _difficultyDescriptionText.text = selected.description;\n    }\n\n    private void UpdateConfirmButtonState()\n    {\n        if (_confirmButton != null)\n            _confirmButton.interactable = (_selectedDifficultyIndex >= 0);\n    }\n\n    private void ConfirmSelection()\n    {\n        if (_selectedDifficultyIndex < 0 || _selectedDifficultyIndex >= _difficulties.Count)\n            return;\n\n        PlayerPrefs.SetInt(\"SelectedDifficulty\", _selectedDifficultyIndex);\n        PlayerPrefs.Save();\n\n        _savedDifficultyIndex = _selectedDifficultyIndex;\n\n        OnDifficultySelected.Invoke(_selectedDifficultyIndex, _difficulties[_selectedDifficultyIndex]);\n    }\n\n    public DifficultySettings GetSelectedDifficulty()\n    {\n        if (_selectedDifficultyIndex >= 0 && _selectedDifficultyIndex < _difficulties.Count)\n            return _difficulties[_selectedDifficultyIndex];\n        \n        return _difficulties[_defaultDifficultyIndex];\n    }\n\n    public static DifficultySettings GetCurrentDifficulty()\n    {\n        int savedIndex = PlayerPrefs.GetInt(\"SelectedDifficulty\", 1);\n        \n        if (_savedDifficultyIndex != -1)\n            savedIndex = _savedDifficultyIndex;\n\n        DifficultySelector selector = FindObjectOfType<DifficultySelector>();\n        if (selector != null && savedIndex >= 0 && savedIndex < selector._difficulties.Count)\n            return selector._difficulties[savedIndex];\n\n        return new DifficultySettings\n        {\n            name = \"Normal\",\n            description = \"Default difficulty\",\n            enemyHealthMultiplier = 1f,\n            enemyDamageMultiplier = 1f,\n            enemySpeedMultiplier = 1f,\n            playerHealthMultiplier = 1f,\n            experienceMultiplier = 1f,\n            maxLives = 3,\n            difficultyColor = Color.white\n        };\n    }\n\n    public void ResetToDefault()\n    {\n        SelectDifficulty(_defaultDifficultyIndex);\n    }\n\n    private class DifficultyButtonHover : MonoBehaviour, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IPointerExitHandler\n    {\n        private Vector3 _originalScale;\n        private float _hoverScale;\n\n        public void Initialize(float hoverScale)\n        {\n            _originalScale = transform.localScale;\n            _hoverScale = hoverScale;\n        }\n\n        public void OnPointerEnter(UnityEngine.EventSystems.PointerEventData eventData)\n        {\n            transform.localScale = _originalScale * _hoverScale;\n        }\n\n        public void OnPointerExit(UnityEngine.EventSystems.PointerEventData eventData)\n        {\n            transform.localScale = _originalScale;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Gun\",\n  \"components\": [\n    \"Transform\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"projectilePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"firePoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"projectileSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"ammoCount\",\n      \"type\": \"int\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"maxAmmo\",\n      \"type\": \"int\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"fireSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lastFireTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_projectile\",\n      \"trigger\": \"when fire input is pressed and enough time has passed since last shot and ammo count is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"create projectile at fire point position and rotation\"\n        },\n        {\n          \"action\": \"apply forward velocity to projectile based on projectile speed\"\n        },\n        {\n          \"action\": \"play fire sound effect\"\n        },\n        {\n          \"action\": \"reduce ammo count by one\"\n        },\n        {\n          \"action\": \"record current time as last fire time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_ammo\",\n      \"trigger\": \"when reload input is pressed and ammo count is less than maximum ammo\",\n      \"actions\": [\n        {\n          \"action\": \"set ammo count to maximum ammo value\"\n        },\n        {\n          \"action\": \"play reload sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_rapid_fire\",\n      \"trigger\": \"when fire input is pressed but not enough time has passed since last shot\",\n      \"actions\": [\n        {\n          \"action\": \"ignore the fire input\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_empty_ammo\",\n      \"trigger\": \"when fire input is pressed but ammo count is zero\",\n      \"actions\": [\n        {\n          \"action\": \"play empty chamber sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Gun : MonoBehaviour\n{\n    [System.Serializable]\n    public class Projectile : MonoBehaviour\n    {\n        [Header(\"Projectile Settings\")]\n        [SerializeField] private float _speed = 10f;\n        [SerializeField] private float _lifetime = 5f;\n        [SerializeField] private int _damage = 10;\n        [SerializeField] private LayerMask _hitLayers = -1;\n        \n        private Rigidbody _rigidbody;\n        private bool _hasHit = false;\n        \n        public UnityEvent<GameObject> OnHit;\n        \n        private void Awake()\n        {\n            _rigidbody = GetComponent<Rigidbody>();\n            if (_rigidbody == null)\n                _rigidbody = gameObject.AddComponent<Rigidbody>();\n                \n            _rigidbody.useGravity = false;\n            Destroy(gameObject, _lifetime);\n        }\n        \n        private void Start()\n        {\n            _rigidbody.velocity = transform.forward * _speed;\n        }\n        \n        private void OnTriggerEnter(Collider other)\n        {\n            if (_hasHit) return;\n            \n            if ((_hitLayers.value & (1 << other.gameObject.layer)) != 0)\n            {\n                _hasHit = true;\n                OnHit?.Invoke(other.gameObject);\n                \n                if (other.CompareTag(\"Player\"))\n                {\n                    Debug.Log($\"Player hit for {_damage} damage!\");\n                }\n                \n                Destroy(gameObject);\n            }\n        }\n    }\n    \n    [Header(\"Gun Settings\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private bool _autoFire = false;\n    [SerializeField] private KeyCode _fireKey = KeyCode.Space;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private GameObject _muzzleFlashEffect;\n    \n    [Header(\"Ammo\")]\n    [SerializeField] private int _maxAmmo = 30;\n    [SerializeField] private int _currentAmmo;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    private float _nextFireTime = 0f;\n    private bool _isReloading = false;\n    \n    public UnityEvent OnFire;\n    public UnityEvent OnReload;\n    public UnityEvent OnAmmoEmpty;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_projectilePrefab == null)\n        {\n            _projectilePrefab = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            _projectilePrefab.transform.localScale = Vector3.one * 0.1f;\n            _projectilePrefab.AddComponent<Projectile>();\n            \n            Collider collider = _projectilePrefab.GetComponent<Collider>();\n            if (collider != null)\n                collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isReloading) return;\n        \n        bool shouldFire = false;\n        \n        if (_autoFire)\n        {\n            shouldFire = Input.GetKey(_fireKey);\n        }\n        else\n        {\n            shouldFire = Input.GetKeyDown(_fireKey);\n        }\n        \n        if (shouldFire && CanFire())\n        {\n            Fire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && _currentAmmo < _maxAmmo)\n        {\n            StartReload();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return Time.time >= _nextFireTime && _currentAmmo > 0 && !_isReloading;\n    }\n    \n    public void Fire()\n    {\n        if (!CanFire()) return;\n        \n        _nextFireTime = Time.time + (1f / _fireRate);\n        _currentAmmo--;\n        \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Projectile projectileScript = projectile.GetComponent<Projectile>();\n        if (projectileScript != null)\n        {\n            projectileScript.OnHit.AddListener(OnProjectileHit);\n        }\n        \n        PlayFireEffects();\n        OnFire?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            OnAmmoEmpty?.Invoke();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.PlayOneShot(_fireSound);\n        }\n        \n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n        \n        if (_muzzleFlashEffect != null)\n        {\n            GameObject flash = Instantiate(_muzzleFlashEffect, _firePoint.position, _firePoint.rotation);\n            Destroy(flash, 0.1f);\n        }\n    }\n    \n    private void OnProjectileHit(GameObject hitObject)\n    {\n        Debug.Log($\"Projectile hit: {hitObject.name}\");\n    }\n    \n    public void StartReload()\n    {\n        if (_isReloading || _currentAmmo >= _maxAmmo) return;\n        \n        _isReloading = true;\n        OnReload?.Invoke();\n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n    \n    public void AddAmmo(int amount)\n    {\n        _currentAmmo = Mathf.Min(_currentAmmo + amount, _maxAmmo);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_firePoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_firePoint.position, 0.1f);\n            Gizmos.DrawRay(_firePoint.position, _firePoint.forward * 2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChargeAttack\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"chargeSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"chargeDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"chargeDistance\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"chargeTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isCharging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"chargeDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_charge_hold\",\n      \"trigger\": \"when attack button is pressed and held\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to true\"\n        },\n        {\n          \"action\": \"record current forward direction as charge direction\"\n        },\n        {\n          \"action\": \"reset charge time to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"build_charge_power\",\n      \"trigger\": \"while attack button is held and charging\",\n      \"actions\": [\n        {\n          \"action\": \"increase charge time\"\n        },\n        {\n          \"action\": \"play charging sound effect\"\n        },\n        {\n          \"action\": \"show charging visual effects that intensify over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_charge_attack\",\n      \"trigger\": \"when attack button is released after charging\",\n      \"actions\": [\n        {\n          \"action\": \"launch forward in charge direction at charge speed\"\n        },\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"play charge attack sound\"\n        },\n        {\n          \"action\": \"show charge attack visual trail\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deal_charge_damage\",\n      \"trigger\": \"when colliding with enemy during charge attack\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to enemy based on charge time\"\n        },\n        {\n          \"action\": \"apply knockback force to enemy\"\n        },\n        {\n          \"action\": \"stop charging movement\"\n        },\n        {\n          \"action\": \"play impact effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_charge_on_obstacle\",\n      \"trigger\": \"when colliding with wall or obstacle during charge\",\n      \"actions\": [\n        {\n          \"action\": \"stop charging movement immediately\"\n        },\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"play collision sound\"\n        },\n        {\n          \"action\": \"show impact particles\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ChargeAttack : MonoBehaviour\n{\n    [Header(\"Charge Settings\")]\n    [SerializeField] private KeyCode _chargeKey = KeyCode.Mouse0;\n    [SerializeField] private float _minChargeTime = 0.5f;\n    [SerializeField] private float _maxChargeTime = 3.0f;\n    [SerializeField] private float _minDamage = 10f;\n    [SerializeField] private float _maxDamage = 50f;\n    [SerializeField] private float _minRange = 2f;\n    [SerializeField] private float _maxRange = 8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _chargingEffect;\n    [SerializeField] private GameObject _attackEffect;\n    [SerializeField] private LineRenderer _rangeIndicator;\n    [SerializeField] private Transform _attackPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeStarted;\n    public UnityEvent<float> OnChargeUpdated;\n    public UnityEvent<float, float> OnAttackReleased;\n    \n    private bool _isCharging = false;\n    private float _chargeStartTime;\n    private float _currentChargeTime;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rangeIndicator != null)\n        {\n            _rangeIndicator.enabled = false;\n            _rangeIndicator.positionCount = 2;\n        }\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (_isCharging)\n        {\n            UpdateCharge();\n            UpdateVisualEffects();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_chargeKey))\n        {\n            StartCharge();\n        }\n        else if (Input.GetKeyUp(_chargeKey) && _isCharging)\n        {\n            ReleaseAttack();\n        }\n    }\n    \n    private void StartCharge()\n    {\n        _isCharging = true;\n        _chargeStartTime = Time.time;\n        _currentChargeTime = 0f;\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(true);\n            \n        if (_audioSource != null && _chargeSound != null)\n            _audioSource.PlayOneShot(_chargeSound);\n            \n        OnChargeStarted.Invoke(0f);\n    }\n    \n    private void UpdateCharge()\n    {\n        _currentChargeTime = Time.time - _chargeStartTime;\n        _currentChargeTime = Mathf.Clamp(_currentChargeTime, 0f, _maxChargeTime);\n        \n        float chargePercent = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        OnChargeUpdated.Invoke(chargePercent);\n        \n        if (_currentChargeTime >= _maxChargeTime)\n        {\n            ReleaseAttack();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_rangeIndicator != null && _attackPoint != null)\n        {\n            _rangeIndicator.enabled = true;\n            float currentRange = Mathf.Lerp(_minRange, _maxRange, _currentChargeTime / _maxChargeTime);\n            \n            Vector3 startPos = _attackPoint.position;\n            Vector3 endPos = startPos + _attackPoint.forward * currentRange;\n            \n            _rangeIndicator.SetPosition(0, startPos);\n            _rangeIndicator.SetPosition(1, endPos);\n        }\n    }\n    \n    private void ReleaseAttack()\n    {\n        if (!_isCharging) return;\n        \n        _isCharging = false;\n        \n        if (_chargingEffect != null)\n            _chargingEffect.SetActive(false);\n            \n        if (_rangeIndicator != null)\n            _rangeIndicator.enabled = false;\n        \n        if (_currentChargeTime >= _minChargeTime)\n        {\n            ExecuteAttack();\n        }\n    }\n    \n    private void ExecuteAttack()\n    {\n        float chargePercent = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        float damage = Mathf.Lerp(_minDamage, _maxDamage, chargePercent);\n        float range = Mathf.Lerp(_minRange, _maxRange, chargePercent);\n        \n        if (_attackEffect != null)\n        {\n            GameObject effect = Instantiate(_attackEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(effect, 2f);\n        }\n        \n        if (_audioSource != null && _releaseSound != null)\n            _audioSource.PlayOneShot(_releaseSound);\n        \n        PerformAttack(damage, range);\n        OnAttackReleased.Invoke(damage, range);\n    }\n    \n    private void PerformAttack(float damage, float range)\n    {\n        Vector3 attackOrigin = _attackPoint != null ? _attackPoint.position : transform.position;\n        Vector3 attackDirection = _attackPoint != null ? _attackPoint.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 1f, attackDirection, range);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(damage);\n            }\n            \n            Rigidbody rb = hit.collider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 knockbackDirection = (hit.point - attackOrigin).normalized;\n                rb.AddForce(knockbackDirection * damage * 10f, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public float GetChargePercent()\n    {\n        if (!_isCharging) return 0f;\n        return Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n    \n    public void CancelCharge()\n    {\n        if (_isCharging)\n        {\n            _isCharging = false;\n            \n            if (_chargingEffect != null)\n                _chargingEffect.SetActive(false);\n                \n            if (_rangeIndicator != null)\n                _rangeIndicator.enabled = false;\n        }\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LedgeGrabClimb\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"grabRange\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"grabHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isGrabbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canClimb\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_ledge\",\n      \"trigger\": \"when player is near a ledge and moving upward\",\n      \"actions\": [\n        {\n          \"action\": \"check for ledge within grab range above player\"\n        },\n        {\n          \"action\": \"verify ledge is at appropriate height for grabbing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"grab_ledge\",\n      \"trigger\": \"when ledge is detected and grab input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"snap player position to ledge grab point\"\n        },\n        {\n          \"action\": \"disable gravity and movement controls\"\n        },\n        {\n          \"action\": \"play ledge grab animation\"\n        },\n        {\n          \"action\": \"set grabbing state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hang_on_ledge\",\n      \"trigger\": \"when player is grabbing ledge\",\n      \"actions\": [\n        {\n          \"action\": \"maintain position at ledge grab point\"\n        },\n        {\n          \"action\": \"play hanging idle animation\"\n        },\n        {\n          \"action\": \"listen for climb or drop inputs\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_up\",\n      \"trigger\": \"when grabbing ledge and climb input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"play climb up animation\"\n        },\n        {\n          \"action\": \"move player upward and forward onto ledge\"\n        },\n        {\n          \"action\": \"restore normal movement controls when climb completes\"\n        },\n        {\n          \"action\": \"set grabbing state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drop_from_ledge\",\n      \"trigger\": \"when grabbing ledge and drop input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"release ledge grab\"\n        },\n        {\n          \"action\": \"restore gravity and movement controls\"\n        },\n        {\n          \"action\": \"play falling animation\"\n        },\n        {\n          \"action\": \"set grabbing state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LedgeGrabber : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private LayerMask _ledgeLayerMask = 1;\n    [SerializeField] private float _grabDistance = 1.5f;\n    [SerializeField] private float _grabHeight = 0.5f;\n    [SerializeField] private Vector3 _grabOffset = new Vector3(0, 0.5f, 0);\n    \n    [Header(\"Climb Settings\")]\n    [SerializeField] private float _climbDuration = 1.0f;\n    [SerializeField] private AnimationCurve _climbCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private Vector3 _climbEndOffset = new Vector3(0, 1.5f, 0.5f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _climbKey = KeyCode.Space;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.S;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onLedgeGrabbed;\n    [SerializeField] private UnityEvent _onLedgeReleased;\n    [SerializeField] private UnityEvent _onClimbComplete;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _isGrabbingLedge = false;\n    private bool _isClimbing = false;\n    private Transform _currentLedge;\n    private Vector3 _grabPosition;\n    private Vector3 _climbStartPosition;\n    private Vector3 _climbEndPosition;\n    private float _climbTimer = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"LedgeGrabber requires a Rigidbody component!\");\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isClimbing)\n        {\n            HandleClimbing();\n            return;\n        }\n        \n        if (_isGrabbingLedge)\n        {\n            HandleLedgeInput();\n        }\n        else\n        {\n            CheckForLedgeGrab();\n        }\n    }\n    \n    private void CheckForLedgeGrab()\n    {\n        if (_rigidbody == null || _rigidbody.velocity.y > 0) return;\n        \n        Vector3 rayOrigin = transform.position + Vector3.up * _grabHeight;\n        Vector3 rayDirection = transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _grabDistance, _ledgeLayerMask))\n        {\n            Vector3 ledgeTop = hit.point + Vector3.up * 0.1f;\n            Vector3 checkPosition = ledgeTop + rayDirection * 0.2f;\n            \n            if (!Physics.Raycast(checkPosition, Vector3.down, 0.3f, _ledgeLayerMask))\n            {\n                GrabLedge(hit.transform, hit.point);\n            }\n        }\n    }\n    \n    private void GrabLedge(Transform ledge, Vector3 grabPoint)\n    {\n        _currentLedge = ledge;\n        _isGrabbingLedge = true;\n        _grabPosition = grabPoint + _grabOffset;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.useGravity = false;\n            _rigidbody.isKinematic = true;\n        }\n        \n        transform.position = _grabPosition;\n        transform.LookAt(_grabPosition + transform.forward);\n        \n        _onLedgeGrabbed?.Invoke();\n    }\n    \n    private void HandleLedgeInput()\n    {\n        if (Input.GetKeyDown(_climbKey))\n        {\n            StartClimbing();\n        }\n        else if (Input.GetKeyDown(_releaseKey))\n        {\n            ReleaseLedge();\n        }\n    }\n    \n    private void StartClimbing()\n    {\n        if (_isClimbing || _currentLedge == null) return;\n        \n        _isClimbing = true;\n        _climbTimer = 0f;\n        _climbStartPosition = transform.position;\n        _climbEndPosition = _grabPosition + _climbEndOffset;\n        \n        Vector3 ledgeForward = _currentLedge.forward;\n        if (Vector3.Dot(transform.forward, ledgeForward) < 0)\n        {\n            ledgeForward = -ledgeForward;\n        }\n        _climbEndPosition = _grabPosition + Vector3.up * _climbEndOffset.y + ledgeForward * _climbEndOffset.z;\n    }\n    \n    private void HandleClimbing()\n    {\n        _climbTimer += Time.deltaTime;\n        float progress = _climbTimer / _climbDuration;\n        \n        if (progress >= 1f)\n        {\n            CompleteClimb();\n            return;\n        }\n        \n        float curveValue = _climbCurve.Evaluate(progress);\n        Vector3 currentPosition = Vector3.Lerp(_climbStartPosition, _climbEndPosition, curveValue);\n        transform.position = currentPosition;\n    }\n    \n    private void CompleteClimb()\n    {\n        _isClimbing = false;\n        _isGrabbingLedge = false;\n        transform.position = _climbEndPosition;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = true;\n        }\n        \n        _currentLedge = null;\n        _onClimbComplete?.Invoke();\n    }\n    \n    private void ReleaseLedge()\n    {\n        _isGrabbingLedge = false;\n        _isClimbing = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = true;\n        }\n        \n        _currentLedge = null;\n        _onLedgeReleased?.Invoke();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 rayOrigin = transform.position + Vector3.up * _grabHeight;\n        Gizmos.DrawRay(rayOrigin, transform.forward * _grabDistance);\n        \n        if (_isGrabbingLedge)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_grabPosition, 0.2f);\n            \n            if (_isClimbing)\n            {\n                Gizmos.color = Color.blue;\n                Gizmos.DrawWireSphere(_climbEndPosition, 0.2f);\n                Gizmos.DrawLine(_climbStartPosition, _climbEndPosition);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AuroraBorealisEffect\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"Light\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"intensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"waveSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"colorShiftSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"flickerIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"ambientVolume\",\n      \"type\": \"float\",\n      \"default\": 0.4\n    },\n    {\n      \"name\": \"maxBrightness\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"minBrightness\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_wave_motion\",\n      \"trigger\": \"every frame while effect is active\",\n      \"actions\": [\n        {\n          \"action\": \"create flowing wave patterns across the sky\"\n        },\n        {\n          \"action\": \"animate particle positions in smooth undulating motion\"\n        },\n        {\n          \"action\": \"vary the height and width of aurora bands dynamically\"\n        }\n      ]\n    },\n    {\n      \"name\": \"color_cycling\",\n      \"trigger\": \"continuously over time\",\n      \"actions\": [\n        {\n          \"action\": \"cycle through green blue and purple color spectrum\"\n        },\n        {\n          \"action\": \"blend colors smoothly between different hues\"\n        },\n        {\n          \"action\": \"adjust particle color gradients from bottom to top\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brightness_flickering\",\n      \"trigger\": \"at random intervals\",\n      \"actions\": [\n        {\n          \"action\": \"create subtle brightness variations\"\n        },\n        {\n          \"action\": \"simulate natural aurora intensity fluctuations\"\n        },\n        {\n          \"action\": \"adjust light component brightness accordingly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ambient_lighting\",\n      \"trigger\": \"when aurora brightness changes\",\n      \"actions\": [\n        {\n          \"action\": \"cast colored light onto surrounding environment\"\n        },\n        {\n          \"action\": \"create soft atmospheric glow effect\"\n        },\n        {\n          \"action\": \"reflect aurora colors on nearby surfaces\"\n        }\n      ]\n    },\n    {\n      \"name\": \"atmospheric_sound\",\n      \"trigger\": \"while effect is visible\",\n      \"actions\": [\n        {\n          \"action\": \"play subtle crackling and humming sounds\"\n        },\n        {\n          \"action\": \"adjust audio volume based on aurora intensity\"\n        },\n        {\n          \"action\": \"create immersive ambient atmosphere\"\n        }\n      ]\n    },\n    {\n      \"name\": \"intensity_control\",\n      \"trigger\": \"when intensity value changes\",\n      \"actions\": [\n        {\n          \"action\": \"scale overall effect visibility\"\n        },\n        {\n          \"action\": \"adjust particle emission rates\"\n        },\n        {\n          \"action\": \"modify light brightness and color saturation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"nighttime_activation\",\n      \"trigger\": \"when scene lighting becomes dark\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade in aurora effect\"\n        },\n        {\n          \"action\": \"increase particle system activity\"\n        },\n        {\n          \"action\": \"enhance color vibrancy for night visibility\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class AuroraBorealis : MonoBehaviour\n{\n    [Header(\"Aurora Configuration\")]\n    [SerializeField] private Material auroraMaterial;\n    [SerializeField] private int auroraLayers = 3;\n    [SerializeField] private float auroraHeight = 50f;\n    [SerializeField] private float auroraWidth = 100f;\n    [SerializeField] private float auroraDepth = 20f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float waveSpeed = 0.5f;\n    [SerializeField] private float waveAmplitude = 2f;\n    [SerializeField] private float colorShiftSpeed = 0.3f;\n    [SerializeField] private float opacityPulseSpeed = 1f;\n    [SerializeField] private float verticalDrift = 0.2f;\n    \n    [Header(\"Visual Properties\")]\n    [SerializeField] private Gradient auroraColors;\n    [SerializeField] private AnimationCurve intensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float baseIntensity = 0.7f;\n    [SerializeField] private float maxIntensity = 1.2f;\n    [SerializeField] private bool useNoise = true;\n    [SerializeField] private float noiseScale = 0.1f;\n    \n    private List<AuroraLayer> _auroraLayers;\n    private float _timeOffset;\n    \n    [System.Serializable]\n    private class AuroraLayer\n    {\n        public GameObject gameObject;\n        public MeshRenderer renderer;\n        public Material material;\n        public float speedMultiplier;\n        public float heightOffset;\n        public float colorOffset;\n        public Vector3[] originalVertices;\n        public Mesh mesh;\n    }\n    \n    private void Start()\n    {\n        _timeOffset = Random.Range(0f, 100f);\n        InitializeAuroraColors();\n        CreateAuroraLayers();\n    }\n    \n    private void InitializeAuroraColors()\n    {\n        if (auroraColors.colorKeys.Length == 0)\n        {\n            GradientColorKey[] colorKeys = new GradientColorKey[4];\n            colorKeys[0] = new GradientColorKey(new Color(0.2f, 1f, 0.3f), 0f);\n            colorKeys[1] = new GradientColorKey(new Color(0.3f, 0.8f, 1f), 0.33f);\n            colorKeys[2] = new GradientColorKey(new Color(1f, 0.4f, 0.8f), 0.66f);\n            colorKeys[3] = new GradientColorKey(new Color(0.8f, 1f, 0.2f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(0.3f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(0.8f, 1f);\n            \n            auroraColors.SetKeys(colorKeys, alphaKeys);\n        }\n    }\n    \n    private void CreateAuroraLayers()\n    {\n        _auroraLayers = new List<AuroraLayer>();\n        \n        for (int i = 0; i < auroraLayers; i++)\n        {\n            GameObject layerObj = new GameObject($\"AuroraLayer_{i}\");\n            layerObj.transform.SetParent(transform);\n            \n            AuroraLayer layer = new AuroraLayer();\n            layer.gameObject = layerObj;\n            layer.speedMultiplier = Random.Range(0.5f, 1.5f);\n            layer.heightOffset = i * (auroraHeight / auroraLayers) + Random.Range(-5f, 5f);\n            layer.colorOffset = (float)i / auroraLayers;\n            \n            CreateAuroraMesh(layer, i);\n            _auroraLayers.Add(layer);\n        }\n    }\n    \n    private void CreateAuroraMesh(AuroraLayer layer, int layerIndex)\n    {\n        MeshFilter meshFilter = layer.gameObject.AddComponent<MeshFilter>();\n        layer.renderer = layer.gameObject.AddComponent<MeshRenderer>();\n        \n        if (auroraMaterial != null)\n        {\n            layer.material = new Material(auroraMaterial);\n        }\n        else\n        {\n            layer.material = CreateDefaultAuroraMaterial();\n        }\n        \n        layer.renderer.material = layer.material;\n        layer.renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n        layer.renderer.receiveShadows = false;\n        \n        Mesh mesh = new Mesh();\n        mesh.name = $\"AuroraMesh_{layerIndex}\";\n        \n        int segments = 50;\n        Vector3[] vertices = new Vector3[(segments + 1) * 2];\n        Vector2[] uvs = new Vector2[vertices.Length];\n        int[] triangles = new int[segments * 6];\n        \n        for (int i = 0; i <= segments; i++)\n        {\n            float t = (float)i / segments;\n            float x = (t - 0.5f) * auroraWidth;\n            float z = Random.Range(-auroraDepth * 0.5f, auroraDepth * 0.5f);\n            \n            vertices[i * 2] = new Vector3(x, layer.heightOffset, z);\n            vertices[i * 2 + 1] = new Vector3(x, layer.heightOffset + auroraHeight * 0.3f, z);\n            \n            uvs[i * 2] = new Vector2(t, 0f);\n            uvs[i * 2 + 1] = new Vector2(t, 1f);\n        }\n        \n        for (int i = 0; i < segments; i++)\n        {\n            int baseIndex = i * 6;\n            int vertIndex = i * 2;\n            \n            triangles[baseIndex] = vertIndex;\n            triangles[baseIndex + 1] = vertIndex + 2;\n            triangles[baseIndex + 2] = vertIndex + 1;\n            \n            triangles[baseIndex + 3] = vertIndex + 1;\n            triangles[baseIndex + 4] = vertIndex + 2;\n            triangles[baseIndex + 5] = vertIndex + 3;\n        }\n        \n        mesh.vertices = vertices;\n        mesh.uv = uvs;\n        mesh.triangles = triangles;\n        mesh.RecalculateNormals();\n        \n        layer.originalVertices = (Vector3[])vertices.Clone();\n        layer.mesh = mesh;\n        meshFilter.mesh = mesh;\n    }\n    \n    private Material CreateDefaultAuroraMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.SetFloat(\"_Mode\", 3);\n        mat.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        mat.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        mat.SetInt(\"_ZWrite\", 0);\n        mat.DisableKeyword(\"_ALPHATEST_ON\");\n        mat.EnableKeyword(\"_ALPHABLEND_ON\");\n        mat.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        mat.renderQueue = 3000;\n        return mat;\n    }\n    \n    private void Update()\n    {\n        float time = Time.time + _timeOffset;\n        \n        for (int i = 0; i < _auroraLayers.Count; i++)\n        {\n            UpdateAuroraLayer(_auroraLayers[i], time, i);\n        }\n    }\n    \n    private void UpdateAuroraLayer(AuroraLayer layer, float time, int layerIndex)\n    {\n        if (layer.mesh == null || layer.originalVertices == null) return;\n        \n        Vector3[] vertices = new Vector3[layer.originalVertices.Length];\n        float layerTime = time * layer.speedMultiplier;\n        \n        for (int i = 0; i < layer.originalVertices.Length; i++)\n        {\n            Vector3 originalPos = layer.originalVertices[i];\n            Vector3 newPos = originalPos;\n            \n            float waveX = Mathf.Sin(layerTime * waveSpeed + originalPos.x * 0.1f) * waveAmplitude;\n            float waveY = Mathf.Sin(layerTime * waveSpeed * 0.7f + originalPos.x * 0.05f) * waveAmplitude * 0.5f;\n            \n            if (useNoise)\n            {\n                float noiseX = Mathf.PerlinNoise(originalPos.x * noiseScale, layerTime * 0.1f) - 0.5f;\n                float noiseY = Mathf.PerlinNoise(originalPos.x * noiseScale + 100f, layerTime * 0.1f) - 0.5f;\n                waveX += noiseX * waveAmplitude * 0.5f;\n                waveY += noiseY * waveAmplitude * 0.3f;\n            }\n            \n            newPos.x += waveX;\n            newPos.y += waveY + Mathf.Sin(layerTime * verticalDrift) * 2f;\n            \n            vertices[i] = newPos;\n        }\n        \n        layer.mesh.vertices = vertices;\n        layer.mesh.RecalculateNormals();\n        \n        UpdateLayerMaterial(layer, time, layerIndex);\n    }\n    \n    private void UpdateLayerMaterial(AuroraLayer layer, float time, int layerIndex)\n    {\n        if (layer.material == null) return;\n        \n        float colorTime = (time * colorShiftSpeed + layer.colorOffset) % 1f;\n        Color auroraColor = auroraColors.Evaluate(colorTime);\n        \n        float intensityTime = time * opacityPulseSpeed + layerIndex * 0.5f;\n        float intensity = baseIntensity + (maxIntensity - baseIntensity) * intensityCurve.Evaluate((Mathf.Sin(intensityTime) + 1f) * 0.5f);\n        \n        auroraColor.a *= intensity;\n        layer.material.color = auroraColor;\n        \n        if (layer.material.HasProperty(\"_MainTex\"))\n        {\n            Vector2 offset = layer.material.mainTextureOffset;\n            offset.x = time * 0.1f * layer.speedMultiplier;\n            layer.material.mainTextureOffset = offset;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_auroraLayers != null)\n        {\n            foreach (var layer in _auroraLayers)\n            {\n                if (layer.material != null)\n                {\n                    DestroyImmediate(layer.material);\n                }\n            }\n        }\n    }\n    \n    private void OnValidate()\n    {\n        auroraLayers = Mathf.Clamp(auroraLayers, 1, 10);\n        auroraHeight = Mathf.Max(0f, auroraHeight);\n        auroraWidth = Mathf.Max(0f, auroraWidth);\n        baseIntensity = Mathf.Clamp01(baseIntensity);\n        maxIntensity = Mathf.Max(baseIntensity, maxIntensity);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FighterJet\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"missileCount\",\n      \"type\": \"int\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"maxMissileCount\",\n      \"type\": \"int\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"lockOnRange\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fuel\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isEngineOn\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"hasTarget\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate_forward\",\n      \"trigger\": \"when thrust input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase forward velocity up to maximum speed\"\n        },\n        {\n          \"action\": \"play engine sound at higher pitch\"\n        },\n        {\n          \"action\": \"emit exhaust particles from engine\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_aircraft\",\n      \"trigger\": \"when steering input is detected\",\n      \"actions\": [\n        {\n          \"action\": \"rotate aircraft around vertical axis based on input direction\"\n        },\n        {\n          \"action\": \"bank aircraft left or right for realistic turning\"\n        },\n        {\n          \"action\": \"adjust engine sound based on turn intensity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lock_onto_target\",\n      \"trigger\": \"when enemy aircraft enters lock on range\",\n      \"actions\": [\n        {\n          \"action\": \"mark enemy as current target\"\n        },\n        {\n          \"action\": \"play target lock sound\"\n        },\n        {\n          \"action\": \"display targeting reticle on enemy\"\n        },\n        {\n          \"action\": \"set has target to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fire_missile\",\n      \"trigger\": \"when fire button is pressed and target is locked and missiles remain\",\n      \"actions\": [\n        {\n          \"action\": \"spawn missile at missile mount point\"\n        },\n        {\n          \"action\": \"set missile target to current locked target\"\n        },\n        {\n          \"action\": \"launch missile toward target\"\n        },\n        {\n          \"action\": \"reduce missile count by one\"\n        },\n        {\n          \"action\": \"play missile launch sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_target_lock\",\n      \"trigger\": \"when target moves beyond lock on range or is destroyed\",\n      \"actions\": [\n        {\n          \"action\": \"clear current target\"\n        },\n        {\n          \"action\": \"hide targeting reticle\"\n        },\n        {\n          \"action\": \"set has target to false\"\n        },\n        {\n          \"action\": \"play lock lost sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by enemy fire or collision occurs\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play damage sound effect\"\n        },\n        {\n          \"action\": \"emit smoke particles from damaged area\"\n        },\n        {\n          \"action\": \"shake aircraft briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"aircraft_destroyed\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"create large explosion particle effect\"\n        },\n        {\n          \"action\": \"disable aircraft controls\"\n        },\n        {\n          \"action\": \"begin falling toward ground\"\n        },\n        {\n          \"action\": \"spawn debris pieces\"\n        }\n      ]\n    },\n    {\n      \"name\": \"consume_fuel\",\n      \"trigger\": \"when engine is running\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease fuel over time\"\n        },\n        {\n          \"action\": \"reduce engine power when fuel is low\"\n        },\n        {\n          \"action\": \"play low fuel warning when fuel is critically low\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FighterJet : MonoBehaviour\n{\n    [Header(\"Flight Controls\")]\n    [SerializeField] private float _thrustForce = 1500f;\n    [SerializeField] private float _pitchTorque = 1000f;\n    [SerializeField] private float _yawTorque = 800f;\n    [SerializeField] private float _rollTorque = 600f;\n    [SerializeField] private float _maxSpeed = 200f;\n    [SerializeField] private float _liftForce = 800f;\n    \n    [Header(\"Missile System\")]\n    [SerializeField] private GameObject _missilePrefab;\n    [SerializeField] private Transform[] _missileSpawnPoints;\n    [SerializeField] private int _maxMissiles = 8;\n    [SerializeField] private float _missileFireRate = 0.5f;\n    [SerializeField] private float _missileSpeed = 300f;\n    [SerializeField] private float _missileLifetime = 10f;\n    [SerializeField] private float _targetingRange = 500f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _missileFireSound;\n    [SerializeField] private AudioClip _engineSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem[] _engineTrails;\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    \n    private Rigidbody _rigidbody;\n    private int _currentMissileCount;\n    private float _lastMissileFireTime;\n    private int _currentSpawnPointIndex;\n    private Transform _currentTarget;\n    private List<GameObject> _activeMissiles = new List<GameObject>();\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = 1000f;\n        _rigidbody.drag = 0.1f;\n        _rigidbody.angularDrag = 5f;\n        \n        _currentMissileCount = _maxMissiles;\n        \n        if (_engineAudioSource != null && _engineSound != null)\n        {\n            _engineAudioSource.clip = _engineSound;\n            _engineAudioSource.loop = true;\n            _engineAudioSource.Play();\n        }\n        \n        SetupEngineTrails();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateEngineAudio();\n        FindTarget();\n        CleanupMissiles();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyThrust();\n        ApplyLift();\n        ApplyRotation();\n        LimitSpeed();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0))\n        {\n            FireMissile();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            ReloadMissiles();\n        }\n    }\n    \n    private void ApplyThrust()\n    {\n        float thrust = Input.GetAxis(\"Vertical\");\n        Vector3 thrustVector = transform.forward * thrust * _thrustForce;\n        _rigidbody.AddForce(thrustVector);\n    }\n    \n    private void ApplyLift()\n    {\n        float speed = Vector3.Dot(_rigidbody.velocity, transform.forward);\n        float liftAmount = speed * speed * 0.001f * _liftForce;\n        Vector3 liftVector = transform.up * liftAmount;\n        _rigidbody.AddForce(liftVector);\n    }\n    \n    private void ApplyRotation()\n    {\n        float pitch = -Input.GetAxis(\"Vertical\") * _pitchTorque;\n        float yaw = Input.GetAxis(\"Horizontal\") * _yawTorque;\n        float roll = -Input.GetAxis(\"Horizontal\") * _rollTorque;\n        \n        _rigidbody.AddTorque(transform.right * pitch);\n        _rigidbody.AddTorque(transform.up * yaw);\n        _rigidbody.AddTorque(transform.forward * roll);\n    }\n    \n    private void LimitSpeed()\n    {\n        if (_rigidbody.velocity.magnitude > _maxSpeed)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n        }\n    }\n    \n    private void FireMissile()\n    {\n        if (_currentMissileCount <= 0 || Time.time - _lastMissileFireTime < _missileFireRate)\n            return;\n        \n        if (_missilePrefab == null || _missileSpawnPoints == null || _missileSpawnPoints.Length == 0)\n            return;\n        \n        Transform spawnPoint = _missileSpawnPoints[_currentSpawnPointIndex];\n        GameObject missile = Instantiate(_missilePrefab, spawnPoint.position, spawnPoint.rotation);\n        \n        Missile missileScript = missile.GetComponent<Missile>();\n        if (missileScript == null)\n        {\n            missileScript = missile.AddComponent<Missile>();\n        }\n        \n        missileScript.Initialize(_missileSpeed, _missileLifetime, _currentTarget);\n        _activeMissiles.Add(missile);\n        \n        _currentMissileCount--;\n        _lastMissileFireTime = Time.time;\n        _currentSpawnPointIndex = (_currentSpawnPointIndex + 1) % _missileSpawnPoints.Length;\n        \n        PlayMissileFireEffects();\n    }\n    \n    private void PlayMissileFireEffects()\n    {\n        if (_missileFireSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_missileFireSound, transform.position);\n        }\n        \n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _targetingRange, _targetLayerMask);\n        float closestDistance = float.MaxValue;\n        Transform closestTarget = null;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = target.transform;\n            }\n        }\n        \n        _currentTarget = closestTarget;\n    }\n    \n    private void ReloadMissiles()\n    {\n        _currentMissileCount = _maxMissiles;\n    }\n    \n    private void UpdateEngineAudio()\n    {\n        if (_engineAudioSource != null)\n        {\n            float throttle = Mathf.Abs(Input.GetAxis(\"Vertical\"));\n            _engineAudioSource.pitch = Mathf.Lerp(0.5f, 2f, throttle);\n            _engineAudioSource.volume = Mathf.Lerp(0.3f, 1f, throttle);\n        }\n    }\n    \n    private void SetupEngineTrails()\n    {\n        if (_engineTrails != null)\n        {\n            foreach (ParticleSystem trail in _engineTrails)\n            {\n                if (trail != null)\n                {\n                    var emission = trail.emission;\n                    emission.enabled = true;\n                }\n            }\n        }\n    }\n    \n    private void CleanupMissiles()\n    {\n        _activeMissiles.RemoveAll(missile => missile == null);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _targetingRange);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}\n\npublic class Missile : MonoBehaviour\n{\n    private float _speed;\n    private float _lifetime;\n    private Transform _target;\n    private Rigidbody _rigidbody;\n    private float _spawnTime;\n    private bool _isInitialized;\n    \n    [SerializeField] private float _turnRate = 180f;\n    [SerializeField] private float _explosionRadius = 10f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _spawnTime = Time.time;\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider == null)\n        {\n            collider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)collider).radius = 0.5f;\n        }\n        collider.isTrigger = true;\n    }\n    \n    public void Initialize(float speed, float lifetime, Transform target)\n    {\n        _speed = speed;\n        _lifetime = lifetime;\n        _target = target;\n        _isInitialized = true;\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        if (Time.time - _spawnTime > _lifetime)\n        {\n            Explode();\n            return;\n        }\n        \n        MoveTowardsTarget();\n    }\n    \n    private void MoveTowardsTarget()\n    {\n        Vector3 direction;\n        \n        if (_target != null)\n        {\n            direction = (_target.position - transform.position).normalized;\n            Vector3 targetDirection = Vector3.RotateTowards(transform.forward, direction, _turnRate * Mathf.Deg2Rad * Time.deltaTime, 0f);\n            transform.rotation = Quaternion.LookRotation(targetDirection);\n        }\n        \n        _rigidbody.velocity = transform.forward * _speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.transform.parent != null && other.transform.parent.GetComponent<FighterJet>() != null)\n            return;\n        \n        Explode();\n    }\n    \n    private void Explode()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n        }\n        \n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_explosionSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AlertGuard\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"alertRadius\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"isAlerted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"alertSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when this guard receives damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"set alerted state to true\"\n        },\n        {\n          \"action\": \"play alert sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"alert_nearby_guards\",\n      \"trigger\": \"when this guard becomes alerted\",\n      \"actions\": [\n        {\n          \"action\": \"find all other guards within alert radius\"\n        },\n        {\n          \"action\": \"notify each nearby guard to become alerted\"\n        },\n        {\n          \"action\": \"broadcast alert message to nearby guards\"\n        }\n      ]\n    },\n    {\n      \"name\": \"receive_alert\",\n      \"trigger\": \"when receiving alert notification from another guard\",\n      \"actions\": [\n        {\n          \"action\": \"set alerted state to true\"\n        },\n        {\n          \"action\": \"play alert sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"die\",\n      \"trigger\": \"when health reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"destroy this guard object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class GuardAlertSystem : MonoBehaviour\n{\n    [Header(\"Guard Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _alertRadius = 15f;\n    [SerializeField] private LayerMask _guardLayerMask = -1;\n    [SerializeField] private float _alertDuration = 10f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _alertIndicator;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _alertedColor = Color.red;\n    [SerializeField] private Renderer _guardRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _alertSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGuardAttacked;\n    public UnityEvent OnGuardAlerted;\n    public UnityEvent OnGuardDeath;\n    \n    private bool _isAlerted = false;\n    private bool _isDead = false;\n    private float _maxHealth;\n    private float _alertTimer = 0f;\n    private List<GuardAlertSystem> _nearbyGuards = new List<GuardAlertSystem>();\n    \n    public bool IsAlerted => _isAlerted;\n    public bool IsDead => _isDead;\n    public float HealthPercentage => _health / _maxHealth;\n    \n    private void Start()\n    {\n        _maxHealth = _health;\n        \n        if (_guardRenderer == null)\n            _guardRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_alertIndicator != null)\n            _alertIndicator.SetActive(false);\n            \n        UpdateVisualState();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        if (_isAlerted)\n        {\n            _alertTimer -= Time.deltaTime;\n            if (_alertTimer <= 0f)\n            {\n                CalmDown();\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _health -= damage;\n        \n        PlaySound(_damageSound);\n        \n        if (_health <= 0f)\n        {\n            Die();\n        }\n        else\n        {\n            TriggerAlert();\n        }\n        \n        OnGuardAttacked?.Invoke();\n    }\n    \n    private void TriggerAlert()\n    {\n        if (_isAlerted) return;\n        \n        _isAlerted = true;\n        _alertTimer = _alertDuration;\n        \n        PlaySound(_alertSound);\n        UpdateVisualState();\n        \n        AlertNearbyGuards();\n        OnGuardAlerted?.Invoke();\n    }\n    \n    public void ReceiveAlert()\n    {\n        if (_isDead || _isAlerted) return;\n        \n        _isAlerted = true;\n        _alertTimer = _alertDuration;\n        \n        UpdateVisualState();\n        OnGuardAlerted?.Invoke();\n    }\n    \n    private void AlertNearbyGuards()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _alertRadius, _guardLayerMask);\n        \n        _nearbyGuards.Clear();\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            GuardAlertSystem otherGuard = col.GetComponent<GuardAlertSystem>();\n            if (otherGuard != null && !otherGuard.IsDead)\n            {\n                _nearbyGuards.Add(otherGuard);\n                otherGuard.ReceiveAlert();\n            }\n        }\n    }\n    \n    private void CalmDown()\n    {\n        _isAlerted = false;\n        _alertTimer = 0f;\n        UpdateVisualState();\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _health = 0f;\n        _isAlerted = false;\n        \n        UpdateVisualState();\n        OnGuardDeath?.Invoke();\n        \n        if (GetComponent<Collider>() != null)\n            GetComponent<Collider>().enabled = false;\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_guardRenderer != null)\n        {\n            if (_isDead)\n            {\n                _guardRenderer.material.color = Color.gray;\n            }\n            else if (_isAlerted)\n            {\n                _guardRenderer.material.color = _alertedColor;\n            }\n            else\n            {\n                _guardRenderer.material.color = _normalColor;\n            }\n        }\n        \n        if (_alertIndicator != null)\n        {\n            _alertIndicator.SetActive(_isAlerted && !_isDead);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isDead) return;\n        \n        if (other.CompareTag(\"Player\") && _isAlerted)\n        {\n            // Player detected while alerted - could trigger additional behavior\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _alertRadius);\n        \n        if (_isAlerted)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _alertRadius * 0.5f);\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        if (_isDead) return;\n        \n        _health = Mathf.Min(_health + amount, _maxHealth);\n    }\n    \n    public void SetAlertState(bool alerted)\n    {\n        if (_isDead) return;\n        \n        if (alerted && !_isAlerted)\n        {\n            TriggerAlert();\n        }\n        else if (!alerted && _isAlerted)\n        {\n            CalmDown();\n        }\n    }\n    \n    public List<GuardAlertSystem> GetNearbyGuards()\n    {\n        return new List<GuardAlertSystem>(_nearbyGuards);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DemonSummoner\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 200\n    },\n    {\n      \"name\": \"summonRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxMinions\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"summonCooldown\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"minionPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"currentMinions\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"lastSummonTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isInCombat\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"enter combat state\"\n        },\n        {\n          \"action\": \"play demon roar sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"summon_minions\",\n      \"trigger\": \"when in combat and current minions less than maximum and summon cooldown has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"play summoning animation\"\n        },\n        {\n          \"action\": \"create dark energy particles at random positions within summon range\"\n        },\n        {\n          \"action\": \"spawn minion at each particle location\"\n        },\n        {\n          \"action\": \"increment current minion count\"\n        },\n        {\n          \"action\": \"reset summon cooldown timer\"\n        },\n        {\n          \"action\": \"play summoning sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_minion_death\",\n      \"trigger\": \"when a summoned minion is destroyed\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current minion count\"\n        }\n      ]\n    },\n    {\n      \"name\": \"move_toward_player\",\n      \"trigger\": \"when in combat and player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at demon move speed\"\n        },\n        {\n          \"action\": \"face toward player direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by player attack\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hit sound effect\"\n        },\n        {\n          \"action\": \"flash red briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"die\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"destroy all remaining summoned minions\"\n        },\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"create explosion particle effect\"\n        },\n        {\n          \"action\": \"play death sound effect\"\n        },\n        {\n          \"action\": \"destroy this demon after animation completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_combat\",\n      \"trigger\": \"when player leaves detection range and no minions remain\",\n      \"actions\": [\n        {\n          \"action\": \"exit combat state\"\n        },\n        {\n          \"action\": \"return to idle animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class DemonSummoner : MonoBehaviour\n{\n    [Header(\"Demon Stats\")]\n    [SerializeField] private float _maxHealth = 200f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Summoning\")]\n    [SerializeField] private GameObject _minionPrefab;\n    [SerializeField] private int _maxMinions = 5;\n    [SerializeField] private float _summonCooldown = 3f;\n    [SerializeField] private float _summonRange = 10f;\n    [SerializeField] private float _summonRadius = 2f;\n    [SerializeField] private ParticleSystem _summonEffect;\n    [SerializeField] private AudioClip _summonSound;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _summonTrigger = \"Summon\";\n    [SerializeField] private string _attackTrigger = \"Attack\";\n    [SerializeField] private string _deathTrigger = \"Death\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDemonDeath;\n    public UnityEvent OnMinionSummoned;\n    \n    private Transform _player;\n    private List<GameObject> _activeMinions = new List<GameObject>();\n    private float _lastSummonTime;\n    private float _lastAttackTime;\n    private bool _isDead = false;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private enum DemonState\n    {\n        Idle,\n        Chasing,\n        Summoning,\n        Attacking,\n        Dead\n    }\n    \n    private DemonState _currentState = DemonState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n        \n        FindPlayer();\n        StartCoroutine(UpdateBehavior());\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        CleanupDeadMinions();\n        \n        if (_player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            UpdateState(distanceToPlayer);\n        }\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead || _player == null) return;\n        \n        if (_currentState == DemonState.Chasing)\n        {\n            MoveTowardsPlayer();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void UpdateState(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case DemonState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                {\n                    _currentState = DemonState.Chasing;\n                }\n                break;\n                \n            case DemonState.Chasing:\n                if (distanceToPlayer > _detectionRange)\n                {\n                    _currentState = DemonState.Idle;\n                }\n                else if (distanceToPlayer <= _attackRange && Time.time >= _lastAttackTime + _attackCooldown)\n                {\n                    _currentState = DemonState.Attacking;\n                    StartCoroutine(AttackSequence());\n                }\n                else if (_activeMinions.Count < _maxMinions && Time.time >= _lastSummonTime + _summonCooldown)\n                {\n                    _currentState = DemonState.Summoning;\n                    StartCoroutine(SummonSequence());\n                }\n                break;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.fixedDeltaTime);\n        }\n    }\n    \n    private IEnumerator SummonSequence()\n    {\n        if (_animator != null)\n            _animator.SetTrigger(_summonTrigger);\n        \n        yield return new WaitForSeconds(0.5f);\n        \n        SummonMinion();\n        _lastSummonTime = Time.time;\n        _currentState = DemonState.Chasing;\n    }\n    \n    private void SummonMinion()\n    {\n        if (_minionPrefab == null) return;\n        \n        Vector3 summonPosition = GetRandomSummonPosition();\n        GameObject minion = Instantiate(_minionPrefab, summonPosition, Quaternion.identity);\n        _activeMinions.Add(minion);\n        \n        if (_summonEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_summonEffect, summonPosition, Quaternion.identity);\n            Destroy(effect.gameObject, 3f);\n        }\n        \n        if (_audioSource != null && _summonSound != null)\n        {\n            _audioSource.PlayOneShot(_summonSound);\n        }\n        \n        OnMinionSummoned?.Invoke();\n    }\n    \n    private Vector3 GetRandomSummonPosition()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _summonRadius;\n        Vector3 summonPosition = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(summonPosition + Vector3.up * 10f, Vector3.down, out hit, 20f))\n        {\n            summonPosition.y = hit.point.y;\n        }\n        \n        return summonPosition;\n    }\n    \n    private IEnumerator AttackSequence()\n    {\n        if (_animator != null)\n            _animator.SetTrigger(_attackTrigger);\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        PerformAttack();\n        _lastAttackTime = Time.time;\n        _currentState = DemonState.Chasing;\n    }\n    \n    private void PerformAttack()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, _attackRange, _playerLayer);\n            \n            foreach (Collider hitCollider in hitColliders)\n            {\n                if (hitCollider.CompareTag(\"Player\"))\n                {\n                    // Deal damage to player - you would implement your damage system here\n                    Debug.Log($\"Demon deals {_attackDamage} damage to player\");\n                }\n            }\n        }\n        \n        if (_audioSource != null && _attackSound != null)\n        {\n            _audioSource.PlayOneShot(_attackSound);\n        }\n    }\n    \n    private void CleanupDeadMinions()\n    {\n        _activeMinions.RemoveAll(minion => minion == null);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = DemonState.Dead;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_deathTrigger);\n        \n        if (_audioSource != null && _deathSound != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_collider != null)\n            _collider.enabled = false;\n        \n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n        \n        OnDemonDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private IEnumerator UpdateBehavior()\n    {\n        while (!_isDead)\n        {\n            if (_player == null)\n            {\n                FindPlayer();\n            }\n            \n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            if (_currentState == DemonState.Idle)\n            {\n                _currentState = DemonState.Chasing;\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _summonRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MagicStaff\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"projectilePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"firePoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"projectileSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"manaCost\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"lastFireTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"cast_magic_projectile\",\n      \"trigger\": \"when fire input is pressed and enough time has passed since last cast and player has sufficient mana\",\n      \"actions\": [\n        {\n          \"action\": \"create magic projectile at fire point position\"\n        },\n        {\n          \"action\": \"launch projectile forward at projectile speed\"\n        },\n        {\n          \"action\": \"reduce player mana by mana cost\"\n        },\n        {\n          \"action\": \"record current time as last fire time\"\n        },\n        {\n          \"action\": \"play casting sound effect\"\n        },\n        {\n          \"action\": \"show casting particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"staff_idle_glow\",\n      \"trigger\": \"when staff is equipped and not casting\",\n      \"actions\": [\n        {\n          \"action\": \"emit soft magical glow from staff tip\"\n        },\n        {\n          \"action\": \"play subtle magical humming sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"insufficient_mana_feedback\",\n      \"trigger\": \"when fire input is pressed but player has insufficient mana\",\n      \"actions\": [\n        {\n          \"action\": \"play error sound\"\n        },\n        {\n          \"action\": \"flash staff briefly in red color\"\n        },\n        {\n          \"action\": \"display low mana warning message\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MagicStaff : MonoBehaviour\n{\n    [Header(\"Staff Settings\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private int _maxAmmo = 30;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _emptySound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _fireAnimationTrigger = \"Fire\";\n    [SerializeField] private string _reloadAnimationTrigger = \"Reload\";\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnReloadStarted;\n    public UnityEvent OnReloadCompleted;\n    public UnityEvent OnProjectileFired;\n    \n    private float _lastFireTime;\n    private int _currentAmmo;\n    private bool _isReloading;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        _playerCamera = Camera.main;\n        \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isReloading)\n            return;\n            \n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            StartReload();\n        }\n    }\n    \n    private void TryFire()\n    {\n        if (Time.time - _lastFireTime < 1f / _fireRate)\n            return;\n            \n        if (_currentAmmo <= 0)\n        {\n            PlayEmptySound();\n            return;\n        }\n        \n        Fire();\n    }\n    \n    private void Fire()\n    {\n        _lastFireTime = Time.time;\n        _currentAmmo--;\n        \n        Vector3 fireDirection = GetFireDirection();\n        CreateProjectile(fireDirection);\n        \n        PlayFireEffects();\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnProjectileFired?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            StartReload();\n        }\n    }\n    \n    private Vector3 GetFireDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n            return ray.direction;\n        }\n        \n        return _firePoint.forward;\n    }\n    \n    private void CreateProjectile(Vector3 direction)\n    {\n        if (_projectilePrefab == null)\n            return;\n            \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, Quaternion.LookRotation(direction));\n        \n        Rigidbody rb = projectile.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.velocity = direction * _projectileSpeed;\n        }\n        \n        MagicProjectile projectileScript = projectile.GetComponent<MagicProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<MagicProjectile>();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n            \n        if (_audioSource != null && _fireSound != null)\n            _audioSource.PlayOneShot(_fireSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(_fireAnimationTrigger);\n    }\n    \n    private void PlayEmptySound()\n    {\n        if (_audioSource != null && _emptySound != null)\n            _audioSource.PlayOneShot(_emptySound);\n    }\n    \n    private void StartReload()\n    {\n        if (_isReloading || _currentAmmo >= _maxAmmo)\n            return;\n            \n        _isReloading = true;\n        OnReloadStarted?.Invoke();\n        \n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(_reloadAnimationTrigger);\n            \n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnReloadCompleted?.Invoke();\n    }\n    \n    public bool CanFire()\n    {\n        return !_isReloading && _currentAmmo > 0 && Time.time - _lastFireTime >= 1f / _fireRate;\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n}\n\npublic class MagicProjectile : MonoBehaviour\n{\n    [Header(\"Projectile Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _lifetime = 5f;\n    [SerializeField] private float _explosionRadius = 3f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffectPrefab;\n    [SerializeField] private GameObject _explosionEffectPrefab;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private TrailRenderer _trail;\n    \n    private bool _hasHit;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit)\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n            return;\n            \n        Hit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit)\n            return;\n            \n        if (collision.gameObject.CompareTag(\"Player\"))\n            return;\n            \n        Hit(collision.collider);\n    }\n    \n    private void Hit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        Vector3 hitPoint = transform.position;\n        \n        if (_explosionRadius > 0)\n        {\n            ExplodeAtPoint(hitPoint);\n        }\n        else\n        {\n            DealDamageToTarget(hitCollider.gameObject);\n        }\n        \n        CreateHitEffects(hitPoint);\n        DestroyProjectile();\n    }\n    \n    private void ExplodeAtPoint(Vector3 explosionPoint)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(explosionPoint, _explosionRadius, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.CompareTag(\"Player\"))\n                continue;\n                \n            DealDamageToTarget(hitCollider.gameObject);\n            \n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - explosionPoint).normalized;\n                float distance = Vector3.Distance(explosionPoint, hitCollider.transform.position);\n                float force = Mathf.Lerp(500f, 100f, distance / _explosionRadius);\n                rb.AddForce(direction * force);\n            }\n        }\n        \n        if (_explosionEffectPrefab != null)\n        {\n            Instantiate(_explosionEffectPrefab, explosionPoint, Quaternion.identity);\n        }\n        \n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n    }\n    \n    private void DealDamageToTarget(GameObject target)\n    {\n        if (target.CompareTag(\"Enemy\"))\n        {\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        if (target.GetComponent<Rigidbody>() != null)\n        {\n            Vector3 force = transform.forward * 300f;\n            target.GetComponent<Rigidbody>().AddForce(force);\n        }\n    }\n    \n    private void CreateHitEffects(Vector3 position)\n    {\n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, position, Quaternion.identity);\n        }\n        \n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void DestroyProjectile()\n    {\n        if (_trail != null)\n            _trail.enabled = false;\n            \n        GetComponent<Collider>().enabled = false;\n        \n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n            rb.velocity = Vector3.zero;\n            \n        Destroy(gameObject, 2f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_explosionRadius > 0)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Slingshot\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"launchForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxPullDistance\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"stonePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"launchPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isPulledBack\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentPullDistance\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"aimDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"pull_back_slingshot\",\n      \"trigger\": \"when player holds down fire button while aiming at slingshot\",\n      \"actions\": [\n        {\n          \"action\": \"set slingshot to pulled back state\"\n        },\n        {\n          \"action\": \"calculate pull distance based on mouse or controller input\"\n        },\n        {\n          \"action\": \"clamp pull distance to maximum allowed value\"\n        },\n        {\n          \"action\": \"update visual representation of slingshot tension\"\n        },\n        {\n          \"action\": \"play stretching sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"aim_slingshot\",\n      \"trigger\": \"while slingshot is pulled back and player moves input\",\n      \"actions\": [\n        {\n          \"action\": \"calculate aim direction from input\"\n        },\n        {\n          \"action\": \"update visual aim indicator or trajectory preview\"\n        },\n        {\n          \"action\": \"rotate slingshot to face aim direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"launch_stone\",\n      \"trigger\": \"when player releases fire button while slingshot is pulled back\",\n      \"actions\": [\n        {\n          \"action\": \"spawn stone projectile at launch point\"\n        },\n        {\n          \"action\": \"apply launch force to stone in aim direction\"\n        },\n        {\n          \"action\": \"scale launch force by current pull distance\"\n        },\n        {\n          \"action\": \"reset slingshot to normal position\"\n        },\n        {\n          \"action\": \"set pulled back state to false\"\n        },\n        {\n          \"action\": \"play launch sound effect\"\n        },\n        {\n          \"action\": \"add screen shake effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_slingshot\",\n      \"trigger\": \"when player cancels aiming or moves away from slingshot\",\n      \"actions\": [\n        {\n          \"action\": \"return slingshot to rest position\"\n        },\n        {\n          \"action\": \"set pulled back state to false\"\n        },\n        {\n          \"action\": \"reset pull distance to zero\"\n        },\n        {\n          \"action\": \"hide aim indicators\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Slingshot : MonoBehaviour\n{\n    [Header(\"Slingshot Settings\")]\n    [SerializeField] private Transform _leftAnchor;\n    [SerializeField] private Transform _rightAnchor;\n    [SerializeField] private Transform _projectileSpawnPoint;\n    [SerializeField] private LineRenderer _leftBand;\n    [SerializeField] private LineRenderer _rightBand;\n    [SerializeField] private float _maxPullDistance = 3f;\n    [SerializeField] private float _forceMultiplier = 10f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Projectile Settings\")]\n    [SerializeField] private GameObject _stonePrefab;\n    [SerializeField] private int _maxStones = 10;\n    [SerializeField] private float _stoneLifetime = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pullSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Vector3> OnStoneReleased;\n    public UnityEvent OnOutOfStones;\n    \n    private Camera _camera;\n    private bool _isPulling = false;\n    private Vector3 _pullPosition;\n    private GameObject _currentStone;\n    private int _remainingStones;\n    private Vector3 _initialSpawnPosition;\n    \n    private void Start()\n    {\n        _camera = Camera.main;\n        if (_camera == null)\n            _camera = FindObjectOfType<Camera>();\n            \n        _remainingStones = _maxStones;\n        _initialSpawnPosition = _projectileSpawnPoint.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupBands();\n        ResetSlingshot();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _remainingStones > 0)\n        {\n            StartPull();\n        }\n        else if (Input.GetMouseButton(0) && _isPulling)\n        {\n            UpdatePull();\n        }\n        else if (Input.GetMouseButtonUp(0) && _isPulling)\n        {\n            ReleaseSlingshot();\n        }\n    }\n    \n    private void StartPull()\n    {\n        Vector3 mouseWorldPos = GetMouseWorldPosition();\n        float distanceToSlingshot = Vector3.Distance(mouseWorldPos, _projectileSpawnPoint.position);\n        \n        if (distanceToSlingshot <= _maxPullDistance)\n        {\n            _isPulling = true;\n            _pullPosition = _initialSpawnPosition;\n            CreateStone();\n            \n            if (_audioSource && _pullSound)\n                _audioSource.PlayOneShot(_pullSound);\n        }\n    }\n    \n    private void UpdatePull()\n    {\n        Vector3 mouseWorldPos = GetMouseWorldPosition();\n        Vector3 pullDirection = mouseWorldPos - _initialSpawnPosition;\n        \n        float pullDistance = Mathf.Clamp(pullDirection.magnitude, 0f, _maxPullDistance);\n        _pullPosition = _initialSpawnPosition + pullDirection.normalized * pullDistance;\n        \n        if (_currentStone != null)\n        {\n            _currentStone.transform.position = _pullPosition;\n        }\n    }\n    \n    private void ReleaseSlingshot()\n    {\n        if (_currentStone != null)\n        {\n            Vector3 launchDirection = (_initialSpawnPosition - _pullPosition).normalized;\n            float pullDistance = Vector3.Distance(_pullPosition, _initialSpawnPosition);\n            float launchForce = pullDistance * _forceMultiplier;\n            \n            Rigidbody stoneRb = _currentStone.GetComponent<Rigidbody>();\n            if (stoneRb != null)\n            {\n                stoneRb.isKinematic = false;\n                stoneRb.AddForce(launchDirection * launchForce, ForceMode.Impulse);\n            }\n            \n            Destroy(_currentStone, _stoneLifetime);\n            _currentStone = null;\n            _remainingStones--;\n            \n            if (_audioSource && _releaseSound)\n                _audioSource.PlayOneShot(_releaseSound);\n                \n            OnStoneReleased?.Invoke(launchDirection * launchForce);\n            \n            if (_remainingStones <= 0)\n                OnOutOfStones?.Invoke();\n        }\n        \n        _isPulling = false;\n        ResetSlingshot();\n    }\n    \n    private void CreateStone()\n    {\n        if (_stonePrefab != null)\n        {\n            _currentStone = Instantiate(_stonePrefab, _pullPosition, Quaternion.identity);\n            \n            Rigidbody rb = _currentStone.GetComponent<Rigidbody>();\n            if (rb == null)\n                rb = _currentStone.AddComponent<Rigidbody>();\n                \n            rb.isKinematic = true;\n            rb.mass = 0.1f;\n            \n            Collider col = _currentStone.GetComponent<Collider>();\n            if (col == null)\n            {\n                SphereCollider sphereCol = _currentStone.AddComponent<SphereCollider>();\n                sphereCol.radius = 0.05f;\n            }\n            \n            StoneProjectile stoneScript = _currentStone.GetComponent<StoneProjectile>();\n            if (stoneScript == null)\n                _currentStone.AddComponent<StoneProjectile>();\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_leftBand != null && _rightBand != null)\n        {\n            Vector3 bandPosition = _isPulling ? _pullPosition : _initialSpawnPosition;\n            \n            _leftBand.SetPosition(0, _leftAnchor.position);\n            _leftBand.SetPosition(1, bandPosition);\n            \n            _rightBand.SetPosition(0, _rightAnchor.position);\n            _rightBand.SetPosition(1, bandPosition);\n        }\n    }\n    \n    private void SetupBands()\n    {\n        if (_leftBand != null)\n        {\n            _leftBand.positionCount = 2;\n            _leftBand.startWidth = 0.02f;\n            _leftBand.endWidth = 0.02f;\n        }\n        \n        if (_rightBand != null)\n        {\n            _rightBand.positionCount = 2;\n            _rightBand.startWidth = 0.02f;\n            _rightBand.endWidth = 0.02f;\n        }\n    }\n    \n    private void ResetSlingshot()\n    {\n        _pullPosition = _initialSpawnPosition;\n        UpdateVisuals();\n    }\n    \n    private Vector3 GetMouseWorldPosition()\n    {\n        if (_camera == null) return Vector3.zero;\n        \n        Vector3 mouseScreenPos = Input.mousePosition;\n        mouseScreenPos.z = Vector3.Distance(_camera.transform.position, transform.position);\n        return _camera.ScreenToWorldPoint(mouseScreenPos);\n    }\n    \n    public void AddStones(int amount)\n    {\n        _remainingStones += amount;\n        _remainingStones = Mathf.Clamp(_remainingStones, 0, _maxStones);\n    }\n    \n    public int GetRemainingStones()\n    {\n        return _remainingStones;\n    }\n    \n    public void ResetAmmo()\n    {\n        _remainingStones = _maxStones;\n    }\n}\n\npublic class StoneProjectile : MonoBehaviour\n{\n    [Header(\"Impact Settings\")]\n    [SerializeField] private float _impactForce = 5f;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private AudioClip _impactSound;\n    \n    private AudioSource _audioSource;\n    private bool _hasImpacted = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasImpacted) return;\n        \n        _hasImpacted = true;\n        \n        if (_impactEffect != null)\n        {\n            GameObject effect = Instantiate(_impactEffect, transform.position, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n        \n        if (_audioSource && _impactSound)\n            _audioSource.PlayOneShot(_impactSound);\n            \n        Rigidbody hitRb = collision.rigidbody;\n        if (hitRb != null)\n        {\n            Vector3 impactDirection = collision.contacts[0].normal * -1f;\n            hitRb.AddForceAtPosition(impactDirection * _impactForce, collision.contacts[0].point, ForceMode.Impulse);\n        }\n        \n        if (collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            collision.gameObject.SendMessage(\"TakeDamage\", 1, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Shield\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"durability\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"maxDurability\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"blockEffectiveness\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"block_damage\",\n      \"trigger\": \"when projectile or attack collides with shield and shield is active\",\n      \"actions\": [\n        {\n          \"action\": \"reduce incoming damage by block effectiveness percentage\"\n        },\n        {\n          \"action\": \"decrease shield durability by remaining damage amount\"\n        },\n        {\n          \"action\": \"play shield impact visual effect\"\n        },\n        {\n          \"action\": \"play shield impact sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_break\",\n      \"trigger\": \"when shield durability reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"set shield as inactive\"\n        },\n        {\n          \"action\": \"play shield breaking visual effect\"\n        },\n        {\n          \"action\": \"play shield breaking sound effect\"\n        },\n        {\n          \"action\": \"disable shield collider\"\n        }\n      ]\n    },\n    {\n      \"name\": \"repair_shield\",\n      \"trigger\": \"when repair ability is used on shield\",\n      \"actions\": [\n        {\n          \"action\": \"restore shield durability to maximum\"\n        },\n        {\n          \"action\": \"set shield as active\"\n        },\n        {\n          \"action\": \"enable shield collider\"\n        },\n        {\n          \"action\": \"play shield repair visual effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Shield : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _maxShieldHealth = 100f;\n    [SerializeField] private float _rechargeDelay = 3f;\n    [SerializeField] private float _rechargeRate = 20f;\n    [SerializeField] private bool _blockAllDamage = true;\n    [SerializeField] private float _damageReduction = 0.8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldVisual;\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private ParticleSystem _rechargeEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private AudioClip _rechargeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnShieldDamaged;\n    public UnityEvent OnShieldBroken;\n    public UnityEvent OnShieldRestored;\n    public UnityEvent<float, float> OnShieldHealthChanged;\n    \n    private float _currentShieldHealth;\n    private bool _isRecharging;\n    private float _lastDamageTime;\n    private Renderer _shieldRenderer;\n    private Color _originalColor;\n    private bool _isShieldActive;\n    \n    private void Start()\n    {\n        _currentShieldHealth = _maxShieldHealth;\n        _isShieldActive = true;\n        \n        if (_shieldVisual != null)\n        {\n            _shieldRenderer = _shieldVisual.GetComponent<Renderer>();\n            if (_shieldRenderer != null)\n            {\n                _originalColor = _shieldRenderer.material.color;\n            }\n        }\n        \n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    private void Update()\n    {\n        if (!_isShieldActive && !_isRecharging && Time.time - _lastDamageTime >= _rechargeDelay)\n        {\n            StartRecharge();\n        }\n        \n        if (_isRecharging)\n        {\n            RechargeShield();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Projectile\") || other.CompareTag(\"Enemy\"))\n        {\n            HandleIncomingDamage(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Projectile\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            HandleIncomingDamage(collision.collider);\n        }\n    }\n    \n    private void HandleIncomingDamage(Collider damageSource)\n    {\n        if (!_isShieldActive) return;\n        \n        float damage = GetDamageFromSource(damageSource);\n        \n        if (_blockAllDamage)\n        {\n            BlockDamage(damage, damageSource);\n        }\n        else\n        {\n            float reducedDamage = damage * (1f - _damageReduction);\n            float shieldDamage = damage * _damageReduction;\n            BlockDamage(shieldDamage, damageSource);\n            \n            // Pass reduced damage to player if they have a health component\n            var playerHealth = GetComponentInParent<MonoBehaviour>();\n            if (playerHealth != null)\n            {\n                playerHealth.SendMessage(\"TakeDamage\", reducedDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private float GetDamageFromSource(Collider source)\n    {\n        // Try to get damage from various common damage components\n        var damageComponent = source.GetComponent<MonoBehaviour>();\n        if (damageComponent != null)\n        {\n            // Try to get damage value through reflection or common field names\n            var damageField = damageComponent.GetType().GetField(\"damage\");\n            if (damageField != null && damageField.FieldType == typeof(float))\n            {\n                return (float)damageField.GetValue(damageComponent);\n            }\n            \n            var damageProperty = damageComponent.GetType().GetProperty(\"Damage\");\n            if (damageProperty != null && damageProperty.PropertyType == typeof(float))\n            {\n                return (float)damageProperty.GetValue(damageComponent);\n            }\n        }\n        \n        // Default damage if no damage component found\n        return 25f;\n    }\n    \n    private void BlockDamage(float damage, Collider source)\n    {\n        _currentShieldHealth -= damage;\n        _lastDamageTime = Time.time;\n        _isRecharging = false;\n        \n        PlayHitEffect();\n        PlaySound(_hitSound);\n        OnShieldDamaged?.Invoke(damage);\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n        \n        if (_currentShieldHealth <= 0)\n        {\n            BreakShield();\n        }\n        \n        // Destroy or disable the damage source\n        if (source.CompareTag(\"Projectile\"))\n        {\n            Destroy(source.gameObject);\n        }\n        \n        UpdateShieldVisual();\n    }\n    \n    private void BreakShield()\n    {\n        _isShieldActive = false;\n        _currentShieldHealth = 0;\n        \n        PlaySound(_breakSound);\n        OnShieldBroken?.Invoke();\n        UpdateShieldVisual();\n        \n        if (_hitEffect != null)\n        {\n            _hitEffect.Stop();\n        }\n    }\n    \n    private void StartRecharge()\n    {\n        _isRecharging = true;\n        PlaySound(_rechargeSound);\n        \n        if (_rechargeEffect != null)\n        {\n            _rechargeEffect.Play();\n        }\n    }\n    \n    private void RechargeShield()\n    {\n        _currentShieldHealth += _rechargeRate * Time.deltaTime;\n        \n        if (_currentShieldHealth >= _maxShieldHealth)\n        {\n            _currentShieldHealth = _maxShieldHealth;\n            _isRecharging = false;\n            _isShieldActive = true;\n            \n            OnShieldRestored?.Invoke();\n            \n            if (_rechargeEffect != null)\n            {\n                _rechargeEffect.Stop();\n            }\n        }\n        \n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n        UpdateShieldVisual();\n    }\n    \n    private void UpdateShieldVisual()\n    {\n        if (_shieldVisual != null)\n        {\n            _shieldVisual.SetActive(_isShieldActive);\n            \n            if (_shieldRenderer != null)\n            {\n                float healthPercent = _currentShieldHealth / _maxShieldHealth;\n                Color shieldColor = Color.Lerp(Color.red, _originalColor, healthPercent);\n                shieldColor.a = _originalColor.a * healthPercent;\n                _shieldRenderer.material.color = shieldColor;\n            }\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_hitEffect != null)\n        {\n            _hitEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetShieldHealth(float health)\n    {\n        _currentShieldHealth = Mathf.Clamp(health, 0, _maxShieldHealth);\n        _isShieldActive = _currentShieldHealth > 0;\n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    public void RepairShield(float amount)\n    {\n        float oldHealth = _currentShieldHealth;\n        _currentShieldHealth = Mathf.Clamp(_currentShieldHealth + amount, 0, _maxShieldHealth);\n        \n        if (oldHealth <= 0 && _currentShieldHealth > 0)\n        {\n            _isShieldActive = true;\n            OnShieldRestored?.Invoke();\n        }\n        \n        UpdateShieldVisual();\n        OnShieldHealthChanged?.Invoke(_currentShieldHealth, _maxShieldHealth);\n    }\n    \n    public float GetShieldHealthPercent()\n    {\n        return _currentShieldHealth / _maxShieldHealth;\n    }\n    \n    public bool IsShieldActive()\n    {\n        return _isShieldActive;\n    }\n    \n    public void ToggleShield(bool active)\n    {\n        _isShieldActive = active && _currentShieldHealth > 0;\n        UpdateShieldVisual();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AerialComboAttacker\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"comboCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxComboHits\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"comboTimeWindow\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"lastAttackTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"attackDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"comboMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"launchForce\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"isAirborne\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canPerformAerialCombo\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_aerial_combo\",\n      \"trigger\": \"when attack input is pressed and character is airborne and not already in combo\",\n      \"actions\": [\n        {\n          \"action\": \"start first aerial attack animation\"\n        },\n        {\n          \"action\": \"set combo count to one\"\n        },\n        {\n          \"action\": \"record current time as last attack time\"\n        },\n        {\n          \"action\": \"enable aerial combo state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continue_aerial_combo\",\n      \"trigger\": \"when attack input is pressed and already in aerial combo and within combo time window and combo count is less than maximum\",\n      \"actions\": [\n        {\n          \"action\": \"play next combo attack animation\"\n        },\n        {\n          \"action\": \"increase combo count by one\"\n        },\n        {\n          \"action\": \"update last attack time to current time\"\n        },\n        {\n          \"action\": \"apply increased damage based on combo multiplier\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_aerial_combo\",\n      \"trigger\": \"when combo count reaches maximum hits or combo time window expires\",\n      \"actions\": [\n        {\n          \"action\": \"play finishing aerial attack animation\"\n        },\n        {\n          \"action\": \"apply powerful downward strike\"\n        },\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"disable aerial combo state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"launch_enemy_upward\",\n      \"trigger\": \"when first aerial combo hit connects with enemy\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force to enemy\"\n        },\n        {\n          \"action\": \"temporarily suspend enemy gravity\"\n        },\n        {\n          \"action\": \"match character height with enemy for combo continuation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_combo_on_landing\",\n      \"trigger\": \"when character touches ground while in aerial combo\",\n      \"actions\": [\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"disable aerial combo state\"\n        },\n        {\n          \"action\": \"return to ground combat state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AerialComboSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class ComboAttack\n    {\n        public string name;\n        public KeyCode inputKey;\n        public float damage;\n        public float knockbackForce;\n        public Vector3 attackOffset;\n        public float attackRadius;\n        public AnimationClip animationClip;\n        public ParticleSystem effectPrefab;\n        public AudioClip soundEffect;\n        public float cooldown;\n        [HideInInspector] public float lastUsedTime;\n    }\n\n    [System.Serializable]\n    public class ComboSequence\n    {\n        public string sequenceName;\n        public List<int> attackIndices;\n        public float maxTimeBetweenAttacks;\n        public float bonusDamageMultiplier;\n        public ParticleSystem finisherEffect;\n        public AudioClip finisherSound;\n    }\n\n    [Header(\"Aerial Combat Settings\")]\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private float _airborneThreshold = 0.5f;\n    [SerializeField] private float _maxAirTime = 5f;\n    [SerializeField] private bool _requireAirborne = true;\n\n    [Header(\"Combo Attacks\")]\n    [SerializeField] private List<ComboAttack> _comboAttacks = new List<ComboAttack>();\n\n    [Header(\"Combo Sequences\")]\n    [SerializeField] private List<ComboSequence> _comboSequences = new List<ComboSequence>();\n    [SerializeField] private float _comboResetTime = 2f;\n\n    [Header(\"Physics\")]\n    [SerializeField] private float _airControlForce = 10f;\n    [SerializeField] private float _attackMomentum = 5f;\n    [SerializeField] private bool _pauseGravityDuringAttack = true;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private ParticleSystem _comboBuilderEffect;\n    [SerializeField] private TrailRenderer _weaponTrail;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _comboStartSound;\n    [SerializeField] private AudioClip _comboBreakSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnComboCountChanged;\n    public UnityEvent<string> OnComboSequenceCompleted;\n    public UnityEvent<float> OnAttackHit;\n    public UnityEvent OnAerialCombatStart;\n    public UnityEvent OnAerialCombatEnd;\n\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private Collider _collider;\n    private bool _isAirborne;\n    private float _airTime;\n    private bool _isAttacking;\n    private int _currentComboCount;\n    private List<int> _currentComboSequence = new List<int>();\n    private float _lastAttackTime;\n    private Vector3 _originalGravityScale;\n    private bool _gravityPaused;\n    private Dictionary<GameObject, float> _hitTargets = new Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_attackPoint == null)\n            _attackPoint = transform;\n\n        _originalGravityScale = Physics.gravity;\n        \n        ValidateComboAttacks();\n    }\n\n    private void Update()\n    {\n        CheckAirborneStatus();\n        HandleComboInput();\n        UpdateComboTimer();\n        UpdateAirTime();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isAirborne && !_isAttacking)\n        {\n            HandleAirMovement();\n        }\n    }\n\n    private void CheckAirborneStatus()\n    {\n        bool wasAirborne = _isAirborne;\n        _isAirborne = !IsGrounded();\n\n        if (_isAirborne && !wasAirborne)\n        {\n            OnAerialCombatStart?.Invoke();\n            _airTime = 0f;\n        }\n        else if (!_isAirborne && wasAirborne)\n        {\n            OnAerialCombatEnd?.Invoke();\n            ResetCombo();\n            RestoreGravity();\n        }\n    }\n\n    private bool IsGrounded()\n    {\n        if (_collider == null) return false;\n        \n        Vector3 center = _collider.bounds.center;\n        Vector3 size = _collider.bounds.size;\n        \n        return Physics.CheckBox(\n            center - Vector3.up * (size.y * 0.5f + _airborneThreshold),\n            new Vector3(size.x * 0.4f, 0.1f, size.z * 0.4f),\n            transform.rotation,\n            _targetLayers\n        );\n    }\n\n    private void HandleComboInput()\n    {\n        if (_requireAirborne && !_isAirborne) return;\n        if (_isAttacking) return;\n\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            if (Input.GetKeyDown(_comboAttacks[i].inputKey))\n            {\n                if (CanPerformAttack(i))\n                {\n                    StartCoroutine(PerformAttack(i));\n                    break;\n                }\n            }\n        }\n    }\n\n    private bool CanPerformAttack(int attackIndex)\n    {\n        if (attackIndex < 0 || attackIndex >= _comboAttacks.Count) return false;\n        \n        ComboAttack attack = _comboAttacks[attackIndex];\n        return Time.time >= attack.lastUsedTime + attack.cooldown;\n    }\n\n    private IEnumerator PerformAttack(int attackIndex)\n    {\n        _isAttacking = true;\n        ComboAttack attack = _comboAttacks[attackIndex];\n        attack.lastUsedTime = Time.time;\n\n        // Add to combo sequence\n        _currentComboSequence.Add(attackIndex);\n        _currentComboCount++;\n        _lastAttackTime = Time.time;\n        OnComboCountChanged?.Invoke(_currentComboCount);\n\n        // Pause gravity if enabled\n        if (_pauseGravityDuringAttack && _isAirborne)\n        {\n            PauseGravity();\n        }\n\n        // Play animation\n        if (_animator != null && attack.animationClip != null)\n        {\n            _animator.Play(attack.animationClip.name);\n        }\n\n        // Apply attack momentum\n        if (_rigidbody != null)\n        {\n            Vector3 attackDirection = transform.forward;\n            _rigidbody.AddForce(attackDirection * _attackMomentum, ForceMode.Impulse);\n        }\n\n        // Enable weapon trail\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = true;\n        }\n\n        // Play sound effect\n        if (_audioSource != null && attack.soundEffect != null)\n        {\n            _audioSource.PlayOneShot(attack.soundEffect);\n        }\n\n        // Wait for attack timing\n        float attackDuration = attack.animationClip != null ? attack.animationClip.length : 0.5f;\n        yield return new WaitForSeconds(attackDuration * 0.3f);\n\n        // Perform hit detection\n        PerformHitDetection(attack);\n\n        // Spawn effect\n        if (attack.effectPrefab != null)\n        {\n            Vector3 effectPosition = _attackPoint.position + attack.attackOffset;\n            ParticleSystem effect = Instantiate(attack.effectPrefab, effectPosition, _attackPoint.rotation);\n            Destroy(effect.gameObject, 3f);\n        }\n\n        yield return new WaitForSeconds(attackDuration * 0.7f);\n\n        // Disable weapon trail\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = false;\n        }\n\n        // Check for combo sequences\n        CheckComboSequences();\n\n        // Restore gravity\n        if (_pauseGravityDuringAttack)\n        {\n            RestoreGravity();\n        }\n\n        _isAttacking = false;\n    }\n\n    private void PerformHitDetection(ComboAttack attack)\n    {\n        Vector3 attackPosition = _attackPoint.position + _attackPoint.TransformDirection(attack.attackOffset);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attack.attackRadius, _targetLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject == gameObject) continue;\n\n            GameObject target = hitCollider.gameObject;\n            \n            // Prevent multiple hits on same target in short time\n            if (_hitTargets.ContainsKey(target) && Time.time - _hitTargets[target] < 0.5f)\n                continue;\n\n            _hitTargets[target] = Time.time;\n\n            // Apply damage and knockback\n            ApplyDamage(target, attack);\n            ApplyKnockback(target, attack);\n\n            OnAttackHit?.Invoke(attack.damage);\n        }\n\n        // Clean up old hit records\n        List<GameObject> keysToRemove = new List<GameObject>();\n        foreach (var kvp in _hitTargets)\n        {\n            if (kvp.Key == null || Time.time - kvp.Value > 2f)\n                keysToRemove.Add(kvp.Key);\n        }\n        foreach (var key in keysToRemove)\n        {\n            _hitTargets.Remove(key);\n        }\n    }\n\n    private void ApplyDamage(GameObject target, ComboAttack attack)\n    {\n        float finalDamage = attack.damage;\n\n        // Apply combo bonus\n        ComboSequence activeSequence = GetActiveComboSequence();\n        if (activeSequence != null)\n        {\n            finalDamage *= activeSequence.bonusDamageMultiplier;\n        }\n\n        // Try to find health component or send message\n        if (target.CompareTag(\"Player\") || target.CompareTag(\"Enemy\"))\n        {\n            target.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n\n    private void ApplyKnockback(GameObject target, ComboAttack attack)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.3f; // Add upward component\n            targetRb.AddForce(knockbackDirection * attack.knockbackForce, ForceMode.Impulse);\n        }\n    }\n\n    private void CheckComboSequences()\n    {\n        foreach (ComboSequence sequence in _comboSequences)\n        {\n            if (IsSequenceMatching(sequence))\n            {\n                CompleteComboSequence(sequence);\n                break;\n            }\n        }\n    }\n\n    private bool IsSequenceMatching(ComboSequence sequence)\n    {\n        if (_currentComboSequence.Count < sequence.attackIndices.Count) return false;\n\n        int startIndex = _currentComboSequence.Count - sequence.attackIndices.Count;\n        for (int i = 0; i < sequence.attackIndices.Count; i++)\n        {\n            if (_currentComboSequence[startIndex + i] != sequence.attackIndices[i])\n                return false;\n        }\n\n        return true;\n    }\n\n    private void CompleteComboSequence(ComboSequence sequence)\n    {\n        OnComboSequenceCompleted?.Invoke(sequence.sequenceName);\n\n        // Play finisher effects\n        if (sequence.finisherEffect != null)\n        {\n            ParticleSystem finisher = Instantiate(sequence.finisherEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(finisher.gameObject, 5f);\n        }\n\n        if (_audioSource != null && sequence.finisherSound != null)\n        {\n            _audioSource.PlayOneShot(sequence.finisherSound);\n        }\n\n        // Reset combo after sequence completion\n        StartCoroutine(DelayedComboReset(1f));\n    }\n\n    private ComboSequence GetActiveComboSequence()\n    {\n        foreach (ComboSequence sequence in _comboSequences)\n        {\n            if (IsSequenceMatching(sequence))\n                return sequence;\n        }\n        return null;\n    }\n\n    private void UpdateComboTimer()\n    {\n        if (_currentComboCount > 0 && Time.time - _lastAttackTime > _comboResetTime)\n        {\n            ResetCombo();\n        }\n    }\n\n    private void UpdateAirTime()\n    {\n        if (_isAirborne)\n        {\n            _airTime += Time.deltaTime;\n            if (_airTime > _maxAirTime)\n            {\n                // Force landing or reset\n                ResetCombo();\n            }\n        }\n    }\n\n    private void HandleAirMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Vector3 movement = new Vector3(horizontal, 0, vertical) * _airControlForce;\n        movement = transform.TransformDirection(movement);\n        \n        _rigidbody.AddForce(movement, ForceMode.Force);\n    }\n\n    private void PauseGravity()\n    {\n        if (!_gravityPaused && _rigidbody != null)\n        {\n            _rigidbody.useGravity = false;\n            _gravityPaused = true;\n        }\n    }\n\n    private void RestoreGravity()\n    {\n        if (_gravityPaused && _rigidbody != null)\n        {\n            _rigidbody.useGravity = true;\n            _gravityPaused = false;\n        }\n    }\n\n    private void ResetCombo()\n    {\n        if (_currentComboCount > 0)\n        {\n            if (_audioSource != null && _comboBreakSound != null)\n            {\n                _audioSource.PlayOneShot(_comboBreakSound);\n            }\n        }\n\n        _currentComboCount = 0;\n        _currentComboSequence.Clear();\n        OnComboCountChanged?.Invoke(0);\n\n        if (_comboBuilderEffect != null)\n        {\n            _comboBuilderEffect.Stop();\n        }\n    }\n\n    private IEnumerator DelayedComboReset(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        ResetCombo();\n    }\n\n    private void ValidateComboAttacks()\n    {\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            if (_comboAttacks[i].attackRadius <= 0)\n                _comboAttacks[i].attackRadius = 1f;\n            if (_comboAttacks[i].damage <= 0)\n                _comboAttacks[i].damage = 10f;\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_attackPoint == null) return;\n\n        Gizmos.color = Color.red;\n        foreach ("}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SingingCrystal\",\n  \"components\": [\n    \"AudioSource\",\n    \"ParticleSystem\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"noteSequence\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"crystalParts\",\n      \"type\": \"GameObject[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"pulseIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"noteDuration\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"isPlaying\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentNoteIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"burstParticles\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_musical_sequence\",\n      \"trigger\": \"when player touches the crystal and sequence is not already playing\",\n      \"actions\": [\n        {\n          \"action\": \"set playing state to true\"\n        },\n        {\n          \"action\": \"reset note index to zero\"\n        },\n        {\n          \"action\": \"begin playing the first musical note\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_current_note\",\n      \"trigger\": \"when it is time to play the current note in sequence\",\n      \"actions\": [\n        {\n          \"action\": \"play the audio clip for current note\"\n        },\n        {\n          \"action\": \"light up the crystal part corresponding to current note\"\n        },\n        {\n          \"action\": \"make entire crystal pulse with rhythm\"\n        },\n        {\n          \"action\": \"schedule next note to play after note duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"advance_to_next_note\",\n      \"trigger\": \"when current note duration has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"dim the previously lit crystal part\"\n        },\n        {\n          \"action\": \"increase note index by one\"\n        },\n        {\n          \"action\": \"check if more notes remain in sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_sequence\",\n      \"trigger\": \"when all five notes have been played\",\n      \"actions\": [\n        {\n          \"action\": \"create burst of light particles around crystal\"\n        },\n        {\n          \"action\": \"stop crystal pulsing\"\n        },\n        {\n          \"action\": \"dim all crystal parts\"\n        },\n        {\n          \"action\": \"set playing state to false\"\n        },\n        {\n          \"action\": \"reset note index for next activation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_crystal\",\n      \"trigger\": \"when crystal should pulse with rhythm during note playback\",\n      \"actions\": [\n        {\n          \"action\": \"increase crystal brightness smoothly\"\n        },\n        {\n          \"action\": \"scale crystal size slightly larger\"\n        },\n        {\n          \"action\": \"return to normal brightness and size smoothly\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class SingingCrystal : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _musicalNotes = new AudioClip[5];\n    [SerializeField] private float _noteDuration = 0.8f;\n    [SerializeField] private float _noteInterval = 0.1f;\n\n    [Header(\"Visual Components\")]\n    [SerializeField] private Renderer[] _crystalParts = new Renderer[5];\n    [SerializeField] private Renderer _mainCrystalRenderer;\n    [SerializeField] private ParticleSystem _burstParticles;\n\n    [Header(\"Lighting Effects\")]\n    [SerializeField] private Color[] _noteColors = new Color[5];\n    [SerializeField] private Color _pulseColor = Color.white;\n    [SerializeField] private float _pulseIntensity = 2f;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n\n    [Header(\"Interaction Settings\")]\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _requirePlayerTag = true;\n\n    private Material[] _originalMaterials;\n    private Color[] _originalColors;\n    private Material _mainMaterial;\n    private Color _originalMainColor;\n    private bool _isPlaying = false;\n    private bool _onCooldown = false;\n    private Coroutine _sequenceCoroutine;\n\n    private void Start()\n    {\n        InitializeComponents();\n        CacheOriginalMaterials();\n        SetupDefaultColors();\n    }\n\n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        if (_mainCrystalRenderer == null)\n            _mainCrystalRenderer = GetComponent<Renderer>();\n\n        if (_burstParticles == null)\n            _burstParticles = GetComponentInChildren<ParticleSystem>();\n    }\n\n    private void CacheOriginalMaterials()\n    {\n        _originalMaterials = new Material[_crystalParts.Length];\n        _originalColors = new Color[_crystalParts.Length];\n\n        for (int i = 0; i < _crystalParts.Length; i++)\n        {\n            if (_crystalParts[i] != null)\n            {\n                _originalMaterials[i] = _crystalParts[i].material;\n                _originalColors[i] = _originalMaterials[i].color;\n            }\n        }\n\n        if (_mainCrystalRenderer != null)\n        {\n            _mainMaterial = _mainCrystalRenderer.material;\n            _originalMainColor = _mainMaterial.color;\n        }\n    }\n\n    private void SetupDefaultColors()\n    {\n        if (_noteColors.Length != 5)\n        {\n            _noteColors = new Color[5]\n            {\n                Color.red,\n                Color.yellow,\n                Color.green,\n                Color.cyan,\n                Color.magenta\n            };\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPlaying || _onCooldown)\n            return;\n\n        if (_requirePlayerTag && !other.CompareTag(\"Player\"))\n            return;\n\n        StartMusicalSequence();\n    }\n\n    private void StartMusicalSequence()\n    {\n        if (_sequenceCoroutine != null)\n            StopCoroutine(_sequenceCoroutine);\n\n        _sequenceCoroutine = StartCoroutine(PlayMusicalSequence());\n    }\n\n    private IEnumerator PlayMusicalSequence()\n    {\n        _isPlaying = true;\n\n        for (int i = 0; i < 5; i++)\n        {\n            yield return StartCoroutine(PlayNote(i));\n            yield return new WaitForSeconds(_noteInterval);\n        }\n\n        yield return StartCoroutine(CreateLightBurst());\n        \n        _isPlaying = false;\n        yield return StartCoroutine(CooldownTimer());\n    }\n\n    private IEnumerator PlayNote(int noteIndex)\n    {\n        if (noteIndex >= _musicalNotes.Length || _musicalNotes[noteIndex] == null)\n            yield break;\n\n        _audioSource.PlayOneShot(_musicalNotes[noteIndex]);\n\n        StartCoroutine(LightUpCrystalPart(noteIndex));\n        StartCoroutine(PulseCrystal());\n\n        yield return new WaitForSeconds(_noteDuration);\n    }\n\n    private IEnumerator LightUpCrystalPart(int partIndex)\n    {\n        if (partIndex >= _crystalParts.Length || _crystalParts[partIndex] == null)\n            yield break;\n\n        Material partMaterial = _crystalParts[partIndex].material;\n        Color targetColor = _noteColors[partIndex];\n        Color originalColor = _originalColors[partIndex];\n\n        float elapsed = 0f;\n        float duration = _noteDuration * 0.8f;\n\n        while (elapsed < duration)\n        {\n            float t = elapsed / duration;\n            float intensity = _pulseCurve.Evaluate(t);\n            \n            partMaterial.color = Color.Lerp(originalColor, targetColor * _pulseIntensity, intensity);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        partMaterial.color = originalColor;\n    }\n\n    private IEnumerator PulseCrystal()\n    {\n        if (_mainMaterial == null)\n            yield break;\n\n        float elapsed = 0f;\n        float duration = _noteDuration;\n\n        while (elapsed < duration)\n        {\n            float t = elapsed / duration;\n            float intensity = _pulseCurve.Evaluate(t);\n            \n            _mainMaterial.color = Color.Lerp(_originalMainColor, _pulseColor * _pulseIntensity, intensity);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        _mainMaterial.color = _originalMainColor;\n    }\n\n    private IEnumerator CreateLightBurst()\n    {\n        if (_burstParticles != null)\n        {\n            _burstParticles.Play();\n        }\n\n        StartCoroutine(FinalCrystalFlash());\n        \n        yield return new WaitForSeconds(1f);\n    }\n\n    private IEnumerator FinalCrystalFlash()\n    {\n        float flashDuration = 0.5f;\n        float elapsed = 0f;\n\n        while (elapsed < flashDuration)\n        {\n            float t = elapsed / flashDuration;\n            float intensity = Mathf.Sin(t * Mathf.PI);\n            \n            if (_mainMaterial != null)\n            {\n                _mainMaterial.color = Color.Lerp(_originalMainColor, Color.white * _pulseIntensity, intensity);\n            }\n\n            for (int i = 0; i < _crystalParts.Length; i++)\n            {\n                if (_crystalParts[i] != null)\n                {\n                    _crystalParts[i].material.color = Color.Lerp(_originalColors[i], Color.white * _pulseIntensity, intensity);\n                }\n            }\n\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n\n        ResetCrystalColors();\n    }\n\n    private void ResetCrystalColors()\n    {\n        if (_mainMaterial != null)\n            _mainMaterial.color = _originalMainColor;\n\n        for (int i = 0; i < _crystalParts.Length; i++)\n        {\n            if (_crystalParts[i] != null)\n                _crystalParts[i].material.color = _originalColors[i];\n        }\n    }\n\n    private IEnumerator CooldownTimer()\n    {\n        _onCooldown = true;\n        yield return new WaitForSeconds(_cooldownTime);\n        _onCooldown = false;\n    }\n\n    private void OnDestroy()\n    {\n        if (_sequenceCoroutine != null)\n            StopCoroutine(_sequenceCoroutine);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GenerationalCounter\",\n  \"components\": [\n    \"AudioSource\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"updateCallCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"generation\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"soundClips\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"materials\",\n      \"type\": \"Material[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"basePitch\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"pitchIncrement\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"count_updates\",\n      \"trigger\": \"every frame during Update\",\n      \"actions\": [\n        {\n          \"action\": \"increment the update call counter by one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"thousand_call_milestone\",\n      \"trigger\": \"when update call count reaches exactly one thousand\",\n      \"actions\": [\n        {\n          \"action\": \"play a random sound from the sound clips array\"\n        },\n        {\n          \"action\": \"set audio source pitch to base pitch plus generation multiplied by pitch increment\"\n        },\n        {\n          \"action\": \"change mesh renderer material to a random material from the materials array\"\n        },\n        {\n          \"action\": \"create a clone of this game object at the same position\"\n        },\n        {\n          \"action\": \"set the clone's generation to current generation plus one\"\n        },\n        {\n          \"action\": \"reset update call count to zero\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SelfReplicatingCounter : MonoBehaviour\n{\n    [Header(\"Counter Settings\")]\n    [SerializeField] private int _updateCallsPerGeneration = 1000;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _baseSound;\n    [SerializeField] private float _pitchIncrement = 0.2f;\n    [SerializeField] private float _basePitch = 1.0f;\n    \n    [Header(\"Material Settings\")]\n    [SerializeField] private Material[] _generationMaterials;\n    [SerializeField] private Color[] _generationColors;\n    \n    [Header(\"Spawning Settings\")]\n    [SerializeField] private Vector3 _spawnOffset = Vector3.right * 2f;\n    [SerializeField] private int _maxGenerations = 10;\n    \n    private int _updateCallCount = 0;\n    private int _generation = 0;\n    private float _currentPitch;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _materialInstance;\n\n    private void Start()\n    {\n        InitializeComponents();\n        SetupGeneration();\n    }\n\n    private void Update()\n    {\n        _updateCallCount++;\n        \n        if (_updateCallCount >= _updateCallsPerGeneration)\n        {\n            ProcessGeneration();\n            _updateCallCount = 0;\n        }\n    }\n\n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null && _renderer.material != null)\n        {\n            _materialInstance = new Material(_renderer.material);\n            _renderer.material = _materialInstance;\n        }\n    }\n\n    private void SetupGeneration()\n    {\n        _currentPitch = _basePitch + (_generation * _pitchIncrement);\n        \n        if (_audioSource != null)\n        {\n            _audioSource.pitch = _currentPitch;\n            _audioSource.clip = _baseSound;\n        }\n        \n        UpdateVisuals();\n    }\n\n    private void ProcessGeneration()\n    {\n        PlayGenerationSound();\n        ChangeMaterial();\n        \n        if (_generation < _maxGenerations)\n        {\n            SpawnClone();\n        }\n    }\n\n    private void PlayGenerationSound()\n    {\n        if (_audioSource != null && _baseSound != null)\n        {\n            _audioSource.pitch = _currentPitch;\n            _audioSource.PlayOneShot(_baseSound);\n        }\n    }\n\n    private void ChangeMaterial()\n    {\n        if (_renderer == null) return;\n\n        if (_generationMaterials != null && _generationMaterials.Length > 0)\n        {\n            int materialIndex = _generation % _generationMaterials.Length;\n            if (_generationMaterials[materialIndex] != null)\n            {\n                if (_materialInstance != null)\n                {\n                    DestroyImmediate(_materialInstance);\n                }\n                _materialInstance = new Material(_generationMaterials[materialIndex]);\n                _renderer.material = _materialInstance;\n            }\n        }\n        else if (_generationColors != null && _generationColors.Length > 0)\n        {\n            int colorIndex = _generation % _generationColors.Length;\n            if (_materialInstance != null)\n            {\n                _materialInstance.color = _generationColors[colorIndex];\n            }\n        }\n        else\n        {\n            // Fallback: Generate random color based on generation\n            if (_materialInstance != null)\n            {\n                float hue = (_generation * 0.1f) % 1.0f;\n                _materialInstance.color = Color.HSVToRGB(hue, 0.8f, 1.0f);\n            }\n        }\n    }\n\n    private void SpawnClone()\n    {\n        Vector3 spawnPosition = transform.position + _spawnOffset;\n        GameObject clone = Instantiate(gameObject, spawnPosition, transform.rotation);\n        \n        SelfReplicatingCounter cloneScript = clone.GetComponent<SelfReplicatingCounter>();\n        if (cloneScript != null)\n        {\n            cloneScript._generation = _generation + 1;\n            cloneScript.SetupGeneration();\n        }\n    }\n\n    private void UpdateVisuals()\n    {\n        // Scale slightly based on generation for visual feedback\n        float scaleMultiplier = 1.0f + (_generation * 0.05f);\n        transform.localScale = Vector3.one * scaleMultiplier;\n        \n        // Update name for debugging\n        gameObject.name = $\"SelfReplicatingCounter_Gen{_generation}\";\n    }\n\n    private void OnDestroy()\n    {\n        if (_materialInstance != null)\n        {\n            DestroyImmediate(_materialInstance);\n        }\n    }\n\n    // Public method to manually set generation (useful for spawned clones)\n    public void SetGeneration(int generation)\n    {\n        _generation = Mathf.Clamp(generation, 0, _maxGenerations);\n        SetupGeneration();\n    }\n\n    // Public getter for current generation\n    public int GetGeneration()\n    {\n        return _generation;\n    }\n\n    // Public getter for update call count\n    public int GetUpdateCallCount()\n    {\n        return _updateCallCount;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Whip\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25.0\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"whipSpeed\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attack_with_whip\",\n      \"trigger\": \"when attack input is pressed and cooldown has finished\",\n      \"actions\": [\n        {\n          \"action\": \"cast ray from player position toward mouse cursor direction up to maximum range\"\n        },\n        {\n          \"action\": \"create visual whip line that extends rapidly to target point\"\n        },\n        {\n          \"action\": \"play whip crack sound effect\"\n        },\n        {\n          \"action\": \"deal damage to first enemy hit along whip path\"\n        },\n        {\n          \"action\": \"apply knockback force to hit enemy away from player\"\n        },\n        {\n          \"action\": \"start cooldown timer before next attack\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_whip_visual\",\n      \"trigger\": \"when whip attack is performed\",\n      \"actions\": [\n        {\n          \"action\": \"show line renderer extending from player to target point\"\n        },\n        {\n          \"action\": \"animate line thickness from thick to thin over short duration\"\n        },\n        {\n          \"action\": \"fade out whip visual after brief display time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_multiple_enemies\",\n      \"trigger\": \"when whip path intersects multiple enemies\",\n      \"actions\": [\n        {\n          \"action\": \"damage all enemies along the whip path\"\n        },\n        {\n          \"action\": \"apply knockback to each hit enemy\"\n        },\n        {\n          \"action\": \"create hit effect at each enemy position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Whip : MonoBehaviour\n{\n    [Header(\"Whip Settings\")]\n    [SerializeField] private float _whipRange = 8f;\n    [SerializeField] private float _whipDamage = 25f;\n    [SerializeField] private float _whipCooldown = 1.5f;\n    [SerializeField] private float _whipDuration = 0.3f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _whipRenderer;\n    [SerializeField] private Transform _whipOrigin;\n    [SerializeField] private AnimationCurve _whipCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _whipWidth = 0.1f;\n    [SerializeField] private Color _whipColor = Color.brown;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whipCrackSound;\n    [SerializeField] private AudioClip _whipHitSound;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _whipKey = KeyCode.Mouse0;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnWhipHit;\n    public UnityEvent OnWhipCrack;\n    \n    private Camera _playerCamera;\n    private bool _isWhipping;\n    private float _lastWhipTime;\n    private Vector3 _whipTargetPosition;\n    private float _whipAnimationTime;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_whipRenderer == null)\n            _whipRenderer = GetComponent<LineRenderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_whipOrigin == null)\n            _whipOrigin = transform;\n            \n        SetupWhipRenderer();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWhipAnimation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_whipKey) && CanWhip())\n        {\n            PerformWhip();\n        }\n    }\n    \n    private bool CanWhip()\n    {\n        return !_isWhipping && Time.time >= _lastWhipTime + _whipCooldown;\n    }\n    \n    private void PerformWhip()\n    {\n        _isWhipping = true;\n        _lastWhipTime = Time.time;\n        _whipAnimationTime = 0f;\n        \n        Vector3 whipDirection = GetWhipDirection();\n        _whipTargetPosition = _whipOrigin.position + whipDirection * _whipRange;\n        \n        CheckWhipHit(whipDirection);\n        PlayWhipSound();\n        OnWhipCrack?.Invoke();\n    }\n    \n    private Vector3 GetWhipDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            return ray.direction;\n        }\n        else\n        {\n            return transform.forward;\n        }\n    }\n    \n    private void CheckWhipHit(Vector3 direction)\n    {\n        RaycastHit[] hits = Physics.RaycastAll(_whipOrigin.position, direction, _whipRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject != gameObject)\n            {\n                ProcessHit(hit.collider.gameObject, hit.point);\n            }\n        }\n    }\n    \n    private void ProcessHit(GameObject hitObject, Vector3 hitPoint)\n    {\n        // Apply damage if target has health component\n        var healthComponent = hitObject.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_whipDamage);\n        }\n        \n        // Apply knockback if target has rigidbody\n        var rb = hitObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 knockbackDirection = (hitPoint - _whipOrigin.position).normalized;\n            rb.AddForce(knockbackDirection * 500f, ForceMode.Impulse);\n        }\n        \n        PlayHitSound();\n        OnWhipHit?.Invoke(hitObject);\n    }\n    \n    private void UpdateWhipAnimation()\n    {\n        if (!_isWhipping)\n        {\n            _whipRenderer.enabled = false;\n            return;\n        }\n        \n        _whipRenderer.enabled = true;\n        _whipAnimationTime += Time.deltaTime;\n        \n        float progress = _whipAnimationTime / _whipDuration;\n        \n        if (progress >= 1f)\n        {\n            _isWhipping = false;\n            _whipRenderer.enabled = false;\n            return;\n        }\n        \n        UpdateWhipVisual(progress);\n    }\n    \n    private void UpdateWhipVisual(float progress)\n    {\n        float curveValue = _whipCurve.Evaluate(progress);\n        Vector3 currentTarget = Vector3.Lerp(_whipOrigin.position, _whipTargetPosition, curveValue);\n        \n        int segments = 20;\n        _whipRenderer.positionCount = segments + 1;\n        \n        for (int i = 0; i <= segments; i++)\n        {\n            float t = (float)i / segments;\n            Vector3 point = Vector3.Lerp(_whipOrigin.position, currentTarget, t);\n            \n            // Add some curve to make it look more whip-like\n            float height = Mathf.Sin(t * Mathf.PI) * 0.5f * curveValue;\n            point += Vector3.up * height;\n            \n            _whipRenderer.SetPosition(i, point);\n        }\n    }\n    \n    private void SetupWhipRenderer()\n    {\n        if (_whipRenderer != null)\n        {\n            _whipRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n            _whipRenderer.color = _whipColor;\n            _whipRenderer.startWidth = _whipWidth;\n            _whipRenderer.endWidth = _whipWidth * 0.3f;\n            _whipRenderer.useWorldSpace = true;\n            _whipRenderer.enabled = false;\n        }\n    }\n    \n    private void PlayWhipSound()\n    {\n        if (_audioSource != null && _whipCrackSound != null)\n        {\n            _audioSource.PlayOneShot(_whipCrackSound);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _whipHitSound != null)\n        {\n            _audioSource.PlayOneShot(_whipHitSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_whipOrigin != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_whipOrigin.position, _whipRange);\n            \n            if (_isWhipping)\n            {\n                Gizmos.color = Color.red;\n                Gizmos.DrawLine(_whipOrigin.position, _whipTargetPosition);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + amount);\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BouncingGem\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"bounceForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"randomMoveInterval\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"random_movement\",\n      \"trigger\": \"every random move interval seconds\",\n      \"actions\": [\n        {\n          \"action\": \"choose random direction\"\n        },\n        {\n          \"action\": \"apply force in random direction at move speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bounce_on_collision\",\n      \"trigger\": \"when colliding with any surface\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward bounce force\"\n        },\n        {\n          \"action\": \"add slight random horizontal force for variation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_gentle_movement\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"apply small random forces to keep gem moving\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class BouncingGem : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _bounceForce = 10f;\n    [SerializeField] private float _directionChangeInterval = 2f;\n    \n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _minBounceAngle = 30f;\n    [SerializeField] private float _maxBounceAngle = 150f;\n    [SerializeField] private LayerMask _bounceLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobAmplitude = 0.5f;\n    [SerializeField] private float _bobFrequency = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentDirection;\n    private float _directionTimer;\n    private Vector3 _startPosition;\n    private float _bobTimer;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 0.5f;\n        _rigidbody.angularDrag = 0.5f;\n        \n        _startPosition = transform.position;\n        _directionTimer = _directionChangeInterval;\n        \n        ChooseRandomDirection();\n    }\n    \n    private void Update()\n    {\n        HandleDirectionChange();\n        HandleVisualEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyMovement();\n    }\n    \n    private void HandleDirectionChange()\n    {\n        _directionTimer -= Time.deltaTime;\n        \n        if (_directionTimer <= 0f)\n        {\n            ChooseRandomDirection();\n            _directionTimer = _directionChangeInterval + Random.Range(-0.5f, 0.5f);\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n        \n        _bobTimer += Time.deltaTime * _bobFrequency;\n        float bobOffset = Mathf.Sin(_bobTimer) * _bobAmplitude;\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _startPosition.y + bobOffset;\n        transform.position = newPosition;\n        \n        _startPosition.x = transform.position.x;\n        _startPosition.z = transform.position.z;\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 targetVelocity = _currentDirection * _moveSpeed;\n        targetVelocity.y = _rigidbody.velocity.y;\n        \n        _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 5f);\n    }\n    \n    private void ChooseRandomDirection()\n    {\n        float randomAngle = Random.Range(0f, 360f);\n        _currentDirection = new Vector3(\n            Mathf.Cos(randomAngle * Mathf.Deg2Rad),\n            0f,\n            Mathf.Sin(randomAngle * Mathf.Deg2Rad)\n        ).normalized;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsInLayerMask(collision.gameObject.layer, _bounceLayerMask))\n        {\n            HandleBounce(collision);\n        }\n    }\n    \n    private void HandleBounce(Collision collision)\n    {\n        Vector3 normal = collision.contacts[0].normal;\n        Vector3 reflectedDirection = Vector3.Reflect(_currentDirection, normal);\n        \n        float bounceAngle = Random.Range(_minBounceAngle, _maxBounceAngle);\n        Vector3 randomDirection = Random.insideUnitSphere;\n        randomDirection.y = 0f;\n        randomDirection.Normalize();\n        \n        _currentDirection = Vector3.Slerp(reflectedDirection, randomDirection, 0.3f).normalized;\n        \n        _rigidbody.AddForce(normal * _bounceForce, ForceMode.Impulse);\n        \n        _directionTimer = _directionChangeInterval;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HandlePlayerInteraction();\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        _rigidbody.AddForce(Vector3.up * _bounceForce * 0.5f, ForceMode.Impulse);\n        ChooseRandomDirection();\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Minecart\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"speed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"brakeForce\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"isOccupied\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentRail\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"railDetectionDistance\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"wheelRotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 360.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_rails\",\n      \"trigger\": \"when minecart is on rails and moving\",\n      \"actions\": [\n        {\n          \"action\": \"align minecart direction with rail direction\"\n        },\n        {\n          \"action\": \"move forward along the rail path\"\n        },\n        {\n          \"action\": \"maintain position centered on rails\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_rail_changes\",\n      \"trigger\": \"when approaching rail junction or curve\",\n      \"actions\": [\n        {\n          \"action\": \"scan for next rail segment ahead\"\n        },\n        {\n          \"action\": \"smoothly transition to new rail direction\"\n        },\n        {\n          \"action\": \"adjust speed based on curve sharpness\"\n        }\n      ]\n    },\n    {\n      \"name\": \"accelerate_downhill\",\n      \"trigger\": \"when rail slopes downward\",\n      \"actions\": [\n        {\n          \"action\": \"increase speed gradually due to gravity\"\n        },\n        {\n          \"action\": \"clamp speed to maximum allowed\"\n        },\n        {\n          \"action\": \"play acceleration sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake_uphill\",\n      \"trigger\": \"when rail slopes upward\",\n      \"actions\": [\n        {\n          \"action\": \"reduce speed due to gravity resistance\"\n        },\n        {\n          \"action\": \"apply additional braking force if needed\"\n        },\n        {\n          \"action\": \"prevent rolling backward\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_passenger_boarding\",\n      \"trigger\": \"when player interacts with stationary minecart\",\n      \"actions\": [\n        {\n          \"action\": \"set player as passenger\"\n        },\n        {\n          \"action\": \"attach player to minecart seat\"\n        },\n        {\n          \"action\": \"mark minecart as occupied\"\n        },\n        {\n          \"action\": \"enable player controls for minecart\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_passenger_exit\",\n      \"trigger\": \"when occupied and player presses exit key\",\n      \"actions\": [\n        {\n          \"action\": \"detach player from minecart\"\n        },\n        {\n          \"action\": \"place player safely beside rails\"\n        },\n        {\n          \"action\": \"mark minecart as unoccupied\"\n        },\n        {\n          \"action\": \"gradually slow minecart to stop\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_wheels\",\n      \"trigger\": \"when minecart is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate wheel objects based on movement speed\"\n        },\n        {\n          \"action\": \"sync wheel rotation with forward motion\"\n        },\n        {\n          \"action\": \"stop wheel animation when stationary\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_movement_sounds\",\n      \"trigger\": \"when minecart is in motion\",\n      \"actions\": [\n        {\n          \"action\": \"play rolling wheel sounds on rails\"\n        },\n        {\n          \"action\": \"adjust sound pitch based on speed\"\n        },\n        {\n          \"action\": \"play creaking sounds during turns\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_rail_end\",\n      \"trigger\": \"when reaching end of rail track\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce speed to zero\"\n        },\n        {\n          \"action\": \"prevent minecart from leaving rails\"\n        },\n        {\n          \"action\": \"play stopping sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MinecartController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 10f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 3f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _railDetectionDistance = 2f;\n    \n    [Header(\"Rail Following\")]\n    [SerializeField] private LayerMask _railLayerMask = 1;\n    [SerializeField] private float _railSnapDistance = 0.5f;\n    [SerializeField] private float _turnSpeed = 180f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _mass = 100f;\n    [SerializeField] private float _friction = 0.1f;\n    [SerializeField] private float _airResistance = 0.05f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rollingSound;\n    [SerializeField] private AudioClip _brakeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerEnter;\n    public UnityEvent OnPlayerExit;\n    public UnityEvent OnMaxSpeedReached;\n    \n    private Rigidbody _rigidbody;\n    private bool _hasPlayer = false;\n    private float _currentSpeed = 0f;\n    private Vector3 _currentDirection = Vector3.forward;\n    private RaycastHit _railHit;\n    private bool _isOnRails = true;\n    private float _inputAcceleration = 0f;\n    private bool _isBraking = false;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        DetectRails();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isOnRails)\n        {\n            MoveOnRails();\n        }\n        else\n        {\n            ApplyGravity();\n        }\n        \n        ApplyResistance();\n        UpdateRigidbody();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_hasPlayer) return;\n        \n        _inputAcceleration = 0f;\n        _isBraking = false;\n        \n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n        {\n            _inputAcceleration = 1f;\n        }\n        else if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n        {\n            _inputAcceleration = -1f;\n        }\n        \n        if (Input.GetKey(KeyCode.Space))\n        {\n            _isBraking = true;\n        }\n    }\n    \n    private void DetectRails()\n    {\n        Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;\n        Vector3 rayDirection = Vector3.down;\n        \n        _isOnRails = Physics.Raycast(rayOrigin, rayDirection, out _railHit, _railDetectionDistance, _railLayerMask);\n        \n        if (_isOnRails)\n        {\n            SnapToRail();\n            UpdateDirection();\n        }\n    }\n    \n    private void SnapToRail()\n    {\n        Vector3 targetPosition = _railHit.point + Vector3.up * 0.1f;\n        float snapDistance = Vector3.Distance(transform.position, targetPosition);\n        \n        if (snapDistance > _railSnapDistance)\n        {\n            transform.position = Vector3.Lerp(transform.position, targetPosition, Time.fixedDeltaTime * 10f);\n        }\n    }\n    \n    private void UpdateDirection()\n    {\n        Vector3 railForward = Vector3.Cross(_railHit.normal, transform.right).normalized;\n        if (Vector3.Dot(railForward, _currentDirection) < 0)\n        {\n            railForward = -railForward;\n        }\n        \n        _currentDirection = Vector3.Slerp(_currentDirection, railForward, Time.fixedDeltaTime * _turnSpeed);\n        transform.rotation = Quaternion.LookRotation(_currentDirection, _railHit.normal);\n    }\n    \n    private void MoveOnRails()\n    {\n        float targetSpeed = _currentSpeed;\n        \n        if (_isBraking)\n        {\n            targetSpeed = Mathf.Max(0f, _currentSpeed - _deceleration * Time.fixedDeltaTime);\n        }\n        else if (_inputAcceleration != 0f)\n        {\n            targetSpeed = _currentSpeed + _inputAcceleration * _acceleration * Time.fixedDeltaTime;\n        }\n        else\n        {\n            float slopeInfluence = Vector3.Dot(_currentDirection, Vector3.down) * _gravity * 0.1f;\n            targetSpeed = _currentSpeed + slopeInfluence * Time.fixedDeltaTime;\n        }\n        \n        _currentSpeed = Mathf.Clamp(targetSpeed, -_maxSpeed, _maxSpeed);\n        \n        if (Mathf.Abs(_currentSpeed) >= _maxSpeed * 0.95f && !_isBraking)\n        {\n            OnMaxSpeedReached?.Invoke();\n        }\n    }\n    \n    private void ApplyGravity()\n    {\n        _rigidbody.AddForce(Vector3.down * _gravity * _mass, ForceMode.Force);\n    }\n    \n    private void ApplyResistance()\n    {\n        float frictionForce = _friction * _mass * _gravity;\n        float airResistanceForce = _airResistance * _currentSpeed * _currentSpeed;\n        \n        float totalResistance = frictionForce + airResistanceForce;\n        \n        if (_currentSpeed > 0)\n        {\n            _currentSpeed = Mathf.Max(0f, _currentSpeed - totalResistance * Time.fixedDeltaTime);\n        }\n        else if (_currentSpeed < 0)\n        {\n            _currentSpeed = Mathf.Min(0f, _currentSpeed + totalResistance * Time.fixedDeltaTime);\n        }\n    }\n    \n    private void UpdateRigidbody()\n    {\n        if (_isOnRails)\n        {\n            Vector3 velocity = _currentDirection * _currentSpeed;\n            _rigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rollingSound != null && _audioSource != null)\n        {\n            if (Mathf.Abs(_currentSpeed) > 0.1f)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _rollingSound;\n                    _audioSource.Play();\n                }\n                \n                _audioSource.pitch = Mathf.Lerp(0.5f, 2f, Mathf.Abs(_currentSpeed) / _maxSpeed);\n                _audioSource.volume = Mathf.Lerp(0.1f, 1f, Mathf.Abs(_currentSpeed) / _maxSpeed);\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n        \n        if (_isBraking && _brakeSound != null && _audioSource != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _brakeSound)\n            {\n                _audioSource.PlayOneShot(_brakeSound);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _hasPlayer = true;\n            OnPlayerEnter?.Invoke();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _hasPlayer = false;\n            OnPlayerExit?.Invoke();\n        }\n    }\n    \n    public void SetSpeed(float speed)\n    {\n        _currentSpeed = Mathf.Clamp(speed, -_maxSpeed, _maxSpeed);\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsOnRails()\n    {\n        return _isOnRails;\n    }\n    \n    public void EmergencyStop()\n    {\n        _currentSpeed = 0f;\n        _rigidbody.velocity = Vector3.zero;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position + Vector3.up * 0.1f, Vector3.down * _railDetectionDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n        \n        if (_isOnRails)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawSphere(_railHit.point, 0.1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ServerBrowserList\",\n  \"components\": [\n    \"ScrollRect\",\n    \"VerticalLayoutGroup\",\n    \"ContentSizeFitter\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"serverEntryPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"contentParent\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"refreshButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"loadingIndicator\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"emptyListMessage\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"refreshInterval\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"maxServersDisplayed\",\n      \"type\": \"int\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_server_list\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"show loading indicator\"\n        },\n        {\n          \"action\": \"hide empty list message\"\n        },\n        {\n          \"action\": \"request server list from master server\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refresh_server_list\",\n      \"trigger\": \"when refresh button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"clear existing server entries\"\n        },\n        {\n          \"action\": \"show loading indicator\"\n        },\n        {\n          \"action\": \"request updated server list from master server\"\n        }\n      ]\n    },\n    {\n      \"name\": \"populate_server_list\",\n      \"trigger\": \"when server data is received\",\n      \"actions\": [\n        {\n          \"action\": \"hide loading indicator\"\n        },\n        {\n          \"action\": \"create server entry for each received server\"\n        },\n        {\n          \"action\": \"display server name, player count, ping, and game mode\"\n        },\n        {\n          \"action\": \"sort servers by player count or ping\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_empty_list\",\n      \"trigger\": \"when no servers are found\",\n      \"actions\": [\n        {\n          \"action\": \"hide loading indicator\"\n        },\n        {\n          \"action\": \"show empty list message\"\n        },\n        {\n          \"action\": \"display no servers available text\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_refresh_list\",\n      \"trigger\": \"when refresh interval time has passed\",\n      \"actions\": [\n        {\n          \"action\": \"automatically request updated server list\"\n        },\n        {\n          \"action\": \"update existing server entries with new data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"filter_full_servers\",\n      \"trigger\": \"when filter option is enabled\",\n      \"actions\": [\n        {\n          \"action\": \"hide server entries that are at maximum capacity\"\n        },\n        {\n          \"action\": \"update list display to show only available servers\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System;\n\npublic class ServerBrowserList : MonoBehaviour\n{\n    [System.Serializable]\n    public class ServerInfo\n    {\n        public string serverName;\n        public string ipAddress;\n        public int port;\n        public int currentPlayers;\n        public int maxPlayers;\n        public int ping;\n        public string gameMode;\n        public string mapName;\n        public bool isPasswordProtected;\n        \n        public ServerInfo(string name, string ip, int p, int current, int max, string mode, string map, bool password = false)\n        {\n            serverName = name;\n            ipAddress = ip;\n            port = p;\n            currentPlayers = current;\n            maxPlayers = max;\n            ping = 0;\n            gameMode = mode;\n            mapName = map;\n            isPasswordProtected = password;\n        }\n    }\n    \n    [System.Serializable]\n    public class ServerSelectedEvent : UnityEvent<ServerInfo> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _serverListParent;\n    [SerializeField] private GameObject _serverItemPrefab;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private Button _joinButton;\n    [SerializeField] private InputField _passwordInputField;\n    [SerializeField] private GameObject _passwordPanel;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private ScrollRect _scrollRect;\n    \n    [Header(\"Server Discovery\")]\n    [SerializeField] private int _broadcastPort = 7777;\n    [SerializeField] private int _discoveryTimeout = 3000;\n    [SerializeField] private string _discoveryMessage = \"SERVER_DISCOVERY\";\n    \n    [Header(\"Filters\")]\n    [SerializeField] private Toggle _showFullServersToggle;\n    [SerializeField] private Toggle _showPasswordProtectedToggle;\n    [SerializeField] private InputField _serverNameFilter;\n    [SerializeField] private Dropdown _gameModeFilter;\n    \n    [Header(\"Events\")]\n    public ServerSelectedEvent OnServerSelected;\n    public UnityEvent OnRefreshStarted;\n    public UnityEvent OnRefreshCompleted;\n    \n    private List<ServerInfo> _allServers = new List<ServerInfo>();\n    private List<ServerInfo> _filteredServers = new List<ServerInfo>();\n    private List<GameObject> _serverItemObjects = new List<GameObject>();\n    private ServerInfo _selectedServer;\n    private UdpClient _udpClient;\n    private Thread _discoveryThread;\n    private bool _isRefreshing = false;\n    private bool _shouldStopDiscovery = false;\n    \n    private void Start()\n    {\n        InitializeUI();\n        AddDummyServers();\n        RefreshServerList();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshServerList);\n            \n        if (_joinButton != null)\n        {\n            _joinButton.onClick.AddListener(JoinSelectedServer);\n            _joinButton.interactable = false;\n        }\n        \n        if (_showFullServersToggle != null)\n            _showFullServersToggle.onValueChanged.AddListener(OnFilterChanged);\n            \n        if (_showPasswordProtectedToggle != null)\n            _showPasswordProtectedToggle.onValueChanged.AddListener(OnFilterChanged);\n            \n        if (_serverNameFilter != null)\n            _serverNameFilter.onValueChanged.AddListener(OnServerNameFilterChanged);\n            \n        if (_gameModeFilter != null)\n            _gameModeFilter.onValueChanged.AddListener(OnGameModeFilterChanged);\n            \n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n            \n        UpdateStatusText(\"Ready\");\n    }\n    \n    private void AddDummyServers()\n    {\n        _allServers.Add(new ServerInfo(\"Official Server #1\", \"192.168.1.100\", 7777, 12, 16, \"Deathmatch\", \"Desert_Map\"));\n        _allServers.Add(new ServerInfo(\"Community Server\", \"192.168.1.101\", 7778, 8, 12, \"Team Deathmatch\", \"City_Map\", true));\n        _allServers.Add(new ServerInfo(\"Noob Friendly\", \"192.168.1.102\", 7779, 4, 8, \"Capture Flag\", \"Forest_Map\"));\n        _allServers.Add(new ServerInfo(\"Pro Players Only\", \"192.168.1.103\", 7780, 16, 16, \"Battle Royale\", \"Island_Map\", true));\n        _allServers.Add(new ServerInfo(\"Training Ground\", \"192.168.1.104\", 7781, 2, 10, \"Practice\", \"Training_Map\"));\n    }\n    \n    public void RefreshServerList()\n    {\n        if (_isRefreshing) return;\n        \n        _isRefreshing = true;\n        OnRefreshStarted?.Invoke();\n        UpdateStatusText(\"Searching for servers...\");\n        \n        if (_refreshButton != null)\n            _refreshButton.interactable = false;\n            \n        StartServerDiscovery();\n    }\n    \n    private void StartServerDiscovery()\n    {\n        _shouldStopDiscovery = false;\n        _discoveryThread = new Thread(DiscoverServers);\n        _discoveryThread.Start();\n        \n        Invoke(nameof(StopServerDiscovery), _discoveryTimeout / 1000f);\n    }\n    \n    private void DiscoverServers()\n    {\n        try\n        {\n            _udpClient = new UdpClient();\n            _udpClient.EnableBroadcast = true;\n            \n            IPEndPoint broadcastEndPoint = new IPEndPoint(IPAddress.Broadcast, _broadcastPort);\n            byte[] data = Encoding.UTF8.GetBytes(_discoveryMessage);\n            \n            _udpClient.Send(data, data.Length, broadcastEndPoint);\n            \n            IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n            _udpClient.Client.ReceiveTimeout = 1000;\n            \n            while (!_shouldStopDiscovery)\n            {\n                try\n                {\n                    byte[] receivedData = _udpClient.Receive(ref remoteEndPoint);\n                    string response = Encoding.UTF8.GetString(receivedData);\n                    \n                    ParseServerResponse(response, remoteEndPoint.Address.ToString());\n                }\n                catch (SocketException)\n                {\n                    // Timeout or other socket exception, continue listening\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError(\"Server discovery error: \" + ex.Message);\n        }\n        finally\n        {\n            _udpClient?.Close();\n        }\n    }\n    \n    private void ParseServerResponse(string response, string ipAddress)\n    {\n        try\n        {\n            string[] parts = response.Split('|');\n            if (parts.Length >= 6)\n            {\n                string serverName = parts[0];\n                int port = int.Parse(parts[1]);\n                int currentPlayers = int.Parse(parts[2]);\n                int maxPlayers = int.Parse(parts[3]);\n                string gameMode = parts[4];\n                string mapName = parts[5];\n                bool isPasswordProtected = parts.Length > 6 && bool.Parse(parts[6]);\n                \n                ServerInfo serverInfo = new ServerInfo(serverName, ipAddress, port, currentPlayers, maxPlayers, gameMode, mapName, isPasswordProtected);\n                \n                // Calculate ping (simplified)\n                serverInfo.ping = UnityEngine.Random.Range(20, 200);\n                \n                lock (_allServers)\n                {\n                    _allServers.Add(serverInfo);\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError(\"Error parsing server response: \" + ex.Message);\n        }\n    }\n    \n    private void StopServerDiscovery()\n    {\n        _shouldStopDiscovery = true;\n        \n        if (_discoveryThread != null && _discoveryThread.IsAlive)\n        {\n            _discoveryThread.Join(1000);\n        }\n        \n        _isRefreshing = false;\n        OnRefreshCompleted?.Invoke();\n        \n        if (_refreshButton != null)\n            _refreshButton.interactable = true;\n            \n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void ApplyFilters()\n    {\n        _filteredServers.Clear();\n        \n        foreach (ServerInfo server in _allServers)\n        {\n            bool passesFilter = true;\n            \n            // Show full servers filter\n            if (_showFullServersToggle != null && !_showFullServersToggle.isOn)\n            {\n                if (server.currentPlayers >= server.maxPlayers)\n                    passesFilter = false;\n            }\n            \n            // Show password protected filter\n            if (_showPasswordProtectedToggle != null && !_showPasswordProtectedToggle.isOn)\n            {\n                if (server.isPasswordProtected)\n                    passesFilter = false;\n            }\n            \n            // Server name filter\n            if (_serverNameFilter != null && !string.IsNullOrEmpty(_serverNameFilter.text))\n            {\n                if (!server.serverName.ToLower().Contains(_serverNameFilter.text.ToLower()))\n                    passesFilter = false;\n            }\n            \n            // Game mode filter\n            if (_gameModeFilter != null && _gameModeFilter.value > 0)\n            {\n                string selectedMode = _gameModeFilter.options[_gameModeFilter.value].text;\n                if (server.gameMode != selectedMode)\n                    passesFilter = false;\n            }\n            \n            if (passesFilter)\n                _filteredServers.Add(server);\n        }\n        \n        // Sort by ping\n        _filteredServers.Sort((a, b) => a.ping.CompareTo(b.ping));\n    }\n    \n    private void UpdateServerListUI()\n    {\n        ClearServerList();\n        \n        foreach (ServerInfo server in _filteredServers)\n        {\n            CreateServerItem(server);\n        }\n        \n        if (_scrollRect != null)\n            _scrollRect.verticalNormalizedPosition = 1f;\n    }\n    \n    private void ClearServerList()\n    {\n        foreach (GameObject item in _serverItemObjects)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _serverItemObjects.Clear();\n    }\n    \n    private void CreateServerItem(ServerInfo server)\n    {\n        if (_serverItemPrefab == null || _serverListParent == null) return;\n        \n        GameObject serverItem = Instantiate(_serverItemPrefab, _serverListParent);\n        _serverItemObjects.Add(serverItem);\n        \n        ServerListItem itemComponent = serverItem.GetComponent<ServerListItem>();\n        if (itemComponent == null)\n            itemComponent = serverItem.AddComponent<ServerListItem>();\n            \n        itemComponent.Initialize(server, OnServerItemClicked);\n    }\n    \n    private void OnServerItemClicked(ServerInfo server)\n    {\n        _selectedServer = server;\n        \n        // Update selection visual\n        foreach (GameObject item in _serverItemObjects)\n        {\n            ServerListItem itemComponent = item.GetComponent<ServerListItem>();\n            if (itemComponent != null)\n            {\n                itemComponent.SetSelected(itemComponent.ServerInfo == server);\n            }\n        }\n        \n        if (_joinButton != null)\n            _joinButton.interactable = true;\n            \n        OnServerSelected?.Invoke(server);\n    }\n    \n    private void JoinSelectedServer()\n    {\n        if (_selectedServer == null) return;\n        \n        if (_selectedServer.isPasswordProtected)\n        {\n            ShowPasswordPanel();\n        }\n        else\n        {\n            ConnectToServer(_selectedServer, \"\");\n        }\n    }\n    \n    private void ShowPasswordPanel()\n    {\n        if (_passwordPanel != null)\n        {\n            _passwordPanel.SetActive(true);\n            \n            Button confirmButton = _passwordPanel.GetComponentInChildren<Button>();\n            if (confirmButton != null)\n            {\n                confirmButton.onClick.RemoveAllListeners();\n                confirmButton.onClick.AddListener(() => {\n                    string password = _passwordInputField != null ? _passwordInputField.text : \"\";\n                    ConnectToServer(_selectedServer, password);\n                    _passwordPanel.SetActive(false);\n                });\n            }\n        }\n    }\n    \n    private void ConnectToServer(ServerInfo server, string password)\n    {\n        UpdateStatusText($\"Connecting to {server.serverName}...\");\n        Debug.Log($\"Connecting to server: {server.serverName} at {server.ipAddress}:{server.port}\");\n        \n        // Here you would implement actual connection logic\n        // For now, just simulate connection\n        Invoke(nameof(SimulateConnectionResult), 2f);\n    }\n    \n    private void SimulateConnectionResult()\n    {\n        bool success = UnityEngine.Random.Range(0f, 1f) > 0.2f; // 80% success rate\n        \n        if (success)\n        {\n            UpdateStatusText(\"Connected successfully!\");\n            Debug.Log(\"Successfully connected to server\");\n        }\n        else\n        {\n            UpdateStatusText(\"Connection failed\");\n            Debug.LogError(\"Failed to connect to server\");\n        }\n    }\n    \n    private void OnFilterChanged(bool value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void OnServerNameFilterChanged(string value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void OnGameModeFilterChanged(int value)\n    {\n        ApplyFilters();\n        UpdateServerListUI();\n        UpdateStatusText($\"Found {_filteredServers.Count} servers\");\n    }\n    \n    private void UpdateStatusText(string message)\n    {\n        if (_statusText != null)\n            _statusText.text = message;\n    }\n    \n    private void OnDestroy()\n    {\n        _shouldStopDiscovery = true;\n        \n        if (_discoveryThread != null && _discoveryThread.IsAlive)\n        {\n            _discoveryThread.Join(1000);\n        }\n        \n        _udpClient?.Close();\n    }\n}\n\npublic class ServerListItem : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Text _serverNameText;\n    [SerializeField] private Text _playersText;\n    [SerializeField] private Text _pingText;\n    [SerializeField] private Text _gameModeText;\n    [SerializeField] private Text _mapNameText;\n    [SerializeField] private GameObject _passwordIcon;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Button _itemButton;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _selectedColor = Color.cyan;\n    [SerializeField] private Color _fullServerColor = Color.red;\n    \n    public ServerBrowserList.ServerInfo ServerInfo { get; private set; }\n    private System.Action<ServerBrowserList.ServerInfo> _onClick"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Spear\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"thrustForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"thrustRange\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isThrusting\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canThrust\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"thrust_attack\",\n      \"trigger\": \"when player presses attack button and can thrust\",\n      \"actions\": [\n        {\n          \"action\": \"set is thrusting to true\"\n        },\n        {\n          \"action\": \"set can thrust to false\"\n        },\n        {\n          \"action\": \"thrust spear forward with thrust force\"\n        },\n        {\n          \"action\": \"play thrust sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deal_damage_on_hit\",\n      \"trigger\": \"when spear collides with enemy during thrust\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to enemy\"\n        },\n        {\n          \"action\": \"apply knockback force to enemy\"\n        },\n        {\n          \"action\": \"play hit impact sound\"\n        },\n        {\n          \"action\": \"stop thrust movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_thrust\",\n      \"trigger\": \"when thrust reaches maximum range or hits obstacle\",\n      \"actions\": [\n        {\n          \"action\": \"set is thrusting to false\"\n        },\n        {\n          \"action\": \"return spear to original position\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_cooldown\",\n      \"trigger\": \"when cooldown time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set can thrust to true\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Spear : MonoBehaviour\n{\n    [Header(\"Spear Settings\")]\n    [SerializeField] private float _thrustDistance = 2f;\n    [SerializeField] private float _thrustSpeed = 10f;\n    [SerializeField] private float _thrustDuration = 0.3f;\n    [SerializeField] private float _retractSpeed = 8f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private int _damage = 25;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.Mouse0;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _thrustSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _thrustEffect;\n    [SerializeField] private GameObject _hitEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnThrustStart;\n    public UnityEvent OnThrustHit;\n    public UnityEvent OnThrustComplete;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _thrustTargetPosition;\n    private bool _isThrusting = false;\n    private bool _isRetracting = false;\n    private bool _canThrust = true;\n    private float _thrustTimer = 0f;\n    private float _cooldownTimer = 0f;\n    \n    private AudioSource _audioSource;\n    private Collider _spearCollider;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _originalPosition = transform.localPosition;\n        _audioSource = GetComponent<AudioSource>();\n        _spearCollider = GetComponent<Collider>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_spearCollider == null)\n        {\n            _spearCollider = gameObject.AddComponent<CapsuleCollider>();\n            _spearCollider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateThrustMovement();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_thrustKey) && _canThrust && !_isThrusting && !_isRetracting)\n        {\n            StartThrust();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canThrust)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canThrust = true;\n            }\n        }\n    }\n    \n    private void UpdateThrustMovement()\n    {\n        if (_isThrusting)\n        {\n            _thrustTimer += Time.deltaTime;\n            \n            float progress = _thrustTimer / _thrustDuration;\n            transform.localPosition = Vector3.Lerp(_originalPosition, _thrustTargetPosition, progress);\n            \n            if (progress >= 1f)\n            {\n                _isThrusting = false;\n                _isRetracting = true;\n                _thrustTimer = 0f;\n            }\n        }\n        else if (_isRetracting)\n        {\n            float retractProgress = _retractSpeed * Time.deltaTime;\n            transform.localPosition = Vector3.MoveTowards(transform.localPosition, _originalPosition, retractProgress);\n            \n            if (Vector3.Distance(transform.localPosition, _originalPosition) < 0.01f)\n            {\n                transform.localPosition = _originalPosition;\n                _isRetracting = false;\n                StartCooldown();\n                OnThrustComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void StartThrust()\n    {\n        _isThrusting = true;\n        _thrustTimer = 0f;\n        _thrustTargetPosition = _originalPosition + transform.forward * _thrustDistance;\n        \n        PlaySound(_thrustSound);\n        PlayThrustEffect();\n        OnThrustStart?.Invoke();\n    }\n    \n    private void StartCooldown()\n    {\n        _canThrust = false;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayThrustEffect()\n    {\n        if (_thrustEffect != null)\n        {\n            _thrustEffect.Play();\n        }\n    }\n    \n    private void PlayHitEffect(Vector3 hitPoint)\n    {\n        if (_hitEffect != null)\n        {\n            GameObject effect = Instantiate(_hitEffect, hitPoint, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isThrusting && other != null)\n        {\n            if (other.CompareTag(\"Enemy\"))\n            {\n                DealDamage(other.gameObject);\n                PlaySound(_hitSound);\n                PlayHitEffect(other.ClosestPoint(transform.position));\n                OnThrustHit?.Invoke();\n            }\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try different common health component patterns\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a fallback for damage dealing\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Alternative: Destroy enemies with specific tags\n        if (target.CompareTag(\"Enemy\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    public void SetDamage(int newDamage)\n    {\n        _damage = Mathf.Max(0, newDamage);\n    }\n    \n    public void SetThrustDistance(float newDistance)\n    {\n        _thrustDistance = Mathf.Max(0.1f, newDistance);\n    }\n    \n    public void SetCooldownTime(float newCooldown)\n    {\n        _cooldownTime = Mathf.Max(0f, newCooldown);\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    public bool CanThrust()\n    {\n        return _canThrust && !_isThrusting && !_isRetracting;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (_canThrust) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Portal\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"whooshSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"teleportRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"scaleMultiplier\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"distortionEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"portal_entry\",\n      \"trigger\": \"when player enters portal collider\",\n      \"actions\": [\n        {\n          \"action\": \"play whoosh sound effect\"\n        },\n        {\n          \"action\": \"rotate player 180 degrees instantly around vertical axis\"\n        },\n        {\n          \"action\": \"reverse player velocity direction\"\n        },\n        {\n          \"action\": \"change portal color to random hue\"\n        },\n        {\n          \"action\": \"scale portal to half its current size\"\n        },\n        {\n          \"action\": \"teleport portal to random location within 50 units\"\n        },\n        {\n          \"action\": \"create visual distortion effect at portal location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Portal : MonoBehaviour\n{\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _whooshSound;\n    \n    [Header(\"Portal Settings\")]\n    [SerializeField] private float _teleportRadius = 50f;\n    [SerializeField] private float _scaleMultiplier = 0.5f;\n    [SerializeField] private float _distortionDuration = 1f;\n    [SerializeField] private AnimationCurve _distortionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _portalEffect;\n    [SerializeField] private Material _distortionMaterial;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerTeleported;\n    \n    private Camera _mainCamera;\n    private Material _originalCameraMaterial;\n    private bool _isDistorting = false;\n    private float _distortionTimer = 0f;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        if (_portalEffect == null)\n            _portalEffect = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (_isDistorting)\n        {\n            _distortionTimer += Time.deltaTime;\n            float normalizedTime = _distortionTimer / _distortionDuration;\n            \n            if (normalizedTime >= 1f)\n            {\n                _isDistorting = false;\n                _distortionTimer = 0f;\n                RemoveDistortionEffect();\n            }\n            else\n            {\n                UpdateDistortionEffect(normalizedTime);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            TeleportPlayer(other.gameObject);\n        }\n    }\n    \n    private void TeleportPlayer(GameObject player)\n    {\n        PlayWhooshSound();\n        RotatePlayer180(player);\n        ReversePlayerVelocity(player);\n        ChangePlayerColor(player);\n        ScalePlayer(player);\n        TeleportToRandomLocation(player);\n        CreateDistortionEffect();\n        \n        if (_portalEffect != null)\n            _portalEffect.Play();\n            \n        OnPlayerTeleported?.Invoke();\n    }\n    \n    private void PlayWhooshSound()\n    {\n        if (_audioSource != null && _whooshSound != null)\n        {\n            _audioSource.PlayOneShot(_whooshSound);\n        }\n    }\n    \n    private void RotatePlayer180(GameObject player)\n    {\n        Transform playerTransform = player.transform;\n        playerTransform.rotation = Quaternion.Euler(\n            playerTransform.eulerAngles.x,\n            playerTransform.eulerAngles.y + 180f,\n            playerTransform.eulerAngles.z\n        );\n    }\n    \n    private void ReversePlayerVelocity(GameObject player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.velocity = -playerRb.velocity;\n            playerRb.angularVelocity = -playerRb.angularVelocity;\n        }\n        \n        CharacterController characterController = player.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            Vector3 reversedVelocity = -characterController.velocity;\n            characterController.Move(reversedVelocity * Time.fixedDeltaTime);\n        }\n    }\n    \n    private void ChangePlayerColor(GameObject player)\n    {\n        Renderer playerRenderer = player.GetComponent<Renderer>();\n        if (playerRenderer == null)\n            playerRenderer = player.GetComponentInChildren<Renderer>();\n            \n        if (playerRenderer != null)\n        {\n            Material playerMaterial = playerRenderer.material;\n            Color randomColor = Color.HSVToRGB(Random.Range(0f, 1f), 1f, 1f);\n            playerMaterial.color = randomColor;\n        }\n        \n        Renderer[] childRenderers = player.GetComponentsInChildren<Renderer>();\n        foreach (Renderer renderer in childRenderers)\n        {\n            Color randomColor = Color.HSVToRGB(Random.Range(0f, 1f), 1f, 1f);\n            renderer.material.color = randomColor;\n        }\n    }\n    \n    private void ScalePlayer(GameObject player)\n    {\n        player.transform.localScale *= _scaleMultiplier;\n    }\n    \n    private void TeleportToRandomLocation(GameObject player)\n    {\n        Vector3 randomDirection = Random.insideUnitSphere * _teleportRadius;\n        randomDirection.y = Mathf.Abs(randomDirection.y);\n        \n        Vector3 newPosition = transform.position + randomDirection;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(newPosition + Vector3.up * 100f, Vector3.down, out hit, 200f))\n        {\n            newPosition.y = hit.point.y + 1f;\n        }\n        \n        CharacterController characterController = player.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            player.transform.position = newPosition;\n            characterController.enabled = true;\n        }\n        else\n        {\n            player.transform.position = newPosition;\n        }\n    }\n    \n    private void CreateDistortionEffect()\n    {\n        if (_mainCamera == null) return;\n        \n        _isDistorting = true;\n        _distortionTimer = 0f;\n        \n        if (_distortionMaterial != null)\n        {\n            ApplyDistortionMaterial();\n        }\n        else\n        {\n            CreateScreenShake();\n        }\n    }\n    \n    private void ApplyDistortionMaterial()\n    {\n        if (_mainCamera != null && _distortionMaterial != null)\n        {\n            _mainCamera.GetComponent<Renderer>().material = _distortionMaterial;\n        }\n    }\n    \n    private void UpdateDistortionEffect(float normalizedTime)\n    {\n        float distortionStrength = _distortionCurve.Evaluate(normalizedTime);\n        \n        if (_distortionMaterial != null)\n        {\n            _distortionMaterial.SetFloat(\"_DistortionStrength\", distortionStrength);\n        }\n        \n        CreateScreenShake(distortionStrength * 0.1f);\n    }\n    \n    private void CreateScreenShake(float intensity = 0.1f)\n    {\n        if (_mainCamera != null)\n        {\n            Vector3 originalPosition = _mainCamera.transform.position;\n            Vector3 shakeOffset = Random.insideUnitSphere * intensity;\n            _mainCamera.transform.position = originalPosition + shakeOffset;\n            \n            StartCoroutine(ResetCameraPosition(originalPosition));\n        }\n    }\n    \n    private System.Collections.IEnumerator ResetCameraPosition(Vector3 originalPosition)\n    {\n        yield return new WaitForEndOfFrame();\n        if (_mainCamera != null)\n        {\n            _mainCamera.transform.position = Vector3.Lerp(\n                _mainCamera.transform.position, \n                originalPosition, \n                Time.deltaTime * 10f\n            );\n        }\n    }\n    \n    private void RemoveDistortionEffect()\n    {\n        if (_mainCamera != null && _originalCameraMaterial != null)\n        {\n            _mainCamera.GetComponent<Renderer>().material = _originalCameraMaterial;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _teleportRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LootChest\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isOpened\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lootItems\",\n      \"type\": \"GameObject[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"minLootCount\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"maxLootCount\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"openSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"chestLid\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"open_chest\",\n      \"trigger\": \"when player interacts with chest and chest is not already opened\",\n      \"actions\": [\n        {\n          \"action\": \"mark chest as opened\"\n        },\n        {\n          \"action\": \"play chest opening sound\"\n        },\n        {\n          \"action\": \"rotate chest lid upward to open position\"\n        },\n        {\n          \"action\": \"generate random number of loot items between minimum and maximum count\"\n        },\n        {\n          \"action\": \"randomly select loot items from available loot array\"\n        },\n        {\n          \"action\": \"spawn selected loot items above chest position\"\n        },\n        {\n          \"action\": \"apply random scatter force to spawned loot items\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_reopening\",\n      \"trigger\": \"when player tries to interact with chest that is already opened\",\n      \"actions\": [\n        {\n          \"action\": \"do nothing and ignore interaction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class LootChest : MonoBehaviour\n{\n    [System.Serializable]\n    public class LootItem\n    {\n        public GameObject itemPrefab;\n        public int minQuantity = 1;\n        public int maxQuantity = 1;\n        [Range(0f, 100f)]\n        public float dropChance = 100f;\n    }\n\n    [Header(\"Chest Settings\")]\n    [SerializeField] private bool _isOpen = false;\n    [SerializeField] private bool _canReopen = false;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Loot Configuration\")]\n    [SerializeField] private List<LootItem> _possibleLoot = new List<LootItem>();\n    [SerializeField] private int _minItemsToSpawn = 1;\n    [SerializeField] private int _maxItemsToSpawn = 3;\n    [SerializeField] private float _lootSpawnRadius = 1.5f;\n    [SerializeField] private float _lootSpawnForce = 5f;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Animator _chestAnimator;\n    [SerializeField] private ParticleSystem _openEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _alreadyOpenSound;\n\n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n\n    [Header(\"Events\")]\n    public UnityEvent OnChestOpened;\n    public UnityEvent OnChestAlreadyOpen;\n\n    private Transform _player;\n    private bool _playerInRange = false;\n\n    private void Start()\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n\n        if (_chestAnimator == null)\n            _chestAnimator = GetComponent<Animator>();\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        UpdateChestVisuals();\n    }\n\n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInteraction();\n    }\n\n    private void CheckForPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _player = player.transform;\n            float distance = Vector3.Distance(transform.position, _player.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _interactionRange;\n\n            if (_playerInRange != wasInRange)\n            {\n                UpdateInteractionPrompt();\n            }\n        }\n        else\n        {\n            if (_playerInRange)\n            {\n                _playerInRange = false;\n                UpdateInteractionPrompt();\n            }\n        }\n    }\n\n    private void HandleInteraction()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            OpenChest();\n        }\n    }\n\n    private void UpdateInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            bool shouldShow = _playerInRange && (!_isOpen || _canReopen);\n            _interactionPrompt.SetActive(shouldShow);\n        }\n    }\n\n    public void OpenChest()\n    {\n        if (_isOpen && !_canReopen)\n        {\n            PlayAlreadyOpenFeedback();\n            return;\n        }\n\n        _isOpen = true;\n        UpdateChestVisuals();\n        SpawnLoot();\n        PlayOpenEffects();\n        OnChestOpened?.Invoke();\n        UpdateInteractionPrompt();\n    }\n\n    private void SpawnLoot()\n    {\n        if (_possibleLoot.Count == 0) return;\n\n        int itemsToSpawn = Random.Range(_minItemsToSpawn, _maxItemsToSpawn + 1);\n        \n        for (int i = 0; i < itemsToSpawn; i++)\n        {\n            LootItem selectedLoot = SelectRandomLoot();\n            if (selectedLoot != null && selectedLoot.itemPrefab != null)\n            {\n                SpawnLootItem(selectedLoot);\n            }\n        }\n    }\n\n    private LootItem SelectRandomLoot()\n    {\n        List<LootItem> availableLoot = new List<LootItem>();\n        \n        foreach (LootItem loot in _possibleLoot)\n        {\n            if (Random.Range(0f, 100f) <= loot.dropChance)\n            {\n                availableLoot.Add(loot);\n            }\n        }\n\n        if (availableLoot.Count == 0) return null;\n        \n        return availableLoot[Random.Range(0, availableLoot.Count)];\n    }\n\n    private void SpawnLootItem(LootItem lootItem)\n    {\n        int quantity = Random.Range(lootItem.minQuantity, lootItem.maxQuantity + 1);\n        \n        for (int i = 0; i < quantity; i++)\n        {\n            Vector3 spawnPosition = GetRandomSpawnPosition();\n            GameObject spawnedItem = Instantiate(lootItem.itemPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody rb = spawnedItem.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 randomDirection = Random.insideUnitSphere;\n                randomDirection.y = Mathf.Abs(randomDirection.y);\n                rb.AddForce(randomDirection * _lootSpawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n\n    private Vector3 GetRandomSpawnPosition()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _lootSpawnRadius;\n        Vector3 spawnOffset = new Vector3(randomCircle.x, 1f, randomCircle.y);\n        return transform.position + spawnOffset;\n    }\n\n    private void UpdateChestVisuals()\n    {\n        if (_chestAnimator != null)\n        {\n            _chestAnimator.SetBool(\"IsOpen\", _isOpen);\n        }\n    }\n\n    private void PlayOpenEffects()\n    {\n        if (_openEffect != null)\n        {\n            _openEffect.Play();\n        }\n\n        if (_audioSource != null && _openSound != null)\n        {\n            _audioSource.PlayOneShot(_openSound);\n        }\n    }\n\n    private void PlayAlreadyOpenFeedback()\n    {\n        if (_audioSource != null && _alreadyOpenSound != null)\n        {\n            _audioSource.PlayOneShot(_alreadyOpenSound);\n        }\n\n        OnChestAlreadyOpen?.Invoke();\n    }\n\n    public void ResetChest()\n    {\n        _isOpen = false;\n        UpdateChestVisuals();\n        UpdateInteractionPrompt();\n    }\n\n    public void AddLootItem(GameObject itemPrefab, int minQty = 1, int maxQty = 1, float chance = 100f)\n    {\n        LootItem newLoot = new LootItem\n        {\n            itemPrefab = itemPrefab,\n            minQuantity = minQty,\n            maxQuantity = maxQty,\n            dropChance = chance\n        };\n        _possibleLoot.Add(newLoot);\n    }\n\n    public void ClearLoot()\n    {\n        _possibleLoot.Clear();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _lootSpawnRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InvincibilityPowerUp\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"invincibilityDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"rotate_continuously\",\n      \"trigger\": \"every frame while power-up exists\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_power_up\",\n      \"trigger\": \"when player touches this power-up\",\n      \"actions\": [\n        {\n          \"action\": \"mark power-up as collected\"\n        },\n        {\n          \"action\": \"grant player invincibility for specified duration\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"destroy this power-up object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bob_up_and_down\",\n      \"trigger\": \"every frame while power-up exists\",\n      \"actions\": [\n        {\n          \"action\": \"move up and down in a smooth floating motion\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class InvincibilityPowerUp : MonoBehaviour\n{\n    [Header(\"Power-Up Settings\")]\n    [SerializeField] private float _invincibilityDuration = 5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private bool _destroyOnPickup = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private Color _invincibilityColor = Color.yellow;\n    [SerializeField] private float _flashSpeed = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPowerUpCollected;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        AnimatePowerUp();\n    }\n    \n    private void AnimatePowerUp()\n    {\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyInvincibility(other.gameObject);\n            HandlePickupEffects();\n            OnPowerUpCollected?.Invoke();\n            \n            if (_destroyOnPickup)\n            {\n                Destroy(gameObject);\n            }\n            else\n            {\n                gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    private void ApplyInvincibility(GameObject player)\n    {\n        InvincibilityEffect invincibilityEffect = player.GetComponent<InvincibilityEffect>();\n        \n        if (invincibilityEffect == null)\n        {\n            invincibilityEffect = player.AddComponent<InvincibilityEffect>();\n        }\n        \n        invincibilityEffect.ActivateInvincibility(_invincibilityDuration, _invincibilityColor, _flashSpeed);\n    }\n    \n    private void HandlePickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n}\n\npublic class InvincibilityEffect : MonoBehaviour\n{\n    private bool _isInvincible = false;\n    private Renderer[] _renderers;\n    private Color[] _originalColors;\n    private Collider _playerCollider;\n    private Coroutine _invincibilityCoroutine;\n    \n    public bool IsInvincible => _isInvincible;\n    \n    private void Awake()\n    {\n        _renderers = GetComponentsInChildren<Renderer>();\n        _originalColors = new Color[_renderers.Length];\n        _playerCollider = GetComponent<Collider>();\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i].material != null)\n            {\n                _originalColors[i] = _renderers[i].material.color;\n            }\n        }\n    }\n    \n    public void ActivateInvincibility(float duration, Color invincibilityColor, float flashSpeed)\n    {\n        if (_invincibilityCoroutine != null)\n        {\n            StopCoroutine(_invincibilityCoroutine);\n        }\n        \n        _invincibilityCoroutine = StartCoroutine(InvincibilityCoroutine(duration, invincibilityColor, flashSpeed));\n    }\n    \n    private IEnumerator InvincibilityCoroutine(float duration, Color invincibilityColor, float flashSpeed)\n    {\n        _isInvincible = true;\n        float elapsed = 0f;\n        \n        if (_playerCollider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), true);\n        }\n        \n        while (elapsed < duration)\n        {\n            float flashValue = Mathf.Sin(Time.time * flashSpeed) * 0.5f + 0.5f;\n            \n            for (int i = 0; i < _renderers.Length; i++)\n            {\n                if (_renderers[i] != null && _renderers[i].material != null)\n                {\n                    _renderers[i].material.color = Color.Lerp(_originalColors[i], invincibilityColor, flashValue);\n                }\n            }\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _isInvincible = false;\n        \n        if (_playerCollider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), false);\n        }\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _renderers[i].material != null)\n            {\n                _renderers[i].material.color = _originalColors[i];\n            }\n        }\n        \n        _invincibilityCoroutine = null;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInvincible && (other.CompareTag(\"Enemy\") || other.CompareTag(\"Projectile\")))\n        {\n            // Ignore damage while invincible\n            return;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isInvincible && (collision.gameObject.CompareTag(\"Enemy\") || collision.gameObject.CompareTag(\"Projectile\")))\n        {\n            // Ignore damage while invincible\n            return;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PoisonScorpion\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"attackRange\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"poisonDamage\",\n      \"type\": \"int\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"poisonDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"attackCooldown\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"int\",\n      \"default\": 80\n    },\n    {\n      \"name\": \"isAttacking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lastAttackTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"patrol_behavior\",\n      \"trigger\": \"when no player is detected within range\",\n      \"actions\": [\n        {\n          \"action\": \"move forward slowly in current direction\"\n        },\n        {\n          \"action\": \"play walking animation\"\n        },\n        {\n          \"action\": \"randomly change direction occasionally\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop patrolling\"\n        },\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"play alert animation\"\n        },\n        {\n          \"action\": \"increase movement speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_player\",\n      \"trigger\": \"when player is within detection range but outside attack range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at increased speed\"\n        },\n        {\n          \"action\": \"play aggressive walking animation\"\n        },\n        {\n          \"action\": \"keep tail raised and ready\"\n        }\n      ]\n    },\n    {\n      \"name\": \"poison_sting_attack\",\n      \"trigger\": \"when player is within attack range and attack cooldown has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"play tail strike animation\"\n        },\n        {\n          \"action\": \"deal poison damage to player\"\n        },\n        {\n          \"action\": \"apply poison effect that damages over time\"\n        },\n        {\n          \"action\": \"start attack cooldown timer\"\n        },\n        {\n          \"action\": \"play attack sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"defensive_stance\",\n      \"trigger\": \"when health drops below half\",\n      \"actions\": [\n        {\n          \"action\": \"raise claws defensively\"\n        },\n        {\n          \"action\": \"move more cautiously\"\n        },\n        {\n          \"action\": \"increase attack frequency\"\n        },\n        {\n          \"action\": \"play wounded animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_behavior\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"curl up tail\"\n        },\n        {\n          \"action\": \"disable collision\"\n        },\n        {\n          \"action\": \"fade out after delay\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Scorpion : MonoBehaviour\n{\n    [System.Serializable]\n    public class ScorpionEvents\n    {\n        public UnityEvent OnAttack;\n        public UnityEvent OnPlayerHit;\n        public UnityEvent OnDeath;\n    }\n\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _wanderRadius = 5f;\n    [SerializeField] private float _wanderTimer = 3f;\n\n    [Header(\"Combat\")]\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _poisonDamage = 10f;\n    [SerializeField] private float _poisonDuration = 5f;\n    [SerializeField] private int _maxHealth = 50;\n\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Transform _tailTransform;\n    [SerializeField] private float _tailAttackHeight = 1.5f;\n    [SerializeField] private float _tailAttackSpeed = 5f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _poisonEffect;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n\n    [Header(\"Events\")]\n    [SerializeField] private ScorpionEvents _events;\n\n    private enum ScorpionState\n    {\n        Wandering,\n        Chasing,\n        Attacking,\n        Dead\n    }\n\n    private ScorpionState _currentState = ScorpionState.Wandering;\n    private Transform _player;\n    private Vector3 _wanderTarget;\n    private Vector3 _initialPosition;\n    private float _lastAttackTime;\n    private float _wanderTime;\n    private int _currentHealth;\n    private bool _isAttacking;\n    private Vector3 _tailOriginalPosition;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _initialPosition = transform.position;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_tailTransform != null)\n        {\n            _tailOriginalPosition = _tailTransform.localPosition;\n        }\n        \n        SetNewWanderTarget();\n    }\n\n    private void Update()\n    {\n        if (_currentState == ScorpionState.Dead) return;\n\n        DetectPlayer();\n        UpdateState();\n        HandleMovement();\n        HandleTailAnimation();\n    }\n\n    private void DetectPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n        \n        if (playersInRange.Length > 0)\n        {\n            Transform closestPlayer = null;\n            float closestDistance = float.MaxValue;\n            \n            foreach (var playerCollider in playersInRange)\n            {\n                if (playerCollider.CompareTag(\"Player\"))\n                {\n                    float distance = Vector3.Distance(transform.position, playerCollider.transform.position);\n                    if (distance < closestDistance)\n                    {\n                        closestDistance = distance;\n                        closestPlayer = playerCollider.transform;\n                    }\n                }\n            }\n            \n            _player = closestPlayer;\n        }\n        else\n        {\n            _player = null;\n        }\n    }\n\n    private void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case ScorpionState.Wandering:\n                if (_player != null)\n                {\n                    _currentState = ScorpionState.Chasing;\n                }\n                else if (Vector3.Distance(transform.position, _wanderTarget) < 0.5f)\n                {\n                    SetNewWanderTarget();\n                }\n                break;\n\n            case ScorpionState.Chasing:\n                if (_player == null)\n                {\n                    _currentState = ScorpionState.Wandering;\n                    SetNewWanderTarget();\n                }\n                else if (Vector3.Distance(transform.position, _player.position) <= _attackRange)\n                {\n                    if (Time.time - _lastAttackTime >= _attackCooldown)\n                    {\n                        _currentState = ScorpionState.Attacking;\n                        StartAttack();\n                    }\n                }\n                break;\n\n            case ScorpionState.Attacking:\n                if (!_isAttacking)\n                {\n                    _currentState = _player != null ? ScorpionState.Chasing : ScorpionState.Wandering;\n                }\n                break;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (_currentState == ScorpionState.Attacking || _isAttacking) return;\n\n        Vector3 targetPosition = _currentState == ScorpionState.Chasing ? _player.position : _wanderTarget;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            \n            Vector3 movement = direction * _moveSpeed * Time.deltaTime;\n            _rigidbody.MovePosition(transform.position + movement);\n        }\n\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsMoving\", direction != Vector3.zero);\n        }\n    }\n\n    private void SetNewWanderTarget()\n    {\n        Vector2 randomDirection = Random.insideUnitCircle * _wanderRadius;\n        _wanderTarget = _initialPosition + new Vector3(randomDirection.x, 0, randomDirection.y);\n        _wanderTime = Time.time + _wanderTimer;\n    }\n\n    private void StartAttack()\n    {\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Attack\");\n        }\n        \n        if (_audioSource != null && _attackSound != null)\n        {\n            _audioSource.PlayOneShot(_attackSound);\n        }\n        \n        _events?.OnAttack?.Invoke();\n        \n        Invoke(nameof(ExecuteAttack), 0.5f);\n        Invoke(nameof(EndAttack), 1f);\n    }\n\n    private void ExecuteAttack()\n    {\n        if (_player != null && Vector3.Distance(transform.position, _player.position) <= _attackRange)\n        {\n            ApplyPoisonToPlayer(_player.gameObject);\n            _events?.OnPlayerHit?.Invoke();\n        }\n    }\n\n    private void EndAttack()\n    {\n        _isAttacking = false;\n    }\n\n    private void ApplyPoisonToPlayer(GameObject player)\n    {\n        PoisonEffect poisonComponent = player.GetComponent<PoisonEffect>();\n        if (poisonComponent == null)\n        {\n            poisonComponent = player.AddComponent<PoisonEffect>();\n        }\n        \n        poisonComponent.ApplyPoison(_poisonDamage, _poisonDuration);\n        \n        if (_poisonEffect != null)\n        {\n            GameObject effect = Instantiate(_poisonEffect, player.transform.position, Quaternion.identity);\n            effect.transform.SetParent(player.transform);\n            Destroy(effect, _poisonDuration);\n        }\n    }\n\n    private void HandleTailAnimation()\n    {\n        if (_tailTransform == null) return;\n\n        if (_isAttacking)\n        {\n            float attackProgress = Mathf.PingPong(Time.time * _tailAttackSpeed, 1f);\n            Vector3 targetPosition = _tailOriginalPosition + Vector3.up * _tailAttackHeight * attackProgress;\n            _tailTransform.localPosition = Vector3.Lerp(_tailTransform.localPosition, targetPosition, Time.deltaTime * 10f);\n        }\n        else\n        {\n            _tailTransform.localPosition = Vector3.Lerp(_tailTransform.localPosition, _tailOriginalPosition, Time.deltaTime * 5f);\n        }\n    }\n\n    public void TakeDamage(int damage)\n    {\n        if (_currentState == ScorpionState.Dead) return;\n\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        _currentState = ScorpionState.Dead;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Death\");\n        }\n        \n        if (_audioSource != null && _deathSound != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        _events?.OnDeath?.Invoke();\n        \n        GetComponent<Collider>().enabled = false;\n        _rigidbody.isKinematic = true;\n        \n        Destroy(gameObject, 3f);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState != ScorpionState.Dead)\n        {\n            if (Vector3.Distance(transform.position, other.transform.position) <= _attackRange)\n            {\n                if (Time.time - _lastAttackTime >= _attackCooldown)\n                {\n                    _currentState = ScorpionState.Attacking;\n                    StartAttack();\n                }\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_initialPosition, _wanderRadius);\n    }\n\n    [System.Serializable]\n    public class PoisonEffect : MonoBehaviour\n    {\n        private float _damagePerSecond;\n        private float _duration;\n        private float _startTime;\n        private bool _isActive;\n\n        public void ApplyPoison(float damage, float duration)\n        {\n            _damagePerSecond = damage / duration;\n            _duration = duration;\n            _startTime = Time.time;\n            _isActive = true;\n        }\n\n        private void Update()\n        {\n            if (!_isActive) return;\n\n            if (Time.time - _startTime >= _duration)\n            {\n                _isActive = false;\n                Destroy(this);\n                return;\n            }\n\n            // Apply poison damage (you would typically reduce player health here)\n            // Since we can't reference PlayerHealth, this is a placeholder\n            Debug.Log($\"Poison damage applied: {_damagePerSecond * Time.deltaTime}\");\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChatMessageBubble\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"messageText\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_message\",\n      \"trigger\": \"when message text is set\",\n      \"actions\": [\n        {\n          \"action\": \"make bubble visible\"\n        },\n        {\n          \"action\": \"display the message text\"\n        },\n        {\n          \"action\": \"set bubble to full opacity\"\n        },\n        {\n          \"action\": \"start display timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_hide\",\n      \"trigger\": \"when display duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"begin fading out the bubble\"\n        },\n        {\n          \"action\": \"gradually reduce opacity to zero\"\n        },\n        {\n          \"action\": \"hide bubble when fully transparent\"\n        }\n      ]\n    },\n    {\n      \"name\": \"follow_speaker\",\n      \"trigger\": \"while bubble is visible\",\n      \"actions\": [\n        {\n          \"action\": \"position bubble above speaker\"\n        },\n        {\n          \"action\": \"maintain offset from speaker position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_size\",\n      \"trigger\": \"when message text changes\",\n      \"actions\": [\n        {\n          \"action\": \"resize bubble to fit text content\"\n        },\n        {\n          \"action\": \"maintain minimum bubble size\"\n        },\n        {\n          \"action\": \"center text within bubble\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\n\npublic class ChatMessageBubble : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private TextMeshProUGUI _messageText;\n    [SerializeField] private TextMeshProUGUI _senderNameText;\n    [SerializeField] private Image _bubbleBackground;\n    [SerializeField] private Image _avatarImage;\n    [SerializeField] private RectTransform _bubbleRect;\n    \n    [Header(\"Bubble Settings\")]\n    [SerializeField] private Color _playerBubbleColor = new Color(0.2f, 0.6f, 1f, 0.8f);\n    [SerializeField] private Color _otherBubbleColor = new Color(0.8f, 0.8f, 0.8f, 0.8f);\n    [SerializeField] private Color _playerTextColor = Color.white;\n    [SerializeField] private Color _otherTextColor = Color.black;\n    [SerializeField] private float _maxBubbleWidth = 300f;\n    [SerializeField] private float _minBubbleWidth = 100f;\n    [SerializeField] private Vector2 _bubblePadding = new Vector2(20f, 15f);\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _scaleInDuration = 0.2f;\n    [SerializeField] private AnimationCurve _scaleInCurve = AnimationCurve.EaseOutQuart(0, 0, 1, 1);\n    [SerializeField] private bool _animateOnStart = true;\n    \n    [Header(\"Auto Destroy\")]\n    [SerializeField] private bool _autoDestroy = false;\n    [SerializeField] private float _destroyDelay = 5f;\n    \n    private CanvasGroup _canvasGroup;\n    private bool _isPlayerMessage;\n    private string _messageContent;\n    private string _senderName;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n        {\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n        }\n        \n        if (_bubbleRect == null)\n        {\n            _bubbleRect = GetComponent<RectTransform>();\n        }\n    }\n    \n    private void Start()\n    {\n        if (_animateOnStart)\n        {\n            AnimateIn();\n        }\n        \n        if (_autoDestroy)\n        {\n            StartCoroutine(AutoDestroyCoroutine());\n        }\n    }\n    \n    public void SetMessage(string message, string senderName, bool isPlayerMessage, Sprite avatarSprite = null)\n    {\n        _messageContent = message;\n        _senderName = senderName;\n        _isPlayerMessage = isPlayerMessage;\n        \n        UpdateMessageDisplay();\n        UpdateBubbleAppearance();\n        UpdateBubbleSize();\n        \n        if (avatarSprite != null && _avatarImage != null)\n        {\n            _avatarImage.sprite = avatarSprite;\n        }\n    }\n    \n    private void UpdateMessageDisplay()\n    {\n        if (_messageText != null)\n        {\n            _messageText.text = _messageContent;\n            _messageText.color = _isPlayerMessage ? _playerTextColor : _otherTextColor;\n        }\n        \n        if (_senderNameText != null)\n        {\n            _senderNameText.text = _senderName;\n            _senderNameText.color = _isPlayerMessage ? _playerTextColor : _otherTextColor;\n        }\n    }\n    \n    private void UpdateBubbleAppearance()\n    {\n        if (_bubbleBackground != null)\n        {\n            _bubbleBackground.color = _isPlayerMessage ? _playerBubbleColor : _otherBubbleColor;\n        }\n        \n        // Flip bubble alignment for player vs other messages\n        if (_bubbleRect != null)\n        {\n            Vector2 anchorMin = _bubbleRect.anchorMin;\n            Vector2 anchorMax = _bubbleRect.anchorMax;\n            Vector2 pivot = _bubbleRect.pivot;\n            \n            if (_isPlayerMessage)\n            {\n                // Align to right\n                anchorMin.x = 1f;\n                anchorMax.x = 1f;\n                pivot.x = 1f;\n            }\n            else\n            {\n                // Align to left\n                anchorMin.x = 0f;\n                anchorMax.x = 0f;\n                pivot.x = 0f;\n            }\n            \n            _bubbleRect.anchorMin = anchorMin;\n            _bubbleRect.anchorMax = anchorMax;\n            _bubbleRect.pivot = pivot;\n        }\n    }\n    \n    private void UpdateBubbleSize()\n    {\n        if (_messageText == null || _bubbleRect == null) return;\n        \n        // Force text to update\n        _messageText.ForceMeshUpdate();\n        \n        // Calculate preferred width based on text\n        float preferredWidth = _messageText.preferredWidth + _bubblePadding.x * 2;\n        preferredWidth = Mathf.Clamp(preferredWidth, _minBubbleWidth, _maxBubbleWidth);\n        \n        // Calculate preferred height based on text\n        float preferredHeight = _messageText.preferredHeight + _bubblePadding.y * 2;\n        \n        // Add height for sender name if present\n        if (_senderNameText != null && !string.IsNullOrEmpty(_senderName))\n        {\n            preferredHeight += _senderNameText.preferredHeight + 5f;\n        }\n        \n        // Set the bubble size\n        _bubbleRect.sizeDelta = new Vector2(preferredWidth, preferredHeight);\n    }\n    \n    public void AnimateIn()\n    {\n        if (_canvasGroup != null)\n        {\n            StartCoroutine(FadeInCoroutine());\n        }\n        \n        StartCoroutine(ScaleInCoroutine());\n    }\n    \n    public void AnimateOut(System.Action onComplete = null)\n    {\n        StartCoroutine(AnimateOutCoroutine(onComplete));\n    }\n    \n    private IEnumerator FadeInCoroutine()\n    {\n        _canvasGroup.alpha = 0f;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            _canvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsedTime / _fadeInDuration);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator ScaleInCoroutine()\n    {\n        Vector3 originalScale = transform.localScale;\n        transform.localScale = Vector3.zero;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _scaleInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _scaleInDuration;\n            float curveValue = _scaleInCurve.Evaluate(progress);\n            transform.localScale = Vector3.Lerp(Vector3.zero, originalScale, curveValue);\n            yield return null;\n        }\n        \n        transform.localScale = originalScale;\n    }\n    \n    private IEnumerator AnimateOutCoroutine(System.Action onComplete)\n    {\n        float duration = 0.2f;\n        Vector3 originalScale = transform.localScale;\n        float originalAlpha = _canvasGroup != null ? _canvasGroup.alpha : 1f;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / duration;\n            \n            transform.localScale = Vector3.Lerp(originalScale, Vector3.zero, progress);\n            \n            if (_canvasGroup != null)\n            {\n                _canvasGroup.alpha = Mathf.Lerp(originalAlpha, 0f, progress);\n            }\n            \n            yield return null;\n        }\n        \n        onComplete?.Invoke();\n    }\n    \n    private IEnumerator AutoDestroyCoroutine()\n    {\n        yield return new WaitForSeconds(_destroyDelay);\n        \n        AnimateOut(() => {\n            if (gameObject != null)\n            {\n                Destroy(gameObject);\n            }\n        });\n    }\n    \n    public void SetAutoDestroy(bool enable, float delay = 5f)\n    {\n        _autoDestroy = enable;\n        _destroyDelay = delay;\n        \n        if (enable)\n        {\n            StopCoroutine(AutoDestroyCoroutine());\n            StartCoroutine(AutoDestroyCoroutine());\n        }\n    }\n    \n    public void UpdateBubbleColors(Color bubbleColor, Color textColor)\n    {\n        if (_bubbleBackground != null)\n        {\n            _bubbleBackground.color = bubbleColor;\n        }\n        \n        if (_messageText != null)\n        {\n            _messageText.color = textColor;\n        }\n        \n        if (_senderNameText != null)\n        {\n            _senderNameText.color = textColor;\n        }\n    }\n    \n    public string GetMessage()\n    {\n        return _messageContent;\n    }\n    \n    public string GetSenderName()\n    {\n        return _senderName;\n    }\n    \n    public bool IsPlayerMessage()\n    {\n        return _isPlayerMessage;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BuffDebuffIcon\",\n  \"components\": [\n    \"Image\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"iconImage\",\n      \"type\": \"Sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"effectType\",\n      \"type\": \"string\",\n      \"default\": \"buff\"\n    },\n    {\n      \"name\": \"duration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"pulseIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_icon\",\n      \"trigger\": \"when effect is applied to player\",\n      \"actions\": [\n        {\n          \"action\": \"make icon visible\"\n        },\n        {\n          \"action\": \"set icon image to match effect type\"\n        },\n        {\n          \"action\": \"start duration countdown\"\n        },\n        {\n          \"action\": \"mark as active\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_animation\",\n      \"trigger\": \"while icon is active\",\n      \"actions\": [\n        {\n          \"action\": \"gently pulse icon transparency\"\n        },\n        {\n          \"action\": \"create subtle breathing effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"countdown_display\",\n      \"trigger\": \"while duration is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"reduce remaining duration over time\"\n        },\n        {\n          \"action\": \"update visual countdown if enabled\"\n        }\n      ]\n    },\n    {\n      \"name\": \"warning_flash\",\n      \"trigger\": \"when duration is less than three seconds\",\n      \"actions\": [\n        {\n          \"action\": \"flash icon more rapidly\"\n        },\n        {\n          \"action\": \"change color to warning tint\"\n        }\n      ]\n    },\n    {\n      \"name\": \"expire_effect\",\n      \"trigger\": \"when duration reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"fade out icon smoothly\"\n        },\n        {\n          \"action\": \"mark as inactive\"\n        },\n        {\n          \"action\": \"hide icon completely\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stack_indicator\",\n      \"trigger\": \"when same effect is applied multiple times\",\n      \"actions\": [\n        {\n          \"action\": \"show stack count number\"\n        },\n        {\n          \"action\": \"refresh duration to maximum\"\n        },\n        {\n          \"action\": \"briefly highlight icon\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class BuffDebuffIconManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class BuffDebuffData\n    {\n        public string name;\n        public Sprite icon;\n        public Color iconColor = Color.white;\n        public bool isBuff = true;\n        public float duration;\n        public string description;\n    }\n\n    [System.Serializable]\n    public class ActiveEffect\n    {\n        public BuffDebuffData data;\n        public float remainingTime;\n        public GameObject iconObject;\n        public Image iconImage;\n        public Image fillImage;\n        public Text durationText;\n        \n        public ActiveEffect(BuffDebuffData effectData, float time)\n        {\n            data = effectData;\n            remainingTime = time;\n        }\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _iconContainer;\n    [SerializeField] private GameObject _iconPrefab;\n    [SerializeField] private Canvas _canvas;\n\n    [Header(\"Layout Settings\")]\n    [SerializeField] private float _iconSize = 50f;\n    [SerializeField] private float _iconSpacing = 5f;\n    [SerializeField] private int _maxIconsPerRow = 8;\n    [SerializeField] private bool _separateBuffsDebuffs = true;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _fadeOutDuration = 0.2f;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 0.8f, 1, 1f);\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _buffBorderColor = Color.green;\n    [SerializeField] private Color _debuffBorderColor = Color.red;\n    [SerializeField] private bool _showDurationText = true;\n    [SerializeField] private bool _showTooltips = true;\n\n    [Header(\"Available Effects\")]\n    [SerializeField] private List<BuffDebuffData> _availableEffects = new List<BuffDebuffData>();\n\n    private List<ActiveEffect> _activeEffects = new List<ActiveEffect>();\n    private Dictionary<string, ActiveEffect> _effectLookup = new Dictionary<string, ActiveEffect>();\n    private Coroutine _updateCoroutine;\n\n    private void Start()\n    {\n        InitializeIconContainer();\n        _updateCoroutine = StartCoroutine(UpdateEffectsCoroutine());\n    }\n\n    private void InitializeIconContainer()\n    {\n        if (_iconContainer == null)\n        {\n            GameObject container = new GameObject(\"BuffDebuffContainer\");\n            container.transform.SetParent(transform);\n            _iconContainer = container.transform;\n            \n            RectTransform rectTransform = container.AddComponent<RectTransform>();\n            rectTransform.anchorMin = new Vector2(0.5f, 1f);\n            rectTransform.anchorMax = new Vector2(0.5f, 1f);\n            rectTransform.pivot = new Vector2(0.5f, 1f);\n            rectTransform.anchoredPosition = new Vector2(0, -10f);\n        }\n\n        if (_canvas == null)\n        {\n            _canvas = GetComponentInParent<Canvas>();\n            if (_canvas == null)\n            {\n                _canvas = FindObjectOfType<Canvas>();\n            }\n        }\n\n        CreateIconPrefabIfNeeded();\n    }\n\n    private void CreateIconPrefabIfNeeded()\n    {\n        if (_iconPrefab == null)\n        {\n            _iconPrefab = new GameObject(\"BuffDebuffIcon\");\n            \n            RectTransform rectTransform = _iconPrefab.AddComponent<RectTransform>();\n            rectTransform.sizeDelta = new Vector2(_iconSize, _iconSize);\n            \n            Image backgroundImage = _iconPrefab.AddComponent<Image>();\n            backgroundImage.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);\n            \n            GameObject iconChild = new GameObject(\"Icon\");\n            iconChild.transform.SetParent(_iconPrefab.transform);\n            RectTransform iconRect = iconChild.AddComponent<RectTransform>();\n            iconRect.anchorMin = Vector2.zero;\n            iconRect.anchorMax = Vector2.one;\n            iconRect.offsetMin = Vector2.one * 2f;\n            iconRect.offsetMax = Vector2.one * -2f;\n            Image iconImage = iconChild.AddComponent<Image>();\n            \n            GameObject fillChild = new GameObject(\"Fill\");\n            fillChild.transform.SetParent(_iconPrefab.transform);\n            RectTransform fillRect = fillChild.AddComponent<RectTransform>();\n            fillRect.anchorMin = Vector2.zero;\n            fillRect.anchorMax = Vector2.one;\n            fillRect.offsetMin = Vector2.zero;\n            fillRect.offsetMax = Vector2.zero;\n            Image fillImage = fillChild.AddComponent<Image>();\n            fillImage.color = new Color(1f, 1f, 1f, 0.3f);\n            fillImage.type = Image.Type.Filled;\n            fillImage.fillMethod = Image.FillMethod.Radial360;\n            \n            if (_showDurationText)\n            {\n                GameObject textChild = new GameObject(\"Duration\");\n                textChild.transform.SetParent(_iconPrefab.transform);\n                RectTransform textRect = textChild.AddComponent<RectTransform>();\n                textRect.anchorMin = new Vector2(0f, 0f);\n                textRect.anchorMax = new Vector2(1f, 0.3f);\n                textRect.offsetMin = Vector2.zero;\n                textRect.offsetMax = Vector2.zero;\n                Text durationText = textChild.AddComponent<Text>();\n                durationText.text = \"\";\n                durationText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n                durationText.fontSize = 10;\n                durationText.color = Color.white;\n                durationText.alignment = TextAnchor.MiddleCenter;\n            }\n            \n            _iconPrefab.SetActive(false);\n        }\n    }\n\n    public void AddEffect(string effectName, float duration = -1f)\n    {\n        BuffDebuffData effectData = GetEffectData(effectName);\n        if (effectData == null)\n        {\n            Debug.LogWarning($\"Effect '{effectName}' not found in available effects.\");\n            return;\n        }\n\n        float effectDuration = duration > 0 ? duration : effectData.duration;\n        \n        if (_effectLookup.ContainsKey(effectName))\n        {\n            RefreshEffect(effectName, effectDuration);\n        }\n        else\n        {\n            CreateNewEffect(effectData, effectDuration);\n        }\n        \n        UpdateIconLayout();\n    }\n\n    public void RemoveEffect(string effectName)\n    {\n        if (_effectLookup.ContainsKey(effectName))\n        {\n            ActiveEffect effect = _effectLookup[effectName];\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    public void RemoveAllEffects()\n    {\n        List<ActiveEffect> effectsToRemove = new List<ActiveEffect>(_activeEffects);\n        foreach (ActiveEffect effect in effectsToRemove)\n        {\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    public bool HasEffect(string effectName)\n    {\n        return _effectLookup.ContainsKey(effectName);\n    }\n\n    public float GetEffectRemainingTime(string effectName)\n    {\n        if (_effectLookup.ContainsKey(effectName))\n        {\n            return _effectLookup[effectName].remainingTime;\n        }\n        return 0f;\n    }\n\n    private BuffDebuffData GetEffectData(string effectName)\n    {\n        return _availableEffects.Find(effect => effect.name == effectName);\n    }\n\n    private void RefreshEffect(string effectName, float newDuration)\n    {\n        ActiveEffect effect = _effectLookup[effectName];\n        effect.remainingTime = newDuration;\n        \n        if (effect.iconObject != null)\n        {\n            StartCoroutine(RefreshEffectAnimation(effect.iconObject));\n        }\n    }\n\n    private void CreateNewEffect(BuffDebuffData effectData, float duration)\n    {\n        GameObject iconObject = Instantiate(_iconPrefab, _iconContainer);\n        iconObject.SetActive(true);\n        \n        ActiveEffect newEffect = new ActiveEffect(effectData, duration);\n        newEffect.iconObject = iconObject;\n        \n        SetupIconComponents(newEffect);\n        _activeEffects.Add(newEffect);\n        _effectLookup[effectData.name] = newEffect;\n        \n        StartCoroutine(FadeInEffect(newEffect));\n    }\n\n    private void SetupIconComponents(ActiveEffect effect)\n    {\n        Image backgroundImage = effect.iconObject.GetComponent<Image>();\n        backgroundImage.color = effect.data.isBuff ? _buffBorderColor : _debuffBorderColor;\n        \n        Transform iconTransform = effect.iconObject.transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            effect.iconImage = iconTransform.GetComponent<Image>();\n            effect.iconImage.sprite = effect.data.icon;\n            effect.iconImage.color = effect.data.iconColor;\n        }\n        \n        Transform fillTransform = effect.iconObject.transform.Find(\"Fill\");\n        if (fillTransform != null)\n        {\n            effect.fillImage = fillTransform.GetComponent<Image>();\n        }\n        \n        if (_showDurationText)\n        {\n            Transform textTransform = effect.iconObject.transform.Find(\"Duration\");\n            if (textTransform != null)\n            {\n                effect.durationText = textTransform.GetComponent<Text>();\n            }\n        }\n        \n        if (_showTooltips)\n        {\n            SetupTooltip(effect);\n        }\n    }\n\n    private void SetupTooltip(ActiveEffect effect)\n    {\n        TooltipTrigger tooltip = effect.iconObject.GetComponent<TooltipTrigger>();\n        if (tooltip == null)\n        {\n            tooltip = effect.iconObject.AddComponent<TooltipTrigger>();\n        }\n        tooltip.tooltipText = $\"{effect.data.name}\\n{effect.data.description}\";\n    }\n\n    private IEnumerator UpdateEffectsCoroutine()\n    {\n        while (true)\n        {\n            UpdateActiveEffects();\n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n\n    private void UpdateActiveEffects()\n    {\n        List<ActiveEffect> effectsToRemove = new List<ActiveEffect>();\n        \n        foreach (ActiveEffect effect in _activeEffects)\n        {\n            if (effect.data.duration > 0)\n            {\n                effect.remainingTime -= 0.1f;\n                \n                if (effect.remainingTime <= 0)\n                {\n                    effectsToRemove.Add(effect);\n                }\n                else\n                {\n                    UpdateEffectVisuals(effect);\n                }\n            }\n        }\n        \n        foreach (ActiveEffect effect in effectsToRemove)\n        {\n            StartCoroutine(RemoveEffectCoroutine(effect));\n        }\n    }\n\n    private void UpdateEffectVisuals(ActiveEffect effect)\n    {\n        if (effect.fillImage != null && effect.data.duration > 0)\n        {\n            float fillAmount = effect.remainingTime / effect.data.duration;\n            effect.fillImage.fillAmount = fillAmount;\n        }\n        \n        if (effect.durationText != null && _showDurationText)\n        {\n            if (effect.remainingTime > 60f)\n            {\n                effect.durationText.text = $\"{Mathf.CeilToInt(effect.remainingTime / 60f)}m\";\n            }\n            else if (effect.remainingTime > 0)\n            {\n                effect.durationText.text = Mathf.CeilToInt(effect.remainingTime).ToString();\n            }\n        }\n    }\n\n    private void UpdateIconLayout()\n    {\n        if (_separateBuffsDebuffs)\n        {\n            LayoutSeparatedIcons();\n        }\n        else\n        {\n            LayoutMixedIcons();\n        }\n    }\n\n    private void LayoutSeparatedIcons()\n    {\n        List<ActiveEffect> buffs = _activeEffects.FindAll(e => e.data.isBuff);\n        List<ActiveEffect> debuffs = _activeEffects.FindAll(e => !e.data.isBuff);\n        \n        float currentY = 0f;\n        \n        if (buffs.Count > 0)\n        {\n            LayoutEffectRow(buffs, ref currentY);\n            currentY -= _iconSize + _iconSpacing;\n        }\n        \n        if (debuffs.Count > 0)\n        {\n            LayoutEffectRow(debuffs, ref currentY);\n        }\n    }\n\n    private void LayoutMixedIcons()\n    {\n        float currentY = 0f;\n        LayoutEffectRow(_activeEffects, ref currentY);\n    }\n\n    private void LayoutEffectRow(List<ActiveEffect> effects, ref float currentY)\n    {\n        int iconsInRow = 0;\n        float currentX = 0f;\n        \n        for (int i = 0; i < effects.Count; i++)\n        {\n            if (iconsInRow >= _maxIconsPerRow)\n            {\n                iconsInRow = 0;\n                currentY -= _iconSize + _iconSpacing;\n                currentX = 0f;\n            }\n            \n            if (iconsInRow == 0)\n            {\n                int iconsThisRow = Mathf.Min(_maxIconsPerRow, effects.Count - i);\n                float totalWidth = iconsThisRow * _iconSize + (iconsThisRow - 1) * _iconSpacing;\n                currentX = -totalWidth * 0.5f + _iconSize * 0.5f;\n            }\n            \n            RectTransform iconRect = effects[i].iconObject.GetComponent<RectTransform>();\n            iconRect.anchoredPosition = new Vector2(currentX, currentY);\n            \n            currentX += _iconSize + _iconSpacing;\n            iconsInRow++;\n        }\n    }\n\n    private IEnumerator FadeInEffect(ActiveEffect effect)\n    {\n        CanvasGroup canvasGroup = effect.iconObject.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = effect.iconObject.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.alpha = 0f;\n        effect.iconObject.transform.localScale = Vector3.one * 0.8f;\n        \n        float elapsed = 0f;\n        while (elapsed < _fadeInDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeInDuration;\n            \n            canvasGroup.alpha = progress;\n            effect.iconObject.transform.localScale = Vector3.one * _scaleCurve.Evaluate(progress);\n            \n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        effect.iconObject.transform.localScale = Vector3.one;\n    }\n\n    private IEnumerator RemoveEffectCoroutine(ActiveEffect effect)\n    {\n        _activeEffects.Remove(effect);\n        _effectLookup.Remove(effect.data.name);"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WeaponUpgradePickup\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"upgradeType\",\n      \"type\": \"string\",\n      \"default\": \"damage\"\n    },\n    {\n      \"name\": \"upgradeAmount\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"bobHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"bobSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"pickupSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"pickupEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"idle_animation\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at rotation speed\"\n        },\n        {\n          \"action\": \"bob up and down smoothly at bob height and bob speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pickup_weapon_upgrade\",\n      \"trigger\": \"when player touches this pickup\",\n      \"actions\": [\n        {\n          \"action\": \"apply weapon upgrade of specified type and amount to player\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"spawn pickup visual effect at current position\"\n        },\n        {\n          \"action\": \"destroy this pickup object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attract_to_player\",\n      \"trigger\": \"when player is very close to pickup\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player position with increasing speed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponUpgradePickup : MonoBehaviour\n{\n    [Header(\"Upgrade Configuration\")]\n    [SerializeField] private UpgradeType _upgradeType = UpgradeType.Damage;\n    [SerializeField] private float _upgradeValue = 10f;\n    [SerializeField] private string _upgradeName = \"Damage Boost\";\n    [SerializeField] private string _upgradeDescription = \"Increases weapon damage\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Pickup Settings\")]\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private float _pickupCooldown = 0.5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Events\")]\n    public UnityEvent<WeaponUpgrade> OnUpgradePickedUp;\n    public UnityEvent OnPickupDestroyed;\n    \n    private Vector3 _startPosition;\n    private bool _canBePickedUp = true;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    public enum UpgradeType\n    {\n        Damage,\n        FireRate,\n        Range,\n        Accuracy,\n        AmmoCapacity,\n        ReloadSpeed,\n        CriticalChance,\n        Penetration\n    }\n    \n    [System.Serializable]\n    public class WeaponUpgrade\n    {\n        public UpgradeType type;\n        public float value;\n        public string name;\n        public string description;\n        \n        public WeaponUpgrade(UpgradeType upgradeType, float upgradeValue, string upgradeName, string upgradeDescription)\n        {\n            type = upgradeType;\n            value = upgradeValue;\n            name = upgradeName;\n            description = upgradeDescription;\n        }\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        ValidateUpgradeSettings();\n    }\n    \n    private void Update()\n    {\n        if (_canBePickedUp)\n        {\n            AnimatePickup();\n        }\n    }\n    \n    private void AnimatePickup()\n    {\n        // Rotate the pickup\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        // Bob up and down\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canBePickedUp) return;\n        \n        if (IsPlayer(other))\n        {\n            PickupUpgrade(other.gameObject);\n        }\n    }\n    \n    private bool IsPlayer(Collider other)\n    {\n        return other.CompareTag(\"Player\") && ((_playerLayer.value & (1 << other.gameObject.layer)) != 0);\n    }\n    \n    private void PickupUpgrade(GameObject player)\n    {\n        _canBePickedUp = false;\n        \n        WeaponUpgrade upgrade = new WeaponUpgrade(_upgradeType, _upgradeValue, _upgradeName, _upgradeDescription);\n        \n        // Apply upgrade to player's weapon\n        ApplyUpgradeToPlayer(player, upgrade);\n        \n        // Trigger events\n        OnUpgradePickedUp?.Invoke(upgrade);\n        \n        // Play effects\n        PlayPickupEffects();\n        \n        // Handle pickup completion\n        if (_destroyOnPickup)\n        {\n            Invoke(nameof(DestroyPickup), 0.1f);\n        }\n        else\n        {\n            StartCooldown();\n        }\n    }\n    \n    private void ApplyUpgradeToPlayer(GameObject player, WeaponUpgrade upgrade)\n    {\n        // Look for weapon components on player or children\n        WeaponStats weaponStats = player.GetComponentInChildren<WeaponStats>();\n        if (weaponStats == null)\n        {\n            weaponStats = player.GetComponent<WeaponStats>();\n        }\n        \n        if (weaponStats != null)\n        {\n            weaponStats.ApplyUpgrade(upgrade);\n        }\n        else\n        {\n            Debug.LogWarning($\"No WeaponStats component found on player {player.name}. Upgrade not applied.\");\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        // Play sound\n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn visual effect\n        if (_pickupEffect != null)\n        {\n            GameObject effect = Instantiate(_pickupEffect, transform.position, transform.rotation);\n            Destroy(effect, 3f);\n        }\n        \n        // Hide visual\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void StartCooldown()\n    {\n        Invoke(nameof(ResetPickup), _pickupCooldown);\n    }\n    \n    private void ResetPickup()\n    {\n        _canBePickedUp = true;\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void DestroyPickup()\n    {\n        OnPickupDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    private void ValidateUpgradeSettings()\n    {\n        if (string.IsNullOrEmpty(_upgradeName))\n        {\n            _upgradeName = _upgradeType.ToString() + \" Upgrade\";\n        }\n        \n        if (string.IsNullOrEmpty(_upgradeDescription))\n        {\n            _upgradeDescription = $\"Improves {_upgradeType.ToString().ToLower()}\";\n        }\n        \n        if (_upgradeValue <= 0)\n        {\n            _upgradeValue = 1f;\n        }\n    }\n    \n    public void SetUpgrade(UpgradeType type, float value, string name = \"\", string description = \"\")\n    {\n        _upgradeType = type;\n        _upgradeValue = value;\n        \n        if (!string.IsNullOrEmpty(name))\n            _upgradeName = name;\n        \n        if (!string.IsNullOrEmpty(description))\n            _upgradeDescription = description;\n        \n        ValidateUpgradeSettings();\n    }\n    \n    public WeaponUpgrade GetUpgradeInfo()\n    {\n        return new WeaponUpgrade(_upgradeType, _upgradeValue, _upgradeName, _upgradeDescription);\n    }\n}\n\n[System.Serializable]\npublic class WeaponStats : MonoBehaviour\n{\n    [Header(\"Base Stats\")]\n    [SerializeField] private float _baseDamage = 25f;\n    [SerializeField] private float _baseFireRate = 1f;\n    [SerializeField] private float _baseRange = 100f;\n    [SerializeField] private float _baseAccuracy = 0.95f;\n    [SerializeField] private int _baseAmmoCapacity = 30;\n    [SerializeField] private float _baseReloadSpeed = 2f;\n    [SerializeField] private float _baseCriticalChance = 0.1f;\n    [SerializeField] private int _basePenetration = 1;\n    \n    [Header(\"Current Stats\")]\n    public float currentDamage;\n    public float currentFireRate;\n    public float currentRange;\n    public float currentAccuracy;\n    public int currentAmmoCapacity;\n    public float currentReloadSpeed;\n    public float currentCriticalChance;\n    public int currentPenetration;\n    \n    [Header(\"Upgrade Multipliers\")]\n    [SerializeField] private float _damageMultiplier = 1.1f;\n    [SerializeField] private float _fireRateMultiplier = 1.15f;\n    [SerializeField] private float _rangeMultiplier = 1.2f;\n    [SerializeField] private float _accuracyMultiplier = 1.05f;\n    [SerializeField] private float _ammoMultiplier = 1.25f;\n    [SerializeField] private float _reloadSpeedMultiplier = 0.9f;\n    [SerializeField] private float _criticalChanceMultiplier = 1.1f;\n    [SerializeField] private int _penetrationBonus = 1;\n    \n    private void Start()\n    {\n        InitializeStats();\n    }\n    \n    private void InitializeStats()\n    {\n        currentDamage = _baseDamage;\n        currentFireRate = _baseFireRate;\n        currentRange = _baseRange;\n        currentAccuracy = _baseAccuracy;\n        currentAmmoCapacity = _baseAmmoCapacity;\n        currentReloadSpeed = _baseReloadSpeed;\n        currentCriticalChance = _baseCriticalChance;\n        currentPenetration = _basePenetration;\n    }\n    \n    public void ApplyUpgrade(WeaponUpgradePickup.WeaponUpgrade upgrade)\n    {\n        switch (upgrade.type)\n        {\n            case WeaponUpgradePickup.UpgradeType.Damage:\n                currentDamage += upgrade.value;\n                break;\n            case WeaponUpgradePickup.UpgradeType.FireRate:\n                currentFireRate *= _fireRateMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.Range:\n                currentRange *= _rangeMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.Accuracy:\n                currentAccuracy = Mathf.Min(1f, currentAccuracy * _accuracyMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.AmmoCapacity:\n                currentAmmoCapacity = Mathf.RoundToInt(currentAmmoCapacity * _ammoMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.ReloadSpeed:\n                currentReloadSpeed *= _reloadSpeedMultiplier;\n                break;\n            case WeaponUpgradePickup.UpgradeType.CriticalChance:\n                currentCriticalChance = Mathf.Min(1f, currentCriticalChance * _criticalChanceMultiplier);\n                break;\n            case WeaponUpgradePickup.UpgradeType.Penetration:\n                currentPenetration += _penetrationBonus;\n                break;\n        }\n        \n        Debug.Log($\"Applied {upgrade.name}: {upgrade.description}\");\n    }\n    \n    public void ResetToBaseStats()\n    {\n        InitializeStats();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RageModeTransformation\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rageThreshold\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"transformationDuration\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"rageDamageMultiplier\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"rageSpeedMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isInRageMode\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"originalScale\",\n      \"type\": \"Vector3\",\n      \"default\": \"1,1,1\"\n    },\n    {\n      \"name\": \"rageScale\",\n      \"type\": \"Vector3\",\n      \"default\": \"1.3,1.3,1.3\"\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"Color\",\n      \"default\": \"white\"\n    },\n    {\n      \"name\": \"rageColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_rage_transformation\",\n      \"trigger\": \"when current health drops below rage threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set rage mode to active\"\n        },\n        {\n          \"action\": \"play transformation sound effect\"\n        },\n        {\n          \"action\": \"start particle effect for transformation\"\n        },\n        {\n          \"action\": \"begin scaling up to rage size over transformation duration\"\n        },\n        {\n          \"action\": \"gradually change color from original to rage color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_rage_effects\",\n      \"trigger\": \"while in rage mode\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage multiplier to all attacks\"\n        },\n        {\n          \"action\": \"apply speed multiplier to movement\"\n        },\n        {\n          \"action\": \"emit continuous rage particles\"\n        },\n        {\n          \"action\": \"play looping rage audio\"\n        },\n        {\n          \"action\": \"pulse red glow effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_rage_mode\",\n      \"trigger\": \"when health is restored above rage threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set rage mode to inactive\"\n        },\n        {\n          \"action\": \"stop rage particle effects\"\n        },\n        {\n          \"action\": \"stop rage audio loop\"\n        },\n        {\n          \"action\": \"gradually scale back to original size\"\n        },\n        {\n          \"action\": \"fade color back to original over time\"\n        },\n        {\n          \"action\": \"reset damage multiplier to normal\"\n        },\n        {\n          \"action\": \"reset speed multiplier to normal\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RageModeTransformation : MonoBehaviour\n{\n    [Header(\"Rage Mode Settings\")]\n    [SerializeField] private float _rageDuration = 10f;\n    [SerializeField] private float _rageActivationThreshold = 0.3f;\n    [SerializeField] private bool _autoActivateOnLowHealth = true;\n    [SerializeField] private KeyCode _manualActivationKey = KeyCode.R;\n    \n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth = 100f;\n    \n    [Header(\"Transformation Effects\")]\n    [SerializeField] private float _damageMultiplier = 2f;\n    [SerializeField] private float _speedMultiplier = 1.5f;\n    [SerializeField] private float _sizeMultiplier = 1.2f;\n    [SerializeField] private Color _rageColor = Color.red;\n    [SerializeField] private float _colorIntensity = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _rageParticles;\n    [SerializeField] private GameObject _rageAura;\n    [SerializeField] private Light _rageLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _transformationSound;\n    [SerializeField] private AudioClip _rageLoopSound;\n    \n    [Header(\"Screen Effects\")]\n    [SerializeField] private bool _enableScreenShake = true;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRageModeActivated;\n    public UnityEvent OnRageModeDeactivated;\n    public UnityEvent<float> OnHealthChanged;\n    \n    private bool _isInRageMode = false;\n    private float _rageTimer = 0f;\n    private Vector3 _originalScale;\n    private Color _originalColor;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Material _rageMaterial;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private Coroutine _shakeCoroutine;\n    \n    // Cached components\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    // Original values for restoration\n    private float _originalMass;\n    private float _originalDrag;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupMaterials();\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _mainCamera = Camera.main;\n        \n        _originalScale = transform.localScale;\n        \n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _originalMass = _rigidbody.mass;\n            _originalDrag = _rigidbody.drag;\n        }\n        \n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n    }\n    \n    private void SetupMaterials()\n    {\n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _rageMaterial = new Material(_originalMaterial);\n            _rageMaterial.color = _rageColor;\n            _rageMaterial.EnableKeyword(\"_EMISSION\");\n            _rageMaterial.SetColor(\"_EmissionColor\", _rageColor * _colorIntensity);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateRageMode();\n        CheckAutoActivation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_manualActivationKey) && !_isInRageMode)\n        {\n            ActivateRageMode();\n        }\n    }\n    \n    private void UpdateRageMode()\n    {\n        if (_isInRageMode)\n        {\n            _rageTimer -= Time.deltaTime;\n            \n            if (_rageTimer <= 0f)\n            {\n                DeactivateRageMode();\n            }\n        }\n    }\n    \n    private void CheckAutoActivation()\n    {\n        if (_autoActivateOnLowHealth && !_isInRageMode)\n        {\n            float healthPercentage = _currentHealth / _maxHealth;\n            if (healthPercentage <= _rageActivationThreshold)\n            {\n                ActivateRageMode();\n            }\n        }\n    }\n    \n    public void ActivateRageMode()\n    {\n        if (_isInRageMode) return;\n        \n        _isInRageMode = true;\n        _rageTimer = _rageDuration;\n        \n        ApplyTransformationEffects();\n        PlayTransformationEffects();\n        \n        OnRageModeActivated?.Invoke();\n    }\n    \n    public void DeactivateRageMode()\n    {\n        if (!_isInRageMode) return;\n        \n        _isInRageMode = false;\n        _rageTimer = 0f;\n        \n        RemoveTransformationEffects();\n        StopTransformationEffects();\n        \n        OnRageModeDeactivated?.Invoke();\n    }\n    \n    private void ApplyTransformationEffects()\n    {\n        // Scale transformation\n        transform.localScale = _originalScale * _sizeMultiplier;\n        \n        // Material transformation\n        if (_renderer != null && _rageMaterial != null)\n        {\n            _renderer.material = _rageMaterial;\n        }\n        \n        // Physics modifications\n        if (_rigidbody != null)\n        {\n            _rigidbody.mass = _originalMass * _damageMultiplier;\n            _rigidbody.drag = _originalDrag * 0.5f;\n        }\n        \n        // Light effects\n        if (_rageLight != null)\n        {\n            _rageLight.enabled = true;\n            _rageLight.color = _rageColor;\n            _rageLight.intensity = _colorIntensity;\n        }\n    }\n    \n    private void RemoveTransformationEffects()\n    {\n        // Restore scale\n        transform.localScale = _originalScale;\n        \n        // Restore material\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _renderer.material = _originalMaterial;\n        }\n        \n        // Restore physics\n        if (_rigidbody != null)\n        {\n            _rigidbody.mass = _originalMass;\n            _rigidbody.drag = _originalDrag;\n        }\n        \n        // Disable light\n        if (_rageLight != null)\n        {\n            _rageLight.enabled = false;\n        }\n    }\n    \n    private void PlayTransformationEffects()\n    {\n        // Particle effects\n        if (_rageParticles != null)\n        {\n            _rageParticles.Play();\n        }\n        \n        // Aura effects\n        if (_rageAura != null)\n        {\n            _rageAura.SetActive(true);\n        }\n        \n        // Sound effects\n        if (_audioSource != null)\n        {\n            if (_transformationSound != null)\n            {\n                _audioSource.PlayOneShot(_transformationSound);\n            }\n            \n            if (_rageLoopSound != null)\n            {\n                _audioSource.clip = _rageLoopSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        \n        // Screen shake\n        if (_enableScreenShake && _mainCamera != null)\n        {\n            if (_shakeCoroutine != null)\n            {\n                StopCoroutine(_shakeCoroutine);\n            }\n            _shakeCoroutine = StartCoroutine(ScreenShake());\n        }\n    }\n    \n    private void StopTransformationEffects()\n    {\n        // Stop particles\n        if (_rageParticles != null)\n        {\n            _rageParticles.Stop();\n        }\n        \n        // Disable aura\n        if (_rageAura != null)\n        {\n            _rageAura.SetActive(false);\n        }\n        \n        // Stop sounds\n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n        }\n        \n        // Stop screen shake\n        if (_shakeCoroutine != null)\n        {\n            StopCoroutine(_shakeCoroutine);\n            _shakeCoroutine = null;\n            \n            if (_mainCamera != null)\n            {\n                _mainCamera.transform.localPosition = _originalCameraPosition;\n            }\n        }\n    }\n    \n    private IEnumerator ScreenShake()\n    {\n        float elapsed = 0f;\n        \n        while (elapsed < _shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _shakeIntensity;\n            float y = Random.Range(-1f, 1f) * _shakeIntensity;\n            \n            _mainCamera.transform.localPosition = _originalCameraPosition + new Vector3(x, y, 0f);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.localPosition = _originalCameraPosition;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    public void Heal(float healAmount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n    \n    public float GetDamageMultiplier()\n    {\n        return _isInRageMode ? _damageMultiplier : 1f;\n    }\n    \n    public float GetSpeedMultiplier()\n    {\n        return _isInRageMode ? _speedMultiplier : 1f;\n    }\n    \n    public bool IsInRageMode()\n    {\n        return _isInRageMode;\n    }\n    \n    public float GetRageTimeRemaining()\n    {\n        return _rageTimer;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_rageMaterial != null)\n        {\n            DestroyImmediate(_rageMaterial);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInRageMode && other.CompareTag(\"Enemy\"))\n        {\n            // Apply rage damage to enemies\n            var enemyHealth = other.GetComponent<RageModeTransformation>();\n            if (enemyHealth != null)\n            {\n                enemyHealth.TakeDamage(10f * _damageMultiplier);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GravityField\",\n  \"components\": [\n    \"SphereCollider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fieldRadius\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"transitionDuration\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"spaceWarpSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"distortionEffect\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_object_entry\",\n      \"trigger\": \"when rigidbody object enters the gravity field trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"play space warp sound effect\"\n        },\n        {\n          \"action\": \"activate visual distortion particle effect\"\n        },\n        {\n          \"action\": \"begin smooth gravity inversion transition for the entering object over one second duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_object_exit\",\n      \"trigger\": \"when rigidbody object exits the gravity field trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"begin smooth gravity restoration transition for the exiting object over one second duration\"\n        },\n        {\n          \"action\": \"deactivate visual distortion effect for that object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_inverted_gravity\",\n      \"trigger\": \"while rigidbody object remains within the gravity field\",\n      \"actions\": [\n        {\n          \"action\": \"apply inverted gravity force to the object\"\n        },\n        {\n          \"action\": \"maintain visual distortion effect around the object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_transition_progress\",\n      \"trigger\": \"during gravity transition period for any object\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly interpolate gravity direction from normal to inverted or vice versa\"\n        },\n        {\n          \"action\": \"update visual effect intensity based on transition progress\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class GravityField : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _fieldRadius = 5f;\n    [SerializeField] private float _transitionDuration = 1f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _spaceWarpSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _distortionMaterial;\n    [SerializeField] private float _distortionStrength = 0.1f;\n    [SerializeField] private float _distortionSpeed = 2f;\n    [SerializeField] private Color _fieldColor = Color.cyan;\n    [SerializeField] private float _fieldAlpha = 0.3f;\n    \n    private AudioSource _audioSource;\n    private SphereCollider _triggerCollider;\n    private Dictionary<Rigidbody, GravityTransition> _affectedObjects = new Dictionary<Rigidbody, GravityTransition>();\n    private MeshRenderer _fieldRenderer;\n    private Material _fieldMaterial;\n    private float _distortionTime;\n    \n    [System.Serializable]\n    private class GravityTransition\n    {\n        public Rigidbody rigidbody;\n        public bool isInField;\n        public float transitionProgress;\n        public Vector3 originalGravity;\n        public Vector3 targetGravity;\n        public Coroutine transitionCoroutine;\n        \n        public GravityTransition(Rigidbody rb)\n        {\n            rigidbody = rb;\n            isInField = false;\n            transitionProgress = 0f;\n            originalGravity = Physics.gravity;\n            targetGravity = -Physics.gravity;\n        }\n    }\n    \n    void Start()\n    {\n        SetupAudioSource();\n        SetupTriggerCollider();\n        SetupVisualField();\n    }\n    \n    void Update()\n    {\n        UpdateDistortionEffect();\n        UpdateGravityTransitions();\n    }\n    \n    void SetupAudioSource()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _spaceWarpSound;\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n        _audioSource.rolloffMode = AudioRolloffMode.Linear;\n        _audioSource.maxDistance = _fieldRadius * 2f;\n    }\n    \n    void SetupTriggerCollider()\n    {\n        _triggerCollider = GetComponent<SphereCollider>();\n        if (_triggerCollider == null)\n        {\n            _triggerCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _triggerCollider.isTrigger = true;\n        _triggerCollider.radius = _fieldRadius;\n    }\n    \n    void SetupVisualField()\n    {\n        GameObject fieldSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        DestroyImmediate(fieldSphere.GetComponent<SphereCollider>());\n        \n        fieldSphere.transform.SetParent(transform);\n        fieldSphere.transform.localPosition = Vector3.zero;\n        fieldSphere.transform.localScale = Vector3.one * (_fieldRadius * 2f);\n        \n        _fieldRenderer = fieldSphere.GetComponent<MeshRenderer>();\n        \n        if (_distortionMaterial != null)\n        {\n            _fieldMaterial = new Material(_distortionMaterial);\n        }\n        else\n        {\n            _fieldMaterial = new Material(Shader.Find(\"Standard\"));\n            _fieldMaterial.SetFloat(\"_Mode\", 3);\n            _fieldMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            _fieldMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            _fieldMaterial.SetInt(\"_ZWrite\", 0);\n            _fieldMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            _fieldMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            _fieldMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            _fieldMaterial.renderQueue = 3000;\n        }\n        \n        Color fieldColor = _fieldColor;\n        fieldColor.a = _fieldAlpha;\n        _fieldMaterial.color = fieldColor;\n        _fieldRenderer.material = _fieldMaterial;\n    }\n    \n    void UpdateDistortionEffect()\n    {\n        if (_fieldMaterial == null) return;\n        \n        _distortionTime += Time.deltaTime * _distortionSpeed;\n        \n        float distortion = Mathf.Sin(_distortionTime) * _distortionStrength;\n        Vector2 offset = new Vector2(distortion, distortion * 0.5f);\n        \n        if (_fieldMaterial.HasProperty(\"_MainTex\"))\n        {\n            _fieldMaterial.SetTextureOffset(\"_MainTex\", offset);\n        }\n        \n        float pulse = (Mathf.Sin(_distortionTime * 2f) + 1f) * 0.5f;\n        Color currentColor = _fieldColor;\n        currentColor.a = _fieldAlpha * (0.7f + pulse * 0.3f);\n        _fieldMaterial.color = currentColor;\n    }\n    \n    void UpdateGravityTransitions()\n    {\n        List<Rigidbody> toRemove = new List<Rigidbody>();\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            var transition = kvp.Value;\n            if (transition.rigidbody == null)\n            {\n                toRemove.Add(kvp.Key);\n                continue;\n            }\n            \n            if (transition.transitionCoroutine == null && transition.transitionProgress < 1f)\n            {\n                Vector3 currentGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, transition.transitionProgress);\n                ApplyGravityToRigidbody(transition.rigidbody, currentGravity);\n            }\n        }\n        \n        foreach (var rb in toRemove)\n        {\n            _affectedObjects.Remove(rb);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (!IsValidTarget(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        if (!_affectedObjects.ContainsKey(rb))\n        {\n            _affectedObjects[rb] = new GravityTransition(rb);\n        }\n        \n        var transition = _affectedObjects[rb];\n        if (!transition.isInField)\n        {\n            transition.isInField = true;\n            transition.targetGravity = -Physics.gravity;\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n            \n            transition.transitionCoroutine = StartCoroutine(TransitionGravity(transition, true));\n            PlaySpaceWarpSound();\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (!IsValidTarget(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null || !_affectedObjects.ContainsKey(rb)) return;\n        \n        var transition = _affectedObjects[rb];\n        if (transition.isInField)\n        {\n            transition.isInField = false;\n            transition.targetGravity = Physics.gravity;\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n            \n            transition.transitionCoroutine = StartCoroutine(TransitionGravity(transition, false));\n        }\n    }\n    \n    bool IsValidTarget(Collider other)\n    {\n        return (_affectedLayers.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    IEnumerator TransitionGravity(GravityTransition transition, bool enteringField)\n    {\n        float startProgress = transition.transitionProgress;\n        float targetProgress = enteringField ? 1f : 0f;\n        float elapsedTime = 0f;\n        \n        Vector3 startGravity = Vector3.Lerp(transition.originalGravity, -transition.originalGravity, startProgress);\n        \n        while (elapsedTime < _transitionDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / _transitionDuration;\n            float smoothProgress = Mathf.SmoothStep(startProgress, targetProgress, normalizedTime);\n            \n            transition.transitionProgress = smoothProgress;\n            \n            Vector3 currentGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, smoothProgress);\n            ApplyGravityToRigidbody(transition.rigidbody, currentGravity);\n            \n            yield return null;\n        }\n        \n        transition.transitionProgress = targetProgress;\n        Vector3 finalGravity = Vector3.Lerp(transition.originalGravity, transition.targetGravity, targetProgress);\n        ApplyGravityToRigidbody(transition.rigidbody, finalGravity);\n        \n        transition.transitionCoroutine = null;\n        \n        if (!enteringField && targetProgress <= 0f)\n        {\n            _affectedObjects.Remove(transition.rigidbody);\n        }\n    }\n    \n    void ApplyGravityToRigidbody(Rigidbody rb, Vector3 gravity)\n    {\n        if (rb == null) return;\n        \n        rb.useGravity = false;\n        rb.AddForce(gravity * rb.mass, ForceMode.Force);\n    }\n    \n    void PlaySpaceWarpSound()\n    {\n        if (_audioSource != null && _spaceWarpSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_spaceWarpSound, _audioVolume);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _fieldColor;\n        Gizmos.DrawWireSphere(transform.position, _fieldRadius);\n        \n        Gizmos.color = new Color(_fieldColor.r, _fieldColor.g, _fieldColor.b, 0.1f);\n        Gizmos.DrawSphere(transform.position, _fieldRadius);\n    }\n    \n    void OnDestroy()\n    {\n        foreach (var kvp in _affectedObjects)\n        {\n            var transition = kvp.Value;\n            if (transition.rigidbody != null)\n            {\n                transition.rigidbody.useGravity = true;\n            }\n            \n            if (transition.transitionCoroutine != null)\n            {\n                StopCoroutine(transition.transitionCoroutine);\n            }\n        }\n        \n        _affectedObjects.Clear();\n        \n        if (_fieldMaterial != null)\n        {\n            DestroyImmediate(_fieldMaterial);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TreasureChest\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isLocked\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"requiredKeyType\",\n      \"type\": \"string\",\n      \"default\": \"golden_key\"\n    },\n    {\n      \"name\": \"treasureContents\",\n      \"type\": \"GameObject[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"openSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lockedSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attempt_open\",\n      \"trigger\": \"when player interacts with chest\",\n      \"actions\": [\n        {\n          \"action\": \"check if player has required key in inventory\"\n        },\n        {\n          \"action\": \"if player has key then unlock and open chest\"\n        },\n        {\n          \"action\": \"if player lacks key then play locked sound and show locked message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"open_chest\",\n      \"trigger\": \"when chest becomes unlocked\",\n      \"actions\": [\n        {\n          \"action\": \"play opening animation\"\n        },\n        {\n          \"action\": \"play chest opening sound\"\n        },\n        {\n          \"action\": \"spawn treasure contents inside chest\"\n        },\n        {\n          \"action\": \"remove required key from player inventory\"\n        },\n        {\n          \"action\": \"set chest state to open\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_interaction_prompt\",\n      \"trigger\": \"when player is near chest and looking at it\",\n      \"actions\": [\n        {\n          \"action\": \"display interaction prompt based on chest state\"\n        },\n        {\n          \"action\": \"show key requirement if chest is locked\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class TreasureChest : MonoBehaviour\n{\n    [Header(\"Chest Settings\")]\n    [SerializeField] private string requiredKeyTag = \"Key\";\n    [SerializeField] private float interactionRange = 2f;\n    [SerializeField] private KeyCode interactionKey = KeyCode.E;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator chestAnimator;\n    [SerializeField] private string openAnimationTrigger = \"Open\";\n    [SerializeField] private AudioClip openSound;\n    [SerializeField] private AudioClip lockedSound;\n    \n    [Header(\"Treasure Contents\")]\n    [SerializeField] private GameObject[] treasureItems;\n    [SerializeField] private Transform spawnPoint;\n    [SerializeField] private float spawnForce = 5f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject interactionPrompt;\n    [SerializeField] private GameObject lockedPrompt;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnChestOpened;\n    public UnityEvent OnChestLocked;\n    \n    private bool _isOpened = false;\n    private bool _playerInRange = false;\n    private GameObject _playerObject;\n    private AudioSource _audioSource;\n    private PlayerInventory _playerInventory;\n    \n    [System.Serializable]\n    private class PlayerInventory\n    {\n        private bool _hasKey = false;\n        \n        public bool HasKey => _hasKey;\n        \n        public void AddKey()\n        {\n            _hasKey = true;\n        }\n        \n        public bool UseKey()\n        {\n            if (_hasKey)\n            {\n                _hasKey = false;\n                return true;\n            }\n            return false;\n        }\n    }\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (interactionPrompt != null)\n            interactionPrompt.SetActive(false);\n            \n        if (lockedPrompt != null)\n            lockedPrompt.SetActive(false);\n            \n        if (spawnPoint == null)\n            spawnPoint = transform;\n    }\n    \n    private void Update()\n    {\n        if (_playerInRange && !_isOpened && Input.GetKeyDown(interactionKey))\n        {\n            TryOpenChest();\n        }\n        \n        UpdateUI();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = true;\n            _playerObject = other.gameObject;\n            \n            _playerInventory = other.GetComponent<PlayerInventory>();\n            if (_playerInventory == null)\n            {\n                _playerInventory = other.gameObject.AddComponent<PlayerInventory>();\n            }\n        }\n        else if (other.CompareTag(requiredKeyTag))\n        {\n            CollectKey(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = false;\n            _playerObject = null;\n            _playerInventory = null;\n            \n            if (interactionPrompt != null)\n                interactionPrompt.SetActive(false);\n                \n            if (lockedPrompt != null)\n                lockedPrompt.SetActive(false);\n        }\n    }\n    \n    private void CollectKey(GameObject keyObject)\n    {\n        if (_playerInventory != null)\n        {\n            _playerInventory.AddKey();\n            Destroy(keyObject);\n        }\n    }\n    \n    private void TryOpenChest()\n    {\n        if (_playerInventory != null && _playerInventory.HasKey)\n        {\n            if (_playerInventory.UseKey())\n            {\n                OpenChest();\n            }\n        }\n        else\n        {\n            PlayLockedSound();\n            OnChestLocked?.Invoke();\n        }\n    }\n    \n    private void OpenChest()\n    {\n        _isOpened = true;\n        \n        if (chestAnimator != null)\n            chestAnimator.SetTrigger(openAnimationTrigger);\n            \n        PlayOpenSound();\n        SpawnTreasure();\n        OnChestOpened?.Invoke();\n    }\n    \n    private void SpawnTreasure()\n    {\n        if (treasureItems == null || treasureItems.Length == 0)\n            return;\n            \n        foreach (GameObject treasureItem in treasureItems)\n        {\n            if (treasureItem != null)\n            {\n                Vector3 spawnPosition = spawnPoint.position + Random.insideUnitSphere * 0.5f;\n                GameObject spawnedItem = Instantiate(treasureItem, spawnPosition, Random.rotation);\n                \n                Rigidbody rb = spawnedItem.GetComponent<Rigidbody>();\n                if (rb == null)\n                    rb = spawnedItem.AddComponent<Rigidbody>();\n                    \n                Vector3 randomDirection = Random.insideUnitSphere;\n                randomDirection.y = Mathf.Abs(randomDirection.y);\n                rb.AddForce(randomDirection * spawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (!_playerInRange || _isOpened)\n        {\n            if (interactionPrompt != null)\n                interactionPrompt.SetActive(false);\n            if (lockedPrompt != null)\n                lockedPrompt.SetActive(false);\n            return;\n        }\n        \n        bool hasKey = _playerInventory != null && _playerInventory.HasKey;\n        \n        if (interactionPrompt != null)\n            interactionPrompt.SetActive(hasKey);\n            \n        if (lockedPrompt != null)\n            lockedPrompt.SetActive(!hasKey);\n    }\n    \n    private void PlayOpenSound()\n    {\n        if (openSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(openSound);\n        }\n    }\n    \n    private void PlayLockedSound()\n    {\n        if (lockedSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(lockedSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, interactionRange);\n        \n        if (spawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(spawnPoint.position, Vector3.one * 0.2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LeaderboardSubmission\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"playerName\",\n      \"type\": \"string\",\n      \"default\": \"Player\"\n    },\n    {\n      \"name\": \"currentScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"leaderboardURL\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"maxRetries\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"submissionTimeout\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isSubmitting\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"submit_score\",\n      \"trigger\": \"when submit score method is called\",\n      \"actions\": [\n        {\n          \"action\": \"validate that score is greater than zero\"\n        },\n        {\n          \"action\": \"validate that player name is not empty\"\n        },\n        {\n          \"action\": \"set submission status to active\"\n        },\n        {\n          \"action\": \"send score data to leaderboard server\"\n        },\n        {\n          \"action\": \"start timeout timer for submission\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_successful_submission\",\n      \"trigger\": \"when server responds with success confirmation\",\n      \"actions\": [\n        {\n          \"action\": \"set submission status to inactive\"\n        },\n        {\n          \"action\": \"display success message to player\"\n        },\n        {\n          \"action\": \"clear timeout timer\"\n        },\n        {\n          \"action\": \"trigger score submitted event\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_failed_submission\",\n      \"trigger\": \"when server responds with error or timeout occurs\",\n      \"actions\": [\n        {\n          \"action\": \"decrease retry counter\"\n        },\n        {\n          \"action\": \"check if retries remain available\"\n        },\n        {\n          \"action\": \"retry submission if attempts remain\"\n        },\n        {\n          \"action\": \"display error message if no retries left\"\n        },\n        {\n          \"action\": \"set submission status to inactive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"validate_connection\",\n      \"trigger\": \"before attempting score submission\",\n      \"actions\": [\n        {\n          \"action\": \"check internet connectivity status\"\n        },\n        {\n          \"action\": \"verify leaderboard server availability\"\n        },\n        {\n          \"action\": \"show connection error if offline\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\nusing TMPro;\n\npublic class LeaderboardManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class LeaderboardEntry\n    {\n        public string playerName;\n        public int score;\n        public string date;\n        \n        public LeaderboardEntry(string name, int playerScore)\n        {\n            playerName = name;\n            score = playerScore;\n            date = System.DateTime.Now.ToString(\"MM/dd/yyyy\");\n        }\n    }\n    \n    [System.Serializable]\n    public class ScoreSubmissionEvent : UnityEvent<string, int> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _leaderboardPanel;\n    [SerializeField] private GameObject _scoreSubmissionPanel;\n    [SerializeField] private TMP_InputField _playerNameInput;\n    [SerializeField] private Button _submitButton;\n    [SerializeField] private Button _cancelButton;\n    [SerializeField] private Transform _leaderboardContent;\n    [SerializeField] private GameObject _leaderboardEntryPrefab;\n    [SerializeField] private TextMeshProUGUI _currentScoreText;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private int _maxLeaderboardEntries = 10;\n    [SerializeField] private string _defaultPlayerName = \"Anonymous\";\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _leaderboardKey = \"Leaderboard\";\n    \n    [Header(\"Events\")]\n    public ScoreSubmissionEvent OnScoreSubmitted;\n    public UnityEvent OnLeaderboardUpdated;\n    \n    private List<LeaderboardEntry> _leaderboardEntries = new List<LeaderboardEntry>();\n    private int _currentScore = 0;\n    private bool _isSubmissionActive = false;\n    \n    private void Start()\n    {\n        InitializeUI();\n        LoadLeaderboard();\n        UpdateLeaderboardDisplay();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_submitButton != null)\n            _submitButton.onClick.AddListener(SubmitScore);\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.AddListener(CancelSubmission);\n            \n        if (_playerNameInput != null)\n        {\n            _playerNameInput.text = _defaultPlayerName;\n            _playerNameInput.onEndEdit.AddListener(OnNameInputChanged);\n        }\n        \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(false);\n            \n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(false);\n    }\n    \n    public void ShowScoreSubmission(int score)\n    {\n        if (_isSubmissionActive) return;\n        \n        _currentScore = score;\n        _isSubmissionActive = true;\n        \n        if (_currentScoreText != null)\n            _currentScoreText.text = \"Score: \" + score.ToString();\n            \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(true);\n            \n        if (_playerNameInput != null)\n        {\n            _playerNameInput.text = GetLastUsedPlayerName();\n            _playerNameInput.Select();\n            _playerNameInput.ActivateInputField();\n        }\n        \n        UpdateSubmitButtonState();\n    }\n    \n    public void ShowLeaderboard()\n    {\n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(true);\n            \n        UpdateLeaderboardDisplay();\n    }\n    \n    public void HideLeaderboard()\n    {\n        if (_leaderboardPanel != null)\n            _leaderboardPanel.SetActive(false);\n    }\n    \n    private void SubmitScore()\n    {\n        if (!_isSubmissionActive || _playerNameInput == null) return;\n        \n        string playerName = _playerNameInput.text.Trim();\n        if (string.IsNullOrEmpty(playerName))\n            playerName = _defaultPlayerName;\n            \n        AddScoreToLeaderboard(playerName, _currentScore);\n        SaveLastUsedPlayerName(playerName);\n        \n        OnScoreSubmitted?.Invoke(playerName, _currentScore);\n        \n        CancelSubmission();\n        ShowLeaderboard();\n    }\n    \n    private void CancelSubmission()\n    {\n        _isSubmissionActive = false;\n        _currentScore = 0;\n        \n        if (_scoreSubmissionPanel != null)\n            _scoreSubmissionPanel.SetActive(false);\n    }\n    \n    private void OnNameInputChanged(string newName)\n    {\n        UpdateSubmitButtonState();\n    }\n    \n    private void UpdateSubmitButtonState()\n    {\n        if (_submitButton == null || _playerNameInput == null) return;\n        \n        bool canSubmit = !string.IsNullOrEmpty(_playerNameInput.text.Trim()) || \n                        !string.IsNullOrEmpty(_defaultPlayerName);\n        _submitButton.interactable = canSubmit;\n    }\n    \n    public void AddScoreToLeaderboard(string playerName, int score)\n    {\n        LeaderboardEntry newEntry = new LeaderboardEntry(playerName, score);\n        _leaderboardEntries.Add(newEntry);\n        \n        _leaderboardEntries = _leaderboardEntries\n            .OrderByDescending(entry => entry.score)\n            .Take(_maxLeaderboardEntries)\n            .ToList();\n            \n        SaveLeaderboard();\n        UpdateLeaderboardDisplay();\n        OnLeaderboardUpdated?.Invoke();\n    }\n    \n    public bool IsHighScore(int score)\n    {\n        if (_leaderboardEntries.Count < _maxLeaderboardEntries)\n            return true;\n            \n        return score > _leaderboardEntries.Last().score;\n    }\n    \n    public int GetHighScore()\n    {\n        if (_leaderboardEntries.Count == 0) return 0;\n        return _leaderboardEntries.First().score;\n    }\n    \n    public List<LeaderboardEntry> GetTopScores(int count = -1)\n    {\n        if (count == -1) count = _maxLeaderboardEntries;\n        return _leaderboardEntries.Take(count).ToList();\n    }\n    \n    private void UpdateLeaderboardDisplay()\n    {\n        if (_leaderboardContent == null || _leaderboardEntryPrefab == null) return;\n        \n        foreach (Transform child in _leaderboardContent)\n        {\n            if (child.gameObject != _leaderboardEntryPrefab)\n                DestroyImmediate(child.gameObject);\n        }\n        \n        for (int i = 0; i < _leaderboardEntries.Count; i++)\n        {\n            GameObject entryObj = Instantiate(_leaderboardEntryPrefab, _leaderboardContent);\n            entryObj.SetActive(true);\n            \n            LeaderboardEntryDisplay display = entryObj.GetComponent<LeaderboardEntryDisplay>();\n            if (display == null)\n                display = entryObj.AddComponent<LeaderboardEntryDisplay>();\n                \n            display.SetupEntry(i + 1, _leaderboardEntries[i]);\n        }\n    }\n    \n    private void SaveLeaderboard()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        string jsonData = JsonUtility.ToJson(new SerializableLeaderboard(_leaderboardEntries));\n        PlayerPrefs.SetString(_leaderboardKey, jsonData);\n        PlayerPrefs.Save();\n    }\n    \n    private void LoadLeaderboard()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        if (PlayerPrefs.HasKey(_leaderboardKey))\n        {\n            string jsonData = PlayerPrefs.GetString(_leaderboardKey);\n            try\n            {\n                SerializableLeaderboard loadedData = JsonUtility.FromJson<SerializableLeaderboard>(jsonData);\n                _leaderboardEntries = loadedData.entries ?? new List<LeaderboardEntry>();\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning(\"Failed to load leaderboard: \" + e.Message);\n                _leaderboardEntries = new List<LeaderboardEntry>();\n            }\n        }\n    }\n    \n    private void SaveLastUsedPlayerName(string playerName)\n    {\n        PlayerPrefs.SetString(\"LastPlayerName\", playerName);\n    }\n    \n    private string GetLastUsedPlayerName()\n    {\n        return PlayerPrefs.GetString(\"LastPlayerName\", _defaultPlayerName);\n    }\n    \n    public void ClearLeaderboard()\n    {\n        _leaderboardEntries.Clear();\n        SaveLeaderboard();\n        UpdateLeaderboardDisplay();\n        OnLeaderboardUpdated?.Invoke();\n    }\n    \n    [System.Serializable]\n    private class SerializableLeaderboard\n    {\n        public List<LeaderboardEntry> entries;\n        \n        public SerializableLeaderboard(List<LeaderboardEntry> leaderboardEntries)\n        {\n            entries = leaderboardEntries;\n        }\n    }\n}\n\npublic class LeaderboardEntryDisplay : MonoBehaviour\n{\n    [Header(\"UI Components\")]\n    [SerializeField] private TextMeshProUGUI _rankText;\n    [SerializeField] private TextMeshProUGUI _nameText;\n    [SerializeField] private TextMeshProUGUI _scoreText;\n    [SerializeField] private TextMeshProUGUI _dateText;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Styling\")]\n    [SerializeField] private Color _topRankColor = Color.yellow;\n    [SerializeField] private Color _normalColor = Color.white;\n    \n    public void SetupEntry(int rank, LeaderboardManager.LeaderboardEntry entry)\n    {\n        if (_rankText != null)\n            _rankText.text = rank.ToString();\n            \n        if (_nameText != null)\n            _nameText.text = entry.playerName;\n            \n        if (_scoreText != null)\n            _scoreText.text = entry.score.ToString();\n            \n        if (_dateText != null)\n            _dateText.text = entry.date;\n            \n        if (_backgroundImage != null)\n        {\n            _backgroundImage.color = rank == 1 ? _topRankColor : _normalColor;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MultiphaseBoss\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"currentPhase\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"phaseTransitionThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.33\n    },\n    {\n      \"name\": \"attackDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"attackRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"chargeSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"projectileSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isAttacking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"attackCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"lastAttackTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"enrageMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"phase_one_combat\",\n      \"trigger\": \"when in phase one and player is within attack range\",\n      \"actions\": [\n        {\n          \"action\": \"perform basic melee attacks\"\n        },\n        {\n          \"action\": \"move slowly toward player\"\n        },\n        {\n          \"action\": \"play phase one combat animations\"\n        }\n      ]\n    },\n    {\n      \"name\": \"phase_transition_to_two\",\n      \"trigger\": \"when health drops below sixty six percent\",\n      \"actions\": [\n        {\n          \"action\": \"change current phase to two\"\n        },\n        {\n          \"action\": \"play phase transition animation\"\n        },\n        {\n          \"action\": \"become temporarily invulnerable\"\n        },\n        {\n          \"action\": \"emit screen shake effect\"\n        },\n        {\n          \"action\": \"spawn protective barrier around self\"\n        }\n      ]\n    },\n    {\n      \"name\": \"phase_two_combat\",\n      \"trigger\": \"when in phase two and player is within attack range\",\n      \"actions\": [\n        {\n          \"action\": \"perform charging attacks at increased speed\"\n        },\n        {\n          \"action\": \"launch projectile attacks in multiple directions\"\n        },\n        {\n          \"action\": \"create area of effect damage zones\"\n        },\n        {\n          \"action\": \"move more aggressively toward player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"phase_transition_to_three\",\n      \"trigger\": \"when health drops below thirty three percent\",\n      \"actions\": [\n        {\n          \"action\": \"change current phase to three\"\n        },\n        {\n          \"action\": \"play enrage animation sequence\"\n        },\n        {\n          \"action\": \"increase all attack damage by enrage multiplier\"\n        },\n        {\n          \"action\": \"reduce attack cooldown times\"\n        },\n        {\n          \"action\": \"change visual appearance to show rage state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"phase_three_combat\",\n      \"trigger\": \"when in phase three and player is within attack range\",\n      \"actions\": [\n        {\n          \"action\": \"perform devastating combo attacks\"\n        },\n        {\n          \"action\": \"launch rapid fire projectile barrages\"\n        },\n        {\n          \"action\": \"create multiple simultaneous area attacks\"\n        },\n        {\n          \"action\": \"teleport around battlefield unpredictably\"\n        },\n        {\n          \"action\": \"summon additional enemy minions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by player attack\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current health by damage amount\"\n        },\n        {\n          \"action\": \"play damage reaction animation\"\n        },\n        {\n          \"action\": \"emit damage particle effects\"\n        },\n        {\n          \"action\": \"play hurt sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_sequence\",\n      \"trigger\": \"when current health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play dramatic death animation\"\n        },\n        {\n          \"action\": \"emit explosion particle effects\"\n        },\n        {\n          \"action\": \"drop valuable loot items\"\n        },\n        {\n          \"action\": \"trigger victory music\"\n        },\n        {\n          \"action\": \"destroy self after animation completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attack_cooldown_management\",\n      \"trigger\": \"when attack finishes executing\",\n      \"actions\": [\n        {\n          \"action\": \"set is attacking to false\"\n        },\n        {\n          \"action\": \"record current time as last attack time\"\n        },\n        {\n          \"action\": \"wait for cooldown period before next attack\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class BossController : MonoBehaviour\n{\n    [System.Serializable]\n    public class BossPhase\n    {\n        [Header(\"Phase Settings\")]\n        public string phaseName = \"Phase\";\n        public float healthThreshold = 100f;\n        public float moveSpeed = 3f;\n        public float attackCooldown = 2f;\n        public Color phaseColor = Color.white;\n        \n        [Header(\"Attack Pattern\")]\n        public AttackType[] attackPattern;\n        public float attackDamage = 10f;\n        public float attackRange = 5f;\n    }\n    \n    [System.Serializable]\n    public enum AttackType\n    {\n        MeleeSlash,\n        RangedProjectile,\n        AreaSlam,\n        ChargeAttack,\n        SpinAttack\n    }\n    \n    [Header(\"Boss Stats\")]\n    [SerializeField] private float _maxHealth = 300f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private bool _isInvulnerable = false;\n    \n    [Header(\"Boss Phases\")]\n    [SerializeField] private BossPhase[] _phases;\n    [SerializeField] private int _currentPhaseIndex = 0;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private Transform _player;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Attack Settings\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private LayerMask _damageLayer = 1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Renderer _bossRenderer;\n    [SerializeField] private ParticleSystem _phaseTransitionEffect;\n    [SerializeField] private ParticleSystem _attackEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _phaseTransitionSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBossDefeated;\n    public UnityEvent<int> OnPhaseChanged;\n    public UnityEvent<float> OnHealthChanged;\n    \n    private Rigidbody _rigidbody;\n    private bool _isAttacking = false;\n    private bool _isDead = false;\n    private float _lastAttackTime;\n    private int _currentAttackIndex = 0;\n    private Coroutine _currentAttackCoroutine;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_bossRenderer == null)\n            _bossRenderer = GetComponent<Renderer>();\n    }\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        InitializePhases();\n        FindPlayer();\n        \n        if (_phases.Length > 0)\n        {\n            ApplyPhaseSettings(_phases[0]);\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _detectionRange)\n        {\n            if (!_isAttacking)\n            {\n                MoveTowardsPlayer();\n                TryAttack();\n            }\n        }\n    }\n    \n    private void InitializePhases()\n    {\n        if (_phases == null || _phases.Length == 0)\n        {\n            _phases = new BossPhase[3];\n            \n            _phases[0] = new BossPhase\n            {\n                phaseName = \"Phase 1\",\n                healthThreshold = _maxHealth * 0.66f,\n                moveSpeed = 2f,\n                attackCooldown = 3f,\n                phaseColor = Color.green,\n                attackPattern = new AttackType[] { AttackType.MeleeSlash, AttackType.RangedProjectile },\n                attackDamage = 15f,\n                attackRange = 3f\n            };\n            \n            _phases[1] = new BossPhase\n            {\n                phaseName = \"Phase 2\",\n                healthThreshold = _maxHealth * 0.33f,\n                moveSpeed = 3f,\n                attackCooldown = 2f,\n                phaseColor = Color.yellow,\n                attackPattern = new AttackType[] { AttackType.AreaSlam, AttackType.ChargeAttack, AttackType.RangedProjectile },\n                attackDamage = 20f,\n                attackRange = 4f\n            };\n            \n            _phases[2] = new BossPhase\n            {\n                phaseName = \"Phase 3\",\n                healthThreshold = 0f,\n                moveSpeed = 4f,\n                attackCooldown = 1.5f,\n                phaseColor = Color.red,\n                attackPattern = new AttackType[] { AttackType.SpinAttack, AttackType.ChargeAttack, AttackType.AreaSlam, AttackType.RangedProjectile },\n                attackDamage = 25f,\n                attackRange = 5f\n            };\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_player == null || _currentPhaseIndex >= _phases.Length) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        float moveSpeed = _phases[_currentPhaseIndex].moveSpeed;\n        _rigidbody.MovePosition(transform.position + direction * moveSpeed * Time.deltaTime);\n        \n        transform.LookAt(new Vector3(_player.position.x, transform.position.y, _player.position.z));\n    }\n    \n    private void TryAttack()\n    {\n        if (_currentPhaseIndex >= _phases.Length) return;\n        \n        BossPhase currentPhase = _phases[_currentPhaseIndex];\n        \n        if (Time.time - _lastAttackTime >= currentPhase.attackCooldown)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            \n            if (distanceToPlayer <= currentPhase.attackRange)\n            {\n                PerformAttack();\n            }\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (_currentPhaseIndex >= _phases.Length) return;\n        \n        BossPhase currentPhase = _phases[_currentPhaseIndex];\n        \n        if (currentPhase.attackPattern.Length == 0) return;\n        \n        AttackType attackType = currentPhase.attackPattern[_currentAttackIndex];\n        _currentAttackIndex = (_currentAttackIndex + 1) % currentPhase.attackPattern.Length;\n        \n        _lastAttackTime = Time.time;\n        \n        if (_currentAttackCoroutine != null)\n        {\n            StopCoroutine(_currentAttackCoroutine);\n        }\n        \n        _currentAttackCoroutine = StartCoroutine(ExecuteAttack(attackType, currentPhase));\n    }\n    \n    private IEnumerator ExecuteAttack(AttackType attackType, BossPhase phase)\n    {\n        _isAttacking = true;\n        \n        PlayAttackSound();\n        PlayAttackEffect();\n        \n        switch (attackType)\n        {\n            case AttackType.MeleeSlash:\n                yield return StartCoroutine(MeleeSlashAttack(phase));\n                break;\n            case AttackType.RangedProjectile:\n                yield return StartCoroutine(RangedProjectileAttack(phase));\n                break;\n            case AttackType.AreaSlam:\n                yield return StartCoroutine(AreaSlamAttack(phase));\n                break;\n            case AttackType.ChargeAttack:\n                yield return StartCoroutine(ChargeAttack(phase));\n                break;\n            case AttackType.SpinAttack:\n                yield return StartCoroutine(SpinAttack(phase));\n                break;\n        }\n        \n        _isAttacking = false;\n    }\n    \n    private IEnumerator MeleeSlashAttack(BossPhase phase)\n    {\n        yield return new WaitForSeconds(0.5f);\n        \n        Collider[] hitColliders = Physics.OverlapSphere(_attackPoint.position, phase.attackRange, _damageLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DamagePlayer(hit.gameObject, phase.attackDamage);\n            }\n        }\n    }\n    \n    private IEnumerator RangedProjectileAttack(BossPhase phase)\n    {\n        if (_projectilePrefab != null && _player != null)\n        {\n            Vector3 direction = (_player.position - _attackPoint.position).normalized;\n            \n            GameObject projectile = Instantiate(_projectilePrefab, _attackPoint.position, Quaternion.LookRotation(direction));\n            Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n            \n            if (projectileRb == null)\n                projectileRb = projectile.AddComponent<Rigidbody>();\n                \n            projectileRb.velocity = direction * _projectileSpeed;\n            \n            ProjectileDamage projectileDamage = projectile.GetComponent<ProjectileDamage>();\n            if (projectileDamage == null)\n                projectileDamage = projectile.AddComponent<ProjectileDamage>();\n                \n            projectileDamage.damage = phase.attackDamage;\n            \n            Destroy(projectile, 5f);\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n    }\n    \n    private IEnumerator AreaSlamAttack(BossPhase phase)\n    {\n        yield return new WaitForSeconds(1f);\n        \n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, phase.attackRange * 1.5f, _damageLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DamagePlayer(hit.gameObject, phase.attackDamage * 1.2f);\n            }\n        }\n    }\n    \n    private IEnumerator ChargeAttack(BossPhase phase)\n    {\n        if (_player == null) yield break;\n        \n        Vector3 chargeDirection = (_player.position - transform.position).normalized;\n        chargeDirection.y = 0;\n        \n        float chargeDistance = 8f;\n        float chargeSpeed = phase.moveSpeed * 3f;\n        \n        Vector3 startPosition = transform.position;\n        Vector3 targetPosition = startPosition + chargeDirection * chargeDistance;\n        \n        float chargeTime = chargeDistance / chargeSpeed;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < chargeTime)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / chargeTime;\n            \n            Vector3 currentPosition = Vector3.Lerp(startPosition, targetPosition, progress);\n            _rigidbody.MovePosition(currentPosition);\n            \n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, 1.5f, _damageLayer);\n            foreach (Collider hit in hitColliders)\n            {\n                if (hit.CompareTag(\"Player\"))\n                {\n                    DamagePlayer(hit.gameObject, phase.attackDamage * 1.5f);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        yield return new WaitForSeconds(0.5f);\n    }\n    \n    private IEnumerator SpinAttack(BossPhase phase)\n    {\n        float spinDuration = 2f;\n        float spinSpeed = 720f;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < spinDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            transform.Rotate(0, spinSpeed * Time.deltaTime, 0);\n            \n            Collider[] hitColliders = Physics.OverlapSphere(transform.position, phase.attackRange, _damageLayer);\n            foreach (Collider hit in hitColliders)\n            {\n                if (hit.CompareTag(\"Player\"))\n                {\n                    DamagePlayer(hit.gameObject, phase.attackDamage * 0.5f);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void DamagePlayer(GameObject player, float damage)\n    {\n        // Send damage message to player\n        player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead || _isInvulnerable) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        CheckPhaseTransition();\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void CheckPhaseTransition()\n    {\n        if (_currentPhaseIndex >= _phases.Length - 1) return;\n        \n        BossPhase nextPhase = _phases[_currentPhaseIndex + 1];\n        \n        if (_currentHealth <= nextPhase.healthThreshold)\n        {\n            TransitionToNextPhase();\n        }\n    }\n    \n    private void TransitionToNextPhase()\n    {\n        _currentPhaseIndex++;\n        \n        if (_currentPhaseIndex < _phases.Length)\n        {\n            ApplyPhaseSettings(_phases[_currentPhaseIndex]);\n            OnPhaseChanged?.Invoke(_currentPhaseIndex);\n            \n            PlayPhaseTransitionEffect();\n            PlayPhaseTransitionSound();\n            \n            _isInvulnerable = true;\n            StartCoroutine(InvulnerabilityPeriod(2f));\n        }\n    }\n    \n    private void ApplyPhaseSettings(BossPhase phase)\n    {\n        if (_bossRenderer != null)\n        {\n            _bossRenderer.material.color = phase.phaseColor;\n        }\n        \n        _currentAttackIndex = 0;\n    }\n    \n    private IEnumerator InvulnerabilityPeriod(float duration)\n    {\n        yield return new WaitForSeconds(duration);\n        _isInvulnerable = false;\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _isAttacking = false;"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RemotePlayerInterpolator\",\n  \"components\": [\n    \"Transform\",\n    \"NetworkBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"interpolationSpeed\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"targetPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"targetRotation\",\n      \"type\": \"Quaternion\",\n      \"default\": \"Quaternion.identity\"\n    },\n    {\n      \"name\": \"positionThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"rotationThreshold\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"receive_network_position\",\n      \"trigger\": \"when network position data is received from remote player\",\n      \"actions\": [\n        {\n          \"action\": \"store received position as target position\"\n        },\n        {\n          \"action\": \"store received rotation as target rotation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interpolate_position\",\n      \"trigger\": \"every frame when current position differs from target position by more than threshold\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly move current position toward target position using interpolation speed\"\n        },\n        {\n          \"action\": \"update transform position with interpolated value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interpolate_rotation\",\n      \"trigger\": \"every frame when current rotation differs from target rotation by more than threshold\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly rotate current rotation toward target rotation using interpolation speed\"\n        },\n        {\n          \"action\": \"update transform rotation with interpolated value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"snap_when_too_far\",\n      \"trigger\": \"when distance between current position and target position is very large\",\n      \"actions\": [\n        {\n          \"action\": \"instantly set position to target position\"\n        },\n        {\n          \"action\": \"instantly set rotation to target rotation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RemotePlayerInterpolator : MonoBehaviour\n{\n    [Header(\"Interpolation Settings\")]\n    [SerializeField] private float _interpolationRate = 15f;\n    [SerializeField] private float _extrapolationLimit = 0.5f;\n    [SerializeField] private bool _useExtrapolation = true;\n    [SerializeField] private float _maxInterpolationDistance = 10f;\n    \n    [Header(\"Network Settings\")]\n    [SerializeField] private float _sendRate = 20f;\n    [SerializeField] private float _networkDelay = 0.1f;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    [SerializeField] private Color _debugLineColor = Color.red;\n\n    private struct NetworkState\n    {\n        public float timestamp;\n        public Vector3 position;\n        public Quaternion rotation;\n        public Vector3 velocity;\n    }\n\n    private Queue<NetworkState> _stateBuffer = new Queue<NetworkState>();\n    private NetworkState _currentState;\n    private NetworkState _previousState;\n    private Vector3 _lastPosition;\n    private float _lastUpdateTime;\n    private bool _hasReceivedData = false;\n\n    private void Start()\n    {\n        _lastPosition = transform.position;\n        _lastUpdateTime = Time.time;\n        \n        _currentState = new NetworkState\n        {\n            timestamp = Time.time,\n            position = transform.position,\n            rotation = transform.rotation,\n            velocity = Vector3.zero\n        };\n        \n        _previousState = _currentState;\n    }\n\n    private void Update()\n    {\n        if (!_hasReceivedData) return;\n\n        float renderTime = Time.time - _networkDelay;\n        InterpolatePosition(renderTime);\n        \n        if (_showDebugInfo)\n        {\n            DrawDebugInfo();\n        }\n    }\n\n    public void ReceiveNetworkUpdate(Vector3 position, Quaternion rotation, float timestamp)\n    {\n        Vector3 velocity = Vector3.zero;\n        \n        if (_hasReceivedData)\n        {\n            float deltaTime = timestamp - _currentState.timestamp;\n            if (deltaTime > 0)\n            {\n                velocity = (position - _currentState.position) / deltaTime;\n            }\n        }\n\n        NetworkState newState = new NetworkState\n        {\n            timestamp = timestamp,\n            position = position,\n            rotation = rotation,\n            velocity = velocity\n        };\n\n        _stateBuffer.Enqueue(newState);\n        \n        // Keep buffer size reasonable\n        while (_stateBuffer.Count > 10)\n        {\n            _stateBuffer.Dequeue();\n        }\n        \n        _hasReceivedData = true;\n    }\n\n    private void InterpolatePosition(float renderTime)\n    {\n        // Find the two states to interpolate between\n        NetworkState from = new NetworkState();\n        NetworkState to = new NetworkState();\n        bool foundStates = false;\n\n        NetworkState[] states = _stateBuffer.ToArray();\n        \n        for (int i = 0; i < states.Length - 1; i++)\n        {\n            if (states[i].timestamp <= renderTime && renderTime <= states[i + 1].timestamp)\n            {\n                from = states[i];\n                to = states[i + 1];\n                foundStates = true;\n                break;\n            }\n        }\n\n        if (!foundStates)\n        {\n            // Use extrapolation if enabled\n            if (_useExtrapolation && states.Length > 0)\n            {\n                NetworkState latest = states[states.Length - 1];\n                float extrapolationTime = renderTime - latest.timestamp;\n                \n                if (extrapolationTime <= _extrapolationLimit)\n                {\n                    Vector3 extrapolatedPosition = latest.position + latest.velocity * extrapolationTime;\n                    \n                    // Check if extrapolation distance is reasonable\n                    float distance = Vector3.Distance(transform.position, extrapolatedPosition);\n                    if (distance <= _maxInterpolationDistance)\n                    {\n                        transform.position = Vector3.Lerp(transform.position, extrapolatedPosition, Time.deltaTime * _interpolationRate);\n                        transform.rotation = Quaternion.Lerp(transform.rotation, latest.rotation, Time.deltaTime * _interpolationRate);\n                    }\n                }\n            }\n            return;\n        }\n\n        // Interpolate between the two states\n        float lerpAmount = 0f;\n        if (to.timestamp != from.timestamp)\n        {\n            lerpAmount = (renderTime - from.timestamp) / (to.timestamp - from.timestamp);\n        }\n\n        Vector3 targetPosition = Vector3.Lerp(from.position, to.position, lerpAmount);\n        Quaternion targetRotation = Quaternion.Lerp(from.rotation, to.rotation, lerpAmount);\n\n        // Check interpolation distance\n        float interpolationDistance = Vector3.Distance(transform.position, targetPosition);\n        if (interpolationDistance <= _maxInterpolationDistance)\n        {\n            transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * _interpolationRate);\n            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * _interpolationRate);\n        }\n        else\n        {\n            // Teleport if too far\n            transform.position = targetPosition;\n            transform.rotation = targetRotation;\n        }\n\n        // Clean up old states\n        CleanupOldStates(renderTime);\n    }\n\n    private void CleanupOldStates(float renderTime)\n    {\n        while (_stateBuffer.Count > 2)\n        {\n            NetworkState oldest = _stateBuffer.Peek();\n            if (oldest.timestamp < renderTime - 1f) // Keep 1 second of history\n            {\n                _stateBuffer.Dequeue();\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void DrawDebugInfo()\n    {\n        if (_stateBuffer.Count < 2) return;\n\n        NetworkState[] states = _stateBuffer.ToArray();\n        \n        // Draw interpolation path\n        for (int i = 0; i < states.Length - 1; i++)\n        {\n            Debug.DrawLine(states[i].position, states[i + 1].position, _debugLineColor, 0.1f);\n        }\n\n        // Draw current position\n        Debug.DrawWireSphere(transform.position, 0.2f, Color.green, 0.1f);\n        \n        // Draw velocity vector\n        if (states.Length > 0)\n        {\n            NetworkState latest = states[states.Length - 1];\n            Debug.DrawRay(transform.position, latest.velocity, Color.blue, 0.1f);\n        }\n    }\n\n    public void SetInterpolationRate(float rate)\n    {\n        _interpolationRate = Mathf.Clamp(rate, 1f, 50f);\n    }\n\n    public void SetNetworkDelay(float delay)\n    {\n        _networkDelay = Mathf.Clamp(delay, 0f, 1f);\n    }\n\n    public bool HasReceivedData()\n    {\n        return _hasReceivedData;\n    }\n\n    public int GetBufferSize()\n    {\n        return _stateBuffer.Count;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (!_showDebugInfo) return;\n\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxInterpolationDistance);\n        \n        if (_stateBuffer != null && _stateBuffer.Count > 0)\n        {\n            NetworkState[] states = _stateBuffer.ToArray();\n            Gizmos.color = Color.red;\n            \n            foreach (NetworkState state in states)\n            {\n                Gizmos.DrawWireCube(state.position, Vector3.one * 0.1f);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ConversationPhone\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isRinging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isInConversation\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"ringVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"conversationVolume\",\n      \"type\": \"float\",\n      \"default\": 0.6\n    },\n    {\n      \"name\": \"ringDuration\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_ringing\",\n      \"trigger\": \"when phone receives incoming call\",\n      \"actions\": [\n        {\n          \"action\": \"play ringing sound at ring volume\"\n        },\n        {\n          \"action\": \"set phone to ringing state\"\n        },\n        {\n          \"action\": \"make phone visually indicate incoming call\"\n        }\n      ]\n    },\n    {\n      \"name\": \"answer_phone\",\n      \"trigger\": \"when player interacts with ringing phone\",\n      \"actions\": [\n        {\n          \"action\": \"stop ringing sound\"\n        },\n        {\n          \"action\": \"start conversation audio\"\n        },\n        {\n          \"action\": \"set phone to conversation state\"\n        },\n        {\n          \"action\": \"disable ringing state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_conversation\",\n      \"trigger\": \"when conversation audio finishes playing\",\n      \"actions\": [\n        {\n          \"action\": \"stop conversation audio\"\n        },\n        {\n          \"action\": \"set phone to idle state\"\n        },\n        {\n          \"action\": \"disable conversation state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hang_up\",\n      \"trigger\": \"when player interacts with phone during conversation\",\n      \"actions\": [\n        {\n          \"action\": \"stop conversation audio immediately\"\n        },\n        {\n          \"action\": \"play hang up sound\"\n        },\n        {\n          \"action\": \"set phone to idle state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_ringing_timeout\",\n      \"trigger\": \"when phone has been ringing for maximum duration\",\n      \"actions\": [\n        {\n          \"action\": \"stop ringing sound\"\n        },\n        {\n          \"action\": \"set phone to idle state\"\n        },\n        {\n          \"action\": \"disable ringing state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Phone : MonoBehaviour\n{\n    [System.Serializable]\n    public class ConversationLine\n    {\n        public string speakerName;\n        [TextArea(2, 4)]\n        public string text;\n        public float displayDuration = 3f;\n        public AudioClip voiceClip;\n    }\n\n    [System.Serializable]\n    public class Conversation\n    {\n        public string conversationName;\n        public List<ConversationLine> lines = new List<ConversationLine>();\n        public bool canSkip = true;\n        public bool autoAdvance = true;\n    }\n\n    [Header(\"Phone Settings\")]\n    [SerializeField] private GameObject _phoneUI;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactKey = KeyCode.E;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"UI Components\")]\n    [SerializeField] private Text _speakerNameText;\n    [SerializeField] private Text _conversationText;\n    [SerializeField] private Button _nextButton;\n    [SerializeField] private Button _skipButton;\n    [SerializeField] private Button _hangUpButton;\n    [SerializeField] private Image _phoneScreen;\n    [SerializeField] private GameObject _interactionPrompt;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _ringTone;\n    [SerializeField] private AudioClip _dialTone;\n    [SerializeField] private AudioClip _hangUpSound;\n    [SerializeField] private float _ringVolume = 0.7f;\n\n    [Header(\"Conversations\")]\n    [SerializeField] private List<Conversation> _conversations = new List<Conversation>();\n    [SerializeField] private int _currentConversationIndex = 0;\n    [SerializeField] private bool _randomizeConversations = false;\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _ringingEffect;\n    [SerializeField] private Color _activeScreenColor = Color.green;\n    [SerializeField] private Color _inactiveScreenColor = Color.black;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPhoneRing;\n    public UnityEvent OnConversationStart;\n    public UnityEvent OnConversationEnd;\n    public UnityEvent OnPlayerNearby;\n    public UnityEvent OnPlayerLeft;\n\n    private bool _isRinging = false;\n    private bool _isInConversation = false;\n    private bool _playerInRange = false;\n    private int _currentLineIndex = 0;\n    private Conversation _currentConversation;\n    private Coroutine _conversationCoroutine;\n    private Coroutine _ringingCoroutine;\n    private Transform _playerTransform;\n\n    private void Start()\n    {\n        InitializePhone();\n        SetupUI();\n        \n        if (_conversations.Count > 0)\n        {\n            StartRinging();\n        }\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n\n    private void InitializePhone()\n    {\n        if (_phoneUI != null)\n            _phoneUI.SetActive(false);\n\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n\n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(false);\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        UpdateScreenColor(_inactiveScreenColor);\n    }\n\n    private void SetupUI()\n    {\n        if (_nextButton != null)\n            _nextButton.onClick.AddListener(NextLine);\n\n        if (_skipButton != null)\n            _skipButton.onClick.AddListener(SkipConversation);\n\n        if (_hangUpButton != null)\n            _hangUpButton.onClick.AddListener(HangUp);\n    }\n\n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange;\n\n        if (_playerInRange && !wasInRange)\n        {\n            _playerTransform = player.transform;\n            OnPlayerNearby.Invoke();\n            ShowInteractionPrompt(true);\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            _playerTransform = null;\n            OnPlayerLeft.Invoke();\n            ShowInteractionPrompt(false);\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (!_playerInRange) return;\n\n        if (Input.GetKeyDown(_interactKey))\n        {\n            if (_isRinging && !_isInConversation)\n            {\n                AnswerPhone();\n            }\n            else if (_isInConversation)\n            {\n                NextLine();\n            }\n        }\n\n        if (Input.GetKeyDown(KeyCode.Escape) && _isInConversation)\n        {\n            HangUp();\n        }\n    }\n\n    private void ShowInteractionPrompt(bool show)\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(show && (_isRinging || _isInConversation));\n    }\n\n    public void StartRinging()\n    {\n        if (_isInConversation || _conversations.Count == 0) return;\n\n        _isRinging = true;\n        \n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(true);\n\n        OnPhoneRing.Invoke();\n        ShowInteractionPrompt(_playerInRange);\n\n        if (_ringingCoroutine != null)\n            StopCoroutine(_ringingCoroutine);\n        \n        _ringingCoroutine = StartCoroutine(PlayRingTone());\n    }\n\n    public void AnswerPhone()\n    {\n        if (!_isRinging || _isInConversation) return;\n\n        StopRinging();\n        StartConversation();\n    }\n\n    private void StopRinging()\n    {\n        _isRinging = false;\n        \n        if (_ringingEffect != null)\n            _ringingEffect.SetActive(false);\n\n        if (_ringingCoroutine != null)\n        {\n            StopCoroutine(_ringingCoroutine);\n            _ringingCoroutine = null;\n        }\n\n        _audioSource.Stop();\n    }\n\n    private void StartConversation()\n    {\n        if (_conversations.Count == 0) return;\n\n        _isInConversation = true;\n        _currentLineIndex = 0;\n\n        if (_randomizeConversations)\n        {\n            _currentConversationIndex = Random.Range(0, _conversations.Count);\n        }\n\n        _currentConversation = _conversations[_currentConversationIndex];\n        \n        if (_phoneUI != null)\n            _phoneUI.SetActive(true);\n\n        UpdateScreenColor(_activeScreenColor);\n        OnConversationStart.Invoke();\n\n        if (_dialTone != null)\n        {\n            _audioSource.PlayOneShot(_dialTone);\n        }\n\n        ShowInteractionPrompt(_playerInRange);\n        DisplayCurrentLine();\n    }\n\n    private void DisplayCurrentLine()\n    {\n        if (_currentConversation == null || _currentLineIndex >= _currentConversation.lines.Count)\n        {\n            EndConversation();\n            return;\n        }\n\n        ConversationLine currentLine = _currentConversation.lines[_currentLineIndex];\n\n        if (_speakerNameText != null)\n            _speakerNameText.text = currentLine.speakerName;\n\n        if (_conversationText != null)\n            _conversationText.text = currentLine.text;\n\n        if (currentLine.voiceClip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(currentLine.voiceClip);\n        }\n\n        UpdateUIButtons();\n\n        if (_currentConversation.autoAdvance)\n        {\n            if (_conversationCoroutine != null)\n                StopCoroutine(_conversationCoroutine);\n            \n            _conversationCoroutine = StartCoroutine(AutoAdvanceLine(currentLine.displayDuration));\n        }\n    }\n\n    private void UpdateUIButtons()\n    {\n        bool isLastLine = _currentLineIndex >= _currentConversation.lines.Count - 1;\n        \n        if (_nextButton != null)\n            _nextButton.gameObject.SetActive(!isLastLine || !_currentConversation.autoAdvance);\n\n        if (_skipButton != null)\n            _skipButton.gameObject.SetActive(_currentConversation.canSkip);\n    }\n\n    public void NextLine()\n    {\n        if (!_isInConversation) return;\n\n        if (_conversationCoroutine != null)\n        {\n            StopCoroutine(_conversationCoroutine);\n            _conversationCoroutine = null;\n        }\n\n        _currentLineIndex++;\n        DisplayCurrentLine();\n    }\n\n    public void SkipConversation()\n    {\n        if (!_isInConversation || !_currentConversation.canSkip) return;\n\n        EndConversation();\n    }\n\n    public void HangUp()\n    {\n        if (_isInConversation)\n        {\n            EndConversation();\n        }\n        else if (_isRinging)\n        {\n            StopRinging();\n        }\n    }\n\n    private void EndConversation()\n    {\n        _isInConversation = false;\n        \n        if (_conversationCoroutine != null)\n        {\n            StopCoroutine(_conversationCoroutine);\n            _conversationCoroutine = null;\n        }\n\n        if (_phoneUI != null)\n            _phoneUI.SetActive(false);\n\n        UpdateScreenColor(_inactiveScreenColor);\n        ShowInteractionPrompt(false);\n\n        if (_hangUpSound != null)\n        {\n            _audioSource.PlayOneShot(_hangUpSound);\n        }\n\n        OnConversationEnd.Invoke();\n\n        // Move to next conversation for future calls\n        _currentConversationIndex = (_currentConversationIndex + 1) % _conversations.Count;\n    }\n\n    private IEnumerator AutoAdvanceLine(float duration)\n    {\n        yield return new WaitForSeconds(duration);\n        NextLine();\n    }\n\n    private IEnumerator PlayRingTone()\n    {\n        while (_isRinging)\n        {\n            if (_ringTone != null)\n            {\n                _audioSource.PlayOneShot(_ringTone, _ringVolume);\n                yield return new WaitForSeconds(_ringTone.length + 1f);\n            }\n            else\n            {\n                yield return new WaitForSeconds(2f);\n            }\n        }\n    }\n\n    private void UpdateScreenColor(Color color)\n    {\n        if (_phoneScreen != null)\n            _phoneScreen.color = color;\n    }\n\n    public void AddConversation(Conversation conversation)\n    {\n        _conversations.Add(conversation);\n    }\n\n    public void TriggerCall()\n    {\n        if (!_isRinging && !_isInConversation)\n        {\n            StartRinging();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n\n    private void OnDisable()\n    {\n        if (_conversationCoroutine != null)\n            StopCoroutine(_conversationCoroutine);\n        \n        if (_ringingCoroutine != null)\n            StopCoroutine(_ringingCoroutine);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ProtectionRing\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"protectionAmount\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"protectionDuration\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_protection\",\n      \"trigger\": \"when player touches the ring\",\n      \"actions\": [\n        {\n          \"action\": \"grant protection buff to player\"\n        },\n        {\n          \"action\": \"reduce incoming damage by protection amount\"\n        },\n        {\n          \"action\": \"start protection duration timer\"\n        },\n        {\n          \"action\": \"make ring glow with protective aura\"\n        },\n        {\n          \"action\": \"play protection activation sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_protection\",\n      \"trigger\": \"while protection is active\",\n      \"actions\": [\n        {\n          \"action\": \"display protection visual effect around player\"\n        },\n        {\n          \"action\": \"reduce all incoming damage\"\n        },\n        {\n          \"action\": \"show remaining protection time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_protection\",\n      \"trigger\": \"when protection duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"remove protection buff from player\"\n        },\n        {\n          \"action\": \"fade out protective visual effects\"\n        },\n        {\n          \"action\": \"play protection end sound\"\n        },\n        {\n          \"action\": \"make ring available for pickup again\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when protection blocks damage\",\n      \"actions\": [\n        {\n          \"action\": \"flash protective barrier effect\"\n        },\n        {\n          \"action\": \"play damage absorption sound\"\n        },\n        {\n          \"action\": \"show blocked damage numbers\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ProtectionRing : MonoBehaviour\n{\n    [System.Serializable]\n    public class ProtectionEvent : UnityEvent<float> { }\n    \n    [Header(\"Protection Settings\")]\n    [SerializeField] private float _protectionAmount = 50f;\n    [SerializeField] private float _protectionDuration = 10f;\n    [SerializeField] private bool _isTemporary = true;\n    [SerializeField] private bool _canStackProtection = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _protectionEffect;\n    [SerializeField] private ParticleSystem _pickupParticles;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private Color _protectionColor = Color.blue;\n    \n    [Header(\"Ring Behavior\")]\n    [SerializeField] private bool _rotateRing = true;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private bool _floatUpDown = true;\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public ProtectionEvent OnProtectionGranted;\n    public UnityEvent OnRingCollected;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    private bool _isCollected = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n            _collider.isTrigger = true;\n            \n        if (_renderer != null && _renderer.material != null)\n        {\n            _renderer.material.color = _protectionColor;\n            _renderer.material.SetFloat(\"_Metallic\", 0.8f);\n            _renderer.material.SetFloat(\"_Smoothness\", 0.9f);\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        if (_rotateRing)\n        {\n            transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        }\n        \n        if (_floatUpDown)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            GrantProtection(other.gameObject);\n            CollectRing();\n        }\n    }\n    \n    private void GrantProtection(GameObject player)\n    {\n        PlayerProtection protection = player.GetComponent<PlayerProtection>();\n        if (protection == null)\n        {\n            protection = player.AddComponent<PlayerProtection>();\n        }\n        \n        if (_canStackProtection || !protection.HasProtection())\n        {\n            protection.AddProtection(_protectionAmount, _protectionDuration, _isTemporary);\n            OnProtectionGranted?.Invoke(_protectionAmount);\n            \n            if (_protectionEffect != null)\n            {\n                GameObject effect = Instantiate(_protectionEffect, player.transform);\n                effect.transform.localPosition = Vector3.zero;\n                \n                if (_isTemporary)\n                {\n                    Destroy(effect, _protectionDuration);\n                }\n            }\n        }\n    }\n    \n    private void CollectRing()\n    {\n        _isCollected = true;\n        \n        if (_pickupParticles != null)\n        {\n            _pickupParticles.Play();\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        OnRingCollected?.Invoke();\n        \n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        if (_collider != null)\n            _collider.enabled = false;\n            \n        Destroy(gameObject, 2f);\n    }\n    \n    public void SetProtectionAmount(float amount)\n    {\n        _protectionAmount = amount;\n    }\n    \n    public void SetProtectionDuration(float duration)\n    {\n        _protectionDuration = duration;\n    }\n    \n    public float GetProtectionAmount()\n    {\n        return _protectionAmount;\n    }\n    \n    public float GetProtectionDuration()\n    {\n        return _protectionDuration;\n    }\n}\n\npublic class PlayerProtection : MonoBehaviour\n{\n    private float _currentProtection = 0f;\n    private float _protectionTimer = 0f;\n    private bool _hasTemporaryProtection = false;\n    private Renderer _playerRenderer;\n    private Color _originalColor;\n    private Material _originalMaterial;\n    \n    private void Start()\n    {\n        _playerRenderer = GetComponent<Renderer>();\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            _originalMaterial = _playerRenderer.material;\n            _originalColor = _originalMaterial.color;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasTemporaryProtection && _protectionTimer > 0f)\n        {\n            _protectionTimer -= Time.deltaTime;\n            \n            if (_protectionTimer <= 0f)\n            {\n                RemoveProtection();\n            }\n            else\n            {\n                UpdateProtectionVisual();\n            }\n        }\n    }\n    \n    public void AddProtection(float amount, float duration, bool isTemporary)\n    {\n        _currentProtection += amount;\n        \n        if (isTemporary)\n        {\n            _hasTemporaryProtection = true;\n            _protectionTimer = duration;\n        }\n        \n        ApplyProtectionVisual();\n    }\n    \n    public bool HasProtection()\n    {\n        return _currentProtection > 0f;\n    }\n    \n    public float GetProtection()\n    {\n        return _currentProtection;\n    }\n    \n    public bool TakeDamage(float damage)\n    {\n        if (_currentProtection > 0f)\n        {\n            _currentProtection -= damage;\n            \n            if (_currentProtection <= 0f)\n            {\n                _currentProtection = 0f;\n                RemoveProtection();\n            }\n            \n            return true;\n        }\n        \n        return false;\n    }\n    \n    private void ApplyProtectionVisual()\n    {\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            _playerRenderer.material.color = Color.Lerp(_originalColor, Color.blue, 0.3f);\n            _playerRenderer.material.SetFloat(\"_Metallic\", 0.5f);\n        }\n    }\n    \n    private void UpdateProtectionVisual()\n    {\n        if (_playerRenderer != null && _playerRenderer.material != null)\n        {\n            float alpha = Mathf.PingPong(Time.time * 3f, 1f);\n            Color protectionColor = Color.Lerp(_originalColor, Color.blue, 0.3f * alpha);\n            _playerRenderer.material.color = protectionColor;\n        }\n    }\n    \n    private void RemoveProtection()\n    {\n        _hasTemporaryProtection = false;\n        _protectionTimer = 0f;\n        \n        if (_playerRenderer != null && _originalMaterial != null)\n        {\n            _playerRenderer.material.color = _originalColor;\n            _playerRenderer.material.SetFloat(\"_Metallic\", _originalMaterial.GetFloat(\"_Metallic\"));\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingHeartPickup\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healthAmount\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90.0\n    },\n    {\n      \"name\": \"pulseScale\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"pulseSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_up_and_down\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"move up and down in a smooth sine wave pattern at float height and float speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_continuously\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_scale\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"scale up and down smoothly between normal size and pulse scale at pulse speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"heal_player_on_pickup\",\n      \"trigger\": \"when player touches this pickup\",\n      \"actions\": [\n        {\n          \"action\": \"restore health amount to player\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"create healing particle effect\"\n        },\n        {\n          \"action\": \"destroy this pickup object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FloatingHeartPickup : MonoBehaviour\n{\n    [Header(\"Pickup Settings\")]\n    [SerializeField] private int _healthAmount = 20;\n    [SerializeField] private float _pickupRange = 2f;\n    [SerializeField] private bool _destroyOnPickup = true;\n    \n    [Header(\"Floating Animation\")]\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _scaleOnPickup = 1.2f;\n    [SerializeField] private float _pickupAnimationDuration = 0.3f;\n    \n    [Header(\"Magnet Effect\")]\n    [SerializeField] private bool _enableMagnetEffect = true;\n    [SerializeField] private float _magnetRange = 5f;\n    [SerializeField] private float _magnetSpeed = 8f;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    private Transform _playerTransform;\n    private bool _isMagneting = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPickedUp) return;\n        \n        HandleFloatingAnimation();\n        HandleMagnetEffect();\n        CheckForPlayerPickup();\n    }\n    \n    private void HandleFloatingAnimation()\n    {\n        if (!_isMagneting)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n        \n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n    }\n    \n    private void HandleMagnetEffect()\n    {\n        if (!_enableMagnetEffect || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer <= _magnetRange && distanceToPlayer > _pickupRange)\n        {\n            _isMagneting = true;\n            Vector3 direction = (_playerTransform.position - transform.position).normalized;\n            transform.position = Vector3.MoveTowards(transform.position, _playerTransform.position, _magnetSpeed * Time.deltaTime);\n        }\n        else if (distanceToPlayer > _magnetRange)\n        {\n            _isMagneting = false;\n        }\n    }\n    \n    private void CheckForPlayerPickup()\n    {\n        if (_playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer <= _pickupRange)\n        {\n            PickupHeart();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PickupHeart();\n        }\n    }\n    \n    private void PickupHeart()\n    {\n        if (_isPickedUp) return;\n        \n        _isPickedUp = true;\n        \n        // Try to heal the player\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            // Try different common health component patterns\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send message to any health-related methods that might exist\n                player.SendMessage(\"Heal\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n                player.SendMessage(\"AddHealth\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n                player.SendMessage(\"RestoreHealth\", _healthAmount, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n        \n        // Play pickup effects\n        PlayPickupEffects();\n        \n        // Handle pickup animation or immediate destruction\n        if (_destroyOnPickup)\n        {\n            StartCoroutine(PickupAnimation());\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            _pickupEffect.Play();\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator PickupAnimation()\n    {\n        Vector3 originalScale = transform.localScale;\n        Vector3 targetScale = originalScale * _scaleOnPickup;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _pickupAnimationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _pickupAnimationDuration;\n            \n            // Scale up then down\n            float scaleMultiplier = progress < 0.5f ? \n                Mathf.Lerp(1f, _scaleOnPickup, progress * 2f) : \n                Mathf.Lerp(_scaleOnPickup, 0f, (progress - 0.5f) * 2f);\n            \n            transform.localScale = originalScale * scaleMultiplier;\n            \n            // Fade out if renderer exists\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null && renderer.material.HasProperty(\"_Color\"))\n            {\n                Color color = renderer.material.color;\n                color.a = 1f - progress;\n                renderer.material.color = color;\n            }\n            \n            yield return null;\n        }\n        \n        // Wait for sound to finish if playing\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            yield return new WaitWhile(() => _audioSource.isPlaying);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw pickup range\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _pickupRange);\n        \n        // Draw magnet range\n        if (_enableMagnetEffect)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _magnetRange);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChargingBow\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxChargeTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"minArrowSpeed\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"maxArrowSpeed\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"arrowPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shootPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentChargeTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"isCharging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"chargingSoundPitch\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_charging\",\n      \"trigger\": \"when player presses and holds fire button\",\n      \"actions\": [\n        {\n          \"action\": \"begin charging the bow\"\n        },\n        {\n          \"action\": \"reset charge time to zero\"\n        },\n        {\n          \"action\": \"play charging sound effect\"\n        },\n        {\n          \"action\": \"show visual charging indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continue_charging\",\n      \"trigger\": \"while fire button is held and charge time is less than maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increase charge time\"\n        },\n        {\n          \"action\": \"increase charging sound pitch based on charge level\"\n        },\n        {\n          \"action\": \"update visual charging indicator intensity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_arrow\",\n      \"trigger\": \"when fire button is released\",\n      \"actions\": [\n        {\n          \"action\": \"calculate arrow speed based on charge time\"\n        },\n        {\n          \"action\": \"spawn arrow at shoot point\"\n        },\n        {\n          \"action\": \"launch arrow forward with calculated speed\"\n        },\n        {\n          \"action\": \"stop charging sound\"\n        },\n        {\n          \"action\": \"hide charging indicator\"\n        },\n        {\n          \"action\": \"reset charge time to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"max_charge_reached\",\n      \"trigger\": \"when charge time reaches maximum\",\n      \"actions\": [\n        {\n          \"action\": \"maintain maximum charge level\"\n        },\n        {\n          \"action\": \"play fully charged sound effect\"\n        },\n        {\n          \"action\": \"show maximum charge visual effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Bow : MonoBehaviour\n{\n    [Header(\"Bow Settings\")]\n    [SerializeField] private float _maxChargeTime = 2f;\n    [SerializeField] private float _minPower = 0.3f;\n    [SerializeField] private float _maxPower = 1f;\n    [SerializeField] private AnimationCurve _chargeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Arrow Settings\")]\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _arrowSpawnPoint;\n    [SerializeField] private float _baseArrowSpeed = 20f;\n    [SerializeField] private float _maxArrowSpeed = 50f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private LineRenderer _trajectoryLine;\n    [SerializeField] private int _trajectoryPoints = 30;\n    [SerializeField] private float _trajectoryTimeStep = 0.1f;\n    [SerializeField] private ParticleSystem _chargeEffect;\n    [SerializeField] private Transform _bowString;\n    [SerializeField] private float _maxStringPull = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drawSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _chargeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeChanged;\n    public UnityEvent<float> OnArrowFired;\n    \n    private bool _isCharging;\n    private float _currentChargeTime;\n    private float _currentPower;\n    private Vector3 _originalStringPosition;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_bowString != null)\n            _originalStringPosition = _bowString.localPosition;\n            \n        if (_trajectoryLine != null)\n        {\n            _trajectoryLine.positionCount = _trajectoryPoints;\n            _trajectoryLine.enabled = false;\n        }\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharging();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        bool drawInput = Input.GetMouseButton(0) || Input.GetKey(KeyCode.Space);\n        bool releaseInput = Input.GetMouseButtonUp(0) || Input.GetKeyUp(KeyCode.Space);\n        \n        if (drawInput && !_isCharging && CanFire())\n        {\n            StartCharging();\n        }\n        else if (releaseInput && _isCharging)\n        {\n            FireArrow();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return _arrowPrefab != null && _arrowSpawnPoint != null;\n    }\n    \n    private void StartCharging()\n    {\n        _isCharging = true;\n        _currentChargeTime = 0f;\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Play();\n            \n        if (_trajectoryLine != null)\n            _trajectoryLine.enabled = true;\n            \n        PlaySound(_drawSound);\n    }\n    \n    private void UpdateCharging()\n    {\n        if (!_isCharging) return;\n        \n        _currentChargeTime += Time.deltaTime;\n        float chargeProgress = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        _currentPower = Mathf.Lerp(_minPower, _maxPower, _chargeCurve.Evaluate(chargeProgress));\n        \n        OnChargeChanged?.Invoke(_currentPower);\n        \n        if (_chargeSound != null && _audioSource != null && !_audioSource.isPlaying)\n        {\n            _audioSource.clip = _chargeSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_isCharging)\n        {\n            UpdateBowString();\n            UpdateTrajectory();\n            UpdateChargeEffect();\n        }\n    }\n    \n    private void UpdateBowString()\n    {\n        if (_bowString == null) return;\n        \n        float pullAmount = _currentPower * _maxStringPull;\n        Vector3 pullDirection = -transform.forward;\n        _bowString.localPosition = _originalStringPosition + pullDirection * pullAmount;\n    }\n    \n    private void UpdateTrajectory()\n    {\n        if (_trajectoryLine == null || _arrowSpawnPoint == null) return;\n        \n        Vector3 velocity = GetArrowVelocity();\n        Vector3 startPos = _arrowSpawnPoint.position;\n        \n        for (int i = 0; i < _trajectoryPoints; i++)\n        {\n            float time = i * _trajectoryTimeStep;\n            Vector3 point = startPos + velocity * time + 0.5f * Physics.gravity * time * time;\n            _trajectoryLine.SetPosition(i, point);\n        }\n    }\n    \n    private void UpdateChargeEffect()\n    {\n        if (_chargeEffect == null) return;\n        \n        var main = _chargeEffect.main;\n        main.startLifetime = _currentPower * 2f;\n        \n        var emission = _chargeEffect.emission;\n        emission.rateOverTime = _currentPower * 50f;\n    }\n    \n    private Vector3 GetArrowVelocity()\n    {\n        Vector3 direction = GetAimDirection();\n        float speed = Mathf.Lerp(_baseArrowSpeed, _maxArrowSpeed, _currentPower);\n        return direction * speed;\n    }\n    \n    private Vector3 GetAimDirection()\n    {\n        if (_playerCamera != null)\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f));\n            return ray.direction;\n        }\n        \n        return transform.forward;\n    }\n    \n    private void FireArrow()\n    {\n        if (_arrowPrefab == null || _arrowSpawnPoint == null) return;\n        \n        GameObject arrow = Instantiate(_arrowPrefab, _arrowSpawnPoint.position, _arrowSpawnPoint.rotation);\n        \n        Rigidbody arrowRb = arrow.GetComponent<Rigidbody>();\n        if (arrowRb == null)\n            arrowRb = arrow.AddComponent<Rigidbody>();\n            \n        Vector3 velocity = GetArrowVelocity();\n        arrowRb.velocity = velocity;\n        \n        Arrow arrowScript = arrow.GetComponent<Arrow>();\n        if (arrowScript == null)\n            arrowScript = arrow.AddComponent<Arrow>();\n            \n        arrowScript.Initialize(_currentPower);\n        \n        OnArrowFired?.Invoke(_currentPower);\n        PlaySound(_releaseSound);\n        ResetBow();\n    }\n    \n    private void ResetBow()\n    {\n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _currentPower = 0f;\n        \n        if (_bowString != null)\n            _bowString.localPosition = _originalStringPosition;\n            \n        if (_trajectoryLine != null)\n            _trajectoryLine.enabled = false;\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _chargeSound)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.loop = false;\n            _audioSource.Play();\n        }\n    }\n    \n    public float GetCurrentPower()\n    {\n        return _currentPower;\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n}\n\npublic class Arrow : MonoBehaviour\n{\n    [Header(\"Arrow Settings\")]\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private float _lifetime = 10f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private float _powerMultiplier = 1f;\n    private bool _hasHit;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    public void Initialize(float powerMultiplier)\n    {\n        _powerMultiplier = powerMultiplier;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        HandleHit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit) return;\n        \n        HandleHit(collision.collider);\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        if (hitCollider.CompareTag(\"Player\"))\n            return;\n            \n        float finalDamage = _damage * _powerMultiplier;\n        \n        if (hitCollider.CompareTag(\"Enemy\"))\n        {\n            var enemyHealth = hitCollider.GetComponent<EnemyHealth>();\n            if (enemyHealth != null)\n                enemyHealth.TakeDamage(finalDamage);\n        }\n        \n        if (_stickToSurfaces)\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.isKinematic = true;\n                _rigidbody.velocity = Vector3.zero;\n            }\n            \n            transform.SetParent(hitCollider.transform);\n        }\n        \n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n        \n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n        \n        if (!_stickToSurfaces)\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n}\n\npublic class EnemyHealth : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioClip _deathSound;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0f, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        OnDeath?.Invoke();\n        \n        if (_deathEffect != null)\n        {\n            Instantiate(_deathEffect, transform.position, transform.rotation);\n        }\n        \n        if (_deathSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n            Destroy(gameObject, _deathSound.length);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExplodingEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"isDead\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when collision occurs with damage dealing object\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_explosion\",\n      \"trigger\": \"when health reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"set isDead to true\"\n        },\n        {\n          \"action\": \"create explosion particle effect at current position\"\n        },\n        {\n          \"action\": \"play explosion sound effect\"\n        },\n        {\n          \"action\": \"find all objects within explosion radius\"\n        },\n        {\n          \"action\": \"apply explosion damage to nearby enemies and player\"\n        },\n        {\n          \"action\": \"apply explosive force to nearby rigidbodies\"\n        },\n        {\n          \"action\": \"destroy this game object after short delay\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplodingEnemy : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    private float _currentHealth;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _explosionDamage = 50f;\n    [SerializeField] private LayerMask _explosionLayers = -1;\n    [SerializeField] private GameObject _explosionEffectPrefab;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _renderer;\n    [SerializeField] private Color _damageColor = Color.red;\n    [SerializeField] private float _damageFlashDuration = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnTakeDamage;\n    \n    private Color _originalColor;\n    private bool _isDead = false;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        \n        if (_renderer == null)\n            _renderer = GetComponent<Renderer>();\n            \n        if (_renderer != null)\n            _originalColor = _renderer.material.color;\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        OnTakeDamage?.Invoke();\n        \n        if (_renderer != null)\n            StartCoroutine(FlashDamage());\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashDamage()\n    {\n        if (_renderer != null)\n        {\n            _renderer.material.color = _damageColor;\n            yield return new WaitForSeconds(_damageFlashDuration);\n            _renderer.material.color = _originalColor;\n        }\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        OnDeath?.Invoke();\n        \n        Explode();\n        \n        Destroy(gameObject);\n    }\n    \n    private void Explode()\n    {\n        Vector3 explosionPosition = transform.position;\n        \n        // Create explosion effect\n        if (_explosionEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_explosionEffectPrefab, explosionPosition, Quaternion.identity);\n            Destroy(effect, 5f);\n        }\n        \n        // Play explosion sound\n        if (_explosionSound != null && _audioSource != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, explosionPosition);\n        }\n        \n        // Find all colliders in explosion radius\n        Collider[] colliders = Physics.OverlapSphere(explosionPosition, _explosionRadius, _explosionLayers);\n        \n        foreach (Collider hit in colliders)\n        {\n            if (hit.gameObject == gameObject) continue;\n            \n            // Apply explosion force\n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, explosionPosition, _explosionRadius);\n            }\n            \n            // Apply damage to other exploding enemies\n            ExplodingEnemy otherEnemy = hit.GetComponent<ExplodingEnemy>();\n            if (otherEnemy != null)\n            {\n                float distance = Vector3.Distance(explosionPosition, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                otherEnemy.TakeDamage(_explosionDamage * damageMultiplier);\n            }\n            \n            // Damage player\n            if (hit.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(explosionPosition, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                float finalDamage = _explosionDamage * damageMultiplier;\n                \n                // Send damage message if player has a method to receive it\n                hit.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            // Optional: Explode on contact with player\n            // Die();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Projectile\"))\n        {\n            TakeDamage(25f);\n            Destroy(collision.gameObject);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    public bool IsDead()\n    {\n        return _isDead;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemySpawner\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"enemyPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"spawnInterval\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"maxEnemies\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"spawnRadius\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_enemy_periodically\",\n      \"trigger\": \"when spawn interval time has elapsed and current enemy count is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"create new enemy instance from prefab\"\n        },\n        {\n          \"action\": \"position enemy at random location within spawn radius around spawner\"\n        },\n        {\n          \"action\": \"reset spawn timer\"\n        },\n        {\n          \"action\": \"increment current enemy count\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_enemy_destruction\",\n      \"trigger\": \"when spawned enemy is destroyed\",\n      \"actions\": [\n        {\n          \"action\": \"decrement current enemy count\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class EnemySpawner : MonoBehaviour\n{\n    [Header(\"Spawn Settings\")]\n    [SerializeField] private GameObject[] _enemyPrefabs;\n    [SerializeField] private Transform[] _spawnPoints;\n    [SerializeField] private float _spawnInterval = 2f;\n    [SerializeField] private int _maxEnemies = 10;\n    [SerializeField] private bool _spawnOnStart = true;\n    \n    [Header(\"Spawn Area (if no spawn points)\")]\n    [SerializeField] private float _spawnRadius = 5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Wave Settings\")]\n    [SerializeField] private bool _useWaves = false;\n    [SerializeField] private int _enemiesPerWave = 5;\n    [SerializeField] private float _timeBetweenWaves = 10f;\n    \n    private List<GameObject> _spawnedEnemies = new List<GameObject>();\n    private Coroutine _spawnCoroutine;\n    private int _currentWaveEnemies = 0;\n    private bool _isSpawning = false;\n    \n    private void Start()\n    {\n        if (_spawnOnStart)\n        {\n            StartSpawning();\n        }\n        \n        ValidateSpawnSettings();\n    }\n    \n    private void ValidateSpawnSettings()\n    {\n        if (_enemyPrefabs == null || _enemyPrefabs.Length == 0)\n        {\n            Debug.LogWarning(\"EnemySpawner: No enemy prefabs assigned!\");\n            return;\n        }\n        \n        if (_spawnPoints == null || _spawnPoints.Length == 0)\n        {\n            Debug.LogWarning(\"EnemySpawner: No spawn points assigned, using random positions around spawner.\");\n        }\n    }\n    \n    public void StartSpawning()\n    {\n        if (_isSpawning) return;\n        \n        _isSpawning = true;\n        \n        if (_useWaves)\n        {\n            _spawnCoroutine = StartCoroutine(SpawnWaves());\n        }\n        else\n        {\n            _spawnCoroutine = StartCoroutine(SpawnContinuous());\n        }\n    }\n    \n    public void StopSpawning()\n    {\n        _isSpawning = false;\n        \n        if (_spawnCoroutine != null)\n        {\n            StopCoroutine(_spawnCoroutine);\n            _spawnCoroutine = null;\n        }\n    }\n    \n    public void ClearAllEnemies()\n    {\n        for (int i = _spawnedEnemies.Count - 1; i >= 0; i--)\n        {\n            if (_spawnedEnemies[i] != null)\n            {\n                Destroy(_spawnedEnemies[i]);\n            }\n        }\n        _spawnedEnemies.Clear();\n    }\n    \n    private IEnumerator SpawnContinuous()\n    {\n        while (_isSpawning)\n        {\n            if (CanSpawn())\n            {\n                SpawnEnemy();\n            }\n            \n            yield return new WaitForSeconds(_spawnInterval);\n        }\n    }\n    \n    private IEnumerator SpawnWaves()\n    {\n        while (_isSpawning)\n        {\n            _currentWaveEnemies = 0;\n            \n            // Spawn wave\n            for (int i = 0; i < _enemiesPerWave; i++)\n            {\n                if (CanSpawn())\n                {\n                    SpawnEnemy();\n                    _currentWaveEnemies++;\n                    yield return new WaitForSeconds(_spawnInterval);\n                }\n            }\n            \n            // Wait for wave to be cleared or timeout\n            float waveTimer = 0f;\n            while (_currentWaveEnemies > 0 && waveTimer < _timeBetweenWaves)\n            {\n                CleanupDestroyedEnemies();\n                waveTimer += Time.deltaTime;\n                yield return null;\n            }\n            \n            yield return new WaitForSeconds(_timeBetweenWaves);\n        }\n    }\n    \n    private bool CanSpawn()\n    {\n        CleanupDestroyedEnemies();\n        return _spawnedEnemies.Count < _maxEnemies && _enemyPrefabs.Length > 0;\n    }\n    \n    private void SpawnEnemy()\n    {\n        GameObject enemyPrefab = _enemyPrefabs[Random.Range(0, _enemyPrefabs.Length)];\n        Vector3 spawnPosition = GetSpawnPosition();\n        \n        if (spawnPosition != Vector3.zero)\n        {\n            GameObject enemy = Instantiate(enemyPrefab, spawnPosition, GetSpawnRotation());\n            _spawnedEnemies.Add(enemy);\n            \n            // Add enemy tracker component\n            EnemyTracker tracker = enemy.GetComponent<EnemyTracker>();\n            if (tracker == null)\n            {\n                tracker = enemy.AddComponent<EnemyTracker>();\n            }\n            tracker.Initialize(this);\n        }\n    }\n    \n    private Vector3 GetSpawnPosition()\n    {\n        if (_spawnPoints != null && _spawnPoints.Length > 0)\n        {\n            Transform spawnPoint = _spawnPoints[Random.Range(0, _spawnPoints.Length)];\n            return spawnPoint != null ? spawnPoint.position : transform.position;\n        }\n        \n        // Random position around spawner\n        Vector2 randomCircle = Random.insideUnitCircle * _spawnRadius;\n        Vector3 randomPosition = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n        \n        // Try to place on ground\n        if (Physics.Raycast(randomPosition + Vector3.up * 10f, Vector3.down, out RaycastHit hit, 20f, _groundLayer))\n        {\n            return hit.point;\n        }\n        \n        return randomPosition;\n    }\n    \n    private Quaternion GetSpawnRotation()\n    {\n        return Quaternion.Euler(0, Random.Range(0, 360), 0);\n    }\n    \n    private void CleanupDestroyedEnemies()\n    {\n        for (int i = _spawnedEnemies.Count - 1; i >= 0; i--)\n        {\n            if (_spawnedEnemies[i] == null)\n            {\n                _spawnedEnemies.RemoveAt(i);\n                if (_useWaves)\n                {\n                    _currentWaveEnemies--;\n                }\n            }\n        }\n    }\n    \n    public void OnEnemyDestroyed(GameObject enemy)\n    {\n        if (_spawnedEnemies.Contains(enemy))\n        {\n            _spawnedEnemies.Remove(enemy);\n            if (_useWaves)\n            {\n                _currentWaveEnemies--;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw spawn radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _spawnRadius);\n        \n        // Draw spawn points\n        if (_spawnPoints != null)\n        {\n            Gizmos.color = Color.red;\n            foreach (Transform spawnPoint in _spawnPoints)\n            {\n                if (spawnPoint != null)\n                {\n                    Gizmos.DrawWireCube(spawnPoint.position, Vector3.one);\n                }\n            }\n        }\n    }\n}\n\npublic class EnemyTracker : MonoBehaviour\n{\n    private EnemySpawner _spawner;\n    \n    public void Initialize(EnemySpawner spawner)\n    {\n        _spawner = spawner;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_spawner != null)\n        {\n            _spawner.OnEnemyDestroyed(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"QuestTrackerDisplay\",\n  \"components\": [\n    \"Canvas\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"questTitleText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"questDescriptionText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"objectivesList\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"objectiveTextPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"fadeOutDuration\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"displayPosition\",\n      \"type\": \"Vector2\",\n      \"default\": {\n        \"x\": 50,\n        \"y\": -50\n      }\n    },\n    {\n      \"name\": \"maxObjectivesToShow\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"autoHideDelay\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_quest_tracker\",\n      \"trigger\": \"when new quest is accepted or quest updates\",\n      \"actions\": [\n        {\n          \"action\": \"fade in the quest tracker display\"\n        },\n        {\n          \"action\": \"update quest title text with current quest name\"\n        },\n        {\n          \"action\": \"update quest description text with current quest details\"\n        },\n        {\n          \"action\": \"clear existing objective list items\"\n        },\n        {\n          \"action\": \"create new objective text items for each active objective\"\n        },\n        {\n          \"action\": \"mark incomplete objectives with bullet points\"\n        },\n        {\n          \"action\": \"mark completed objectives with checkmarks\"\n        },\n        {\n          \"action\": \"position tracker at designated screen location\"\n        },\n        {\n          \"action\": \"set visibility flag to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_quest_tracker\",\n      \"trigger\": \"when quest is completed or player requests to hide tracker\",\n      \"actions\": [\n        {\n          \"action\": \"fade out the quest tracker display\"\n        },\n        {\n          \"action\": \"set visibility flag to false\"\n        },\n        {\n          \"action\": \"clear all quest text content\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_objective_status\",\n      \"trigger\": \"when quest objective progress changes\",\n      \"actions\": [\n        {\n          \"action\": \"find the corresponding objective text item\"\n        },\n        {\n          \"action\": \"update objective text with current progress\"\n        },\n        {\n          \"action\": \"change visual indicator from bullet to checkmark if completed\"\n        },\n        {\n          \"action\": \"apply strikethrough formatting to completed objectives\"\n        },\n        {\n          \"action\": \"play subtle completion animation if objective finished\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_hide_tracker\",\n      \"trigger\": \"when tracker has been visible for auto hide duration\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade out the quest tracker\"\n        },\n        {\n          \"action\": \"set visibility flag to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"toggle_tracker_visibility\",\n      \"trigger\": \"when player presses quest tracker toggle key\",\n      \"actions\": [\n        {\n          \"action\": \"check current visibility state\"\n        },\n        {\n          \"action\": \"show tracker if currently hidden\"\n        },\n        {\n          \"action\": \"hide tracker if currently visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"limit_objective_display\",\n      \"trigger\": \"when quest has more objectives than maximum display limit\",\n      \"actions\": [\n        {\n          \"action\": \"show only the most recent objectives up to maximum limit\"\n        },\n        {\n          \"action\": \"add indicator text showing additional objectives exist\"\n        },\n        {\n          \"action\": \"prioritize incomplete objectives over completed ones\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\nusing System;\n\npublic class QuestTrackerDisplay : MonoBehaviour\n{\n    [System.Serializable]\n    public class Quest\n    {\n        public string questId;\n        public string title;\n        public string description;\n        public List<QuestObjective> objectives;\n        public bool isCompleted;\n        public bool isActive;\n        \n        public Quest(string id, string questTitle, string questDescription)\n        {\n            questId = id;\n            title = questTitle;\n            description = questDescription;\n            objectives = new List<QuestObjective>();\n            isCompleted = false;\n            isActive = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class QuestObjective\n    {\n        public string description;\n        public int currentCount;\n        public int targetCount;\n        public bool isCompleted;\n        \n        public QuestObjective(string desc, int target)\n        {\n            description = desc;\n            currentCount = 0;\n            targetCount = target;\n            isCompleted = false;\n        }\n        \n        public void UpdateProgress(int amount)\n        {\n            currentCount = Mathf.Clamp(currentCount + amount, 0, targetCount);\n            isCompleted = currentCount >= targetCount;\n        }\n    }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _questTrackerPanel;\n    [SerializeField] private Transform _questContainer;\n    [SerializeField] private GameObject _questEntryPrefab;\n    [SerializeField] private Button _toggleButton;\n    [SerializeField] private Text _noQuestsText;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private int _maxDisplayedQuests = 5;\n    [SerializeField] private bool _showCompletedQuests = false;\n    [SerializeField] private bool _autoHideWhenEmpty = true;\n    [SerializeField] private Color _completedQuestColor = Color.green;\n    [SerializeField] private Color _activeQuestColor = Color.white;\n    [SerializeField] private Color _objectiveCompletedColor = Color.gray;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _useAnimations = true;\n    [SerializeField] private float _fadeSpeed = 2f;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private List<Quest> _allQuests = new List<Quest>();\n    private List<GameObject> _questEntryObjects = new List<GameObject>();\n    private bool _isVisible = true;\n    private CanvasGroup _canvasGroup;\n    \n    public static event Action<string> OnQuestCompleted;\n    public static event Action<string, int> OnObjectiveUpdated;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void Start()\n    {\n        InitializeUI();\n        RefreshDisplay();\n        \n        if (_toggleButton != null)\n            _toggleButton.onClick.AddListener(ToggleVisibility);\n    }\n    \n    private void InitializeUI()\n    {\n        if (_questTrackerPanel == null)\n            _questTrackerPanel = gameObject;\n            \n        if (_noQuestsText != null)\n            _noQuestsText.text = \"No active quests\";\n    }\n    \n    public void AddQuest(string questId, string title, string description)\n    {\n        if (GetQuestById(questId) != null)\n            return;\n            \n        Quest newQuest = new Quest(questId, title, description);\n        newQuest.isActive = true;\n        _allQuests.Add(newQuest);\n        RefreshDisplay();\n    }\n    \n    public void AddObjectiveToQuest(string questId, string objectiveDescription, int targetCount)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        QuestObjective objective = new QuestObjective(objectiveDescription, targetCount);\n        quest.objectives.Add(objective);\n        RefreshDisplay();\n    }\n    \n    public void UpdateObjective(string questId, int objectiveIndex, int progressAmount)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null || objectiveIndex < 0 || objectiveIndex >= quest.objectives.Count)\n            return;\n            \n        QuestObjective objective = quest.objectives[objectiveIndex];\n        objective.UpdateProgress(progressAmount);\n        \n        OnObjectiveUpdated?.Invoke(questId, objectiveIndex);\n        \n        CheckQuestCompletion(quest);\n        RefreshDisplay();\n    }\n    \n    public void CompleteQuest(string questId)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        quest.isCompleted = true;\n        quest.isActive = false;\n        \n        foreach (var objective in quest.objectives)\n        {\n            objective.isCompleted = true;\n            objective.currentCount = objective.targetCount;\n        }\n        \n        OnQuestCompleted?.Invoke(questId);\n        RefreshDisplay();\n        \n        if (_useAnimations)\n            StartCoroutine(AnimateQuestCompletion(questId));\n    }\n    \n    public void RemoveQuest(string questId)\n    {\n        Quest quest = GetQuestById(questId);\n        if (quest == null)\n            return;\n            \n        _allQuests.Remove(quest);\n        RefreshDisplay();\n    }\n    \n    private Quest GetQuestById(string questId)\n    {\n        return _allQuests.Find(q => q.questId == questId);\n    }\n    \n    private void CheckQuestCompletion(Quest quest)\n    {\n        if (quest.isCompleted)\n            return;\n            \n        bool allObjectivesComplete = true;\n        foreach (var objective in quest.objectives)\n        {\n            if (!objective.isCompleted)\n            {\n                allObjectivesComplete = false;\n                break;\n            }\n        }\n        \n        if (allObjectivesComplete && quest.objectives.Count > 0)\n        {\n            CompleteQuest(quest.questId);\n        }\n    }\n    \n    private void RefreshDisplay()\n    {\n        ClearQuestEntries();\n        \n        List<Quest> displayQuests = GetQuestsToDisplay();\n        \n        if (displayQuests.Count == 0)\n        {\n            ShowNoQuestsMessage();\n            if (_autoHideWhenEmpty)\n                SetVisibility(false);\n            return;\n        }\n        \n        HideNoQuestsMessage();\n        \n        foreach (Quest quest in displayQuests)\n        {\n            CreateQuestEntry(quest);\n        }\n        \n        if (_autoHideWhenEmpty)\n            SetVisibility(true);\n    }\n    \n    private List<Quest> GetQuestsToDisplay()\n    {\n        List<Quest> displayQuests = new List<Quest>();\n        \n        foreach (Quest quest in _allQuests)\n        {\n            if (quest.isActive || (_showCompletedQuests && quest.isCompleted))\n            {\n                displayQuests.Add(quest);\n            }\n        }\n        \n        if (displayQuests.Count > _maxDisplayedQuests)\n        {\n            displayQuests = displayQuests.GetRange(0, _maxDisplayedQuests);\n        }\n        \n        return displayQuests;\n    }\n    \n    private void CreateQuestEntry(Quest quest)\n    {\n        if (_questEntryPrefab == null || _questContainer == null)\n            return;\n            \n        GameObject entryObject = Instantiate(_questEntryPrefab, _questContainer);\n        _questEntryObjects.Add(entryObject);\n        \n        QuestEntryUI entryUI = entryObject.GetComponent<QuestEntryUI>();\n        if (entryUI == null)\n            entryUI = entryObject.AddComponent<QuestEntryUI>();\n            \n        entryUI.SetupQuestEntry(quest, _completedQuestColor, _activeQuestColor, _objectiveCompletedColor);\n        \n        if (_useAnimations)\n            StartCoroutine(AnimateEntryAppearance(entryObject));\n    }\n    \n    private void ClearQuestEntries()\n    {\n        foreach (GameObject entry in _questEntryObjects)\n        {\n            if (entry != null)\n                DestroyImmediate(entry);\n        }\n        _questEntryObjects.Clear();\n    }\n    \n    private void ShowNoQuestsMessage()\n    {\n        if (_noQuestsText != null)\n            _noQuestsText.gameObject.SetActive(true);\n    }\n    \n    private void HideNoQuestsMessage()\n    {\n        if (_noQuestsText != null)\n            _noQuestsText.gameObject.SetActive(false);\n    }\n    \n    public void ToggleVisibility()\n    {\n        SetVisibility(!_isVisible);\n    }\n    \n    public void SetVisibility(bool visible)\n    {\n        _isVisible = visible;\n        \n        if (_useAnimations)\n        {\n            StopAllCoroutines();\n            StartCoroutine(AnimateVisibility(visible));\n        }\n        else\n        {\n            _questTrackerPanel.SetActive(visible);\n        }\n    }\n    \n    private System.Collections.IEnumerator AnimateVisibility(bool show)\n    {\n        float targetAlpha = show ? 1f : 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        if (show)\n            _questTrackerPanel.SetActive(true);\n        \n        float elapsed = 0f;\n        while (elapsed < 1f / _fadeSpeed)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed * _fadeSpeed;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = targetAlpha;\n        \n        if (!show)\n            _questTrackerPanel.SetActive(false);\n    }\n    \n    private System.Collections.IEnumerator AnimateEntryAppearance(GameObject entry)\n    {\n        Transform entryTransform = entry.transform;\n        Vector3 originalScale = entryTransform.localScale;\n        entryTransform.localScale = Vector3.zero;\n        \n        float elapsed = 0f;\n        float duration = 0.3f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n            float scaleValue = _scaleCurve.Evaluate(progress);\n            entryTransform.localScale = originalScale * scaleValue;\n            yield return null;\n        }\n        \n        entryTransform.localScale = originalScale;\n    }\n    \n    private System.Collections.IEnumerator AnimateQuestCompletion(string questId)\n    {\n        yield return new WaitForSeconds(2f);\n        \n        if (!_showCompletedQuests)\n        {\n            RemoveQuest(questId);\n        }\n    }\n}\n\npublic class QuestEntryUI : MonoBehaviour\n{\n    private Text _titleText;\n    private Text _descriptionText;\n    private Transform _objectivesContainer;\n    private GameObject _objectivePrefab;\n    \n    private void Awake()\n    {\n        FindUIComponents();\n    }\n    \n    private void FindUIComponents()\n    {\n        _titleText = transform.Find(\"Title\")?.GetComponent<Text>();\n        _descriptionText = transform.Find(\"Description\")?.GetComponent<Text>();\n        _objectivesContainer = transform.Find(\"Objectives\");\n        \n        if (_objectivesContainer != null && _objectivesContainer.childCount > 0)\n        {\n            _objectivePrefab = _objectivesContainer.GetChild(0).gameObject;\n            _objectivePrefab.SetActive(false);\n        }\n    }\n    \n    public void SetupQuestEntry(QuestTrackerDisplay.Quest quest, Color completedColor, Color activeColor, Color objectiveCompletedColor)\n    {\n        if (_titleText != null)\n        {\n            _titleText.text = quest.title;\n            _titleText.color = quest.isCompleted ? completedColor : activeColor;\n        }\n        \n        if (_descriptionText != null)\n        {\n            _descriptionText.text = quest.description;\n            _descriptionText.color = quest.isCompleted ? completedColor : activeColor;\n        }\n        \n        SetupObjectives(quest.objectives, objectiveCompletedColor);\n    }\n    \n    private void SetupObjectives(List<QuestTrackerDisplay.QuestObjective> objectives, Color completedColor)\n    {\n        if (_objectivesContainer == null || _objectivePrefab == null)\n            return;\n            \n        foreach (Transform child in _objectivesContainer)\n        {\n            if (child.gameObject != _objectivePrefab)\n                DestroyImmediate(child.gameObject);\n        }\n        \n        foreach (var objective in objectives)\n        {\n            GameObject objEntry = Instantiate(_objectivePrefab, _objectivesContainer);\n            objEntry.SetActive(true);\n            \n            Text objText = objEntry.GetComponent<Text>();\n            if (objText != null)\n            {\n                string progressText = objective.targetCount > 1 ? \n                    $\" ({objective.currentCount}/{objective.targetCount})\" : \"\";\n                objText.text = \"\u2022 \" + objective.description + progressText;\n                objText.color = objective.isCompleted ? completedColor : Color.white;\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EmoteAnimationSystem\",\n  \"components\": [\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"emoteAnimations\",\n      \"type\": \"AnimationClip[]\",\n      \"default\": \"null\"\n    },\n    {\n      \"name\": \"emoteDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"canEmote\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"currentEmoteIndex\",\n      \"type\": \"int\",\n      \"default\": -1\n    },\n    {\n      \"name\": \"emoteNames\",\n      \"type\": \"string[]\",\n      \"default\": \"null\"\n    },\n    {\n      \"name\": \"emoteCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_emote\",\n      \"trigger\": \"when emote input is received\",\n      \"actions\": [\n        {\n          \"action\": \"check if emoting is currently allowed\"\n        },\n        {\n          \"action\": \"select random emote animation from available emotes\"\n        },\n        {\n          \"action\": \"play selected emote animation\"\n        },\n        {\n          \"action\": \"disable emote ability temporarily\"\n        },\n        {\n          \"action\": \"store current emote index\"\n        }\n      ]\n    },\n    {\n      \"name\": \"trigger_specific_emote\",\n      \"trigger\": \"when specific emote number is requested\",\n      \"actions\": [\n        {\n          \"action\": \"check if emoting is currently allowed\"\n        },\n        {\n          \"action\": \"validate emote index is within valid range\"\n        },\n        {\n          \"action\": \"play emote animation at specified index\"\n        },\n        {\n          \"action\": \"disable emote ability temporarily\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_emote\",\n      \"trigger\": \"when emote animation duration completes\",\n      \"actions\": [\n        {\n          \"action\": \"return to idle animation state\"\n        },\n        {\n          \"action\": \"reset current emote index to none\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enable_emoting\",\n      \"trigger\": \"when cooldown period expires\",\n      \"actions\": [\n        {\n          \"action\": \"enable emote ability\"\n        },\n        {\n          \"action\": \"allow new emote inputs\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interrupt_emote\",\n      \"trigger\": \"when movement input is detected during emote\",\n      \"actions\": [\n        {\n          \"action\": \"stop current emote animation\"\n        },\n        {\n          \"action\": \"return to movement animation state\"\n        },\n        {\n          \"action\": \"enable emote ability immediately\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class EmoteAnimationSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class EmoteData\n    {\n        [Header(\"Emote Settings\")]\n        public string emoteName;\n        public KeyCode triggerKey;\n        public AnimationClip animationClip;\n        public float duration = 2f;\n        public bool canInterrupt = true;\n        public bool lockMovement = false;\n        \n        [Header(\"Audio\")]\n        public AudioClip soundEffect;\n        [Range(0f, 1f)]\n        public float volume = 1f;\n        \n        [Header(\"Effects\")]\n        public GameObject particleEffect;\n        public Transform effectSpawnPoint;\n    }\n\n    [Header(\"Emote Configuration\")]\n    [SerializeField] private List<EmoteData> _availableEmotes = new List<EmoteData>();\n    [SerializeField] private bool _enableKeyboardInput = true;\n    [SerializeField] private float _cooldownTime = 0.5f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _emoteParameterName = \"EmoteTrigger\";\n    [SerializeField] private string _emoteIndexParameterName = \"EmoteIndex\";\n    [SerializeField] private bool _useAnimatorParameters = true;\n    \n    [Header(\"Movement Control\")]\n    [SerializeField] private Rigidbody _rigidbody;\n    [SerializeField] private CharacterController _characterController;\n    [SerializeField] private bool _freezePositionDuringEmote = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnEmoteStarted;\n    public UnityEvent<string> OnEmoteFinished;\n    public UnityEvent OnEmoteInterrupted;\n\n    private EmoteData _currentEmote;\n    private bool _isEmoting = false;\n    private float _lastEmoteTime = 0f;\n    private Coroutine _emoteCoroutine;\n    private Vector3 _originalPosition;\n    private bool _wasKinematic = false;\n    private Dictionary<string, int> _emoteIndexMap = new Dictionary<string, int>();\n\n    private void Start()\n    {\n        InitializeComponents();\n        BuildEmoteIndexMap();\n    }\n\n    private void InitializeComponents()\n    {\n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_rigidbody == null)\n            _rigidbody = GetComponent<Rigidbody>();\n            \n        if (_characterController == null)\n            _characterController = GetComponent<CharacterController>();\n    }\n\n    private void BuildEmoteIndexMap()\n    {\n        _emoteIndexMap.Clear();\n        for (int i = 0; i < _availableEmotes.Count; i++)\n        {\n            if (!string.IsNullOrEmpty(_availableEmotes[i].emoteName))\n            {\n                _emoteIndexMap[_availableEmotes[i].emoteName] = i;\n            }\n        }\n    }\n\n    private void Update()\n    {\n        if (_enableKeyboardInput)\n        {\n            HandleKeyboardInput();\n        }\n    }\n\n    private void HandleKeyboardInput()\n    {\n        if (Time.time - _lastEmoteTime < _cooldownTime)\n            return;\n\n        foreach (var emote in _availableEmotes)\n        {\n            if (Input.GetKeyDown(emote.triggerKey))\n            {\n                PlayEmote(emote.emoteName);\n                break;\n            }\n        }\n    }\n\n    public void PlayEmote(string emoteName)\n    {\n        if (string.IsNullOrEmpty(emoteName))\n            return;\n\n        var emoteData = GetEmoteByName(emoteName);\n        if (emoteData == null)\n        {\n            Debug.LogWarning($\"Emote '{emoteName}' not found!\");\n            return;\n        }\n\n        PlayEmote(emoteData);\n    }\n\n    public void PlayEmoteByIndex(int index)\n    {\n        if (index < 0 || index >= _availableEmotes.Count)\n        {\n            Debug.LogWarning($\"Emote index {index} is out of range!\");\n            return;\n        }\n\n        PlayEmote(_availableEmotes[index]);\n    }\n\n    private void PlayEmote(EmoteData emoteData)\n    {\n        if (emoteData == null)\n            return;\n\n        if (Time.time - _lastEmoteTime < _cooldownTime)\n            return;\n\n        if (_isEmoting && !_currentEmote.canInterrupt)\n            return;\n\n        if (_isEmoting)\n        {\n            StopCurrentEmote(true);\n        }\n\n        StartEmote(emoteData);\n    }\n\n    private void StartEmote(EmoteData emoteData)\n    {\n        _currentEmote = emoteData;\n        _isEmoting = true;\n        _lastEmoteTime = Time.time;\n\n        if (_freezePositionDuringEmote && emoteData.lockMovement)\n        {\n            FreezeMovement();\n        }\n\n        PlayEmoteAnimation(emoteData);\n        PlayEmoteAudio(emoteData);\n        SpawnEmoteEffect(emoteData);\n\n        OnEmoteStarted?.Invoke(emoteData.emoteName);\n\n        _emoteCoroutine = StartCoroutine(EmoteCoroutine(emoteData));\n    }\n\n    private void PlayEmoteAnimation(EmoteData emoteData)\n    {\n        if (_animator == null)\n            return;\n\n        if (_useAnimatorParameters)\n        {\n            if (_animator.parameters != null)\n            {\n                foreach (var param in _animator.parameters)\n                {\n                    if (param.name == _emoteParameterName && param.type == AnimatorControllerParameterType.Trigger)\n                    {\n                        _animator.SetTrigger(_emoteParameterName);\n                    }\n                    else if (param.name == _emoteIndexParameterName && param.type == AnimatorControllerParameterType.Int)\n                    {\n                        if (_emoteIndexMap.ContainsKey(emoteData.emoteName))\n                        {\n                            _animator.SetInteger(_emoteIndexParameterName, _emoteIndexMap[emoteData.emoteName]);\n                        }\n                    }\n                }\n            }\n        }\n        else if (emoteData.animationClip != null)\n        {\n            _animator.Play(emoteData.animationClip.name);\n        }\n    }\n\n    private void PlayEmoteAudio(EmoteData emoteData)\n    {\n        if (_audioSource != null && emoteData.soundEffect != null)\n        {\n            _audioSource.clip = emoteData.soundEffect;\n            _audioSource.volume = emoteData.volume;\n            _audioSource.Play();\n        }\n    }\n\n    private void SpawnEmoteEffect(EmoteData emoteData)\n    {\n        if (emoteData.particleEffect != null)\n        {\n            Transform spawnPoint = emoteData.effectSpawnPoint != null ? emoteData.effectSpawnPoint : transform;\n            GameObject effect = Instantiate(emoteData.particleEffect, spawnPoint.position, spawnPoint.rotation);\n            \n            if (emoteData.duration > 0)\n            {\n                Destroy(effect, emoteData.duration + 1f);\n            }\n        }\n    }\n\n    private void FreezeMovement()\n    {\n        _originalPosition = transform.position;\n\n        if (_rigidbody != null)\n        {\n            _wasKinematic = _rigidbody.isKinematic;\n            _rigidbody.isKinematic = true;\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n        }\n    }\n\n    private void UnfreezeMovement()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = _wasKinematic;\n        }\n    }\n\n    private IEnumerator EmoteCoroutine(EmoteData emoteData)\n    {\n        yield return new WaitForSeconds(emoteData.duration);\n        FinishEmote();\n    }\n\n    private void FinishEmote()\n    {\n        if (!_isEmoting)\n            return;\n\n        string emoteName = _currentEmote != null ? _currentEmote.emoteName : \"\";\n        \n        if (_currentEmote != null && _currentEmote.lockMovement)\n        {\n            UnfreezeMovement();\n        }\n\n        _isEmoting = false;\n        _currentEmote = null;\n\n        OnEmoteFinished?.Invoke(emoteName);\n    }\n\n    public void StopCurrentEmote(bool wasInterrupted = false)\n    {\n        if (!_isEmoting)\n            return;\n\n        if (_emoteCoroutine != null)\n        {\n            StopCoroutine(_emoteCoroutine);\n            _emoteCoroutine = null;\n        }\n\n        if (_currentEmote != null && _currentEmote.lockMovement)\n        {\n            UnfreezeMovement();\n        }\n\n        if (wasInterrupted)\n        {\n            OnEmoteInterrupted?.Invoke();\n        }\n\n        _isEmoting = false;\n        _currentEmote = null;\n    }\n\n    private EmoteData GetEmoteByName(string emoteName)\n    {\n        foreach (var emote in _availableEmotes)\n        {\n            if (emote.emoteName.Equals(emoteName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                return emote;\n            }\n        }\n        return null;\n    }\n\n    public bool IsEmoting()\n    {\n        return _isEmoting;\n    }\n\n    public string GetCurrentEmoteName()\n    {\n        return _currentEmote != null ? _currentEmote.emoteName : \"\";\n    }\n\n    public List<string> GetAvailableEmoteNames()\n    {\n        List<string> names = new List<string>();\n        foreach (var emote in _availableEmotes)\n        {\n            if (!string.IsNullOrEmpty(emote.emoteName))\n            {\n                names.Add(emote.emoteName);\n            }\n        }\n        return names;\n    }\n\n    public void AddEmote(EmoteData newEmote)\n    {\n        if (newEmote != null && !string.IsNullOrEmpty(newEmote.emoteName))\n        {\n            _availableEmotes.Add(newEmote);\n            BuildEmoteIndexMap();\n        }\n    }\n\n    public void RemoveEmote(string emoteName)\n    {\n        for (int i = _availableEmotes.Count - 1; i >= 0; i--)\n        {\n            if (_availableEmotes[i].emoteName.Equals(emoteName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                _availableEmotes.RemoveAt(i);\n                BuildEmoteIndexMap();\n                break;\n            }\n        }\n    }\n\n    private void OnDisable()\n    {\n        StopCurrentEmote();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LaserWeapon\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"beamWidth\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"energyCost\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"overheatingThreshold\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"coolingRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"currentHeat\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"currentEnergy\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isFiring\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isOverheated\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_firing\",\n      \"trigger\": \"when fire input is pressed and weapon is not overheated and has energy\",\n      \"actions\": [\n        {\n          \"action\": \"set firing state to true\"\n        },\n        {\n          \"action\": \"enable laser beam visual\"\n        },\n        {\n          \"action\": \"play laser firing sound\"\n        },\n        {\n          \"action\": \"cast ray from weapon position in forward direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_beam\",\n      \"trigger\": \"while firing state is active\",\n      \"actions\": [\n        {\n          \"action\": \"update laser beam endpoint to hit position or max range\"\n        },\n        {\n          \"action\": \"apply damage to hit target continuously\"\n        },\n        {\n          \"action\": \"increase weapon heat over time\"\n        },\n        {\n          \"action\": \"decrease energy over time\"\n        },\n        {\n          \"action\": \"create sparks effect at beam impact point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_firing\",\n      \"trigger\": \"when fire input is released or energy depleted or weapon overheats\",\n      \"actions\": [\n        {\n          \"action\": \"set firing state to false\"\n        },\n        {\n          \"action\": \"disable laser beam visual\"\n        },\n        {\n          \"action\": \"stop laser firing sound\"\n        },\n        {\n          \"action\": \"play weapon cooldown sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"weapon_cooling\",\n      \"trigger\": \"when weapon is not firing\",\n      \"actions\": [\n        {\n          \"action\": \"decrease weapon heat over time\"\n        },\n        {\n          \"action\": \"regenerate energy slowly over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"overheat_protection\",\n      \"trigger\": \"when weapon heat exceeds overheating threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set overheated state to true\"\n        },\n        {\n          \"action\": \"force stop firing\"\n        },\n        {\n          \"action\": \"play overheating warning sound\"\n        },\n        {\n          \"action\": \"show overheating visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooldown_complete\",\n      \"trigger\": \"when overheated weapon heat drops below safe threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set overheated state to false\"\n        },\n        {\n          \"action\": \"play ready sound\"\n        },\n        {\n          \"action\": \"hide overheating visual effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LaserWeapon : MonoBehaviour\n{\n    [Header(\"Laser Configuration\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private LineRenderer _laserLine;\n    [SerializeField] private ParticleSystem _muzzleEffect;\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private float _maxRange = 100f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageInterval = 0.1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Color _laserColor = Color.red;\n    [SerializeField] private float _laserWidth = 0.1f;\n    [SerializeField] private Material _laserMaterial;\n    [SerializeField] private Light _laserLight;\n    [SerializeField] private float _lightIntensity = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Mouse0;\n    [SerializeField] private bool _useInput = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLaserStart;\n    public UnityEvent OnLaserStop;\n    public UnityEvent<Vector3> OnLaserHit;\n    \n    private bool _isFiring;\n    private float _lastDamageTime;\n    private RaycastHit _currentHit;\n    private GameObject _currentTarget;\n    private TargetHealth _currentTargetHealth;\n    \n    [System.Serializable]\n    public class TargetHealth\n    {\n        public float maxHealth = 100f;\n        public float currentHealth;\n        public bool isDead;\n        \n        public TargetHealth(float health)\n        {\n            maxHealth = health;\n            currentHealth = health;\n            isDead = false;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            if (isDead) return;\n            \n            currentHealth -= damage;\n            if (currentHealth <= 0)\n            {\n                currentHealth = 0;\n                isDead = true;\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeLaser();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateLaser();\n    }\n    \n    private void InitializeLaser()\n    {\n        if (_laserLine == null)\n        {\n            _laserLine = GetComponent<LineRenderer>();\n            if (_laserLine == null)\n            {\n                _laserLine = gameObject.AddComponent<LineRenderer>();\n            }\n        }\n        \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupLineRenderer();\n        SetupLight();\n        \n        _laserLine.enabled = false;\n        if (_laserLight != null)\n            _laserLight.enabled = false;\n    }\n    \n    private void SetupLineRenderer()\n    {\n        _laserLine.positionCount = 2;\n        _laserLine.startWidth = _laserWidth;\n        _laserLine.endWidth = _laserWidth;\n        _laserLine.color = _laserColor;\n        _laserLine.useWorldSpace = true;\n        \n        if (_laserMaterial != null)\n            _laserLine.material = _laserMaterial;\n    }\n    \n    private void SetupLight()\n    {\n        if (_laserLight == null)\n        {\n            GameObject lightObj = new GameObject(\"LaserLight\");\n            lightObj.transform.SetParent(_firePoint);\n            lightObj.transform.localPosition = Vector3.zero;\n            _laserLight = lightObj.AddComponent<Light>();\n        }\n        \n        _laserLight.type = LightType.Spot;\n        _laserLight.color = _laserColor;\n        _laserLight.intensity = _lightIntensity;\n        _laserLight.range = _maxRange;\n        _laserLight.spotAngle = 30f;\n    }\n    \n    private void HandleInput()\n    {\n        if (!_useInput) return;\n        \n        if (Input.GetKeyDown(_fireKey))\n        {\n            StartFiring();\n        }\n        else if (Input.GetKeyUp(_fireKey))\n        {\n            StopFiring();\n        }\n    }\n    \n    public void StartFiring()\n    {\n        if (_isFiring) return;\n        \n        _isFiring = true;\n        _laserLine.enabled = true;\n        \n        if (_laserLight != null)\n            _laserLight.enabled = true;\n            \n        if (_muzzleEffect != null)\n            _muzzleEffect.Play();\n            \n        PlayFireSound();\n        OnLaserStart?.Invoke();\n    }\n    \n    public void StopFiring()\n    {\n        if (!_isFiring) return;\n        \n        _isFiring = false;\n        _laserLine.enabled = false;\n        \n        if (_laserLight != null)\n            _laserLight.enabled = false;\n            \n        if (_muzzleEffect != null)\n            _muzzleEffect.Stop();\n            \n        if (_hitEffect != null)\n            _hitEffect.Stop();\n            \n        StopFireSound();\n        _currentTarget = null;\n        _currentTargetHealth = null;\n        OnLaserStop?.Invoke();\n    }\n    \n    private void UpdateLaser()\n    {\n        if (!_isFiring) return;\n        \n        Vector3 startPos = _firePoint.position;\n        Vector3 direction = _firePoint.forward;\n        Vector3 endPos = startPos + direction * _maxRange;\n        \n        if (Physics.Raycast(startPos, direction, out _currentHit, _maxRange, _targetLayers))\n        {\n            endPos = _currentHit.point;\n            HandleHit();\n        }\n        else\n        {\n            _currentTarget = null;\n            _currentTargetHealth = null;\n            if (_hitEffect != null)\n                _hitEffect.Stop();\n        }\n        \n        _laserLine.SetPosition(0, startPos);\n        _laserLine.SetPosition(1, endPos);\n        \n        if (_laserLight != null)\n        {\n            _laserLight.transform.position = startPos;\n            _laserLight.transform.LookAt(endPos);\n        }\n    }\n    \n    private void HandleHit()\n    {\n        if (_currentHit.collider == null) return;\n        \n        // Visual effects\n        if (_hitEffect != null)\n        {\n            _hitEffect.transform.position = _currentHit.point;\n            _hitEffect.transform.LookAt(_currentHit.point + _currentHit.normal);\n            if (!_hitEffect.isPlaying)\n                _hitEffect.Play();\n        }\n        \n        // Damage handling\n        if (Time.time >= _lastDamageTime + _damageInterval)\n        {\n            ApplyDamage(_currentHit.collider.gameObject);\n            _lastDamageTime = Time.time;\n            OnLaserHit?.Invoke(_currentHit.point);\n        }\n    }\n    \n    private void ApplyDamage(GameObject target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            // Handle player damage\n            HandlePlayerDamage(target);\n        }\n        else if (target.CompareTag(\"Enemy\"))\n        {\n            // Handle enemy damage\n            HandleEnemyDamage(target);\n        }\n        else\n        {\n            // Handle other objects\n            HandleGenericDamage(target);\n        }\n        \n        PlayHitSound();\n    }\n    \n    private void HandlePlayerDamage(GameObject player)\n    {\n        // Send damage message if the player has a damage receiver\n        player.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void HandleEnemyDamage(GameObject enemy)\n    {\n        if (_currentTarget != enemy)\n        {\n            _currentTarget = enemy;\n            _currentTargetHealth = enemy.GetComponent<TargetHealth>();\n            \n            if (_currentTargetHealth == null)\n            {\n                _currentTargetHealth = enemy.AddComponent<TargetHealth>();\n                _currentTargetHealth.maxHealth = 100f;\n                _currentTargetHealth.currentHealth = 100f;\n            }\n        }\n        \n        if (_currentTargetHealth != null && !_currentTargetHealth.isDead)\n        {\n            _currentTargetHealth.TakeDamage(_damage);\n            \n            if (_currentTargetHealth.isDead)\n            {\n                DestroyTarget(enemy);\n            }\n        }\n    }\n    \n    private void HandleGenericDamage(GameObject target)\n    {\n        // Try to send damage message\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Check for destructible objects\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    private void DestroyTarget(GameObject target)\n    {\n        // Add explosion effect if available\n        if (_hitEffect != null)\n        {\n            ParticleSystem explosion = Instantiate(_hitEffect, target.transform.position, Quaternion.identity);\n            explosion.Play();\n            Destroy(explosion.gameObject, 2f);\n        }\n        \n        Destroy(target);\n        _currentTarget = null;\n        _currentTargetHealth = null;\n    }\n    \n    private void PlayFireSound()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.clip = _fireSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopFireSound()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        StopFiring();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_firePoint == null) return;\n        \n        Gizmos.color = _laserColor;\n        Gizmos.DrawRay(_firePoint.position, _firePoint.forward * _maxRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VignetteDarkness\",\n  \"components\": [\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"vignetteIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"vignetteSize\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"vignetteSmoothness\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"vignetteColor\",\n      \"type\": \"Color\",\n      \"default\": \"black\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_vignette_effect\",\n      \"trigger\": \"when camera renders the scene\",\n      \"actions\": [\n        {\n          \"action\": \"create circular gradient from center to edges\"\n        },\n        {\n          \"action\": \"darken pixels based on distance from screen center\"\n        },\n        {\n          \"action\": \"apply vignette color to edge areas\"\n        },\n        {\n          \"action\": \"blend darkness effect with original image\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_vignette_intensity\",\n      \"trigger\": \"when vignette intensity value changes\",\n      \"actions\": [\n        {\n          \"action\": \"update darkness strength at screen edges\"\n        },\n        {\n          \"action\": \"recalculate vignette gradient\"\n        }\n      ]\n    },\n    {\n      \"name\": \"modify_vignette_size\",\n      \"trigger\": \"when vignette size value changes\",\n      \"actions\": [\n        {\n          \"action\": \"adjust radius of clear center area\"\n        },\n        {\n          \"action\": \"update falloff distance to edges\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class VignetteEffect : MonoBehaviour\n{\n    [Header(\"Vignette Settings\")]\n    [SerializeField] private float _vignetteIntensity = 0.5f;\n    [SerializeField] private float _vignetteSmoothness = 0.3f;\n    [SerializeField] private Color _vignetteColor = Color.black;\n    [SerializeField] private bool _animateVignette = false;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _animationSpeed = 1f;\n    [SerializeField] private float _minIntensity = 0.2f;\n    [SerializeField] private float _maxIntensity = 0.8f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _triggerOnPlayerNear = false;\n    [SerializeField] private float _triggerDistance = 5f;\n    [SerializeField] private float _transitionSpeed = 2f;\n    \n    private Material _vignetteMaterial;\n    private Camera _camera;\n    private float _currentIntensity;\n    private float _targetIntensity;\n    private Transform _player;\n    \n    private static readonly int IntensityProperty = Shader.PropertyToID(\"_Intensity\");\n    private static readonly int SmoothnessProperty = Shader.PropertyToID(\"_Smoothness\");\n    private static readonly int ColorProperty = Shader.PropertyToID(\"_Color\");\n    \n    void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n        {\n            _camera = Camera.main;\n        }\n        \n        CreateVignetteMaterial();\n        _currentIntensity = _vignetteIntensity;\n        _targetIntensity = _vignetteIntensity;\n        \n        if (_triggerOnPlayerNear)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n            {\n                _player = playerObject.transform;\n            }\n        }\n    }\n    \n    void CreateVignetteMaterial()\n    {\n        Shader vignetteShader = Shader.Find(\"Hidden/VignetteShader\");\n        if (vignetteShader == null)\n        {\n            vignetteShader = CreateVignetteShader();\n        }\n        \n        _vignetteMaterial = new Material(vignetteShader);\n        _vignetteMaterial.SetFloat(IntensityProperty, _vignetteIntensity);\n        _vignetteMaterial.SetFloat(SmoothnessProperty, _vignetteSmoothness);\n        _vignetteMaterial.SetColor(ColorProperty, _vignetteColor);\n    }\n    \n    Shader CreateVignetteShader()\n    {\n        string shaderCode = @\"\n        Shader \"\"Hidden/VignetteShader\"\"\n        {\n            Properties\n            {\n                _MainTex (\"\"Texture\"\", 2D) = \"\"white\"\" {}\n                _Intensity (\"\"Intensity\"\", Range(0, 1)) = 0.5\n                _Smoothness (\"\"Smoothness\"\", Range(0, 1)) = 0.3\n                _Color (\"\"Color\"\", Color) = (0,0,0,1)\n            }\n            SubShader\n            {\n                Tags { \"\"RenderType\"\"=\"\"Opaque\"\" }\n                Pass\n                {\n                    CGPROGRAM\n                    #pragma vertex vert\n                    #pragma fragment frag\n                    #include \"\"UnityCG.cginc\"\"\n                    \n                    struct appdata\n                    {\n                        float4 vertex : POSITION;\n                        float2 uv : TEXCOORD0;\n                    };\n                    \n                    struct v2f\n                    {\n                        float2 uv : TEXCOORD0;\n                        float4 vertex : SV_POSITION;\n                    };\n                    \n                    sampler2D _MainTex;\n                    float _Intensity;\n                    float _Smoothness;\n                    fixed4 _Color;\n                    \n                    v2f vert (appdata v)\n                    {\n                        v2f o;\n                        o.vertex = UnityObjectToClipPos(v.vertex);\n                        o.uv = v.uv;\n                        return o;\n                    }\n                    \n                    fixed4 frag (v2f i) : SV_Target\n                    {\n                        fixed4 col = tex2D(_MainTex, i.uv);\n                        float2 center = float2(0.5, 0.5);\n                        float dist = distance(i.uv, center);\n                        float vignette = smoothstep(0.5 - _Smoothness, 0.5, dist);\n                        vignette = pow(vignette, 2);\n                        col.rgb = lerp(col.rgb, _Color.rgb, vignette * _Intensity);\n                        return col;\n                    }\n                    ENDCG\n                }\n            }\n        }\";\n        \n        return Shader.Find(\"Hidden/VignetteShader\");\n    }\n    \n    void Update()\n    {\n        if (_animateVignette)\n        {\n            float animatedIntensity = Mathf.Lerp(_minIntensity, _maxIntensity, \n                (Mathf.Sin(Time.time * _animationSpeed) + 1f) * 0.5f);\n            _targetIntensity = animatedIntensity;\n        }\n        \n        if (_triggerOnPlayerNear && _player != null)\n        {\n            float distance = Vector3.Distance(transform.position, _player.position);\n            if (distance <= _triggerDistance)\n            {\n                _targetIntensity = _maxIntensity;\n            }\n            else\n            {\n                _targetIntensity = _vignetteIntensity;\n            }\n        }\n        \n        _currentIntensity = Mathf.Lerp(_currentIntensity, _targetIntensity, \n            Time.deltaTime * _transitionSpeed);\n        \n        if (_vignetteMaterial != null)\n        {\n            _vignetteMaterial.SetFloat(IntensityProperty, _currentIntensity);\n            _vignetteMaterial.SetFloat(SmoothnessProperty, _vignetteSmoothness);\n            _vignetteMaterial.SetColor(ColorProperty, _vignetteColor);\n        }\n    }\n    \n    void OnRenderImage(RenderTexture source, RenderTexture destination)\n    {\n        if (_vignetteMaterial != null)\n        {\n            Graphics.Blit(source, destination, _vignetteMaterial);\n        }\n        else\n        {\n            Graphics.Blit(source, destination);\n        }\n    }\n    \n    public void SetVignetteIntensity(float intensity)\n    {\n        _vignetteIntensity = Mathf.Clamp01(intensity);\n        if (!_animateVignette && !_triggerOnPlayerNear)\n        {\n            _targetIntensity = _vignetteIntensity;\n        }\n    }\n    \n    public void SetVignetteSmoothness(float smoothness)\n    {\n        _vignetteSmoothness = Mathf.Clamp01(smoothness);\n    }\n    \n    public void SetVignetteColor(Color color)\n    {\n        _vignetteColor = color;\n    }\n    \n    public void EnableAnimation(bool enable)\n    {\n        _animateVignette = enable;\n        if (!enable)\n        {\n            _targetIntensity = _vignetteIntensity;\n        }\n    }\n    \n    public void TriggerVignetteEffect(float duration)\n    {\n        StartCoroutine(VignetteEffectCoroutine(duration));\n    }\n    \n    private System.Collections.IEnumerator VignetteEffectCoroutine(float duration)\n    {\n        float originalTarget = _targetIntensity;\n        _targetIntensity = _maxIntensity;\n        \n        yield return new WaitForSeconds(duration);\n        \n        _targetIntensity = originalTarget;\n    }\n    \n    void OnDestroy()\n    {\n        if (_vignetteMaterial != null)\n        {\n            DestroyImmediate(_vignetteMaterial);\n        }\n    }\n    \n    void OnValidate()\n    {\n        _vignetteIntensity = Mathf.Clamp01(_vignetteIntensity);\n        _vignetteSmoothness = Mathf.Clamp01(_vignetteSmoothness);\n        _minIntensity = Mathf.Clamp01(_minIntensity);\n        _maxIntensity = Mathf.Clamp01(_maxIntensity);\n        _triggerDistance = Mathf.Max(0f, _triggerDistance);\n        _animationSpeed = Mathf.Max(0f, _animationSpeed);\n        _transitionSpeed = Mathf.Max(0f, _transitionSpeed);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerJump\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxJumpTime\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isJumping\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"jumpTimeCounter\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_jump\",\n      \"trigger\": \"when jump input is pressed and player is grounded\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force to rigidbody\"\n        },\n        {\n          \"action\": \"set jumping state to true\"\n        },\n        {\n          \"action\": \"reset jump time counter\"\n        },\n        {\n          \"action\": \"set grounded state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continue_jump\",\n      \"trigger\": \"when jump input is held and player is jumping and jump time is less than maximum\",\n      \"actions\": [\n        {\n          \"action\": \"apply additional upward force to rigidbody\"\n        },\n        {\n          \"action\": \"increment jump time counter\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_jump\",\n      \"trigger\": \"when jump input is released or maximum jump time is reached\",\n      \"actions\": [\n        {\n          \"action\": \"set jumping state to false\"\n        },\n        {\n          \"action\": \"reset jump time counter\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ground_detection\",\n      \"trigger\": \"when player collides with ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"set grounded state to true\"\n        },\n        {\n          \"action\": \"set jumping state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PlayerJump : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _variableJumpMultiplier = 0.5f;\n    [SerializeField] private float _maxJumpTime = 0.3f;\n    [SerializeField] private float _fallMultiplier = 2.5f;\n    [SerializeField] private float _lowJumpMultiplier = 2f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheck;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _jumpKey = KeyCode.Space;\n    \n    private Rigidbody2D _rigidbody;\n    private bool _isGrounded;\n    private bool _isJumping;\n    private float _jumpTimeCounter;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"PlayerJump requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_groundCheck == null)\n        {\n            GameObject groundCheckObj = new GameObject(\"GroundCheck\");\n            groundCheckObj.transform.SetParent(transform);\n            groundCheckObj.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheck = groundCheckObj.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleJumpInput();\n        ApplyVariableJump();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBetterJump();\n    }\n    \n    private void CheckGrounded()\n    {\n        _isGrounded = Physics2D.OverlapCircle(_groundCheck.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    private void HandleJumpInput()\n    {\n        if (Input.GetKeyDown(_jumpKey) && _isGrounded)\n        {\n            StartJump();\n        }\n        \n        if (Input.GetKey(_jumpKey) && _isJumping)\n        {\n            if (_jumpTimeCounter > 0)\n            {\n                _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, _jumpForce);\n                _jumpTimeCounter -= Time.deltaTime;\n            }\n            else\n            {\n                _isJumping = false;\n            }\n        }\n        \n        if (Input.GetKeyUp(_jumpKey))\n        {\n            _isJumping = false;\n        }\n    }\n    \n    private void StartJump()\n    {\n        _isJumping = true;\n        _jumpTimeCounter = _maxJumpTime;\n        _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, _jumpForce);\n    }\n    \n    private void ApplyVariableJump()\n    {\n        if (_rigidbody.velocity.y < 0 && !Input.GetKey(_jumpKey))\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_lowJumpMultiplier - 1) * Time.deltaTime;\n        }\n    }\n    \n    private void ApplyBetterJump()\n    {\n        if (_rigidbody.velocity.y < 0)\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_fallMultiplier - 1) * Time.deltaTime;\n        }\n        else if (_rigidbody.velocity.y > 0 && !Input.GetKey(_jumpKey))\n        {\n            _rigidbody.velocity += Vector2.up * Physics2D.gravity.y * (_lowJumpMultiplier - 1) * Time.deltaTime;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheck != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheck.position, _groundCheckRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TooltipOnHover\",\n  \"components\": [\n    \"EventTrigger\",\n    \"Canvas\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"tooltipText\",\n      \"type\": \"string\",\n      \"default\": \"Item Description\"\n    },\n    {\n      \"name\": \"tooltipPanel\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"offsetPosition\",\n      \"type\": \"Vector2\",\n      \"default\": {\n        \"x\": 10,\n        \"y\": 10\n      }\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_tooltip_on_hover\",\n      \"trigger\": \"when mouse cursor enters the item area\",\n      \"actions\": [\n        {\n          \"action\": \"make tooltip panel visible\"\n        },\n        {\n          \"action\": \"position tooltip panel near mouse cursor with offset\"\n        },\n        {\n          \"action\": \"display tooltip text in the panel\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_tooltip_on_exit\",\n      \"trigger\": \"when mouse cursor leaves the item area\",\n      \"actions\": [\n        {\n          \"action\": \"make tooltip panel invisible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"follow_mouse_while_hovering\",\n      \"trigger\": \"while mouse cursor is over the item area\",\n      \"actions\": [\n        {\n          \"action\": \"update tooltip panel position to follow mouse cursor\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing TMPro;\n\npublic class TooltipOnHover : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerMoveHandler\n{\n    [Header(\"Tooltip Settings\")]\n    [SerializeField] private string _tooltipTitle = \"Item Name\";\n    [SerializeField] private string _tooltipDescription = \"Item description goes here\";\n    [SerializeField] private Sprite _tooltipIcon;\n    [SerializeField] private float _showDelay = 0.5f;\n    [SerializeField] private Vector2 _offset = new Vector2(10f, 10f);\n    \n    [Header(\"Tooltip Prefab\")]\n    [SerializeField] private GameObject _tooltipPrefab;\n    \n    private static TooltipDisplay _currentTooltip;\n    private static Canvas _tooltipCanvas;\n    private Coroutine _showTooltipCoroutine;\n    \n    private void Start()\n    {\n        if (_tooltipCanvas == null)\n        {\n            CreateTooltipCanvas();\n        }\n    }\n    \n    private void CreateTooltipCanvas()\n    {\n        GameObject canvasGO = new GameObject(\"TooltipCanvas\");\n        _tooltipCanvas = canvasGO.AddComponent<Canvas>();\n        _tooltipCanvas.renderMode = RenderMode.ScreenSpaceOverlay;\n        _tooltipCanvas.sortingOrder = 1000;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;\n        scaler.referenceResolution = new Vector2(1920, 1080);\n        \n        canvasGO.AddComponent<GraphicRaycaster>();\n        DontDestroyOnLoad(canvasGO);\n    }\n    \n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        _showTooltipCoroutine = StartCoroutine(ShowTooltipAfterDelay());\n    }\n    \n    public void OnPointerExit(PointerEventData eventData)\n    {\n        if (_showTooltipCoroutine != null)\n        {\n            StopCoroutine(_showTooltipCoroutine);\n            _showTooltipCoroutine = null;\n        }\n        HideTooltip();\n    }\n    \n    public void OnPointerMove(PointerEventData eventData)\n    {\n        if (_currentTooltip != null)\n        {\n            UpdateTooltipPosition(eventData.position);\n        }\n    }\n    \n    private System.Collections.IEnumerator ShowTooltipAfterDelay()\n    {\n        yield return new WaitForSeconds(_showDelay);\n        ShowTooltip();\n    }\n    \n    private void ShowTooltip()\n    {\n        if (_tooltipCanvas == null) return;\n        \n        HideTooltip();\n        \n        GameObject tooltipGO;\n        if (_tooltipPrefab != null)\n        {\n            tooltipGO = Instantiate(_tooltipPrefab, _tooltipCanvas.transform);\n        }\n        else\n        {\n            tooltipGO = CreateDefaultTooltip();\n        }\n        \n        _currentTooltip = tooltipGO.GetComponent<TooltipDisplay>();\n        if (_currentTooltip == null)\n        {\n            _currentTooltip = tooltipGO.AddComponent<TooltipDisplay>();\n        }\n        \n        _currentTooltip.SetupTooltip(_tooltipTitle, _tooltipDescription, _tooltipIcon);\n        UpdateTooltipPosition(Input.mousePosition);\n    }\n    \n    private GameObject CreateDefaultTooltip()\n    {\n        GameObject tooltipGO = new GameObject(\"Tooltip\");\n        tooltipGO.transform.SetParent(_tooltipCanvas.transform);\n        \n        Image background = tooltipGO.AddComponent<Image>();\n        background.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);\n        \n        RectTransform rectTransform = tooltipGO.GetComponent<RectTransform>();\n        rectTransform.sizeDelta = new Vector2(300, 100);\n        \n        GameObject textGO = new GameObject(\"Text\");\n        textGO.transform.SetParent(tooltipGO.transform);\n        \n        TextMeshProUGUI text = textGO.AddComponent<TextMeshProUGUI>();\n        text.text = _tooltipTitle + \"\\n\" + _tooltipDescription;\n        text.fontSize = 14;\n        text.color = Color.white;\n        text.alignment = TextAlignmentOptions.TopLeft;\n        \n        RectTransform textRect = textGO.GetComponent<RectTransform>();\n        textRect.anchorMin = Vector2.zero;\n        textRect.anchorMax = Vector2.one;\n        textRect.offsetMin = new Vector2(10, 10);\n        textRect.offsetMax = new Vector2(-10, -10);\n        \n        return tooltipGO;\n    }\n    \n    private void UpdateTooltipPosition(Vector2 mousePosition)\n    {\n        if (_currentTooltip == null) return;\n        \n        RectTransform tooltipRect = _currentTooltip.GetComponent<RectTransform>();\n        Vector2 position = mousePosition + _offset;\n        \n        Vector2 screenSize = new Vector2(Screen.width, Screen.height);\n        Vector2 tooltipSize = tooltipRect.sizeDelta;\n        \n        if (position.x + tooltipSize.x > screenSize.x)\n        {\n            position.x = mousePosition.x - tooltipSize.x - _offset.x;\n        }\n        \n        if (position.y - tooltipSize.y < 0)\n        {\n            position.y = mousePosition.y + tooltipSize.y + _offset.y;\n        }\n        \n        tooltipRect.position = position;\n    }\n    \n    private void HideTooltip()\n    {\n        if (_currentTooltip != null)\n        {\n            Destroy(_currentTooltip.gameObject);\n            _currentTooltip = null;\n        }\n    }\n    \n    public void SetTooltipContent(string title, string description, Sprite icon = null)\n    {\n        _tooltipTitle = title;\n        _tooltipDescription = description;\n        _tooltipIcon = icon;\n    }\n}\n\npublic class TooltipDisplay : MonoBehaviour\n{\n    private TextMeshProUGUI _titleText;\n    private TextMeshProUGUI _descriptionText;\n    private Image _iconImage;\n    \n    private void Awake()\n    {\n        SetupComponents();\n    }\n    \n    private void SetupComponents()\n    {\n        Transform titleTransform = transform.Find(\"Title\");\n        if (titleTransform != null)\n        {\n            _titleText = titleTransform.GetComponent<TextMeshProUGUI>();\n        }\n        \n        Transform descTransform = transform.Find(\"Description\");\n        if (descTransform != null)\n        {\n            _descriptionText = descTransform.GetComponent<TextMeshProUGUI>();\n        }\n        \n        Transform iconTransform = transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            _iconImage = iconTransform.GetComponent<Image>();\n        }\n    }\n    \n    public void SetupTooltip(string title, string description, Sprite icon)\n    {\n        if (_titleText != null)\n        {\n            _titleText.text = title;\n        }\n        \n        if (_descriptionText != null)\n        {\n            _descriptionText.text = description;\n        }\n        \n        if (_iconImage != null && icon != null)\n        {\n            _iconImage.sprite = icon;\n            _iconImage.gameObject.SetActive(true);\n        }\n        else if (_iconImage != null)\n        {\n            _iconImage.gameObject.SetActive(false);\n        }\n        \n        LayoutRebuilder.ForceRebuildLayoutImmediate(GetComponent<RectTransform>());\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CurrencyBag\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"goldAmount\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"collectSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"sparkleEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"collect_currency\",\n      \"trigger\": \"when player touches the currency bag\",\n      \"actions\": [\n        {\n          \"action\": \"add gold amount to player inventory\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"spawn sparkle particle effect at bag position\"\n        },\n        {\n          \"action\": \"mark bag as collected\"\n        },\n        {\n          \"action\": \"destroy the currency bag object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_animation\",\n      \"trigger\": \"continuously while bag exists and not collected\",\n      \"actions\": [\n        {\n          \"action\": \"gently rotate the bag around vertical axis\"\n        },\n        {\n          \"action\": \"bob up and down slightly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attract_attention\",\n      \"trigger\": \"when player is nearby but not touching\",\n      \"actions\": [\n        {\n          \"action\": \"increase rotation speed slightly\"\n        },\n        {\n          \"action\": \"emit golden glow effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class CurrencyBag : MonoBehaviour\n{\n    [Header(\"Currency Settings\")]\n    [SerializeField] private int _goldAmount = 100;\n    [SerializeField] private bool _isCollected = false;\n    [SerializeField] private float _collectDistance = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _coinPrefab;\n    [SerializeField] private Transform _coinSpawnPoint;\n    [SerializeField] private int _coinCount = 5;\n    [SerializeField] private float _coinSpawnRadius = 1f;\n    [SerializeField] private float _coinSpawnForce = 5f;\n    [SerializeField] private ParticleSystem _collectEffect;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.2f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private AudioClip _coinSpillSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnGoldCollected;\n    public UnityEvent OnBagDestroyed;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private bool _isSpillingCoins = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        \n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_collider).isTrigger = true;\n            ((SphereCollider)_collider).radius = _collectDistance;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_coinSpawnPoint == null)\n        {\n            _coinSpawnPoint = transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        AnimateBag();\n        CheckForPlayerNearby();\n    }\n    \n    private void AnimateBag()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _startPosition + Vector3.up * bobOffset;\n        \n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayerNearby()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _collectDistance);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                CollectBag();\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectBag();\n        }\n    }\n    \n    private void CollectBag()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        SpillCoins();\n        PlayCollectEffects();\n        OnGoldCollected?.Invoke(_goldAmount);\n        \n        StartCoroutine(DestroyAfterDelay(2f));\n    }\n    \n    private void SpillCoins()\n    {\n        if (_coinPrefab == null || _isSpillingCoins) return;\n        \n        _isSpillingCoins = true;\n        \n        if (_coinSpillSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_coinSpillSound);\n        }\n        \n        for (int i = 0; i < _coinCount; i++)\n        {\n            Vector3 spawnPosition = _coinSpawnPoint.position + Random.insideUnitSphere * _coinSpawnRadius;\n            spawnPosition.y = _coinSpawnPoint.position.y;\n            \n            GameObject coin = Instantiate(_coinPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody coinRb = coin.GetComponent<Rigidbody>();\n            if (coinRb == null)\n            {\n                coinRb = coin.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 forceDirection = (spawnPosition - _coinSpawnPoint.position).normalized;\n            forceDirection.y = 0.5f;\n            coinRb.AddForce(forceDirection * _coinSpawnForce, ForceMode.Impulse);\n            \n            coin.AddComponent<CoinBehavior>().Initialize(Random.Range(5, 25));\n            \n            Destroy(coin, 10f);\n        }\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectEffect != null)\n        {\n            _collectEffect.Play();\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        \n        OnBagDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    public void SetGoldAmount(int amount)\n    {\n        _goldAmount = Mathf.Max(0, amount);\n    }\n    \n    public int GetGoldAmount()\n    {\n        return _goldAmount;\n    }\n    \n    public bool IsCollected()\n    {\n        return _isCollected;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _collectDistance);\n        \n        if (_coinSpawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_coinSpawnPoint.position, _coinSpawnRadius);\n        }\n    }\n}\n\n[System.Serializable]\npublic class CoinBehavior : MonoBehaviour\n{\n    private int _value;\n    private float _collectRadius = 1f;\n    private bool _isCollected = false;\n    private AudioSource _audioSource;\n    \n    public void Initialize(int value)\n    {\n        _value = value;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.volume = 0.3f;\n        _audioSource.playOnAwake = false;\n        \n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            col = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)col).isTrigger = true;\n            ((SphereCollider)col).radius = _collectRadius;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        transform.Rotate(Vector3.up, 180f * Time.deltaTime);\n        \n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _collectRadius);\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                CollectCoin();\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            renderer.enabled = false;\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    public int GetValue()\n    {\n        return _value;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Zombie\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"walkingSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"walk_toward_player\",\n      \"trigger\": \"when player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"move slowly toward player position at walking speed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class ZombieController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _stopDistance = 1.5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _groanSounds;\n    [SerializeField] private float _groanInterval = 3f;\n    \n    private Transform _player;\n    private NavMeshAgent _navMeshAgent;\n    private Rigidbody _rigidbody;\n    private float _lastGroanTime;\n    private bool _hasNavMesh;\n    \n    void Start()\n    {\n        InitializeComponents();\n        FindPlayer();\n        _lastGroanTime = Time.time + Random.Range(0f, _groanInterval);\n    }\n    \n    void InitializeComponents()\n    {\n        _navMeshAgent = GetComponent<NavMeshAgent>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_navMeshAgent != null)\n        {\n            _hasNavMesh = true;\n            _navMeshAgent.speed = _moveSpeed;\n            _navMeshAgent.stoppingDistance = _stopDistance;\n            _navMeshAgent.angularSpeed = _rotationSpeed;\n        }\n        else if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n        \n        if (_animator == null)\n        {\n            _animator = GetComponent<Animator>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _detectionRange)\n        {\n            MoveTowardsPlayer(distanceToPlayer);\n            UpdateAnimation(true);\n        }\n        else\n        {\n            UpdateAnimation(false);\n        }\n        \n        PlayRandomGroan();\n    }\n    \n    void MoveTowardsPlayer(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _stopDistance)\n        {\n            return;\n        }\n        \n        if (_hasNavMesh && _navMeshAgent.enabled)\n        {\n            _navMeshAgent.SetDestination(_player.position);\n        }\n        else\n        {\n            MoveWithoutNavMesh();\n        }\n    }\n    \n    void MoveWithoutNavMesh()\n    {\n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0f;\n        \n        if (_rigidbody != null)\n        {\n            Vector3 movement = direction * _moveSpeed * Time.deltaTime;\n            _rigidbody.MovePosition(transform.position + movement);\n        }\n        else\n        {\n            transform.Translate(direction * _moveSpeed * Time.deltaTime, Space.World);\n        }\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void UpdateAnimation(bool isMoving)\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsWalking\", isMoving);\n            \n            if (_hasNavMesh && _navMeshAgent != null)\n            {\n                _animator.SetFloat(\"Speed\", _navMeshAgent.velocity.magnitude);\n            }\n            else\n            {\n                _animator.SetFloat(\"Speed\", isMoving ? _moveSpeed : 0f);\n            }\n        }\n    }\n    \n    void PlayRandomGroan()\n    {\n        if (_audioSource != null && _groanSounds != null && _groanSounds.Length > 0)\n        {\n            if (Time.time >= _lastGroanTime + _groanInterval)\n            {\n                AudioClip randomGroan = _groanSounds[Random.Range(0, _groanSounds.Length)];\n                _audioSource.PlayOneShot(randomGroan);\n                _lastGroanTime = Time.time;\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _stopDistance);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            if (_audioSource != null && _groanSounds != null && _groanSounds.Length > 0)\n            {\n                AudioClip randomGroan = _groanSounds[Random.Range(0, _groanSounds.Length)];\n                _audioSource.PlayOneShot(randomGroan);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Giant\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"stompForce\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"stompRadius\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"stompCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"stompHeight\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_target\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"look toward player\"\n        },\n        {\n          \"action\": \"prepare stomp animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"perform_stomp\",\n      \"trigger\": \"when stomp cooldown is ready and target is detected\",\n      \"actions\": [\n        {\n          \"action\": \"lift foot high into air\"\n        },\n        {\n          \"action\": \"play stomp animation\"\n        },\n        {\n          \"action\": \"slam foot down with great force\"\n        },\n        {\n          \"action\": \"create ground impact at foot position\"\n        },\n        {\n          \"action\": \"shake camera violently\"\n        },\n        {\n          \"action\": \"play thunderous stomp sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ground_impact\",\n      \"trigger\": \"when foot hits ground during stomp\",\n      \"actions\": [\n        {\n          \"action\": \"push away all objects within stomp radius\"\n        },\n        {\n          \"action\": \"deal damage to nearby enemies and player\"\n        },\n        {\n          \"action\": \"create dust and debris particles\"\n        },\n        {\n          \"action\": \"spawn shockwave effect expanding outward\"\n        },\n        {\n          \"action\": \"start stomp cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_behavior\",\n      \"trigger\": \"when no targets are in range\",\n      \"actions\": [\n        {\n          \"action\": \"play idle breathing animation\"\n        },\n        {\n          \"action\": \"occasionally look around slowly\"\n        },\n        {\n          \"action\": \"shift weight from foot to foot\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GiantStomp : MonoBehaviour\n{\n    [Header(\"Stomp Settings\")]\n    [SerializeField] private float _stompInterval = 3f;\n    [SerializeField] private float _stompForce = 1000f;\n    [SerializeField] private float _stompRadius = 10f;\n    [SerializeField] private float _stompDamage = 50f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _liftHeight = 2f;\n    [SerializeField] private float _liftDuration = 1f;\n    [SerializeField] private float _stompDuration = 0.3f;\n    [SerializeField] private Transform _footTransform;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _stompEffectPrefab;\n    [SerializeField] private AudioClip _stompSound;\n    [SerializeField] private AudioClip _liftSound;\n    [SerializeField] private float _cameraShakeIntensity = 2f;\n    [SerializeField] private float _cameraShakeDuration = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStompStart;\n    public UnityEvent OnStompImpact;\n    public UnityEvent OnStompComplete;\n    \n    private AudioSource _audioSource;\n    private Vector3 _originalFootPosition;\n    private bool _isStomping = false;\n    private float _stompTimer = 0f;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private float _shakeTimer = 0f;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_footTransform == null)\n            _footTransform = transform;\n            \n        _originalFootPosition = _footTransform.position;\n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n            \n        _stompTimer = _stompInterval;\n    }\n    \n    private void Update()\n    {\n        if (!_isStomping)\n        {\n            _stompTimer -= Time.deltaTime;\n            if (_stompTimer <= 0f)\n            {\n                StartStomp();\n                _stompTimer = _stompInterval;\n            }\n        }\n        \n        UpdateCameraShake();\n    }\n    \n    private void StartStomp()\n    {\n        if (_isStomping) return;\n        \n        _isStomping = true;\n        OnStompStart?.Invoke();\n        \n        if (_liftSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_liftSound);\n            \n        StartCoroutine(StompSequence());\n    }\n    \n    private System.Collections.IEnumerator StompSequence()\n    {\n        // Lift foot\n        Vector3 startPos = _originalFootPosition;\n        Vector3 liftPos = _originalFootPosition + Vector3.up * _liftHeight;\n        \n        float elapsedTime = 0f;\n        while (elapsedTime < _liftDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime / _liftDuration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            _footTransform.position = Vector3.Lerp(startPos, liftPos, t);\n            yield return null;\n        }\n        \n        // Stomp down\n        elapsedTime = 0f;\n        while (elapsedTime < _stompDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime / _stompDuration;\n            t = t * t; // Accelerate downward\n            _footTransform.position = Vector3.Lerp(liftPos, _originalFootPosition, t);\n            yield return null;\n        }\n        \n        _footTransform.position = _originalFootPosition;\n        \n        // Impact\n        PerformStompImpact();\n        OnStompImpact?.Invoke();\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        _isStomping = false;\n        OnStompComplete?.Invoke();\n    }\n    \n    private void PerformStompImpact()\n    {\n        Vector3 stompPosition = _footTransform.position;\n        \n        // Play sound\n        if (_stompSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_stompSound);\n            \n        // Spawn effect\n        if (_stompEffectPrefab != null)\n            Instantiate(_stompEffectPrefab, stompPosition, Quaternion.identity);\n            \n        // Camera shake\n        StartCameraShake();\n        \n        // Find affected objects\n        Collider[] hitColliders = Physics.OverlapSphere(stompPosition, _stompRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Apply force to rigidbodies\n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - stompPosition).normalized;\n                float distance = Vector3.Distance(hitCollider.transform.position, stompPosition);\n                float forceMagnitude = _stompForce * (1f - distance / _stompRadius);\n                \n                rb.AddForce(direction * forceMagnitude + Vector3.up * forceMagnitude * 0.5f, ForceMode.Impulse);\n            }\n            \n            // Damage players\n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                // Send damage message if the player has a method to receive it\n                hitCollider.SendMessage(\"TakeDamage\", _stompDamage, SendMessageOptions.DontRequireReceiver);\n                \n                // Alternative: Use a simple health component if it exists\n                var healthComponent = hitCollider.GetComponent<SimpleHealth>();\n                if (healthComponent != null)\n                {\n                    healthComponent.TakeDamage(_stompDamage);\n                }\n            }\n            \n            // Destroy destructible objects\n            if (hitCollider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hitCollider.gameObject);\n            }\n        }\n    }\n    \n    private void StartCameraShake()\n    {\n        if (_mainCamera != null)\n        {\n            _shakeTimer = _cameraShakeDuration;\n        }\n    }\n    \n    private void UpdateCameraShake()\n    {\n        if (_shakeTimer > 0f && _mainCamera != null)\n        {\n            _shakeTimer -= Time.deltaTime;\n            \n            float shakeAmount = _cameraShakeIntensity * (_shakeTimer / _cameraShakeDuration);\n            Vector3 shakeOffset = Random.insideUnitSphere * shakeAmount;\n            shakeOffset.z = 0f; // Keep camera on same Z plane\n            \n            _mainCamera.transform.position = _originalCameraPosition + shakeOffset;\n            \n            if (_shakeTimer <= 0f)\n            {\n                _mainCamera.transform.position = _originalCameraPosition;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 center = _footTransform != null ? _footTransform.position : transform.position;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, _stompRadius);\n        \n        if (_footTransform != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(center + Vector3.up * _liftHeight, Vector3.one * 0.5f);\n        }\n    }\n}\n\n// Simple health component that can be used with the stomp system\npublic class SimpleHealth : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n            Destroy(gameObject);\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + amount);\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChasingEnemy\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"chaseSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"isChasing\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"set chasing state to true\"\n        },\n        {\n          \"action\": \"face toward player direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_player\",\n      \"trigger\": \"while chasing state is active and player is visible\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at chase speed\"\n        },\n        {\n          \"action\": \"maintain facing direction toward player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_chasing\",\n      \"trigger\": \"when player exits detection range or becomes hidden\",\n      \"actions\": [\n        {\n          \"action\": \"set chasing state to false\"\n        },\n        {\n          \"action\": \"stop movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class EnemyChaser : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _fieldOfViewAngle = 60f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    [SerializeField] private LayerMask _playerLayerMask = 1 << 6;\n    \n    [Header(\"Chase Settings\")]\n    [SerializeField] private float _chaseSpeed = 5f;\n    [SerializeField] private float _patrolSpeed = 2f;\n    [SerializeField] private float _loseTargetTime = 5f;\n    [SerializeField] private float _attackRange = 2f;\n    \n    [Header(\"Patrol Settings\")]\n    [SerializeField] private Transform[] _patrolPoints;\n    [SerializeField] private float _waitTimeAtPatrol = 2f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _detectionColor = Color.red;\n    [SerializeField] private Color _patrolColor = Color.green;\n    [SerializeField] private bool _showDebugGizmos = true;\n    \n    private NavMeshAgent _navAgent;\n    private Transform _player;\n    private EnemyState _currentState;\n    private float _lastSeenTime;\n    private Vector3 _lastKnownPlayerPosition;\n    private int _currentPatrolIndex;\n    private float _patrolWaitTimer;\n    private bool _isWaitingAtPatrol;\n    \n    private enum EnemyState\n    {\n        Patrolling,\n        Chasing,\n        Searching,\n        Attacking\n    }\n    \n    void Start()\n    {\n        _navAgent = GetComponent<NavMeshAgent>();\n        if (_navAgent == null)\n        {\n            Debug.LogError(\"NavMeshAgent component required on \" + gameObject.name);\n            enabled = false;\n            return;\n        }\n        \n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n        \n        _currentState = EnemyState.Patrolling;\n        _navAgent.speed = _patrolSpeed;\n        \n        if (_patrolPoints.Length > 0)\n        {\n            SetDestinationToPatrolPoint();\n        }\n    }\n    \n    void Update()\n    {\n        if (_player == null) return;\n        \n        switch (_currentState)\n        {\n            case EnemyState.Patrolling:\n                HandlePatrolling();\n                break;\n            case EnemyState.Chasing:\n                HandleChasing();\n                break;\n            case EnemyState.Searching:\n                HandleSearching();\n                break;\n            case EnemyState.Attacking:\n                HandleAttacking();\n                break;\n        }\n        \n        CheckForPlayer();\n    }\n    \n    void HandlePatrolling()\n    {\n        if (_patrolPoints.Length == 0) return;\n        \n        if (!_navAgent.pathPending && _navAgent.remainingDistance < 0.5f)\n        {\n            if (!_isWaitingAtPatrol)\n            {\n                _isWaitingAtPatrol = true;\n                _patrolWaitTimer = _waitTimeAtPatrol;\n            }\n            else\n            {\n                _patrolWaitTimer -= Time.deltaTime;\n                if (_patrolWaitTimer <= 0f)\n                {\n                    _isWaitingAtPatrol = false;\n                    _currentPatrolIndex = (_currentPatrolIndex + 1) % _patrolPoints.Length;\n                    SetDestinationToPatrolPoint();\n                }\n            }\n        }\n    }\n    \n    void HandleChasing()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attackRange)\n        {\n            _currentState = EnemyState.Attacking;\n            _navAgent.isStopped = true;\n            return;\n        }\n        \n        if (CanSeePlayer())\n        {\n            _lastSeenTime = Time.time;\n            _lastKnownPlayerPosition = _player.position;\n            _navAgent.SetDestination(_player.position);\n        }\n        else if (Time.time - _lastSeenTime > _loseTargetTime)\n        {\n            _currentState = EnemyState.Searching;\n            _navAgent.SetDestination(_lastKnownPlayerPosition);\n        }\n    }\n    \n    void HandleSearching()\n    {\n        if (!_navAgent.pathPending && _navAgent.remainingDistance < 0.5f)\n        {\n            _currentState = EnemyState.Patrolling;\n            _navAgent.speed = _patrolSpeed;\n            SetDestinationToPatrolPoint();\n        }\n    }\n    \n    void HandleAttacking()\n    {\n        if (_player == null) return;\n        \n        Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n        transform.rotation = Quaternion.LookRotation(new Vector3(directionToPlayer.x, 0, directionToPlayer.z));\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer > _attackRange)\n        {\n            _currentState = EnemyState.Chasing;\n            _navAgent.isStopped = false;\n            _navAgent.speed = _chaseSpeed;\n        }\n    }\n    \n    void CheckForPlayer()\n    {\n        if (_player == null || _currentState == EnemyState.Attacking) return;\n        \n        if (CanSeePlayer() && _currentState != EnemyState.Chasing)\n        {\n            _currentState = EnemyState.Chasing;\n            _navAgent.speed = _chaseSpeed;\n            _navAgent.isStopped = false;\n            _lastSeenTime = Time.time;\n        }\n    }\n    \n    bool CanSeePlayer()\n    {\n        if (_player == null) return false;\n        \n        Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer > _detectionRange) return false;\n        \n        float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer);\n        if (angleToPlayer > _fieldOfViewAngle / 2f) return false;\n        \n        Vector3 rayOrigin = transform.position + Vector3.up * 1.5f;\n        Vector3 rayTarget = _player.position + Vector3.up * 1f;\n        \n        if (Physics.Raycast(rayOrigin, (rayTarget - rayOrigin).normalized, out RaycastHit hit, distanceToPlayer, _obstacleLayerMask))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    void SetDestinationToPatrolPoint()\n    {\n        if (_patrolPoints.Length == 0) return;\n        \n        _navAgent.SetDestination(_patrolPoints[_currentPatrolIndex].position);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (!_showDebugGizmos) return;\n        \n        Gizmos.color = _currentState == EnemyState.Chasing ? _detectionColor : _patrolColor;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Vector3 leftBoundary = Quaternion.Euler(0, -_fieldOfViewAngle / 2f, 0) * transform.forward * _detectionRange;\n        Vector3 rightBoundary = Quaternion.Euler(0, _fieldOfViewAngle / 2f, 0) * transform.forward * _detectionRange;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, leftBoundary);\n        Gizmos.DrawRay(transform.position, rightBoundary);\n        \n        if (_patrolPoints != null)\n        {\n            Gizmos.color = Color.cyan;\n            for (int i = 0; i < _patrolPoints.Length; i++)\n            {\n                if (_patrolPoints[i] != null)\n                {\n                    Gizmos.DrawWireSphere(_patrolPoints[i].position, 0.5f);\n                    if (i < _patrolPoints.Length - 1 && _patrolPoints[i + 1] != null)\n                    {\n                        Gizmos.DrawLine(_patrolPoints[i].position, _patrolPoints[i + 1].position);\n                    }\n                    else if (i == _patrolPoints.Length - 1 && _patrolPoints[0] != null)\n                    {\n                        Gizmos.DrawLine(_patrolPoints[i].position, _patrolPoints[0].position);\n                    }\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SurfaceClimber\",\n  \"components\": [\n    \"Rigidbody\",\n    \"CapsuleCollider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"climbableTag\",\n      \"type\": \"string\",\n      \"default\": \"Climbable\"\n    },\n    {\n      \"name\": \"isClimbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"climbDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_climbable_surface\",\n      \"trigger\": \"when touching object with climbable tag\",\n      \"actions\": [\n        {\n          \"action\": \"enable climbing mode\"\n        },\n        {\n          \"action\": \"disable gravity\"\n        },\n        {\n          \"action\": \"calculate surface normal direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_movement\",\n      \"trigger\": \"when climbing mode is active and movement input is received\",\n      \"actions\": [\n        {\n          \"action\": \"move along surface in input direction at climb speed\"\n        },\n        {\n          \"action\": \"maintain contact with climbable surface\"\n        },\n        {\n          \"action\": \"rotate character to face climbing direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_climbing\",\n      \"trigger\": \"when no longer touching climbable surface or jump input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"disable climbing mode\"\n        },\n        {\n          \"action\": \"enable gravity\"\n        },\n        {\n          \"action\": \"restore normal movement physics\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_transition\",\n      \"trigger\": \"when moving from one climbable surface to another\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly transition between surface orientations\"\n        },\n        {\n          \"action\": \"maintain climbing speed during transition\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ClimbingSystem : MonoBehaviour\n{\n    [Header(\"Climbing Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private float _climbDetectionDistance = 1.5f;\n    [SerializeField] private LayerMask _climbableLayerMask = 1;\n    [SerializeField] private string _climbableTag = \"Climbable\";\n    \n    [Header(\"Movement Controls\")]\n    [SerializeField] private KeyCode _climbKey = KeyCode.E;\n    [SerializeField] private float _horizontalClimbSpeed = 2f;\n    [SerializeField] private float _gravityScale = 1f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private Transform _climbDetectionPoint;\n    [SerializeField] private float _climbDetectionRadius = 0.3f;\n    [SerializeField] private Vector3 _climbOffset = new Vector3(0, 0, -0.5f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnClimbStart;\n    public UnityEvent OnClimbEnd;\n    \n    private Rigidbody _rigidbody;\n    private Collider _playerCollider;\n    private bool _isClimbing;\n    private bool _canClimb;\n    private GameObject _currentClimbSurface;\n    private Vector3 _climbDirection;\n    private float _originalGravityScale;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _playerCollider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"ClimbingSystem requires a Rigidbody component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_climbDetectionPoint == null)\n        {\n            GameObject detectionPoint = new GameObject(\"ClimbDetectionPoint\");\n            detectionPoint.transform.SetParent(transform);\n            detectionPoint.transform.localPosition = Vector3.forward * 0.5f;\n            _climbDetectionPoint = detectionPoint.transform;\n        }\n        \n        _originalGravityScale = _rigidbody.drag;\n    }\n    \n    private void Update()\n    {\n        DetectClimbableSurfaces();\n        HandleClimbInput();\n        \n        if (_isClimbing)\n        {\n            HandleClimbMovement();\n        }\n    }\n    \n    private void DetectClimbableSurfaces()\n    {\n        Collider[] climbableObjects = Physics.OverlapSphere(\n            _climbDetectionPoint.position, \n            _climbDetectionRadius, \n            _climbableLayerMask\n        );\n        \n        _canClimb = false;\n        _currentClimbSurface = null;\n        \n        foreach (Collider col in climbableObjects)\n        {\n            if (col.CompareTag(_climbableTag) && col.gameObject != gameObject)\n            {\n                _canClimb = true;\n                _currentClimbSurface = col.gameObject;\n                \n                Vector3 surfaceNormal = GetSurfaceNormal(col);\n                _climbDirection = -surfaceNormal;\n                break;\n            }\n        }\n        \n        if (!_canClimb && _isClimbing)\n        {\n            StopClimbing();\n        }\n    }\n    \n    private Vector3 GetSurfaceNormal(Collider surface)\n    {\n        Vector3 directionToSurface = (surface.transform.position - transform.position).normalized;\n        \n        if (Physics.Raycast(transform.position, directionToSurface, out RaycastHit hit, _climbDetectionDistance, _climbableLayerMask))\n        {\n            return hit.normal;\n        }\n        \n        return -transform.forward;\n    }\n    \n    private void HandleClimbInput()\n    {\n        if (Input.GetKeyDown(_climbKey))\n        {\n            if (_canClimb && !_isClimbing)\n            {\n                StartClimbing();\n            }\n            else if (_isClimbing)\n            {\n                StopClimbing();\n            }\n        }\n    }\n    \n    private void StartClimbing()\n    {\n        if (!_canClimb || _currentClimbSurface == null) return;\n        \n        _isClimbing = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 climbPosition = _currentClimbSurface.transform.position + _climbOffset;\n        transform.position = Vector3.Lerp(transform.position, climbPosition, Time.deltaTime * 5f);\n        \n        OnClimbStart?.Invoke();\n    }\n    \n    private void StopClimbing()\n    {\n        _isClimbing = false;\n        _rigidbody.useGravity = true;\n        _currentClimbSurface = null;\n        \n        OnClimbEnd?.Invoke();\n    }\n    \n    private void HandleClimbMovement()\n    {\n        if (!_isClimbing || _currentClimbSurface == null) return;\n        \n        Vector3 moveDirection = Vector3.zero;\n        \n        float verticalInput = Input.GetAxis(\"Vertical\");\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(verticalInput) > 0.1f)\n        {\n            moveDirection += Vector3.up * verticalInput * _climbSpeed;\n        }\n        \n        if (Mathf.Abs(horizontalInput) > 0.1f)\n        {\n            Vector3 rightDirection = Vector3.Cross(Vector3.up, _climbDirection).normalized;\n            moveDirection += rightDirection * horizontalInput * _horizontalClimbSpeed;\n        }\n        \n        _rigidbody.velocity = moveDirection;\n        \n        Vector3 targetPosition = transform.position + _climbDirection * 0.1f;\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 2f);\n        \n        if (_currentClimbSurface != null)\n        {\n            transform.LookAt(transform.position + _climbDirection, Vector3.up);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_climbableTag))\n        {\n            _canClimb = true;\n            _currentClimbSurface = other.gameObject;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_climbableTag) && other.gameObject == _currentClimbSurface)\n        {\n            _canClimb = false;\n            if (_isClimbing)\n            {\n                StopClimbing();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_climbDetectionPoint != null)\n        {\n            Gizmos.color = _canClimb ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_climbDetectionPoint.position, _climbDetectionRadius);\n            \n            if (_isClimbing && _currentClimbSurface != null)\n            {\n                Gizmos.color = Color.blue;\n                Gizmos.DrawRay(transform.position, _climbDirection * 2f);\n            }\n        }\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, transform.forward * _climbDetectionDistance);\n    }\n    \n    public bool IsClimbing => _isClimbing;\n    public bool CanClimb => _canClimb;\n    public GameObject CurrentClimbSurface => _currentClimbSurface;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TimeBomb\",\n  \"components\": [\n    \"AudioSource\",\n    \"Renderer\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"totalTime\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"beepSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentTime\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"lastBeepTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.white\"\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"countdown_timer\",\n      \"trigger\": \"every frame while bomb is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current time by frame time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"beep_timing\",\n      \"trigger\": \"when enough time has passed since last beep based on remaining time\",\n      \"actions\": [\n        {\n          \"action\": \"play beep sound\"\n        },\n        {\n          \"action\": \"record current time as last beep time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"color_pulse\",\n      \"trigger\": \"when beep sound plays\",\n      \"actions\": [\n        {\n          \"action\": \"flash object color to bright red\"\n        },\n        {\n          \"action\": \"fade color back to original over short duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shake_effect\",\n      \"trigger\": \"every frame while bomb is active\",\n      \"actions\": [\n        {\n          \"action\": \"shake object position randomly with intensity based on how little time remains\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode\",\n      \"trigger\": \"when countdown reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"find all rigidbodies within explosion radius\"\n        },\n        {\n          \"action\": \"apply massive outward force to each found rigidbody\"\n        },\n        {\n          \"action\": \"destroy this bomb object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeBomb : MonoBehaviour\n{\n    [Header(\"Bomb Settings\")]\n    [SerializeField] private float _countdownTime = 10f;\n    [SerializeField] private float _explosionRadius = 20f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _warningColor = Color.red;\n    [SerializeField] private float _pulseDuration = 0.1f;\n    [SerializeField] private AnimationCurve _shakeIntensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _maxShakeIntensity = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _beepSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _minBeepInterval = 0.1f;\n    [SerializeField] private float _maxBeepInterval = 1f;\n    \n    [Header(\"Explosion Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private bool _destroyOnExplode = true;\n    \n    private float _timeRemaining;\n    private bool _isActive = false;\n    private bool _hasExploded = false;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    private Material _material;\n    \n    private Coroutine _countdownCoroutine;\n    private Coroutine _pulseCoroutine;\n    private Coroutine _shakeCoroutine;\n\n    private void Awake()\n    {\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n        }\n        \n        _originalPosition = transform.position;\n        _timeRemaining = _countdownTime;\n    }\n\n    private void Start()\n    {\n        StartBomb();\n    }\n\n    public void StartBomb()\n    {\n        if (_isActive || _hasExploded) return;\n        \n        _isActive = true;\n        _timeRemaining = _countdownTime;\n        \n        _countdownCoroutine = StartCoroutine(CountdownRoutine());\n        _shakeCoroutine = StartCoroutine(ShakeRoutine());\n    }\n\n    public void DefuseBomb()\n    {\n        if (_hasExploded) return;\n        \n        _isActive = false;\n        \n        if (_countdownCoroutine != null) StopCoroutine(_countdownCoroutine);\n        if (_pulseCoroutine != null) StopCoroutine(_pulseCoroutine);\n        if (_shakeCoroutine != null) StopCoroutine(_shakeCoroutine);\n        \n        ResetVisuals();\n    }\n\n    private IEnumerator CountdownRoutine()\n    {\n        while (_timeRemaining > 0 && _isActive)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            float beepInterval = Mathf.Lerp(_maxBeepInterval, _minBeepInterval, progress);\n            \n            PlayBeep();\n            StartPulse();\n            \n            yield return new WaitForSeconds(beepInterval);\n            _timeRemaining -= beepInterval;\n        }\n        \n        if (_isActive)\n        {\n            Explode();\n        }\n    }\n\n    private IEnumerator ShakeRoutine()\n    {\n        while (_isActive && !_hasExploded)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            float shakeIntensity = _shakeIntensityCurve.Evaluate(progress) * _maxShakeIntensity;\n            \n            Vector3 randomOffset = Random.insideUnitSphere * shakeIntensity;\n            transform.position = _originalPosition + randomOffset;\n            \n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n    }\n\n    private void PlayBeep()\n    {\n        if (_audioSource != null && _beepSound != null)\n        {\n            float progress = 1f - (_timeRemaining / _countdownTime);\n            _audioSource.pitch = Mathf.Lerp(0.8f, 2f, progress);\n            _audioSource.PlayOneShot(_beepSound);\n        }\n    }\n\n    private void StartPulse()\n    {\n        if (_pulseCoroutine != null)\n        {\n            StopCoroutine(_pulseCoroutine);\n        }\n        _pulseCoroutine = StartCoroutine(PulseRoutine());\n    }\n\n    private IEnumerator PulseRoutine()\n    {\n        if (_material == null) yield break;\n        \n        Color originalColor = _material.color;\n        float elapsed = 0f;\n        \n        while (elapsed < _pulseDuration)\n        {\n            float t = elapsed / _pulseDuration;\n            float pulseValue = Mathf.Sin(t * Mathf.PI);\n            \n            _material.color = Color.Lerp(originalColor, _warningColor, pulseValue);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _material.color = originalColor;\n    }\n\n    private void Explode()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        _isActive = false;\n        \n        // Stop all coroutines\n        if (_countdownCoroutine != null) StopCoroutine(_countdownCoroutine);\n        if (_pulseCoroutine != null) StopCoroutine(_pulseCoroutine);\n        if (_shakeCoroutine != null) StopCoroutine(_shakeCoroutine);\n        \n        // Play explosion sound\n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n        \n        // Spawn explosion effect\n        if (_explosionPrefab != null)\n        {\n            Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n        }\n        \n        // Apply explosion force\n        ApplyExplosionForce();\n        \n        // Destroy or disable the bomb\n        if (_destroyOnExplode)\n        {\n            Destroy(gameObject, _explosionSound != null ? _explosionSound.length : 0f);\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n\n    private void ApplyExplosionForce()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            Rigidbody rb = col.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            // Damage players or other objects\n            if (col.CompareTag(\"Player\"))\n            {\n                // Send damage message if the object can receive it\n                col.SendMessage(\"TakeDamage\", 100f, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n\n    private void ResetVisuals()\n    {\n        if (_material != null)\n        {\n            _material.color = _normalColor;\n        }\n        \n        transform.position = _originalPosition;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n\n    private void OnDestroy()\n    {\n        if (_material != null)\n        {\n            Destroy(_material);\n        }\n    }\n\n    // Public methods for external control\n    public float TimeRemaining => _timeRemaining;\n    public bool IsActive => _isActive;\n    public bool HasExploded => _hasExploded;\n    \n    public void SetCountdownTime(float time)\n    {\n        if (!_isActive)\n        {\n            _countdownTime = time;\n            _timeRemaining = time;\n        }\n    }\n}"}]}
