{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CreditsScroll\",\n  \"components\": [\n    \"RectTransform\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"scrollSpeed\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"fadeOutDuration\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"startDelay\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_credits_sequence\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"set initial transparency to zero\"\n        },\n        {\n          \"action\": \"wait for start delay duration\"\n        },\n        {\n          \"action\": \"fade in credits text over fade in duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"scroll_credits_upward\",\n      \"trigger\": \"continuously while credits are visible\",\n      \"actions\": [\n        {\n          \"action\": \"move credits text upward at scroll speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out_when_complete\",\n      \"trigger\": \"when credits text has scrolled completely off screen\",\n      \"actions\": [\n        {\n          \"action\": \"fade out credits text over fade out duration\"\n        },\n        {\n          \"action\": \"disable credits display when fade out completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"skip_credits\",\n      \"trigger\": \"when any key is pressed or screen is touched\",\n      \"actions\": [\n        {\n          \"action\": \"immediately fade out credits\"\n        },\n        {\n          \"action\": \"disable credits display\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class CreditsScroll : MonoBehaviour\n{\n    [Header(\"Scroll Settings\")]\n    [SerializeField] private float _scrollSpeed = 50f;\n    [SerializeField] private float _startDelay = 1f;\n    [SerializeField] private bool _autoStart = true;\n    [SerializeField] private bool _loopCredits = false;\n    \n    [Header(\"Boundaries\")]\n    [SerializeField] private float _startYPosition = -500f;\n    [SerializeField] private float _endYPosition = 1000f;\n    [SerializeField] private bool _useScreenBounds = true;\n    \n    [Header(\"Control Settings\")]\n    [SerializeField] private KeyCode _skipKey = KeyCode.Escape;\n    [SerializeField] private KeyCode _pauseKey = KeyCode.Space;\n    [SerializeField] private float _mouseScrollSensitivity = 100f;\n    [SerializeField] private bool _allowManualControl = true;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onCreditsStart = new UnityEvent();\n    [SerializeField] private UnityEvent _onCreditsComplete = new UnityEvent();\n    [SerializeField] private UnityEvent _onCreditsSkipped = new UnityEvent();\n    \n    private RectTransform _rectTransform;\n    private Canvas _parentCanvas;\n    private bool _isScrolling = false;\n    private bool _isPaused = false;\n    private float _currentSpeed;\n    private Vector3 _initialPosition;\n    private Coroutine _scrollCoroutine;\n    \n    private void Awake()\n    {\n        _rectTransform = GetComponent<RectTransform>();\n        if (_rectTransform == null)\n        {\n            Debug.LogError(\"CreditsScroll requires a RectTransform component!\");\n            enabled = false;\n            return;\n        }\n        \n        _parentCanvas = GetComponentInParent<Canvas>();\n        _currentSpeed = _scrollSpeed;\n        _initialPosition = _rectTransform.anchoredPosition;\n    }\n    \n    private void Start()\n    {\n        SetupInitialPosition();\n        \n        if (_autoStart)\n        {\n            StartCredits();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isScrolling) return;\n        \n        HandleInput();\n        \n        if (_allowManualControl && !_isPaused)\n        {\n            HandleManualScroll();\n        }\n    }\n    \n    private void SetupInitialPosition()\n    {\n        if (_useScreenBounds && _parentCanvas != null)\n        {\n            RectTransform canvasRect = _parentCanvas.GetComponent<RectTransform>();\n            if (canvasRect != null)\n            {\n                _startYPosition = -canvasRect.rect.height / 2 - _rectTransform.rect.height / 2;\n                _endYPosition = canvasRect.rect.height / 2 + _rectTransform.rect.height / 2;\n            }\n        }\n        \n        Vector3 startPos = _rectTransform.anchoredPosition;\n        startPos.y = _startYPosition;\n        _rectTransform.anchoredPosition = startPos;\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_skipKey))\n        {\n            SkipCredits();\n        }\n        \n        if (Input.GetKeyDown(_pauseKey))\n        {\n            TogglePause();\n        }\n    }\n    \n    private void HandleManualScroll()\n    {\n        float scrollInput = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scrollInput) > 0.01f)\n        {\n            Vector3 currentPos = _rectTransform.anchoredPosition;\n            currentPos.y += scrollInput * _mouseScrollSensitivity;\n            currentPos.y = Mathf.Clamp(currentPos.y, _startYPosition, _endYPosition);\n            _rectTransform.anchoredPosition = currentPos;\n        }\n    }\n    \n    public void StartCredits()\n    {\n        if (_isScrolling) return;\n        \n        _isScrolling = true;\n        _isPaused = false;\n        _onCreditsStart.Invoke();\n        \n        if (_scrollCoroutine != null)\n        {\n            StopCoroutine(_scrollCoroutine);\n        }\n        \n        _scrollCoroutine = StartCoroutine(ScrollCreditsCoroutine());\n    }\n    \n    public void StopCredits()\n    {\n        if (_scrollCoroutine != null)\n        {\n            StopCoroutine(_scrollCoroutine);\n            _scrollCoroutine = null;\n        }\n        \n        _isScrolling = false;\n        _isPaused = false;\n    }\n    \n    public void SkipCredits()\n    {\n        if (!_isScrolling) return;\n        \n        StopCredits();\n        _onCreditsSkipped.Invoke();\n        \n        if (_loopCredits)\n        {\n            ResetPosition();\n            StartCredits();\n        }\n    }\n    \n    public void TogglePause()\n    {\n        if (!_isScrolling) return;\n        \n        _isPaused = !_isPaused;\n    }\n    \n    public void SetScrollSpeed(float speed)\n    {\n        _scrollSpeed = Mathf.Max(0f, speed);\n        _currentSpeed = _scrollSpeed;\n    }\n    \n    public void ResetPosition()\n    {\n        Vector3 resetPos = _rectTransform.anchoredPosition;\n        resetPos.y = _startYPosition;\n        _rectTransform.anchoredPosition = resetPos;\n    }\n    \n    private IEnumerator ScrollCreditsCoroutine()\n    {\n        yield return new WaitForSeconds(_startDelay);\n        \n        while (_isScrolling)\n        {\n            if (!_isPaused)\n            {\n                Vector3 currentPos = _rectTransform.anchoredPosition;\n                currentPos.y += _currentSpeed * Time.deltaTime;\n                _rectTransform.anchoredPosition = currentPos;\n                \n                if (currentPos.y >= _endYPosition)\n                {\n                    _onCreditsComplete.Invoke();\n                    \n                    if (_loopCredits)\n                    {\n                        ResetPosition();\n                        yield return new WaitForSeconds(_startDelay);\n                    }\n                    else\n                    {\n                        StopCredits();\n                        break;\n                    }\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_scrollSpeed < 0f)\n            _scrollSpeed = 0f;\n            \n        if (_mouseScrollSensitivity < 0f)\n            _mouseScrollSensitivity = 0f;\n            \n        if (_startDelay < 0f)\n            _startDelay = 0f;\n    }\n    \n    private void OnDisable()\n    {\n        StopCredits();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DualDaggers\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"attackDamage\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"attackSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"comboWindow\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"comboMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"maxComboCount\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"currentComboCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"lastAttackTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isAttacking\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"primary_attack\",\n      \"trigger\": \"when primary attack input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"perform quick dagger slash animation\"\n        },\n        {\n          \"action\": \"deal base attack damage to enemies in front\"\n        },\n        {\n          \"action\": \"play metal slash sound effect\"\n        },\n        {\n          \"action\": \"record current time as last attack time\"\n        },\n        {\n          \"action\": \"set attacking state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combo_attack\",\n      \"trigger\": \"when primary attack input is pressed and previous attack was within combo window\",\n      \"actions\": [\n        {\n          \"action\": \"increase combo count by one\"\n        },\n        {\n          \"action\": \"perform faster alternating dagger strike animation\"\n        },\n        {\n          \"action\": \"deal attack damage multiplied by combo multiplier\"\n        },\n        {\n          \"action\": \"play higher pitched slash sound\"\n        },\n        {\n          \"action\": \"create visual combo effect\"\n        },\n        {\n          \"action\": \"reset combo window timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combo_finisher\",\n      \"trigger\": \"when combo count reaches maximum and attack input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"perform spinning dual dagger finisher animation\"\n        },\n        {\n          \"action\": \"deal double damage in wider area\"\n        },\n        {\n          \"action\": \"create dramatic visual effect\"\n        },\n        {\n          \"action\": \"play powerful impact sound\"\n        },\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"add brief cooldown period\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combo_reset\",\n      \"trigger\": \"when combo window time expires without new attack\",\n      \"actions\": [\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"set attacking state to false\"\n        },\n        {\n          \"action\": \"return to idle weapon stance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dual_strike\",\n      \"trigger\": \"when secondary attack input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"perform simultaneous dual dagger thrust animation\"\n        },\n        {\n          \"action\": \"deal increased damage with both daggers\"\n        },\n        {\n          \"action\": \"create piercing attack that hits multiple enemies\"\n        },\n        {\n          \"action\": \"play double impact sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class DualDaggerWeapon : MonoBehaviour\n{\n    [Header(\"Weapon Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _comboWindow = 0.8f;\n    [SerializeField] private int _maxComboCount = 4;\n    [SerializeField] private float _comboDamageMultiplier = 1.2f;\n    \n    [Header(\"Attack Timing\")]\n    [SerializeField] private float _leftDaggerDelay = 0f;\n    [SerializeField] private float _rightDaggerDelay = 0.15f;\n    [SerializeField] private float _attackCooldown = 0.3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _leftDagger;\n    [SerializeField] private Transform _rightDagger;\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private TrailRenderer _leftTrail;\n    [SerializeField] private TrailRenderer _rightTrail;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _attackSounds;\n    [SerializeField] private AudioClip _comboFinishSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _weaponAnimator;\n    [SerializeField] private string _leftAttackTrigger = \"LeftAttack\";\n    [SerializeField] private string _rightAttackTrigger = \"RightAttack\";\n    [SerializeField] private string _comboTrigger = \"ComboAttack\";\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent<int> OnComboChanged;\n    public UnityEvent OnComboFinished;\n    \n    private int _currentCombo = 0;\n    private float _lastAttackTime = 0f;\n    private bool _canAttack = true;\n    private bool _isAttacking = false;\n    private Camera _playerCamera;\n    private LayerMask _enemyLayerMask = -1;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_weaponAnimator == null)\n            _weaponAnimator = GetComponent<Animator>();\n            \n        _enemyLayerMask = ~(1 << gameObject.layer);\n        \n        SetupTrails();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateComboTimer();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack && !_isAttacking)\n        {\n            PerformAttack();\n        }\n    }\n    \n    private void UpdateComboTimer()\n    {\n        if (_currentCombo > 0 && Time.time - _lastAttackTime > _comboWindow)\n        {\n            ResetCombo();\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (!_canAttack) return;\n        \n        _isAttacking = true;\n        _canAttack = false;\n        _lastAttackTime = Time.time;\n        \n        _currentCombo = Mathf.Min(_currentCombo + 1, _maxComboCount);\n        OnComboChanged?.Invoke(_currentCombo);\n        \n        bool useLeftDagger = (_currentCombo % 2 == 1);\n        \n        if (_weaponAnimator != null)\n        {\n            if (_currentCombo >= _maxComboCount)\n            {\n                _weaponAnimator.SetTrigger(_comboTrigger);\n                StartCoroutine(ExecuteComboFinisher());\n            }\n            else\n            {\n                string trigger = useLeftDagger ? _leftAttackTrigger : _rightAttackTrigger;\n                _weaponAnimator.SetTrigger(trigger);\n                StartCoroutine(ExecuteSingleAttack(useLeftDagger));\n            }\n        }\n        else\n        {\n            if (_currentCombo >= _maxComboCount)\n            {\n                StartCoroutine(ExecuteComboFinisher());\n            }\n            else\n            {\n                StartCoroutine(ExecuteSingleAttack(useLeftDagger));\n            }\n        }\n    }\n    \n    private IEnumerator ExecuteSingleAttack(bool useLeftDagger)\n    {\n        float delay = useLeftDagger ? _leftDaggerDelay : _rightDaggerDelay;\n        yield return new WaitForSeconds(delay);\n        \n        Transform activeDagger = useLeftDagger ? _leftDagger : _rightDagger;\n        TrailRenderer activeTrail = useLeftDagger ? _leftTrail : _rightTrail;\n        \n        if (activeTrail != null)\n        {\n            activeTrail.enabled = true;\n            activeTrail.Clear();\n        }\n        \n        PlayAttackSound();\n        PerformDamageCheck(activeDagger, false);\n        \n        if (_slashEffect != null && activeDagger != null)\n        {\n            _slashEffect.transform.position = activeDagger.position;\n            _slashEffect.Play();\n        }\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        if (activeTrail != null)\n            activeTrail.enabled = false;\n            \n        yield return new WaitForSeconds(_attackCooldown - 0.2f);\n        \n        _canAttack = true;\n        _isAttacking = false;\n    }\n    \n    private IEnumerator ExecuteComboFinisher()\n    {\n        yield return new WaitForSeconds(_leftDaggerDelay);\n        \n        if (_leftTrail != null)\n        {\n            _leftTrail.enabled = true;\n            _leftTrail.Clear();\n        }\n        if (_rightTrail != null)\n        {\n            _rightTrail.enabled = true;\n            _rightTrail.Clear();\n        }\n        \n        PlayComboSound();\n        \n        PerformDamageCheck(_leftDagger, true);\n        yield return new WaitForSeconds(0.1f);\n        PerformDamageCheck(_rightDagger, true);\n        \n        if (_slashEffect != null)\n        {\n            if (_leftDagger != null)\n            {\n                _slashEffect.transform.position = _leftDagger.position;\n                _slashEffect.Play();\n            }\n            yield return new WaitForSeconds(0.1f);\n            if (_rightDagger != null)\n            {\n                _slashEffect.transform.position = _rightDagger.position;\n                _slashEffect.Play();\n            }\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        if (_leftTrail != null) _leftTrail.enabled = false;\n        if (_rightTrail != null) _rightTrail.enabled = false;\n        \n        OnComboFinished?.Invoke();\n        ResetCombo();\n        \n        yield return new WaitForSeconds(_attackCooldown);\n        \n        _canAttack = true;\n        _isAttacking = false;\n    }\n    \n    private void PerformDamageCheck(Transform dagger, bool isComboFinisher)\n    {\n        if (dagger == null) return;\n        \n        Vector3 attackOrigin = dagger.position;\n        Vector3 attackDirection = dagger.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.5f, attackDirection, _attackRange, _enemyLayerMask);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            float finalDamage = _attackDamage;\n            \n            if (isComboFinisher)\n            {\n                finalDamage *= _comboDamageMultiplier * _maxComboCount;\n            }\n            else if (_currentCombo > 1)\n            {\n                finalDamage *= Mathf.Pow(_comboDamageMultiplier, _currentCombo - 1);\n            }\n            \n            IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(finalDamage);\n            }\n            else\n            {\n                Rigidbody rb = hit.collider.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 forceDirection = (hit.point - attackOrigin).normalized;\n                    rb.AddForce(forceDirection * finalDamage * 10f, ForceMode.Impulse);\n                }\n            }\n            \n            OnDamageDealt?.Invoke(finalDamage);\n        }\n    }\n    \n    private void PlayAttackSound()\n    {\n        if (_audioSource != null && _attackSounds != null && _attackSounds.Length > 0)\n        {\n            AudioClip clip = _attackSounds[Random.Range(0, _attackSounds.Length)];\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayComboSound()\n    {\n        if (_audioSource != null && _comboFinishSound != null)\n        {\n            _audioSource.PlayOneShot(_comboFinishSound);\n        }\n    }\n    \n    private void ResetCombo()\n    {\n        _currentCombo = 0;\n        OnComboChanged?.Invoke(_currentCombo);\n    }\n    \n    private void SetupTrails()\n    {\n        if (_leftTrail != null)\n        {\n            _leftTrail.enabled = false;\n            _leftTrail.time = 0.3f;\n        }\n        if (_rightTrail != null)\n        {\n            _rightTrail.enabled = false;\n            _rightTrail.time = 0.3f;\n        }\n    }\n    \n    public int GetCurrentCombo()\n    {\n        return _currentCombo;\n    }\n    \n    public bool IsAttacking()\n    {\n        return _isAttacking;\n    }\n    \n    public void SetAttackDamage(float damage)\n    {\n        _attackDamage = damage;\n    }\n    \n    public void SetComboMultiplier(float multiplier)\n    {\n        _comboDamageMultiplier = multiplier;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_leftDagger != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_leftDagger.position, 0.5f);\n            Gizmos.DrawRay(_leftDagger.position, _leftDagger.forward * _attackRange);\n        }\n        \n        if (_rightDagger != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_rightDagger.position, 0.5f);\n            Gizmos.DrawRay(_rightDagger.position, _rightDagger.forward * _attackRange);\n        }\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RopeClimbing\",\n  \"components\": [\n    \"Rigidbody\",\n    \"CapsuleCollider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"grabRange\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isClimbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentRope\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"grab_rope\",\n      \"trigger\": \"when player presses grab button and is near a rope\",\n      \"actions\": [\n        {\n          \"action\": \"attach player to the rope\"\n        },\n        {\n          \"action\": \"disable gravity on player\"\n        },\n        {\n          \"action\": \"set climbing state to true\"\n        },\n        {\n          \"action\": \"play grab animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_up\",\n      \"trigger\": \"when climbing and player holds up input\",\n      \"actions\": [\n        {\n          \"action\": \"move player upward along rope at climb speed\"\n        },\n        {\n          \"action\": \"play climbing up animation\"\n        },\n        {\n          \"action\": \"rotate player to face rope direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_down\",\n      \"trigger\": \"when climbing and player holds down input\",\n      \"actions\": [\n        {\n          \"action\": \"move player downward along rope at climb speed\"\n        },\n        {\n          \"action\": \"play climbing down animation\"\n        },\n        {\n          \"action\": \"rotate player to face rope direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_rope\",\n      \"trigger\": \"when climbing and player presses jump or grab button\",\n      \"actions\": [\n        {\n          \"action\": \"detach player from rope\"\n        },\n        {\n          \"action\": \"enable gravity on player\"\n        },\n        {\n          \"action\": \"set climbing state to false\"\n        },\n        {\n          \"action\": \"apply small outward force to player\"\n        },\n        {\n          \"action\": \"play release animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rope_idle\",\n      \"trigger\": \"when climbing and no movement input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"keep player attached to current rope position\"\n        },\n        {\n          \"action\": \"play idle hanging animation\"\n        },\n        {\n          \"action\": \"maintain rope grip\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RopeClimbing : MonoBehaviour\n{\n    [Header(\"Rope Settings\")]\n    [SerializeField] private float _climbSpeed = 3f;\n    [SerializeField] private float _slideSpeed = 1f;\n    [SerializeField] private float _grabDistance = 1.5f;\n    [SerializeField] private LayerMask _ropeLayer = 1;\n    [SerializeField] private string _ropeTag = \"Rope\";\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private string _verticalAxis = \"Vertical\";\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private float _swayForce = 2f;\n    [SerializeField] private float _maxSwayAngle = 30f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _climbSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRopeGrabbed;\n    public UnityEvent OnRopeReleased;\n    public UnityEvent OnReachedTop;\n    public UnityEvent OnReachedBottom;\n    \n    private Rigidbody2D _rigidbody;\n    private Collider2D _collider;\n    private AudioSource _audioSource;\n    private Transform _currentRope;\n    private bool _isClimbing;\n    private bool _wasGrounded;\n    private float _originalGravityScale;\n    private Vector2 _ropeGrabPoint;\n    private float _ropeLength;\n    private float _currentRopePosition;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _collider = GetComponent<Collider2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"RopeClimbing requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalGravityScale = _rigidbody.gravityScale;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (_isClimbing)\n        {\n            HandleClimbing();\n            HandleSwaying();\n            CheckRopeBounds();\n        }\n        else\n        {\n            CheckForNearbyRope();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (_isClimbing)\n            {\n                ReleaseRope();\n            }\n            else\n            {\n                TryGrabRope();\n            }\n        }\n    }\n    \n    private void CheckForNearbyRope()\n    {\n        Collider2D[] nearbyRopes = Physics2D.OverlapCircleAll(transform.position, _grabDistance, _ropeLayer);\n        \n        foreach (var rope in nearbyRopes)\n        {\n            if (rope.CompareTag(_ropeTag))\n            {\n                // Visual feedback could be added here\n                break;\n            }\n        }\n    }\n    \n    private void TryGrabRope()\n    {\n        Collider2D[] nearbyRopes = Physics2D.OverlapCircleAll(transform.position, _grabDistance, _ropeLayer);\n        \n        foreach (var rope in nearbyRopes)\n        {\n            if (rope.CompareTag(_ropeTag))\n            {\n                GrabRope(rope.transform);\n                break;\n            }\n        }\n    }\n    \n    private void GrabRope(Transform rope)\n    {\n        _currentRope = rope;\n        _isClimbing = true;\n        _rigidbody.gravityScale = 0f;\n        _rigidbody.velocity = Vector2.zero;\n        \n        // Calculate rope grab point and length\n        _ropeGrabPoint = _currentRope.position;\n        _ropeLength = _currentRope.localScale.y;\n        \n        // Calculate current position on rope (0 = bottom, 1 = top)\n        float distanceFromBottom = Vector2.Distance(transform.position, _ropeGrabPoint - Vector3.up * _ropeLength * 0.5f);\n        _currentRopePosition = Mathf.Clamp01(distanceFromBottom / _ropeLength);\n        \n        // Position player on rope\n        Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n        transform.position = new Vector3(ropePosition.x, transform.position.y, transform.position.z);\n        \n        PlaySound(_grabSound);\n        OnRopeGrabbed?.Invoke();\n    }\n    \n    private void ReleaseRope()\n    {\n        _currentRope = null;\n        _isClimbing = false;\n        _rigidbody.gravityScale = _originalGravityScale;\n        \n        PlaySound(_releaseSound);\n        OnRopeReleased?.Invoke();\n    }\n    \n    private void HandleClimbing()\n    {\n        if (_currentRope == null)\n        {\n            ReleaseRope();\n            return;\n        }\n        \n        float verticalInput = Input.GetAxis(_verticalAxis);\n        \n        if (Mathf.Abs(verticalInput) > 0.1f)\n        {\n            // Move along rope\n            float moveSpeed = verticalInput > 0 ? _climbSpeed : _slideSpeed;\n            _currentRopePosition += verticalInput * moveSpeed * Time.deltaTime / _ropeLength;\n            _currentRopePosition = Mathf.Clamp01(_currentRopePosition);\n            \n            // Update position\n            Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n            transform.position = new Vector3(ropePosition.x, ropePosition.y, transform.position.z);\n            \n            // Play climbing sound\n            if (_audioSource != null && _climbSound != null && !_audioSource.isPlaying)\n            {\n                PlaySound(_climbSound);\n            }\n        }\n    }\n    \n    private void HandleSwaying()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(horizontalInput) > 0.1f)\n        {\n            // Apply sway force to the rope (if it has physics)\n            Rigidbody2D ropeRb = _currentRope.GetComponent<Rigidbody2D>();\n            if (ropeRb != null)\n            {\n                Vector2 swayForce = Vector2.right * horizontalInput * _swayForce;\n                ropeRb.AddForceAtPosition(swayForce, transform.position);\n            }\n            else\n            {\n                // Simple sway animation for static ropes\n                float swayAmount = Mathf.Sin(Time.time * 3f) * horizontalInput * 0.5f;\n                swayAmount = Mathf.Clamp(swayAmount, -_maxSwayAngle, _maxSwayAngle);\n                \n                Vector3 swayOffset = Vector3.right * swayAmount * 0.1f;\n                Vector3 ropePosition = _ropeGrabPoint + Vector3.up * (_currentRopePosition - 0.5f) * _ropeLength;\n                transform.position = new Vector3(ropePosition.x + swayOffset.x, ropePosition.y, transform.position.z);\n            }\n        }\n    }\n    \n    private void CheckRopeBounds()\n    {\n        if (_currentRopePosition >= 0.95f)\n        {\n            OnReachedTop?.Invoke();\n        }\n        else if (_currentRopePosition <= 0.05f)\n        {\n            OnReachedBottom?.Invoke();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerExit2D(Collider2D other)\n    {\n        if (_isClimbing && other.transform == _currentRope)\n        {\n            ReleaseRope();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw grab distance\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _grabDistance);\n        \n        // Draw rope connection when climbing\n        if (_isClimbing && _currentRope != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentRope.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DoubleJump\",\n  \"components\": [\n    \"Rigidbody2D\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxJumps\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"currentJumps\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"reset_jumps_on_ground\",\n      \"trigger\": \"when character touches ground\",\n      \"actions\": [\n        {\n          \"action\": \"set current jumps to zero\"\n        },\n        {\n          \"action\": \"mark character as grounded\"\n        }\n      ]\n    },\n    {\n      \"name\": \"leave_ground\",\n      \"trigger\": \"when character leaves ground\",\n      \"actions\": [\n        {\n          \"action\": \"mark character as not grounded\"\n        }\n      ]\n    },\n    {\n      \"name\": \"perform_jump\",\n      \"trigger\": \"when jump input is pressed and current jumps is less than max jumps\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force equal to jump force\"\n        },\n        {\n          \"action\": \"increase current jumps by one\"\n        },\n        {\n          \"action\": \"mark character as not grounded\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class DoubleJumpController : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _doubleJumpForce = 8f;\n    [SerializeField] private int _maxJumps = 2;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheck;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _doubleJumpSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _jumpParticles;\n    [SerializeField] private ParticleSystem _doubleJumpParticles;\n    \n    private Rigidbody2D _rigidbody2D;\n    private AudioSource _audioSource;\n    private int _jumpsRemaining;\n    private bool _isGrounded;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody2D == null)\n        {\n            Debug.LogError(\"DoubleJumpController requires a Rigidbody2D component!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_groundCheck == null)\n        {\n            _groundCheck = transform;\n        }\n        \n        _jumpsRemaining = _maxJumps;\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleJumpInput();\n    }\n    \n    private void CheckGrounded()\n    {\n        _wasGrounded = _isGrounded;\n        _isGrounded = Physics2D.OverlapCircle(_groundCheck.position, _groundCheckRadius, _groundLayerMask);\n        \n        if (_isGrounded && !_wasGrounded)\n        {\n            _jumpsRemaining = _maxJumps;\n        }\n    }\n    \n    private void HandleJumpInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && CanJump())\n        {\n            PerformJump();\n        }\n    }\n    \n    private bool CanJump()\n    {\n        return _jumpsRemaining > 0;\n    }\n    \n    private void PerformJump()\n    {\n        _rigidbody2D.velocity = new Vector2(_rigidbody2D.velocity.x, 0f);\n        \n        bool isFirstJump = _jumpsRemaining == _maxJumps;\n        float jumpForce = isFirstJump ? _jumpForce : _doubleJumpForce;\n        \n        _rigidbody2D.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);\n        _jumpsRemaining--;\n        \n        PlayJumpEffects(isFirstJump);\n    }\n    \n    private void PlayJumpEffects(bool isFirstJump)\n    {\n        if (_audioSource != null)\n        {\n            AudioClip soundToPlay = isFirstJump ? _jumpSound : _doubleJumpSound;\n            if (soundToPlay != null)\n            {\n                _audioSource.PlayOneShot(soundToPlay);\n            }\n        }\n        \n        ParticleSystem particlesToPlay = isFirstJump ? _jumpParticles : _doubleJumpParticles;\n        if (particlesToPlay != null)\n        {\n            particlesToPlay.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheck != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheck.position, _groundCheckRadius);\n        }\n    }\n    \n    public bool IsGrounded => _isGrounded;\n    public int JumpsRemaining => _jumpsRemaining;\n    public int MaxJumps => _maxJumps;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RockThrowingGolem\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"throwCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"rockPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"throwPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"play angry animation\"\n        },\n        {\n          \"action\": \"enter combat state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"throw_rock\",\n      \"trigger\": \"when in combat state and cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"play throwing animation\"\n        },\n        {\n          \"action\": \"create rock at throw point\"\n        },\n        {\n          \"action\": \"launch rock toward player with throw force\"\n        },\n        {\n          \"action\": \"reset cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"when in combat state\",\n      \"actions\": [\n        {\n          \"action\": \"slowly rotate to face player\"\n        },\n        {\n          \"action\": \"play tracking animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_target\",\n      \"trigger\": \"when player leaves detection range\",\n      \"actions\": [\n        {\n          \"action\": \"return to idle state\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        },\n        {\n          \"action\": \"stop tracking player\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class RockThrowingGolem : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private Transform _eyePosition;\n    \n    [Header(\"Rock Throwing\")]\n    [SerializeField] private GameObject _rockPrefab;\n    [SerializeField] private Transform _throwPoint;\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _throwCooldown = 2f;\n    [SerializeField] private float _rockLifetime = 5f;\n    [SerializeField] private int _rockDamage = 25;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _throwTrigger = \"Throw\";\n    [SerializeField] private string _idleBool = \"IsIdle\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _rockHitSound;\n    \n    private Transform _player;\n    private bool _canThrow = true;\n    private bool _playerInRange = false;\n    private Coroutine _throwCoroutine;\n    \n    private void Start()\n    {\n        if (_eyePosition == null)\n            _eyePosition = transform;\n            \n        if (_throwPoint == null)\n            _throwPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        \n        if (_playerInRange && _canThrow && _player != null)\n        {\n            LookAtPlayer();\n            \n            if (_throwCoroutine == null)\n            {\n                _throwCoroutine = StartCoroutine(ThrowRockSequence());\n            }\n        }\n        else if (!_playerInRange && _throwCoroutine != null)\n        {\n            StopCoroutine(_throwCoroutine);\n            _throwCoroutine = null;\n            \n            if (_animator != null)\n                _animator.SetBool(_idleBool, true);\n        }\n    }\n    \n    private void DetectPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(_eyePosition.position, _detectionRange, _playerLayer);\n        \n        _playerInRange = false;\n        _player = null;\n        \n        foreach (Collider col in playersInRange)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                Vector3 directionToPlayer = (col.transform.position - _eyePosition.position).normalized;\n                \n                if (Physics.Raycast(_eyePosition.position, directionToPlayer, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider.CompareTag(\"Player\"))\n                    {\n                        _playerInRange = true;\n                        _player = col.transform;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void LookAtPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion lookRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 2f);\n        }\n    }\n    \n    private IEnumerator ThrowRockSequence()\n    {\n        while (_playerInRange && _player != null)\n        {\n            if (_canThrow)\n            {\n                _canThrow = false;\n                \n                if (_animator != null)\n                {\n                    _animator.SetBool(_idleBool, false);\n                    _animator.SetTrigger(_throwTrigger);\n                }\n                \n                yield return new WaitForSeconds(0.5f);\n                \n                ThrowRock();\n                \n                yield return new WaitForSeconds(_throwCooldown);\n                \n                _canThrow = true;\n            }\n            else\n            {\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n        \n        _throwCoroutine = null;\n    }\n    \n    private void ThrowRock()\n    {\n        if (_rockPrefab == null || _player == null) return;\n        \n        GameObject rock = Instantiate(_rockPrefab, _throwPoint.position, Quaternion.identity);\n        \n        ThrownRock rockComponent = rock.GetComponent<ThrownRock>();\n        if (rockComponent == null)\n        {\n            rockComponent = rock.AddComponent<ThrownRock>();\n        }\n        \n        rockComponent.Initialize(_rockDamage, _rockLifetime, _rockHitSound);\n        \n        Rigidbody rockRb = rock.GetComponent<Rigidbody>();\n        if (rockRb == null)\n        {\n            rockRb = rock.AddComponent<Rigidbody>();\n        }\n        \n        Vector3 throwDirection = CalculateThrowDirection();\n        rockRb.AddForce(throwDirection * _throwForce, ForceMode.Impulse);\n        \n        if (_audioSource != null && _throwSound != null)\n        {\n            _audioSource.PlayOneShot(_throwSound);\n        }\n    }\n    \n    private Vector3 CalculateThrowDirection()\n    {\n        Vector3 targetPosition = _player.position + Vector3.up * 1f;\n        Vector3 direction = (targetPosition - _throwPoint.position).normalized;\n        \n        float distance = Vector3.Distance(_throwPoint.position, targetPosition);\n        float gravity = Physics.gravity.magnitude;\n        float angle = 30f * Mathf.Deg2Rad;\n        \n        float velocity = Mathf.Sqrt(distance * gravity / Mathf.Sin(2f * angle));\n        \n        Vector3 throwVector = new Vector3(direction.x, Mathf.Tan(angle), direction.z).normalized;\n        return throwVector * velocity / _throwForce;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_eyePosition != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_eyePosition.position, _detectionRange);\n        }\n        \n        if (_throwPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_throwPoint.position, 0.2f);\n        }\n    }\n}\n\npublic class ThrownRock : MonoBehaviour\n{\n    private int _damage;\n    private float _lifetime;\n    private AudioClip _hitSound;\n    private bool _hasHit = false;\n    \n    public void Initialize(int damage, float lifetime, AudioClip hitSound)\n    {\n        _damage = damage;\n        _lifetime = lifetime;\n        _hitSound = hitSound;\n        \n        Destroy(gameObject, _lifetime);\n        \n        if (GetComponent<Collider>() == null)\n        {\n            SphereCollider col = gameObject.AddComponent<SphereCollider>();\n            col.radius = 0.2f;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _hasHit = true;\n            \n            // Apply damage to player if they have a method for it\n            other.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            \n            PlayHitEffect();\n            Destroy(gameObject);\n        }\n        else if (!other.CompareTag(\"Golem\") && !other.isTrigger)\n        {\n            _hasHit = true;\n            PlayHitEffect();\n            \n            Rigidbody rb = GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.isKinematic = true;\n            }\n            \n            Destroy(gameObject, 2f);\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_hitSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_hitSound, transform.position);\n        }\n        \n        // Simple particle effect\n        GameObject effect = new GameObject(\"RockHitEffect\");\n        effect.transform.position = transform.position;\n        \n        ParticleSystem particles = effect.AddComponent<ParticleSystem>();\n        var main = particles.main;\n        main.startLifetime = 0.5f;\n        main.startSpeed = 5f;\n        main.maxParticles = 20;\n        \n        Destroy(effect, 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WeatherRainEffect\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rainIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"windStrength\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"rainDropSize\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"rainColor\",\n      \"type\": \"Color\",\n      \"default\": \"gray\"\n    },\n    {\n      \"name\": \"maxRainDrops\",\n      \"type\": \"int\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"rainSoundVolume\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"isRaining\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_rain\",\n      \"trigger\": \"when rain is enabled\",\n      \"actions\": [\n        {\n          \"action\": \"activate particle system\"\n        },\n        {\n          \"action\": \"set particle emission rate based on rain intensity\"\n        },\n        {\n          \"action\": \"set particle size based on rain drop size\"\n        },\n        {\n          \"action\": \"set particle color to rain color\"\n        },\n        {\n          \"action\": \"start playing rain sound effect\"\n        },\n        {\n          \"action\": \"set audio volume to rain sound volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_rain\",\n      \"trigger\": \"when rain is disabled\",\n      \"actions\": [\n        {\n          \"action\": \"stop particle emission\"\n        },\n        {\n          \"action\": \"fade out rain sound effect\"\n        },\n        {\n          \"action\": \"wait for existing particles to disappear\"\n        },\n        {\n          \"action\": \"deactivate particle system\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_rain_intensity\",\n      \"trigger\": \"when rain intensity changes\",\n      \"actions\": [\n        {\n          \"action\": \"modify particle emission rate to match new intensity\"\n        },\n        {\n          \"action\": \"adjust rain sound volume proportionally\"\n        },\n        {\n          \"action\": \"change particle velocity based on intensity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_wind_effect\",\n      \"trigger\": \"when wind strength is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"tilt rain particles in wind direction\"\n        },\n        {\n          \"action\": \"add horizontal velocity to particles based on wind strength\"\n        },\n        {\n          \"action\": \"create swaying motion in rain pattern\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WeatherRainEffect : MonoBehaviour\n{\n    [Header(\"Rain Settings\")]\n    [SerializeField] private GameObject _rainDropPrefab;\n    [SerializeField] private int _maxRainDrops = 1000;\n    [SerializeField] private float _rainIntensity = 0.5f;\n    [SerializeField] private Vector3 _rainAreaSize = new Vector3(50f, 20f, 50f);\n    [SerializeField] private float _rainDropSpeed = 10f;\n    [SerializeField] private Vector3 _windDirection = new Vector3(0.1f, 0f, 0f);\n    \n    [Header(\"Rain Drop Properties\")]\n    [SerializeField] private float _dropLifetime = 5f;\n    [SerializeField] private float _dropScale = 1f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _rainAudioSource;\n    [SerializeField] private AudioClip _rainSoundClip;\n    [SerializeField] private float _audioVolume = 0.3f;\n    \n    [Header(\"Particle System\")]\n    [SerializeField] private ParticleSystem _rainParticleSystem;\n    [SerializeField] private bool _useParticleSystem = true;\n    \n    private List<RainDrop> _activeRainDrops = new List<RainDrop>();\n    private Queue<RainDrop> _rainDropPool = new Queue<RainDrop>();\n    private Transform _playerTransform;\n    private Camera _mainCamera;\n    private float _spawnTimer;\n    private bool _isRaining = true;\n    \n    [System.Serializable]\n    private class RainDrop\n    {\n        public GameObject gameObject;\n        public Transform transform;\n        public Rigidbody rigidbody;\n        public float lifetime;\n        public bool isActive;\n        \n        public RainDrop(GameObject obj)\n        {\n            gameObject = obj;\n            transform = obj.transform;\n            rigidbody = obj.GetComponent<Rigidbody>();\n            lifetime = 0f;\n            isActive = false;\n        }\n    }\n    \n    void Start()\n    {\n        InitializeRainSystem();\n        SetupAudio();\n        SetupParticleSystem();\n        FindPlayerAndCamera();\n    }\n    \n    void Update()\n    {\n        if (!_isRaining) return;\n        \n        UpdatePlayerPosition();\n        SpawnRainDrops();\n        UpdateRainDrops();\n        UpdateAudio();\n    }\n    \n    private void InitializeRainSystem()\n    {\n        if (_rainDropPrefab == null)\n        {\n            CreateDefaultRainDropPrefab();\n        }\n        \n        PrewarmRainDropPool();\n    }\n    \n    private void CreateDefaultRainDropPrefab()\n    {\n        _rainDropPrefab = GameObject.CreatePrimitive(PrimitiveType.Capsule);\n        _rainDropPrefab.transform.localScale = new Vector3(0.02f, 0.1f, 0.02f);\n        \n        Renderer renderer = _rainDropPrefab.GetComponent<Renderer>();\n        Material rainMaterial = new Material(Shader.Find(\"Standard\"));\n        rainMaterial.color = new Color(0.7f, 0.8f, 1f, 0.6f);\n        rainMaterial.SetFloat(\"_Mode\", 3);\n        rainMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        rainMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        rainMaterial.SetInt(\"_ZWrite\", 0);\n        rainMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n        rainMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n        rainMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        rainMaterial.renderQueue = 3000;\n        renderer.material = rainMaterial;\n        \n        Rigidbody rb = _rainDropPrefab.GetComponent<Rigidbody>();\n        rb.useGravity = false;\n        rb.drag = 0f;\n        \n        _rainDropPrefab.SetActive(false);\n    }\n    \n    private void PrewarmRainDropPool()\n    {\n        for (int i = 0; i < _maxRainDrops; i++)\n        {\n            GameObject dropObj = Instantiate(_rainDropPrefab, transform);\n            RainDrop rainDrop = new RainDrop(dropObj);\n            _rainDropPool.Enqueue(rainDrop);\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_rainAudioSource == null)\n        {\n            _rainAudioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rainAudioSource.clip = _rainSoundClip;\n        _rainAudioSource.loop = true;\n        _rainAudioSource.volume = _audioVolume;\n        _rainAudioSource.spatialBlend = 0f;\n        \n        if (_rainSoundClip != null && _isRaining)\n        {\n            _rainAudioSource.Play();\n        }\n    }\n    \n    private void SetupParticleSystem()\n    {\n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var main = _rainParticleSystem.main;\n            main.startLifetime = _dropLifetime;\n            main.startSpeed = _rainDropSpeed;\n            main.maxParticles = _maxRainDrops;\n            \n            var emission = _rainParticleSystem.emission;\n            emission.rateOverTime = _maxRainDrops * _rainIntensity / _dropLifetime;\n            \n            var shape = _rainParticleSystem.shape;\n            shape.shapeType = ParticleSystemShapeType.Box;\n            shape.scale = _rainAreaSize;\n            \n            var velocityOverLifetime = _rainParticleSystem.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            velocityOverLifetime.x = _windDirection.x * _rainDropSpeed;\n            velocityOverLifetime.y = -_rainDropSpeed;\n            velocityOverLifetime.z = _windDirection.z * _rainDropSpeed;\n        }\n    }\n    \n    private void FindPlayerAndCamera()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n        {\n            _mainCamera = FindObjectOfType<Camera>();\n        }\n    }\n    \n    private void UpdatePlayerPosition()\n    {\n        if (_playerTransform != null)\n        {\n            Vector3 playerPos = _playerTransform.position;\n            transform.position = new Vector3(playerPos.x, playerPos.y + _rainAreaSize.y * 0.5f, playerPos.z);\n        }\n        else if (_mainCamera != null)\n        {\n            Vector3 cameraPos = _mainCamera.transform.position;\n            transform.position = new Vector3(cameraPos.x, cameraPos.y + _rainAreaSize.y * 0.5f, cameraPos.z);\n        }\n    }\n    \n    private void SpawnRainDrops()\n    {\n        _spawnTimer += Time.deltaTime;\n        float spawnRate = _maxRainDrops * _rainIntensity / _dropLifetime;\n        float spawnInterval = 1f / spawnRate;\n        \n        if (_spawnTimer >= spawnInterval && _rainDropPool.Count > 0)\n        {\n            _spawnTimer = 0f;\n            SpawnRainDrop();\n        }\n    }\n    \n    private void SpawnRainDrop()\n    {\n        RainDrop rainDrop = _rainDropPool.Dequeue();\n        \n        Vector3 spawnPosition = transform.position + new Vector3(\n            Random.Range(-_rainAreaSize.x * 0.5f, _rainAreaSize.x * 0.5f),\n            Random.Range(0f, _rainAreaSize.y * 0.5f),\n            Random.Range(-_rainAreaSize.z * 0.5f, _rainAreaSize.z * 0.5f)\n        );\n        \n        rainDrop.transform.position = spawnPosition;\n        rainDrop.transform.localScale = Vector3.one * _dropScale;\n        rainDrop.lifetime = _dropLifetime;\n        rainDrop.isActive = true;\n        rainDrop.gameObject.SetActive(true);\n        \n        Vector3 velocity = new Vector3(_windDirection.x, -1f, _windDirection.z) * _rainDropSpeed;\n        rainDrop.rigidbody.velocity = velocity;\n        \n        _activeRainDrops.Add(rainDrop);\n    }\n    \n    private void UpdateRainDrops()\n    {\n        for (int i = _activeRainDrops.Count - 1; i >= 0; i--)\n        {\n            RainDrop rainDrop = _activeRainDrops[i];\n            \n            rainDrop.lifetime -= Time.deltaTime;\n            \n            if (rainDrop.lifetime <= 0f || IsRainDropHittingGround(rainDrop))\n            {\n                DeactivateRainDrop(rainDrop, i);\n            }\n        }\n    }\n    \n    private bool IsRainDropHittingGround(RainDrop rainDrop)\n    {\n        RaycastHit hit;\n        Vector3 rayOrigin = rainDrop.transform.position;\n        Vector3 rayDirection = rainDrop.rigidbody.velocity.normalized;\n        float rayDistance = rainDrop.rigidbody.velocity.magnitude * Time.deltaTime;\n        \n        return Physics.Raycast(rayOrigin, rayDirection, out hit, rayDistance, _groundLayer);\n    }\n    \n    private void DeactivateRainDrop(RainDrop rainDrop, int index)\n    {\n        rainDrop.isActive = false;\n        rainDrop.gameObject.SetActive(false);\n        rainDrop.rigidbody.velocity = Vector3.zero;\n        \n        _activeRainDrops.RemoveAt(index);\n        _rainDropPool.Enqueue(rainDrop);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rainAudioSource != null)\n        {\n            float targetVolume = _isRaining ? _audioVolume * _rainIntensity : 0f;\n            _rainAudioSource.volume = Mathf.Lerp(_rainAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n        }\n    }\n    \n    public void SetRainIntensity(float intensity)\n    {\n        _rainIntensity = Mathf.Clamp01(intensity);\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var emission = _rainParticleSystem.emission;\n            emission.rateOverTime = _maxRainDrops * _rainIntensity / _dropLifetime;\n        }\n    }\n    \n    public void StartRain()\n    {\n        _isRaining = true;\n        \n        if (_rainAudioSource != null && _rainSoundClip != null)\n        {\n            _rainAudioSource.Play();\n        }\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            _rainParticleSystem.Play();\n        }\n    }\n    \n    public void StopRain()\n    {\n        _isRaining = false;\n        \n        if (_rainAudioSource != null)\n        {\n            _rainAudioSource.Stop();\n        }\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            _rainParticleSystem.Stop();\n        }\n        \n        for (int i = _activeRainDrops.Count - 1; i >= 0; i--)\n        {\n            DeactivateRainDrop(_activeRainDrops[i], i);\n        }\n    }\n    \n    public void SetWindDirection(Vector3 windDirection)\n    {\n        _windDirection = windDirection;\n        \n        if (_useParticleSystem && _rainParticleSystem != null)\n        {\n            var velocityOverLifetime = _rainParticleSystem.velocityOverLifetime;\n            velocityOverLifetime.x = _windDirection.x * _rainDropSpeed;\n            velocityOverLifetime.z = _windDirection.z * _rainDropSpeed;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = new Color(0f, 0.5f, 1f, 0.3f);\n        Gizmos.DrawCube(transform.position, _rainAreaSize);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, _rainAreaSize);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"QuickTurnAround\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 540\n    },\n    {\n      \"name\": \"isQuickTurning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"execute_quick_turn\",\n      \"trigger\": \"when quick turn is requested\",\n      \"actions\": [\n        {\n          \"action\": \"set quick turning flag to true\"\n        },\n        {\n          \"action\": \"rotate object one hundred eighty degrees around vertical axis at turn speed\"\n        },\n        {\n          \"action\": \"set quick turning flag to false when rotation is complete\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class QuickTurnAround : MonoBehaviour\n{\n    [Header(\"Turn Settings\")]\n    [SerializeField] private float _turnSpeed = 720f;\n    [SerializeField] private KeyCode _turnKey = KeyCode.Q;\n    [SerializeField] private bool _useMouseInput = false;\n    [SerializeField] private float _mouseSensitivity = 2f;\n    \n    [Header(\"Turn Direction\")]\n    [SerializeField] private bool _turnLeft = true;\n    [SerializeField] private float _turnAngle = 180f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private AnimationCurve _turnCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private bool _useSmoothing = true;\n    \n    [Header(\"Cooldown\")]\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private bool _allowContinuousTurn = false;\n    \n    private bool _isTurning = false;\n    private float _currentTurnTime = 0f;\n    private float _startRotationY;\n    private float _targetRotationY;\n    private float _lastTurnTime = 0f;\n    private Vector3 _originalRotation;\n    \n    private void Start()\n    {\n        _originalRotation = transform.eulerAngles;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        ProcessTurn();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isTurning && !_allowContinuousTurn) return;\n        if (Time.time - _lastTurnTime < _cooldownTime) return;\n        \n        bool shouldTurn = false;\n        \n        if (_useMouseInput)\n        {\n            float mouseX = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(mouseX) > _mouseSensitivity)\n            {\n                _turnLeft = mouseX < 0;\n                shouldTurn = true;\n            }\n        }\n        \n        if (Input.GetKeyDown(_turnKey))\n        {\n            shouldTurn = true;\n        }\n        \n        if (shouldTurn)\n        {\n            StartTurn();\n        }\n    }\n    \n    private void StartTurn()\n    {\n        if (!_allowContinuousTurn && _isTurning) return;\n        \n        _isTurning = true;\n        _currentTurnTime = 0f;\n        _startRotationY = transform.eulerAngles.y;\n        \n        float turnDirection = _turnLeft ? -1f : 1f;\n        _targetRotationY = _startRotationY + (_turnAngle * turnDirection);\n        \n        _lastTurnTime = Time.time;\n    }\n    \n    private void ProcessTurn()\n    {\n        if (!_isTurning) return;\n        \n        _currentTurnTime += Time.deltaTime;\n        float turnDuration = _turnAngle / _turnSpeed;\n        float normalizedTime = _currentTurnTime / turnDuration;\n        \n        if (normalizedTime >= 1f)\n        {\n            CompleteTurn();\n            return;\n        }\n        \n        float rotationY;\n        if (_useSmoothing)\n        {\n            float curveValue = _turnCurve.Evaluate(normalizedTime);\n            rotationY = Mathf.LerpAngle(_startRotationY, _targetRotationY, curveValue);\n        }\n        else\n        {\n            rotationY = Mathf.LerpAngle(_startRotationY, _targetRotationY, normalizedTime);\n        }\n        \n        Vector3 newRotation = transform.eulerAngles;\n        newRotation.y = rotationY;\n        transform.eulerAngles = newRotation;\n    }\n    \n    private void CompleteTurn()\n    {\n        Vector3 finalRotation = transform.eulerAngles;\n        finalRotation.y = _targetRotationY;\n        transform.eulerAngles = finalRotation;\n        \n        _isTurning = false;\n        _currentTurnTime = 0f;\n    }\n    \n    public void TurnAround()\n    {\n        StartTurn();\n    }\n    \n    public void TurnLeft()\n    {\n        _turnLeft = true;\n        StartTurn();\n    }\n    \n    public void TurnRight()\n    {\n        _turnLeft = false;\n        StartTurn();\n    }\n    \n    public void SetTurnSpeed(float speed)\n    {\n        _turnSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void SetTurnAngle(float angle)\n    {\n        _turnAngle = Mathf.Clamp(angle, 1f, 360f);\n    }\n    \n    public bool IsTurning()\n    {\n        return _isTurning;\n    }\n    \n    private void OnValidate()\n    {\n        _turnSpeed = Mathf.Max(0.1f, _turnSpeed);\n        _turnAngle = Mathf.Clamp(_turnAngle, 1f, 360f);\n        _cooldownTime = Mathf.Max(0f, _cooldownTime);\n        _mouseSensitivity = Mathf.Max(0.1f, _mouseSensitivity);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MinimapObjectiveMarker\",\n  \"components\": [\n    \"Transform\",\n    \"SpriteRenderer\",\n    \"Canvas\",\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"markerIcon\",\n      \"type\": \"Sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"markerColor\",\n      \"type\": \"Color\",\n      \"default\": \"yellow\"\n    },\n    {\n      \"name\": \"markerSize\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"blinkSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"showDistance\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"maxVisibleDistance\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"objectiveTarget\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isCompleted\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_objective_position\",\n      \"trigger\": \"every frame while objective exists\",\n      \"actions\": [\n        {\n          \"action\": \"update marker position to match objective location on minimap\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_marker_when_in_range\",\n      \"trigger\": \"when objective is within maximum visible distance\",\n      \"actions\": [\n        {\n          \"action\": \"make marker visible on minimap\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_marker_when_far\",\n      \"trigger\": \"when objective is beyond maximum visible distance\",\n      \"actions\": [\n        {\n          \"action\": \"hide marker from minimap\"\n        }\n      ]\n    },\n    {\n      \"name\": \"blink_active_marker\",\n      \"trigger\": \"when objective is active and not completed\",\n      \"actions\": [\n        {\n          \"action\": \"make marker blink at specified speed to draw attention\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_completed_appearance\",\n      \"trigger\": \"when objective is marked as completed\",\n      \"actions\": [\n        {\n          \"action\": \"change marker color to green\"\n        },\n        {\n          \"action\": \"stop blinking animation\"\n        },\n        {\n          \"action\": \"reduce marker opacity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"scale_with_distance\",\n      \"trigger\": \"when player distance to objective changes\",\n      \"actions\": [\n        {\n          \"action\": \"adjust marker size based on distance to objective\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_completed_marker\",\n      \"trigger\": \"when objective has been completed for specified duration\",\n      \"actions\": [\n        {\n          \"action\": \"fade out marker\"\n        },\n        {\n          \"action\": \"remove marker from minimap\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class MinimapObjectiveMarker : MonoBehaviour\n{\n    [Header(\"Marker Settings\")]\n    [SerializeField] private GameObject _markerPrefab;\n    [SerializeField] private Transform _minimapCanvas;\n    [SerializeField] private Camera _minimapCamera;\n    [SerializeField] private RectTransform _minimapRect;\n    \n    [Header(\"Marker Appearance\")]\n    [SerializeField] private Color _activeColor = Color.yellow;\n    [SerializeField] private Color _completedColor = Color.green;\n    [SerializeField] private Color _failedColor = Color.red;\n    [SerializeField] private float _markerSize = 20f;\n    [SerializeField] private bool _showDistance = true;\n    \n    [Header(\"Objective Settings\")]\n    [SerializeField] private string _objectiveTitle = \"Objective\";\n    [SerializeField] private string _objectiveDescription = \"Complete this objective\";\n    [SerializeField] private bool _isCompleted = false;\n    [SerializeField] private bool _isFailed = false;\n    [SerializeField] private float _completionRadius = 5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _pulseAnimation = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseScale = 1.2f;\n    \n    private GameObject _markerInstance;\n    private Image _markerImage;\n    private Text _distanceText;\n    private Transform _player;\n    private RectTransform _markerRect;\n    private Vector3 _originalScale;\n    private bool _isVisible = true;\n    \n    public enum ObjectiveState\n    {\n        Active,\n        Completed,\n        Failed,\n        Hidden\n    }\n    \n    private ObjectiveState _currentState = ObjectiveState.Active;\n    \n    void Start()\n    {\n        InitializeMarker();\n        FindPlayer();\n        SetupMarkerAppearance();\n    }\n    \n    void Update()\n    {\n        if (_markerInstance == null || _player == null) return;\n        \n        UpdateMarkerPosition();\n        UpdateMarkerVisibility();\n        UpdateDistanceDisplay();\n        UpdateObjectiveCompletion();\n        \n        if (_pulseAnimation && _currentState == ObjectiveState.Active)\n        {\n            AnimateMarker();\n        }\n    }\n    \n    private void InitializeMarker()\n    {\n        if (_minimapCanvas == null)\n        {\n            _minimapCanvas = FindObjectOfType<Canvas>()?.transform;\n        }\n        \n        if (_minimapCamera == null)\n        {\n            _minimapCamera = Camera.main;\n        }\n        \n        if (_minimapRect == null)\n        {\n            _minimapRect = _minimapCanvas?.GetComponent<RectTransform>();\n        }\n        \n        CreateMarkerInstance();\n    }\n    \n    private void CreateMarkerInstance()\n    {\n        if (_minimapCanvas == null) return;\n        \n        if (_markerPrefab != null)\n        {\n            _markerInstance = Instantiate(_markerPrefab, _minimapCanvas);\n        }\n        else\n        {\n            _markerInstance = new GameObject(\"ObjectiveMarker\");\n            _markerInstance.transform.SetParent(_minimapCanvas);\n            \n            _markerImage = _markerInstance.AddComponent<Image>();\n            _markerImage.sprite = CreateCircleSprite();\n        }\n        \n        _markerRect = _markerInstance.GetComponent<RectTransform>();\n        if (_markerRect == null)\n        {\n            _markerRect = _markerInstance.AddComponent<RectTransform>();\n        }\n        \n        _markerRect.sizeDelta = Vector2.one * _markerSize;\n        _originalScale = _markerRect.localScale;\n        \n        if (_markerImage == null)\n        {\n            _markerImage = _markerInstance.GetComponent<Image>();\n        }\n        \n        SetupDistanceText();\n    }\n    \n    private void SetupDistanceText()\n    {\n        if (!_showDistance) return;\n        \n        GameObject textObj = new GameObject(\"DistanceText\");\n        textObj.transform.SetParent(_markerInstance.transform);\n        \n        _distanceText = textObj.AddComponent<Text>();\n        _distanceText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        _distanceText.fontSize = 12;\n        _distanceText.color = Color.white;\n        _distanceText.alignment = TextAnchor.MiddleCenter;\n        \n        RectTransform textRect = textObj.GetComponent<RectTransform>();\n        textRect.anchoredPosition = Vector2.zero;\n        textRect.sizeDelta = new Vector2(50, 20);\n        textRect.anchoredPosition = new Vector2(0, -25);\n    }\n    \n    private Sprite CreateCircleSprite()\n    {\n        Texture2D texture = new Texture2D(32, 32);\n        Color[] pixels = new Color[32 * 32];\n        Vector2 center = new Vector2(16, 16);\n        \n        for (int y = 0; y < 32; y++)\n        {\n            for (int x = 0; x < 32; x++)\n            {\n                float distance = Vector2.Distance(new Vector2(x, y), center);\n                pixels[y * 32 + x] = distance <= 15 ? Color.white : Color.clear;\n            }\n        }\n        \n        texture.SetPixels(pixels);\n        texture.Apply();\n        \n        return Sprite.Create(texture, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f));\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n    \n    private void SetupMarkerAppearance()\n    {\n        if (_markerImage == null) return;\n        \n        switch (_currentState)\n        {\n            case ObjectiveState.Active:\n                _markerImage.color = _activeColor;\n                break;\n            case ObjectiveState.Completed:\n                _markerImage.color = _completedColor;\n                break;\n            case ObjectiveState.Failed:\n                _markerImage.color = _failedColor;\n                break;\n            case ObjectiveState.Hidden:\n                _markerInstance.SetActive(false);\n                break;\n        }\n    }\n    \n    private void UpdateMarkerPosition()\n    {\n        if (_minimapCamera == null || _minimapRect == null) return;\n        \n        Vector3 worldPos = transform.position;\n        Vector3 screenPos = _minimapCamera.WorldToScreenPoint(worldPos);\n        \n        Vector2 localPos;\n        RectTransformUtility.ScreenPointToLocalPointInRectangle(\n            _minimapRect, screenPos, null, out localPos);\n        \n        _markerRect.anchoredPosition = localPos;\n    }\n    \n    private void UpdateMarkerVisibility()\n    {\n        if (_markerInstance == null) return;\n        \n        bool shouldBeVisible = _currentState != ObjectiveState.Hidden && _isVisible;\n        _markerInstance.SetActive(shouldBeVisible);\n    }\n    \n    private void UpdateDistanceDisplay()\n    {\n        if (_distanceText == null || _player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        _distanceText.text = $\"{distance:F0}m\";\n    }\n    \n    private void UpdateObjectiveCompletion()\n    {\n        if (_player == null || _currentState != ObjectiveState.Active) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _completionRadius && !_isCompleted)\n        {\n            CompleteObjective();\n        }\n    }\n    \n    private void AnimateMarker()\n    {\n        if (_markerRect == null) return;\n        \n        float scale = 1f + Mathf.Sin(Time.time * _pulseSpeed) * (_pulseScale - 1f) * 0.5f;\n        _markerRect.localScale = _originalScale * scale;\n    }\n    \n    public void SetObjectiveState(ObjectiveState state)\n    {\n        _currentState = state;\n        \n        switch (state)\n        {\n            case ObjectiveState.Completed:\n                _isCompleted = true;\n                break;\n            case ObjectiveState.Failed:\n                _isFailed = true;\n                break;\n        }\n        \n        SetupMarkerAppearance();\n    }\n    \n    public void CompleteObjective()\n    {\n        SetObjectiveState(ObjectiveState.Completed);\n        \n        if (_pulseAnimation)\n        {\n            _markerRect.localScale = _originalScale;\n        }\n    }\n    \n    public void FailObjective()\n    {\n        SetObjectiveState(ObjectiveState.Failed);\n        \n        if (_pulseAnimation)\n        {\n            _markerRect.localScale = _originalScale;\n        }\n    }\n    \n    public void ShowMarker()\n    {\n        _isVisible = true;\n        if (_currentState != ObjectiveState.Hidden)\n        {\n            _markerInstance?.SetActive(true);\n        }\n    }\n    \n    public void HideMarker()\n    {\n        _isVisible = false;\n        _markerInstance?.SetActive(false);\n    }\n    \n    public void SetMarkerColor(Color color)\n    {\n        if (_markerImage != null)\n        {\n            _markerImage.color = color;\n        }\n    }\n    \n    public void SetObjectiveTitle(string title)\n    {\n        _objectiveTitle = title;\n    }\n    \n    public void SetObjectiveDescription(string description)\n    {\n        _objectiveDescription = description;\n    }\n    \n    public string GetObjectiveTitle()\n    {\n        return _objectiveTitle;\n    }\n    \n    public string GetObjectiveDescription()\n    {\n        return _objectiveDescription;\n    }\n    \n    public ObjectiveState GetCurrentState()\n    {\n        return _currentState;\n    }\n    \n    public bool IsCompleted()\n    {\n        return _isCompleted;\n    }\n    \n    public bool IsFailed()\n    {\n        return _isFailed;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _completionRadius);\n    }\n    \n    void OnDestroy()\n    {\n        if (_markerInstance != null)\n        {\n            DestroyImmediate(_markerInstance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ThrowingKnife\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"arcHeight\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 720\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"lifeTime\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"hasBeenThrown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"throw_knife\",\n      \"trigger\": \"when throw method is called with target position\",\n      \"actions\": [\n        {\n          \"action\": \"calculate arc trajectory toward target position with specified arc height\"\n        },\n        {\n          \"action\": \"apply throwing force in calculated direction\"\n        },\n        {\n          \"action\": \"start spinning knife around forward axis at rotation speed\"\n        },\n        {\n          \"action\": \"mark knife as thrown\"\n        },\n        {\n          \"action\": \"start lifetime countdown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spin_while_flying\",\n      \"trigger\": \"when knife has been thrown and is in the air\",\n      \"actions\": [\n        {\n          \"action\": \"continuously rotate knife around its forward axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_collision\",\n      \"trigger\": \"when knife collides with any object\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"stop spinning\"\n        },\n        {\n          \"action\": \"stick to the surface at collision point\"\n        },\n        {\n          \"action\": \"if collided object can take damage then apply damage amount\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_after_lifetime\",\n      \"trigger\": \"when lifetime countdown reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"destroy the knife object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ThrowingKnife : MonoBehaviour\n{\n    [Header(\"Throwing Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _arcHeight = 3f;\n    [SerializeField] private float _rotationSpeed = 720f;\n    [SerializeField] private float _maxThrowDistance = 20f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffectPrefab;\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    \n    [Header(\"Damage\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private bool _destroyOnHit = true;\n    [SerializeField] private float _lifeTime = 5f;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private AudioSource _audioSource;\n    private bool _hasBeenThrown = false;\n    private bool _hasHit = false;\n    private Vector3 _initialPosition;\n    private float _timeAlive = 0f;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _collider.isTrigger = true;\n        _initialPosition = transform.position;\n    }\n    \n    private void Start()\n    {\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasBeenThrown && !_hasHit)\n        {\n            _timeAlive += Time.deltaTime;\n            \n            if (_timeAlive >= _lifeTime)\n            {\n                DestroyKnife();\n                return;\n            }\n            \n            transform.Rotate(Vector3.forward * _rotationSpeed * Time.deltaTime);\n            \n            Vector3 currentVelocity = _rigidbody.velocity;\n            currentVelocity.y -= Physics.gravity.y * _gravityScale * Time.deltaTime;\n            _rigidbody.velocity = currentVelocity;\n            \n            if (Vector3.Distance(_initialPosition, transform.position) > _maxThrowDistance)\n            {\n                DestroyKnife();\n            }\n        }\n    }\n    \n    public void ThrowKnife(Vector3 targetPosition)\n    {\n        if (_hasBeenThrown) return;\n        \n        _hasBeenThrown = true;\n        _initialPosition = transform.position;\n        \n        Vector3 direction = (targetPosition - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetPosition);\n        \n        Vector3 velocity = CalculateArcVelocity(transform.position, targetPosition, _arcHeight);\n        \n        _rigidbody.velocity = velocity;\n        transform.LookAt(targetPosition);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        PlaySound(_throwSound);\n    }\n    \n    public void ThrowKnife(Vector3 direction, float force)\n    {\n        if (_hasBeenThrown) return;\n        \n        _hasBeenThrown = true;\n        _initialPosition = transform.position;\n        \n        Vector3 throwDirection = direction.normalized;\n        throwDirection.y += 0.3f;\n        \n        _rigidbody.velocity = throwDirection * force;\n        transform.LookAt(transform.position + throwDirection);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        PlaySound(_throwSound);\n    }\n    \n    private Vector3 CalculateArcVelocity(Vector3 startPos, Vector3 endPos, float arcHeight)\n    {\n        Vector3 direction = endPos - startPos;\n        Vector3 directionXZ = new Vector3(direction.x, 0, direction.z);\n        \n        float time = directionXZ.magnitude / _throwForce;\n        \n        Vector3 velocityXZ = directionXZ / time;\n        float velocityY = (direction.y + 0.5f * Physics.gravity.y * time * time) / time;\n        velocityY += Mathf.Sqrt(2 * Physics.gravity.y * arcHeight);\n        \n        return new Vector3(velocityXZ.x, velocityY, velocityXZ.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_hasBeenThrown || _hasHit) return;\n        \n        if (((1 << other.gameObject.layer) & _hitLayers) == 0) return;\n        \n        _hasHit = true;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n        \n        HandleHit(other);\n        PlaySound(_hitSound);\n        \n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, transform.position, transform.rotation);\n        }\n        \n        if (_destroyOnHit)\n        {\n            Invoke(nameof(DestroyKnife), 0.1f);\n        }\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            ApplyDamageToPlayer(hitCollider.gameObject);\n        }\n        else if (hitCollider.CompareTag(\"Enemy\"))\n        {\n            ApplyDamageToEnemy(hitCollider.gameObject);\n        }\n        \n        StickToSurface(hitCollider);\n    }\n    \n    private void ApplyDamageToPlayer(GameObject player)\n    {\n        var playerRigidbody = player.GetComponent<Rigidbody>();\n        if (playerRigidbody != null)\n        {\n            Vector3 knockback = transform.forward * 5f;\n            playerRigidbody.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n    \n    private void ApplyDamageToEnemy(GameObject enemy)\n    {\n        var enemyRigidbody = enemy.GetComponent<Rigidbody>();\n        if (enemyRigidbody != null)\n        {\n            Vector3 knockback = transform.forward * 3f;\n            enemyRigidbody.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        transform.SetParent(surface.transform);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, transform.forward, out hit, 1f))\n        {\n            transform.position = hit.point;\n            transform.rotation = Quaternion.LookRotation(hit.normal);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void DestroyKnife()\n    {\n        if (_hitEffectPrefab != null)\n        {\n            Instantiate(_hitEffectPrefab, transform.position, transform.rotation);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    public void ResetKnife()\n    {\n        _hasBeenThrown = false;\n        _hasHit = false;\n        _timeAlive = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = false;\n        _collider.isTrigger = true;\n        transform.SetParent(null);\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    public bool HasBeenThrown => _hasBeenThrown;\n    public bool HasHit => _hasHit;\n    public float Damage => _damage;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PressurePlate\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"targetDoor\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"activationWeight\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"pressSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"releaseSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isPressed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_plate\",\n      \"trigger\": \"when object with sufficient weight enters trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"lower pressure plate visually\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"mark plate as pressed\"\n        },\n        {\n          \"action\": \"send open command to target door\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_plate\",\n      \"trigger\": \"when all objects leave trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"raise pressure plate to original position\"\n        },\n        {\n          \"action\": \"play release sound effect\"\n        },\n        {\n          \"action\": \"mark plate as not pressed\"\n        },\n        {\n          \"action\": \"send close command to target door\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_activation\",\n      \"trigger\": \"when plate remains pressed with sufficient weight\",\n      \"actions\": [\n        {\n          \"action\": \"keep door in open state\"\n        },\n        {\n          \"action\": \"maintain pressed visual state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Pressure Plate Settings\")]\n    [SerializeField] private float _activationDelay = 0.1f;\n    [SerializeField] private float _deactivationDelay = 0.5f;\n    [SerializeField] private bool _stayActivated = false;\n    [SerializeField] private string[] _activatorTags = { \"Player\", \"Box\" };\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Transform _plateTransform;\n    [SerializeField] private float _pressedHeight = -0.1f;\n    [SerializeField] private float _normalHeight = 0f;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Door Connection\")]\n    [SerializeField] private DoorController _connectedDoor;\n    [SerializeField] private float _doorSearchRadius = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnActivated;\n    public UnityEvent OnDeactivated;\n    \n    private bool _isActivated = false;\n    private bool _hasObjectsOnPlate = false;\n    private int _objectsOnPlate = 0;\n    private AudioSource _audioSource;\n    private Vector3 _targetPosition;\n    private float _activationTimer = 0f;\n    private float _deactivationTimer = 0f;\n    private bool _pendingActivation = false;\n    private bool _pendingDeactivation = false;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        if (_plateTransform == null)\n            _plateTransform = transform;\n            \n        _targetPosition = _plateTransform.localPosition;\n        _targetPosition.y = _normalHeight;\n        _plateTransform.localPosition = _targetPosition;\n        \n        if (_connectedDoor == null)\n            FindNearbyDoor();\n    }\n    \n    private void Update()\n    {\n        HandleTimers();\n        AnimatePlate();\n    }\n    \n    private void HandleTimers()\n    {\n        if (_pendingActivation)\n        {\n            _activationTimer += Time.deltaTime;\n            if (_activationTimer >= _activationDelay)\n            {\n                ActivatePlate();\n                _pendingActivation = false;\n                _activationTimer = 0f;\n            }\n        }\n        \n        if (_pendingDeactivation && !_stayActivated)\n        {\n            _deactivationTimer += Time.deltaTime;\n            if (_deactivationTimer >= _deactivationDelay)\n            {\n                DeactivatePlate();\n                _pendingDeactivation = false;\n                _deactivationTimer = 0f;\n            }\n        }\n    }\n    \n    private void AnimatePlate()\n    {\n        Vector3 currentPos = _plateTransform.localPosition;\n        currentPos = Vector3.Lerp(currentPos, _targetPosition, Time.deltaTime * _animationSpeed);\n        _plateTransform.localPosition = currentPos;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidActivator(other))\n        {\n            _objectsOnPlate++;\n            \n            if (!_hasObjectsOnPlate)\n            {\n                _hasObjectsOnPlate = true;\n                _pendingActivation = true;\n                _pendingDeactivation = false;\n                _activationTimer = 0f;\n                _deactivationTimer = 0f;\n                \n                _targetPosition.y = _pressedHeight;\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsValidActivator(other))\n        {\n            _objectsOnPlate--;\n            \n            if (_objectsOnPlate <= 0)\n            {\n                _objectsOnPlate = 0;\n                _hasObjectsOnPlate = false;\n                \n                if (!_stayActivated)\n                {\n                    _pendingDeactivation = true;\n                    _pendingActivation = false;\n                    _activationTimer = 0f;\n                    _deactivationTimer = 0f;\n                }\n                \n                _targetPosition.y = _normalHeight;\n            }\n        }\n    }\n    \n    private bool IsValidActivator(Collider other)\n    {\n        foreach (string tag in _activatorTags)\n        {\n            if (other.CompareTag(tag))\n                return true;\n        }\n        return false;\n    }\n    \n    private void ActivatePlate()\n    {\n        if (_isActivated) return;\n        \n        _isActivated = true;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.OpenDoor();\n            \n        PlaySound(_activationSound);\n        OnActivated.Invoke();\n    }\n    \n    private void DeactivatePlate()\n    {\n        if (!_isActivated) return;\n        \n        _isActivated = false;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.CloseDoor();\n            \n        PlaySound(_deactivationSound);\n        OnDeactivated.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void FindNearbyDoor()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _doorSearchRadius);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            DoorController door = col.GetComponent<DoorController>();\n            if (door != null)\n            {\n                _connectedDoor = door;\n                break;\n            }\n        }\n    }\n    \n    public void ResetPlate()\n    {\n        _isActivated = false;\n        _hasObjectsOnPlate = false;\n        _objectsOnPlate = 0;\n        _pendingActivation = false;\n        _pendingDeactivation = false;\n        _activationTimer = 0f;\n        _deactivationTimer = 0f;\n        _targetPosition.y = _normalHeight;\n        \n        if (_connectedDoor != null)\n            _connectedDoor.CloseDoor();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _doorSearchRadius);\n        \n        if (_connectedDoor != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _connectedDoor.transform.position);\n        }\n    }\n}\n\npublic class DoorController : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private Transform _doorTransform;\n    [SerializeField] private Vector3 _openPosition;\n    [SerializeField] private Vector3 _closedPosition;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private AnimationCurve _openCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private Vector3 _targetPosition;\n    private AudioSource _audioSource;\n    private Coroutine _moveCoroutine;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_doorTransform == null)\n            _doorTransform = transform;\n            \n        _closedPosition = _doorTransform.localPosition;\n        _targetPosition = _closedPosition;\n    }\n    \n    public void OpenDoor()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _targetPosition = _openPosition;\n        \n        if (_moveCoroutine != null)\n            StopCoroutine(_moveCoroutine);\n            \n        _moveCoroutine = StartCoroutine(MoveDoor(_openPosition, _openSound));\n    }\n    \n    public void CloseDoor()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _targetPosition = _closedPosition;\n        \n        if (_moveCoroutine != null)\n            StopCoroutine(_moveCoroutine);\n            \n        _moveCoroutine = StartCoroutine(MoveDoor(_closedPosition, _closeSound));\n    }\n    \n    private System.Collections.IEnumerator MoveDoor(Vector3 targetPos, AudioClip sound)\n    {\n        _isMoving = true;\n        Vector3 startPos = _doorTransform.localPosition;\n        float journey = 0f;\n        float distance = Vector3.Distance(startPos, targetPos);\n        \n        if (_audioSource != null && sound != null)\n            _audioSource.PlayOneShot(sound);\n        \n        while (journey <= 1f)\n        {\n            journey += Time.deltaTime * _openSpeed;\n            float curveValue = _openCurve.Evaluate(journey);\n            _doorTransform.localPosition = Vector3.Lerp(startPos, targetPos, curveValue);\n            yield return null;\n        }\n        \n        _doorTransform.localPosition = targetPos;\n        _isMoving = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VendingMachine\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"selectedItem\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"itemCount\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"requiresCoin\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"hasCoin\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"dispensingItem\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"cycle_selection_up\",\n      \"trigger\": \"when up arrow key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase selected item number by one\"\n        },\n        {\n          \"action\": \"wrap selection to first item if past last item\"\n        },\n        {\n          \"action\": \"play selection sound effect\"\n        },\n        {\n          \"action\": \"update display to show current selection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cycle_selection_down\",\n      \"trigger\": \"when down arrow key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"decrease selected item number by one\"\n        },\n        {\n          \"action\": \"wrap selection to last item if before first item\"\n        },\n        {\n          \"action\": \"play selection sound effect\"\n        },\n        {\n          \"action\": \"update display to show current selection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"insert_coin\",\n      \"trigger\": \"when coin is inserted into machine\",\n      \"actions\": [\n        {\n          \"action\": \"set has coin status to true\"\n        },\n        {\n          \"action\": \"play coin insertion sound\"\n        },\n        {\n          \"action\": \"illuminate purchase button\"\n        }\n      ]\n    },\n    {\n      \"name\": \"purchase_item\",\n      \"trigger\": \"when purchase button is pressed and machine has coin\",\n      \"actions\": [\n        {\n          \"action\": \"set dispensing status to true\"\n        },\n        {\n          \"action\": \"set has coin status to false\"\n        },\n        {\n          \"action\": \"play dispensing motor sound\"\n        },\n        {\n          \"action\": \"spawn selected item at dispenser slot\"\n        },\n        {\n          \"action\": \"set dispensing status to false after delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reject_purchase\",\n      \"trigger\": \"when purchase button is pressed and machine has no coin\",\n      \"actions\": [\n        {\n          \"action\": \"play error buzzer sound\"\n        },\n        {\n          \"action\": \"flash coin required message on display\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class VendingMachine : MonoBehaviour\n{\n    [System.Serializable]\n    public class VendingItem\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public GameObject itemPrefab;\n        public int price;\n        public int stock;\n        public string description;\n    }\n\n    [System.Serializable]\n    public class PurchaseEvent : UnityEvent<string, int> { }\n\n    [Header(\"Vending Machine Settings\")]\n    [SerializeField] private List<VendingItem> _availableItems = new List<VendingItem>();\n    [SerializeField] private Transform _dispensingPoint;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _vendingUI;\n    [SerializeField] private Transform _itemButtonContainer;\n    [SerializeField] private Button _itemButtonPrefab;\n    [SerializeField] private Text _moneyDisplay;\n    [SerializeField] private Text _messageDisplay;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _purchaseSound;\n    [SerializeField] private AudioClip _errorSound;\n    [SerializeField] private AudioClip _dispensingSound;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Animator _machineAnimator;\n    [SerializeField] private ParticleSystem _dispensingEffect;\n\n    [Header(\"Events\")]\n    public PurchaseEvent OnItemPurchased;\n\n    private bool _isPlayerNearby = false;\n    private GameObject _currentPlayer;\n    private int _playerMoney = 100;\n    private List<Button> _itemButtons = new List<Button>();\n    private VendingItem _selectedItem;\n    private bool _isDispensing = false;\n\n    private void Start()\n    {\n        InitializeUI();\n        SetupEventListeners();\n        UpdateMoneyDisplay();\n        \n        if (_vendingUI != null)\n            _vendingUI.gameObject.SetActive(false);\n    }\n\n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n    }\n\n    private void InitializeUI()\n    {\n        if (_itemButtonContainer == null || _itemButtonPrefab == null) return;\n\n        foreach (Transform child in _itemButtonContainer)\n        {\n            if (child != _itemButtonPrefab.transform)\n                DestroyImmediate(child.gameObject);\n        }\n\n        _itemButtons.Clear();\n\n        for (int i = 0; i < _availableItems.Count; i++)\n        {\n            VendingItem item = _availableItems[i];\n            Button itemButton = Instantiate(_itemButtonPrefab, _itemButtonContainer);\n            itemButton.gameObject.SetActive(true);\n\n            Text[] texts = itemButton.GetComponentsInChildren<Text>();\n            Image[] images = itemButton.GetComponentsInChildren<Image>();\n\n            if (texts.Length > 0) texts[0].text = item.itemName;\n            if (texts.Length > 1) texts[1].text = $\"${item.price}\";\n            if (texts.Length > 2) texts[2].text = $\"Stock: {item.stock}\";\n\n            if (images.Length > 1 && item.itemIcon != null)\n                images[1].sprite = item.itemIcon;\n\n            int index = i;\n            itemButton.onClick.AddListener(() => SelectItem(index));\n            \n            _itemButtons.Add(itemButton);\n        }\n\n        if (_itemButtonPrefab != null)\n            _itemButtonPrefab.gameObject.SetActive(false);\n    }\n\n    private void SetupEventListeners()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(CloseVendingMachine);\n    }\n\n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange, _playerLayer);\n        bool playerFound = false;\n\n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                if (!_isPlayerNearby)\n                {\n                    _isPlayerNearby = true;\n                    _currentPlayer = col.gameObject;\n                    ShowInteractionPrompt();\n                }\n                playerFound = true;\n                break;\n            }\n        }\n\n        if (!playerFound && _isPlayerNearby)\n        {\n            _isPlayerNearby = false;\n            _currentPlayer = null;\n            HideInteractionPrompt();\n            CloseVendingMachine();\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_isPlayerNearby && Input.GetKeyDown(KeyCode.E))\n        {\n            if (_vendingUI != null && !_vendingUI.gameObject.activeInHierarchy)\n            {\n                OpenVendingMachine();\n            }\n        }\n\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            CloseVendingMachine();\n        }\n    }\n\n    private void OpenVendingMachine()\n    {\n        if (_vendingUI != null)\n        {\n            _vendingUI.gameObject.SetActive(true);\n            Time.timeScale = 0f;\n            Cursor.lockState = CursorLockMode.None;\n            Cursor.visible = true;\n            \n            RefreshItemButtons();\n            ShowMessage(\"Select an item to purchase\");\n        }\n    }\n\n    private void CloseVendingMachine()\n    {\n        if (_vendingUI != null && _vendingUI.gameObject.activeInHierarchy)\n        {\n            _vendingUI.gameObject.SetActive(false);\n            Time.timeScale = 1f;\n            Cursor.lockState = CursorLockMode.Locked;\n            Cursor.visible = false;\n            _selectedItem = null;\n        }\n    }\n\n    private void SelectItem(int itemIndex)\n    {\n        if (itemIndex < 0 || itemIndex >= _availableItems.Count) return;\n\n        _selectedItem = _availableItems[itemIndex];\n        \n        if (_selectedItem.stock <= 0)\n        {\n            ShowMessage(\"Item out of stock!\");\n            PlayErrorSound();\n            return;\n        }\n\n        if (_playerMoney < _selectedItem.price)\n        {\n            ShowMessage(\"Insufficient funds!\");\n            PlayErrorSound();\n            return;\n        }\n\n        PurchaseItem(_selectedItem, itemIndex);\n    }\n\n    private void PurchaseItem(VendingItem item, int itemIndex)\n    {\n        if (_isDispensing) return;\n\n        _playerMoney -= item.price;\n        item.stock--;\n        \n        UpdateMoneyDisplay();\n        RefreshItemButtons();\n        \n        ShowMessage($\"Purchased {item.itemName}!\");\n        PlayPurchaseSound();\n        \n        StartCoroutine(DispenseItem(item));\n        \n        OnItemPurchased?.Invoke(item.itemName, item.price);\n    }\n\n    private IEnumerator DispenseItem(VendingItem item)\n    {\n        _isDispensing = true;\n\n        if (_machineAnimator != null)\n            _machineAnimator.SetTrigger(\"Dispense\");\n\n        yield return new WaitForSeconds(0.5f);\n\n        if (_dispensingEffect != null)\n            _dispensingEffect.Play();\n\n        if (_dispensingSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_dispensingSound);\n\n        yield return new WaitForSeconds(1f);\n\n        if (item.itemPrefab != null && _dispensingPoint != null)\n        {\n            GameObject dispensedItem = Instantiate(item.itemPrefab, _dispensingPoint.position, _dispensingPoint.rotation);\n            \n            Rigidbody rb = dispensedItem.GetComponent<Rigidbody>();\n            if (rb == null)\n                rb = dispensedItem.AddComponent<Rigidbody>();\n            \n            rb.AddForce(Vector3.forward * 2f + Vector3.down * 1f, ForceMode.Impulse);\n        }\n\n        _isDispensing = false;\n    }\n\n    private void RefreshItemButtons()\n    {\n        for (int i = 0; i < _itemButtons.Count && i < _availableItems.Count; i++)\n        {\n            VendingItem item = _availableItems[i];\n            Button button = _itemButtons[i];\n            \n            Text[] texts = button.GetComponentsInChildren<Text>();\n            if (texts.Length > 2)\n                texts[2].text = $\"Stock: {item.stock}\";\n\n            button.interactable = item.stock > 0 && _playerMoney >= item.price;\n            \n            if (item.stock <= 0)\n            {\n                button.GetComponent<Image>().color = Color.gray;\n            }\n            else if (_playerMoney < item.price)\n            {\n                button.GetComponent<Image>().color = Color.red;\n            }\n            else\n            {\n                button.GetComponent<Image>().color = Color.white;\n            }\n        }\n    }\n\n    private void UpdateMoneyDisplay()\n    {\n        if (_moneyDisplay != null)\n            _moneyDisplay.text = $\"Money: ${_playerMoney}\";\n    }\n\n    private void ShowMessage(string message)\n    {\n        if (_messageDisplay != null)\n        {\n            _messageDisplay.text = message;\n            StopCoroutine(nameof(ClearMessageAfterDelay));\n            StartCoroutine(ClearMessageAfterDelay());\n        }\n    }\n\n    private IEnumerator ClearMessageAfterDelay()\n    {\n        yield return new WaitForSecondsRealtime(3f);\n        if (_messageDisplay != null)\n            _messageDisplay.text = \"\";\n    }\n\n    private void ShowInteractionPrompt()\n    {\n        // Override this method to show interaction UI\n    }\n\n    private void HideInteractionPrompt()\n    {\n        // Override this method to hide interaction UI\n    }\n\n    private void PlayPurchaseSound()\n    {\n        if (_audioSource != null && _purchaseSound != null)\n            _audioSource.PlayOneShot(_purchaseSound);\n    }\n\n    private void PlayErrorSound()\n    {\n        if (_audioSource != null && _errorSound != null)\n            _audioSource.PlayOneShot(_errorSound);\n    }\n\n    public void AddMoney(int amount)\n    {\n        _playerMoney += amount;\n        UpdateMoneyDisplay();\n        RefreshItemButtons();\n    }\n\n    public void RestockItem(int itemIndex, int amount)\n    {\n        if (itemIndex >= 0 && itemIndex < _availableItems.Count)\n        {\n            _availableItems[itemIndex].stock += amount;\n            RefreshItemButtons();\n        }\n    }\n\n    public void RestockAllItems(int amount)\n    {\n        for (int i = 0; i < _availableItems.Count; i++)\n        {\n            _availableItems[i].stock += amount;\n        }\n        RefreshItemButtons();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_dispensingPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_dispensingPoint.position, Vector3.one * 0.2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SecretRevealingPainting\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isSecretRevealed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"revealDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"revealSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"secretObject\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalTexture\",\n      \"type\": \"Texture\",\n      \"default\": null\n    },\n    {\n      \"name\": \"secretTexture\",\n      \"type\": \"Texture\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"reveal_secret_on_approach\",\n      \"trigger\": \"when player comes within reveal distance\",\n      \"actions\": [\n        {\n          \"action\": \"change painting texture to secret texture\"\n        },\n        {\n          \"action\": \"make secret object visible\"\n        },\n        {\n          \"action\": \"play reveal sound effect\"\n        },\n        {\n          \"action\": \"set secret revealed flag to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_secret_on_distance\",\n      \"trigger\": \"when player moves away beyond reveal distance and secret is currently revealed\",\n      \"actions\": [\n        {\n          \"action\": \"change painting texture back to normal texture\"\n        },\n        {\n          \"action\": \"make secret object invisible\"\n        },\n        {\n          \"action\": \"set secret revealed flag to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interact_with_painting\",\n      \"trigger\": \"when player clicks on painting while close enough\",\n      \"actions\": [\n        {\n          \"action\": \"toggle between normal and secret texture\"\n        },\n        {\n          \"action\": \"toggle secret object visibility\"\n        },\n        {\n          \"action\": \"play interaction sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SecretRevealingPainting : MonoBehaviour\n{\n    [Header(\"Painting Settings\")]\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Secret Reveal\")]\n    [SerializeField] private GameObject _secretObject;\n    [SerializeField] private Transform _secretRevealPosition;\n    [SerializeField] private float _revealDuration = 2f;\n    [SerializeField] private AnimationCurve _revealCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _revealParticles;\n    [SerializeField] private Light _mysticalLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _revealSound;\n    [SerializeField] private Material _glowMaterial;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private string _promptText = \"Press E to examine painting\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSecretRevealed;\n    public UnityEvent OnPlayerNearby;\n    public UnityEvent OnPlayerLeft;\n    \n    private bool _secretRevealed = false;\n    private bool _isRevealing = false;\n    private bool _playerNearby = false;\n    private Transform _playerTransform;\n    private Renderer _paintingRenderer;\n    private Material _originalMaterial;\n    private Vector3 _originalSecretPosition;\n    private Vector3 _originalSecretScale;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupSecret();\n        SetupUI();\n    }\n    \n    private void InitializeComponents()\n    {\n        _paintingRenderer = GetComponent<Renderer>();\n        if (_paintingRenderer != null)\n        {\n            _originalMaterial = _paintingRenderer.material;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = false;\n        }\n    }\n    \n    private void SetupSecret()\n    {\n        if (_secretObject != null)\n        {\n            _originalSecretPosition = _secretObject.transform.position;\n            _originalSecretScale = _secretObject.transform.localScale;\n            \n            if (_secretRevealPosition == null)\n            {\n                _secretRevealPosition = transform;\n            }\n            \n            _secretObject.transform.localScale = Vector3.zero;\n            _secretObject.SetActive(false);\n        }\n    }\n    \n    private void SetupUI()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _interactionDistance, _playerLayer);\n        bool playerFound = false;\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                playerFound = true;\n                _playerTransform = col.transform;\n                \n                if (!_playerNearby)\n                {\n                    OnPlayerEntered();\n                }\n                break;\n            }\n        }\n        \n        if (!playerFound && _playerNearby)\n        {\n            OnPlayerExited();\n        }\n    }\n    \n    private void OnPlayerEntered()\n    {\n        _playerNearby = true;\n        \n        if (_interactionPrompt != null && !_secretRevealed)\n        {\n            _interactionPrompt.SetActive(true);\n        }\n        \n        OnPlayerNearby?.Invoke();\n    }\n    \n    private void OnPlayerExited()\n    {\n        _playerNearby = false;\n        _playerTransform = null;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        OnPlayerLeft?.Invoke();\n    }\n    \n    private void HandleInput()\n    {\n        if (_playerNearby && !_secretRevealed && !_isRevealing && Input.GetKeyDown(_interactionKey))\n        {\n            RevealSecret();\n        }\n    }\n    \n    private void RevealSecret()\n    {\n        if (_secretRevealed || _isRevealing) return;\n        \n        _isRevealing = true;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        StartCoroutine(RevealSequence());\n    }\n    \n    private System.Collections.IEnumerator RevealSequence()\n    {\n        // Start visual effects\n        if (_revealParticles != null)\n        {\n            _revealParticles.Play();\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = true;\n        }\n        \n        // Play sound\n        if (_audioSource != null && _revealSound != null)\n        {\n            _audioSource.PlayOneShot(_revealSound);\n        }\n        \n        // Change painting material\n        if (_paintingRenderer != null && _glowMaterial != null)\n        {\n            _paintingRenderer.material = _glowMaterial;\n        }\n        \n        // Reveal secret object\n        if (_secretObject != null)\n        {\n            _secretObject.SetActive(true);\n            _secretObject.transform.position = _secretRevealPosition.position;\n            \n            float elapsedTime = 0f;\n            \n            while (elapsedTime < _revealDuration)\n            {\n                elapsedTime += Time.deltaTime;\n                float progress = elapsedTime / _revealDuration;\n                float curveValue = _revealCurve.Evaluate(progress);\n                \n                _secretObject.transform.localScale = Vector3.Lerp(Vector3.zero, _originalSecretScale, curveValue);\n                \n                if (_mysticalLight != null)\n                {\n                    _mysticalLight.intensity = Mathf.Lerp(0f, 2f, curveValue);\n                }\n                \n                yield return null;\n            }\n            \n            _secretObject.transform.localScale = _originalSecretScale;\n        }\n        \n        _secretRevealed = true;\n        _isRevealing = false;\n        \n        OnSecretRevealed?.Invoke();\n        \n        // Fade out light after reveal\n        if (_mysticalLight != null)\n        {\n            StartCoroutine(FadeLight());\n        }\n    }\n    \n    private System.Collections.IEnumerator FadeLight()\n    {\n        yield return new WaitForSeconds(1f);\n        \n        float startIntensity = _mysticalLight.intensity;\n        float elapsedTime = 0f;\n        float fadeDuration = 2f;\n        \n        while (elapsedTime < fadeDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / fadeDuration;\n            \n            _mysticalLight.intensity = Mathf.Lerp(startIntensity, 0.5f, progress);\n            \n            yield return null;\n        }\n    }\n    \n    public void ResetPainting()\n    {\n        _secretRevealed = false;\n        _isRevealing = false;\n        \n        if (_secretObject != null)\n        {\n            _secretObject.SetActive(false);\n            _secretObject.transform.position = _originalSecretPosition;\n            _secretObject.transform.localScale = Vector3.zero;\n        }\n        \n        if (_paintingRenderer != null && _originalMaterial != null)\n        {\n            _paintingRenderer.material = _originalMaterial;\n        }\n        \n        if (_mysticalLight != null)\n        {\n            _mysticalLight.enabled = false;\n        }\n        \n        if (_revealParticles != null)\n        {\n            _revealParticles.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n        \n        if (_secretRevealPosition != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_secretRevealPosition.position, Vector3.one * 0.5f);\n            Gizmos.DrawLine(transform.position, _secretRevealPosition.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParticleEmitterTrigger\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"emissionDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"particleCount\",\n      \"type\": \"int\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"emit_particles_on_trigger_enter\",\n      \"trigger\": \"when another object enters the trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"start emitting particles\"\n        },\n        {\n          \"action\": \"set particle emission count to specified amount\"\n        },\n        {\n          \"action\": \"play particle system for the specified duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_particles_on_trigger_exit\",\n      \"trigger\": \"when object leaves the trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"stop emitting new particles\"\n        },\n        {\n          \"action\": \"allow existing particles to fade out naturally\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ParticleEmitterTrigger : MonoBehaviour\n{\n    [Header(\"Particle System\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private bool _createParticleSystemIfNull = true;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private bool _emitOnEnter = true;\n    [SerializeField] private bool _emitOnExit = false;\n    [SerializeField] private bool _emitOnStay = false;\n    [SerializeField] private float _stayEmissionInterval = 0.5f;\n    \n    [Header(\"Emission Settings\")]\n    [SerializeField] private int _particlesToEmit = 50;\n    [SerializeField] private bool _useCustomEmissionRate = false;\n    [SerializeField] private float _customEmissionRate = 100f;\n    [SerializeField] private float _emissionDuration = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _emissionSound;\n    [SerializeField] private bool _playAudioOnEmit = false;\n    \n    private float _lastStayEmissionTime;\n    private bool _isEmitting;\n    private float _emissionStartTime;\n    private float _originalEmissionRate;\n    \n    private void Start()\n    {\n        if (_particleSystem == null)\n        {\n            _particleSystem = GetComponent<ParticleSystem>();\n            \n            if (_particleSystem == null && _createParticleSystemIfNull)\n            {\n                _particleSystem = gameObject.AddComponent<ParticleSystem>();\n                ConfigureDefaultParticleSystem();\n            }\n        }\n        \n        if (_particleSystem != null)\n        {\n            var emission = _particleSystem.emission;\n            _originalEmissionRate = emission.rateOverTime.constant;\n            emission.enabled = false;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        Collider triggerCollider = GetComponent<Collider>();\n        if (triggerCollider != null)\n        {\n            triggerCollider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isEmitting && _useCustomEmissionRate)\n        {\n            if (Time.time - _emissionStartTime >= _emissionDuration)\n            {\n                StopEmission();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnEnter)\n        {\n            EmitParticles();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnExit)\n        {\n            EmitParticles();\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(_targetTag) && _emitOnStay)\n        {\n            if (Time.time - _lastStayEmissionTime >= _stayEmissionInterval)\n            {\n                EmitParticles();\n                _lastStayEmissionTime = Time.time;\n            }\n        }\n    }\n    \n    private void EmitParticles()\n    {\n        if (_particleSystem == null) return;\n        \n        if (_useCustomEmissionRate)\n        {\n            StartCustomEmission();\n        }\n        else\n        {\n            _particleSystem.Emit(_particlesToEmit);\n        }\n        \n        PlayEmissionAudio();\n    }\n    \n    private void StartCustomEmission()\n    {\n        var emission = _particleSystem.emission;\n        emission.enabled = true;\n        emission.rateOverTime = _customEmissionRate;\n        \n        _isEmitting = true;\n        _emissionStartTime = Time.time;\n    }\n    \n    private void StopEmission()\n    {\n        if (_particleSystem == null) return;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        emission.rateOverTime = _originalEmissionRate;\n        \n        _isEmitting = false;\n    }\n    \n    private void PlayEmissionAudio()\n    {\n        if (_playAudioOnEmit && _audioSource != null && _emissionSound != null)\n        {\n            _audioSource.PlayOneShot(_emissionSound);\n        }\n    }\n    \n    private void ConfigureDefaultParticleSystem()\n    {\n        if (_particleSystem == null) return;\n        \n        var main = _particleSystem.main;\n        main.startLifetime = 2f;\n        main.startSpeed = 5f;\n        main.startSize = 0.1f;\n        main.startColor = Color.white;\n        main.maxParticles = 1000;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        emission.rateOverTime = 50f;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Sphere;\n        shape.radius = 1f;\n        \n        var velocityOverLifetime = _particleSystem.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;\n        velocityOverLifetime.radial = new ParticleSystem.MinMaxCurve(2f);\n    }\n    \n    public void ForceEmit()\n    {\n        EmitParticles();\n    }\n    \n    public void ForceEmit(int particleCount)\n    {\n        if (_particleSystem != null)\n        {\n            _particleSystem.Emit(particleCount);\n            PlayEmissionAudio();\n        }\n    }\n    \n    public void SetTargetTag(string newTag)\n    {\n        _targetTag = newTag;\n    }\n    \n    public void SetParticleCount(int count)\n    {\n        _particlesToEmit = Mathf.Max(0, count);\n    }\n    \n    private void OnValidate()\n    {\n        _particlesToEmit = Mathf.Max(0, _particlesToEmit);\n        _stayEmissionInterval = Mathf.Max(0.1f, _stayEmissionInterval);\n        _emissionDuration = Mathf.Max(0.1f, _emissionDuration);\n        _customEmissionRate = Mathf.Max(0f, _customEmissionRate);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LobbyRoomSystem\",\n  \"components\": [\n    \"NetworkBehaviour\",\n    \"Canvas\",\n    \"Button\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxPlayersPerRoom\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"roomListUpdateInterval\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"roomNamePrefix\",\n      \"type\": \"string\",\n      \"default\": \"Room\"\n    },\n    {\n      \"name\": \"isHost\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentRoomName\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"playerCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"create_new_room\",\n      \"trigger\": \"when create room button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"generate unique room name with prefix and random number\"\n        },\n        {\n          \"action\": \"create new multiplayer room with generated name\"\n        },\n        {\n          \"action\": \"set local player as room host\"\n        },\n        {\n          \"action\": \"join the newly created room\"\n        },\n        {\n          \"action\": \"update room display with current room info\"\n        }\n      ]\n    },\n    {\n      \"name\": \"join_existing_room\",\n      \"trigger\": \"when room from list is selected and join button clicked\",\n      \"actions\": [\n        {\n          \"action\": \"attempt to join selected room\"\n        },\n        {\n          \"action\": \"check if room has available slots\"\n        },\n        {\n          \"action\": \"add local player to room if space available\"\n        },\n        {\n          \"action\": \"update player count display\"\n        },\n        {\n          \"action\": \"show room full message if no space available\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refresh_room_list\",\n      \"trigger\": \"when refresh interval timer expires or refresh button clicked\",\n      \"actions\": [\n        {\n          \"action\": \"query server for available rooms\"\n        },\n        {\n          \"action\": \"update room list display with current rooms\"\n        },\n        {\n          \"action\": \"show player count for each room\"\n        },\n        {\n          \"action\": \"highlight rooms that are not full\"\n        }\n      ]\n    },\n    {\n      \"name\": \"leave_current_room\",\n      \"trigger\": \"when leave room button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"remove local player from current room\"\n        },\n        {\n          \"action\": \"update room player count\"\n        },\n        {\n          \"action\": \"return to main lobby interface\"\n        },\n        {\n          \"action\": \"clear current room information\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_game_session\",\n      \"trigger\": \"when host clicks start game and minimum players present\",\n      \"actions\": [\n        {\n          \"action\": \"check if minimum player count is met\"\n        },\n        {\n          \"action\": \"lock room to prevent new players joining\"\n        },\n        {\n          \"action\": \"send start game signal to all room members\"\n        },\n        {\n          \"action\": \"transition all players to game scene\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_player_disconnect\",\n      \"trigger\": \"when any player in room disconnects\",\n      \"actions\": [\n        {\n          \"action\": \"remove disconnected player from room\"\n        },\n        {\n          \"action\": \"update player count display\"\n        },\n        {\n          \"action\": \"reassign host if disconnected player was host\"\n        },\n        {\n          \"action\": \"notify remaining players of disconnection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_room_status\",\n      \"trigger\": \"when room state changes or new player joins\",\n      \"actions\": [\n        {\n          \"action\": \"refresh current player list in room\"\n        },\n        {\n          \"action\": \"update ready status indicators for each player\"\n        },\n        {\n          \"action\": \"enable or disable start button based on player readiness\"\n        },\n        {\n          \"action\": \"broadcast room status to all connected players\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class LobbyRoomSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class Room\n    {\n        public string roomName;\n        public string roomId;\n        public int currentPlayers;\n        public int maxPlayers;\n        public bool isPrivate;\n        public string password;\n        public bool isInGame;\n        public List<string> playerNames;\n\n        public Room(string name, string id, int maxPlayers, bool isPrivate = false, string password = \"\")\n        {\n            this.roomName = name;\n            this.roomId = id;\n            this.maxPlayers = maxPlayers;\n            this.isPrivate = isPrivate;\n            this.password = password;\n            this.currentPlayers = 0;\n            this.isInGame = false;\n            this.playerNames = new List<string>();\n        }\n\n        public bool CanJoin()\n        {\n            return currentPlayers < maxPlayers && !isInGame;\n        }\n\n        public bool AddPlayer(string playerName)\n        {\n            if (CanJoin() && !playerNames.Contains(playerName))\n            {\n                playerNames.Add(playerName);\n                currentPlayers++;\n                return true;\n            }\n            return false;\n        }\n\n        public bool RemovePlayer(string playerName)\n        {\n            if (playerNames.Contains(playerName))\n            {\n                playerNames.Remove(playerName);\n                currentPlayers--;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    [System.Serializable]\n    public class RoomEvents\n    {\n        public UnityEvent<Room> OnRoomCreated;\n        public UnityEvent<Room> OnRoomJoined;\n        public UnityEvent<Room> OnRoomLeft;\n        public UnityEvent<Room> OnRoomUpdated;\n        public UnityEvent<string> OnRoomDeleted;\n        public UnityEvent<string> OnError;\n    }\n\n    [Header(\"Room Settings\")]\n    [SerializeField] private int _maxRoomsCount = 50;\n    [SerializeField] private int _defaultMaxPlayers = 4;\n    [SerializeField] private float _roomUpdateInterval = 1f;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Transform _roomListParent;\n    [SerializeField] private GameObject _roomItemPrefab;\n    [SerializeField] private Button _createRoomButton;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private InputField _roomNameInput;\n    [SerializeField] private InputField _maxPlayersInput;\n    [SerializeField] private Toggle _privateRoomToggle;\n    [SerializeField] private InputField _passwordInput;\n    [SerializeField] private GameObject _createRoomPanel;\n    [SerializeField] private GameObject _passwordPanel;\n    [SerializeField] private InputField _passwordEntryInput;\n    [SerializeField] private Button _joinWithPasswordButton;\n    [SerializeField] private Button _cancelPasswordButton;\n\n    [Header(\"Current Room UI\")]\n    [SerializeField] private GameObject _currentRoomPanel;\n    [SerializeField] private Text _currentRoomNameText;\n    [SerializeField] private Text _currentRoomPlayersText;\n    [SerializeField] private Transform _playerListParent;\n    [SerializeField] private GameObject _playerItemPrefab;\n    [SerializeField] private Button _leaveRoomButton;\n    [SerializeField] private Button _startGameButton;\n\n    [Header(\"Events\")]\n    [SerializeField] private RoomEvents _roomEvents;\n\n    private Dictionary<string, Room> _rooms = new Dictionary<string, Room>();\n    private List<GameObject> _roomUIItems = new List<GameObject>();\n    private List<GameObject> _playerUIItems = new List<GameObject>();\n    private Room _currentRoom;\n    private string _currentPlayerName = \"Player\";\n    private Room _pendingJoinRoom;\n    private float _lastUpdateTime;\n\n    private void Start()\n    {\n        InitializeUI();\n        SetCurrentPlayerName();\n        RefreshRoomList();\n    }\n\n    private void Update()\n    {\n        if (Time.time - _lastUpdateTime >= _roomUpdateInterval)\n        {\n            UpdateRoomList();\n            _lastUpdateTime = Time.time;\n        }\n    }\n\n    private void InitializeUI()\n    {\n        if (_createRoomButton != null)\n            _createRoomButton.onClick.AddListener(ShowCreateRoomPanel);\n\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshRoomList);\n\n        if (_leaveRoomButton != null)\n            _leaveRoomButton.onClick.AddListener(LeaveCurrentRoom);\n\n        if (_startGameButton != null)\n            _startGameButton.onClick.AddListener(StartGame);\n\n        if (_joinWithPasswordButton != null)\n            _joinWithPasswordButton.onClick.AddListener(JoinRoomWithPassword);\n\n        if (_cancelPasswordButton != null)\n            _cancelPasswordButton.onClick.AddListener(CancelPasswordEntry);\n\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(false);\n\n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(false);\n    }\n\n    private void SetCurrentPlayerName()\n    {\n        _currentPlayerName = \"Player_\" + Random.Range(1000, 9999);\n    }\n\n    public void ShowCreateRoomPanel()\n    {\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(true);\n    }\n\n    public void HideCreateRoomPanel()\n    {\n        if (_createRoomPanel != null)\n            _createRoomPanel.SetActive(false);\n    }\n\n    public void CreateRoom()\n    {\n        string roomName = _roomNameInput != null ? _roomNameInput.text : \"New Room\";\n        int maxPlayers = _defaultMaxPlayers;\n\n        if (_maxPlayersInput != null && !string.IsNullOrEmpty(_maxPlayersInput.text))\n        {\n            if (!int.TryParse(_maxPlayersInput.text, out maxPlayers))\n                maxPlayers = _defaultMaxPlayers;\n        }\n\n        maxPlayers = Mathf.Clamp(maxPlayers, 1, 8);\n\n        bool isPrivate = _privateRoomToggle != null && _privateRoomToggle.isOn;\n        string password = isPrivate && _passwordInput != null ? _passwordInput.text : \"\";\n\n        if (string.IsNullOrEmpty(roomName.Trim()))\n        {\n            _roomEvents.OnError?.Invoke(\"Room name cannot be empty\");\n            return;\n        }\n\n        if (_rooms.Count >= _maxRoomsCount)\n        {\n            _roomEvents.OnError?.Invoke(\"Maximum number of rooms reached\");\n            return;\n        }\n\n        string roomId = System.Guid.NewGuid().ToString();\n        Room newRoom = new Room(roomName.Trim(), roomId, maxPlayers, isPrivate, password);\n\n        _rooms[roomId] = newRoom;\n        newRoom.AddPlayer(_currentPlayerName);\n        _currentRoom = newRoom;\n\n        _roomEvents.OnRoomCreated?.Invoke(newRoom);\n        UpdateCurrentRoomUI();\n        HideCreateRoomPanel();\n        RefreshRoomList();\n    }\n\n    public void JoinRoom(string roomId)\n    {\n        if (!_rooms.ContainsKey(roomId))\n        {\n            _roomEvents.OnError?.Invoke(\"Room not found\");\n            return;\n        }\n\n        Room room = _rooms[roomId];\n\n        if (!room.CanJoin())\n        {\n            _roomEvents.OnError?.Invoke(\"Cannot join room\");\n            return;\n        }\n\n        if (room.isPrivate)\n        {\n            _pendingJoinRoom = room;\n            ShowPasswordPanel();\n            return;\n        }\n\n        JoinRoomInternal(room);\n    }\n\n    private void JoinRoomInternal(Room room)\n    {\n        if (_currentRoom != null)\n            LeaveCurrentRoom();\n\n        if (room.AddPlayer(_currentPlayerName))\n        {\n            _currentRoom = room;\n            _roomEvents.OnRoomJoined?.Invoke(room);\n            UpdateCurrentRoomUI();\n            RefreshRoomList();\n        }\n        else\n        {\n            _roomEvents.OnError?.Invoke(\"Failed to join room\");\n        }\n    }\n\n    private void ShowPasswordPanel()\n    {\n        if (_passwordPanel != null)\n        {\n            _passwordPanel.SetActive(true);\n            if (_passwordEntryInput != null)\n                _passwordEntryInput.text = \"\";\n        }\n    }\n\n    private void JoinRoomWithPassword()\n    {\n        if (_pendingJoinRoom == null)\n            return;\n\n        string enteredPassword = _passwordEntryInput != null ? _passwordEntryInput.text : \"\";\n\n        if (_pendingJoinRoom.password == enteredPassword)\n        {\n            JoinRoomInternal(_pendingJoinRoom);\n            _passwordPanel.SetActive(false);\n            _pendingJoinRoom = null;\n        }\n        else\n        {\n            _roomEvents.OnError?.Invoke(\"Incorrect password\");\n        }\n    }\n\n    private void CancelPasswordEntry()\n    {\n        _pendingJoinRoom = null;\n        if (_passwordPanel != null)\n            _passwordPanel.SetActive(false);\n    }\n\n    public void LeaveCurrentRoom()\n    {\n        if (_currentRoom == null)\n            return;\n\n        _currentRoom.RemovePlayer(_currentPlayerName);\n\n        if (_currentRoom.currentPlayers == 0)\n        {\n            _rooms.Remove(_currentRoom.roomId);\n            _roomEvents.OnRoomDeleted?.Invoke(_currentRoom.roomId);\n        }\n        else\n        {\n            _roomEvents.OnRoomUpdated?.Invoke(_currentRoom);\n        }\n\n        _roomEvents.OnRoomLeft?.Invoke(_currentRoom);\n        _currentRoom = null;\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(false);\n\n        RefreshRoomList();\n    }\n\n    public void StartGame()\n    {\n        if (_currentRoom == null)\n            return;\n\n        _currentRoom.isInGame = true;\n        _roomEvents.OnRoomUpdated?.Invoke(_currentRoom);\n        RefreshRoomList();\n    }\n\n    public void RefreshRoomList()\n    {\n        ClearRoomUI();\n        CreateRoomUIItems();\n    }\n\n    private void UpdateRoomList()\n    {\n        if (_currentRoom != null)\n            UpdateCurrentRoomUI();\n    }\n\n    private void ClearRoomUI()\n    {\n        foreach (GameObject item in _roomUIItems)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _roomUIItems.Clear();\n    }\n\n    private void CreateRoomUIItems()\n    {\n        if (_roomListParent == null || _roomItemPrefab == null)\n            return;\n\n        foreach (Room room in _rooms.Values)\n        {\n            GameObject roomItem = Instantiate(_roomItemPrefab, _roomListParent);\n            _roomUIItems.Add(roomItem);\n\n            Text[] texts = roomItem.GetComponentsInChildren<Text>();\n            if (texts.Length >= 3)\n            {\n                texts[0].text = room.roomName;\n                texts[1].text = $\"{room.currentPlayers}/{room.maxPlayers}\";\n                texts[2].text = room.isInGame ? \"In Game\" : \"Waiting\";\n            }\n\n            Button joinButton = roomItem.GetComponentInChildren<Button>();\n            if (joinButton != null)\n            {\n                string roomId = room.roomId;\n                joinButton.onClick.RemoveAllListeners();\n                joinButton.onClick.AddListener(() => JoinRoom(roomId));\n                joinButton.interactable = room.CanJoin();\n            }\n\n            Image lockIcon = roomItem.transform.Find(\"LockIcon\")?.GetComponent<Image>();\n            if (lockIcon != null)\n                lockIcon.gameObject.SetActive(room.isPrivate);\n        }\n    }\n\n    private void UpdateCurrentRoomUI()\n    {\n        if (_currentRoom == null)\n        {\n            if (_currentRoomPanel != null)\n                _currentRoomPanel.SetActive(false);\n            return;\n        }\n\n        if (_currentRoomPanel != null)\n            _currentRoomPanel.SetActive(true);\n\n        if (_currentRoomNameText != null)\n            _currentRoomNameText.text = _currentRoom.roomName;\n\n        if (_currentRoomPlayersText != null)\n            _currentRoomPlayersText.text = $\"Players: {_currentRoom.currentPlayers}/{_currentRoom.maxPlayers}\";\n\n        UpdatePlayerList();\n\n        if (_startGameButton != null)\n            _startGameButton.interactable = _currentRoom.currentPlayers > 1 && !_currentRoom.isInGame;\n    }\n\n    private void UpdatePlayerList()\n    {\n        ClearPlayerUI();\n\n        if (_playerListParent == null || _playerItemPrefab == null || _currentRoom == null)\n            return;\n\n        foreach (string playerName in _currentRoom.playerNames)\n        {\n            GameObject playerItem = Instantiate(_playerItemPrefab, _playerListParent);\n            _playerUIItems.Add(playerItem);\n\n            Text playerText = playerItem.GetComponentInChildren<Text>();\n            if (playerText != null)\n                playerText.text = playerName;\n        }\n    }\n\n    private void ClearPlayerUI()\n    {\n        foreach (GameObject item in _playerUIItems)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _playerUIItems.Clear();\n    }\n\n    public Room GetCurrentRoom()\n    {\n        return _currentRoom;\n    }\n\n    public Dictionary<string, Room> GetAllRooms()\n    {\n        return new Dictionary<string, Room>(_rooms);\n    }\n\n    public void SetPlayerName(string playerName)\n    {\n        if (!string.IsNullOrEmpty(playerName))\n            _currentPlayerName = playerName;\n    }\n\n    public string GetPlayerName()\n    {\n        return _currentPlayerName;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpookyNightObject\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"erraticMoveForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"spookyAudioClip\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    },\n    {\n      \"name\": \"glowMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spooky_time_activation\",\n      \"trigger\": \"when current system time is between 2 AM and 4 AM and exactly 7 other Rigidbody objects exist in the scene\",\n      \"actions\": [\n        {\n          \"action\": \"switch renderer material to glow material\"\n        },\n        {\n          \"action\": \"increase material emission intensity to glow level\"\n        },\n        {\n          \"action\": \"start playing spooky audio clip on loop\"\n        },\n        {\n          \"action\": \"apply random erratic forces to rigidbody in all directions\"\n        },\n        {\n          \"action\": \"randomly change movement direction every few seconds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"normal_time_deactivation\",\n      \"trigger\": \"when current system time is not between 2 AM and 4 AM or exactly 7 other Rigidbody objects do not exist in the scene\",\n      \"actions\": [\n        {\n          \"action\": \"switch renderer material back to normal material\"\n        },\n        {\n          \"action\": \"reset material emission to normal levels\"\n        },\n        {\n          \"action\": \"stop playing spooky audio\"\n        },\n        {\n          \"action\": \"stop applying erratic forces to rigidbody\"\n        },\n        {\n          \"action\": \"return to normal physics behavior\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System;\nusing System.Collections;\n\npublic class SpookyTimeObject : MonoBehaviour\n{\n    [Header(\"Time Settings\")]\n    [SerializeField] private int _startHour = 2;\n    [SerializeField] private int _endHour = 4;\n    [SerializeField] private bool _useSystemTime = true;\n    [SerializeField] private float _simulatedTimeSpeed = 1f;\n    \n    [Header(\"Glow Effect\")]\n    [SerializeField] private Material _glowMaterial;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Color _glowColor = Color.red;\n    [SerializeField] private float _glowIntensity = 2f;\n    [SerializeField] private float _glowPulseSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _spookySounds;\n    [SerializeField] private float _soundInterval = 3f;\n    [SerializeField] private float _soundVolume = 0.5f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _movementIntensity = 2f;\n    [SerializeField] private float _movementSpeed = 1f;\n    [SerializeField] private Vector3 _movementRange = new Vector3(5f, 2f, 5f);\n    \n    [Header(\"Rigidbody Check\")]\n    [SerializeField] private int _requiredRigidbodyCount = 7;\n    [SerializeField] private float _rigidbodyCheckInterval = 1f;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    private bool _isSpookyTime = false;\n    private bool _hasCorrectRigidbodyCount = false;\n    private bool _isActive = false;\n    private float _simulatedTime = 0f;\n    private Coroutine _movementCoroutine;\n    private Coroutine _soundCoroutine;\n    private Coroutine _rigidbodyCheckCoroutine;\n    private Material _originalMaterial;\n    \n    void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _soundVolume;\n        _audioSource.playOnAwake = false;\n        \n        _originalPosition = transform.position;\n        \n        if (_renderer != null && _normalMaterial != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n        \n        _simulatedTime = (float)(DateTime.Now.Hour * 3600 + DateTime.Now.Minute * 60 + DateTime.Now.Second);\n        \n        StartCoroutine(TimeCheckCoroutine());\n        _rigidbodyCheckCoroutine = StartCoroutine(RigidbodyCheckCoroutine());\n    }\n    \n    void Update()\n    {\n        if (!_useSystemTime)\n        {\n            _simulatedTime += Time.deltaTime * _simulatedTimeSpeed * 3600f;\n            if (_simulatedTime >= 86400f)\n            {\n                _simulatedTime -= 86400f;\n            }\n        }\n        \n        UpdateGlowEffect();\n    }\n    \n    IEnumerator TimeCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckSpookyTime();\n            yield return new WaitForSeconds(1f);\n        }\n    }\n    \n    IEnumerator RigidbodyCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckRigidbodyCount();\n            yield return new WaitForSeconds(_rigidbodyCheckInterval);\n        }\n    }\n    \n    void CheckSpookyTime()\n    {\n        int currentHour;\n        \n        if (_useSystemTime)\n        {\n            currentHour = DateTime.Now.Hour;\n        }\n        else\n        {\n            currentHour = Mathf.FloorToInt(_simulatedTime / 3600f) % 24;\n        }\n        \n        bool wasSpookyTime = _isSpookyTime;\n        _isSpookyTime = (currentHour >= _startHour && currentHour < _endHour);\n        \n        if (_isSpookyTime != wasSpookyTime)\n        {\n            UpdateActiveState();\n        }\n    }\n    \n    void CheckRigidbodyCount()\n    {\n        Rigidbody[] allRigidbodies = FindObjectsOfType<Rigidbody>();\n        int count = 0;\n        \n        foreach (Rigidbody rb in allRigidbodies)\n        {\n            if (rb.gameObject != gameObject)\n            {\n                count++;\n            }\n        }\n        \n        bool wasCorrect = _hasCorrectRigidbodyCount;\n        _hasCorrectRigidbodyCount = (count == _requiredRigidbodyCount);\n        \n        if (_hasCorrectRigidbodyCount != wasCorrect)\n        {\n            UpdateActiveState();\n        }\n    }\n    \n    void UpdateActiveState()\n    {\n        bool shouldBeActive = _isSpookyTime && _hasCorrectRigidbodyCount;\n        \n        if (shouldBeActive && !_isActive)\n        {\n            ActivateSpookyBehavior();\n        }\n        else if (!shouldBeActive && _isActive)\n        {\n            DeactivateSpookyBehavior();\n        }\n        \n        _isActive = shouldBeActive;\n    }\n    \n    void ActivateSpookyBehavior()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n        }\n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n        }\n        \n        _movementCoroutine = StartCoroutine(ErraticMovementCoroutine());\n        _soundCoroutine = StartCoroutine(SpookySoundCoroutine());\n        \n        SetGlowMaterial(true);\n    }\n    \n    void DeactivateSpookyBehavior()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n            _movementCoroutine = null;\n        }\n        \n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n            _soundCoroutine = null;\n        }\n        \n        if (_audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        transform.position = _originalPosition;\n        SetGlowMaterial(false);\n    }\n    \n    void SetGlowMaterial(bool useGlow)\n    {\n        if (_renderer == null) return;\n        \n        if (useGlow && _glowMaterial != null)\n        {\n            _renderer.material = _glowMaterial;\n        }\n        else if (!useGlow)\n        {\n            if (_normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n            }\n            else if (_originalMaterial != null)\n            {\n                _renderer.material = _originalMaterial;\n            }\n        }\n    }\n    \n    void UpdateGlowEffect()\n    {\n        if (!_isActive || _renderer == null) return;\n        \n        float pulse = Mathf.Sin(Time.time * _glowPulseSpeed) * 0.5f + 0.5f;\n        Color currentColor = _glowColor * (_glowIntensity * pulse);\n        \n        if (_renderer.material.HasProperty(\"_EmissionColor\"))\n        {\n            _renderer.material.SetColor(\"_EmissionColor\", currentColor);\n        }\n        else if (_renderer.material.HasProperty(\"_Color\"))\n        {\n            _renderer.material.color = Color.Lerp(Color.white, _glowColor, pulse);\n        }\n    }\n    \n    IEnumerator ErraticMovementCoroutine()\n    {\n        while (_isActive)\n        {\n            Vector3 randomOffset = new Vector3(\n                UnityEngine.Random.Range(-_movementRange.x, _movementRange.x),\n                UnityEngine.Random.Range(-_movementRange.y, _movementRange.y),\n                UnityEngine.Random.Range(-_movementRange.z, _movementRange.z)\n            ) * _movementIntensity;\n            \n            Vector3 targetPosition = _originalPosition + randomOffset;\n            \n            float duration = UnityEngine.Random.Range(0.5f, 2f) / _movementSpeed;\n            float elapsed = 0f;\n            Vector3 startPos = transform.position;\n            \n            while (elapsed < duration && _isActive)\n            {\n                elapsed += Time.deltaTime;\n                float t = elapsed / duration;\n                t = Mathf.SmoothStep(0f, 1f, t);\n                \n                transform.position = Vector3.Lerp(startPos, targetPosition, t);\n                yield return null;\n            }\n            \n            yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 0.5f));\n        }\n    }\n    \n    IEnumerator SpookySoundCoroutine()\n    {\n        while (_isActive)\n        {\n            if (_spookySounds != null && _spookySounds.Length > 0)\n            {\n                AudioClip randomClip = _spookySounds[UnityEngine.Random.Range(0, _spookySounds.Length)];\n                if (randomClip != null)\n                {\n                    _audioSource.clip = randomClip;\n                    _audioSource.Play();\n                }\n            }\n            \n            yield return new WaitForSeconds(_soundInterval + UnityEngine.Random.Range(-1f, 1f));\n        }\n    }\n    \n    void OnDestroy()\n    {\n        if (_movementCoroutine != null)\n        {\n            StopCoroutine(_movementCoroutine);\n        }\n        if (_soundCoroutine != null)\n        {\n            StopCoroutine(_soundCoroutine);\n        }\n        if (_rigidbodyCheckCoroutine != null)\n        {\n            StopCoroutine(_rigidbodyCheckCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PartyInviteSystem\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxPartySize\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"inviteTimeout\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    },\n    {\n      \"name\": \"currentPartyMembers\",\n      \"type\": \"List<GameObject>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"pendingInvites\",\n      \"type\": \"Dictionary<GameObject, float>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"partyLeader\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"inviteUI\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"partyListUI\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"send_party_invite\",\n      \"trigger\": \"when player sends invite to another player\",\n      \"actions\": [\n        {\n          \"action\": \"check if target player is already in a party\"\n        },\n        {\n          \"action\": \"check if current party has available slots\"\n        },\n        {\n          \"action\": \"add invite to pending invites with timestamp\"\n        },\n        {\n          \"action\": \"display invite notification to target player\"\n        },\n        {\n          \"action\": \"show invite sent confirmation to sender\"\n        }\n      ]\n    },\n    {\n      \"name\": \"accept_party_invite\",\n      \"trigger\": \"when player accepts a party invite\",\n      \"actions\": [\n        {\n          \"action\": \"remove invite from pending invites\"\n        },\n        {\n          \"action\": \"add accepting player to party members list\"\n        },\n        {\n          \"action\": \"notify all party members of new member\"\n        },\n        {\n          \"action\": \"update party UI for all members\"\n        },\n        {\n          \"action\": \"hide invite notification\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decline_party_invite\",\n      \"trigger\": \"when player declines a party invite\",\n      \"actions\": [\n        {\n          \"action\": \"remove invite from pending invites\"\n        },\n        {\n          \"action\": \"notify sender that invite was declined\"\n        },\n        {\n          \"action\": \"hide invite notification\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_invite_timeouts\",\n      \"trigger\": \"every second while system is active\",\n      \"actions\": [\n        {\n          \"action\": \"check all pending invites for expired timestamps\"\n        },\n        {\n          \"action\": \"remove expired invites from pending list\"\n        },\n        {\n          \"action\": \"notify players when their sent invites expire\"\n        }\n      ]\n    },\n    {\n      \"name\": \"leave_party\",\n      \"trigger\": \"when player chooses to leave party\",\n      \"actions\": [\n        {\n          \"action\": \"remove player from party members list\"\n        },\n        {\n          \"action\": \"notify remaining party members of departure\"\n        },\n        {\n          \"action\": \"transfer party leadership if leaving player was leader\"\n        },\n        {\n          \"action\": \"update party UI for all remaining members\"\n        }\n      ]\n    },\n    {\n      \"name\": \"kick_party_member\",\n      \"trigger\": \"when party leader kicks a member\",\n      \"actions\": [\n        {\n          \"action\": \"check if requesting player is party leader\"\n        },\n        {\n          \"action\": \"remove target player from party members list\"\n        },\n        {\n          \"action\": \"notify kicked player they were removed\"\n        },\n        {\n          \"action\": \"notify remaining party members of removal\"\n        },\n        {\n          \"action\": \"update party UI for all members\"\n        }\n      ]\n    },\n    {\n      \"name\": \"disband_party\",\n      \"trigger\": \"when party leader disbands the party\",\n      \"actions\": [\n        {\n          \"action\": \"clear all party members from list\"\n        },\n        {\n          \"action\": \"notify all members that party was disbanded\"\n        },\n        {\n          \"action\": \"reset party leader to null\"\n        },\n        {\n          \"action\": \"hide party UI for all former members\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class PartyInviteSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class PartyMember\n    {\n        public string playerId;\n        public string playerName;\n        public bool isLeader;\n        public bool isOnline;\n        public DateTime joinTime;\n\n        public PartyMember(string id, string name, bool leader = false)\n        {\n            playerId = id;\n            playerName = name;\n            isLeader = leader;\n            isOnline = true;\n            joinTime = DateTime.Now;\n        }\n    }\n\n    [System.Serializable]\n    public class PartyInvite\n    {\n        public string inviteId;\n        public string fromPlayerId;\n        public string fromPlayerName;\n        public string toPlayerId;\n        public string toPlayerName;\n        public DateTime sentTime;\n        public float expireTime;\n\n        public PartyInvite(string from, string fromName, string to, string toName, float expire)\n        {\n            inviteId = Guid.NewGuid().ToString();\n            fromPlayerId = from;\n            fromPlayerName = fromName;\n            toPlayerId = to;\n            toPlayerName = toName;\n            sentTime = DateTime.Now;\n            expireTime = expire;\n        }\n\n        public bool IsExpired => (DateTime.Now - sentTime).TotalSeconds > expireTime;\n    }\n\n    [System.Serializable]\n    public class PartyInviteEvent : UnityEvent<PartyInvite> { }\n\n    [System.Serializable]\n    public class PartyMemberEvent : UnityEvent<PartyMember> { }\n\n    [System.Serializable]\n    public class PartyEvent : UnityEvent<List<PartyMember>> { }\n\n    [Header(\"Party Settings\")]\n    [SerializeField] private int _maxPartySize = 4;\n    [SerializeField] private float _inviteExpireTime = 30f;\n    [SerializeField] private bool _allowPublicJoin = false;\n    [SerializeField] private string _currentPlayerId = \"Player1\";\n    [SerializeField] private string _currentPlayerName = \"LocalPlayer\";\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _invitePanel;\n    [SerializeField] private Text _inviteText;\n    [SerializeField] private Button _acceptButton;\n    [SerializeField] private Button _declineButton;\n    [SerializeField] private GameObject _partyPanel;\n    [SerializeField] private Transform _memberListParent;\n    [SerializeField] private GameObject _memberPrefab;\n    [SerializeField] private Button _leavePartyButton;\n    [SerializeField] private InputField _invitePlayerInput;\n    [SerializeField] private Button _sendInviteButton;\n\n    [Header(\"Events\")]\n    public PartyInviteEvent OnInviteReceived;\n    public PartyInviteEvent OnInviteSent;\n    public PartyMemberEvent OnMemberJoined;\n    public PartyMemberEvent OnMemberLeft;\n    public PartyEvent OnPartyUpdated;\n    public UnityEvent OnPartyDisbanded;\n\n    private List<PartyMember> _currentParty = new List<PartyMember>();\n    private List<PartyInvite> _pendingInvites = new List<PartyInvite>();\n    private List<PartyInvite> _sentInvites = new List<PartyInvite>();\n    private PartyInvite _currentInviteDisplay;\n    private Dictionary<string, GameObject> _memberUIElements = new Dictionary<string, GameObject>();\n\n    public bool IsInParty => _currentParty.Count > 0;\n    public bool IsPartyLeader => IsInParty && _currentParty.Find(m => m.playerId == _currentPlayerId)?.isLeader == true;\n    public int PartySize => _currentParty.Count;\n    public bool IsPartyFull => PartySize >= _maxPartySize;\n\n    private void Start()\n    {\n        InitializeUI();\n        StartCoroutine(CleanupExpiredInvites());\n    }\n\n    private void InitializeUI()\n    {\n        if (_invitePanel != null)\n            _invitePanel.SetActive(false);\n\n        if (_partyPanel != null)\n            _partyPanel.SetActive(false);\n\n        if (_acceptButton != null)\n            _acceptButton.onClick.AddListener(AcceptCurrentInvite);\n\n        if (_declineButton != null)\n            _declineButton.onClick.AddListener(DeclineCurrentInvite);\n\n        if (_leavePartyButton != null)\n            _leavePartyButton.onClick.AddListener(LeaveParty);\n\n        if (_sendInviteButton != null)\n            _sendInviteButton.onClick.AddListener(SendInviteFromInput);\n\n        UpdatePartyUI();\n    }\n\n    public void SendInvite(string targetPlayerId, string targetPlayerName)\n    {\n        if (string.IsNullOrEmpty(targetPlayerId) || string.IsNullOrEmpty(targetPlayerName))\n        {\n            Debug.LogWarning(\"Cannot send invite: Invalid target player information\");\n            return;\n        }\n\n        if (targetPlayerId == _currentPlayerId)\n        {\n            Debug.LogWarning(\"Cannot invite yourself to party\");\n            return;\n        }\n\n        if (IsPartyFull)\n        {\n            Debug.LogWarning(\"Cannot send invite: Party is full\");\n            return;\n        }\n\n        if (IsInParty && !IsPartyLeader)\n        {\n            Debug.LogWarning(\"Cannot send invite: Only party leader can invite members\");\n            return;\n        }\n\n        if (_currentParty.Exists(m => m.playerId == targetPlayerId))\n        {\n            Debug.LogWarning(\"Player is already in the party\");\n            return;\n        }\n\n        if (_sentInvites.Exists(i => i.toPlayerId == targetPlayerId && !i.IsExpired))\n        {\n            Debug.LogWarning(\"Invite already sent to this player\");\n            return;\n        }\n\n        PartyInvite invite = new PartyInvite(_currentPlayerId, _currentPlayerName, targetPlayerId, targetPlayerName, _inviteExpireTime);\n        _sentInvites.Add(invite);\n\n        OnInviteSent?.Invoke(invite);\n        Debug.Log($\"Party invite sent to {targetPlayerName}\");\n\n        // Simulate receiving invite on target (for demo purposes)\n        if (targetPlayerId == \"DemoPlayer\")\n        {\n            SimulateReceiveInvite(invite);\n        }\n    }\n\n    public void ReceiveInvite(PartyInvite invite)\n    {\n        if (invite == null || invite.IsExpired)\n        {\n            Debug.LogWarning(\"Received invalid or expired invite\");\n            return;\n        }\n\n        if (invite.toPlayerId != _currentPlayerId)\n        {\n            Debug.LogWarning(\"Received invite not intended for this player\");\n            return;\n        }\n\n        if (IsPartyFull)\n        {\n            Debug.LogWarning(\"Cannot accept invite: Already in a full party\");\n            return;\n        }\n\n        _pendingInvites.Add(invite);\n        OnInviteReceived?.Invoke(invite);\n        ShowInviteUI(invite);\n    }\n\n    public void AcceptInvite(string inviteId)\n    {\n        PartyInvite invite = _pendingInvites.Find(i => i.inviteId == inviteId);\n        if (invite == null)\n        {\n            Debug.LogWarning(\"Invite not found\");\n            return;\n        }\n\n        if (invite.IsExpired)\n        {\n            Debug.LogWarning(\"Cannot accept expired invite\");\n            _pendingInvites.Remove(invite);\n            return;\n        }\n\n        // Leave current party if in one\n        if (IsInParty)\n        {\n            LeaveParty();\n        }\n\n        // Join the party\n        JoinParty(invite.fromPlayerId, invite.fromPlayerName);\n        _pendingInvites.Remove(invite);\n        HideInviteUI();\n\n        Debug.Log($\"Accepted party invite from {invite.fromPlayerName}\");\n    }\n\n    public void DeclineInvite(string inviteId)\n    {\n        PartyInvite invite = _pendingInvites.Find(i => i.inviteId == inviteId);\n        if (invite != null)\n        {\n            _pendingInvites.Remove(invite);\n            Debug.Log($\"Declined party invite from {invite.fromPlayerName}\");\n        }\n        HideInviteUI();\n    }\n\n    public void CreateParty()\n    {\n        if (IsInParty)\n        {\n            Debug.LogWarning(\"Already in a party\");\n            return;\n        }\n\n        _currentParty.Clear();\n        PartyMember leader = new PartyMember(_currentPlayerId, _currentPlayerName, true);\n        _currentParty.Add(leader);\n\n        OnMemberJoined?.Invoke(leader);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log(\"Party created\");\n    }\n\n    public void JoinParty(string leaderId, string leaderName)\n    {\n        if (IsInParty)\n        {\n            LeaveParty();\n        }\n\n        _currentParty.Clear();\n        \n        // Add leader\n        PartyMember leader = new PartyMember(leaderId, leaderName, true);\n        _currentParty.Add(leader);\n\n        // Add self\n        PartyMember self = new PartyMember(_currentPlayerId, _currentPlayerName, false);\n        _currentParty.Add(self);\n\n        OnMemberJoined?.Invoke(self);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log($\"Joined party led by {leaderName}\");\n    }\n\n    public void LeaveParty()\n    {\n        if (!IsInParty)\n        {\n            Debug.LogWarning(\"Not in a party\");\n            return;\n        }\n\n        PartyMember leavingMember = _currentParty.Find(m => m.playerId == _currentPlayerId);\n        bool wasLeader = leavingMember?.isLeader == true;\n\n        _currentParty.RemoveAll(m => m.playerId == _currentPlayerId);\n\n        if (wasLeader && _currentParty.Count > 0)\n        {\n            // Transfer leadership to next member\n            _currentParty[0].isLeader = true;\n            Debug.Log($\"Leadership transferred to {_currentParty[0].playerName}\");\n        }\n\n        if (leavingMember != null)\n        {\n            OnMemberLeft?.Invoke(leavingMember);\n        }\n\n        if (_currentParty.Count == 0)\n        {\n            OnPartyDisbanded?.Invoke();\n            Debug.Log(\"Party disbanded\");\n        }\n        else\n        {\n            OnPartyUpdated?.Invoke(_currentParty);\n        }\n\n        UpdatePartyUI();\n        Debug.Log(\"Left party\");\n    }\n\n    public void KickMember(string playerId)\n    {\n        if (!IsPartyLeader)\n        {\n            Debug.LogWarning(\"Only party leader can kick members\");\n            return;\n        }\n\n        if (playerId == _currentPlayerId)\n        {\n            Debug.LogWarning(\"Cannot kick yourself\");\n            return;\n        }\n\n        PartyMember memberToKick = _currentParty.Find(m => m.playerId == playerId);\n        if (memberToKick == null)\n        {\n            Debug.LogWarning(\"Member not found in party\");\n            return;\n        }\n\n        _currentParty.Remove(memberToKick);\n        OnMemberLeft?.Invoke(memberToKick);\n        OnPartyUpdated?.Invoke(_currentParty);\n        UpdatePartyUI();\n\n        Debug.Log($\"Kicked {memberToKick.playerName} from party\");\n    }\n\n    private void SendInviteFromInput()\n    {\n        if (_invitePlayerInput != null && !string.IsNullOrEmpty(_invitePlayerInput.text))\n        {\n            string targetName = _invitePlayerInput.text.Trim();\n            string targetId = \"Player_\" + targetName; // Simple ID generation\n            SendInvite(targetId, targetName);\n            _invitePlayerInput.text = \"\";\n        }\n    }\n\n    private void AcceptCurrentInvite()\n    {\n        if (_currentInviteDisplay != null)\n        {\n            AcceptInvite(_currentInviteDisplay.inviteId);\n        }\n    }\n\n    private void DeclineCurrentInvite()\n    {\n        if (_currentInviteDisplay != null)\n        {\n            DeclineInvite(_currentInviteDisplay.inviteId);\n        }\n    }\n\n    private void ShowInviteUI(PartyInvite invite)\n    {\n        _currentInviteDisplay = invite;\n        \n        if (_invitePanel != null)\n        {\n            _invitePanel.SetActive(true);\n        }\n\n        if (_inviteText != null)\n        {\n            _inviteText.text = $\"{invite.fromPlayerName} invited you to join their party\";\n        }\n    }\n\n    private void HideInviteUI()\n    {\n        _currentInviteDisplay = null;\n        \n        if (_invitePanel != null)\n        {\n            _invitePanel.SetActive(false);\n        }\n    }\n\n    private void UpdatePartyUI()\n    {\n        if (_partyPanel != null)\n        {\n            _partyPanel.SetActive(IsInParty);\n        }\n\n        if (_leavePartyButton != null)\n        {\n            _leavePartyButton.gameObject.SetActive(IsInParty);\n        }\n\n        UpdateMemberList();\n    }\n\n    private void UpdateMemberList()\n    {\n        if (_memberListParent == null || _memberPrefab == null)\n            return;\n\n        // Clear existing UI elements\n        foreach (var kvp in _memberUIElements)\n        {\n            if (kvp.Value != null)\n                DestroyImmediate(kvp.Value);\n        }\n        _memberUIElements.Clear();\n\n        // Create UI elements for current party members\n        foreach (PartyMember member in _currentParty)\n        {\n            GameObject memberUI = Instantiate(_memberPrefab, _memberListParent);\n            _memberUIElements[member.playerId] = memberUI;\n\n            Text memberText = memberUI.GetComponentInChildren<Text>();\n            if (memberText != null)\n            {\n                string displayText = member.playerName;\n                if (member.isLeader)\n                    displayText += \" (Leader)\";\n                if (member.playerId == _currentPlayerId)\n                    displayText += \" (You)\";\n                \n                memberText.text = displayText;\n            }\n\n            Button kickButton = memberUI.GetComponentInChildren<Button>();\n            if (kickButton != null)\n            {\n                bool canKick = IsPartyLeader && member.playerId != _currentPlayerId;\n                kickButton.gameObject.SetActive(canKick);\n                \n                if (canKick)\n                {\n                    string memberIdToKick = member.playerId;\n                    kickButton.onClick.RemoveAllListeners();\n                    kickButton.onClick.AddListener(() => KickMember(memberIdToKick));\n                }\n            }\n        }\n    }\n\n    private System.Collections.IEnumerator CleanupExpiredInvites()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(5f);\n\n            _pendingInvites.RemoveAll(i => i.IsExpired);\n            _sentInvites.RemoveAll(i => i.IsExpired);"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Elevator\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentFloor\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"targetFloor\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"floorHeight\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"maxFloor\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"minFloor\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"isMoving\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"doorOpenTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"doorsOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"select_floor\",\n      \"trigger\": \"when floor button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set target floor to selected floor number\"\n        },\n        {\n          \"action\": \"close doors if they are open\"\n        },\n        {\n          \"action\": \"play button press sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"move_to_target_floor\",\n      \"trigger\": \"when target floor is different from current floor and doors are closed\",\n      \"actions\": [\n        {\n          \"action\": \"set moving state to true\"\n        },\n        {\n          \"action\": \"play elevator movement sound\"\n        },\n        {\n          \"action\": \"move elevator vertically toward target floor position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"arrive_at_floor\",\n      \"trigger\": \"when elevator reaches target floor position\",\n      \"actions\": [\n        {\n          \"action\": \"set moving state to false\"\n        },\n        {\n          \"action\": \"update current floor to target floor\"\n        },\n        {\n          \"action\": \"stop movement sound\"\n        },\n        {\n          \"action\": \"play arrival chime\"\n        },\n        {\n          \"action\": \"open doors\"\n        }\n      ]\n    },\n    {\n      \"name\": \"close_doors_automatically\",\n      \"trigger\": \"when doors have been open for the specified time\",\n      \"actions\": [\n        {\n          \"action\": \"close doors\"\n        },\n        {\n          \"action\": \"play door closing sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_invalid_selection\",\n      \"trigger\": \"when selected floor is outside valid range\",\n      \"actions\": [\n        {\n          \"action\": \"play error sound\"\n        },\n        {\n          \"action\": \"ignore floor selection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emergency_stop\",\n      \"trigger\": \"when emergency button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement immediately\"\n        },\n        {\n          \"action\": \"set moving state to false\"\n        },\n        {\n          \"action\": \"play emergency alarm\"\n        },\n        {\n          \"action\": \"open doors\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Elevator : MonoBehaviour\n{\n    [System.Serializable]\n    public class Floor\n    {\n        public string floorName;\n        public Transform floorPosition;\n        public Button floorButton;\n        public bool isAccessible = true;\n    }\n\n    [Header(\"Elevator Settings\")]\n    [SerializeField] private Transform _elevatorCabin;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _doorOpenTime = 3f;\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n\n    [Header(\"Floors\")]\n    [SerializeField] private List<Floor> _floors = new List<Floor>();\n    [SerializeField] private int _currentFloorIndex = 0;\n\n    [Header(\"Doors\")]\n    [SerializeField] private Transform _leftDoor;\n    [SerializeField] private Transform _rightDoor;\n    [SerializeField] private Vector3 _doorOpenOffset = new Vector3(1.5f, 0, 0);\n    [SerializeField] private float _doorSpeed = 1f;\n\n    [Header(\"UI\")]\n    [SerializeField] private Text _floorDisplay;\n    [SerializeField] private Text _statusDisplay;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _movingSound;\n    [SerializeField] private AudioClip _arrivalSound;\n    [SerializeField] private AudioClip _doorSound;\n\n    [Header(\"Lights\")]\n    [SerializeField] private Light _elevatorLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _movingLightColor = Color.yellow;\n\n    private bool _isMoving = false;\n    private bool _doorsOpen = false;\n    private Vector3 _leftDoorClosedPos;\n    private Vector3 _rightDoorClosedPos;\n    private Queue<int> _floorQueue = new Queue<int>();\n    private Coroutine _currentMovement;\n\n    private void Start()\n    {\n        InitializeElevator();\n        SetupFloorButtons();\n        UpdateDisplay();\n        StartCoroutine(OpenDoorsRoutine());\n    }\n\n    private void InitializeElevator()\n    {\n        if (_elevatorCabin == null)\n            _elevatorCabin = transform;\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_leftDoor != null)\n            _leftDoorClosedPos = _leftDoor.localPosition;\n\n        if (_rightDoor != null)\n            _rightDoorClosedPos = _rightDoor.localPosition;\n\n        if (_floors.Count > 0 && _currentFloorIndex < _floors.Count)\n        {\n            _elevatorCabin.position = _floors[_currentFloorIndex].floorPosition.position;\n        }\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _normalLightColor;\n    }\n\n    private void SetupFloorButtons()\n    {\n        for (int i = 0; i < _floors.Count; i++)\n        {\n            int floorIndex = i;\n            if (_floors[i].floorButton != null)\n            {\n                _floors[i].floorButton.onClick.AddListener(() => RequestFloor(floorIndex));\n                UpdateButtonState(i);\n            }\n        }\n    }\n\n    public void RequestFloor(int floorIndex)\n    {\n        if (floorIndex < 0 || floorIndex >= _floors.Count)\n            return;\n\n        if (!_floors[floorIndex].isAccessible)\n        {\n            UpdateStatus(\"Floor not accessible\");\n            return;\n        }\n\n        if (floorIndex == _currentFloorIndex)\n        {\n            if (!_doorsOpen)\n                StartCoroutine(OpenDoorsRoutine());\n            return;\n        }\n\n        if (!_floorQueue.Contains(floorIndex))\n        {\n            _floorQueue.Enqueue(floorIndex);\n            UpdateButtonState(floorIndex);\n        }\n\n        if (!_isMoving)\n            StartCoroutine(ProcessFloorQueue());\n    }\n\n    private IEnumerator ProcessFloorQueue()\n    {\n        while (_floorQueue.Count > 0)\n        {\n            int targetFloor = _floorQueue.Dequeue();\n            yield return StartCoroutine(MoveToFloor(targetFloor));\n            UpdateButtonState(targetFloor);\n        }\n    }\n\n    private IEnumerator MoveToFloor(int targetFloorIndex)\n    {\n        if (targetFloorIndex == _currentFloorIndex)\n            yield break;\n\n        _isMoving = true;\n        UpdateStatus(\"Moving...\");\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _movingLightColor;\n\n        yield return StartCoroutine(CloseDoorsRoutine());\n\n        Vector3 startPos = _elevatorCabin.position;\n        Vector3 targetPos = _floors[targetFloorIndex].floorPosition.position;\n        float distance = Vector3.Distance(startPos, targetPos);\n        float duration = distance / _moveSpeed;\n\n        PlaySound(_movingSound, true);\n\n        float elapsed = 0f;\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = _movementCurve.Evaluate(elapsed / duration);\n            _elevatorCabin.position = Vector3.Lerp(startPos, targetPos, progress);\n            yield return null;\n        }\n\n        _elevatorCabin.position = targetPos;\n        _currentFloorIndex = targetFloorIndex;\n\n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n\n        PlaySound(_arrivalSound);\n\n        if (_elevatorLight != null)\n            _elevatorLight.color = _normalLightColor;\n\n        _isMoving = false;\n        UpdateDisplay();\n        UpdateStatus(\"Arrived\");\n\n        yield return StartCoroutine(OpenDoorsRoutine());\n    }\n\n    private IEnumerator OpenDoorsRoutine()\n    {\n        if (_doorsOpen)\n            yield break;\n\n        PlaySound(_doorSound);\n        UpdateStatus(\"Opening doors...\");\n\n        Vector3 leftTarget = _leftDoorClosedPos - _doorOpenOffset;\n        Vector3 rightTarget = _rightDoorClosedPos + _doorOpenOffset;\n\n        float elapsed = 0f;\n        float duration = 1f / _doorSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n\n            if (_leftDoor != null)\n                _leftDoor.localPosition = Vector3.Lerp(_leftDoorClosedPos, leftTarget, progress);\n\n            if (_rightDoor != null)\n                _rightDoor.localPosition = Vector3.Lerp(_rightDoorClosedPos, rightTarget, progress);\n\n            yield return null;\n        }\n\n        _doorsOpen = true;\n        UpdateStatus(\"Doors open\");\n\n        yield return new WaitForSeconds(_doorOpenTime);\n\n        if (!_isMoving && _floorQueue.Count == 0)\n            yield return StartCoroutine(CloseDoorsRoutine());\n    }\n\n    private IEnumerator CloseDoorsRoutine()\n    {\n        if (!_doorsOpen)\n            yield break;\n\n        PlaySound(_doorSound);\n        UpdateStatus(\"Closing doors...\");\n\n        Vector3 leftCurrent = _leftDoor != null ? _leftDoor.localPosition : _leftDoorClosedPos;\n        Vector3 rightCurrent = _rightDoor != null ? _rightDoor.localPosition : _rightDoorClosedPos;\n\n        float elapsed = 0f;\n        float duration = 1f / _doorSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n\n            if (_leftDoor != null)\n                _leftDoor.localPosition = Vector3.Lerp(leftCurrent, _leftDoorClosedPos, progress);\n\n            if (_rightDoor != null)\n                _rightDoor.localPosition = Vector3.Lerp(rightCurrent, _rightDoorClosedPos, progress);\n\n            yield return null;\n        }\n\n        _doorsOpen = false;\n        UpdateStatus(\"Doors closed\");\n    }\n\n    private void UpdateDisplay()\n    {\n        if (_floorDisplay != null && _currentFloorIndex < _floors.Count)\n        {\n            _floorDisplay.text = _floors[_currentFloorIndex].floorName;\n        }\n    }\n\n    private void UpdateStatus(string status)\n    {\n        if (_statusDisplay != null)\n            _statusDisplay.text = status;\n    }\n\n    private void UpdateButtonState(int floorIndex)\n    {\n        if (floorIndex < 0 || floorIndex >= _floors.Count)\n            return;\n\n        Button button = _floors[floorIndex].floorButton;\n        if (button != null)\n        {\n            bool isQueued = _floorQueue.Contains(floorIndex);\n            bool isCurrent = floorIndex == _currentFloorIndex;\n            \n            ColorBlock colors = button.colors;\n            colors.normalColor = isCurrent ? Color.green : (isQueued ? Color.yellow : Color.white);\n            button.colors = colors;\n            \n            button.interactable = _floors[floorIndex].isAccessible && !isCurrent;\n        }\n    }\n\n    private void PlaySound(AudioClip clip, bool loop = false)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.loop = loop;\n            _audioSource.Play();\n        }\n    }\n\n    public void SetFloorAccessibility(int floorIndex, bool accessible)\n    {\n        if (floorIndex >= 0 && floorIndex < _floors.Count)\n        {\n            _floors[floorIndex].isAccessible = accessible;\n            UpdateButtonState(floorIndex);\n        }\n    }\n\n    public int GetCurrentFloor()\n    {\n        return _currentFloorIndex;\n    }\n\n    public bool IsMoving()\n    {\n        return _isMoving;\n    }\n\n    public bool AreDoorsOpen()\n    {\n        return _doorsOpen;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _doorsOpen)\n        {\n            UpdateStatus(\"Welcome aboard!\");\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _doorsOpen)\n        {\n            UpdateStatus(\"Doors open\");\n        }\n    }\n\n    private void OnValidate()\n    {\n        if (_floors != null)\n        {\n            for (int i = 0; i < _floors.Count; i++)\n            {\n                if (string.IsNullOrEmpty(_floors[i].floorName))\n                    _floors[i].floorName = \"Floor \" + (i + 1);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HostMigrationHandler\",\n  \"components\": [\n    \"NetworkBehaviour\",\n    \"NetworkManager\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"migrationTimeout\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"isHostMigrationInProgress\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"candidateHosts\",\n      \"type\": \"List<NetworkPlayer>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"migrationStartTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"hostSelectionCriteria\",\n      \"type\": \"string\",\n      \"default\": \"lowest_ping\"\n    },\n    {\n      \"name\": \"backupGameState\",\n      \"type\": \"GameStateData\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_host_disconnection\",\n      \"trigger\": \"when current host player disconnects unexpectedly\",\n      \"actions\": [\n        {\n          \"action\": \"mark host migration as in progress\"\n        },\n        {\n          \"action\": \"record the time migration started\"\n        },\n        {\n          \"action\": \"pause all game simulation\"\n        },\n        {\n          \"action\": \"notify all remaining clients about host migration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_new_host\",\n      \"trigger\": \"when host migration begins\",\n      \"actions\": [\n        {\n          \"action\": \"gather list of eligible host candidates from remaining players\"\n        },\n        {\n          \"action\": \"evaluate each candidate based on connection quality and system specs\"\n        },\n        {\n          \"action\": \"select the most suitable player as new host\"\n        },\n        {\n          \"action\": \"send host assignment message to selected player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"backup_game_state\",\n      \"trigger\": \"when host migration is detected\",\n      \"actions\": [\n        {\n          \"action\": \"capture current game state including player positions and scores\"\n        },\n        {\n          \"action\": \"store critical gameplay data temporarily\"\n        },\n        {\n          \"action\": \"preserve match timer and round information\"\n        },\n        {\n          \"action\": \"save pending player actions and inputs\"\n        }\n      ]\n    },\n    {\n      \"name\": \"establish_new_host\",\n      \"trigger\": \"when selected player accepts host role\",\n      \"actions\": [\n        {\n          \"action\": \"transfer network authority to new host\"\n        },\n        {\n          \"action\": \"restore backed up game state on new host\"\n        },\n        {\n          \"action\": \"reconnect all clients to new host\"\n        },\n        {\n          \"action\": \"synchronize game state across all players\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_migration_timeout\",\n      \"trigger\": \"when host migration takes longer than timeout duration\",\n      \"actions\": [\n        {\n          \"action\": \"abort current migration attempt\"\n        },\n        {\n          \"action\": \"try selecting alternative host candidate\"\n        },\n        {\n          \"action\": \"if no candidates available disconnect all players gracefully\"\n        },\n        {\n          \"action\": \"display migration failed message to players\"\n        }\n      ]\n    },\n    {\n      \"name\": \"resume_gameplay\",\n      \"trigger\": \"when new host is successfully established and synchronized\",\n      \"actions\": [\n        {\n          \"action\": \"mark host migration as completed\"\n        },\n        {\n          \"action\": \"resume game simulation and player input processing\"\n        },\n        {\n          \"action\": \"clear migration progress flags\"\n        },\n        {\n          \"action\": \"notify players that migration is complete\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_migration_failure\",\n      \"trigger\": \"when host migration cannot be completed successfully\",\n      \"actions\": [\n        {\n          \"action\": \"save player progress and match statistics\"\n        },\n        {\n          \"action\": \"gracefully disconnect all remaining players\"\n        },\n        {\n          \"action\": \"return players to main menu with appropriate error message\"\n        },\n        {\n          \"action\": \"log migration failure details for debugging\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Networking;\n\npublic class HostMigrationManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class HostMigrationEvent : UnityEvent<bool> { }\n    \n    [System.Serializable]\n    public class PlayerData\n    {\n        public string playerId;\n        public string playerName;\n        public Vector3 position;\n        public Quaternion rotation;\n        public float health;\n        public int score;\n        public bool isActive;\n        \n        public PlayerData(string id, string name, Vector3 pos, Quaternion rot, float hp, int sc)\n        {\n            playerId = id;\n            playerName = name;\n            position = pos;\n            rotation = rot;\n            health = hp;\n            score = sc;\n            isActive = true;\n        }\n    }\n    \n    [System.Serializable]\n    public class GameStateData\n    {\n        public float gameTime;\n        public int gamePhase;\n        public List<PlayerData> players;\n        public Dictionary<string, object> customData;\n        \n        public GameStateData()\n        {\n            players = new List<PlayerData>();\n            customData = new Dictionary<string, object>();\n        }\n    }\n    \n    [Header(\"Host Migration Settings\")]\n    [SerializeField] private float _migrationTimeout = 10f;\n    [SerializeField] private float _heartbeatInterval = 2f;\n    [SerializeField] private int _maxMigrationAttempts = 3;\n    [SerializeField] private bool _enableAutomaticMigration = true;\n    \n    [Header(\"Events\")]\n    public HostMigrationEvent OnHostMigrationStarted;\n    public HostMigrationEvent OnHostMigrationCompleted;\n    public UnityEvent OnHostDisconnected;\n    public UnityEvent OnBecameNewHost;\n    public UnityEvent OnMigrationFailed;\n    \n    private bool _isHost;\n    private bool _isMigrating;\n    private string _currentHostId;\n    private List<string> _connectedClients;\n    private GameStateData _gameState;\n    private Coroutine _heartbeatCoroutine;\n    private Coroutine _migrationCoroutine;\n    private float _lastHeartbeatTime;\n    private int _migrationAttempts;\n    private Dictionary<string, float> _clientPriorities;\n    \n    private void Start()\n    {\n        InitializeHostMigration();\n    }\n    \n    private void Update()\n    {\n        if (!_isMigrating)\n        {\n            CheckHostConnection();\n            UpdateGameState();\n        }\n    }\n    \n    private void InitializeHostMigration()\n    {\n        _connectedClients = new List<string>();\n        _gameState = new GameStateData();\n        _clientPriorities = new Dictionary<string, float>();\n        _lastHeartbeatTime = Time.time;\n        _migrationAttempts = 0;\n        \n        DetermineHostStatus();\n        \n        if (_isHost)\n        {\n            StartHostHeartbeat();\n        }\n    }\n    \n    private void DetermineHostStatus()\n    {\n        _isHost = Network.isServer || (Network.connections.Length == 0);\n        _currentHostId = _isHost ? Network.player.ToString() : \"\";\n        \n        if (_isHost)\n        {\n            Debug.Log(\"This client is the host\");\n        }\n    }\n    \n    private void StartHostHeartbeat()\n    {\n        if (_heartbeatCoroutine != null)\n        {\n            StopCoroutine(_heartbeatCoroutine);\n        }\n        _heartbeatCoroutine = StartCoroutine(HostHeartbeatCoroutine());\n    }\n    \n    private IEnumerator HostHeartbeatCoroutine()\n    {\n        while (_isHost && !_isMigrating)\n        {\n            SendHeartbeat();\n            yield return new WaitForSeconds(_heartbeatInterval);\n        }\n    }\n    \n    private void SendHeartbeat()\n    {\n        if (!_isHost) return;\n        \n        // Simulate sending heartbeat to all clients\n        foreach (string clientId in _connectedClients)\n        {\n            // In a real implementation, this would send network messages\n            Debug.Log($\"Sending heartbeat to client: {clientId}\");\n        }\n        \n        _lastHeartbeatTime = Time.time;\n    }\n    \n    private void CheckHostConnection()\n    {\n        if (_isHost) return;\n        \n        float timeSinceLastHeartbeat = Time.time - _lastHeartbeatTime;\n        \n        if (timeSinceLastHeartbeat > _migrationTimeout && !_isMigrating)\n        {\n            Debug.Log(\"Host connection lost, initiating migration\");\n            OnHostDisconnected?.Invoke();\n            \n            if (_enableAutomaticMigration)\n            {\n                StartHostMigration();\n            }\n        }\n    }\n    \n    public void StartHostMigration()\n    {\n        if (_isMigrating) return;\n        \n        _isMigrating = true;\n        _migrationAttempts++;\n        \n        Debug.Log($\"Starting host migration (attempt {_migrationAttempts})\");\n        OnHostMigrationStarted?.Invoke(true);\n        \n        if (_migrationCoroutine != null)\n        {\n            StopCoroutine(_migrationCoroutine);\n        }\n        _migrationCoroutine = StartCoroutine(HostMigrationCoroutine());\n    }\n    \n    private IEnumerator HostMigrationCoroutine()\n    {\n        yield return new WaitForSeconds(1f); // Brief pause for network stabilization\n        \n        // Collect game state from all clients\n        yield return StartCoroutine(CollectGameStateCoroutine());\n        \n        // Determine new host based on priority\n        string newHostId = DetermineNewHost();\n        \n        if (newHostId == Network.player.ToString())\n        {\n            // This client becomes the new host\n            yield return StartCoroutine(BecomeNewHostCoroutine());\n        }\n        else\n        {\n            // Wait for new host to be established\n            yield return StartCoroutine(WaitForNewHostCoroutine(newHostId));\n        }\n        \n        CompleteMigration();\n    }\n    \n    private IEnumerator CollectGameStateCoroutine()\n    {\n        Debug.Log(\"Collecting game state from all clients\");\n        \n        // Simulate collecting game state\n        _gameState.gameTime = Time.time;\n        _gameState.gamePhase = 1;\n        \n        // Collect player data\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        _gameState.players.Clear();\n        \n        foreach (GameObject player in players)\n        {\n            if (player != null)\n            {\n                PlayerData playerData = new PlayerData(\n                    player.name,\n                    player.name,\n                    player.transform.position,\n                    player.transform.rotation,\n                    100f, // Default health\n                    0     // Default score\n                );\n                _gameState.players.Add(playerData);\n            }\n        }\n        \n        yield return new WaitForSeconds(0.5f);\n    }\n    \n    private string DetermineNewHost()\n    {\n        string newHostId = \"\";\n        float highestPriority = -1f;\n        \n        // Calculate priorities for all connected clients\n        foreach (string clientId in _connectedClients)\n        {\n            float priority = CalculateClientPriority(clientId);\n            _clientPriorities[clientId] = priority;\n            \n            if (priority > highestPriority)\n            {\n                highestPriority = priority;\n                newHostId = clientId;\n            }\n        }\n        \n        // Include self in consideration\n        string selfId = Network.player.ToString();\n        float selfPriority = CalculateClientPriority(selfId);\n        \n        if (selfPriority > highestPriority)\n        {\n            newHostId = selfId;\n        }\n        \n        Debug.Log($\"New host determined: {newHostId} with priority: {highestPriority}\");\n        return newHostId;\n    }\n    \n    private float CalculateClientPriority(string clientId)\n    {\n        float priority = 0f;\n        \n        // Base priority on connection stability\n        priority += Random.Range(0.5f, 1f);\n        \n        // Bonus for lower ping (simulated)\n        priority += Random.Range(0f, 0.3f);\n        \n        // Bonus for being the original host\n        if (clientId == _currentHostId)\n        {\n            priority += 0.2f;\n        }\n        \n        return priority;\n    }\n    \n    private IEnumerator BecomeNewHostCoroutine()\n    {\n        Debug.Log(\"Becoming new host\");\n        \n        _isHost = true;\n        _currentHostId = Network.player.ToString();\n        \n        // Restore game state\n        yield return StartCoroutine(RestoreGameStateCoroutine());\n        \n        // Notify all clients of new host\n        NotifyClientsOfNewHost();\n        \n        // Start host responsibilities\n        StartHostHeartbeat();\n        \n        OnBecameNewHost?.Invoke();\n        yield return null;\n    }\n    \n    private IEnumerator WaitForNewHostCoroutine(string newHostId)\n    {\n        Debug.Log($\"Waiting for new host: {newHostId}\");\n        \n        float waitTime = 0f;\n        bool hostEstablished = false;\n        \n        while (waitTime < _migrationTimeout && !hostEstablished)\n        {\n            // Check if new host is responding\n            hostEstablished = CheckNewHostResponse(newHostId);\n            \n            if (!hostEstablished)\n            {\n                yield return new WaitForSeconds(0.5f);\n                waitTime += 0.5f;\n            }\n        }\n        \n        if (!hostEstablished)\n        {\n            Debug.Log(\"New host failed to establish, retrying migration\");\n            if (_migrationAttempts < _maxMigrationAttempts)\n            {\n                yield return new WaitForSeconds(1f);\n                StartHostMigration();\n            }\n            else\n            {\n                OnMigrationFailed?.Invoke();\n            }\n        }\n        else\n        {\n            _currentHostId = newHostId;\n            _lastHeartbeatTime = Time.time;\n        }\n    }\n    \n    private bool CheckNewHostResponse(string hostId)\n    {\n        // Simulate checking for new host response\n        return Random.Range(0f, 1f) > 0.3f; // 70% chance of success\n    }\n    \n    private IEnumerator RestoreGameStateCoroutine()\n    {\n        Debug.Log(\"Restoring game state\");\n        \n        // Restore player positions and data\n        foreach (PlayerData playerData in _gameState.players)\n        {\n            GameObject player = GameObject.Find(playerData.playerId);\n            if (player != null)\n            {\n                player.transform.position = playerData.position;\n                player.transform.rotation = playerData.rotation;\n            }\n        }\n        \n        yield return new WaitForSeconds(0.2f);\n    }\n    \n    private void NotifyClientsOfNewHost()\n    {\n        Debug.Log(\"Notifying clients of new host\");\n        \n        // In a real implementation, this would send network messages\n        foreach (string clientId in _connectedClients)\n        {\n            Debug.Log($\"Notifying client {clientId} of new host\");\n        }\n    }\n    \n    private void CompleteMigration()\n    {\n        _isMigrating = false;\n        _migrationAttempts = 0;\n        \n        Debug.Log(\"Host migration completed successfully\");\n        OnHostMigrationCompleted?.Invoke(true);\n    }\n    \n    private void UpdateGameState()\n    {\n        if (!_isHost) return;\n        \n        _gameState.gameTime = Time.time;\n        \n        // Update player data\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        _gameState.players.Clear();\n        \n        foreach (GameObject player in players)\n        {\n            if (player != null)\n            {\n                PlayerData playerData = new PlayerData(\n                    player.name,\n                    player.name,\n                    player.transform.position,\n                    player.transform.rotation,\n                    100f,\n                    0\n                );\n                _gameState.players.Add(playerData);\n            }\n        }\n    }\n    \n    public void AddClient(string clientId)\n    {\n        if (!_connectedClients.Contains(clientId))\n        {\n            _connectedClients.Add(clientId);\n            Debug.Log($\"Client added: {clientId}\");\n        }\n    }\n    \n    public void RemoveClient(string clientId)\n    {\n        if (_connectedClients.Contains(clientId))\n        {\n            _connectedClients.Remove(clientId);\n            Debug.Log($\"Client removed: {clientId}\");\n            \n            if (clientId == _currentHostId && !_isMigrating)\n            {\n                OnHostDisconnected?.Invoke();\n                if (_enableAutomaticMigration)\n                {\n                    StartHostMigration();\n                }\n            }\n        }\n    }\n    \n    public void ForceHostMigration()\n    {\n        if (!_isMigrating)\n        {\n            StartHostMigration();\n        }\n    }\n    \n    public bool IsHost()\n    {\n        return _isHost;\n    }\n    \n    public bool IsMigrating()\n    {\n        return _isMigrating;\n    }\n    \n    public string GetCurrentHostId()\n    {\n        return _currentHostId;\n    }\n    \n    public GameStateData GetGameState()\n    {\n        return _gameState;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_heartbeatCoroutine != null)\n        {\n            StopCoroutine(_heartbeatCoroutine);\n        }\n        \n        if (_migrationCoroutine != null)\n        {\n            StopCoroutine(_migrationCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerReadyState\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isReady\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"readyDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"idleAnimationName\",\n      \"type\": \"string\",\n      \"default\": \"Idle\"\n    },\n    {\n      \"name\": \"readyAnimationName\",\n      \"type\": \"string\",\n      \"default\": \"Ready\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_ready_state\",\n      \"trigger\": \"when ready input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set ready status to true\"\n        },\n        {\n          \"action\": \"play ready animation\"\n        },\n        {\n          \"action\": \"start ready timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_ready_stance\",\n      \"trigger\": \"while in ready state\",\n      \"actions\": [\n        {\n          \"action\": \"prevent movement\"\n        },\n        {\n          \"action\": \"face forward direction\"\n        },\n        {\n          \"action\": \"maintain ready animation loop\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_ready_state\",\n      \"trigger\": \"when ready duration expires or input is released\",\n      \"actions\": [\n        {\n          \"action\": \"set ready status to false\"\n        },\n        {\n          \"action\": \"return to idle animation\"\n        },\n        {\n          \"action\": \"restore normal movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_ready_state\",\n      \"trigger\": \"when movement input is detected while ready\",\n      \"actions\": [\n        {\n          \"action\": \"immediately exit ready state\"\n        },\n        {\n          \"action\": \"transition to movement state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class PlayerReadyState : MonoBehaviour\n{\n    [Header(\"Ready State Settings\")]\n    [SerializeField] private bool _isReady = false;\n    [SerializeField] private float _readyCheckInterval = 0.1f;\n    [SerializeField] private bool _requireGrounded = true;\n    [SerializeField] private bool _requireMinHealth = false;\n    [SerializeField] private float _minHealthThreshold = 50f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _readyKey = KeyCode.R;\n    [SerializeField] private string _readyButton = \"Fire1\";\n    [SerializeField] private bool _useKeyInput = true;\n    [SerializeField] private bool _useButtonInput = false;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckRadius = 0.2f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Health Check\")]\n    [SerializeField] private float _currentHealth = 100f;\n    [SerializeField] private float _maxHealth = 100f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _readyIndicator;\n    [SerializeField] private Color _readyColor = Color.green;\n    [SerializeField] private Color _notReadyColor = Color.red;\n    [SerializeField] private Renderer _playerRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _readySound;\n    [SerializeField] private AudioClip _notReadySound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBecomeReady;\n    public UnityEvent OnBecomeNotReady;\n    public UnityEvent OnReadyStateChanged;\n    \n    private bool _wasReady = false;\n    private Rigidbody _rigidbody;\n    private CharacterController _characterController;\n    private Material _originalMaterial;\n    private Color _originalColor;\n    \n    public bool IsReady => _isReady;\n    public float CurrentHealth => _currentHealth;\n    public float HealthPercentage => _currentHealth / _maxHealth;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        InitializeVisuals();\n        StartCoroutine(ReadyStateCheckCoroutine());\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _characterController = GetComponent<CharacterController>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_groundCheckPoint == null)\n            _groundCheckPoint = transform;\n    }\n    \n    private void InitializeVisuals()\n    {\n        if (_playerRenderer != null)\n        {\n            _originalMaterial = _playerRenderer.material;\n            _originalColor = _originalMaterial.color;\n        }\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n    }\n    \n    private void HandleInput()\n    {\n        bool inputPressed = false;\n        \n        if (_useKeyInput && Input.GetKeyDown(_readyKey))\n            inputPressed = true;\n            \n        if (_useButtonInput && Input.GetButtonDown(_readyButton))\n            inputPressed = true;\n            \n        if (inputPressed)\n        {\n            ToggleReadyState();\n        }\n    }\n    \n    private IEnumerator ReadyStateCheckCoroutine()\n    {\n        while (true)\n        {\n            CheckReadyConditions();\n            yield return new WaitForSeconds(_readyCheckInterval);\n        }\n    }\n    \n    private void CheckReadyConditions()\n    {\n        bool canBeReady = true;\n        \n        if (_requireGrounded && !IsGrounded())\n            canBeReady = false;\n            \n        if (_requireMinHealth && _currentHealth < _minHealthThreshold)\n            canBeReady = false;\n            \n        bool newReadyState = _isReady && canBeReady;\n        \n        if (newReadyState != _wasReady)\n        {\n            _isReady = newReadyState;\n            OnReadyStateChange();\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        if (_groundCheckPoint == null) return true;\n        \n        return Physics.CheckSphere(_groundCheckPoint.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    public void ToggleReadyState()\n    {\n        SetReadyState(!_isReady);\n    }\n    \n    public void SetReadyState(bool ready)\n    {\n        bool canBeReady = true;\n        \n        if (ready)\n        {\n            if (_requireGrounded && !IsGrounded())\n                canBeReady = false;\n                \n            if (_requireMinHealth && _currentHealth < _minHealthThreshold)\n                canBeReady = false;\n        }\n        \n        bool newState = ready && canBeReady;\n        \n        if (newState != _isReady)\n        {\n            _isReady = newState;\n            OnReadyStateChange();\n        }\n    }\n    \n    private void OnReadyStateChange()\n    {\n        if (_isReady != _wasReady)\n        {\n            if (_isReady)\n            {\n                OnBecomeReady?.Invoke();\n                PlayReadySound();\n            }\n            else\n            {\n                OnBecomeNotReady?.Invoke();\n                PlayNotReadySound();\n            }\n            \n            OnReadyStateChanged?.Invoke();\n            UpdateVisualFeedback();\n            _wasReady = _isReady;\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_readyIndicator != null)\n        {\n            _readyIndicator.SetActive(_isReady);\n        }\n        \n        if (_playerRenderer != null)\n        {\n            Color targetColor = _isReady ? _readyColor : _notReadyColor;\n            _playerRenderer.material.color = Color.Lerp(_originalColor, targetColor, 0.5f);\n        }\n    }\n    \n    private void PlayReadySound()\n    {\n        if (_audioSource != null && _readySound != null)\n        {\n            _audioSource.PlayOneShot(_readySound);\n        }\n    }\n    \n    private void PlayNotReadySound()\n    {\n        if (_audioSource != null && _notReadySound != null)\n        {\n            _audioSource.PlayOneShot(_notReadySound);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        CheckReadyConditions();\n    }\n    \n    public void Heal(float healAmount)\n    {\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        CheckReadyConditions();\n    }\n    \n    public void SetHealth(float health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        CheckReadyConditions();\n    }\n    \n    public void ResetReadyState()\n    {\n        _isReady = false;\n        _wasReady = false;\n        UpdateVisualFeedback();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = IsGrounded() ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, _groundCheckRadius);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _minHealthThreshold = Mathf.Clamp(_minHealthThreshold, 0f, _maxHealth);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"IceFloor\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"frictionReduction\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"slideForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"reduce_friction_on_contact\",\n      \"trigger\": \"when object enters ice surface area\",\n      \"actions\": [\n        {\n          \"action\": \"reduce the friction of the contacting object\"\n        },\n        {\n          \"action\": \"apply sliding physics to the object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"restore_friction_on_exit\",\n      \"trigger\": \"when object leaves ice surface area\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal friction to the object\"\n        },\n        {\n          \"action\": \"remove sliding physics effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_slide_effect\",\n      \"trigger\": \"while object remains on ice surface\",\n      \"actions\": [\n        {\n          \"action\": \"maintain reduced friction state\"\n        },\n        {\n          \"action\": \"allow momentum to carry object forward with minimal resistance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class IceFloor : MonoBehaviour\n{\n    [Header(\"Ice Properties\")]\n    [SerializeField] private float _frictionReduction = 0.1f;\n    [SerializeField] private float _slidingForce = 5f;\n    [SerializeField] private bool _maintainMomentum = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _iceParticles;\n    [SerializeField] private AudioClip _slideSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Physics Materials\")]\n    [SerializeField] private PhysicMaterial _icyMaterial;\n    [SerializeField] private PhysicMaterial _originalMaterial;\n    \n    private Collider _floorCollider;\n    \n    private void Start()\n    {\n        _floorCollider = GetComponent<Collider>();\n        \n        if (_floorCollider == null)\n        {\n            Debug.LogError(\"IceFloor requires a Collider component!\");\n            return;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        SetupIcyPhysicsMaterial();\n    }\n    \n    private void SetupIcyPhysicsMaterial()\n    {\n        if (_icyMaterial == null)\n        {\n            _icyMaterial = new PhysicMaterial(\"IcyMaterial\");\n            _icyMaterial.dynamicFriction = _frictionReduction;\n            _icyMaterial.staticFriction = _frictionReduction;\n            _icyMaterial.bounciness = 0f;\n            _icyMaterial.frictionCombine = PhysicMaterialCombine.Minimum;\n            _icyMaterial.bounceCombine = PhysicMaterialCombine.Minimum;\n        }\n        \n        _floorCollider.material = _icyMaterial;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyIceEffect(other);\n            PlayIceEffects();\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _maintainMomentum)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && rb.velocity.magnitude > 0.1f)\n            {\n                Vector3 slideDirection = rb.velocity.normalized;\n                rb.AddForce(slideDirection * _slidingForce, ForceMode.Acceleration);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            RestoreNormalFriction(other);\n            StopIceEffects();\n        }\n    }\n    \n    private void ApplyIceEffect(Collider player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.drag = _frictionReduction;\n        }\n        \n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null)\n        {\n            if (_originalMaterial == null)\n                _originalMaterial = playerCollider.material;\n            \n            playerCollider.material = _icyMaterial;\n        }\n    }\n    \n    private void RestoreNormalFriction(Collider player)\n    {\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.drag = 0f;\n        }\n        \n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null && _originalMaterial != null)\n        {\n            playerCollider.material = _originalMaterial;\n        }\n    }\n    \n    private void PlayIceEffects()\n    {\n        if (_iceParticles != null && !_iceParticles.isPlaying)\n        {\n            _iceParticles.Play();\n        }\n        \n        if (_audioSource != null && _slideSound != null)\n        {\n            _audioSource.clip = _slideSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopIceEffects()\n    {\n        if (_iceParticles != null && _iceParticles.isPlaying)\n        {\n            _iceParticles.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _frictionReduction = Mathf.Clamp01(_frictionReduction);\n        _slidingForce = Mathf.Max(0f, _slidingForce);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FootstepSoundController\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"grassSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"stoneSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"woodSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"metalSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"waterSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"stepVolume\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    },\n    {\n      \"name\": \"stepPitchVariation\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"raycastDistance\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_surface_type\",\n      \"trigger\": \"when character takes a step\",\n      \"actions\": [\n        {\n          \"action\": \"cast ray downward from character position to detect ground surface\"\n        },\n        {\n          \"action\": \"identify surface material type from hit object tag or material\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_grass_footstep\",\n      \"trigger\": \"when surface type is grass and step occurs\",\n      \"actions\": [\n        {\n          \"action\": \"select random sound from grass sounds array\"\n        },\n        {\n          \"action\": \"apply slight pitch variation to selected sound\"\n        },\n        {\n          \"action\": \"play selected grass footstep sound at step volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_stone_footstep\",\n      \"trigger\": \"when surface type is stone and step occurs\",\n      \"actions\": [\n        {\n          \"action\": \"select random sound from stone sounds array\"\n        },\n        {\n          \"action\": \"apply slight pitch variation to selected sound\"\n        },\n        {\n          \"action\": \"play selected stone footstep sound at step volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_wood_footstep\",\n      \"trigger\": \"when surface type is wood and step occurs\",\n      \"actions\": [\n        {\n          \"action\": \"select random sound from wood sounds array\"\n        },\n        {\n          \"action\": \"apply slight pitch variation to selected sound\"\n        },\n        {\n          \"action\": \"play selected wood footstep sound at step volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_metal_footstep\",\n      \"trigger\": \"when surface type is metal and step occurs\",\n      \"actions\": [\n        {\n          \"action\": \"select random sound from metal sounds array\"\n        },\n        {\n          \"action\": \"apply slight pitch variation to selected sound\"\n        },\n        {\n          \"action\": \"play selected metal footstep sound at step volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_water_footstep\",\n      \"trigger\": \"when surface type is water and step occurs\",\n      \"actions\": [\n        {\n          \"action\": \"select random sound from water sounds array\"\n        },\n        {\n          \"action\": \"apply slight pitch variation to selected sound\"\n        },\n        {\n          \"action\": \"play selected water footstep sound at step volume\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FootstepSoundController : MonoBehaviour\n{\n    [System.Serializable]\n    public class SurfaceAudioData\n    {\n        public string surfaceTag;\n        public AudioClip[] footstepClips;\n        [Range(0f, 1f)]\n        public float volume = 1f;\n        [Range(0.5f, 2f)]\n        public float pitchVariation = 0.1f;\n    }\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private List<SurfaceAudioData> _surfaceAudioData = new List<SurfaceAudioData>();\n    \n    [Header(\"Footstep Detection\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _raycastDistance = 1.1f;\n    [SerializeField] private Transform _raycastOrigin;\n    \n    [Header(\"Timing\")]\n    [SerializeField] private float _stepInterval = 0.5f;\n    [SerializeField] private float _minimumVelocity = 0.1f;\n    \n    [Header(\"Default Audio\")]\n    [SerializeField] private AudioClip[] _defaultFootstepClips;\n    [SerializeField] private float _defaultVolume = 0.7f;\n\n    private Rigidbody _rigidbody;\n    private CharacterController _characterController;\n    private float _lastStepTime;\n    private string _currentSurfaceTag = \"\";\n    private Dictionary<string, SurfaceAudioData> _surfaceDataDict;\n\n    private void Awake()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        if (_raycastOrigin == null)\n            _raycastOrigin = transform;\n\n        _rigidbody = GetComponent<Rigidbody>();\n        _characterController = GetComponent<CharacterController>();\n\n        InitializeSurfaceDataDictionary();\n    }\n\n    private void Start()\n    {\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n\n    private void Update()\n    {\n        if (ShouldPlayFootstep())\n        {\n            DetectSurfaceAndPlayFootstep();\n        }\n    }\n\n    private void InitializeSurfaceDataDictionary()\n    {\n        _surfaceDataDict = new Dictionary<string, SurfaceAudioData>();\n        \n        foreach (var surfaceData in _surfaceAudioData)\n        {\n            if (!string.IsNullOrEmpty(surfaceData.surfaceTag))\n            {\n                _surfaceDataDict[surfaceData.surfaceTag] = surfaceData;\n            }\n        }\n    }\n\n    private bool ShouldPlayFootstep()\n    {\n        if (Time.time - _lastStepTime < _stepInterval)\n            return false;\n\n        bool isMoving = false;\n\n        if (_characterController != null)\n        {\n            isMoving = _characterController.velocity.magnitude > _minimumVelocity && _characterController.isGrounded;\n        }\n        else if (_rigidbody != null)\n        {\n            Vector3 horizontalVelocity = new Vector3(_rigidbody.velocity.x, 0, _rigidbody.velocity.z);\n            isMoving = horizontalVelocity.magnitude > _minimumVelocity && IsGrounded();\n        }\n        else\n        {\n            isMoving = transform.hasChanged && IsGrounded();\n            transform.hasChanged = false;\n        }\n\n        return isMoving;\n    }\n\n    private bool IsGrounded()\n    {\n        return Physics.Raycast(_raycastOrigin.position, Vector3.down, _raycastDistance, _groundLayerMask);\n    }\n\n    private void DetectSurfaceAndPlayFootstep()\n    {\n        RaycastHit hit;\n        if (Physics.Raycast(_raycastOrigin.position, Vector3.down, out hit, _raycastDistance, _groundLayerMask))\n        {\n            string surfaceTag = hit.collider.tag;\n            PlayFootstepSound(surfaceTag);\n            _currentSurfaceTag = surfaceTag;\n        }\n    }\n\n    private void PlayFootstepSound(string surfaceTag)\n    {\n        AudioClip[] clipsToUse = _defaultFootstepClips;\n        float volumeToUse = _defaultVolume;\n        float pitchVariation = 0.1f;\n\n        if (_surfaceDataDict.ContainsKey(surfaceTag))\n        {\n            var surfaceData = _surfaceDataDict[surfaceTag];\n            if (surfaceData.footstepClips != null && surfaceData.footstepClips.Length > 0)\n            {\n                clipsToUse = surfaceData.footstepClips;\n                volumeToUse = surfaceData.volume;\n                pitchVariation = surfaceData.pitchVariation;\n            }\n        }\n\n        if (clipsToUse != null && clipsToUse.Length > 0)\n        {\n            AudioClip clipToPlay = clipsToUse[Random.Range(0, clipsToUse.Length)];\n            \n            if (clipToPlay != null)\n            {\n                _audioSource.clip = clipToPlay;\n                _audioSource.volume = volumeToUse;\n                _audioSource.pitch = 1f + Random.Range(-pitchVariation, pitchVariation);\n                _audioSource.Play();\n                \n                _lastStepTime = Time.time;\n            }\n        }\n    }\n\n    public void SetStepInterval(float interval)\n    {\n        _stepInterval = Mathf.Max(0.1f, interval);\n    }\n\n    public void SetMinimumVelocity(float velocity)\n    {\n        _minimumVelocity = Mathf.Max(0f, velocity);\n    }\n\n    public string GetCurrentSurfaceTag()\n    {\n        return _currentSurfaceTag;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_raycastOrigin != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_raycastOrigin.position, _raycastOrigin.position + Vector3.down * _raycastDistance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HiddenSwitchBookshelf\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"requiredBook\",\n      \"type\": \"string\",\n      \"default\": \"red_book\"\n    },\n    {\n      \"name\": \"activationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"secretDoorTarget\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_book_interaction\",\n      \"trigger\": \"when player interacts with the correct book on the shelf\",\n      \"actions\": [\n        {\n          \"action\": \"play mechanical clicking sound\"\n        },\n        {\n          \"action\": \"mark switch as activated\"\n        },\n        {\n          \"action\": \"send activation signal to connected secret door\"\n        },\n        {\n          \"action\": \"slightly move the book inward to show it has been pressed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wrong_book_interaction\",\n      \"trigger\": \"when player interacts with any incorrect book on the shelf\",\n      \"actions\": [\n        {\n          \"action\": \"play soft book sliding sound\"\n        },\n        {\n          \"action\": \"briefly move the book outward then return to original position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_switch\",\n      \"trigger\": \"when reset signal is received from game manager\",\n      \"actions\": [\n        {\n          \"action\": \"mark switch as not activated\"\n        },\n        {\n          \"action\": \"return the correct book to its original position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class BookshelfHiddenSwitch : MonoBehaviour\n{\n    [Header(\"Bookshelf Settings\")]\n    [SerializeField] private Transform _bookshelf;\n    [SerializeField] private Transform _hiddenBook;\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _bookPullDistance = 0.2f;\n    [SerializeField] private float _animationDuration = 1f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _bookPullSound;\n    [SerializeField] private AudioClip _switchActivateSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _highlightEffect;\n    [SerializeField] private ParticleSystem _activationParticles;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSwitchActivated;\n    public UnityEvent OnSwitchDeactivated;\n    \n    private bool _isActivated = false;\n    private bool _isAnimating = false;\n    private bool _playerInRange = false;\n    private Vector3 _originalBookPosition;\n    private Vector3 _pulledBookPosition;\n    private Camera _playerCamera;\n    private Collider _bookCollider;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupPositions();\n        SetupAudio();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_hiddenBook == null)\n            _hiddenBook = transform.GetChild(0);\n            \n        if (_bookshelf == null)\n            _bookshelf = transform;\n            \n        _bookCollider = _hiddenBook.GetComponent<Collider>();\n        if (_bookCollider == null)\n            _bookCollider = _hiddenBook.gameObject.AddComponent<BoxCollider>();\n            \n        _playerCamera = Camera.main;\n        \n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n    \n    private void SetupPositions()\n    {\n        _originalBookPosition = _hiddenBook.localPosition;\n        _pulledBookPosition = _originalBookPosition + _hiddenBook.forward * _bookPullDistance;\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        bool wasInRange = _playerInRange;\n        _playerInRange = false;\n        \n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _interactionDistance, _playerLayer);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n                break;\n            }\n        }\n        \n        if (_playerInRange != wasInRange)\n        {\n            if (_highlightEffect != null)\n                _highlightEffect.SetActive(_playerInRange && !_isActivated);\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (!_playerInRange || _isAnimating)\n            return;\n            \n        if (Input.GetKeyDown(KeyCode.E) || Input.GetMouseButtonDown(0))\n        {\n            if (IsLookingAtBook())\n            {\n                ToggleSwitch();\n            }\n        }\n    }\n    \n    private bool IsLookingAtBook()\n    {\n        if (_playerCamera == null)\n            return true;\n            \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _interactionDistance))\n        {\n            return hit.collider == _bookCollider;\n        }\n        \n        return false;\n    }\n    \n    private void ToggleSwitch()\n    {\n        if (_isAnimating)\n            return;\n            \n        _isActivated = !_isActivated;\n        StartCoroutine(AnimateBook());\n        \n        if (_isActivated)\n        {\n            PlaySound(_switchActivateSound);\n            OnSwitchActivated?.Invoke();\n            \n            if (_activationParticles != null)\n                _activationParticles.Play();\n        }\n        else\n        {\n            PlaySound(_bookPullSound);\n            OnSwitchDeactivated?.Invoke();\n        }\n        \n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n    \n    private System.Collections.IEnumerator AnimateBook()\n    {\n        _isAnimating = true;\n        \n        Vector3 startPosition = _hiddenBook.localPosition;\n        Vector3 targetPosition = _isActivated ? _pulledBookPosition : _originalBookPosition;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _animationDuration;\n            float curveValue = _animationCurve.Evaluate(progress);\n            \n            _hiddenBook.localPosition = Vector3.Lerp(startPosition, targetPosition, curveValue);\n            \n            yield return null;\n        }\n        \n        _hiddenBook.localPosition = targetPosition;\n        _isAnimating = false;\n        \n        if (_highlightEffect != null && _playerInRange && !_isActivated)\n            _highlightEffect.SetActive(true);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    public void ResetSwitch()\n    {\n        if (_isAnimating)\n            return;\n            \n        _isActivated = false;\n        _hiddenBook.localPosition = _originalBookPosition;\n        \n        if (_highlightEffect != null && _playerInRange)\n            _highlightEffect.SetActive(true);\n    }\n    \n    public void ForceActivate()\n    {\n        if (_isAnimating || _isActivated)\n            return;\n            \n        _isActivated = true;\n        _hiddenBook.localPosition = _pulledBookPosition;\n        OnSwitchActivated?.Invoke();\n        \n        if (_activationParticles != null)\n            _activationParticles.Play();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n        \n        if (_hiddenBook != null)\n        {\n            Gizmos.color = Color.red;\n            Vector3 pullDirection = _hiddenBook.forward * _bookPullDistance;\n            Gizmos.DrawLine(_hiddenBook.position, _hiddenBook.position + pullDirection);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ReassemblingSkeleton\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"reassemblyTime\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"scatterForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isReassembling\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isDead\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_sequence\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"set isDead to true\"\n        },\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"scatter bone pieces in random directions with force\"\n        },\n        {\n          \"action\": \"disable main collider\"\n        },\n        {\n          \"action\": \"start reassembly timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"begin_reassembly\",\n      \"trigger\": \"when reassembly timer expires and skeleton is dead\",\n      \"actions\": [\n        {\n          \"action\": \"set isReassembling to true\"\n        },\n        {\n          \"action\": \"play bone gathering sound effect\"\n        },\n        {\n          \"action\": \"create magical particle effects around scattered bones\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reassemble_bones\",\n      \"trigger\": \"when reassembly process is active\",\n      \"actions\": [\n        {\n          \"action\": \"move scattered bone pieces back toward original positions\"\n        },\n        {\n          \"action\": \"rotate bones to correct orientations\"\n        },\n        {\n          \"action\": \"play reassembly sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_resurrection\",\n      \"trigger\": \"when all bones have returned to original positions\",\n      \"actions\": [\n        {\n          \"action\": \"restore full health\"\n        },\n        {\n          \"action\": \"set isDead to false\"\n        },\n        {\n          \"action\": \"set isReassembling to false\"\n        },\n        {\n          \"action\": \"enable main collider\"\n        },\n        {\n          \"action\": \"play resurrection animation\"\n        },\n        {\n          \"action\": \"create resurrection particle burst\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class SkeletonReassembly : MonoBehaviour\n{\n    [Header(\"Skeleton Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _reassemblyTime = 5f;\n    [SerializeField] private int _maxReassemblies = 3;\n    [SerializeField] private float _reassemblyRadius = 2f;\n    \n    [Header(\"Bone Parts\")]\n    [SerializeField] private Transform[] _boneParts;\n    [SerializeField] private Rigidbody[] _boneRigidbodies;\n    [SerializeField] private Collider _mainCollider;\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private ParticleSystem _reassemblyEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _deathSound;\n    [SerializeField] private AudioClip _reassemblySound;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    private float _currentHealth;\n    private int _reassemblyCount = 0;\n    private bool _isDead = false;\n    private bool _isReassembling = false;\n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private Transform _player;\n    private Vector3[] _originalBonePositions;\n    private Quaternion[] _originalBoneRotations;\n    \n    private enum SkeletonState\n    {\n        Alive,\n        Dead,\n        Reassembling\n    }\n    \n    private SkeletonState _currentState = SkeletonState.Alive;\n    \n    void Start()\n    {\n        _currentHealth = _health;\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n        \n        if (_mainCollider == null)\n            _mainCollider = GetComponent<Collider>();\n        \n        StoreBonePositions();\n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        switch (_currentState)\n        {\n            case SkeletonState.Alive:\n                HandleAliveState();\n                break;\n            case SkeletonState.Dead:\n                HandleDeadState();\n                break;\n            case SkeletonState.Reassembling:\n                break;\n        }\n    }\n    \n    void HandleAliveState()\n    {\n        if (_player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                Vector3 direction = (_player.position - transform.position).normalized;\n                transform.position += direction * _moveSpeed * Time.deltaTime;\n                transform.LookAt(_player);\n                \n                if (_animator != null)\n                    _animator.SetBool(\"IsWalking\", true);\n            }\n            else\n            {\n                if (_animator != null)\n                    _animator.SetBool(\"IsWalking\", false);\n            }\n        }\n    }\n    \n    void HandleDeadState()\n    {\n        if (!_isReassembling && _reassemblyCount < _maxReassemblies)\n        {\n            StartCoroutine(ReassembleCoroutine());\n        }\n    }\n    \n    void StoreBonePositions()\n    {\n        if (_boneParts != null && _boneParts.Length > 0)\n        {\n            _originalBonePositions = new Vector3[_boneParts.Length];\n            _originalBoneRotations = new Quaternion[_boneParts.Length];\n            \n            for (int i = 0; i < _boneParts.Length; i++)\n            {\n                if (_boneParts[i] != null)\n                {\n                    _originalBonePositions[i] = _boneParts[i].localPosition;\n                    _originalBoneRotations[i] = _boneParts[i].localRotation;\n                }\n            }\n        }\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n            _player = playerObject.transform;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_currentState != SkeletonState.Alive) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        _currentState = SkeletonState.Dead;\n        _isDead = true;\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsWalking\", false);\n            _animator.SetTrigger(\"Die\");\n        }\n        \n        if (_mainCollider != null)\n            _mainCollider.enabled = false;\n        \n        ScatterBones();\n        \n        if (_deathEffect != null)\n            _deathEffect.Play();\n        \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n    }\n    \n    void ScatterBones()\n    {\n        if (_boneParts == null || _boneRigidbodies == null) return;\n        \n        for (int i = 0; i < _boneParts.Length && i < _boneRigidbodies.Length; i++)\n        {\n            if (_boneParts[i] != null && _boneRigidbodies[i] != null)\n            {\n                _boneRigidbodies[i].isKinematic = false;\n                _boneRigidbodies[i].useGravity = true;\n                \n                Vector3 randomForce = new Vector3(\n                    Random.Range(-5f, 5f),\n                    Random.Range(2f, 8f),\n                    Random.Range(-5f, 5f)\n                );\n                \n                _boneRigidbodies[i].AddForce(randomForce, ForceMode.Impulse);\n                _boneRigidbodies[i].AddTorque(Random.insideUnitSphere * 10f, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    IEnumerator ReassembleCoroutine()\n    {\n        _isReassembling = true;\n        _currentState = SkeletonState.Reassembling;\n        \n        yield return new WaitForSeconds(_reassemblyTime);\n        \n        if (_reassemblyEffect != null)\n            _reassemblyEffect.Play();\n        \n        if (_audioSource != null && _reassemblySound != null)\n            _audioSource.PlayOneShot(_reassemblySound);\n        \n        yield return StartCoroutine(GatherBones());\n        \n        _currentHealth = _health;\n        _isDead = false;\n        _isReassembling = false;\n        _reassemblyCount++;\n        _currentState = SkeletonState.Alive;\n        \n        if (_mainCollider != null)\n            _mainCollider.enabled = true;\n        \n        if (_animator != null)\n            _animator.SetTrigger(\"Reassemble\");\n        \n        transform.position = _originalPosition;\n        transform.rotation = _originalRotation;\n    }\n    \n    IEnumerator GatherBones()\n    {\n        float gatherTime = 2f;\n        float elapsed = 0f;\n        \n        if (_boneParts == null || _boneRigidbodies == null) yield break;\n        \n        Vector3[] startPositions = new Vector3[_boneParts.Length];\n        Quaternion[] startRotations = new Quaternion[_boneParts.Length];\n        \n        for (int i = 0; i < _boneParts.Length; i++)\n        {\n            if (_boneParts[i] != null && _boneRigidbodies[i] != null)\n            {\n                _boneRigidbodies[i].isKinematic = true;\n                _boneRigidbodies[i].useGravity = false;\n                startPositions[i] = _boneParts[i].position;\n                startRotations[i] = _boneParts[i].rotation;\n            }\n        }\n        \n        while (elapsed < gatherTime)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / gatherTime;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            for (int i = 0; i < _boneParts.Length; i++)\n            {\n                if (_boneParts[i] != null)\n                {\n                    Vector3 targetWorldPos = transform.TransformPoint(_originalBonePositions[i]);\n                    Quaternion targetWorldRot = transform.rotation * _originalBoneRotations[i];\n                    \n                    _boneParts[i].position = Vector3.Lerp(startPositions[i], targetWorldPos, t);\n                    _boneParts[i].rotation = Quaternion.Lerp(startRotations[i], targetWorldRot, t);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        for (int i = 0; i < _boneParts.Length; i++)\n        {\n            if (_boneParts[i] != null)\n            {\n                _boneParts[i].localPosition = _originalBonePositions[i];\n                _boneParts[i].localRotation = _originalBoneRotations[i];\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_currentState != SkeletonState.Alive) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            TakeDamage(25f);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _reassemblyRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpikeTrap\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_on_contact\",\n      \"trigger\": \"when player or enemy enters trigger area and trap is active\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to the colliding entity\"\n        },\n        {\n          \"action\": \"play spike damage sound effect\"\n        },\n        {\n          \"action\": \"show damage visual effect at contact point\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpikeTrap : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damageAmount = 10;\n    [SerializeField] private float _damageInterval = 1f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private GameObject _spikesVisual;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private Vector3 _extendedPosition = Vector3.up;\n    [SerializeField] private Vector3 _retractedPosition = Vector3.zero;\n    \n    [Header(\"Activation Settings\")]\n    [SerializeField] private bool _isActive = true;\n    [SerializeField] private bool _animateSpikes = true;\n    [SerializeField] private float _activationDelay = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerDamaged;\n    public UnityEvent OnTrapActivated;\n    \n    private bool _playerInRange = false;\n    private float _lastDamageTime = 0f;\n    private bool _spikesExtended = false;\n    private Vector3 _originalSpikePosition;\n    private Coroutine _activationCoroutine;\n    \n    private void Start()\n    {\n        if (_spikesVisual != null)\n        {\n            _originalSpikePosition = _spikesVisual.transform.localPosition;\n            _retractedPosition += _originalSpikePosition;\n            _extendedPosition += _originalSpikePosition;\n            \n            if (!_isActive)\n            {\n                _spikesVisual.transform.localPosition = _retractedPosition;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_animateSpikes && _spikesVisual != null)\n        {\n            Vector3 targetPosition = _spikesExtended ? _extendedPosition : _retractedPosition;\n            _spikesVisual.transform.localPosition = Vector3.Lerp(\n                _spikesVisual.transform.localPosition, \n                targetPosition, \n                Time.deltaTime * _animationSpeed\n            );\n        }\n        \n        if (_playerInRange && _isActive && Time.time >= _lastDamageTime + _damageInterval)\n        {\n            DealDamage();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = true;\n            \n            if (_isActive)\n            {\n                if (_activationCoroutine != null)\n                {\n                    StopCoroutine(_activationCoroutine);\n                }\n                _activationCoroutine = StartCoroutine(ActivateWithDelay());\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = false;\n            _spikesExtended = false;\n            \n            if (_activationCoroutine != null)\n            {\n                StopCoroutine(_activationCoroutine);\n                _activationCoroutine = null;\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ActivateWithDelay()\n    {\n        yield return new WaitForSeconds(_activationDelay);\n        \n        if (_playerInRange && _isActive)\n        {\n            ActivateTrap();\n        }\n    }\n    \n    private void ActivateTrap()\n    {\n        _spikesExtended = true;\n        \n        if (_audioSource != null && _activationSound != null)\n        {\n            _audioSource.PlayOneShot(_activationSound);\n        }\n        \n        OnTrapActivated?.Invoke();\n        \n        if (_playerInRange)\n        {\n            DealDamage();\n        }\n    }\n    \n    private void DealDamage()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _lastDamageTime = Time.time;\n            \n            // Try to find a component that can take damage\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Use SendMessage as a fallback for damage dealing\n                player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            if (_audioSource != null && _damageSound != null)\n            {\n                _audioSource.PlayOneShot(_damageSound);\n            }\n            \n            OnPlayerDamaged?.Invoke(player);\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        if (!active)\n        {\n            _spikesExtended = false;\n            _playerInRange = false;\n        }\n    }\n    \n    public void ToggleActive()\n    {\n        SetActive(!_isActive);\n    }\n    \n    public void ForceActivate()\n    {\n        if (_isActive)\n        {\n            ActivateTrap();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActive ? Color.red : Color.gray;\n        Gizmos.DrawWireCube(transform.position, GetComponent<Collider>().bounds.size);\n        \n        if (_spikesVisual != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(transform.position + _retractedPosition, transform.position + _extendedPosition);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MinionFollower\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"leader\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"followDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"stopDistance\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_leader\",\n      \"trigger\": \"when leader exists and distance to leader is greater than follow distance\",\n      \"actions\": [\n        {\n          \"action\": \"move toward leader at move speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_following\",\n      \"trigger\": \"when distance to leader is less than stop distance\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        }\n      ]\n    },\n    {\n      \"name\": \"face_leader\",\n      \"trigger\": \"when leader exists and not moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate to face leader\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class MinionFollower : MonoBehaviour\n{\n    [Header(\"Follow Settings\")]\n    [SerializeField] private Transform _leader;\n    [SerializeField] private float _followDistance = 3f;\n    [SerializeField] private float _stopDistance = 1.5f;\n    [SerializeField] private float _maxFollowDistance = 10f;\n    [SerializeField] private float _updateRate = 0.1f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3.5f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _useNavMesh = true;\n    \n    [Header(\"Behavior\")]\n    [SerializeField] private bool _teleportWhenTooFar = true;\n    [SerializeField] private float _teleportDistance = 20f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    \n    private NavMeshAgent _navAgent;\n    private Rigidbody _rigidbody;\n    private float _lastUpdateTime;\n    private Vector3 _targetPosition;\n    private bool _isFollowing;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        FindLeaderIfNull();\n        _targetPosition = transform.position;\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_useNavMesh)\n        {\n            _navAgent = GetComponent<NavMeshAgent>();\n            if (_navAgent != null)\n            {\n                _navAgent.speed = _moveSpeed;\n                _navAgent.stoppingDistance = _stopDistance;\n            }\n        }\n        else\n        {\n            _rigidbody = GetComponent<Rigidbody>();\n            if (_rigidbody == null)\n            {\n                _rigidbody = gameObject.AddComponent<Rigidbody>();\n                _rigidbody.freezeRotation = true;\n            }\n        }\n    }\n    \n    private void FindLeaderIfNull()\n    {\n        if (_leader == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n            {\n                _leader = player.transform;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (_leader == null) return;\n        \n        if (Time.time - _lastUpdateTime >= _updateRate)\n        {\n            UpdateFollowBehavior();\n            _lastUpdateTime = Time.time;\n        }\n        \n        if (!_useNavMesh && _isFollowing)\n        {\n            MoveWithoutNavMesh();\n        }\n        \n        RotateTowardsMovementDirection();\n    }\n    \n    private void UpdateFollowBehavior()\n    {\n        float distanceToLeader = Vector3.Distance(transform.position, _leader.position);\n        \n        if (_teleportWhenTooFar && distanceToLeader > _teleportDistance)\n        {\n            TeleportToLeader();\n            return;\n        }\n        \n        if (distanceToLeader > _followDistance)\n        {\n            Vector3 directionToLeader = (_leader.position - transform.position).normalized;\n            _targetPosition = _leader.position - directionToLeader * _followDistance;\n            \n            if (HasClearPath(_targetPosition))\n            {\n                StartFollowing();\n            }\n        }\n        else if (distanceToLeader <= _stopDistance)\n        {\n            StopFollowing();\n        }\n    }\n    \n    private void StartFollowing()\n    {\n        _isFollowing = true;\n        \n        if (_useNavMesh && _navAgent != null)\n        {\n            _navAgent.SetDestination(_targetPosition);\n        }\n    }\n    \n    private void StopFollowing()\n    {\n        _isFollowing = false;\n        \n        if (_useNavMesh && _navAgent != null)\n        {\n            _navAgent.ResetPath();\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n        }\n    }\n    \n    private void MoveWithoutNavMesh()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        float distanceToTarget = Vector3.Distance(transform.position, _targetPosition);\n        \n        if (distanceToTarget > _stopDistance)\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.velocity = direction * _moveSpeed;\n            }\n            else\n            {\n                transform.position += direction * _moveSpeed * Time.deltaTime;\n            }\n        }\n        else\n        {\n            if (_rigidbody != null)\n            {\n                _rigidbody.velocity = Vector3.zero;\n            }\n        }\n    }\n    \n    private void RotateTowardsMovementDirection()\n    {\n        Vector3 movementDirection = Vector3.zero;\n        \n        if (_useNavMesh && _navAgent != null && _navAgent.hasPath)\n        {\n            movementDirection = _navAgent.velocity.normalized;\n        }\n        else if (_rigidbody != null)\n        {\n            movementDirection = _rigidbody.velocity.normalized;\n        }\n        else if (_isFollowing)\n        {\n            movementDirection = (_targetPosition - transform.position).normalized;\n        }\n        \n        if (movementDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(movementDirection);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private bool HasClearPath(Vector3 targetPos)\n    {\n        Vector3 direction = (targetPos - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetPos);\n        \n        return !Physics.Raycast(transform.position, direction, distance, _obstacleLayerMask);\n    }\n    \n    private void TeleportToLeader()\n    {\n        Vector3 teleportPosition = _leader.position + Random.insideUnitSphere * 2f;\n        teleportPosition.y = _leader.position.y;\n        \n        if (Physics.CheckSphere(teleportPosition, 0.5f, _obstacleLayerMask))\n        {\n            teleportPosition = _leader.position;\n        }\n        \n        transform.position = teleportPosition;\n        StopFollowing();\n    }\n    \n    public void SetLeader(Transform newLeader)\n    {\n        _leader = newLeader;\n    }\n    \n    public void SetFollowDistance(float distance)\n    {\n        _followDistance = Mathf.Max(0f, distance);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_leader == null) return;\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(_leader.position, _followDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_leader.position, _stopDistance);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_leader.position, _teleportDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(transform.position, _targetPosition);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Crossbow\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"boltPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"firePoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"boltSpeed\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"isLoaded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isReloading\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"fireSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"reloadSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_bolt\",\n      \"trigger\": \"when fire input is pressed and crossbow is loaded and not reloading\",\n      \"actions\": [\n        {\n          \"action\": \"play fire sound\"\n        },\n        {\n          \"action\": \"instantiate bolt at fire point position and rotation\"\n        },\n        {\n          \"action\": \"apply forward velocity to bolt based on bolt speed\"\n        },\n        {\n          \"action\": \"set crossbow as not loaded\"\n        },\n        {\n          \"action\": \"start reload timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_crossbow\",\n      \"trigger\": \"when reload time has elapsed and crossbow is not loaded\",\n      \"actions\": [\n        {\n          \"action\": \"play reload sound\"\n        },\n        {\n          \"action\": \"set crossbow as loaded\"\n        },\n        {\n          \"action\": \"set reloading state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_reload\",\n      \"trigger\": \"when crossbow becomes not loaded\",\n      \"actions\": [\n        {\n          \"action\": \"set reloading state to true\"\n        },\n        {\n          \"action\": \"begin countdown for reload duration\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Crossbow : MonoBehaviour\n{\n    [Header(\"Crossbow Settings\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _boltPrefab;\n    [SerializeField] private float _boltSpeed = 20f;\n    [SerializeField] private float _reloadTime = 2f;\n    [SerializeField] private bool _autoReload = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _fireAnimationTrigger = \"Fire\";\n    [SerializeField] private string _reloadAnimationTrigger = \"Reload\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFire;\n    public UnityEvent OnReloadStart;\n    public UnityEvent OnReloadComplete;\n    \n    private bool _isLoaded = true;\n    private bool _isReloading = false;\n    private float _reloadTimer = 0f;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleReloading();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            StartReload();\n        }\n    }\n    \n    private void HandleReloading()\n    {\n        if (_isReloading)\n        {\n            _reloadTimer += Time.deltaTime;\n            \n            if (_reloadTimer >= _reloadTime)\n            {\n                CompleteReload();\n            }\n        }\n    }\n    \n    public void TryFire()\n    {\n        if (!_isLoaded || _isReloading)\n            return;\n            \n        Fire();\n    }\n    \n    private void Fire()\n    {\n        if (_boltPrefab != null)\n        {\n            GameObject bolt = Instantiate(_boltPrefab, _firePoint.position, _firePoint.rotation);\n            CrossbowBolt boltScript = bolt.GetComponent<CrossbowBolt>();\n            \n            if (boltScript == null)\n                boltScript = bolt.AddComponent<CrossbowBolt>();\n                \n            boltScript.Initialize(_boltSpeed);\n        }\n        \n        _isLoaded = false;\n        \n        PlayFireEffects();\n        OnFire?.Invoke();\n        \n        if (_autoReload)\n        {\n            StartReload();\n        }\n    }\n    \n    private void PlayFireEffects()\n    {\n        if (_audioSource != null && _fireSound != null)\n        {\n            _audioSource.PlayOneShot(_fireSound);\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_fireAnimationTrigger))\n        {\n            _animator.SetTrigger(_fireAnimationTrigger);\n        }\n    }\n    \n    public void StartReload()\n    {\n        if (_isLoaded || _isReloading)\n            return;\n            \n        _isReloading = true;\n        _reloadTimer = 0f;\n        \n        if (_audioSource != null && _reloadSound != null)\n        {\n            _audioSource.PlayOneShot(_reloadSound);\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_reloadAnimationTrigger))\n        {\n            _animator.SetTrigger(_reloadAnimationTrigger);\n        }\n        \n        OnReloadStart?.Invoke();\n    }\n    \n    private void CompleteReload()\n    {\n        _isReloading = false;\n        _isLoaded = true;\n        _reloadTimer = 0f;\n        \n        OnReloadComplete?.Invoke();\n    }\n    \n    public bool IsLoaded => _isLoaded;\n    public bool IsReloading => _isReloading;\n    public float ReloadProgress => _isReloading ? _reloadTimer / _reloadTime : 0f;\n}\n\npublic class CrossbowBolt : MonoBehaviour\n{\n    [Header(\"Bolt Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _lifetime = 10f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravityScale = 1f;\n    [SerializeField] private bool _useGravity = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private TrailRenderer _trail;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _hasHit = false;\n    private float _speed;\n    private Vector3 _velocity;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_collider == null)\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n    }\n    \n    private void Start()\n    {\n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_hasHit && _useGravity)\n        {\n            _rigidbody.AddForce(Physics.gravity * _gravityScale, ForceMode.Acceleration);\n        }\n        \n        if (!_hasHit)\n        {\n            AlignWithVelocity();\n        }\n    }\n    \n    public void Initialize(float speed)\n    {\n        _speed = speed;\n        _velocity = transform.forward * speed;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = _velocity;\n            _rigidbody.useGravity = _useGravity;\n        }\n    }\n    \n    private void AlignWithVelocity()\n    {\n        if (_rigidbody != null && _rigidbody.velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_rigidbody.velocity);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleHit(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleHit(collision.collider);\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        if (_hasHit)\n            return;\n            \n        if ((_hitLayers.value & (1 << hitCollider.gameObject.layer)) == 0)\n            return;\n            \n        _hasHit = true;\n        \n        // Deal damage to player\n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            // Send damage message\n            hitCollider.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Stick to surface\n        if (_stickToSurfaces)\n        {\n            StickToSurface(hitCollider);\n        }\n        \n        // Play effects\n        PlayHitEffects();\n        \n        // Destroy after sticking\n        if (_stickToSurfaces)\n        {\n            Destroy(gameObject, 5f);\n        }\n        else\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        // Parent to hit object if it's not static\n        if (surface.attachedRigidbody != null)\n        {\n            transform.SetParent(surface.transform);\n        }\n        \n        if (_trail != null)\n        {\n            _trail.enabled = false;\n        }\n    }\n    \n    private void PlayHitEffects()\n    {\n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n        \n        if (_hitSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_hitSound, transform.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RisingWater\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"riseSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"maxHeight\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"currentHeight\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"rise_water_level\",\n      \"trigger\": \"every frame while water height is below maximum height\",\n      \"actions\": [\n        {\n          \"action\": \"increase water height by rise speed over time\"\n        },\n        {\n          \"action\": \"move water surface upward to match current height\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_rising\",\n      \"trigger\": \"when water height reaches maximum height\",\n      \"actions\": [\n        {\n          \"action\": \"stop increasing water height\"\n        },\n        {\n          \"action\": \"maintain water at maximum level\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RisingWater : MonoBehaviour\n{\n    [Header(\"Water Level Settings\")]\n    [SerializeField] private float _riseSpeed = 1f;\n    [SerializeField] private float _maxHeight = 50f;\n    [SerializeField] private float _startDelay = 0f;\n    [SerializeField] private bool _startRisingOnAwake = true;\n    \n    [Header(\"Water Behavior\")]\n    [SerializeField] private AnimationCurve _riseSpeedCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);\n    [SerializeField] private bool _pauseOnPlayerContact = false;\n    [SerializeField] private float _pauseDuration = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _risingSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWaterStartRising;\n    public UnityEvent OnWaterReachMaxHeight;\n    public UnityEvent<GameObject> OnObjectSubmerged;\n    public UnityEvent<GameObject> OnPlayerContact;\n    \n    private float _currentHeight;\n    private float _initialHeight;\n    private bool _isRising = false;\n    private float _startTime;\n    private float _pauseEndTime;\n    private bool _isPaused = false;\n    private bool _hasReachedMax = false;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    private void Awake()\n    {\n        _initialHeight = transform.position.y;\n        _currentHeight = _initialHeight;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        if (_startRisingOnAwake)\n        {\n            StartRising();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isRising || _hasReachedMax)\n            return;\n            \n        if (_isPaused && Time.time < _pauseEndTime)\n            return;\n            \n        if (_isPaused && Time.time >= _pauseEndTime)\n        {\n            _isPaused = false;\n        }\n        \n        if (Time.time < _startTime + _startDelay)\n            return;\n            \n        float progress = (_currentHeight - _initialHeight) / (_maxHeight - _initialHeight);\n        float speedMultiplier = _riseSpeedCurve.Evaluate(progress);\n        \n        _currentHeight += _riseSpeed * speedMultiplier * Time.deltaTime;\n        \n        if (_currentHeight >= _maxHeight)\n        {\n            _currentHeight = _maxHeight;\n            _hasReachedMax = true;\n            OnWaterReachMaxHeight?.Invoke();\n            \n            if (_audioSource != null && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _currentHeight;\n        transform.position = newPosition;\n    }\n    \n    public void StartRising()\n    {\n        _isRising = true;\n        _startTime = Time.time;\n        OnWaterStartRising?.Invoke();\n        \n        if (_audioSource != null && _risingSound != null)\n        {\n            _audioSource.clip = _risingSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    public void StopRising()\n    {\n        _isRising = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n    \n    public void PauseRising()\n    {\n        if (!_isRising)\n            return;\n            \n        _isPaused = true;\n        _pauseEndTime = Time.time + _pauseDuration;\n    }\n    \n    public void ResetWaterLevel()\n    {\n        _currentHeight = _initialHeight;\n        _hasReachedMax = false;\n        _isRising = false;\n        _isPaused = false;\n        _lastDamageTime.Clear();\n        \n        Vector3 newPosition = transform.position;\n        newPosition.y = _currentHeight;\n        transform.position = newPosition;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n    \n    public void SetRiseSpeed(float newSpeed)\n    {\n        _riseSpeed = Mathf.Max(0f, newSpeed);\n    }\n    \n    public void SetMaxHeight(float newMaxHeight)\n    {\n        _maxHeight = newMaxHeight;\n    }\n    \n    public float GetWaterLevel()\n    {\n        return _currentHeight;\n    }\n    \n    public float GetWaterProgress()\n    {\n        if (_maxHeight <= _initialHeight)\n            return 0f;\n            \n        return Mathf.Clamp01((_currentHeight - _initialHeight) / (_maxHeight - _initialHeight));\n    }\n    \n    public bool IsRising()\n    {\n        return _isRising && !_hasReachedMax;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            OnPlayerContact?.Invoke(other.gameObject);\n            \n            if (_pauseOnPlayerContact)\n            {\n                PauseRising();\n            }\n            \n            PlaySplashEffect(other.transform.position);\n        }\n        \n        OnObjectSubmerged?.Invoke(other.gameObject);\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (ShouldDamageObject(other))\n        {\n            DealDamage(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_lastDamageTime.ContainsKey(other.gameObject))\n        {\n            _lastDamageTime.Remove(other.gameObject);\n        }\n    }\n    \n    private bool ShouldDamageObject(Collider other)\n    {\n        if (_damageAmount <= 0f)\n            return false;\n            \n        if ((_damageableLayers.value & (1 << other.gameObject.layer)) == 0)\n            return false;\n            \n        if (!_lastDamageTime.ContainsKey(other.gameObject))\n            return true;\n            \n        return Time.time >= _lastDamageTime[other.gameObject] + _damageInterval;\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        _lastDamageTime[target] = Time.time;\n        \n        // Try to find health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to call TakeDamage if it exists\n            var takeDamageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Alternative: Send message (safer approach)\n        target.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void PlaySplashEffect(Vector3 position)\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = position;\n            _splashEffect.Play();\n        }\n        \n        if (_audioSource != null && _splashSound != null)\n        {\n            _audioSource.PlayOneShot(_splashSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        \n        Vector3 currentPos = transform.position;\n        Vector3 maxPos = new Vector3(currentPos.x, _maxHeight, currentPos.z);\n        \n        // Draw current water level\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(currentPos, new Vector3(10f, 0.1f, 10f));\n        \n        // Draw max water level\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(maxPos, new Vector3(10f, 0.1f, 10f));\n        \n        // Draw rise direction\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(currentPos, maxPos);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ReturningChakram\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"returnSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxDistance\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 720\n    },\n    {\n      \"name\": \"thrower\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isReturning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"throw_chakram\",\n      \"trigger\": \"when chakram is thrown\",\n      \"actions\": [\n        {\n          \"action\": \"apply forward force based on throw force\"\n        },\n        {\n          \"action\": \"start spinning continuously at rotation speed\"\n        },\n        {\n          \"action\": \"record the thrower position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_return_condition\",\n      \"trigger\": \"when chakram has traveled maximum distance or hits obstacle\",\n      \"actions\": [\n        {\n          \"action\": \"set returning state to true\"\n        },\n        {\n          \"action\": \"stop forward momentum\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_thrower\",\n      \"trigger\": \"when chakram is in returning state\",\n      \"actions\": [\n        {\n          \"action\": \"move toward thrower position at return speed\"\n        },\n        {\n          \"action\": \"continue spinning during return flight\"\n        }\n      ]\n    },\n    {\n      \"name\": \"catch_chakram\",\n      \"trigger\": \"when chakram reaches thrower position while returning\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"stop spinning\"\n        },\n        {\n          \"action\": \"reset returning state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ReturningChakram : MonoBehaviour\n{\n    [Header(\"Chakram Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _returnSpeed = 10f;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _rotationSpeed = 720f;\n    [SerializeField] private float _returnDelay = 0.5f;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _returnSound;\n    \n    private enum ChakramState\n    {\n        Idle,\n        Thrown,\n        Returning,\n        Caught\n    }\n    \n    private ChakramState _currentState = ChakramState.Idle;\n    private Transform _thrower;\n    private Vector3 _throwDirection;\n    private Vector3 _startPosition;\n    private float _distanceTraveled;\n    private float _returnTimer;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private bool _hasHitTarget;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.useGravity = false;\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        HandleRotation();\n        HandleMovement();\n        CheckReturnConditions();\n    }\n    \n    private void HandleRotation()\n    {\n        if (_currentState != ChakramState.Idle && _currentState != ChakramState.Caught)\n        {\n            transform.Rotate(Vector3.forward * _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        switch (_currentState)\n        {\n            case ChakramState.Thrown:\n                HandleThrownMovement();\n                break;\n            case ChakramState.Returning:\n                HandleReturningMovement();\n                break;\n        }\n    }\n    \n    private void HandleThrownMovement()\n    {\n        _distanceTraveled += _rigidbody.velocity.magnitude * Time.deltaTime;\n        \n        if (_returnTimer > 0f)\n        {\n            _returnTimer -= Time.deltaTime;\n        }\n    }\n    \n    private void HandleReturningMovement()\n    {\n        if (_thrower != null)\n        {\n            Vector3 directionToThrower = (_thrower.position - transform.position).normalized;\n            _rigidbody.velocity = directionToThrower * _returnSpeed;\n            \n            float distanceToThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceToThrower < 1f)\n            {\n                CatchChakram();\n            }\n        }\n        else\n        {\n            Vector3 directionToStart = (_startPosition - transform.position).normalized;\n            _rigidbody.velocity = directionToStart * _returnSpeed;\n            \n            float distanceToStart = Vector3.Distance(transform.position, _startPosition);\n            if (distanceToStart < 1f)\n            {\n                ResetChakram();\n            }\n        }\n    }\n    \n    private void CheckReturnConditions()\n    {\n        if (_currentState == ChakramState.Thrown)\n        {\n            bool shouldReturn = _distanceTraveled >= _maxDistance || \n                              _returnTimer <= 0f || \n                              _hasHitTarget;\n            \n            if (shouldReturn)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    public void ThrowChakram(Transform thrower, Vector3 direction)\n    {\n        if (_currentState != ChakramState.Idle) return;\n        \n        _thrower = thrower;\n        _throwDirection = direction.normalized;\n        _currentState = ChakramState.Thrown;\n        _distanceTraveled = 0f;\n        _returnTimer = _returnDelay;\n        _hasHitTarget = false;\n        \n        _rigidbody.velocity = _throwDirection * _throwForce;\n        \n        PlaySound(_throwSound);\n    }\n    \n    private void StartReturning()\n    {\n        if (_currentState != ChakramState.Thrown) return;\n        \n        _currentState = ChakramState.Returning;\n        PlaySound(_returnSound);\n    }\n    \n    private void CatchChakram()\n    {\n        _currentState = ChakramState.Caught;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_thrower != null)\n        {\n            transform.SetParent(_thrower);\n            transform.localPosition = Vector3.zero;\n        }\n        \n        ResetChakram();\n    }\n    \n    private void ResetChakram()\n    {\n        _currentState = ChakramState.Idle;\n        _rigidbody.velocity = Vector3.zero;\n        _distanceTraveled = 0f;\n        _returnTimer = 0f;\n        _hasHitTarget = false;\n        _thrower = null;\n        \n        transform.SetParent(null);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_currentState != ChakramState.Thrown && _currentState != ChakramState.Returning) return;\n        \n        if (other.CompareTag(\"Player\") && _currentState == ChakramState.Returning)\n        {\n            CatchChakram();\n            return;\n        }\n        \n        if (_thrower != null && other.transform == _thrower) return;\n        \n        if (IsInLayerMask(other.gameObject.layer, _enemyLayers))\n        {\n            DealDamage(other);\n            _hasHitTarget = true;\n            \n            if (_currentState == ChakramState.Thrown)\n            {\n                StartReturning();\n            }\n        }\n        else if (other.CompareTag(\"Wall\") || other.CompareTag(\"Obstacle\"))\n        {\n            _hasHitTarget = true;\n            \n            if (_currentState == ChakramState.Thrown)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        var targetHealth = target.GetComponent<Health>();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(_damage);\n        }\n        \n        PlaySound(_hitSound);\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsAvailable()\n    {\n        return _currentState == ChakramState.Idle;\n    }\n    \n    public void ForceReturn()\n    {\n        if (_currentState == ChakramState.Thrown)\n        {\n            StartReturning();\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InvisibilityToggle\",\n  \"components\": [\n    \"Renderer\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isInvisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"toggleKey\",\n      \"type\": \"KeyCode\",\n      \"default\": \"KeyCode.I\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"toggle_invisibility\",\n      \"trigger\": \"when toggle key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"switch invisibility state to opposite of current state\"\n        },\n        {\n          \"action\": \"if becoming invisible then hide renderer and disable collider\"\n        },\n        {\n          \"action\": \"if becoming visible then show renderer and enable collider\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class InvisibilityToggle : MonoBehaviour\n{\n    [Header(\"Invisibility Settings\")]\n    [SerializeField] private KeyCode _toggleKey = KeyCode.I;\n    [SerializeField] private float _invisibilityDuration = 5f;\n    [SerializeField] private bool _hasLimitedDuration = true;\n    [SerializeField] private float _cooldownTime = 3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _visibleAlpha = 1f;\n    [SerializeField] private float _invisibleAlpha = 0.1f;\n    [SerializeField] private float _fadeSpeed = 5f;\n    [SerializeField] private bool _disableColliders = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _activateSound;\n    [SerializeField] private AudioClip _deactivateSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnInvisibilityActivated;\n    public UnityEvent OnInvisibilityDeactivated;\n    public UnityEvent OnCooldownStarted;\n    public UnityEvent OnCooldownEnded;\n    \n    private bool _isInvisible = false;\n    private bool _isOnCooldown = false;\n    private float _invisibilityTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private float _currentAlpha;\n    \n    private Renderer[] _renderers;\n    private Collider[] _colliders;\n    private AudioSource _audioSource;\n    private Material[] _originalMaterials;\n    private Material[] _transparentMaterials;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupMaterials();\n        _currentAlpha = _visibleAlpha;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateTimers();\n        UpdateVisualEffects();\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderers = GetComponentsInChildren<Renderer>();\n        _colliders = GetComponentsInChildren<Collider>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.playOnAwake = false;\n        _audioSource.volume = _audioVolume;\n    }\n    \n    private void SetupMaterials()\n    {\n        if (_renderers == null || _renderers.Length == 0) return;\n        \n        _originalMaterials = new Material[_renderers.Length];\n        _transparentMaterials = new Material[_renderers.Length];\n        \n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _renderers[i].material != null)\n            {\n                _originalMaterials[i] = _renderers[i].material;\n                _transparentMaterials[i] = new Material(_originalMaterials[i]);\n                \n                // Enable transparency\n                _transparentMaterials[i].SetFloat(\"_Mode\", 3);\n                _transparentMaterials[i].SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n                _transparentMaterials[i].SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n                _transparentMaterials[i].SetInt(\"_ZWrite\", 0);\n                _transparentMaterials[i].DisableKeyword(\"_ALPHATEST_ON\");\n                _transparentMaterials[i].EnableKeyword(\"_ALPHABLEND_ON\");\n                _transparentMaterials[i].DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n                _transparentMaterials[i].renderQueue = 3000;\n            }\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_toggleKey) && !_isOnCooldown)\n        {\n            ToggleInvisibility();\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_isInvisible && _hasLimitedDuration)\n        {\n            _invisibilityTimer -= Time.deltaTime;\n            if (_invisibilityTimer <= 0f)\n            {\n                DeactivateInvisibility();\n            }\n        }\n        \n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownEnded?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        float targetAlpha = _isInvisible ? _invisibleAlpha : _visibleAlpha;\n        _currentAlpha = Mathf.Lerp(_currentAlpha, targetAlpha, _fadeSpeed * Time.deltaTime);\n        \n        ApplyAlphaToMaterials(_currentAlpha);\n    }\n    \n    private void ApplyAlphaToMaterials(float alpha)\n    {\n        for (int i = 0; i < _renderers.Length; i++)\n        {\n            if (_renderers[i] != null && _transparentMaterials[i] != null)\n            {\n                Color color = _transparentMaterials[i].color;\n                color.a = alpha;\n                _transparentMaterials[i].color = color;\n                \n                if (_renderers[i].material != _transparentMaterials[i])\n                {\n                    _renderers[i].material = _transparentMaterials[i];\n                }\n            }\n        }\n    }\n    \n    public void ToggleInvisibility()\n    {\n        if (_isInvisible)\n        {\n            DeactivateInvisibility();\n        }\n        else\n        {\n            ActivateInvisibility();\n        }\n    }\n    \n    public void ActivateInvisibility()\n    {\n        if (_isOnCooldown) return;\n        \n        _isInvisible = true;\n        \n        if (_hasLimitedDuration)\n        {\n            _invisibilityTimer = _invisibilityDuration;\n        }\n        \n        if (_disableColliders)\n        {\n            SetCollidersEnabled(false);\n        }\n        \n        PlaySound(_activateSound);\n        OnInvisibilityActivated?.Invoke();\n    }\n    \n    public void DeactivateInvisibility()\n    {\n        _isInvisible = false;\n        _invisibilityTimer = 0f;\n        \n        if (_disableColliders)\n        {\n            SetCollidersEnabled(true);\n        }\n        \n        if (_cooldownTime > 0f)\n        {\n            StartCooldown();\n        }\n        \n        PlaySound(_deactivateSound);\n        OnInvisibilityDeactivated?.Invoke();\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        OnCooldownStarted?.Invoke();\n    }\n    \n    private void SetCollidersEnabled(bool enabled)\n    {\n        foreach (Collider col in _colliders)\n        {\n            if (col != null)\n            {\n                col.enabled = enabled;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        // Clean up transparent materials\n        if (_transparentMaterials != null)\n        {\n            for (int i = 0; i < _transparentMaterials.Length; i++)\n            {\n                if (_transparentMaterials[i] != null)\n                {\n                    DestroyImmediate(_transparentMaterials[i]);\n                }\n            }\n        }\n        \n        // Restore original materials\n        if (_originalMaterials != null && _renderers != null)\n        {\n            for (int i = 0; i < _renderers.Length; i++)\n            {\n                if (_renderers[i] != null && _originalMaterials[i] != null)\n                {\n                    _renderers[i].material = _originalMaterials[i];\n                }\n            }\n        }\n    }\n    \n    public bool IsInvisible => _isInvisible;\n    public bool IsOnCooldown => _isOnCooldown;\n    public float RemainingInvisibilityTime => _invisibilityTimer;\n    public float RemainingCooldownTime => _cooldownTimer;\n    public float InvisibilityProgress => _hasLimitedDuration ? (_invisibilityDuration - _invisibilityTimer) / _invisibilityDuration : 0f;\n    public float CooldownProgress => _cooldownTime > 0f ? (_cooldownTime - _cooldownTimer) / _cooldownTime : 1f;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ControlRemapper\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentControlScheme\",\n      \"type\": \"string\",\n      \"default\": \"default\"\n    },\n    {\n      \"name\": \"isRemapping\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"remapTimeLimit\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"controlMappings\",\n      \"type\": \"Dictionary\",\n      \"default\": \"empty\"\n    },\n    {\n      \"name\": \"defaultMappings\",\n      \"type\": \"Dictionary\",\n      \"default\": \"empty\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_default_controls\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"load default control mappings from settings\"\n        },\n        {\n          \"action\": \"apply current control scheme to input system\"\n        },\n        {\n          \"action\": \"display current control bindings in UI\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_control_remapping\",\n      \"trigger\": \"when remap button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"enter remapping mode\"\n        },\n        {\n          \"action\": \"highlight the control being remapped\"\n        },\n        {\n          \"action\": \"display instruction to press new key\"\n        },\n        {\n          \"action\": \"start countdown timer for input timeout\"\n        }\n      ]\n    },\n    {\n      \"name\": \"capture_new_input\",\n      \"trigger\": \"when any key is pressed during remapping mode\",\n      \"actions\": [\n        {\n          \"action\": \"check if new key is already assigned to another action\"\n        },\n        {\n          \"action\": \"warn user about conflicting key assignments\"\n        },\n        {\n          \"action\": \"assign new key to selected control action\"\n        },\n        {\n          \"action\": \"update control mapping dictionary\"\n        },\n        {\n          \"action\": \"exit remapping mode\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_remapping_timeout\",\n      \"trigger\": \"when remapping timer expires without input\",\n      \"actions\": [\n        {\n          \"action\": \"cancel remapping operation\"\n        },\n        {\n          \"action\": \"restore previous key binding\"\n        },\n        {\n          \"action\": \"exit remapping mode\"\n        },\n        {\n          \"action\": \"display timeout message to user\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_to_defaults\",\n      \"trigger\": \"when reset defaults button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"restore all controls to default mappings\"\n        },\n        {\n          \"action\": \"clear any custom key assignments\"\n        },\n        {\n          \"action\": \"update UI to show default bindings\"\n        },\n        {\n          \"action\": \"save default settings to persistent storage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"save_control_settings\",\n      \"trigger\": \"when apply or save button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"validate all control mappings for conflicts\"\n        },\n        {\n          \"action\": \"save current mappings to player preferences\"\n        },\n        {\n          \"action\": \"apply new control scheme to game systems\"\n        },\n        {\n          \"action\": \"display confirmation message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_duplicate_assignment\",\n      \"trigger\": \"when attempting to assign already used key\",\n      \"actions\": [\n        {\n          \"action\": \"show conflict resolution dialog\"\n        },\n        {\n          \"action\": \"offer to swap key assignments\"\n        },\n        {\n          \"action\": \"allow user to choose different key\"\n        },\n        {\n          \"action\": \"highlight conflicting control actions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_control_display\",\n      \"trigger\": \"when control mappings change\",\n      \"actions\": [\n        {\n          \"action\": \"refresh UI elements showing key bindings\"\n        },\n        {\n          \"action\": \"update button labels with new key names\"\n        },\n        {\n          \"action\": \"highlight recently changed controls\"\n        },\n        {\n          \"action\": \"validate control scheme completeness\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class InputRemapper : MonoBehaviour\n{\n    [System.Serializable]\n    public class InputAction\n    {\n        public string actionName;\n        public KeyCode defaultKey;\n        public KeyCode currentKey;\n        public string description;\n        \n        public InputAction(string name, KeyCode key, string desc)\n        {\n            actionName = name;\n            defaultKey = key;\n            currentKey = key;\n            description = desc;\n        }\n    }\n\n    [System.Serializable]\n    public class InputBinding\n    {\n        public Button remapButton;\n        public Text actionLabel;\n        public Text keyLabel;\n        public string actionName;\n    }\n\n    [Header(\"Input Actions\")]\n    [SerializeField] private List<InputAction> _inputActions = new List<InputAction>();\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _remapPanel;\n    [SerializeField] private List<InputBinding> _inputBindings = new List<InputBinding>();\n    [SerializeField] private Button _resetButton;\n    [SerializeField] private Button _saveButton;\n    [SerializeField] private Button _cancelButton;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private GameObject _listeningOverlay;\n    [SerializeField] private Text _listeningText;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private string _saveKey = \"InputMappings\";\n    [SerializeField] private float _listeningTimeout = 10f;\n    \n    private Dictionary<string, KeyCode> _keyMappings = new Dictionary<string, KeyCode>();\n    private bool _isListening = false;\n    private string _currentRemappingAction = \"\";\n    private float _listeningTimer = 0f;\n    private Dictionary<string, KeyCode> _originalMappings = new Dictionary<string, KeyCode>();\n    \n    public UnityEvent<string, KeyCode> OnKeyRemapped = new UnityEvent<string, KeyCode>();\n    public UnityEvent OnMappingsReset = new UnityEvent();\n    public UnityEvent OnMappingsSaved = new UnityEvent();\n\n    private void Start()\n    {\n        InitializeDefaultActions();\n        LoadMappings();\n        SetupUI();\n        UpdateUI();\n    }\n\n    private void Update()\n    {\n        if (_isListening)\n        {\n            HandleKeyListening();\n        }\n        \n        HandleInputActions();\n    }\n\n    private void InitializeDefaultActions()\n    {\n        if (_inputActions.Count == 0)\n        {\n            _inputActions.Add(new InputAction(\"Move Forward\", KeyCode.W, \"Move character forward\"));\n            _inputActions.Add(new InputAction(\"Move Backward\", KeyCode.S, \"Move character backward\"));\n            _inputActions.Add(new InputAction(\"Move Left\", KeyCode.A, \"Move character left\"));\n            _inputActions.Add(new InputAction(\"Move Right\", KeyCode.D, \"Move character right\"));\n            _inputActions.Add(new InputAction(\"Jump\", KeyCode.Space, \"Make character jump\"));\n            _inputActions.Add(new InputAction(\"Run\", KeyCode.LeftShift, \"Make character run\"));\n            _inputActions.Add(new InputAction(\"Interact\", KeyCode.E, \"Interact with objects\"));\n            _inputActions.Add(new InputAction(\"Inventory\", KeyCode.Tab, \"Open inventory\"));\n            _inputActions.Add(new InputAction(\"Pause\", KeyCode.Escape, \"Pause the game\"));\n        }\n\n        foreach (var action in _inputActions)\n        {\n            _keyMappings[action.actionName] = action.currentKey;\n            _originalMappings[action.actionName] = action.currentKey;\n        }\n    }\n\n    private void SetupUI()\n    {\n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetToDefaults);\n            \n        if (_saveButton != null)\n            _saveButton.onClick.AddListener(SaveMappings);\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.AddListener(CancelRemapping);\n\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.remapButton != null)\n            {\n                string actionName = binding.actionName;\n                binding.remapButton.onClick.AddListener(() => StartRemapping(actionName));\n            }\n        }\n    }\n\n    private void HandleKeyListening()\n    {\n        _listeningTimer += Time.unscaledDeltaTime;\n        \n        if (_listeningTimer >= _listeningTimeout)\n        {\n            CancelRemapping();\n            return;\n        }\n\n        if (_listeningText != null)\n        {\n            float remainingTime = _listeningTimeout - _listeningTimer;\n            _listeningText.text = $\"Press a key for '{_currentRemappingAction}'\\nTimeout: {remainingTime:F1}s\";\n        }\n\n        foreach (KeyCode key in System.Enum.GetValues(typeof(KeyCode)))\n        {\n            if (Input.GetKeyDown(key))\n            {\n                if (key == KeyCode.Escape)\n                {\n                    CancelRemapping();\n                    return;\n                }\n\n                if (IsValidKey(key))\n                {\n                    RemapKey(_currentRemappingAction, key);\n                    StopListening();\n                }\n                else\n                {\n                    ShowStatus(\"Invalid key selected\", Color.red);\n                }\n                return;\n            }\n        }\n    }\n\n    private void HandleInputActions()\n    {\n        // This method can be used by other scripts to check for input\n        // Example usage in other scripts: if (inputRemapper.IsActionPressed(\"Jump\"))\n    }\n\n    public bool IsActionPressed(string actionName)\n    {\n        if (_keyMappings.ContainsKey(actionName))\n        {\n            return Input.GetKeyDown(_keyMappings[actionName]);\n        }\n        return false;\n    }\n\n    public bool IsActionHeld(string actionName)\n    {\n        if (_keyMappings.ContainsKey(actionName))\n        {\n            return Input.GetKey(_keyMappings[actionName]);\n        }\n        return false;\n    }\n\n    public KeyCode GetKeyForAction(string actionName)\n    {\n        return _keyMappings.ContainsKey(actionName) ? _keyMappings[actionName] : KeyCode.None;\n    }\n\n    public void StartRemapping(string actionName)\n    {\n        if (_isListening) return;\n\n        _currentRemappingAction = actionName;\n        _isListening = true;\n        _listeningTimer = 0f;\n\n        if (_listeningOverlay != null)\n            _listeningOverlay.SetActive(true);\n\n        ShowStatus($\"Listening for new key for '{actionName}'...\", Color.yellow);\n    }\n\n    private void RemapKey(string actionName, KeyCode newKey)\n    {\n        if (IsKeyAlreadyMapped(newKey, actionName))\n        {\n            ShowStatus($\"Key '{newKey}' is already mapped to another action\", Color.red);\n            return;\n        }\n\n        KeyCode oldKey = _keyMappings[actionName];\n        _keyMappings[actionName] = newKey;\n\n        var action = _inputActions.Find(a => a.actionName == actionName);\n        if (action != null)\n        {\n            action.currentKey = newKey;\n        }\n\n        OnKeyRemapped.Invoke(actionName, newKey);\n        ShowStatus($\"'{actionName}' remapped to '{newKey}'\", Color.green);\n        UpdateUI();\n    }\n\n    private void StopListening()\n    {\n        _isListening = false;\n        _currentRemappingAction = \"\";\n        _listeningTimer = 0f;\n\n        if (_listeningOverlay != null)\n            _listeningOverlay.SetActive(false);\n    }\n\n    private void CancelRemapping()\n    {\n        StopListening();\n        ShowStatus(\"Remapping cancelled\", Color.gray);\n    }\n\n    private bool IsValidKey(KeyCode key)\n    {\n        return key != KeyCode.None && \n               key != KeyCode.Mouse0 && \n               key != KeyCode.Mouse1 && \n               key != KeyCode.Mouse2;\n    }\n\n    private bool IsKeyAlreadyMapped(KeyCode key, string excludeAction = \"\")\n    {\n        foreach (var mapping in _keyMappings)\n        {\n            if (mapping.Value == key && mapping.Key != excludeAction)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void UpdateUI()\n    {\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.actionLabel != null)\n            {\n                var action = _inputActions.Find(a => a.actionName == binding.actionName);\n                if (action != null)\n                {\n                    binding.actionLabel.text = action.description;\n                }\n            }\n\n            if (binding.keyLabel != null && _keyMappings.ContainsKey(binding.actionName))\n            {\n                binding.keyLabel.text = _keyMappings[binding.actionName].ToString();\n            }\n        }\n    }\n\n    public void ResetToDefaults()\n    {\n        foreach (var action in _inputActions)\n        {\n            action.currentKey = action.defaultKey;\n            _keyMappings[action.actionName] = action.defaultKey;\n        }\n\n        OnMappingsReset.Invoke();\n        ShowStatus(\"Controls reset to defaults\", Color.green);\n        UpdateUI();\n    }\n\n    public void SaveMappings()\n    {\n        string json = JsonUtility.ToJson(new SerializableKeyMappings(_keyMappings));\n        PlayerPrefs.SetString(_saveKey, json);\n        PlayerPrefs.Save();\n\n        foreach (var mapping in _keyMappings)\n        {\n            _originalMappings[mapping.Key] = mapping.Value;\n        }\n\n        OnMappingsSaved.Invoke();\n        ShowStatus(\"Controls saved successfully\", Color.green);\n    }\n\n    private void LoadMappings()\n    {\n        if (PlayerPrefs.HasKey(_saveKey))\n        {\n            string json = PlayerPrefs.GetString(_saveKey);\n            try\n            {\n                var loadedMappings = JsonUtility.FromJson<SerializableKeyMappings>(json);\n                if (loadedMappings != null && loadedMappings.keys != null)\n                {\n                    for (int i = 0; i < loadedMappings.keys.Count; i++)\n                    {\n                        string actionName = loadedMappings.keys[i];\n                        KeyCode keyCode = loadedMappings.values[i];\n                        \n                        if (_keyMappings.ContainsKey(actionName))\n                        {\n                            _keyMappings[actionName] = keyCode;\n                            var action = _inputActions.Find(a => a.actionName == actionName);\n                            if (action != null)\n                            {\n                                action.currentKey = keyCode;\n                            }\n                        }\n                    }\n                }\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning($\"Failed to load input mappings: {e.Message}\");\n            }\n        }\n    }\n\n    public void OpenRemapPanel()\n    {\n        if (_remapPanel != null)\n        {\n            _remapPanel.SetActive(true);\n            UpdateUI();\n        }\n    }\n\n    public void CloseRemapPanel()\n    {\n        if (_remapPanel != null)\n        {\n            _remapPanel.SetActive(false);\n        }\n        \n        if (_isListening)\n        {\n            CancelRemapping();\n        }\n    }\n\n    private void ShowStatus(string message, Color color)\n    {\n        if (_statusText != null)\n        {\n            _statusText.text = message;\n            _statusText.color = color;\n            CancelInvoke(nameof(ClearStatus));\n            Invoke(nameof(ClearStatus), 3f);\n        }\n    }\n\n    private void ClearStatus()\n    {\n        if (_statusText != null)\n        {\n            _statusText.text = \"\";\n        }\n    }\n\n    [System.Serializable]\n    private class SerializableKeyMappings\n    {\n        public List<string> keys = new List<string>();\n        public List<KeyCode> values = new List<KeyCode>();\n\n        public SerializableKeyMappings(Dictionary<string, KeyCode> mappings)\n        {\n            foreach (var mapping in mappings)\n            {\n                keys.Add(mapping.Key);\n                values.Add(mapping.Value);\n            }\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_resetButton != null)\n            _resetButton.onClick.RemoveAllListeners();\n            \n        if (_saveButton != null)\n            _saveButton.onClick.RemoveAllListeners();\n            \n        if (_cancelButton != null)\n            _cancelButton.onClick.RemoveAllListeners();\n\n        foreach (var binding in _inputBindings)\n        {\n            if (binding.remapButton != null)\n                binding.remapButton.onClick.RemoveAllListeners();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SelfModifyingObject\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"baseMass\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"baseScale\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.one\"\n    },\n    {\n      \"name\": \"collisionCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"growthSoundClip\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"splitThreshold\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"massMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.1\n    },\n    {\n      \"name\": \"scaleMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.05\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.white\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_properties\",\n      \"trigger\": \"when object starts\",\n      \"actions\": [\n        {\n          \"action\": \"store original mass as base mass\"\n        },\n        {\n          \"action\": \"store original scale as base scale\"\n        },\n        {\n          \"action\": \"store original material color as original color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_collision\",\n      \"trigger\": \"when object collides with another object\",\n      \"actions\": [\n        {\n          \"action\": \"increment collision count by one\"\n        },\n        {\n          \"action\": \"increase mass by ten percent of current mass\"\n        },\n        {\n          \"action\": \"scale up object by five percent of current scale\"\n        },\n        {\n          \"action\": \"play growth sound effect\"\n        },\n        {\n          \"action\": \"add random color tint to material\"\n        },\n        {\n          \"action\": \"check if collision count reaches split threshold\"\n        }\n      ]\n    },\n    {\n      \"name\": \"split_object\",\n      \"trigger\": \"when collision count reaches ten\",\n      \"actions\": [\n        {\n          \"action\": \"create first child object at slightly offset position\"\n        },\n        {\n          \"action\": \"create second child object at opposite offset position\"\n        },\n        {\n          \"action\": \"set each child mass to half of current accumulated mass\"\n        },\n        {\n          \"action\": \"set each child scale to half of current accumulated scale\"\n        },\n        {\n          \"action\": \"copy current color tint to both child objects\"\n        },\n        {\n          \"action\": \"reset collision count to zero for both children\"\n        },\n        {\n          \"action\": \"destroy original object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_random_tint\",\n      \"trigger\": \"when adding color tint after collision\",\n      \"actions\": [\n        {\n          \"action\": \"generate random color values for red green and blue\"\n        },\n        {\n          \"action\": \"blend random color with current material color\"\n        },\n        {\n          \"action\": \"apply blended color to object material\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class SelfModifyingObject : MonoBehaviour\n{\n    [Header(\"Growth Settings\")]\n    [SerializeField] private float _massIncreasePercent = 0.1f;\n    [SerializeField] private float _scaleIncreasePercent = 0.05f;\n    [SerializeField] private int _splitThreshold = 10;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _growthSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private float _colorIntensity = 0.3f;\n    [SerializeField] private GameObject _splitPrefab;\n    \n    [Header(\"Split Settings\")]\n    [SerializeField] private float _splitForce = 5f;\n    [SerializeField] private float _splitDistance = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Material _instanceMaterial;\n    \n    private int _collisionCount = 0;\n    private float _originalMass;\n    private Vector3 _originalScale;\n    private Color _accumulatedTint = Color.white;\n    private float _totalMassGained = 0f;\n    private Vector3 _totalScaleGained = Vector3.zero;\n    \n    [System.Serializable]\n    public class SplitEvent : UnityEvent<GameObject, GameObject> { }\n    \n    [Header(\"Events\")]\n    public SplitEvent OnSplit = new SplitEvent();\n    public UnityEvent<int> OnCollisionCountChanged = new UnityEvent<int>();\n    \n    private void Start()\n    {\n        InitializeComponents();\n        StoreOriginalValues();\n        CreateInstanceMaterial();\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.volume = _audioVolume;\n        }\n        \n        if (_renderer == null)\n        {\n            Debug.LogWarning(\"No Renderer found on \" + gameObject.name);\n        }\n    }\n    \n    private void StoreOriginalValues()\n    {\n        _originalMass = _rigidbody.mass;\n        _originalScale = transform.localScale;\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n    }\n    \n    private void CreateInstanceMaterial()\n    {\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _instanceMaterial = new Material(_originalMaterial);\n            _renderer.material = _instanceMaterial;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        ProcessCollision();\n    }\n    \n    private void ProcessCollision()\n    {\n        _collisionCount++;\n        \n        IncreaseMass();\n        ScaleUp();\n        AddRandomColorTint();\n        PlayGrowthSound();\n        \n        OnCollisionCountChanged.Invoke(_collisionCount);\n        \n        if (_collisionCount >= _splitThreshold)\n        {\n            StartCoroutine(SplitObject());\n        }\n    }\n    \n    private void IncreaseMass()\n    {\n        float massIncrease = _rigidbody.mass * _massIncreasePercent;\n        _rigidbody.mass += massIncrease;\n        _totalMassGained += massIncrease;\n    }\n    \n    private void ScaleUp()\n    {\n        Vector3 scaleIncrease = transform.localScale * _scaleIncreasePercent;\n        transform.localScale += scaleIncrease;\n        _totalScaleGained += scaleIncrease;\n    }\n    \n    private void AddRandomColorTint()\n    {\n        if (_instanceMaterial == null) return;\n        \n        Color randomTint = new Color(\n            Random.Range(0f, 1f),\n            Random.Range(0f, 1f),\n            Random.Range(0f, 1f),\n            1f\n        );\n        \n        _accumulatedTint = Color.Lerp(_accumulatedTint, randomTint, _colorIntensity);\n        _instanceMaterial.color = _accumulatedTint;\n    }\n    \n    private void PlayGrowthSound()\n    {\n        if (_audioSource != null && _growthSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_growthSound);\n        }\n    }\n    \n    private IEnumerator SplitObject()\n    {\n        yield return new WaitForFixedUpdate();\n        \n        GameObject splitObject1 = CreateSplitObject();\n        GameObject splitObject2 = CreateSplitObject();\n        \n        PositionSplitObjects(splitObject1, splitObject2);\n        ApplySplitForces(splitObject1, splitObject2);\n        \n        OnSplit.Invoke(splitObject1, splitObject2);\n        \n        Destroy(gameObject);\n    }\n    \n    private GameObject CreateSplitObject()\n    {\n        GameObject splitObj;\n        \n        if (_splitPrefab != null)\n        {\n            splitObj = Instantiate(_splitPrefab, transform.position, transform.rotation);\n        }\n        else\n        {\n            splitObj = Instantiate(gameObject);\n        }\n        \n        SelfModifyingObject splitComponent = splitObj.GetComponent<SelfModifyingObject>();\n        if (splitComponent != null)\n        {\n            splitComponent.InitializeAsSplit(this);\n        }\n        \n        return splitObj;\n    }\n    \n    private void PositionSplitObjects(GameObject obj1, GameObject obj2)\n    {\n        Vector3 randomDirection = Random.onUnitSphere;\n        randomDirection.y = Mathf.Abs(randomDirection.y);\n        \n        obj1.transform.position = transform.position + randomDirection * _splitDistance;\n        obj2.transform.position = transform.position - randomDirection * _splitDistance;\n    }\n    \n    private void ApplySplitForces(GameObject obj1, GameObject obj2)\n    {\n        Rigidbody rb1 = obj1.GetComponent<Rigidbody>();\n        Rigidbody rb2 = obj2.GetComponent<Rigidbody>();\n        \n        if (rb1 != null && rb2 != null)\n        {\n            Vector3 force1 = (obj1.transform.position - transform.position).normalized * _splitForce;\n            Vector3 force2 = (obj2.transform.position - transform.position).normalized * _splitForce;\n            \n            rb1.AddForce(force1, ForceMode.Impulse);\n            rb2.AddForce(force2, ForceMode.Impulse);\n        }\n    }\n    \n    public void InitializeAsSplit(SelfModifyingObject parent)\n    {\n        _collisionCount = 0;\n        \n        float halfMass = parent._originalMass + (parent._totalMassGained * 0.5f);\n        Vector3 halfScale = parent._originalScale + (parent._totalScaleGained * 0.5f);\n        Color halfTint = Color.Lerp(Color.white, parent._accumulatedTint, 0.5f);\n        \n        _rigidbody.mass = halfMass;\n        transform.localScale = halfScale;\n        \n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.color = halfTint;\n            _accumulatedTint = halfTint;\n        }\n        \n        _totalMassGained = halfMass - _originalMass;\n        _totalScaleGained = halfScale - _originalScale;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_instanceMaterial != null)\n        {\n            DestroyImmediate(_instanceMaterial);\n        }\n    }\n    \n    public int GetCollisionCount()\n    {\n        return _collisionCount;\n    }\n    \n    public float GetCurrentMass()\n    {\n        return _rigidbody != null ? _rigidbody.mass : 0f;\n    }\n    \n    public Vector3 GetCurrentScale()\n    {\n        return transform.localScale;\n    }\n    \n    public Color GetCurrentTint()\n    {\n        return _accumulatedTint;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"KillDeathScoreTracker\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"kills\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"deaths\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"score\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"killPoints\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"deathPenalty\",\n      \"type\": \"int\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"record_kill\",\n      \"trigger\": \"when this player kills another player\",\n      \"actions\": [\n        {\n          \"action\": \"increase kill count by one\"\n        },\n        {\n          \"action\": \"add kill points to total score\"\n        },\n        {\n          \"action\": \"display kill notification on screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"record_death\",\n      \"trigger\": \"when this player dies\",\n      \"actions\": [\n        {\n          \"action\": \"increase death count by one\"\n        },\n        {\n          \"action\": \"subtract death penalty from total score\"\n        },\n        {\n          \"action\": \"display death notification on screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_kd_ratio\",\n      \"trigger\": \"when stats are requested\",\n      \"actions\": [\n        {\n          \"action\": \"calculate kill to death ratio\"\n        },\n        {\n          \"action\": \"return ratio value avoiding division by zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_stats\",\n      \"trigger\": \"when reset command is received\",\n      \"actions\": [\n        {\n          \"action\": \"set kills back to zero\"\n        },\n        {\n          \"action\": \"set deaths back to zero\"\n        },\n        {\n          \"action\": \"set score back to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"display_current_stats\",\n      \"trigger\": \"when UI update is needed\",\n      \"actions\": [\n        {\n          \"action\": \"show current kill count on interface\"\n        },\n        {\n          \"action\": \"show current death count on interface\"\n        },\n        {\n          \"action\": \"show current score on interface\"\n        },\n        {\n          \"action\": \"show kill death ratio on interface\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class ScoreTracker : MonoBehaviour\n{\n    [Header(\"Score Settings\")]\n    [SerializeField] private int _killScore = 100;\n    [SerializeField] private int _deathPenalty = 50;\n    [SerializeField] private bool _allowNegativeScore = false;\n    \n    [Header(\"Score Display\")]\n    [SerializeField] private UnityEngine.UI.Text _scoreText;\n    [SerializeField] private UnityEngine.UI.Text _killsText;\n    [SerializeField] private UnityEngine.UI.Text _deathsText;\n    [SerializeField] private string _scorePrefix = \"Score: \";\n    [SerializeField] private string _killsPrefix = \"Kills: \";\n    [SerializeField] private string _deathsPrefix = \"Deaths: \";\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnScoreChanged;\n    public UnityEvent<int> OnKillCountChanged;\n    public UnityEvent<int> OnDeathCountChanged;\n    public UnityEvent<PlayerStats> OnStatsUpdated;\n    \n    [Header(\"Persistence\")]\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _scoreKey = \"PlayerScore\";\n    [SerializeField] private string _killsKey = \"PlayerKills\";\n    [SerializeField] private string _deathsKey = \"PlayerDeaths\";\n    \n    private int _currentScore;\n    private int _totalKills;\n    private int _totalDeaths;\n    private Dictionary<string, int> _killsByType = new Dictionary<string, int>();\n    \n    public int CurrentScore => _currentScore;\n    public int TotalKills => _totalKills;\n    public int TotalDeaths => _totalDeaths;\n    public float KillDeathRatio => _totalDeaths > 0 ? (float)_totalKills / _totalDeaths : _totalKills;\n    \n    [System.Serializable]\n    public class PlayerStats\n    {\n        public int score;\n        public int kills;\n        public int deaths;\n        public float killDeathRatio;\n        \n        public PlayerStats(int score, int kills, int deaths, float kdr)\n        {\n            this.score = score;\n            this.kills = kills;\n            this.deaths = deaths;\n            this.killDeathRatio = kdr;\n        }\n    }\n    \n    private void Start()\n    {\n        LoadStats();\n        UpdateUI();\n    }\n    \n    private void OnEnable()\n    {\n        FindAndSubscribeToHealthComponents();\n    }\n    \n    private void OnDisable()\n    {\n        UnsubscribeFromHealthComponents();\n    }\n    \n    private void FindAndSubscribeToHealthComponents()\n    {\n        HealthComponent[] healthComponents = FindObjectsOfType<HealthComponent>();\n        foreach (var health in healthComponents)\n        {\n            health.OnDeath.AddListener(OnEntityDeath);\n        }\n    }\n    \n    private void UnsubscribeFromHealthComponents()\n    {\n        HealthComponent[] healthComponents = FindObjectsOfType<HealthComponent>();\n        foreach (var health in healthComponents)\n        {\n            if (health != null)\n                health.OnDeath.RemoveListener(OnEntityDeath);\n        }\n    }\n    \n    public void RegisterKill(string killedEntityTag = \"Enemy\", string killerTag = \"Player\")\n    {\n        if (killerTag == \"Player\")\n        {\n            _totalKills++;\n            _currentScore += _killScore;\n            \n            if (!_killsByType.ContainsKey(killedEntityTag))\n                _killsByType[killedEntityTag] = 0;\n            _killsByType[killedEntityTag]++;\n            \n            OnKillCountChanged?.Invoke(_totalKills);\n            OnScoreChanged?.Invoke(_currentScore);\n            \n            UpdateUI();\n            SaveStats();\n            \n            OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n        }\n    }\n    \n    public void RegisterDeath(string deadEntityTag = \"Player\")\n    {\n        if (deadEntityTag == \"Player\")\n        {\n            _totalDeaths++;\n            _currentScore -= _deathPenalty;\n            \n            if (!_allowNegativeScore && _currentScore < 0)\n                _currentScore = 0;\n            \n            OnDeathCountChanged?.Invoke(_totalDeaths);\n            OnScoreChanged?.Invoke(_currentScore);\n            \n            UpdateUI();\n            SaveStats();\n            \n            OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n        }\n    }\n    \n    private void OnEntityDeath(GameObject deadEntity, GameObject killer)\n    {\n        if (killer != null && killer.CompareTag(\"Player\") && !deadEntity.CompareTag(\"Player\"))\n        {\n            RegisterKill(deadEntity.tag, killer.tag);\n        }\n        else if (deadEntity.CompareTag(\"Player\"))\n        {\n            RegisterDeath(deadEntity.tag);\n        }\n    }\n    \n    public void AddScore(int points)\n    {\n        _currentScore += points;\n        if (!_allowNegativeScore && _currentScore < 0)\n            _currentScore = 0;\n        \n        OnScoreChanged?.Invoke(_currentScore);\n        UpdateUI();\n        SaveStats();\n    }\n    \n    public void ResetStats()\n    {\n        _currentScore = 0;\n        _totalKills = 0;\n        _totalDeaths = 0;\n        _killsByType.Clear();\n        \n        OnScoreChanged?.Invoke(_currentScore);\n        OnKillCountChanged?.Invoke(_totalKills);\n        OnDeathCountChanged?.Invoke(_totalDeaths);\n        \n        UpdateUI();\n        SaveStats();\n        \n        OnStatsUpdated?.Invoke(new PlayerStats(_currentScore, _totalKills, _totalDeaths, KillDeathRatio));\n    }\n    \n    public int GetKillsByType(string entityType)\n    {\n        return _killsByType.ContainsKey(entityType) ? _killsByType[entityType] : 0;\n    }\n    \n    private void UpdateUI()\n    {\n        if (_scoreText != null)\n            _scoreText.text = _scorePrefix + _currentScore.ToString();\n        \n        if (_killsText != null)\n            _killsText.text = _killsPrefix + _totalKills.ToString();\n        \n        if (_deathsText != null)\n            _deathsText.text = _deathsPrefix + _totalDeaths.ToString();\n    }\n    \n    private void SaveStats()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        PlayerPrefs.SetInt(_scoreKey, _currentScore);\n        PlayerPrefs.SetInt(_killsKey, _totalKills);\n        PlayerPrefs.SetInt(_deathsKey, _totalDeaths);\n        \n        foreach (var kvp in _killsByType)\n        {\n            PlayerPrefs.SetInt(\"Kills_\" + kvp.Key, kvp.Value);\n        }\n        \n        PlayerPrefs.Save();\n    }\n    \n    private void LoadStats()\n    {\n        if (!_saveToPlayerPrefs) return;\n        \n        _currentScore = PlayerPrefs.GetInt(_scoreKey, 0);\n        _totalKills = PlayerPrefs.GetInt(_killsKey, 0);\n        _totalDeaths = PlayerPrefs.GetInt(_deathsKey, 0);\n        \n        string[] enemyTypes = { \"Enemy\", \"Boss\", \"Minion\", \"Elite\" };\n        foreach (string type in enemyTypes)\n        {\n            int kills = PlayerPrefs.GetInt(\"Kills_\" + type, 0);\n            if (kills > 0)\n                _killsByType[type] = kills;\n        }\n    }\n}\n\n[System.Serializable]\npublic class HealthComponent : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private int _currentHealth;\n    [SerializeField] private bool _destroyOnDeath = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnHealthChanged;\n    public UnityEvent<GameObject, GameObject> OnDeath;\n    public UnityEvent<int> OnDamageTaken;\n    \n    public int MaxHealth => _maxHealth;\n    public int CurrentHealth => _currentHealth;\n    public bool IsDead => _currentHealth <= 0;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public void TakeDamage(int damage, GameObject attacker = null)\n    {\n        if (IsDead) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        OnDamageTaken?.Invoke(damage);\n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0)\n        {\n            Die(attacker);\n        }\n    }\n    \n    public void Heal(int amount)\n    {\n        if (IsDead) return;\n        \n        _currentHealth += amount;\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Die(GameObject killer)\n    {\n        OnDeath?.Invoke(gameObject, killer);\n        \n        if (_destroyOnDeath)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Damage\"))\n        {\n            DamageDealer dealer = other.GetComponent<DamageDealer>();\n            if (dealer != null)\n            {\n                TakeDamage(dealer.Damage, dealer.Owner);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class DamageDealer : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 10;\n    [SerializeField] private GameObject _owner;\n    [SerializeField] private bool _destroyOnHit = true;\n    \n    public int Damage => _damage;\n    public GameObject Owner => _owner;\n    \n    public void SetOwner(GameObject owner)\n    {\n        _owner = owner;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HealthComponent health = other.GetComponent<HealthComponent>();\n        if (health != null && other.gameObject != _owner)\n        {\n            health.TakeDamage(_damage, _owner);\n            \n            if (_destroyOnHit)\n            {\n                Destroy(gameObject);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PitfallTrap\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isTriggered\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"resetTime\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_trap\",\n      \"trigger\": \"when player steps on trap surface\",\n      \"actions\": [\n        {\n          \"action\": \"mark trap as triggered\"\n        },\n        {\n          \"action\": \"play trap activation sound\"\n        },\n        {\n          \"action\": \"make trap surface disappear or become transparent\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_falls\",\n      \"trigger\": \"when trap is triggered and player is above pit\",\n      \"actions\": [\n        {\n          \"action\": \"make player fall downward at fall speed\"\n        },\n        {\n          \"action\": \"disable player movement controls\"\n        },\n        {\n          \"action\": \"play falling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spike_damage\",\n      \"trigger\": \"when player reaches bottom of pit\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player equal to damage amount\"\n        },\n        {\n          \"action\": \"play spike impact sound\"\n        },\n        {\n          \"action\": \"show damage visual effects\"\n        },\n        {\n          \"action\": \"make spikes briefly glow or animate\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_trap\",\n      \"trigger\": \"when reset time has elapsed after triggering\",\n      \"actions\": [\n        {\n          \"action\": \"mark trap as not triggered\"\n        },\n        {\n          \"action\": \"restore trap surface visibility\"\n        },\n        {\n          \"action\": \"reset player position to safe location\"\n        },\n        {\n          \"action\": \"restore player movement controls\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PitfallTrap : MonoBehaviour\n{\n    [Header(\"Trap Settings\")]\n    [SerializeField] private float _fallDepth = 5f;\n    [SerializeField] private float _fallSpeed = 10f;\n    [SerializeField] private float _resetDelay = 3f;\n    [SerializeField] private bool _resetAfterFall = true;\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    \n    [Header(\"Spike Settings\")]\n    [SerializeField] private GameObject[] _spikes;\n    [SerializeField] private float _spikeRiseSpeed = 8f;\n    [SerializeField] private float _spikeRiseDelay = 0.5f;\n    [SerializeField] private int _spikeDamage = 50;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fallSound;\n    [SerializeField] private AudioClip _spikeSound;\n    [SerializeField] private AudioClip _resetSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private ParticleSystem _bloodEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTrapTriggered;\n    public UnityEvent OnPlayerDamaged;\n    public UnityEvent OnTrapReset;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _targetPosition;\n    private bool _isTriggered = false;\n    private bool _isResetting = false;\n    private bool _spikesRaised = false;\n    private Vector3[] _originalSpikePositions;\n    private Vector3[] _targetSpikePositions;\n    private Collider _trapCollider;\n    private Rigidbody _trapRigidbody;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _targetPosition = _originalPosition + Vector3.down * _fallDepth;\n        _trapCollider = GetComponent<Collider>();\n        _trapRigidbody = GetComponent<Rigidbody>();\n        \n        if (_trapRigidbody != null)\n        {\n            _trapRigidbody.isKinematic = true;\n        }\n        \n        InitializeSpikes();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void InitializeSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) return;\n        \n        _originalSpikePositions = new Vector3[_spikes.Length];\n        _targetSpikePositions = new Vector3[_spikes.Length];\n        \n        for (int i = 0; i < _spikes.Length; i++)\n        {\n            if (_spikes[i] != null)\n            {\n                _originalSpikePositions[i] = _spikes[i].transform.localPosition;\n                _targetSpikePositions[i] = _originalSpikePositions[i] + Vector3.up * 2f;\n                \n                // Hide spikes initially\n                _spikes[i].transform.localPosition = _originalSpikePositions[i] - Vector3.up * 1f;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isTriggered || _isResetting) return;\n        \n        if (IsValidTarget(other))\n        {\n            TriggerTrap(other);\n        }\n    }\n    \n    private bool IsValidTarget(Collider other)\n    {\n        return (_triggerLayers.value & (1 << other.gameObject.layer)) > 0;\n    }\n    \n    private void TriggerTrap(Collider target)\n    {\n        _isTriggered = true;\n        OnTrapTriggered?.Invoke();\n        \n        PlaySound(_fallSound);\n        PlayEffect(_dustEffect);\n        \n        StartCoroutine(FallSequence(target));\n    }\n    \n    private System.Collections.IEnumerator FallSequence(Collider target)\n    {\n        // Fall animation\n        float fallTime = 0f;\n        float fallDuration = _fallDepth / _fallSpeed;\n        \n        while (fallTime < fallDuration)\n        {\n            fallTime += Time.deltaTime;\n            float progress = fallTime / fallDuration;\n            transform.position = Vector3.Lerp(_originalPosition, _targetPosition, progress);\n            yield return null;\n        }\n        \n        transform.position = _targetPosition;\n        \n        // Wait before raising spikes\n        yield return new WaitForSeconds(_spikeRiseDelay);\n        \n        // Raise spikes\n        yield return StartCoroutine(RaiseSpikes());\n        \n        // Check for damage\n        CheckForDamage(target);\n        \n        // Reset if enabled\n        if (_resetAfterFall)\n        {\n            yield return new WaitForSeconds(_resetDelay);\n            yield return StartCoroutine(ResetTrap());\n        }\n    }\n    \n    private System.Collections.IEnumerator RaiseSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) yield break;\n        \n        PlaySound(_spikeSound);\n        _spikesRaised = true;\n        \n        float riseTime = 0f;\n        float riseDuration = 2f / _spikeRiseSpeed;\n        \n        while (riseTime < riseDuration)\n        {\n            riseTime += Time.deltaTime;\n            float progress = riseTime / riseDuration;\n            \n            for (int i = 0; i < _spikes.Length; i++)\n            {\n                if (_spikes[i] != null)\n                {\n                    Vector3 startPos = _originalSpikePositions[i] - Vector3.up * 1f;\n                    _spikes[i].transform.localPosition = Vector3.Lerp(startPos, _targetSpikePositions[i], progress);\n                }\n            }\n            \n            yield return null;\n        }\n        \n        // Ensure final positions\n        for (int i = 0; i < _spikes.Length; i++)\n        {\n            if (_spikes[i] != null)\n            {\n                _spikes[i].transform.localPosition = _targetSpikePositions[i];\n            }\n        }\n    }\n    \n    private void CheckForDamage(Collider target)\n    {\n        if (target == null) return;\n        \n        // Check if target is still in trap area\n        Bounds trapBounds = _trapCollider.bounds;\n        if (trapBounds.Contains(target.transform.position))\n        {\n            DamageTarget(target);\n        }\n    }\n    \n    private void DamageTarget(Collider target)\n    {\n        // Try to find a component that can take damage\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage for generic damage handling\n            target.SendMessage(\"TakeDamage\", _spikeDamage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"OnDamaged\", _spikeDamage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Apply physics damage if rigidbody exists\n        var targetRigidbody = target.GetComponent<Rigidbody>();\n        if (targetRigidbody != null)\n        {\n            targetRigidbody.AddForce(Vector3.down * 500f, ForceMode.Impulse);\n        }\n        \n        PlayEffect(_bloodEffect);\n        OnPlayerDamaged?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator ResetTrap()\n    {\n        _isResetting = true;\n        PlaySound(_resetSound);\n        \n        // Lower spikes first\n        if (_spikesRaised)\n        {\n            yield return StartCoroutine(LowerSpikes());\n        }\n        \n        // Raise platform\n        float resetTime = 0f;\n        float resetDuration = _fallDepth / _fallSpeed;\n        \n        while (resetTime < resetDuration)\n        {\n            resetTime += Time.deltaTime;\n            float progress = resetTime / resetDuration;\n            transform.position = Vector3.Lerp(_targetPosition, _originalPosition, progress);\n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n        \n        _isTriggered = false;\n        _isResetting = false;\n        _spikesRaised = false;\n        \n        OnTrapReset?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator LowerSpikes()\n    {\n        if (_spikes == null || _spikes.Length == 0) yield break;\n        \n        float lowerTime = 0f;\n        float lowerDuration = 2f / _spikeRiseSpeed;\n        \n        while (lowerTime < lowerDuration)\n        {\n            lowerTime += Time.deltaTime;\n            float progress = lowerTime / lowerDuration;\n            \n            for (int i = 0; i < _spikes.Length; i++)\n            {\n                if (_spikes[i] != null)\n                {\n                    Vector3 endPos = _originalSpikePositions[i] - Vector3.up * 1f;\n                    _spikes[i].transform.localPosition = Vector3.Lerp(_targetSpikePositions[i], endPos, progress);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    public void ManualTrigger()\n    {\n        if (!_isTriggered && !_isResetting)\n        {\n            TriggerTrap(null);\n        }\n    }\n    \n    public void ManualReset()\n    {\n        if (_isTriggered && !_isResetting)\n        {\n            StartCoroutine(ResetTrap());\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 fallPosition = transform.position + Vector3.down * _fallDepth;\n        Gizmos.DrawWireCube(fallPosition, transform.localScale);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(transform.position, fallPosition);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Car\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"accelerationForce\",\n      \"type\": \"float\",\n      \"default\": 1500\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"steeringAngle\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"brakeForce\",\n      \"type\": \"float\",\n      \"default\": 3000\n    },\n    {\n      \"name\": \"currentSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate_forward\",\n      \"trigger\": \"when forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply forward force based on acceleration force\"\n        },\n        {\n          \"action\": \"limit speed to maximum speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"accelerate_backward\",\n      \"trigger\": \"when backward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply backward force based on acceleration force\"\n        },\n        {\n          \"action\": \"limit reverse speed to half of maximum speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_left\",\n      \"trigger\": \"when left input is pressed and car is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate car left based on steering angle and current speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_right\",\n      \"trigger\": \"when right input is pressed and car is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate car right based on steering angle and current speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_brakes\",\n      \"trigger\": \"when brake input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply brake force to reduce current speed\"\n        },\n        {\n          \"action\": \"gradually stop the car\"\n        }\n      ]\n    },\n    {\n      \"name\": \"natural_deceleration\",\n      \"trigger\": \"when no input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce speed due to friction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CarController : MonoBehaviour\n{\n    [Header(\"Car Settings\")]\n    [SerializeField] private float _motorForce = 1500f;\n    [SerializeField] private float _brakeForce = 3000f;\n    [SerializeField] private float _maxSteerAngle = 30f;\n    [SerializeField] private float _downForce = 100f;\n    \n    [Header(\"Wheel Colliders\")]\n    [SerializeField] private WheelCollider _frontLeftWheelCollider;\n    [SerializeField] private WheelCollider _frontRightWheelCollider;\n    [SerializeField] private WheelCollider _rearLeftWheelCollider;\n    [SerializeField] private WheelCollider _rearRightWheelCollider;\n    \n    [Header(\"Wheel Transforms\")]\n    [SerializeField] private Transform _frontLeftWheelTransform;\n    [SerializeField] private Transform _frontRightWheelTransform;\n    [SerializeField] private Transform _rearLeftWheelTransform;\n    [SerializeField] private Transform _rearRightWheelTransform;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private string _horizontalInputAxis = \"Horizontal\";\n    [SerializeField] private string _verticalInputAxis = \"Vertical\";\n    [SerializeField] private KeyCode _brakeKey = KeyCode.Space;\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _steerAngle;\n    private bool _isBreaking;\n    private Rigidbody _carRigidbody;\n    \n    private void Start()\n    {\n        _carRigidbody = GetComponent<Rigidbody>();\n        if (_carRigidbody == null)\n        {\n            _carRigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _carRigidbody.centerOfMass = new Vector3(0, -0.5f, 0.5f);\n    }\n    \n    private void Update()\n    {\n        GetInput();\n        HandleMotor();\n        HandleSteering();\n        UpdateWheels();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyDownForce();\n    }\n    \n    private void GetInput()\n    {\n        _horizontalInput = Input.GetAxis(_horizontalInputAxis);\n        _verticalInput = Input.GetAxis(_verticalInputAxis);\n        _isBreaking = Input.GetKey(_brakeKey);\n    }\n    \n    private void HandleMotor()\n    {\n        if (_frontLeftWheelCollider == null || _frontRightWheelCollider == null) return;\n        \n        _frontLeftWheelCollider.motorTorque = _verticalInput * _motorForce;\n        _frontRightWheelCollider.motorTorque = _verticalInput * _motorForce;\n        \n        float currentBrakeForce = _isBreaking ? _brakeForce : 0f;\n        ApplyBreaking(currentBrakeForce);\n    }\n    \n    private void ApplyBreaking(float brakeForce)\n    {\n        if (_frontRightWheelCollider != null)\n            _frontRightWheelCollider.brakeTorque = brakeForce;\n        if (_frontLeftWheelCollider != null)\n            _frontLeftWheelCollider.brakeTorque = brakeForce;\n        if (_rearLeftWheelCollider != null)\n            _rearLeftWheelCollider.brakeTorque = brakeForce;\n        if (_rearRightWheelCollider != null)\n            _rearRightWheelCollider.brakeTorque = brakeForce;\n    }\n    \n    private void HandleSteering()\n    {\n        _steerAngle = _maxSteerAngle * _horizontalInput;\n        \n        if (_frontLeftWheelCollider != null)\n            _frontLeftWheelCollider.steerAngle = _steerAngle;\n        if (_frontRightWheelCollider != null)\n            _frontRightWheelCollider.steerAngle = _steerAngle;\n    }\n    \n    private void UpdateWheels()\n    {\n        UpdateSingleWheel(_frontLeftWheelCollider, _frontLeftWheelTransform);\n        UpdateSingleWheel(_frontRightWheelCollider, _frontRightWheelTransform);\n        UpdateSingleWheel(_rearRightWheelCollider, _rearRightWheelTransform);\n        UpdateSingleWheel(_rearLeftWheelCollider, _rearLeftWheelTransform);\n    }\n    \n    private void UpdateSingleWheel(WheelCollider wheelCollider, Transform wheelTransform)\n    {\n        if (wheelCollider == null || wheelTransform == null) return;\n        \n        Vector3 pos;\n        Quaternion rot;\n        wheelCollider.GetWorldPose(out pos, out rot);\n        wheelTransform.rotation = rot;\n        wheelTransform.position = pos;\n    }\n    \n    private void ApplyDownForce()\n    {\n        if (_carRigidbody != null)\n        {\n            _carRigidbody.AddForce(-transform.up * _downForce * _carRigidbody.velocity.magnitude);\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _carRigidbody != null ? _carRigidbody.velocity.magnitude * 3.6f : 0f;\n    }\n    \n    public bool IsGrounded()\n    {\n        return (_frontLeftWheelCollider != null && _frontLeftWheelCollider.isGrounded) ||\n               (_frontRightWheelCollider != null && _frontRightWheelCollider.isGrounded) ||\n               (_rearLeftWheelCollider != null && _rearLeftWheelCollider.isGrounded) ||\n               (_rearRightWheelCollider != null && _rearRightWheelCollider.isGrounded);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Flamethrower\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\",\n    \"LineRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"fuelCapacity\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentFuel\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fuelConsumptionRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isFiring\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"fireButton\",\n      \"type\": \"string\",\n      \"default\": \"Fire1\"\n    },\n    {\n      \"name\": \"flameParticles\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"smokeParticles\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"fireSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"igniteSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_firing\",\n      \"trigger\": \"when fire button is pressed and fuel is available\",\n      \"actions\": [\n        {\n          \"action\": \"set firing state to true\"\n        },\n        {\n          \"action\": \"start flame particle emission\"\n        },\n        {\n          \"action\": \"start smoke particle emission\"\n        },\n        {\n          \"action\": \"play ignite sound effect\"\n        },\n        {\n          \"action\": \"begin continuous fire sound loop\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_firing\",\n      \"trigger\": \"while fire button is held and fuel remains\",\n      \"actions\": [\n        {\n          \"action\": \"continue flame particle emission\"\n        },\n        {\n          \"action\": \"reduce current fuel by consumption rate\"\n        },\n        {\n          \"action\": \"cast ray forward to detect targets within range\"\n        },\n        {\n          \"action\": \"apply damage to any flammable objects hit\"\n        },\n        {\n          \"action\": \"create heat distortion effect along flame path\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_firing\",\n      \"trigger\": \"when fire button is released or fuel is depleted\",\n      \"actions\": [\n        {\n          \"action\": \"set firing state to false\"\n        },\n        {\n          \"action\": \"stop flame particle emission\"\n        },\n        {\n          \"action\": \"gradually reduce smoke particle emission\"\n        },\n        {\n          \"action\": \"stop fire sound loop\"\n        },\n        {\n          \"action\": \"clear heat distortion effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fuel_warning\",\n      \"trigger\": \"when fuel drops below twenty percent\",\n      \"actions\": [\n        {\n          \"action\": \"reduce flame particle intensity\"\n        },\n        {\n          \"action\": \"create flickering flame effect\"\n        },\n        {\n          \"action\": \"play low fuel warning sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_fuel\",\n      \"trigger\": \"when reload button is pressed and not currently firing\",\n      \"actions\": [\n        {\n          \"action\": \"restore fuel to maximum capacity\"\n        },\n        {\n          \"action\": \"play fuel reload sound effect\"\n        },\n        {\n          \"action\": \"reset flame particle intensity to full\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Flamethrower : MonoBehaviour\n{\n    [Header(\"Flame Settings\")]\n    [SerializeField] private float _maxRange = 10f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageRate = 0.1f;\n    [SerializeField] private float _fuelConsumption = 10f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _currentFuel = 100f;\n    [SerializeField] private float _refuelRate = 20f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private ParticleSystem _sparkParticles;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _igniteSound;\n    [SerializeField] private AudioClip _flameLoopSound;\n    [SerializeField] private AudioClip _extinguishSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _flameLight;\n    [SerializeField] private float _lightIntensity = 2f;\n    [SerializeField] private Color _flameColor = Color.red;\n    [SerializeField] private AnimationCurve _lightFlicker = AnimationCurve.Linear(0, 0.8f, 1, 1.2f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _refuelKey = KeyCode.R;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnIgnite;\n    public UnityEvent OnExtinguish;\n    public UnityEvent OnFuelEmpty;\n    public UnityEvent<float> OnFuelChanged;\n    \n    private bool _isFiring;\n    private float _damageTimer;\n    private float _lightFlickerTime;\n    private System.Collections.Generic.HashSet<Collider> _targetsInRange = new System.Collections.Generic.HashSet<Collider>();\n    private ParticleSystem.MainModule _flameMain;\n    private ParticleSystem.MainModule _smokeMain;\n    private ParticleSystem.MainModule _sparkMain;\n    private float _originalLightIntensity;\n    \n    private void Start()\n    {\n        _currentFuel = _maxFuel;\n        \n        if (_flameParticles != null)\n        {\n            _flameMain = _flameParticles.main;\n            _flameParticles.Stop();\n        }\n        \n        if (_smokeParticles != null)\n        {\n            _smokeMain = _smokeParticles.main;\n            _smokeParticles.Stop();\n        }\n        \n        if (_sparkParticles != null)\n        {\n            _sparkMain = _sparkParticles.main;\n            _sparkParticles.Stop();\n        }\n        \n        if (_flameLight != null)\n        {\n            _originalLightIntensity = _flameLight.intensity;\n            _flameLight.intensity = 0f;\n            _flameLight.color = _flameColor;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateFlamethrower();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        bool shouldFire = Input.GetKey(_fireKey) && _currentFuel > 0f;\n        \n        if (shouldFire && !_isFiring)\n        {\n            StartFiring();\n        }\n        else if (!shouldFire && _isFiring)\n        {\n            StopFiring();\n        }\n        \n        if (Input.GetKeyDown(_refuelKey))\n        {\n            Refuel();\n        }\n    }\n    \n    private void UpdateFlamethrower()\n    {\n        if (_isFiring)\n        {\n            ConsumeFuel();\n            DealDamage();\n            DetectTargets();\n        }\n        \n        _lightFlickerTime += Time.deltaTime * 5f;\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_flameLight != null)\n        {\n            if (_isFiring)\n            {\n                float flickerValue = _lightFlicker.Evaluate(Mathf.PingPong(_lightFlickerTime, 1f));\n                _flameLight.intensity = _lightIntensity * flickerValue;\n            }\n            else\n            {\n                _flameLight.intensity = Mathf.Lerp(_flameLight.intensity, 0f, Time.deltaTime * 5f);\n            }\n        }\n    }\n    \n    private void StartFiring()\n    {\n        _isFiring = true;\n        \n        if (_flameParticles != null)\n            _flameParticles.Play();\n        \n        if (_smokeParticles != null)\n            _smokeParticles.Play();\n        \n        if (_sparkParticles != null)\n            _sparkParticles.Play();\n        \n        PlaySound(_igniteSound);\n        \n        if (_flameLoopSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _flameLoopSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        OnIgnite?.Invoke();\n    }\n    \n    private void StopFiring()\n    {\n        _isFiring = false;\n        \n        if (_flameParticles != null)\n            _flameParticles.Stop();\n        \n        if (_smokeParticles != null)\n            _smokeParticles.Stop();\n        \n        if (_sparkParticles != null)\n            _sparkParticles.Stop();\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n        \n        PlaySound(_extinguishSound);\n        \n        _targetsInRange.Clear();\n        OnExtinguish?.Invoke();\n    }\n    \n    private void ConsumeFuel()\n    {\n        _currentFuel -= _fuelConsumption * Time.deltaTime;\n        _currentFuel = Mathf.Max(0f, _currentFuel);\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n        \n        if (_currentFuel <= 0f)\n        {\n            StopFiring();\n            OnFuelEmpty?.Invoke();\n        }\n    }\n    \n    private void DetectTargets()\n    {\n        _targetsInRange.Clear();\n        \n        RaycastHit[] hits = Physics.SphereCastAll(\n            transform.position,\n            1f,\n            transform.forward,\n            _maxRange,\n            _targetLayers\n        );\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider != null && hit.collider.gameObject != gameObject)\n            {\n                _targetsInRange.Add(hit.collider);\n            }\n        }\n    }\n    \n    private void DealDamage()\n    {\n        _damageTimer += Time.deltaTime;\n        \n        if (_damageTimer >= _damageRate)\n        {\n            _damageTimer = 0f;\n            \n            foreach (Collider target in _targetsInRange)\n            {\n                if (target == null) continue;\n                \n                // Apply damage to objects with health components\n                var healthComponent = target.GetComponent<Health>();\n                if (healthComponent != null)\n                {\n                    healthComponent.TakeDamage(_damage);\n                }\n                \n                // Apply fire effect to burnable objects\n                var burnableComponent = target.GetComponent<Burnable>();\n                if (burnableComponent != null)\n                {\n                    burnableComponent.Ignite();\n                }\n                \n                // Push rigidbodies away\n                var rb = target.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 pushDirection = (target.transform.position - transform.position).normalized;\n                    rb.AddForce(pushDirection * 5f, ForceMode.Impulse);\n                }\n            }\n        }\n    }\n    \n    private void Refuel()\n    {\n        _currentFuel = _maxFuel;\n        OnFuelChanged?.Invoke(1f);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetFuel(float amount)\n    {\n        _currentFuel = Mathf.Clamp(amount, 0f, _maxFuel);\n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return _currentFuel / _maxFuel;\n    }\n    \n    public bool IsFiring()\n    {\n        return _isFiring;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position + transform.forward * _maxRange, 1f);\n        Gizmos.DrawRay(transform.position, transform.forward * _maxRange);\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0f, _currentHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n}\n\n[System.Serializable]\npublic class Burnable : MonoBehaviour\n{\n    [SerializeField] private float _burnDuration = 5f;\n    [SerializeField] private float _burnDamage = 10f;\n    [SerializeField] private ParticleSystem _fireEffect;\n    \n    public UnityEvent OnIgnited;\n    public UnityEvent OnExtinguished;\n    \n    private bool _isBurning;\n    private float _burnTimer;\n    private Health _health;\n    \n    private void Start()\n    {\n        _health = GetComponent<Health>();\n    }\n    \n    private void Update()\n    {\n        if (_isBurning)\n        {\n            _burnTimer -= Time.deltaTime;\n            \n            if (_health != null)\n            {\n                _health.TakeDamage(_burnDamage * Time.deltaTime);\n            }\n            \n            if (_burnTimer <= 0f)\n            {\n                Extinguish();\n            }\n        }\n    }\n    \n    public void Ignite()\n    {\n        if (!_isBurning)\n        {\n            _isBurning = true;\n            _burnTimer = _burnDuration;\n            \n            if (_fireEffect != null)\n                _fireEffect.Play();\n            \n            OnIgnited?.Invoke();\n        }\n        else\n        {\n            _burnTimer = _burnDuration; // Reset burn timer\n        }\n    }\n    \n    public void Extinguish()\n    {\n        if (_isBurning)\n        {\n            _isBurning = false;\n            \n            if (_fireEffect != null)\n                _fireEffect.Stop();\n            \n            OnExtinguished?.Invoke();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StunMace\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"stunDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"stunChance\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"swingForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"isSwinging\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"swing_mace\",\n      \"trigger\": \"when player presses attack button\",\n      \"actions\": [\n        {\n          \"action\": \"play swing sound effect\"\n        },\n        {\n          \"action\": \"apply forward force to mace\"\n        },\n        {\n          \"action\": \"set swinging state to true\"\n        },\n        {\n          \"action\": \"start swing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hit_target\",\n      \"trigger\": \"when mace collides with enemy during swing\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to enemy\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"create impact particle effect\"\n        },\n        {\n          \"action\": \"check if stun effect should trigger based on chance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_stun\",\n      \"trigger\": \"when stun effect is triggered on enemy hit\",\n      \"actions\": [\n        {\n          \"action\": \"disable enemy movement for stun duration\"\n        },\n        {\n          \"action\": \"disable enemy attacks for stun duration\"\n        },\n        {\n          \"action\": \"play stun visual effect on enemy\"\n        },\n        {\n          \"action\": \"play stun sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_swing\",\n      \"trigger\": \"when swing animation completes\",\n      \"actions\": [\n        {\n          \"action\": \"set swinging state to false\"\n        },\n        {\n          \"action\": \"reset mace position to ready stance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class Mace : MonoBehaviour\n{\n    [Header(\"Mace Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Stun Effect\")]\n    [SerializeField] private float _stunDuration = 2f;\n    [SerializeField] private float _stunChance = 0.3f;\n    [SerializeField] private GameObject _stunEffectPrefab;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _stunSound;\n    [SerializeField] private Transform _attackPoint;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _attackTrigger = \"Attack\";\n    \n    private AudioSource _audioSource;\n    private bool _canAttack = true;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class StunnedTarget\n    {\n        public GameObject target;\n        public float stunEndTime;\n        public GameObject stunEffect;\n        public Vector3 originalVelocity;\n        public bool wasKinematic;\n    }\n    \n    private System.Collections.Generic.List<StunnedTarget> _stunnedTargets = new System.Collections.Generic.List<StunnedTarget>();\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_attackPoint == null)\n            _attackPoint = transform;\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateStunnedTargets();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            Attack();\n        }\n    }\n    \n    void Attack()\n    {\n        if (!_canAttack) return;\n        \n        _canAttack = false;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_attackTrigger);\n            \n        StartCoroutine(PerformAttack());\n        StartCoroutine(AttackCooldown());\n    }\n    \n    IEnumerator PerformAttack()\n    {\n        yield return new WaitForSeconds(0.3f);\n        \n        Collider[] hitTargets = Physics.OverlapSphere(_attackPoint.position, _attackRange, _targetLayers);\n        \n        foreach (Collider target in hitTargets)\n        {\n            if (target.gameObject == gameObject) continue;\n            \n            ProcessHit(target.gameObject);\n        }\n    }\n    \n    void ProcessHit(GameObject target)\n    {\n        // Apply damage\n        var healthComponent = target.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_damage);\n        }\n        \n        // Check for stun\n        bool shouldStun = Random.Range(0f, 1f) <= _stunChance;\n        if (shouldStun)\n        {\n            ApplyStun(target);\n        }\n        \n        // Visual and audio effects\n        PlayHitEffects(target.transform.position, shouldStun);\n    }\n    \n    void ApplyStun(GameObject target)\n    {\n        // Remove existing stun if present\n        RemoveStun(target);\n        \n        StunnedTarget stunnedTarget = new StunnedTarget\n        {\n            target = target,\n            stunEndTime = Time.time + _stunDuration\n        };\n        \n        // Handle different target types\n        var rigidbody = target.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            stunnedTarget.originalVelocity = rigidbody.velocity;\n            stunnedTarget.wasKinematic = rigidbody.isKinematic;\n            rigidbody.velocity = Vector3.zero;\n            rigidbody.isKinematic = true;\n        }\n        \n        var navMeshAgent = target.GetComponent<UnityEngine.AI.NavMeshAgent>();\n        if (navMeshAgent != null)\n        {\n            navMeshAgent.isStopped = true;\n        }\n        \n        var characterController = target.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n        }\n        \n        // Spawn stun effect\n        if (_stunEffectPrefab != null)\n        {\n            stunnedTarget.stunEffect = Instantiate(_stunEffectPrefab, target.transform.position + Vector3.up, Quaternion.identity);\n            stunnedTarget.stunEffect.transform.SetParent(target.transform);\n        }\n        \n        _stunnedTargets.Add(stunnedTarget);\n    }\n    \n    void UpdateStunnedTargets()\n    {\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            if (_stunnedTargets[i].target == null || Time.time >= _stunnedTargets[i].stunEndTime)\n            {\n                RemoveStunAtIndex(i);\n            }\n        }\n    }\n    \n    void RemoveStun(GameObject target)\n    {\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            if (_stunnedTargets[i].target == target)\n            {\n                RemoveStunAtIndex(i);\n                break;\n            }\n        }\n    }\n    \n    void RemoveStunAtIndex(int index)\n    {\n        if (index < 0 || index >= _stunnedTargets.Count) return;\n        \n        StunnedTarget stunnedTarget = _stunnedTargets[index];\n        \n        if (stunnedTarget.target != null)\n        {\n            // Restore movement\n            var rigidbody = stunnedTarget.target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                rigidbody.isKinematic = stunnedTarget.wasKinematic;\n                if (!stunnedTarget.wasKinematic)\n                    rigidbody.velocity = stunnedTarget.originalVelocity;\n            }\n            \n            var navMeshAgent = stunnedTarget.target.GetComponent<UnityEngine.AI.NavMeshAgent>();\n            if (navMeshAgent != null)\n            {\n                navMeshAgent.isStopped = false;\n            }\n            \n            var characterController = stunnedTarget.target.GetComponent<CharacterController>();\n            if (characterController != null)\n            {\n                characterController.enabled = true;\n            }\n        }\n        \n        // Remove stun effect\n        if (stunnedTarget.stunEffect != null)\n        {\n            Destroy(stunnedTarget.stunEffect);\n        }\n        \n        _stunnedTargets.RemoveAt(index);\n    }\n    \n    void PlayHitEffects(Vector3 position, bool wasStunned)\n    {\n        if (_hitEffect != null)\n        {\n            _hitEffect.transform.position = position;\n            _hitEffect.Play();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (wasStunned && _stunSound != null)\n                _audioSource.PlayOneShot(_stunSound);\n            else if (_hitSound != null)\n                _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    IEnumerator AttackCooldown()\n    {\n        yield return new WaitForSeconds(_attackCooldown);\n        _canAttack = true;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_attackPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_attackPoint.position, _attackRange);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        // Clean up all stuns when mace is destroyed\n        for (int i = _stunnedTargets.Count - 1; i >= 0; i--)\n        {\n            RemoveStunAtIndex(i);\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"JetpackFlight\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"thrustForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"fuelCapacity\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentFuel\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fuelConsumptionRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"maxFlightSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isFlying\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_jetpack\",\n      \"trigger\": \"when jump input is held and current fuel is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"set flying state to true\"\n        },\n        {\n          \"action\": \"apply upward thrust force\"\n        },\n        {\n          \"action\": \"play jetpack engine sound\"\n        },\n        {\n          \"action\": \"consume fuel over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_jetpack\",\n      \"trigger\": \"when jump input is released or fuel runs out\",\n      \"actions\": [\n        {\n          \"action\": \"set flying state to false\"\n        },\n        {\n          \"action\": \"stop applying thrust force\"\n        },\n        {\n          \"action\": \"stop jetpack engine sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"limit_flight_speed\",\n      \"trigger\": \"when flying and velocity exceeds maximum flight speed\",\n      \"actions\": [\n        {\n          \"action\": \"clamp velocity to maximum flight speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_fuel\",\n      \"trigger\": \"when not flying and current fuel is below capacity\",\n      \"actions\": [\n        {\n          \"action\": \"slowly restore fuel over time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class JetpackFlight : MonoBehaviour\n{\n    [Header(\"Jetpack Settings\")]\n    [SerializeField] private float _thrustForce = 15f;\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _fuelConsumptionRate = 20f;\n    [SerializeField] private float _fuelRegenRate = 10f;\n    [SerializeField] private float _maxSpeed = 20f;\n    [SerializeField] private bool _requiresFuel = true;\n    \n    [Header(\"Controls\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseInput = false;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _drag = 2f;\n    [SerializeField] private float _angularDrag = 5f;\n    [SerializeField] private bool _stabilizeRotation = true;\n    [SerializeField] private float _stabilizationForce = 50f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _thrustParticles;\n    [SerializeField] private AudioSource _thrustAudio;\n    [SerializeField] private Transform _thrustPoint;\n    [SerializeField] private float _screenShakeIntensity = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnJetpackStart;\n    public UnityEvent OnJetpackStop;\n    public UnityEvent OnFuelEmpty;\n    public UnityEvent<float> OnFuelChanged;\n    \n    private Rigidbody _rigidbody;\n    private float _currentFuel;\n    private bool _isThrusting;\n    private Vector3 _thrustDirection;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n    }\n    \n    private void Start()\n    {\n        _currentFuel = _maxFuel;\n        _rigidbody.drag = _drag;\n        _rigidbody.angularDrag = _angularDrag;\n        \n        if (_thrustPoint == null)\n        {\n            _thrustPoint = transform;\n        }\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateFuel();\n        UpdateEffects();\n        UpdateScreenShake();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isThrusting && CanThrust())\n        {\n            ApplyThrust();\n        }\n        \n        if (_stabilizeRotation && !_isThrusting)\n        {\n            StabilizeRotation();\n        }\n        \n        LimitSpeed();\n    }\n    \n    private void HandleInput()\n    {\n        bool thrustInput = false;\n        \n        if (_useMouseInput)\n        {\n            thrustInput = Input.GetMouseButton(0);\n            \n            Vector3 mousePosition = Input.mousePosition;\n            Vector3 worldPosition = _mainCamera.ScreenToWorldPoint(new Vector3(mousePosition.x, mousePosition.y, 10f));\n            _thrustDirection = (worldPosition - transform.position).normalized;\n        }\n        else\n        {\n            thrustInput = Input.GetKey(_thrustKey);\n            \n            float horizontal = Input.GetAxis(\"Horizontal\");\n            float vertical = Input.GetAxis(\"Vertical\");\n            _thrustDirection = new Vector3(horizontal, vertical, 0f).normalized;\n            \n            if (_thrustDirection == Vector3.zero)\n            {\n                _thrustDirection = transform.up;\n            }\n        }\n        \n        if (thrustInput && CanThrust() && !_isThrusting)\n        {\n            StartThrust();\n        }\n        else if (!thrustInput && _isThrusting)\n        {\n            StopThrust();\n        }\n    }\n    \n    private bool CanThrust()\n    {\n        return !_requiresFuel || _currentFuel > 0f;\n    }\n    \n    private void StartThrust()\n    {\n        _isThrusting = true;\n        OnJetpackStart?.Invoke();\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Play();\n        }\n        \n        if (_thrustAudio != null && !_thrustAudio.isPlaying)\n        {\n            _thrustAudio.Play();\n        }\n    }\n    \n    private void StopThrust()\n    {\n        _isThrusting = false;\n        OnJetpackStop?.Invoke();\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Stop();\n        }\n        \n        if (_thrustAudio != null)\n        {\n            _thrustAudio.Stop();\n        }\n    }\n    \n    private void ApplyThrust()\n    {\n        Vector3 force = _thrustDirection * _thrustForce;\n        _rigidbody.AddForce(force, ForceMode.Acceleration);\n        \n        if (_thrustPoint != null)\n        {\n            _rigidbody.AddForceAtPosition(force, _thrustPoint.position, ForceMode.Acceleration);\n        }\n    }\n    \n    private void UpdateFuel()\n    {\n        if (!_requiresFuel) return;\n        \n        if (_isThrusting && _currentFuel > 0f)\n        {\n            _currentFuel -= _fuelConsumptionRate * Time.deltaTime;\n            _currentFuel = Mathf.Max(0f, _currentFuel);\n            \n            if (_currentFuel <= 0f)\n            {\n                StopThrust();\n                OnFuelEmpty?.Invoke();\n            }\n        }\n        else if (!_isThrusting && _currentFuel < _maxFuel)\n        {\n            _currentFuel += _fuelRegenRate * Time.deltaTime;\n            _currentFuel = Mathf.Min(_maxFuel, _currentFuel);\n        }\n        \n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_thrustParticles != null)\n        {\n            if (_isThrusting && CanThrust())\n            {\n                if (!_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Play();\n                }\n                \n                var main = _thrustParticles.main;\n                main.startSpeed = _thrustForce * 0.5f;\n            }\n            else if (_thrustParticles.isPlaying)\n            {\n                _thrustParticles.Stop();\n            }\n        }\n        \n        if (_thrustAudio != null)\n        {\n            if (_isThrusting && CanThrust())\n            {\n                if (!_thrustAudio.isPlaying)\n                {\n                    _thrustAudio.Play();\n                }\n                _thrustAudio.volume = Mathf.Lerp(0.1f, 1f, _rigidbody.velocity.magnitude / _maxSpeed);\n            }\n            else if (_thrustAudio.isPlaying)\n            {\n                _thrustAudio.Stop();\n            }\n        }\n    }\n    \n    private void UpdateScreenShake()\n    {\n        if (_mainCamera == null || _screenShakeIntensity <= 0f) return;\n        \n        if (_isThrusting && CanThrust())\n        {\n            Vector3 shake = Random.insideUnitSphere * _screenShakeIntensity;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shake;\n        }\n        else\n        {\n            _mainCamera.transform.localPosition = Vector3.Lerp(_mainCamera.transform.localPosition, _originalCameraPosition, Time.deltaTime * 10f);\n        }\n    }\n    \n    private void StabilizeRotation()\n    {\n        Vector3 targetUp = Vector3.up;\n        Vector3 currentUp = transform.up;\n        Vector3 torque = Vector3.Cross(currentUp, targetUp) * _stabilizationForce;\n        _rigidbody.AddTorque(torque, ForceMode.Acceleration);\n    }\n    \n    private void LimitSpeed()\n    {\n        if (_rigidbody.velocity.magnitude > _maxSpeed)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n        }\n    }\n    \n    public void RefillFuel()\n    {\n        _currentFuel = _maxFuel;\n        OnFuelChanged?.Invoke(1f);\n    }\n    \n    public void SetFuel(float amount)\n    {\n        _currentFuel = Mathf.Clamp(amount, 0f, _maxFuel);\n        OnFuelChanged?.Invoke(_currentFuel / _maxFuel);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return _currentFuel / _maxFuel;\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    public void SetThrustForce(float force)\n    {\n        _thrustForce = Mathf.Max(0f, force);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_thrustPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_thrustPoint.position, 0.5f);\n            \n            if (_isThrusting)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawRay(_thrustPoint.position, -_thrustDirection * 2f);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AchievementBanner\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\",\n    \"Text\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"slideInSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeOutSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"achievementTitle\",\n      \"type\": \"string\",\n      \"default\": \"Achievement Unlocked!\"\n    },\n    {\n      \"name\": \"achievementDescription\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"achievementIcon\",\n      \"type\": \"Sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"bannerColor\",\n      \"type\": \"Color\",\n      \"default\": \"gold\"\n    },\n    {\n      \"name\": \"soundEffect\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_achievement\",\n      \"trigger\": \"when achievement unlock event is received\",\n      \"actions\": [\n        {\n          \"action\": \"update banner text with achievement title and description\"\n        },\n        {\n          \"action\": \"set banner icon to achievement icon\"\n        },\n        {\n          \"action\": \"play achievement unlock sound effect\"\n        },\n        {\n          \"action\": \"slide banner in from top of screen\"\n        },\n        {\n          \"action\": \"make banner fully visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_hide_banner\",\n      \"trigger\": \"when banner has been displayed for full duration\",\n      \"actions\": [\n        {\n          \"action\": \"fade out banner opacity\"\n        },\n        {\n          \"action\": \"slide banner up off screen\"\n        },\n        {\n          \"action\": \"hide banner completely\"\n        }\n      ]\n    },\n    {\n      \"name\": \"manual_dismiss\",\n      \"trigger\": \"when player clicks on banner\",\n      \"actions\": [\n        {\n          \"action\": \"immediately start fade out animation\"\n        },\n        {\n          \"action\": \"slide banner up off screen faster than normal\"\n        },\n        {\n          \"action\": \"hide banner completely\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_entrance\",\n      \"trigger\": \"when banner starts showing\",\n      \"actions\": [\n        {\n          \"action\": \"start banner above visible screen area\"\n        },\n        {\n          \"action\": \"smoothly slide banner down to display position\"\n        },\n        {\n          \"action\": \"add slight bounce effect when reaching final position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AchievementBanner : MonoBehaviour\n{\n    [System.Serializable]\n    public class Achievement\n    {\n        public string title;\n        public string description;\n        public Sprite icon;\n        public Color backgroundColor = Color.white;\n        public AudioClip unlockSound;\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _bannerPanel;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Image _iconImage;\n    [SerializeField] private TextMeshProUGUI _titleText;\n    [SerializeField] private TextMeshProUGUI _descriptionText;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _slideInDuration = 0.5f;\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _slideOutDuration = 0.5f;\n    [SerializeField] private AnimationCurve _slideInCurve = AnimationCurve.EaseOut(0, 0, 1, 1);\n    [SerializeField] private AnimationCurve _slideOutCurve = AnimationCurve.EaseIn(0, 0, 1, 1);\n\n    [Header(\"Position Settings\")]\n    [SerializeField] private Vector2 _hiddenPosition = new Vector2(0, 100);\n    [SerializeField] private Vector2 _visiblePosition = Vector2.zero;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _defaultUnlockSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _celebrationParticles;\n    [SerializeField] private bool _useScreenShake = true;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 0.2f;\n\n    private RectTransform _bannerRect;\n    private Queue<Achievement> _achievementQueue = new Queue<Achievement>();\n    private bool _isDisplaying = false;\n    private Coroutine _displayCoroutine;\n    private Vector3 _originalCameraPosition;\n    private Camera _mainCamera;\n\n    private void Awake()\n    {\n        _bannerRect = _bannerPanel.GetComponent<RectTransform>();\n        _mainCamera = Camera.main;\n        \n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(DismissBanner);\n    }\n\n    private void Start()\n    {\n        if (_bannerPanel != null)\n        {\n            _bannerPanel.SetActive(false);\n            _bannerRect.anchoredPosition = _hiddenPosition;\n        }\n    }\n\n    public void UnlockAchievement(Achievement achievement)\n    {\n        if (achievement == null) return;\n\n        _achievementQueue.Enqueue(achievement);\n        \n        if (!_isDisplaying)\n        {\n            ProcessNextAchievement();\n        }\n    }\n\n    public void UnlockAchievement(string title, string description, Sprite icon = null, Color? backgroundColor = null, AudioClip unlockSound = null)\n    {\n        Achievement achievement = new Achievement\n        {\n            title = title,\n            description = description,\n            icon = icon,\n            backgroundColor = backgroundColor ?? Color.white,\n            unlockSound = unlockSound\n        };\n\n        UnlockAchievement(achievement);\n    }\n\n    private void ProcessNextAchievement()\n    {\n        if (_achievementQueue.Count == 0) return;\n\n        Achievement achievement = _achievementQueue.Dequeue();\n        _displayCoroutine = StartCoroutine(DisplayAchievementCoroutine(achievement));\n    }\n\n    private IEnumerator DisplayAchievementCoroutine(Achievement achievement)\n    {\n        _isDisplaying = true;\n\n        SetupBannerContent(achievement);\n        _bannerPanel.SetActive(true);\n\n        // Play unlock sound\n        PlayUnlockSound(achievement.unlockSound);\n\n        // Screen shake effect\n        if (_useScreenShake && _mainCamera != null)\n        {\n            StartCoroutine(ScreenShakeCoroutine());\n        }\n\n        // Slide in animation\n        yield return StartCoroutine(SlideBannerCoroutine(_hiddenPosition, _visiblePosition, _slideInDuration, _slideInCurve));\n\n        // Trigger celebration particles\n        if (_celebrationParticles != null)\n        {\n            _celebrationParticles.Play();\n        }\n\n        // Display duration\n        yield return new WaitForSeconds(_displayDuration);\n\n        // Slide out animation\n        yield return StartCoroutine(SlideBannerCoroutine(_visiblePosition, _hiddenPosition, _slideOutDuration, _slideOutCurve));\n\n        _bannerPanel.SetActive(false);\n        _isDisplaying = false;\n\n        // Process next achievement if any\n        if (_achievementQueue.Count > 0)\n        {\n            yield return new WaitForSeconds(0.2f);\n            ProcessNextAchievement();\n        }\n    }\n\n    private void SetupBannerContent(Achievement achievement)\n    {\n        if (_titleText != null)\n            _titleText.text = achievement.title;\n\n        if (_descriptionText != null)\n            _descriptionText.text = achievement.description;\n\n        if (_iconImage != null)\n        {\n            _iconImage.sprite = achievement.icon;\n            _iconImage.gameObject.SetActive(achievement.icon != null);\n        }\n\n        if (_backgroundImage != null)\n            _backgroundImage.color = achievement.backgroundColor;\n    }\n\n    private IEnumerator SlideBannerCoroutine(Vector2 startPos, Vector2 endPos, float duration, AnimationCurve curve)\n    {\n        float elapsed = 0f;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            float curveValue = curve.Evaluate(t);\n            \n            _bannerRect.anchoredPosition = Vector2.Lerp(startPos, endPos, curveValue);\n            \n            yield return null;\n        }\n\n        _bannerRect.anchoredPosition = endPos;\n    }\n\n    private IEnumerator ScreenShakeCoroutine()\n    {\n        if (_mainCamera == null) yield break;\n\n        float elapsed = 0f;\n\n        while (elapsed < _shakeDuration)\n        {\n            elapsed += Time.deltaTime;\n            \n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.z = 0f;\n            \n            _mainCamera.transform.position = _originalCameraPosition + randomOffset;\n            \n            yield return null;\n        }\n\n        _mainCamera.transform.position = _originalCameraPosition;\n    }\n\n    private void PlayUnlockSound(AudioClip customSound)\n    {\n        if (_audioSource == null) return;\n\n        AudioClip soundToPlay = customSound != null ? customSound : _defaultUnlockSound;\n        \n        if (soundToPlay != null)\n        {\n            _audioSource.PlayOneShot(soundToPlay);\n        }\n    }\n\n    public void DismissBanner()\n    {\n        if (_displayCoroutine != null)\n        {\n            StopCoroutine(_displayCoroutine);\n        }\n\n        StartCoroutine(DismissBannerCoroutine());\n    }\n\n    private IEnumerator DismissBannerCoroutine()\n    {\n        yield return StartCoroutine(SlideBannerCoroutine(_bannerRect.anchoredPosition, _hiddenPosition, _slideOutDuration * 0.5f, _slideOutCurve));\n        \n        _bannerPanel.SetActive(false);\n        _isDisplaying = false;\n\n        if (_achievementQueue.Count > 0)\n        {\n            yield return new WaitForSeconds(0.2f);\n            ProcessNextAchievement();\n        }\n    }\n\n    public void ClearQueue()\n    {\n        _achievementQueue.Clear();\n        \n        if (_isDisplaying)\n        {\n            DismissBanner();\n        }\n    }\n\n    public int GetQueueCount()\n    {\n        return _achievementQueue.Count;\n    }\n\n    public bool IsDisplaying()\n    {\n        return _isDisplaying;\n    }\n\n    private void OnDestroy()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.RemoveListener(DismissBanner);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LaserBeam\",\n  \"components\": [\n    \"LineRenderer\",\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"toggleInterval\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"beamWidth\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"beamColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"toggle_laser_periodically\",\n      \"trigger\": \"every toggle interval seconds\",\n      \"actions\": [\n        {\n          \"action\": \"switch laser beam visibility state\"\n        },\n        {\n          \"action\": \"toggle light component on or off\"\n        },\n        {\n          \"action\": \"update beam active status\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_laser\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set line renderer width to beam width\"\n        },\n        {\n          \"action\": \"set line renderer color to beam color\"\n        },\n        {\n          \"action\": \"position beam from start point to end point\"\n        },\n        {\n          \"action\": \"configure light intensity and color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_beam_appearance\",\n      \"trigger\": \"when laser state changes\",\n      \"actions\": [\n        {\n          \"action\": \"show or hide line renderer based on active state\"\n        },\n        {\n          \"action\": \"enable or disable light component based on active state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LaserBeam : MonoBehaviour\n{\n    [Header(\"Laser Settings\")]\n    [SerializeField] private bool _startActive = true;\n    [SerializeField] private float _toggleInterval = 2f;\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private LineRenderer _lineRenderer;\n    [SerializeField] private Transform _startPoint;\n    [SerializeField] private Transform _endPoint;\n    [SerializeField] private ParticleSystem _startEffect;\n    [SerializeField] private ParticleSystem _endEffect;\n    [SerializeField] private Light _laserLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    [SerializeField] private AudioClip _loopSound;\n    \n    [Header(\"Raycast Settings\")]\n    [SerializeField] private float _maxDistance = 100f;\n    [SerializeField] private float _damageInterval = 0.1f;\n    \n    private bool _isActive;\n    private float _toggleTimer;\n    private float _damageTimer;\n    private Collider _currentTarget;\n    private Vector3 _hitPoint;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _isActive = _startActive;\n        _toggleTimer = _toggleInterval;\n        UpdateLaserState();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_lineRenderer == null)\n            _lineRenderer = GetComponent<LineRenderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_startPoint == null)\n            _startPoint = transform;\n            \n        if (_lineRenderer != null)\n        {\n            _lineRenderer.positionCount = 2;\n            _lineRenderer.useWorldSpace = true;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleToggleTimer();\n        \n        if (_isActive)\n        {\n            UpdateLaserRaycast();\n            HandleDamage();\n        }\n    }\n    \n    private void HandleToggleTimer()\n    {\n        if (_toggleInterval > 0)\n        {\n            _toggleTimer -= Time.deltaTime;\n            if (_toggleTimer <= 0)\n            {\n                ToggleLaser();\n                _toggleTimer = _toggleInterval;\n            }\n        }\n    }\n    \n    private void UpdateLaserRaycast()\n    {\n        Vector3 startPos = _startPoint.position;\n        Vector3 direction = _endPoint != null ? (_endPoint.position - startPos).normalized : transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(startPos, direction, out hit, _maxDistance, _damageableLayers))\n        {\n            _hitPoint = hit.point;\n            _currentTarget = hit.collider;\n        }\n        else\n        {\n            _hitPoint = startPos + direction * _maxDistance;\n            _currentTarget = null;\n        }\n        \n        UpdateVisuals();\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_lineRenderer != null)\n        {\n            _lineRenderer.SetPosition(0, _startPoint.position);\n            _lineRenderer.SetPosition(1, _hitPoint);\n            _lineRenderer.enabled = _isActive;\n        }\n        \n        if (_startEffect != null)\n        {\n            if (_isActive && !_startEffect.isPlaying)\n                _startEffect.Play();\n            else if (!_isActive && _startEffect.isPlaying)\n                _startEffect.Stop();\n        }\n        \n        if (_endEffect != null)\n        {\n            _endEffect.transform.position = _hitPoint;\n            if (_isActive && !_endEffect.isPlaying)\n                _endEffect.Play();\n            else if (!_isActive && _endEffect.isPlaying)\n                _endEffect.Stop();\n        }\n        \n        if (_laserLight != null)\n            _laserLight.enabled = _isActive;\n    }\n    \n    private void HandleDamage()\n    {\n        if (_currentTarget == null || _damage <= 0)\n            return;\n            \n        _damageTimer += Time.deltaTime;\n        if (_damageTimer >= _damageInterval)\n        {\n            ApplyDamage(_currentTarget);\n            _damageTimer = 0f;\n        }\n    }\n    \n    private void ApplyDamage(Collider target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            // Apply damage to player using standard Unity components\n            var rigidbody = target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                Vector3 knockback = (_hitPoint - _startPoint.position).normalized * _damage * 0.1f;\n                rigidbody.AddForce(knockback, ForceMode.Impulse);\n            }\n        }\n        \n        // Send damage message to any component that might handle it\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        target.SendMessage(\"OnLaserHit\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void ToggleLaser()\n    {\n        _isActive = !_isActive;\n        UpdateLaserState();\n    }\n    \n    public void SetLaserActive(bool active)\n    {\n        _isActive = active;\n        UpdateLaserState();\n    }\n    \n    private void UpdateLaserState()\n    {\n        if (_audioSource != null)\n        {\n            if (_isActive)\n            {\n                if (_activationSound != null)\n                    _audioSource.PlayOneShot(_activationSound);\n                    \n                if (_loopSound != null)\n                {\n                    _audioSource.clip = _loopSound;\n                    _audioSource.loop = true;\n                    _audioSource.Play();\n                }\n            }\n            else\n            {\n                if (_deactivationSound != null)\n                    _audioSource.PlayOneShot(_deactivationSound);\n                    \n                if (_audioSource.isPlaying && _audioSource.clip == _loopSound)\n                    _audioSource.Stop();\n            }\n        }\n        \n        UpdateVisuals();\n        _damageTimer = 0f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_startPoint != null)\n        {\n            Gizmos.color = _isActive ? Color.red : Color.gray;\n            Vector3 direction = _endPoint != null ? (_endPoint.position - _startPoint.position).normalized : transform.forward;\n            Gizmos.DrawRay(_startPoint.position, direction * _maxDistance);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_startEffect != null && _startEffect.isPlaying)\n            _startEffect.Stop();\n            \n        if (_endEffect != null && _endEffect.isPlaying)\n            _endEffect.Stop();\n            \n        if (_audioSource != null && _audioSource.isPlaying)\n            _audioSource.Stop();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PoisonGasCloud\",\n  \"components\": [\n    \"Collider\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"cloudDuration\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"cloudRadius\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_gas_cloud\",\n      \"trigger\": \"when object is created\",\n      \"actions\": [\n        {\n          \"action\": \"create green particle effect with poison appearance\"\n        },\n        {\n          \"action\": \"set collider to trigger mode with cloud radius size\"\n        },\n        {\n          \"action\": \"start cloud lifetime timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_entities_in_cloud\",\n      \"trigger\": \"when living entity enters or stays in gas cloud area\",\n      \"actions\": [\n        {\n          \"action\": \"apply poison damage to entity at regular intervals\"\n        },\n        {\n          \"action\": \"show damage effect on affected entity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dissipate_cloud\",\n      \"trigger\": \"when cloud duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade out particle effects\"\n        },\n        {\n          \"action\": \"destroy gas cloud object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_damage_on_exit\",\n      \"trigger\": \"when entity leaves gas cloud area\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying poison damage to that entity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class PoisonGasCloud : MonoBehaviour\n{\n    [Header(\"Gas Properties\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    [SerializeField] private float _cloudDuration = 15f;\n    [SerializeField] private bool _destroyAfterDuration = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _gasParticles;\n    [SerializeField] private Color _gasColor = Color.green;\n    [SerializeField] private AnimationCurve _opacityOverTime = AnimationCurve.Linear(0, 1, 1, 0);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _gasHissSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    private float _currentLifetime;\n    private Collider _gasCollider;\n    private Renderer _gasRenderer;\n    private Material _gasMaterial;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        _gasCollider = GetComponent<Collider>();\n        _gasRenderer = GetComponent<Renderer>();\n        \n        if (_gasCollider != null)\n        {\n            _gasCollider.isTrigger = true;\n        }\n        \n        if (_gasRenderer != null && _gasRenderer.material != null)\n        {\n            _gasMaterial = _gasRenderer.material;\n            _originalColor = _gasMaterial.color;\n            _gasMaterial.color = _gasColor;\n        }\n        \n        if (_gasParticles != null)\n        {\n            _gasParticles.Play();\n        }\n        \n        if (_audioSource != null && _gasHissSound != null)\n        {\n            _audioSource.clip = _gasHissSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        _currentLifetime = 0f;\n    }\n    \n    private void Update()\n    {\n        if (_destroyAfterDuration)\n        {\n            _currentLifetime += Time.deltaTime;\n            \n            float normalizedTime = _currentLifetime / _cloudDuration;\n            \n            if (_gasMaterial != null)\n            {\n                float opacity = _opacityOverTime.Evaluate(normalizedTime);\n                Color currentColor = _gasMaterial.color;\n                currentColor.a = opacity;\n                _gasMaterial.color = currentColor;\n            }\n            \n            if (_currentLifetime >= _cloudDuration)\n            {\n                DestroyGasCloud();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCoroutine(DamageOverTime(other.gameObject));\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StopCoroutine(DamageOverTime(other.gameObject));\n        }\n    }\n    \n    private System.Collections.IEnumerator DamageOverTime(GameObject target)\n    {\n        while (target != null && _gasCollider.bounds.Contains(target.transform.position))\n        {\n            DealDamage(target);\n            yield return new WaitForSeconds(_damageInterval);\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try to find a component that can take damage\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - target object should implement this\n            target.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Play damage sound\n        if (_audioSource != null && _damageSound != null)\n        {\n            _audioSource.PlayOneShot(_damageSound);\n        }\n        \n        // Create damage effect at target position\n        CreateDamageEffect(target.transform.position);\n    }\n    \n    private void CreateDamageEffect(Vector3 position)\n    {\n        // Create a simple damage indicator\n        GameObject damageIndicator = new GameObject(\"DamageIndicator\");\n        damageIndicator.transform.position = position + Vector3.up * 2f;\n        \n        TextMesh textMesh = damageIndicator.AddComponent<TextMesh>();\n        textMesh.text = \"-\" + _damageAmount.ToString();\n        textMesh.color = Color.red;\n        textMesh.fontSize = 20;\n        textMesh.anchor = TextAnchor.MiddleCenter;\n        \n        // Animate the damage text\n        StartCoroutine(AnimateDamageText(damageIndicator));\n    }\n    \n    private System.Collections.IEnumerator AnimateDamageText(GameObject textObject)\n    {\n        Vector3 startPos = textObject.transform.position;\n        Vector3 endPos = startPos + Vector3.up * 1f;\n        float duration = 1f;\n        float elapsed = 0f;\n        \n        TextMesh textMesh = textObject.GetComponent<TextMesh>();\n        Color startColor = textMesh.color;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / duration;\n            \n            textObject.transform.position = Vector3.Lerp(startPos, endPos, progress);\n            \n            Color currentColor = startColor;\n            currentColor.a = 1f - progress;\n            textMesh.color = currentColor;\n            \n            yield return null;\n        }\n        \n        Destroy(textObject);\n    }\n    \n    private void DestroyGasCloud()\n    {\n        if (_gasParticles != null)\n        {\n            _gasParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        StartCoroutine(FadeOutAndDestroy());\n    }\n    \n    private System.Collections.IEnumerator FadeOutAndDestroy()\n    {\n        float fadeTime = 2f;\n        float elapsed = 0f;\n        \n        while (elapsed < fadeTime)\n        {\n            elapsed += Time.deltaTime;\n            float alpha = 1f - (elapsed / fadeTime);\n            \n            if (_gasMaterial != null)\n            {\n                Color currentColor = _gasMaterial.color;\n                currentColor.a = alpha;\n                _gasMaterial.color = currentColor;\n            }\n            \n            yield return null;\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    public void SetDamage(float damage)\n    {\n        _damageAmount = damage;\n    }\n    \n    public void SetDuration(float duration)\n    {\n        _cloudDuration = duration;\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = interval;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_gasMaterial != null)\n        {\n            _gasMaterial.color = _originalColor;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpawnPointAssignment\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"spawnPoints\",\n      \"type\": \"Transform[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"assignmentMode\",\n      \"type\": \"string\",\n      \"default\": \"sequential\"\n    },\n    {\n      \"name\": \"currentIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isOccupied\",\n      \"type\": \"bool[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"maxPlayersPerPoint\",\n      \"type\": \"int\",\n      \"default\": 1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"assign_spawn_point\",\n      \"trigger\": \"when player requests spawn location\",\n      \"actions\": [\n        {\n          \"action\": \"find next available spawn point based on assignment mode\"\n        },\n        {\n          \"action\": \"mark spawn point as occupied\"\n        },\n        {\n          \"action\": \"return spawn point position and rotation to requesting player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_spawn_point\",\n      \"trigger\": \"when player leaves spawn area or dies\",\n      \"actions\": [\n        {\n          \"action\": \"mark previously assigned spawn point as available\"\n        },\n        {\n          \"action\": \"reset occupation status for that spawn point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cycle_sequential_assignment\",\n      \"trigger\": \"when using sequential assignment mode and current spawn point is occupied\",\n      \"actions\": [\n        {\n          \"action\": \"increment current index to next spawn point\"\n        },\n        {\n          \"action\": \"wrap around to first spawn point if reached end of list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"find_random_spawn_point\",\n      \"trigger\": \"when using random assignment mode\",\n      \"actions\": [\n        {\n          \"action\": \"select random spawn point from available points\"\n        },\n        {\n          \"action\": \"verify selected point is not at maximum capacity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SpawnPointManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class SpawnPoint\n    {\n        public Transform transform;\n        public bool isOccupied;\n        public float occupiedRadius = 2f;\n        public string teamTag = \"\";\n        public int priority = 0;\n        public bool isActive = true;\n        \n        public SpawnPoint(Transform t)\n        {\n            transform = t;\n            isOccupied = false;\n        }\n    }\n\n    [Header(\"Spawn Configuration\")]\n    [SerializeField] private Transform[] _spawnTransforms;\n    [SerializeField] private bool _autoFindSpawnPoints = true;\n    [SerializeField] private string _spawnPointTag = \"SpawnPoint\";\n    \n    [Header(\"Assignment Rules\")]\n    [SerializeField] private bool _useTeamBasedSpawning = false;\n    [SerializeField] private bool _avoidOccupiedSpawns = true;\n    [SerializeField] private float _occupiedCheckRadius = 2f;\n    [SerializeField] private LayerMask _obstacleCheckLayers = -1;\n    \n    [Header(\"Spawn Modes\")]\n    [SerializeField] private SpawnMode _spawnMode = SpawnMode.Random;\n    [SerializeField] private bool _usePrioritySystem = false;\n    [SerializeField] private float _respawnCooldown = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnSpawnPointAssigned;\n    public UnityEvent<Transform> OnSpawnPointOccupied;\n    public UnityEvent<Transform> OnSpawnPointFreed;\n\n    public enum SpawnMode\n    {\n        Random,\n        Sequential,\n        Nearest,\n        Furthest,\n        Priority\n    }\n\n    private List<SpawnPoint> _spawnPoints = new List<SpawnPoint>();\n    private Dictionary<string, List<SpawnPoint>> _teamSpawnPoints = new Dictionary<string, List<SpawnPoint>>();\n    private int _sequentialIndex = 0;\n    private Dictionary<Transform, float> _spawnCooldowns = new Dictionary<Transform, float>();\n\n    private void Start()\n    {\n        InitializeSpawnPoints();\n        InvokeRepeating(nameof(UpdateOccupiedStates), 0f, 0.5f);\n        InvokeRepeating(nameof(UpdateCooldowns), 0f, 0.1f);\n    }\n\n    private void InitializeSpawnPoints()\n    {\n        _spawnPoints.Clear();\n        _teamSpawnPoints.Clear();\n\n        if (_autoFindSpawnPoints)\n        {\n            GameObject[] spawnObjects = GameObject.FindGameObjectsWithTag(_spawnPointTag);\n            _spawnTransforms = spawnObjects.Select(go => go.transform).ToArray();\n        }\n\n        foreach (Transform spawnTransform in _spawnTransforms)\n        {\n            if (spawnTransform == null) continue;\n\n            SpawnPoint spawnPoint = new SpawnPoint(spawnTransform);\n            \n            SpawnPointData spawnData = spawnTransform.GetComponent<SpawnPointData>();\n            if (spawnData != null)\n            {\n                spawnPoint.teamTag = spawnData.teamTag;\n                spawnPoint.priority = spawnData.priority;\n                spawnPoint.occupiedRadius = spawnData.occupiedRadius;\n                spawnPoint.isActive = spawnData.isActive;\n            }\n\n            _spawnPoints.Add(spawnPoint);\n\n            if (_useTeamBasedSpawning && !string.IsNullOrEmpty(spawnPoint.teamTag))\n            {\n                if (!_teamSpawnPoints.ContainsKey(spawnPoint.teamTag))\n                {\n                    _teamSpawnPoints[spawnPoint.teamTag] = new List<SpawnPoint>();\n                }\n                _teamSpawnPoints[spawnPoint.teamTag].Add(spawnPoint);\n            }\n        }\n\n        if (_usePrioritySystem)\n        {\n            _spawnPoints = _spawnPoints.OrderByDescending(sp => sp.priority).ToList();\n        }\n    }\n\n    public Transform AssignSpawnPoint(string teamTag = \"\", Vector3 referencePosition = default)\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0)\n        {\n            Debug.LogWarning(\"No available spawn points found!\");\n            return null;\n        }\n\n        SpawnPoint selectedSpawn = SelectSpawnPoint(availableSpawns, referencePosition);\n        \n        if (selectedSpawn != null)\n        {\n            selectedSpawn.isOccupied = true;\n            _spawnCooldowns[selectedSpawn.transform] = Time.time + _respawnCooldown;\n            OnSpawnPointAssigned?.Invoke(selectedSpawn.transform);\n            OnSpawnPointOccupied?.Invoke(selectedSpawn.transform);\n            return selectedSpawn.transform;\n        }\n\n        return null;\n    }\n\n    public Transform GetNearestSpawnPoint(Vector3 position, string teamTag = \"\")\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0) return null;\n\n        SpawnPoint nearest = availableSpawns\n            .OrderBy(sp => Vector3.Distance(sp.transform.position, position))\n            .FirstOrDefault();\n\n        return nearest?.transform;\n    }\n\n    public Transform GetRandomSpawnPoint(string teamTag = \"\")\n    {\n        List<SpawnPoint> availableSpawns = GetAvailableSpawnPoints(teamTag);\n        \n        if (availableSpawns.Count == 0) return null;\n\n        int randomIndex = Random.Range(0, availableSpawns.Count);\n        return availableSpawns[randomIndex].transform;\n    }\n\n    public void FreeSpawnPoint(Transform spawnTransform)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint != null)\n        {\n            spawnPoint.isOccupied = false;\n            OnSpawnPointFreed?.Invoke(spawnTransform);\n        }\n    }\n\n    public void SetSpawnPointActive(Transform spawnTransform, bool active)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint != null)\n        {\n            spawnPoint.isActive = active;\n        }\n    }\n\n    public bool IsSpawnPointAvailable(Transform spawnTransform)\n    {\n        SpawnPoint spawnPoint = _spawnPoints.FirstOrDefault(sp => sp.transform == spawnTransform);\n        if (spawnPoint == null) return false;\n\n        return spawnPoint.isActive && \n               !spawnPoint.isOccupied && \n               !IsOnCooldown(spawnTransform) &&\n               !IsObstructed(spawnTransform);\n    }\n\n    private List<SpawnPoint> GetAvailableSpawnPoints(string teamTag)\n    {\n        List<SpawnPoint> spawnsToCheck = _spawnPoints;\n\n        if (_useTeamBasedSpawning && !string.IsNullOrEmpty(teamTag) && _teamSpawnPoints.ContainsKey(teamTag))\n        {\n            spawnsToCheck = _teamSpawnPoints[teamTag];\n        }\n\n        return spawnsToCheck.Where(sp => \n            sp.isActive && \n            (!_avoidOccupiedSpawns || !sp.isOccupied) &&\n            !IsOnCooldown(sp.transform) &&\n            !IsObstructed(sp.transform)\n        ).ToList();\n    }\n\n    private SpawnPoint SelectSpawnPoint(List<SpawnPoint> availableSpawns, Vector3 referencePosition)\n    {\n        switch (_spawnMode)\n        {\n            case SpawnMode.Random:\n                return availableSpawns[Random.Range(0, availableSpawns.Count)];\n\n            case SpawnMode.Sequential:\n                SpawnPoint sequential = availableSpawns[_sequentialIndex % availableSpawns.Count];\n                _sequentialIndex++;\n                return sequential;\n\n            case SpawnMode.Nearest:\n                if (referencePosition == default) referencePosition = Vector3.zero;\n                return availableSpawns.OrderBy(sp => Vector3.Distance(sp.transform.position, referencePosition)).FirstOrDefault();\n\n            case SpawnMode.Furthest:\n                if (referencePosition == default) referencePosition = Vector3.zero;\n                return availableSpawns.OrderByDescending(sp => Vector3.Distance(sp.transform.position, referencePosition)).FirstOrDefault();\n\n            case SpawnMode.Priority:\n                return availableSpawns.OrderByDescending(sp => sp.priority).FirstOrDefault();\n\n            default:\n                return availableSpawns[0];\n        }\n    }\n\n    private bool IsOnCooldown(Transform spawnTransform)\n    {\n        return _spawnCooldowns.ContainsKey(spawnTransform) && \n               Time.time < _spawnCooldowns[spawnTransform];\n    }\n\n    private bool IsObstructed(Transform spawnTransform)\n    {\n        Collider[] colliders = Physics.OverlapSphere(spawnTransform.position, _occupiedCheckRadius, _obstacleCheckLayers);\n        return colliders.Length > 0;\n    }\n\n    private void UpdateOccupiedStates()\n    {\n        foreach (SpawnPoint spawnPoint in _spawnPoints)\n        {\n            bool wasOccupied = spawnPoint.isOccupied;\n            \n            Collider[] colliders = Physics.OverlapSphere(\n                spawnPoint.transform.position, \n                spawnPoint.occupiedRadius\n            );\n\n            spawnPoint.isOccupied = colliders.Any(col => col.CompareTag(\"Player\"));\n\n            if (wasOccupied && !spawnPoint.isOccupied)\n            {\n                OnSpawnPointFreed?.Invoke(spawnPoint.transform);\n            }\n            else if (!wasOccupied && spawnPoint.isOccupied)\n            {\n                OnSpawnPointOccupied?.Invoke(spawnPoint.transform);\n            }\n        }\n    }\n\n    private void UpdateCooldowns()\n    {\n        List<Transform> expiredCooldowns = new List<Transform>();\n        \n        foreach (var kvp in _spawnCooldowns)\n        {\n            if (Time.time >= kvp.Value)\n            {\n                expiredCooldowns.Add(kvp.Key);\n            }\n        }\n\n        foreach (Transform expired in expiredCooldowns)\n        {\n            _spawnCooldowns.Remove(expired);\n        }\n    }\n\n    private void OnDrawGizmos()\n    {\n        if (_spawnPoints == null) return;\n\n        foreach (SpawnPoint spawnPoint in _spawnPoints)\n        {\n            if (spawnPoint.transform == null) continue;\n\n            Gizmos.color = spawnPoint.isActive ? \n                (spawnPoint.isOccupied ? Color.red : Color.green) : \n                Color.gray;\n\n            Gizmos.DrawWireSphere(spawnPoint.transform.position, spawnPoint.occupiedRadius);\n            Gizmos.DrawWireCube(spawnPoint.transform.position, Vector3.one * 0.5f);\n        }\n    }\n}\n\n[System.Serializable]\npublic class SpawnPointData : MonoBehaviour\n{\n    [Header(\"Spawn Point Settings\")]\n    public string teamTag = \"\";\n    public int priority = 0;\n    public float occupiedRadius = 2f;\n    public bool isActive = true;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Campfire\",\n  \"components\": [\n    \"Collider\",\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healingAmount\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"healingInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"heal_nearby_player\",\n      \"trigger\": \"when player enters campfire area\",\n      \"actions\": [\n        {\n          \"action\": \"start healing process for player\"\n        },\n        {\n          \"action\": \"play healing sound effect\"\n        },\n        {\n          \"action\": \"show healing particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_healing\",\n      \"trigger\": \"every healing interval while player is near campfire\",\n      \"actions\": [\n        {\n          \"action\": \"restore player health by healing amount\"\n        },\n        {\n          \"action\": \"clamp player health to maximum health value\"\n        },\n        {\n          \"action\": \"display health restoration visual feedback\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_healing\",\n      \"trigger\": \"when player leaves campfire area\",\n      \"actions\": [\n        {\n          \"action\": \"stop healing process\"\n        },\n        {\n          \"action\": \"stop healing sound effect\"\n        },\n        {\n          \"action\": \"fade out healing particle effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Campfire : MonoBehaviour\n{\n    [Header(\"Healing Settings\")]\n    [SerializeField] private float _healingRate = 10f;\n    [SerializeField] private float _healingInterval = 1f;\n    [SerializeField] private float _healingRadius = 3f;\n    [SerializeField] private float _maxHealth = 100f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private AudioSource _fireAudioSource;\n    [SerializeField] private GameObject _healingEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerEnterHealing;\n    public UnityEvent<GameObject> OnPlayerExitHealing;\n    public UnityEvent<GameObject, float> OnPlayerHealed;\n    \n    private bool _isActive = true;\n    private Coroutine _healingCoroutine;\n    \n    [System.Serializable]\n    public class PlayerHealthData\n    {\n        public GameObject player;\n        public float currentHealth;\n        public bool isHealing;\n        \n        public PlayerHealthData(GameObject playerObj)\n        {\n            player = playerObj;\n            currentHealth = 100f;\n            isHealing = false;\n        }\n    }\n    \n    private System.Collections.Generic.List<PlayerHealthData> _playersInRange = \n        new System.Collections.Generic.List<PlayerHealthData>();\n    \n    private void Start()\n    {\n        SetupComponents();\n        StartHealing();\n    }\n    \n    private void SetupComponents()\n    {\n        if (_fireParticles == null)\n            _fireParticles = GetComponentInChildren<ParticleSystem>();\n            \n        if (_fireLight == null)\n            _fireLight = GetComponentInChildren<Light>();\n            \n        if (_fireAudioSource == null)\n            _fireAudioSource = GetComponent<AudioSource>();\n            \n        if (_fireAudioSource != null)\n        {\n            _fireAudioSource.loop = true;\n            _fireAudioSource.Play();\n        }\n        \n        SphereCollider trigger = GetComponent<SphereCollider>();\n        if (trigger == null)\n        {\n            trigger = gameObject.AddComponent<SphereCollider>();\n        }\n        trigger.isTrigger = true;\n        trigger.radius = _healingRadius;\n    }\n    \n    private void StartHealing()\n    {\n        if (_healingCoroutine == null)\n        {\n            _healingCoroutine = StartCoroutine(HealingLoop());\n        }\n    }\n    \n    private void StopHealing()\n    {\n        if (_healingCoroutine != null)\n        {\n            StopCoroutine(_healingCoroutine);\n            _healingCoroutine = null;\n        }\n    }\n    \n    private IEnumerator HealingLoop()\n    {\n        while (_isActive)\n        {\n            yield return new WaitForSeconds(_healingInterval);\n            \n            for (int i = _playersInRange.Count - 1; i >= 0; i--)\n            {\n                if (_playersInRange[i].player == null)\n                {\n                    _playersInRange.RemoveAt(i);\n                    continue;\n                }\n                \n                HealPlayer(_playersInRange[i]);\n            }\n        }\n    }\n    \n    private void HealPlayer(PlayerHealthData playerData)\n    {\n        if (playerData.currentHealth >= _maxHealth) return;\n        \n        float previousHealth = playerData.currentHealth;\n        playerData.currentHealth = Mathf.Min(playerData.currentHealth + _healingRate, _maxHealth);\n        \n        float healedAmount = playerData.currentHealth - previousHealth;\n        if (healedAmount > 0)\n        {\n            OnPlayerHealed?.Invoke(playerData.player, healedAmount);\n            ShowHealingEffect(playerData.player);\n        }\n    }\n    \n    private void ShowHealingEffect(GameObject player)\n    {\n        if (_healingEffect != null)\n        {\n            GameObject effect = Instantiate(_healingEffect, player.transform.position + Vector3.up, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        PlayerHealthData existingData = _playersInRange.Find(p => p.player == other.gameObject);\n        if (existingData == null)\n        {\n            PlayerHealthData newPlayerData = new PlayerHealthData(other.gameObject);\n            _playersInRange.Add(newPlayerData);\n            OnPlayerEnterHealing?.Invoke(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == other.gameObject);\n        if (playerData != null)\n        {\n            _playersInRange.Remove(playerData);\n            OnPlayerExitHealing?.Invoke(other.gameObject);\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_fireParticles != null)\n        {\n            if (active)\n                _fireParticles.Play();\n            else\n                _fireParticles.Stop();\n        }\n        \n        if (_fireLight != null)\n            _fireLight.enabled = active;\n            \n        if (_fireAudioSource != null)\n        {\n            if (active)\n                _fireAudioSource.Play();\n            else\n                _fireAudioSource.Stop();\n        }\n        \n        if (active)\n            StartHealing();\n        else\n            StopHealing();\n    }\n    \n    public float GetPlayerHealth(GameObject player)\n    {\n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == player);\n        return playerData?.currentHealth ?? 0f;\n    }\n    \n    public void SetPlayerHealth(GameObject player, float health)\n    {\n        PlayerHealthData playerData = _playersInRange.Find(p => p.player == player);\n        if (playerData != null)\n        {\n            playerData.currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _healingRadius);\n    }\n    \n    private void OnDestroy()\n    {\n        StopHealing();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TelekinesisGrab\",\n  \"components\": [\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"grabRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"grabForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"holdDistance\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isGrabbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"grabbedObject\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_grab\",\n      \"trigger\": \"when grab input is pressed and not currently grabbing\",\n      \"actions\": [\n        {\n          \"action\": \"cast ray forward from player position\"\n        },\n        {\n          \"action\": \"find first object with rigidbody within grab range\"\n        },\n        {\n          \"action\": \"set grabbed object to the found object\"\n        },\n        {\n          \"action\": \"set is grabbing to true\"\n        },\n        {\n          \"action\": \"disable gravity on grabbed object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_grab\",\n      \"trigger\": \"when currently grabbing an object\",\n      \"actions\": [\n        {\n          \"action\": \"calculate position in front of player at hold distance\"\n        },\n        {\n          \"action\": \"apply force to move grabbed object toward target position\"\n        },\n        {\n          \"action\": \"apply damping to reduce grabbed object velocity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_grab\",\n      \"trigger\": \"when grab input is released or grab input is pressed while grabbing\",\n      \"actions\": [\n        {\n          \"action\": \"enable gravity on grabbed object\"\n        },\n        {\n          \"action\": \"set grabbed object to null\"\n        },\n        {\n          \"action\": \"set is grabbing to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_release_on_distance\",\n      \"trigger\": \"when grabbed object is too far from player\",\n      \"actions\": [\n        {\n          \"action\": \"enable gravity on grabbed object\"\n        },\n        {\n          \"action\": \"set grabbed object to null\"\n        },\n        {\n          \"action\": \"set is grabbing to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class TelekinesisGrab : MonoBehaviour\n{\n    [Header(\"Telekinesis Settings\")]\n    [SerializeField] private float _maxGrabDistance = 10f;\n    [SerializeField] private float _grabForce = 500f;\n    [SerializeField] private float _holdDistance = 3f;\n    [SerializeField] private float _rotationSpeed = 100f;\n    [SerializeField] private LayerMask _grabbableLayerMask = -1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Q;\n    [SerializeField] private KeyCode _rotateLeftKey = KeyCode.Z;\n    [SerializeField] private KeyCode _rotateRightKey = KeyCode.X;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _telekinesisBeam;\n    [SerializeField] private ParticleSystem _grabEffect;\n    [SerializeField] private Color _beamColor = Color.cyan;\n    [SerializeField] private float _beamWidth = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _holdLoopSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectGrabbed;\n    public UnityEvent<GameObject> OnObjectReleased;\n    \n    private Camera _playerCamera;\n    private GameObject _grabbedObject;\n    private Rigidbody _grabbedRigidbody;\n    private Vector3 _originalGravityScale;\n    private bool _wasKinematic;\n    private Transform _holdPoint;\n    private List<Collider> _grabbedColliders = new List<Collider>();\n    \n    [System.Serializable]\n    public class GrabbableObject\n    {\n        public Rigidbody rigidbody;\n        public Vector3 originalPosition;\n        public Quaternion originalRotation;\n        public bool wasKinematic;\n        public float originalMass;\n    }\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        CreateHoldPoint();\n        SetupLineRenderer();\n    }\n    \n    private void CreateHoldPoint()\n    {\n        GameObject holdPointObj = new GameObject(\"TelekinesisHoldPoint\");\n        _holdPoint = holdPointObj.transform;\n        _holdPoint.SetParent(transform);\n        _holdPoint.localPosition = Vector3.forward * _holdDistance;\n    }\n    \n    private void SetupLineRenderer()\n    {\n        if (_telekinesisBeam == null)\n        {\n            _telekinesisBeam = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _telekinesisBeam.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _telekinesisBeam.color = _beamColor;\n        _telekinesisBeam.startWidth = _beamWidth;\n        _telekinesisBeam.endWidth = _beamWidth;\n        _telekinesisBeam.positionCount = 2;\n        _telekinesisBeam.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateGrabbedObject();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (_grabbedObject == null)\n                TryGrabObject();\n            else\n                ReleaseObject();\n        }\n        \n        if (Input.GetKeyDown(_releaseKey) && _grabbedObject != null)\n        {\n            ReleaseObject();\n        }\n        \n        if (_grabbedObject != null)\n        {\n            HandleRotationInput();\n            HandleDistanceAdjustment();\n        }\n    }\n    \n    private void HandleRotationInput()\n    {\n        if (Input.GetKey(_rotateLeftKey))\n        {\n            _grabbedObject.transform.Rotate(Vector3.up, -_rotationSpeed * Time.deltaTime, Space.World);\n        }\n        \n        if (Input.GetKey(_rotateRightKey))\n        {\n            _grabbedObject.transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime, Space.World);\n        }\n    }\n    \n    private void HandleDistanceAdjustment()\n    {\n        float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scroll) > 0.01f)\n        {\n            _holdDistance = Mathf.Clamp(_holdDistance + scroll * 2f, 1f, _maxGrabDistance);\n            _holdPoint.localPosition = Vector3.forward * _holdDistance;\n        }\n    }\n    \n    private void TryGrabObject()\n    {\n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _maxGrabDistance, _grabbableLayerMask))\n        {\n            GameObject target = hit.collider.gameObject;\n            Rigidbody targetRb = target.GetComponent<Rigidbody>();\n            \n            if (targetRb != null && CanGrabObject(target))\n            {\n                GrabObject(target, targetRb);\n            }\n        }\n    }\n    \n    private bool CanGrabObject(GameObject obj)\n    {\n        if (obj.CompareTag(\"Player\"))\n            return false;\n            \n        TelekinesisGrab otherGrabber = obj.GetComponent<TelekinesisGrab>();\n        if (otherGrabber != null)\n            return false;\n            \n        return true;\n    }\n    \n    private void GrabObject(GameObject obj, Rigidbody rb)\n    {\n        _grabbedObject = obj;\n        _grabbedRigidbody = rb;\n        \n        _wasKinematic = rb.isKinematic;\n        rb.isKinematic = false;\n        rb.useGravity = false;\n        \n        _grabbedColliders.Clear();\n        Collider[] colliders = obj.GetComponentsInChildren<Collider>();\n        foreach (Collider col in colliders)\n        {\n            _grabbedColliders.Add(col);\n        }\n        \n        PlaySound(_grabSound);\n        \n        if (_grabEffect != null)\n        {\n            _grabEffect.transform.position = obj.transform.position;\n            _grabEffect.Play();\n        }\n        \n        OnObjectGrabbed?.Invoke(obj);\n    }\n    \n    private void UpdateGrabbedObject()\n    {\n        if (_grabbedObject == null || _grabbedRigidbody == null)\n            return;\n            \n        Vector3 targetPosition = _holdPoint.position;\n        Vector3 direction = targetPosition - _grabbedObject.transform.position;\n        \n        float distance = direction.magnitude;\n        if (distance > 0.1f)\n        {\n            Vector3 force = direction.normalized * _grabForce * distance;\n            _grabbedRigidbody.AddForce(force);\n        }\n        \n        _grabbedRigidbody.velocity *= 0.95f;\n        _grabbedRigidbody.angularVelocity *= 0.9f;\n        \n        if (Vector3.Distance(_grabbedObject.transform.position, transform.position) > _maxGrabDistance * 1.5f)\n        {\n            ReleaseObject();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_grabbedObject != null && _telekinesisBeam != null)\n        {\n            _telekinesisBeam.enabled = true;\n            _telekinesisBeam.SetPosition(0, transform.position);\n            _telekinesisBeam.SetPosition(1, _grabbedObject.transform.position);\n        }\n        else if (_telekinesisBeam != null)\n        {\n            _telekinesisBeam.enabled = false;\n        }\n    }\n    \n    private void ReleaseObject()\n    {\n        if (_grabbedObject == null)\n            return;\n            \n        if (_grabbedRigidbody != null)\n        {\n            _grabbedRigidbody.isKinematic = _wasKinematic;\n            _grabbedRigidbody.useGravity = true;\n        }\n        \n        PlaySound(_releaseSound);\n        \n        OnObjectReleased?.Invoke(_grabbedObject);\n        \n        _grabbedObject = null;\n        _grabbedRigidbody = null;\n        _grabbedColliders.Clear();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxGrabDistance);\n        \n        if (_holdPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPoint.position, 0.2f);\n            Gizmos.DrawLine(transform.position, _holdPoint.position);\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_grabbedObject != null)\n        {\n            ReleaseObject();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HelicopterController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"targetAltitude\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"maxAltitude\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"minAltitude\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"altitudeSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"hoverForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"stabilityForce\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"rotorSpeed\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"enginePower\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"maintain_target_altitude\",\n      \"trigger\": \"every frame while helicopter is active\",\n      \"actions\": [\n        {\n          \"action\": \"check current altitude against target altitude\"\n        },\n        {\n          \"action\": \"apply upward force when below target altitude\"\n        },\n        {\n          \"action\": \"apply downward force when above target altitude\"\n        },\n        {\n          \"action\": \"adjust force strength based on altitude difference\"\n        }\n      ]\n    },\n    {\n      \"name\": \"altitude_input_control\",\n      \"trigger\": \"when altitude increase input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase target altitude within maximum limit\"\n        },\n        {\n          \"action\": \"play engine acceleration sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"altitude_decrease_control\",\n      \"trigger\": \"when altitude decrease input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"decrease target altitude within minimum limit\"\n        },\n        {\n          \"action\": \"play engine deceleration sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hover_stabilization\",\n      \"trigger\": \"when helicopter velocity is low and near target altitude\",\n      \"actions\": [\n        {\n          \"action\": \"apply gentle upward hover force to counteract gravity\"\n        },\n        {\n          \"action\": \"reduce horizontal drift with stabilizing forces\"\n        }\n      ]\n    },\n    {\n      \"name\": \"altitude_safety_limits\",\n      \"trigger\": \"when helicopter approaches maximum or minimum altitude\",\n      \"actions\": [\n        {\n          \"action\": \"prevent further altitude changes beyond safe limits\"\n        },\n        {\n          \"action\": \"play warning sound when near altitude boundaries\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotor_sound_control\",\n      \"trigger\": \"every frame based on engine power and altitude changes\",\n      \"actions\": [\n        {\n          \"action\": \"adjust rotor sound pitch based on engine power\"\n        },\n        {\n          \"action\": \"modify rotor sound volume based on altitude change rate\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HelicopterController : MonoBehaviour\n{\n    [Header(\"Flight Controls\")]\n    [SerializeField] private float _liftForce = 1000f;\n    [SerializeField] private float _maxAltitude = 100f;\n    [SerializeField] private float _minAltitude = 0.5f;\n    [SerializeField] private float _altitudeControlSensitivity = 2f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _forwardSpeed = 20f;\n    [SerializeField] private float _sidewaysSpeed = 15f;\n    [SerializeField] private float _rotationSpeed = 50f;\n    \n    [Header(\"Stability\")]\n    [SerializeField] private float _stabilizationForce = 500f;\n    [SerializeField] private float _tiltAmount = 15f;\n    [SerializeField] private float _tiltSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _rotorAudioSource;\n    [SerializeField] private float _minRotorPitch = 0.5f;\n    [SerializeField] private float _maxRotorPitch = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private float _dustEffectHeight = 5f;\n    \n    private Rigidbody _rigidbody;\n    private float _currentThrottle;\n    private float _targetAltitude;\n    private Vector3 _initialRotation;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = 1000f;\n        _rigidbody.drag = 1f;\n        _rigidbody.angularDrag = 5f;\n        \n        _initialRotation = transform.eulerAngles;\n        _targetAltitude = transform.position.y;\n        \n        if (_rotorAudioSource == null)\n        {\n            _rotorAudioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateAudio();\n        UpdateEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyLift();\n        ApplyMovement();\n        ApplyStabilization();\n        CheckGroundContact();\n    }\n    \n    private void HandleInput()\n    {\n        float throttleInput = Input.GetAxis(\"Vertical\");\n        float yawInput = Input.GetAxis(\"Horizontal\");\n        \n        _currentThrottle = Mathf.Clamp01(_currentThrottle + throttleInput * Time.deltaTime * _altitudeControlSensitivity);\n        \n        if (Input.GetKey(KeyCode.Q))\n        {\n            _targetAltitude = Mathf.Min(_targetAltitude + 10f * Time.deltaTime, _maxAltitude);\n        }\n        if (Input.GetKey(KeyCode.E))\n        {\n            _targetAltitude = Mathf.Max(_targetAltitude - 10f * Time.deltaTime, _minAltitude);\n        }\n        \n        if (Mathf.Abs(yawInput) > 0.1f)\n        {\n            transform.Rotate(0, yawInput * _rotationSpeed * Time.deltaTime, 0);\n        }\n    }\n    \n    private void ApplyLift()\n    {\n        float currentAltitude = transform.position.y;\n        float altitudeDifference = _targetAltitude - currentAltitude;\n        \n        float liftMultiplier = _currentThrottle;\n        \n        if (Mathf.Abs(altitudeDifference) > 0.5f)\n        {\n            liftMultiplier += Mathf.Sign(altitudeDifference) * 0.5f;\n        }\n        \n        liftMultiplier = Mathf.Clamp01(liftMultiplier);\n        \n        Vector3 liftVector = Vector3.up * _liftForce * liftMultiplier;\n        _rigidbody.AddForce(liftVector);\n        \n        Vector3 counterGravity = -Physics.gravity * _rigidbody.mass * 0.8f;\n        _rigidbody.AddForce(counterGravity);\n    }\n    \n    private void ApplyMovement()\n    {\n        float forwardInput = 0f;\n        float sidewaysInput = 0f;\n        \n        if (Input.GetKey(KeyCode.W)) forwardInput = 1f;\n        if (Input.GetKey(KeyCode.S)) forwardInput = -1f;\n        if (Input.GetKey(KeyCode.A)) sidewaysInput = -1f;\n        if (Input.GetKey(KeyCode.D)) sidewaysInput = 1f;\n        \n        Vector3 forwardForce = transform.forward * forwardInput * _forwardSpeed;\n        Vector3 sidewaysForce = transform.right * sidewaysInput * _sidewaysSpeed;\n        \n        _rigidbody.AddForce(forwardForce + sidewaysForce);\n        \n        float tiltX = -forwardInput * _tiltAmount;\n        float tiltZ = -sidewaysInput * _tiltAmount;\n        \n        Vector3 targetRotation = new Vector3(\n            _initialRotation.x + tiltX,\n            transform.eulerAngles.y,\n            _initialRotation.z + tiltZ\n        );\n        \n        transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(targetRotation), _tiltSpeed * Time.deltaTime);\n    }\n    \n    private void ApplyStabilization()\n    {\n        Vector3 stabilizationForce = -_rigidbody.velocity * _stabilizationForce * Time.fixedDeltaTime;\n        stabilizationForce.y *= 0.1f;\n        _rigidbody.AddForce(stabilizationForce);\n        \n        Vector3 angularStabilization = -_rigidbody.angularVelocity * _stabilizationForce * 0.1f * Time.fixedDeltaTime;\n        _rigidbody.AddTorque(angularStabilization);\n    }\n    \n    private void CheckGroundContact()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _minAltitude + 0.5f);\n        \n        if (_isGrounded && hit.distance < _minAltitude)\n        {\n            Vector3 position = transform.position;\n            position.y = hit.point.y + _minAltitude;\n            transform.position = position;\n            \n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = Mathf.Max(velocity.y, 0f);\n            _rigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_rotorAudioSource != null)\n        {\n            float pitchTarget = Mathf.Lerp(_minRotorPitch, _maxRotorPitch, _currentThrottle);\n            _rotorAudioSource.pitch = Mathf.Lerp(_rotorAudioSource.pitch, pitchTarget, Time.deltaTime * 2f);\n            \n            if (!_rotorAudioSource.isPlaying)\n            {\n                _rotorAudioSource.Play();\n            }\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_dustEffect != null)\n        {\n            bool shouldPlayDust = _isGrounded && transform.position.y < _dustEffectHeight;\n            \n            if (shouldPlayDust && !_dustEffect.isPlaying)\n            {\n                _dustEffect.Play();\n            }\n            else if (!shouldPlayDust && _dustEffect.isPlaying)\n            {\n                _dustEffect.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.up * _targetAltitude, 1f);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * _maxAltitude, Vector3.one * 2f);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * _minAltitude, Vector3.one * 2f);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(transform.position, Vector3.down * (_minAltitude + 0.5f));\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MotorcycleController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 80\n    },\n    {\n      \"name\": \"leanAngle\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"leanSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"currentSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"currentLean\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate_forward\",\n      \"trigger\": \"when forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase speed toward maximum speed using acceleration rate\"\n        },\n        {\n          \"action\": \"move motorcycle forward at current speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decelerate\",\n      \"trigger\": \"when no forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce speed to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_left_with_lean\",\n      \"trigger\": \"when left turn input is pressed and motorcycle is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate motorcycle left at turn speed based on current speed\"\n        },\n        {\n          \"action\": \"lean motorcycle left toward maximum lean angle\"\n        },\n        {\n          \"action\": \"smoothly interpolate lean rotation over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_right_with_lean\",\n      \"trigger\": \"when right turn input is pressed and motorcycle is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate motorcycle right at turn speed based on current speed\"\n        },\n        {\n          \"action\": \"lean motorcycle right toward maximum lean angle\"\n        },\n        {\n          \"action\": \"smoothly interpolate lean rotation over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_upright\",\n      \"trigger\": \"when no turn input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"gradually return motorcycle to upright position\"\n        },\n        {\n          \"action\": \"smoothly reduce lean angle to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_turning_when_stopped\",\n      \"trigger\": \"when motorcycle speed is zero\",\n      \"actions\": [\n        {\n          \"action\": \"disable turning and leaning\"\n        },\n        {\n          \"action\": \"keep motorcycle upright\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MotorcycleController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 30f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 15f;\n    [SerializeField] private float _brakeForce = 25f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _reverseSpeed = 10f;\n\n    [Header(\"Leaning Settings\")]\n    [SerializeField] private float _maxLeanAngle = 45f;\n    [SerializeField] private float _leanSpeed = 3f;\n    [SerializeField] private float _leanReturnSpeed = 2f;\n    [SerializeField] private Transform _motorcycleBody;\n\n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _downForce = 100f;\n    [SerializeField] private float _centerOfMassOffset = -0.5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _engineIdleClip;\n    [SerializeField] private AudioClip _engineRevClip;\n    [SerializeField] private float _minPitch = 0.8f;\n    [SerializeField] private float _maxPitch = 2f;\n\n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private float _motorInput;\n    private float _steerInput;\n    private float _currentLeanAngle;\n    private bool _isGrounded;\n    private Vector3 _originalCenterOfMass;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n\n        _originalCenterOfMass = _rigidbody.centerOfMass;\n        _rigidbody.centerOfMass = _originalCenterOfMass + Vector3.up * _centerOfMassOffset;\n\n        if (_motorcycleBody == null)\n        {\n            _motorcycleBody = transform;\n        }\n\n        if (_engineAudioSource == null)\n        {\n            _engineAudioSource = gameObject.AddComponent<AudioSource>();\n            _engineAudioSource.loop = true;\n            _engineAudioSource.playOnAwake = false;\n        }\n\n        if (_engineIdleClip != null)\n        {\n            _engineAudioSource.clip = _engineIdleClip;\n            _engineAudioSource.Play();\n        }\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        CheckGrounded();\n        UpdateEngineAudio();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isGrounded)\n        {\n            HandleMotorcycleMovement();\n            HandleLeaning();\n            ApplyDownForce();\n        }\n    }\n\n    private void HandleInput()\n    {\n        _motorInput = Input.GetAxis(\"Vertical\");\n        _steerInput = Input.GetAxis(\"Horizontal\");\n    }\n\n    private void HandleMotorcycleMovement()\n    {\n        _currentSpeed = Vector3.Dot(_rigidbody.velocity, transform.forward);\n\n        // Forward/Backward movement\n        if (_motorInput > 0)\n        {\n            // Accelerating forward\n            if (_currentSpeed < _maxSpeed)\n            {\n                _rigidbody.AddForce(transform.forward * _motorInput * _acceleration, ForceMode.Acceleration);\n            }\n        }\n        else if (_motorInput < 0)\n        {\n            if (_currentSpeed > 0)\n            {\n                // Braking\n                _rigidbody.AddForce(transform.forward * _motorInput * _brakeForce, ForceMode.Acceleration);\n            }\n            else if (_currentSpeed > -_reverseSpeed)\n            {\n                // Reversing\n                _rigidbody.AddForce(transform.forward * _motorInput * _acceleration * 0.5f, ForceMode.Acceleration);\n            }\n        }\n        else\n        {\n            // Natural deceleration\n            _rigidbody.AddForce(-_rigidbody.velocity * _deceleration * 0.1f, ForceMode.Acceleration);\n        }\n\n        // Steering (only when moving)\n        if (Mathf.Abs(_currentSpeed) > 0.1f && Mathf.Abs(_steerInput) > 0.1f)\n        {\n            float steerAmount = _steerInput * _turnSpeed * (_currentSpeed / _maxSpeed) * Time.fixedDeltaTime;\n            transform.Rotate(0, steerAmount, 0);\n        }\n    }\n\n    private void HandleLeaning()\n    {\n        float targetLeanAngle = 0f;\n\n        // Calculate lean angle based on steering input and speed\n        if (Mathf.Abs(_steerInput) > 0.1f && Mathf.Abs(_currentSpeed) > 1f)\n        {\n            float speedFactor = Mathf.Clamp01(Mathf.Abs(_currentSpeed) / _maxSpeed);\n            targetLeanAngle = -_steerInput * _maxLeanAngle * speedFactor;\n        }\n\n        // Smoothly interpolate to target lean angle\n        float lerpSpeed = Mathf.Abs(targetLeanAngle) > Mathf.Abs(_currentLeanAngle) ? _leanSpeed : _leanReturnSpeed;\n        _currentLeanAngle = Mathf.Lerp(_currentLeanAngle, targetLeanAngle, lerpSpeed * Time.fixedDeltaTime);\n\n        // Apply lean rotation to motorcycle body\n        if (_motorcycleBody != null)\n        {\n            Vector3 currentRotation = _motorcycleBody.localEulerAngles;\n            _motorcycleBody.localRotation = Quaternion.Euler(currentRotation.x, currentRotation.y, _currentLeanAngle);\n        }\n    }\n\n    private void CheckGrounded()\n    {\n        float rayDistance = 1.5f;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, rayDistance, _groundLayer);\n    }\n\n    private void ApplyDownForce()\n    {\n        if (_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.down * _downForce * _rigidbody.velocity.magnitude, ForceMode.Force);\n        }\n    }\n\n    private void UpdateEngineAudio()\n    {\n        if (_engineAudioSource != null)\n        {\n            float speedRatio = Mathf.Abs(_currentSpeed) / _maxSpeed;\n            float inputRatio = Mathf.Abs(_motorInput);\n            \n            float targetPitch = Mathf.Lerp(_minPitch, _maxPitch, Mathf.Max(speedRatio, inputRatio * 0.5f));\n            _engineAudioSource.pitch = Mathf.Lerp(_engineAudioSource.pitch, targetPitch, Time.deltaTime * 3f);\n\n            float targetVolume = Mathf.Lerp(0.3f, 1f, Mathf.Max(speedRatio, inputRatio * 0.3f));\n            _engineAudioSource.volume = Mathf.Lerp(_engineAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n\n            // Switch between idle and rev clips based on input\n            if (_motorInput > 0.1f && _engineRevClip != null && _engineAudioSource.clip != _engineRevClip)\n            {\n                _engineAudioSource.clip = _engineRevClip;\n                _engineAudioSource.Play();\n            }\n            else if (_motorInput <= 0.1f && _engineIdleClip != null && _engineAudioSource.clip != _engineIdleClip)\n            {\n                _engineAudioSource.clip = _engineIdleClip;\n                _engineAudioSource.Play();\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Draw ground check ray\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * 1.5f);\n\n        // Draw center of mass\n        Gizmos.color = Color.yellow;\n        if (_rigidbody != null)\n        {\n            Gizmos.DrawSphere(transform.TransformPoint(_rigidbody.centerOfMass), 0.1f);\n        }\n\n        // Draw lean angle visualization\n        Gizmos.color = Color.blue;\n        Vector3 leanDirection = Quaternion.AngleAxis(_currentLeanAngle, transform.forward) * transform.right;\n        Gizmos.DrawRay(transform.position, leanDirection * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SlipperySlope\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slipperiness\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"slopeAngle\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"slideForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_slippery_physics\",\n      \"trigger\": \"when object with rigidbody touches this surface\",\n      \"actions\": [\n        {\n          \"action\": \"reduce friction between touching object and slope surface\"\n        },\n        {\n          \"action\": \"apply downward sliding force along slope direction\"\n        },\n        {\n          \"action\": \"prevent object from gripping or stopping on slope\"\n        }\n      ]\n    },\n    {\n      \"name\": \"increase_slide_over_time\",\n      \"trigger\": \"while object remains on slippery slope\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase sliding speed\"\n        },\n        {\n          \"action\": \"make object harder to control while sliding\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_slipping_effect\",\n      \"trigger\": \"when object leaves the slope surface\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal friction to the object\"\n        },\n        {\n          \"action\": \"stop applying sliding forces\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SlipperySlope : MonoBehaviour\n{\n    [Header(\"Slippery Surface Settings\")]\n    [SerializeField] private float _slipperiness = 0.95f;\n    [SerializeField] private float _slopeForce = 10f;\n    [SerializeField] private float _maxSlideSpeed = 15f;\n    [SerializeField] private bool _affectsPlayer = true;\n    [SerializeField] private bool _affectsObjects = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _slideParticles;\n    [SerializeField] private AudioSource _slideAudioSource;\n    [SerializeField] private AudioClip _slideSound;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private PhysicMaterial _slipperyMaterial;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    private Collider _surfaceCollider;\n    private Vector3 _slopeDirection;\n    private float _slopeAngle;\n    \n    private void Start()\n    {\n        _surfaceCollider = GetComponent<Collider>();\n        if (_surfaceCollider == null)\n        {\n            Debug.LogError(\"SlipperySlope requires a Collider component!\");\n            return;\n        }\n        \n        CalculateSlopeDirection();\n        SetupSlipperyMaterial();\n        \n        if (_slideAudioSource == null)\n        {\n            _slideAudioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void CalculateSlopeDirection()\n    {\n        Vector3 forward = transform.forward;\n        Vector3 up = transform.up;\n        \n        _slopeDirection = Vector3.ProjectOnPlane(forward, Vector3.up).normalized;\n        _slopeAngle = Vector3.Angle(up, Vector3.up);\n        \n        if (_slopeAngle < 1f)\n        {\n            _slopeDirection = -transform.up;\n        }\n    }\n    \n    private void SetupSlipperyMaterial()\n    {\n        if (_slipperyMaterial == null)\n        {\n            _slipperyMaterial = new PhysicMaterial(\"SlipperyMaterial\");\n            _slipperyMaterial.dynamicFriction = 0.1f;\n            _slipperyMaterial.staticFriction = 0.1f;\n            _slipperyMaterial.frictionCombine = PhysicMaterialCombine.Minimum;\n        }\n        \n        if (_surfaceCollider != null)\n        {\n            _surfaceCollider.material = _slipperyMaterial;\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (!IsAffectedObject(other)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb == null) return;\n        \n        ApplySlipperyEffect(rb, other);\n    }\n    \n    private void OnCollisionStay(Collision collision)\n    {\n        if (!IsAffectedObject(collision.collider)) return;\n        \n        Rigidbody rb = collision.rigidbody;\n        if (rb == null) return;\n        \n        ApplySlipperyEffect(rb, collision.collider);\n    }\n    \n    private bool IsAffectedObject(Collider other)\n    {\n        if ((_affectedLayers.value & (1 << other.gameObject.layer)) == 0)\n            return false;\n        \n        if (other.CompareTag(\"Player\") && !_affectsPlayer)\n            return false;\n        \n        if (!other.CompareTag(\"Player\") && !_affectsObjects)\n            return false;\n        \n        return true;\n    }\n    \n    private void ApplySlipperyEffect(Rigidbody rb, Collider other)\n    {\n        Vector3 slopeForceVector = _slopeDirection * _slopeForce;\n        Vector3 currentVelocity = rb.velocity;\n        \n        Vector3 slideVelocity = Vector3.Lerp(currentVelocity, \n            currentVelocity + slopeForceVector, _slipperiness * Time.fixedDeltaTime);\n        \n        slideVelocity = Vector3.ClampMagnitude(slideVelocity, _maxSlideSpeed);\n        \n        rb.velocity = slideVelocity;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            DisablePlayerControl(other);\n        }\n        \n        PlaySlideEffects(other.transform.position);\n    }\n    \n    private void DisablePlayerControl(Collider playerCollider)\n    {\n        CharacterController characterController = playerCollider.GetComponent<CharacterController>();\n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            StartCoroutine(ReenableCharacterController(characterController));\n        }\n    }\n    \n    private System.Collections.IEnumerator ReenableCharacterController(CharacterController controller)\n    {\n        yield return new WaitForSeconds(0.1f);\n        if (controller != null)\n        {\n            controller.enabled = true;\n        }\n    }\n    \n    private void PlaySlideEffects(Vector3 position)\n    {\n        if (_slideParticles != null && !_slideParticles.isPlaying)\n        {\n            _slideParticles.transform.position = position;\n            _slideParticles.Play();\n        }\n        \n        if (_slideAudioSource != null && _slideSound != null && !_slideAudioSource.isPlaying)\n        {\n            _slideAudioSource.clip = _slideSound;\n            _slideAudioSource.Play();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            RestorePlayerControl(other);\n        }\n        \n        StopSlideEffects();\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        if (collision.collider.CompareTag(\"Player\"))\n        {\n            RestorePlayerControl(collision.collider);\n        }\n        \n        StopSlideEffects();\n    }\n    \n    private void RestorePlayerControl(Collider playerCollider)\n    {\n        CharacterController characterController = playerCollider.GetComponent<CharacterController>();\n        if (characterController != null && !characterController.enabled)\n        {\n            characterController.enabled = true;\n        }\n    }\n    \n    private void StopSlideEffects()\n    {\n        if (_slideParticles != null && _slideParticles.isPlaying)\n        {\n            _slideParticles.Stop();\n        }\n        \n        if (_slideAudioSource != null && _slideAudioSource.isPlaying)\n        {\n            _slideAudioSource.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawRay(transform.position, _slopeDirection * 3f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n    }\n    \n    public void SetSlipperiness(float value)\n    {\n        _slipperiness = Mathf.Clamp01(value);\n    }\n    \n    public void SetSlopeForce(float value)\n    {\n        _slopeForce = Mathf.Max(0f, value);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WaterCurrent\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentStrength\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"currentDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.right\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"push_player\",\n      \"trigger\": \"when player enters water current area\",\n      \"actions\": [\n        {\n          \"action\": \"apply continuous force to player in current direction with current strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_pushing\",\n      \"trigger\": \"when player exits water current area\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying current force to player\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class WaterCurrent : MonoBehaviour\n{\n    [Header(\"Current Settings\")]\n    [SerializeField] private Vector3 _currentDirection = Vector3.forward;\n    [SerializeField] private float _currentStrength = 5f;\n    [SerializeField] private bool _useLocalDirection = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _particleEffect;\n    [SerializeField] private bool _showGizmos = true;\n    [SerializeField] private Color _gizmoColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _waterFlowClip;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Force Settings\")]\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    [SerializeField] private float _maxVelocity = 10f;\n    [SerializeField] private bool _limitVelocity = true;\n    \n    private Collider _currentCollider;\n    \n    private void Start()\n    {\n        _currentCollider = GetComponent<Collider>();\n        if (_currentCollider == null)\n        {\n            Debug.LogWarning(\"WaterCurrent requires a Collider component to function properly.\");\n        }\n        \n        if (_currentCollider != null && !_currentCollider.isTrigger)\n        {\n            _currentCollider.isTrigger = true;\n        }\n        \n        SetupAudio();\n        SetupParticles();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _waterFlowClip != null)\n        {\n            _audioSource.clip = _waterFlowClip;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            main.loop = true;\n            \n            var velocityOverLifetime = _particleEffect.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            \n            Vector3 particleDirection = _useLocalDirection ? transform.TransformDirection(_currentDirection) : _currentDirection;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            velocityOverLifetime.x = particleDirection.x * _currentStrength * 0.5f;\n            velocityOverLifetime.y = particleDirection.y * _currentStrength * 0.5f;\n            velocityOverLifetime.z = particleDirection.z * _currentStrength * 0.5f;\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ApplyCurrentForce(other);\n        }\n    }\n    \n    private void ApplyCurrentForce(Collider target)\n    {\n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        if (targetRigidbody == null) return;\n        \n        Vector3 forceDirection = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        Vector3 force = forceDirection * _currentStrength;\n        \n        if (_limitVelocity)\n        {\n            Vector3 currentVelocity = targetRigidbody.velocity;\n            Vector3 projectedVelocity = Vector3.Project(currentVelocity, forceDirection);\n            \n            if (projectedVelocity.magnitude < _maxVelocity)\n            {\n                targetRigidbody.AddForce(force, _forceMode);\n            }\n        }\n        else\n        {\n            targetRigidbody.AddForce(force, _forceMode);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_currentStrength < 0f)\n            _currentStrength = 0f;\n            \n        if (_maxVelocity < 0f)\n            _maxVelocity = 0f;\n            \n        if (_audioVolume < 0f)\n            _audioVolume = 0f;\n        else if (_audioVolume > 1f)\n            _audioVolume = 1f;\n            \n        if (Application.isPlaying)\n        {\n            SetupParticles();\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = _gizmoColor;\n        \n        Vector3 center = transform.position;\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        \n        Gizmos.DrawRay(center, direction * _currentStrength);\n        \n        Gizmos.color = new Color(_gizmoColor.r, _gizmoColor.g, _gizmoColor.b, 0.3f);\n        if (_currentCollider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            if (_currentCollider is BoxCollider box)\n            {\n                Gizmos.DrawCube(box.center, box.size);\n            }\n            else if (_currentCollider is SphereCollider sphere)\n            {\n                Gizmos.DrawSphere(sphere.center, sphere.radius);\n            }\n        }\n        \n        Gizmos.matrix = Matrix4x4.identity;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = Color.white;\n        Vector3 center = transform.position;\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_currentDirection.normalized) : _currentDirection.normalized;\n        \n        for (int i = 0; i < 5; i++)\n        {\n            float offset = i * 0.5f;\n            Gizmos.DrawRay(center + direction * offset, direction * 0.3f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RollingBoulderTrap\",\n  \"components\": [\n    \"Rigidbody\",\n    \"SphereCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rollSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"rollDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_approach\",\n      \"trigger\": \"when player enters detection range and trap is not already activated\",\n      \"actions\": [\n        {\n          \"action\": \"set trap to activated state\"\n        },\n        {\n          \"action\": \"play boulder rolling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"roll_boulder\",\n      \"trigger\": \"when trap is activated\",\n      \"actions\": [\n        {\n          \"action\": \"apply rolling force in specified direction at roll speed\"\n        },\n        {\n          \"action\": \"enable physics simulation for realistic rolling motion\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_on_collision\",\n      \"trigger\": \"when boulder collides with player\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage amount to player\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"apply knockback force to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_on_obstacle\",\n      \"trigger\": \"when boulder hits wall or large obstacle\",\n      \"actions\": [\n        {\n          \"action\": \"play destruction sound effect\"\n        },\n        {\n          \"action\": \"create debris particle effects\"\n        },\n        {\n          \"action\": \"destroy boulder object after short delay\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RollingBoulderTrap : MonoBehaviour\n{\n    [Header(\"Boulder Settings\")]\n    [SerializeField] private GameObject boulderPrefab;\n    [SerializeField] private Transform spawnPoint;\n    [SerializeField] private float boulderSpeed = 10f;\n    [SerializeField] private float boulderMass = 100f;\n    [SerializeField] private float boulderLifetime = 15f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool triggerOnPlayerEnter = true;\n    [SerializeField] private bool triggerOnce = true;\n    [SerializeField] private float triggerDelay = 0.5f;\n    [SerializeField] private string playerTag = \"Player\";\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float gravity = -9.81f;\n    [SerializeField] private LayerMask groundLayer = 1;\n    [SerializeField] private float bounceForce = 5f;\n    [SerializeField] private float rollingResistance = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip boulderRollSound;\n    [SerializeField] private AudioClip boulderCrashSound;\n    [SerializeField] private float audioVolume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem dustEffect;\n    [SerializeField] private GameObject impactEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTrapTriggered;\n    public UnityEvent OnBoulderSpawned;\n    public UnityEvent OnBoulderDestroyed;\n    \n    private bool _hasTriggered = false;\n    private AudioSource _audioSource;\n    private Collider _triggerCollider;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider != null)\n        {\n            _triggerCollider.isTrigger = true;\n        }\n        \n        if (spawnPoint == null)\n        {\n            spawnPoint = transform;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!triggerOnPlayerEnter) return;\n        if (triggerOnce && _hasTriggered) return;\n        if (!other.CompareTag(playerTag)) return;\n        \n        TriggerTrap();\n    }\n    \n    public void TriggerTrap()\n    {\n        if (triggerOnce && _hasTriggered) return;\n        \n        _hasTriggered = true;\n        OnTrapTriggered?.Invoke();\n        \n        if (triggerDelay > 0)\n        {\n            Invoke(nameof(SpawnBoulder), triggerDelay);\n        }\n        else\n        {\n            SpawnBoulder();\n        }\n    }\n    \n    private void SpawnBoulder()\n    {\n        if (boulderPrefab == null || spawnPoint == null) return;\n        \n        GameObject boulder = Instantiate(boulderPrefab, spawnPoint.position, spawnPoint.rotation);\n        \n        BoulderController boulderController = boulder.GetComponent<BoulderController>();\n        if (boulderController == null)\n        {\n            boulderController = boulder.AddComponent<BoulderController>();\n        }\n        \n        boulderController.Initialize(this, boulderSpeed, boulderMass, boulderLifetime, gravity, \n                                   groundLayer, bounceForce, rollingResistance);\n        \n        OnBoulderSpawned?.Invoke();\n        \n        if (boulderRollSound != null && _audioSource != null)\n        {\n            _audioSource.clip = boulderRollSound;\n            _audioSource.volume = audioVolume;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        if (dustEffect != null)\n        {\n            dustEffect.Play();\n        }\n    }\n    \n    public void OnBoulderImpact(Vector3 position)\n    {\n        if (impactEffectPrefab != null)\n        {\n            Instantiate(impactEffectPrefab, position, Quaternion.identity);\n        }\n        \n        if (boulderCrashSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(boulderCrashSound, audioVolume);\n        }\n    }\n    \n    public void OnBoulderDestroyedCallback()\n    {\n        OnBoulderDestroyed?.Invoke();\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (dustEffect != null && dustEffect.isPlaying)\n        {\n            dustEffect.Stop();\n        }\n    }\n    \n    public void ResetTrap()\n    {\n        _hasTriggered = false;\n    }\n}\n\npublic class BoulderController : MonoBehaviour\n{\n    private RollingBoulderTrap _parentTrap;\n    private float _speed;\n    private float _mass;\n    private float _lifetime;\n    private float _gravity;\n    private LayerMask _groundLayer;\n    private float _bounceForce;\n    private float _rollingResistance;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private float _currentLifetime;\n    private Vector3 _velocity;\n    \n    public void Initialize(RollingBoulderTrap parentTrap, float speed, float mass, float lifetime, \n                          float gravity, LayerMask groundLayer, float bounceForce, float rollingResistance)\n    {\n        _parentTrap = parentTrap;\n        _speed = speed;\n        _mass = mass;\n        _lifetime = lifetime;\n        _gravity = gravity;\n        _groundLayer = groundLayer;\n        _bounceForce = bounceForce;\n        _rollingResistance = rollingResistance;\n        \n        SetupRigidbody();\n        _velocity = transform.forward * _speed;\n        _currentLifetime = _lifetime;\n    }\n    \n    private void SetupRigidbody()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        _rigidbody.drag = _rollingResistance;\n        _rigidbody.angularDrag = 0.5f;\n        \n        if (GetComponent<Collider>() == null)\n        {\n            gameObject.AddComponent<SphereCollider>();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        CheckGrounded();\n        ApplyMovement();\n        UpdateLifetime();\n    }\n    \n    private void CheckGrounded()\n    {\n        float radius = GetComponent<Collider>().bounds.size.y * 0.5f;\n        _isGrounded = Physics.CheckSphere(transform.position, radius + 0.1f, _groundLayer);\n    }\n    \n    private void ApplyMovement()\n    {\n        if (!_isGrounded)\n        {\n            _velocity.y += _gravity * Time.fixedDeltaTime;\n        }\n        else\n        {\n            if (_velocity.y < 0)\n            {\n                _velocity.y = 0;\n            }\n        }\n        \n        _rigidbody.velocity = _velocity;\n        \n        if (_isGrounded && _velocity.magnitude > 0.1f)\n        {\n            float rotationSpeed = _velocity.magnitude / (GetComponent<Collider>().bounds.size.x * 0.5f);\n            transform.Rotate(Vector3.right, rotationSpeed * Time.fixedDeltaTime * Mathf.Rad2Deg);\n        }\n    }\n    \n    private void UpdateLifetime()\n    {\n        _currentLifetime -= Time.fixedDeltaTime;\n        if (_currentLifetime <= 0)\n        {\n            DestroyBoulder();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            Rigidbody playerRb = collision.gameObject.GetComponent<Rigidbody>();\n            if (playerRb != null)\n            {\n                Vector3 pushDirection = (collision.transform.position - transform.position).normalized;\n                playerRb.AddForce(pushDirection * _bounceForce, ForceMode.Impulse);\n            }\n        }\n        \n        if ((_groundLayer.value & (1 << collision.gameObject.layer)) != 0)\n        {\n            Vector3 bounceDirection = Vector3.Reflect(_velocity.normalized, collision.contacts[0].normal);\n            _velocity = bounceDirection * _velocity.magnitude * 0.7f;\n            \n            if (_parentTrap != null)\n            {\n                _parentTrap.OnBoulderImpact(collision.contacts[0].point);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"BoulderDestroyer\") || other.CompareTag(\"DeathZone\"))\n        {\n            DestroyBoulder();\n        }\n    }\n    \n    private void DestroyBoulder()\n    {\n        if (_parentTrap != null)\n        {\n            _parentTrap.OnBoulderDestroyedCallback();\n        }\n        \n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AutoDoor\",\n  \"components\": [\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"open_door_on_approach\",\n      \"trigger\": \"when player enters detection radius and door is closed\",\n      \"actions\": [\n        {\n          \"action\": \"play door opening animation\"\n        },\n        {\n          \"action\": \"set door state to open\"\n        }\n      ]\n    },\n    {\n      \"name\": \"close_door_on_exit\",\n      \"trigger\": \"when player leaves detection radius and door is open\",\n      \"actions\": [\n        {\n          \"action\": \"play door closing animation\"\n        },\n        {\n          \"action\": \"set door state to closed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ProximityDoor : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private float _detectionRange = 3f;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private float _closeSpeed = 1f;\n    [SerializeField] private Vector3 _openOffset = new Vector3(0, 3f, 0);\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Door Components\")]\n    [SerializeField] private Transform _doorTransform;\n    [SerializeField] private Collider _doorCollider;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorClosed;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        InitializeDoor();\n    }\n    \n    private void InitializeDoor()\n    {\n        if (_doorTransform == null)\n            _doorTransform = transform;\n            \n        _closedPosition = _doorTransform.localPosition;\n        _openPosition = _closedPosition + _openOffset;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleDoorMovement();\n    }\n    \n    private void CheckForPlayer()\n    {\n        bool playerWasInRange = _playerInRange;\n        _playerInRange = false;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _playerLayer);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n                break;\n            }\n        }\n        \n        if (_playerInRange && !playerWasInRange)\n        {\n            OpenDoor();\n        }\n        else if (!_playerInRange && playerWasInRange)\n        {\n            CloseDoor();\n        }\n    }\n    \n    private void HandleDoorMovement()\n    {\n        if (!_isMoving) return;\n        \n        Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n        float speed = _isOpen ? _openSpeed : _closeSpeed;\n        \n        _doorTransform.localPosition = Vector3.MoveTowards(\n            _doorTransform.localPosition, \n            targetPosition, \n            speed * Time.deltaTime\n        );\n        \n        if (Vector3.Distance(_doorTransform.localPosition, targetPosition) < 0.01f)\n        {\n            _doorTransform.localPosition = targetPosition;\n            _isMoving = false;\n            \n            if (_doorCollider != null)\n                _doorCollider.enabled = !_isOpen;\n        }\n    }\n    \n    private void OpenDoor()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        PlaySound(_openSound);\n        OnDoorOpened?.Invoke();\n    }\n    \n    private void CloseDoor()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _isMoving = true;\n        \n        PlaySound(_closeSound);\n        OnDoorClosed?.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_doorTransform != null)\n        {\n            Gizmos.color = Color.green;\n            Vector3 openPos = transform.TransformPoint(_closedPosition + _openOffset);\n            Gizmos.DrawWireCube(openPos, _doorTransform.localScale);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MeleeWeapon\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"comboWindow\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"attackCooldown\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"comboCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxComboCount\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"comboDamageMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"isAttacking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canCombo\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_attack\",\n      \"trigger\": \"when attack input is pressed and weapon is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"start attack animation\"\n        },\n        {\n          \"action\": \"set attacking state to true\"\n        },\n        {\n          \"action\": \"enable weapon collider\"\n        },\n        {\n          \"action\": \"play attack sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combo_attack\",\n      \"trigger\": \"when attack input is pressed during combo window and combo count is less than maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increment combo count\"\n        },\n        {\n          \"action\": \"start next combo animation\"\n        },\n        {\n          \"action\": \"increase damage by combo multiplier\"\n        },\n        {\n          \"action\": \"reset combo window timer\"\n        },\n        {\n          \"action\": \"play combo sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deal_damage\",\n      \"trigger\": \"when weapon collider hits enemy during attack\",\n      \"actions\": [\n        {\n          \"action\": \"calculate final damage with combo multiplier\"\n        },\n        {\n          \"action\": \"apply damage to hit enemy\"\n        },\n        {\n          \"action\": \"create hit effect at contact point\"\n        },\n        {\n          \"action\": \"play impact sound\"\n        },\n        {\n          \"action\": \"add screen shake effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_attack\",\n      \"trigger\": \"when attack animation completes\",\n      \"actions\": [\n        {\n          \"action\": \"disable weapon collider\"\n        },\n        {\n          \"action\": \"set attacking state to false\"\n        },\n        {\n          \"action\": \"start combo window timer\"\n        },\n        {\n          \"action\": \"enable combo possibility\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_combo\",\n      \"trigger\": \"when combo window expires without new attack input\",\n      \"actions\": [\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"disable combo possibility\"\n        },\n        {\n          \"action\": \"start attack cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_combo_sequence\",\n      \"trigger\": \"when maximum combo count is reached\",\n      \"actions\": [\n        {\n          \"action\": \"play finishing move animation\"\n        },\n        {\n          \"action\": \"apply maximum damage with full multiplier\"\n        },\n        {\n          \"action\": \"create powerful visual effect\"\n        },\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"start extended cooldown period\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MeleeWeapon : MonoBehaviour\n{\n    [System.Serializable]\n    public class ComboAttack\n    {\n        public string attackName;\n        public float damage;\n        public float range;\n        public float attackDuration;\n        public float comboWindow;\n        public AnimationClip attackAnimation;\n        public AudioClip attackSound;\n        public GameObject hitEffect;\n        public Vector3 attackOffset;\n        public float knockbackForce;\n    }\n\n    [Header(\"Weapon Settings\")]\n    [SerializeField] private Transform _attackPoint;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    [SerializeField] private float _baseDamage = 10f;\n    \n    [Header(\"Combo System\")]\n    [SerializeField] private List<ComboAttack> _comboAttacks = new List<ComboAttack>();\n    [SerializeField] private float _comboResetTime = 2f;\n    [SerializeField] private bool _canCancelCombo = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private TrailRenderer _weaponTrail;\n    [SerializeField] private ParticleSystem _hitParticles;\n    [SerializeField] private GameObject _slashEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnAttackHit;\n    public UnityEvent OnComboComplete;\n    public UnityEvent<int> OnComboStep;\n\n    private Animator _animator;\n    private int _currentComboIndex = 0;\n    private bool _isAttacking = false;\n    private bool _canAttack = true;\n    private float _lastAttackTime;\n    private Coroutine _comboResetCoroutine;\n    private List<Collider> _hitTargets = new List<Collider>();\n\n    private void Start()\n    {\n        _animator = GetComponentInParent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_attackPoint == null)\n            _attackPoint = transform;\n            \n        SetupDefaultCombo();\n    }\n\n    private void Update()\n    {\n        HandleInput();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            PerformAttack();\n        }\n    }\n\n    private void SetupDefaultCombo()\n    {\n        if (_comboAttacks.Count == 0)\n        {\n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Light Attack\",\n                damage = _baseDamage,\n                range = 2f,\n                attackDuration = 0.5f,\n                comboWindow = 1f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 5f\n            });\n            \n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Medium Attack\",\n                damage = _baseDamage * 1.5f,\n                range = 2.5f,\n                attackDuration = 0.7f,\n                comboWindow = 1.2f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 8f\n            });\n            \n            _comboAttacks.Add(new ComboAttack\n            {\n                attackName = \"Heavy Attack\",\n                damage = _baseDamage * 2f,\n                range = 3f,\n                attackDuration = 1f,\n                comboWindow = 0.5f,\n                attackOffset = Vector3.forward,\n                knockbackForce = 12f\n            });\n        }\n    }\n\n    public void PerformAttack()\n    {\n        if (!_canAttack || _isAttacking) return;\n\n        ComboAttack currentAttack = _comboAttacks[_currentComboIndex];\n        StartCoroutine(ExecuteAttack(currentAttack));\n    }\n\n    private IEnumerator ExecuteAttack(ComboAttack attack)\n    {\n        _isAttacking = true;\n        _canAttack = false;\n        _hitTargets.Clear();\n\n        PlayAttackAnimation(attack);\n        PlayAttackSound(attack);\n        ShowVisualEffects(attack);\n\n        yield return new WaitForSeconds(attack.attackDuration * 0.3f);\n\n        PerformHitDetection(attack);\n\n        yield return new WaitForSeconds(attack.attackDuration * 0.7f);\n\n        _isAttacking = false;\n        \n        float currentTime = Time.time;\n        bool withinComboWindow = (currentTime - _lastAttackTime) <= attack.comboWindow;\n        \n        if (withinComboWindow && _currentComboIndex < _comboAttacks.Count - 1)\n        {\n            _currentComboIndex++;\n            _canAttack = true;\n            OnComboStep?.Invoke(_currentComboIndex);\n        }\n        else\n        {\n            if (_currentComboIndex >= _comboAttacks.Count - 1)\n            {\n                OnComboComplete?.Invoke();\n            }\n            ResetCombo();\n        }\n\n        _lastAttackTime = currentTime;\n        StartComboResetTimer();\n    }\n\n    private void PerformHitDetection(ComboAttack attack)\n    {\n        Vector3 attackPosition = _attackPoint.position + transform.TransformDirection(attack.attackOffset);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, attack.range, _enemyLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (_hitTargets.Contains(hitCollider)) continue;\n            \n            _hitTargets.Add(hitCollider);\n            \n            if (hitCollider.CompareTag(\"Enemy\"))\n            {\n                DealDamage(hitCollider, attack);\n                ApplyKnockback(hitCollider, attack);\n                SpawnHitEffect(hitCollider.transform.position, attack);\n                PlayHitSound();\n                OnAttackHit?.Invoke(attack.damage);\n            }\n        }\n    }\n\n    private void DealDamage(Collider target, ComboAttack attack)\n    {\n        var healthComponent = target.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(attack.damage);\n        }\n        else\n        {\n            target.SendMessage(\"TakeDamage\", attack.damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n\n    private void ApplyKnockback(Collider target, ComboAttack attack)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * attack.knockbackForce, ForceMode.Impulse);\n        }\n    }\n\n    private void PlayAttackAnimation(ComboAttack attack)\n    {\n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Attack\");\n            _animator.SetInteger(\"ComboIndex\", _currentComboIndex);\n        }\n    }\n\n    private void PlayAttackSound(ComboAttack attack)\n    {\n        if (_audioSource != null)\n        {\n            AudioClip soundToPlay = attack.attackSound != null ? attack.attackSound : _swingSound;\n            if (soundToPlay != null)\n            {\n                _audioSource.PlayOneShot(soundToPlay);\n            }\n        }\n    }\n\n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n\n    private void ShowVisualEffects(ComboAttack attack)\n    {\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = true;\n            StartCoroutine(DisableTrailAfterDelay(0.3f));\n        }\n\n        if (_slashEffect != null)\n        {\n            GameObject effect = Instantiate(_slashEffect, _attackPoint.position, _attackPoint.rotation);\n            Destroy(effect, 2f);\n        }\n    }\n\n    private void SpawnHitEffect(Vector3 position, ComboAttack attack)\n    {\n        if (_hitParticles != null)\n        {\n            _hitParticles.transform.position = position;\n            _hitParticles.Play();\n        }\n\n        if (attack.hitEffect != null)\n        {\n            GameObject effect = Instantiate(attack.hitEffect, position, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n\n    private IEnumerator DisableTrailAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        if (_weaponTrail != null)\n        {\n            _weaponTrail.enabled = false;\n        }\n    }\n\n    private void StartComboResetTimer()\n    {\n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n        _comboResetCoroutine = StartCoroutine(ComboResetTimer());\n    }\n\n    private IEnumerator ComboResetTimer()\n    {\n        yield return new WaitForSeconds(_comboResetTime);\n        ResetCombo();\n    }\n\n    private void ResetCombo()\n    {\n        _currentComboIndex = 0;\n        _canAttack = true;\n        _isAttacking = false;\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n            _comboResetCoroutine = null;\n        }\n    }\n\n    public void CancelCombo()\n    {\n        if (_canCancelCombo)\n        {\n            ResetCombo();\n        }\n    }\n\n    public bool IsAttacking()\n    {\n        return _isAttacking;\n    }\n\n    public int GetCurrentComboStep()\n    {\n        return _currentComboIndex;\n    }\n\n    public int GetMaxComboSteps()\n    {\n        return _comboAttacks.Count;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_attackPoint == null) return;\n\n        Gizmos.color = Color.red;\n        for (int i = 0; i < _comboAttacks.Count; i++)\n        {\n            ComboAttack attack = _comboAttacks[i];\n            Vector3 attackPos = _attackPoint.position + transform.TransformDirection(attack.attackOffset);\n            Gizmos.DrawWireSphere(attackPos, attack.range);\n        }\n    }\n}\n\n[System.Serializable]\npublic class Health : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n\n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n\n    public bool IsAlive()\n    {\n        return _currentHealth > 0f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WeatherController\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rainParticles\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"rainAudioSource\",\n      \"type\": \"AudioSource\",\n      \"default\": null\n    },\n    {\n      \"name\": \"thunderAudioSource\",\n      \"type\": \"AudioSource\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lightningParticles\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"ambientLight\",\n      \"type\": \"Light\",\n      \"default\": null\n    },\n    {\n      \"name\": \"originalLightIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"darkenedLightIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"weatherDuration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isWeatherActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_weather\",\n      \"trigger\": \"when weather controller is activated\",\n      \"actions\": [\n        {\n          \"action\": \"start rain particle system with downward falling particles\"\n        },\n        {\n          \"action\": \"play rain sound effects on loop\"\n        },\n        {\n          \"action\": \"reduce bounce properties of all physics materials in scene\"\n        },\n        {\n          \"action\": \"darken ambient lighting to create stormy atmosphere\"\n        },\n        {\n          \"action\": \"set weather active state to true\"\n        },\n        {\n          \"action\": \"start countdown timer for lightning phase\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spawn_lightning\",\n      \"trigger\": \"when weather has been active for specified duration\",\n      \"actions\": [\n        {\n          \"action\": \"spawn lightning bolt particle effects at random sky positions\"\n        },\n        {\n          \"action\": \"play thunder sound effects with dramatic volume\"\n        },\n        {\n          \"action\": \"briefly flash ambient lighting to simulate lightning illumination\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_weather\",\n      \"trigger\": \"when weather controller is deactivated\",\n      \"actions\": [\n        {\n          \"action\": \"stop rain particle system\"\n        },\n        {\n          \"action\": \"stop rain sound effects\"\n        },\n        {\n          \"action\": \"restore original bounce properties to all physics materials\"\n        },\n        {\n          \"action\": \"restore original ambient lighting intensity\"\n        },\n        {\n          \"action\": \"stop lightning and thunder effects\"\n        },\n        {\n          \"action\": \"set weather active state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class WeatherController : MonoBehaviour\n{\n    [Header(\"Rain Settings\")]\n    [SerializeField] private ParticleSystem _rainParticles;\n    [SerializeField] private AudioSource _rainAudioSource;\n    [SerializeField] private AudioClip _rainSoundClip;\n    [SerializeField] private float _rainIntensity = 1000f;\n    [SerializeField] private float _rainArea = 50f;\n    \n    [Header(\"Lightning Settings\")]\n    [SerializeField] private GameObject _lightningBoltPrefab;\n    [SerializeField] private AudioSource _thunderAudioSource;\n    [SerializeField] private AudioClip[] _thunderSoundClips;\n    [SerializeField] private float _lightningDelay = 10f;\n    [SerializeField] private float _lightningInterval = 3f;\n    [SerializeField] private int _lightningCount = 5;\n    [SerializeField] private float _lightningHeight = 20f;\n    \n    [Header(\"Lighting Settings\")]\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _stormLightColor = new Color(0.3f, 0.3f, 0.4f, 1f);\n    [SerializeField] private float _normalLightIntensity = 1f;\n    [SerializeField] private float _stormLightIntensity = 0.3f;\n    [SerializeField] private float _lightTransitionSpeed = 2f;\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _normalBounciness = 0.6f;\n    [SerializeField] private float _wetBounciness = 0.2f;\n    [SerializeField] private string[] _affectedTags = { \"Ground\", \"Wall\", \"Platform\" };\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWeatherStart;\n    public UnityEvent OnLightningStrike;\n    public UnityEvent OnWeatherEnd;\n    \n    private bool _isWeatherActive = false;\n    private List<PhysicMaterial> _originalMaterials = new List<PhysicMaterial>();\n    private List<Collider> _affectedColliders = new List<Collider>();\n    private Coroutine _weatherCoroutine;\n    private Coroutine _lightningCoroutine;\n    private Coroutine _lightTransitionCoroutine;\n    \n    private void Start()\n    {\n        SetupComponents();\n        StoreOriginalMaterials();\n    }\n    \n    private void SetupComponents()\n    {\n        if (_rainParticles == null)\n        {\n            GameObject rainObj = new GameObject(\"RainParticles\");\n            rainObj.transform.SetParent(transform);\n            _rainParticles = rainObj.AddComponent<ParticleSystem>();\n            SetupRainParticles();\n        }\n        \n        if (_rainAudioSource == null)\n        {\n            _rainAudioSource = gameObject.AddComponent<AudioSource>();\n            _rainAudioSource.loop = true;\n            _rainAudioSource.volume = 0.5f;\n        }\n        \n        if (_thunderAudioSource == null)\n        {\n            _thunderAudioSource = gameObject.AddComponent<AudioSource>();\n            _thunderAudioSource.volume = 0.8f;\n        }\n        \n        if (_sunLight == null)\n        {\n            _sunLight = FindObjectOfType<Light>();\n        }\n        \n        if (_lightningBoltPrefab == null)\n        {\n            CreateLightningBoltPrefab();\n        }\n    }\n    \n    private void SetupRainParticles()\n    {\n        var main = _rainParticles.main;\n        main.startLifetime = 2f;\n        main.startSpeed = 10f;\n        main.startSize = 0.1f;\n        main.startColor = new Color(0.7f, 0.8f, 1f, 0.8f);\n        main.maxParticles = (int)_rainIntensity;\n        \n        var emission = _rainParticles.emission;\n        emission.rateOverTime = _rainIntensity / 2f;\n        \n        var shape = _rainParticles.shape;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(_rainArea, 1f, _rainArea);\n        \n        var velocityOverLifetime = _rainParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = -15f;\n        \n        _rainParticles.transform.position = transform.position + Vector3.up * 15f;\n    }\n    \n    private void CreateLightningBoltPrefab()\n    {\n        GameObject lightningObj = new GameObject(\"LightningBolt\");\n        LineRenderer lr = lightningObj.AddComponent<LineRenderer>();\n        lr.material = new Material(Shader.Find(\"Sprites/Default\"));\n        lr.color = Color.white;\n        lr.startWidth = 0.3f;\n        lr.endWidth = 0.1f;\n        lr.positionCount = 10;\n        \n        Light lightningLight = lightningObj.AddComponent<Light>();\n        lightningLight.type = LightType.Point;\n        lightningLight.color = Color.white;\n        lightningLight.intensity = 8f;\n        lightningLight.range = 30f;\n        \n        lightningObj.AddComponent<LightningBolt>();\n        _lightningBoltPrefab = lightningObj;\n    }\n    \n    private void StoreOriginalMaterials()\n    {\n        foreach (string tag in _affectedTags)\n        {\n            GameObject[] objects = GameObject.FindGameObjectsWithTag(tag);\n            foreach (GameObject obj in objects)\n            {\n                Collider col = obj.GetComponent<Collider>();\n                if (col != null)\n                {\n                    _affectedColliders.Add(col);\n                    if (col.material != null)\n                    {\n                        _originalMaterials.Add(col.material);\n                    }\n                    else\n                    {\n                        _originalMaterials.Add(null);\n                    }\n                }\n            }\n        }\n    }\n    \n    public void ActivateWeather()\n    {\n        if (_isWeatherActive) return;\n        \n        _isWeatherActive = true;\n        _weatherCoroutine = StartCoroutine(WeatherSequence());\n        OnWeatherStart?.Invoke();\n    }\n    \n    public void DeactivateWeather()\n    {\n        if (!_isWeatherActive) return;\n        \n        _isWeatherActive = false;\n        \n        if (_weatherCoroutine != null)\n            StopCoroutine(_weatherCoroutine);\n        \n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        StopRain();\n        RestorePhysics();\n        RestoreLighting();\n        \n        OnWeatherEnd?.Invoke();\n    }\n    \n    private IEnumerator WeatherSequence()\n    {\n        StartRain();\n        DampenPhysics();\n        DarkenLighting();\n        \n        yield return new WaitForSeconds(_lightningDelay);\n        \n        _lightningCoroutine = StartCoroutine(LightningSequence());\n    }\n    \n    private void StartRain()\n    {\n        if (_rainParticles != null)\n        {\n            _rainParticles.Play();\n        }\n        \n        if (_rainAudioSource != null && _rainSoundClip != null)\n        {\n            _rainAudioSource.clip = _rainSoundClip;\n            _rainAudioSource.Play();\n        }\n    }\n    \n    private void StopRain()\n    {\n        if (_rainParticles != null)\n        {\n            _rainParticles.Stop();\n        }\n        \n        if (_rainAudioSource != null)\n        {\n            _rainAudioSource.Stop();\n        }\n    }\n    \n    private void DampenPhysics()\n    {\n        PhysicMaterial wetMaterial = new PhysicMaterial(\"WetMaterial\");\n        wetMaterial.bounciness = _wetBounciness;\n        wetMaterial.dynamicFriction = 0.8f;\n        wetMaterial.staticFriction = 0.9f;\n        \n        foreach (Collider col in _affectedColliders)\n        {\n            if (col != null)\n            {\n                col.material = wetMaterial;\n            }\n        }\n    }\n    \n    private void RestorePhysics()\n    {\n        for (int i = 0; i < _affectedColliders.Count && i < _originalMaterials.Count; i++)\n        {\n            if (_affectedColliders[i] != null)\n            {\n                _affectedColliders[i].material = _originalMaterials[i];\n            }\n        }\n    }\n    \n    private void DarkenLighting()\n    {\n        if (_lightTransitionCoroutine != null)\n            StopCoroutine(_lightTransitionCoroutine);\n        \n        _lightTransitionCoroutine = StartCoroutine(TransitionLighting(_stormLightColor, _stormLightIntensity));\n    }\n    \n    private void RestoreLighting()\n    {\n        if (_lightTransitionCoroutine != null)\n            StopCoroutine(_lightTransitionCoroutine);\n        \n        _lightTransitionCoroutine = StartCoroutine(TransitionLighting(_normalLightColor, _normalLightIntensity));\n    }\n    \n    private IEnumerator TransitionLighting(Color targetColor, float targetIntensity)\n    {\n        if (_sunLight == null) yield break;\n        \n        Color startColor = _sunLight.color;\n        float startIntensity = _sunLight.intensity;\n        float elapsed = 0f;\n        \n        while (elapsed < 1f)\n        {\n            elapsed += Time.deltaTime * _lightTransitionSpeed;\n            float t = Mathf.SmoothStep(0f, 1f, elapsed);\n            \n            _sunLight.color = Color.Lerp(startColor, targetColor, t);\n            _sunLight.intensity = Mathf.Lerp(startIntensity, targetIntensity, t);\n            \n            yield return null;\n        }\n        \n        _sunLight.color = targetColor;\n        _sunLight.intensity = targetIntensity;\n    }\n    \n    private IEnumerator LightningSequence()\n    {\n        for (int i = 0; i < _lightningCount; i++)\n        {\n            if (!_isWeatherActive) yield break;\n            \n            SpawnLightning();\n            yield return new WaitForSeconds(_lightningInterval + Random.Range(-1f, 1f));\n        }\n    }\n    \n    private void SpawnLightning()\n    {\n        if (_lightningBoltPrefab == null) return;\n        \n        Vector3 spawnPos = transform.position + new Vector3(\n            Random.Range(-_rainArea / 2f, _rainArea / 2f),\n            _lightningHeight,\n            Random.Range(-_rainArea / 2f, _rainArea / 2f)\n        );\n        \n        GameObject lightning = Instantiate(_lightningBoltPrefab, spawnPos, Quaternion.identity);\n        \n        if (_thunderAudioSource != null && _thunderSoundClips.Length > 0)\n        {\n            AudioClip thunderClip = _thunderSoundClips[Random.Range(0, _thunderSoundClips.Length)];\n            _thunderAudioSource.PlayOneShot(thunderClip);\n        }\n        \n        OnLightningStrike?.Invoke();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ActivateWeather();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position, new Vector3(_rainArea, 1f, _rainArea));\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.up * _lightningHeight, 2f);\n    }\n}\n\npublic class LightningBolt : MonoBehaviour\n{\n    private LineRenderer _lineRenderer;\n    private Light _lightningLight;\n    private float _duration = 0.2f;\n    private float _flickerTime = 0.05f;\n    \n    private void Start()\n    {\n        _lineRenderer = GetComponent<LineRenderer>();\n        _lightningLight = GetComponent<Light>();\n        \n        GenerateLightningPath();\n        StartCoroutine(LightningEffect());\n    }\n    \n    private void GenerateLightningPath()\n    {\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + Vector3.down * 20f;\n        \n        Vector3[] positions = new Vector3[_lineRenderer.positionCount];\n        \n        for (int i = 0; i < positions.Length; i++)\n        {\n            float t = (float)i / (positions.Length - 1);\n            Vector3 basePos = Vector3.Lerp(startPos, endPos, t);\n            \n            if (i > 0 && i < positions.Length - 1)\n            {\n                basePos += new Vector3(\n                    Random.Range(-2f, 2f),\n                    0f,\n                    Random.Range(-2f, 2f)\n                );\n            }\n            \n            positions[i] = basePos;\n        }\n        \n        _lineRenderer.SetPositions(positions);\n    }\n    \n    private IEnumerator LightningEffect()\n    {\n        float elapsed = 0f;\n        \n        while (elapsed < _duration)\n        {\n            bool isVisible = (elapsed % _flickerTime) < (_flickerTime * 0.7f);\n            _lineRenderer.enabled = isVisible;\n            _lightningLight.enabled = isVisible;\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PowerPunchCharge\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"chargeTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"maxPunchForce\",\n      \"type\": \"float\",\n      \"default\": 1000.0\n    },\n    {\n      \"name\": \"chargeEffectPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isCharging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentChargeLevel\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_charge\",\n      \"trigger\": \"when punch button is pressed and held\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to true\"\n        },\n        {\n          \"action\": \"reset charge level to zero\"\n        },\n        {\n          \"action\": \"spawn charging visual effect\"\n        },\n        {\n          \"action\": \"play charging sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"build_charge\",\n      \"trigger\": \"while charging and punch button is held\",\n      \"actions\": [\n        {\n          \"action\": \"increase charge level over time\"\n        },\n        {\n          \"action\": \"intensify visual charging effects\"\n        },\n        {\n          \"action\": \"increase charging sound pitch\"\n        },\n        {\n          \"action\": \"clamp charge level to maximum value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_punch\",\n      \"trigger\": \"when punch button is released while charging\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"calculate punch force based on charge level\"\n        },\n        {\n          \"action\": \"apply forward force to rigidbody\"\n        },\n        {\n          \"action\": \"destroy charging visual effects\"\n        },\n        {\n          \"action\": \"play punch release sound\"\n        },\n        {\n          \"action\": \"reset charge level to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_charge\",\n      \"trigger\": \"when movement input is detected while charging\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"destroy charging visual effects\"\n        },\n        {\n          \"action\": \"stop charging sound\"\n        },\n        {\n          \"action\": \"reset charge level to zero\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PowerPunchCharge : MonoBehaviour\n{\n    [Header(\"Charge Settings\")]\n    [SerializeField] private float _maxChargeTime = 3f;\n    [SerializeField] private float _minChargeTime = 0.5f;\n    [SerializeField] private AnimationCurve _chargeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _chargeKey = KeyCode.Mouse0;\n    [SerializeField] private bool _holdToCharge = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _chargeEffect;\n    [SerializeField] private Transform _chargePoint;\n    [SerializeField] private GameObject _chargeIndicator;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Feedback\")]\n    [SerializeField] private float _cameraShakeIntensity = 0.1f;\n    [SerializeField] private Color _minChargeColor = Color.yellow;\n    [SerializeField] private Color _maxChargeColor = Color.red;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnChargeStarted;\n    public UnityEvent<float> OnChargeUpdated;\n    public UnityEvent<float> OnPunchReleased;\n    public UnityEvent OnChargeCancelled;\n    \n    private float _currentChargeTime;\n    private float _chargePercentage;\n    private bool _isCharging;\n    private bool _canCharge = true;\n    private Camera _mainCamera;\n    private Vector3 _originalCameraPosition;\n    private Renderer _indicatorRenderer;\n    private Light _chargeLight;\n    \n    [System.Serializable]\n    public class ChargeLevel\n    {\n        public float threshold;\n        public float damageMultiplier;\n        public float forceMultiplier;\n        public Color effectColor;\n        public string levelName;\n    }\n    \n    [Header(\"Charge Levels\")]\n    [SerializeField] private ChargeLevel[] _chargeLevels = new ChargeLevel[]\n    {\n        new ChargeLevel { threshold = 0.33f, damageMultiplier = 1.5f, forceMultiplier = 1.2f, effectColor = Color.yellow, levelName = \"Light\" },\n        new ChargeLevel { threshold = 0.66f, damageMultiplier = 2f, forceMultiplier = 1.5f, effectColor = Color.orange, levelName = \"Medium\" },\n        new ChargeLevel { threshold = 1f, damageMultiplier = 3f, forceMultiplier = 2f, effectColor = Color.red, levelName = \"Heavy\" }\n    };\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n            \n        if (_chargeIndicator != null)\n        {\n            _indicatorRenderer = _chargeIndicator.GetComponent<Renderer>();\n            _chargeLight = _chargeIndicator.GetComponent<Light>();\n            _chargeIndicator.SetActive(false);\n        }\n        \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharge();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_canCharge) return;\n        \n        bool inputPressed = Input.GetKeyDown(_chargeKey);\n        bool inputHeld = Input.GetKey(_chargeKey);\n        bool inputReleased = Input.GetKeyUp(_chargeKey);\n        \n        if (inputPressed && !_isCharging)\n        {\n            StartCharge();\n        }\n        else if (_holdToCharge && inputHeld && _isCharging)\n        {\n            ContinueCharge();\n        }\n        else if (inputReleased && _isCharging)\n        {\n            ReleasePunch();\n        }\n        else if (!_holdToCharge && inputPressed && _isCharging)\n        {\n            ReleasePunch();\n        }\n    }\n    \n    private void StartCharge()\n    {\n        _isCharging = true;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n        \n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(true);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Play();\n            \n        if (_audioSource != null && _chargeSound != null)\n            _audioSource.PlayOneShot(_chargeSound);\n            \n        OnChargeStarted?.Invoke(_chargePercentage);\n    }\n    \n    private void ContinueCharge()\n    {\n        _currentChargeTime += Time.deltaTime;\n        _chargePercentage = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n        \n        OnChargeUpdated?.Invoke(_chargePercentage);\n    }\n    \n    private void UpdateCharge()\n    {\n        if (!_isCharging) return;\n        \n        if (!_holdToCharge)\n        {\n            _currentChargeTime += Time.deltaTime;\n            _chargePercentage = Mathf.Clamp01(_currentChargeTime / _maxChargeTime);\n            OnChargeUpdated?.Invoke(_chargePercentage);\n        }\n        \n        // Apply charge curve\n        float curvedCharge = _chargeCurve.Evaluate(_chargePercentage);\n        \n        // Camera shake based on charge level\n        if (_mainCamera != null && _chargePercentage > 0.3f)\n        {\n            float shakeAmount = curvedCharge * _cameraShakeIntensity;\n            Vector3 shakeOffset = Random.insideUnitSphere * shakeAmount;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (!_isCharging) return;\n        \n        // Update indicator color\n        if (_indicatorRenderer != null)\n        {\n            Color currentColor = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n            _indicatorRenderer.material.color = currentColor;\n        }\n        \n        // Update light intensity\n        if (_chargeLight != null)\n        {\n            _chargeLight.intensity = _chargePercentage * 2f;\n            _chargeLight.color = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n        }\n        \n        // Update particle effect\n        if (_chargeEffect != null)\n        {\n            var main = _chargeEffect.main;\n            main.startColor = Color.Lerp(_minChargeColor, _maxChargeColor, _chargePercentage);\n            \n            var emission = _chargeEffect.emission;\n            emission.rateOverTime = _chargePercentage * 50f;\n        }\n    }\n    \n    private void ReleasePunch()\n    {\n        if (_currentChargeTime < _minChargeTime)\n        {\n            CancelCharge();\n            return;\n        }\n        \n        float finalChargePercentage = _chargePercentage;\n        ChargeLevel currentLevel = GetChargeLevel(finalChargePercentage);\n        \n        // Reset camera position\n        if (_mainCamera != null)\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n            \n        // Stop effects\n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(false);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        if (_audioSource != null && _releaseSound != null)\n            _audioSource.PlayOneShot(_releaseSound);\n            \n        // Perform punch logic\n        PerformPunch(currentLevel, finalChargePercentage);\n        \n        OnPunchReleased?.Invoke(finalChargePercentage);\n        \n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n    }\n    \n    private void CancelCharge()\n    {\n        _isCharging = false;\n        _currentChargeTime = 0f;\n        _chargePercentage = 0f;\n        \n        if (_mainCamera != null)\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n            \n        if (_chargeIndicator != null)\n            _chargeIndicator.SetActive(false);\n            \n        if (_chargeEffect != null)\n            _chargeEffect.Stop();\n            \n        OnChargeCancelled?.Invoke();\n    }\n    \n    private ChargeLevel GetChargeLevel(float chargePercentage)\n    {\n        ChargeLevel selectedLevel = _chargeLevels[0];\n        \n        for (int i = 0; i < _chargeLevels.Length; i++)\n        {\n            if (chargePercentage >= _chargeLevels[i].threshold)\n                selectedLevel = _chargeLevels[i];\n        }\n        \n        return selectedLevel;\n    }\n    \n    private void PerformPunch(ChargeLevel level, float chargePercentage)\n    {\n        // Raycast or sphere cast to detect targets\n        Vector3 punchDirection = transform.forward;\n        Vector3 punchOrigin = _chargePoint != null ? _chargePoint.position : transform.position;\n        \n        float punchRange = 2f + (chargePercentage * 3f);\n        RaycastHit[] hits = Physics.SphereCastAll(punchOrigin, 0.5f, punchDirection, punchRange);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            // Apply force to rigidbodies\n            Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 forceDirection = (hit.point - punchOrigin).normalized;\n                float force = level.forceMultiplier * chargePercentage * 1000f;\n                targetRb.AddForce(forceDirection * force, ForceMode.Impulse);\n            }\n            \n            // Damage destructible objects\n            if (hit.collider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hit.collider.gameObject);\n            }\n        }\n    }\n    \n    public void SetCanCharge(bool canCharge)\n    {\n        _canCharge = canCharge;\n        if (!canCharge && _isCharging)\n            CancelCharge();\n    }\n    \n    public float GetCurrentChargePercentage()\n    {\n        return _chargePercentage;\n    }\n    \n    public bool IsCharging()\n    {\n        return _isCharging;\n    }\n    \n    public ChargeLevel GetCurrentChargeLevel()\n    {\n        return GetChargeLevel(_chargePercentage);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 origin = _chargePoint != null ? _chargePoint.position : transform.position;\n        Vector3 direction = transform.forward;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(origin, direction * (2f + (_chargePercentage * 3f)));\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(origin, 0.5f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Portal\",\n  \"components\": [\n    \"Collider\",\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"destinationPortal\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"teleportDelay\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"requiresKey\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"keyItemName\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"lastTeleportTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"teleport_player\",\n      \"trigger\": \"when player enters portal trigger area and portal is active and cooldown period has passed\",\n      \"actions\": [\n        {\n          \"action\": \"check if player has required key item if key is required\"\n        },\n        {\n          \"action\": \"play portal activation sound effect\"\n        },\n        {\n          \"action\": \"start teleportation particle effects\"\n        },\n        {\n          \"action\": \"disable player movement temporarily\"\n        },\n        {\n          \"action\": \"wait for teleport delay duration\"\n        },\n        {\n          \"action\": \"move player to destination portal location\"\n        },\n        {\n          \"action\": \"face player away from destination portal\"\n        },\n        {\n          \"action\": \"play arrival particle effects at destination\"\n        },\n        {\n          \"action\": \"re-enable player movement\"\n        },\n        {\n          \"action\": \"record current time as last teleport time\"\n        },\n        {\n          \"action\": \"trigger cooldown on both portals\"\n        }\n      ]\n    },\n    {\n      \"name\": \"portal_visual_feedback\",\n      \"trigger\": \"when player approaches portal within interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"increase portal particle intensity\"\n        },\n        {\n          \"action\": \"play ambient portal humming sound\"\n        },\n        {\n          \"action\": \"display interaction prompt if portal is usable\"\n        }\n      ]\n    },\n    {\n      \"name\": \"portal_idle_state\",\n      \"trigger\": \"when player moves away from portal interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"return portal particles to normal intensity\"\n        },\n        {\n          \"action\": \"fade out ambient portal sounds\"\n        },\n        {\n          \"action\": \"hide interaction prompt\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_missing_destination\",\n      \"trigger\": \"when player tries to use portal but destination portal is not set\",\n      \"actions\": [\n        {\n          \"action\": \"play error sound effect\"\n        },\n        {\n          \"action\": \"display message that portal is not connected\"\n        },\n        {\n          \"action\": \"prevent teleportation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_locked_portal\",\n      \"trigger\": \"when player tries to use portal but does not have required key\",\n      \"actions\": [\n        {\n          \"action\": \"play locked portal sound effect\"\n        },\n        {\n          \"action\": \"display message about required key item\"\n        },\n        {\n          \"action\": \"show portal locked visual effect\"\n        },\n        {\n          \"action\": \"prevent teleportation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Portal : MonoBehaviour\n{\n    [Header(\"Portal Configuration\")]\n    [SerializeField] private Portal _destinationPortal;\n    [SerializeField] private Transform _spawnPoint;\n    [SerializeField] private float _teleportCooldown = 1f;\n    [SerializeField] private bool _requiresActivation = false;\n    [SerializeField] private KeyCode _activationKey = KeyCode.E;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _portalEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private GameObject _activationPrompt;\n    \n    [Header(\"Portal Behavior\")]\n    [SerializeField] private LayerMask _teleportLayers = -1;\n    [SerializeField] private float _teleportForce = 5f;\n    [SerializeField] private bool _maintainVelocity = true;\n    [SerializeField] private bool _faceDestinationDirection = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTeleportStart;\n    public UnityEvent OnTeleportComplete;\n    public UnityEvent<GameObject> OnObjectTeleported;\n    \n    private bool _isActive = true;\n    private float _lastTeleportTime;\n    private GameObject _playerInRange;\n    private Collider _portalCollider;\n    \n    private void Start()\n    {\n        _portalCollider = GetComponent<Collider>();\n        if (_portalCollider == null)\n        {\n            _portalCollider = gameObject.AddComponent<BoxCollider>();\n            ((BoxCollider)_portalCollider).isTrigger = true;\n        }\n        \n        if (_spawnPoint == null)\n        {\n            GameObject spawnPoint = new GameObject(\"SpawnPoint\");\n            spawnPoint.transform.SetParent(transform);\n            spawnPoint.transform.localPosition = Vector3.forward * 2f;\n            _spawnPoint = spawnPoint.transform;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_activationPrompt != null)\n            _activationPrompt.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_requiresActivation && _playerInRange != null)\n        {\n            if (Input.GetKeyDown(_activationKey))\n            {\n                TeleportObject(_playerInRange);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive || Time.time - _lastTeleportTime < _teleportCooldown)\n            return;\n            \n        if (!IsValidTeleportTarget(other.gameObject))\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = other.gameObject;\n            if (_requiresActivation && _activationPrompt != null)\n                _activationPrompt.SetActive(true);\n        }\n        \n        if (!_requiresActivation)\n        {\n            TeleportObject(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInRange = null;\n            if (_activationPrompt != null)\n                _activationPrompt.SetActive(false);\n        }\n    }\n    \n    private bool IsValidTeleportTarget(GameObject target)\n    {\n        if (_destinationPortal == null)\n            return false;\n            \n        int targetLayer = 1 << target.layer;\n        return (_teleportLayers.value & targetLayer) != 0;\n    }\n    \n    private void TeleportObject(GameObject target)\n    {\n        if (!IsValidTeleportTarget(target) || !_isActive)\n            return;\n            \n        StartCoroutine(PerformTeleport(target));\n    }\n    \n    private IEnumerator PerformTeleport(GameObject target)\n    {\n        _isActive = false;\n        _lastTeleportTime = Time.time;\n        \n        OnTeleportStart?.Invoke();\n        \n        if (_portalEffect != null)\n            _portalEffect.Play();\n            \n        if (_audioSource != null && _teleportSound != null)\n            _audioSource.PlayOneShot(_teleportSound);\n        \n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        Vector3 originalVelocity = Vector3.zero;\n        \n        if (targetRigidbody != null && _maintainVelocity)\n            originalVelocity = targetRigidbody.velocity;\n        \n        CharacterController characterController = target.GetComponent<CharacterController>();\n        if (characterController != null)\n            characterController.enabled = false;\n        \n        Vector3 destinationPosition = _destinationPortal._spawnPoint.position;\n        target.transform.position = destinationPosition;\n        \n        if (_faceDestinationDirection)\n        {\n            target.transform.rotation = _destinationPortal._spawnPoint.rotation;\n        }\n        \n        yield return new WaitForFixedUpdate();\n        \n        if (characterController != null)\n            characterController.enabled = true;\n        \n        if (targetRigidbody != null)\n        {\n            if (_maintainVelocity)\n            {\n                Vector3 adjustedVelocity = _destinationPortal.transform.TransformDirection(\n                    transform.InverseTransformDirection(originalVelocity));\n                targetRigidbody.velocity = adjustedVelocity;\n            }\n            else\n            {\n                Vector3 forwardForce = _destinationPortal._spawnPoint.forward * _teleportForce;\n                targetRigidbody.velocity = forwardForce;\n            }\n        }\n        \n        if (_destinationPortal._portalEffect != null)\n            _destinationPortal._portalEffect.Play();\n        \n        OnObjectTeleported?.Invoke(target);\n        OnTeleportComplete?.Invoke();\n        \n        _destinationPortal._lastTeleportTime = Time.time;\n        \n        yield return new WaitForSeconds(_teleportCooldown);\n        \n        _isActive = true;\n    }\n    \n    public void SetDestination(Portal destination)\n    {\n        _destinationPortal = destination;\n    }\n    \n    public void ActivatePortal()\n    {\n        _isActive = true;\n    }\n    \n    public void DeactivatePortal()\n    {\n        _isActive = false;\n    }\n    \n    public void TogglePortal()\n    {\n        _isActive = !_isActive;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_destinationPortal != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _destinationPortal.transform.position);\n            Gizmos.DrawWireSphere(_destinationPortal.transform.position, 0.5f);\n        }\n        \n        if (_spawnPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_spawnPoint.position, 0.3f);\n            Gizmos.DrawRay(_spawnPoint.position, _spawnPoint.forward * 2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TimeRewindAbility\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rewindDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"recordInterval\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"maxRecordedStates\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isRewinding\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canRewind\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"record_state\",\n      \"trigger\": \"every record interval while not rewinding\",\n      \"actions\": [\n        {\n          \"action\": \"store current position in history list\"\n        },\n        {\n          \"action\": \"store current rotation in history list\"\n        },\n        {\n          \"action\": \"store current velocity in history list\"\n        },\n        {\n          \"action\": \"remove oldest state if history exceeds maximum recorded states\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_rewind\",\n      \"trigger\": \"when rewind input is pressed and can rewind and not currently rewinding\",\n      \"actions\": [\n        {\n          \"action\": \"set rewinding state to true\"\n        },\n        {\n          \"action\": \"set can rewind to false\"\n        },\n        {\n          \"action\": \"disable player input\"\n        },\n        {\n          \"action\": \"start rewind visual effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"perform_rewind\",\n      \"trigger\": \"while rewinding and have recorded states\",\n      \"actions\": [\n        {\n          \"action\": \"get most recent recorded state from history\"\n        },\n        {\n          \"action\": \"set object position to recorded position\"\n        },\n        {\n          \"action\": \"set object rotation to recorded rotation\"\n        },\n        {\n          \"action\": \"set object velocity to recorded velocity\"\n        },\n        {\n          \"action\": \"remove used state from history\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_rewind\",\n      \"trigger\": \"when rewind duration expires or no more recorded states\",\n      \"actions\": [\n        {\n          \"action\": \"set rewinding state to false\"\n        },\n        {\n          \"action\": \"enable player input\"\n        },\n        {\n          \"action\": \"stop rewind visual effects\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_cooldown\",\n      \"trigger\": \"when cooldown timer reaches cooldown time\",\n      \"actions\": [\n        {\n          \"action\": \"set can rewind to true\"\n        },\n        {\n          \"action\": \"reset cooldown timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class TimeRewindAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class TransformSnapshot\n    {\n        public Vector3 position;\n        public Quaternion rotation;\n        public Vector3 scale;\n        public float timestamp;\n        \n        public TransformSnapshot(Transform transform, float time)\n        {\n            position = transform.position;\n            rotation = transform.rotation;\n            scale = transform.localScale;\n            timestamp = time;\n        }\n    }\n    \n    [System.Serializable]\n    public class RigidbodySnapshot\n    {\n        public Vector3 velocity;\n        public Vector3 angularVelocity;\n        public float timestamp;\n        \n        public RigidbodySnapshot(Rigidbody rb, float time)\n        {\n            velocity = rb.velocity;\n            angularVelocity = rb.angularVelocity;\n            timestamp = time;\n        }\n    }\n    \n    [Header(\"Rewind Settings\")]\n    [SerializeField] private KeyCode _rewindKey = KeyCode.R;\n    [SerializeField] private float _maxRewindTime = 10f;\n    [SerializeField] private float _snapshotInterval = 0.1f;\n    [SerializeField] private float _rewindSpeed = 2f;\n    [SerializeField] private bool _pauseTimeWhileRewinding = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _rewindEffect;\n    [SerializeField] private Material _rewindMaterial;\n    [SerializeField] private Color _rewindTint = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rewindStartSound;\n    [SerializeField] private AudioClip _rewindLoopSound;\n    [SerializeField] private AudioClip _rewindEndSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRewindStart;\n    public UnityEvent OnRewindEnd;\n    public UnityEvent<float> OnRewindProgress;\n    \n    private List<TransformSnapshot> _transformSnapshots = new List<TransformSnapshot>();\n    private List<RigidbodySnapshot> _rigidbodySnapshots = new List<RigidbodySnapshot>();\n    private Dictionary<Renderer, Material[]> _originalMaterials = new Dictionary<Renderer, Material[]>();\n    \n    private bool _isRewinding = false;\n    private float _lastSnapshotTime = 0f;\n    private float _rewindStartTime = 0f;\n    private float _originalTimeScale = 1f;\n    private int _currentSnapshotIndex = 0;\n    \n    private Rigidbody _rigidbody;\n    private Renderer[] _renderers;\n    private Collider[] _colliders;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderers = GetComponentsInChildren<Renderer>();\n        _colliders = GetComponentsInChildren<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        StoreOriginalMaterials();\n        _originalTimeScale = Time.timeScale;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        \n        if (!_isRewinding)\n        {\n            RecordSnapshot();\n            CleanupOldSnapshots();\n        }\n        else\n        {\n            ProcessRewind();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_rewindKey) && !_isRewinding && _transformSnapshots.Count > 0)\n        {\n            StartRewind();\n        }\n        else if (Input.GetKeyUp(_rewindKey) && _isRewinding)\n        {\n            StopRewind();\n        }\n    }\n    \n    private void RecordSnapshot()\n    {\n        if (Time.time - _lastSnapshotTime >= _snapshotInterval)\n        {\n            _transformSnapshots.Add(new TransformSnapshot(transform, Time.time));\n            \n            if (_rigidbody != null)\n            {\n                _rigidbodySnapshots.Add(new RigidbodySnapshot(_rigidbody, Time.time));\n            }\n            \n            _lastSnapshotTime = Time.time;\n        }\n    }\n    \n    private void CleanupOldSnapshots()\n    {\n        float cutoffTime = Time.time - _maxRewindTime;\n        \n        _transformSnapshots.RemoveAll(snapshot => snapshot.timestamp < cutoffTime);\n        _rigidbodySnapshots.RemoveAll(snapshot => snapshot.timestamp < cutoffTime);\n    }\n    \n    private void StartRewind()\n    {\n        if (_transformSnapshots.Count == 0) return;\n        \n        _isRewinding = true;\n        _rewindStartTime = Time.time;\n        _currentSnapshotIndex = _transformSnapshots.Count - 1;\n        \n        if (_pauseTimeWhileRewinding)\n        {\n            Time.timeScale = 0f;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        SetCollidersEnabled(false);\n        ApplyRewindVisuals();\n        PlayRewindAudio(_rewindStartSound);\n        \n        if (_rewindEffect != null)\n            _rewindEffect.Play();\n        \n        OnRewindStart?.Invoke();\n    }\n    \n    private void ProcessRewind()\n    {\n        if (_currentSnapshotIndex < 0)\n        {\n            StopRewind();\n            return;\n        }\n        \n        float rewindProgress = 1f - (_currentSnapshotIndex / (float)_transformSnapshots.Count);\n        OnRewindProgress?.Invoke(rewindProgress);\n        \n        TransformSnapshot targetSnapshot = _transformSnapshots[_currentSnapshotIndex];\n        \n        transform.position = targetSnapshot.position;\n        transform.rotation = targetSnapshot.rotation;\n        transform.localScale = targetSnapshot.scale;\n        \n        _currentSnapshotIndex -= Mathf.RoundToInt(_rewindSpeed);\n        _currentSnapshotIndex = Mathf.Max(_currentSnapshotIndex, 0);\n    }\n    \n    private void StopRewind()\n    {\n        if (!_isRewinding) return;\n        \n        _isRewinding = false;\n        \n        if (_pauseTimeWhileRewinding)\n        {\n            Time.timeScale = _originalTimeScale;\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            RestoreRigidbodyState();\n        }\n        \n        SetCollidersEnabled(true);\n        RestoreOriginalVisuals();\n        PlayRewindAudio(_rewindEndSound);\n        \n        if (_rewindEffect != null)\n            _rewindEffect.Stop();\n        \n        ClearSnapshotsAfterRewind();\n        OnRewindEnd?.Invoke();\n    }\n    \n    private void RestoreRigidbodyState()\n    {\n        if (_rigidbody == null || _rigidbodySnapshots.Count == 0) return;\n        \n        int targetIndex = Mathf.Clamp(_currentSnapshotIndex, 0, _rigidbodySnapshots.Count - 1);\n        RigidbodySnapshot targetState = _rigidbodySnapshots[targetIndex];\n        \n        _rigidbody.velocity = targetState.velocity;\n        _rigidbody.angularVelocity = targetState.angularVelocity;\n    }\n    \n    private void ClearSnapshotsAfterRewind()\n    {\n        if (_currentSnapshotIndex >= 0 && _currentSnapshotIndex < _transformSnapshots.Count)\n        {\n            _transformSnapshots.RemoveRange(_currentSnapshotIndex, _transformSnapshots.Count - _currentSnapshotIndex);\n            \n            if (_rigidbodySnapshots.Count > _currentSnapshotIndex)\n            {\n                _rigidbodySnapshots.RemoveRange(_currentSnapshotIndex, _rigidbodySnapshots.Count - _currentSnapshotIndex);\n            }\n        }\n    }\n    \n    private void SetCollidersEnabled(bool enabled)\n    {\n        foreach (Collider col in _colliders)\n        {\n            if (col != null)\n                col.enabled = enabled;\n        }\n    }\n    \n    private void StoreOriginalMaterials()\n    {\n        foreach (Renderer renderer in _renderers)\n        {\n            if (renderer != null)\n            {\n                _originalMaterials[renderer] = renderer.materials;\n            }\n        }\n    }\n    \n    private void ApplyRewindVisuals()\n    {\n        if (_rewindMaterial == null) return;\n        \n        foreach (Renderer renderer in _renderers)\n        {\n            if (renderer != null)\n            {\n                Material[] rewindMaterials = new Material[renderer.materials.Length];\n                for (int i = 0; i < rewindMaterials.Length; i++)\n                {\n                    rewindMaterials[i] = _rewindMaterial;\n                }\n                renderer.materials = rewindMaterials;\n                renderer.material.color = _rewindTint;\n            }\n        }\n    }\n    \n    private void RestoreOriginalVisuals()\n    {\n        foreach (var kvp in _originalMaterials)\n        {\n            if (kvp.Key != null)\n            {\n                kvp.Key.materials = kvp.Value;\n            }\n        }\n    }\n    \n    private void PlayRewindAudio(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void TriggerRewind()\n    {\n        if (!_isRewinding && _transformSnapshots.Count > 0)\n        {\n            StartRewind();\n        }\n    }\n    \n    public void StopRewindManually()\n    {\n        if (_isRewinding)\n        {\n            StopRewind();\n        }\n    }\n    \n    public bool IsRewinding()\n    {\n        return _isRewinding;\n    }\n    \n    public float GetRewindProgress()\n    {\n        if (!_isRewinding || _transformSnapshots.Count == 0) return 0f;\n        return 1f - (_currentSnapshotIndex / (float)_transformSnapshots.Count);\n    }\n    \n    public void ClearAllSnapshots()\n    {\n        _transformSnapshots.Clear();\n        _rigidbodySnapshots.Clear();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_pauseTimeWhileRewinding && _isRewinding)\n        {\n            Time.timeScale = _originalTimeScale;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WolfMount\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"runSpeed\",\n      \"type\": \"float\",\n      \"default\": 12\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"stamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"staminaDrainRate\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"staminaRegenRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isMounted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isRunning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_running\",\n      \"trigger\": \"when player presses run input while mounted and stamina is above zero\",\n      \"actions\": [\n        {\n          \"action\": \"set running state to true\"\n        },\n        {\n          \"action\": \"play running animation\"\n        },\n        {\n          \"action\": \"play galloping sound effect\"\n        },\n        {\n          \"action\": \"increase movement speed to run speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_running\",\n      \"trigger\": \"while running and run input is held\",\n      \"actions\": [\n        {\n          \"action\": \"accelerate forward at acceleration rate\"\n        },\n        {\n          \"action\": \"drain stamina at drain rate per second\"\n        },\n        {\n          \"action\": \"create dust particle effects behind wolf\"\n        },\n        {\n          \"action\": \"play breathing sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_running\",\n      \"trigger\": \"when run input is released or stamina reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"set running state to false\"\n        },\n        {\n          \"action\": \"play walking animation\"\n        },\n        {\n          \"action\": \"reduce movement speed to walk speed\"\n        },\n        {\n          \"action\": \"stop galloping sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_stamina\",\n      \"trigger\": \"when not running and stamina is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"restore stamina at regeneration rate per second\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_dismount_while_running\",\n      \"trigger\": \"when player dismounts while wolf is running\",\n      \"actions\": [\n        {\n          \"action\": \"gradually slow down to stop\"\n        },\n        {\n          \"action\": \"set running state to false\"\n        },\n        {\n          \"action\": \"play tired panting animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class WolfMount : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _walkSpeed = 3f;\n    [SerializeField] private float _runSpeed = 8f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 15f;\n    [SerializeField] private float _turnSpeed = 180f;\n    \n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    [SerializeField] private float _minStaminaToRun = 10f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _speedParameter = \"Speed\";\n    [SerializeField] private string _isRunningParameter = \"IsRunning\";\n    [SerializeField] private string _isMountedParameter = \"IsMounted\";\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _footstepSounds;\n    [SerializeField] private AudioClip[] _breathingSounds;\n    [SerializeField] private float _footstepInterval = 0.5f;\n    \n    [Header(\"Mounting Settings\")]\n    [SerializeField] private Transform _mountPoint;\n    [SerializeField] private float _mountRange = 2f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    [SerializeField] private KeyCode _dismountKey = KeyCode.F;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnMounted;\n    public UnityEvent OnDismounted;\n    public UnityEvent OnStaminaDepleted;\n    \n    private CharacterController _characterController;\n    private Transform _rider;\n    private bool _isMounted = false;\n    private bool _isRunning = false;\n    private float _currentSpeed = 0f;\n    private float _currentStamina;\n    private float _footstepTimer = 0f;\n    private Vector3 _moveDirection = Vector3.zero;\n    private Camera _playerCamera;\n    private Vector3 _lastPosition;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        if (_characterController == null)\n            _characterController = gameObject.AddComponent<CharacterController>();\n            \n        if (_animator == null)\n            _animator = GetComponentInChildren<Animator>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_mountPoint == null)\n        {\n            GameObject mountPointObj = new GameObject(\"MountPoint\");\n            mountPointObj.transform.SetParent(transform);\n            mountPointObj.transform.localPosition = new Vector3(0, 1.5f, 0);\n            _mountPoint = mountPointObj.transform;\n        }\n        \n        _currentStamina = _maxStamina;\n        _lastPosition = transform.position;\n        _playerCamera = Camera.main;\n    }\n    \n    private void Update()\n    {\n        HandleMountingInput();\n        \n        if (_isMounted && _rider != null)\n        {\n            HandleMovementInput();\n            HandleStamina();\n            UpdateAnimation();\n            HandleAudio();\n        }\n        else\n        {\n            CheckForNearbyPlayer();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isMounted && _rider != null)\n        {\n            ApplyMovement();\n        }\n    }\n    \n    private void HandleMountingInput()\n    {\n        if (Input.GetKeyDown(_mountKey) && !_isMounted)\n        {\n            TryMount();\n        }\n        else if (Input.GetKeyDown(_dismountKey) && _isMounted)\n        {\n            Dismount();\n        }\n    }\n    \n    private void CheckForNearbyPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance <= _mountRange)\n            {\n                // Visual indicator could be added here\n            }\n        }\n    }\n    \n    private void TryMount()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance <= _mountRange)\n            {\n                Mount(player.transform);\n            }\n        }\n    }\n    \n    private void Mount(Transform rider)\n    {\n        _rider = rider;\n        _isMounted = true;\n        \n        // Disable player's character controller if it exists\n        CharacterController playerController = _rider.GetComponent<CharacterController>();\n        if (playerController != null)\n            playerController.enabled = false;\n            \n        // Position rider on mount point\n        _rider.position = _mountPoint.position;\n        _rider.SetParent(_mountPoint);\n        \n        // Update animation\n        if (_animator != null)\n            _animator.SetBool(_isMountedParameter, true);\n            \n        OnMounted?.Invoke();\n    }\n    \n    private void Dismount()\n    {\n        if (_rider != null)\n        {\n            // Re-enable player's character controller\n            CharacterController playerController = _rider.GetComponent<CharacterController>();\n            if (playerController != null)\n                playerController.enabled = true;\n                \n            // Position rider next to wolf\n            _rider.SetParent(null);\n            _rider.position = transform.position + transform.right * 2f;\n        }\n        \n        _rider = null;\n        _isMounted = false;\n        _isRunning = false;\n        _currentSpeed = 0f;\n        \n        // Update animation\n        if (_animator != null)\n        {\n            _animator.SetBool(_isMountedParameter, false);\n            _animator.SetBool(_isRunningParameter, false);\n            _animator.SetFloat(_speedParameter, 0f);\n        }\n        \n        OnDismounted?.Invoke();\n    }\n    \n    private void HandleMovementInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        bool runInput = Input.GetKey(KeyCode.LeftShift);\n        \n        Vector3 inputDirection = new Vector3(horizontal, 0, vertical).normalized;\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            // Calculate movement direction relative to camera\n            Vector3 cameraForward = _playerCamera.transform.forward;\n            Vector3 cameraRight = _playerCamera.transform.right;\n            cameraForward.y = 0;\n            cameraRight.y = 0;\n            cameraForward.Normalize();\n            cameraRight.Normalize();\n            \n            _moveDirection = (cameraForward * vertical + cameraRight * horizontal).normalized;\n            \n            // Determine if running\n            _isRunning = runInput && _currentStamina > _minStaminaToRun && inputDirection.magnitude > 0.8f;\n            \n            float targetSpeed = _isRunning ? _runSpeed : _walkSpeed;\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, targetSpeed, _acceleration * Time.deltaTime);\n            \n            // Rotate wolf to face movement direction\n            if (_moveDirection != Vector3.zero)\n            {\n                Quaternion targetRotation = Quaternion.LookRotation(_moveDirection);\n                transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _turnSpeed * Time.deltaTime);\n            }\n        }\n        else\n        {\n            _isRunning = false;\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0f, _deceleration * Time.deltaTime);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 movement = _moveDirection * _currentSpeed;\n        movement.y = -9.81f; // Apply gravity\n        \n        _characterController.Move(movement * Time.fixedDeltaTime);\n    }\n    \n    private void HandleStamina()\n    {\n        if (_isRunning && _currentSpeed > _walkSpeed)\n        {\n            _currentStamina -= _staminaDrainRate * Time.deltaTime;\n            _currentStamina = Mathf.Max(0f, _currentStamina);\n            \n            if (_currentStamina <= 0f)\n            {\n                OnStaminaDepleted?.Invoke();\n            }\n        }\n        else if (_currentStamina < _maxStamina)\n        {\n            _currentStamina += _staminaRegenRate * Time.deltaTime;\n            _currentStamina = Mathf.Min(_maxStamina, _currentStamina);\n        }\n    }\n    \n    private void UpdateAnimation()\n    {\n        if (_animator != null)\n        {\n            float normalizedSpeed = _currentSpeed / _runSpeed;\n            _animator.SetFloat(_speedParameter, normalizedSpeed);\n            _animator.SetBool(_isRunningParameter, _isRunning);\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        if (_currentSpeed > 0.1f)\n        {\n            _footstepTimer += Time.deltaTime;\n            float intervalMultiplier = _isRunning ? 0.7f : 1f;\n            \n            if (_footstepTimer >= _footstepInterval * intervalMultiplier)\n            {\n                PlayFootstepSound();\n                _footstepTimer = 0f;\n            }\n        }\n        \n        // Play breathing sounds when running\n        if (_isRunning && _breathingSounds.Length > 0 && !_audioSource.isPlaying)\n        {\n            AudioClip breathingClip = _breathingSounds[Random.Range(0, _breathingSounds.Length)];\n            _audioSource.PlayOneShot(breathingClip, 0.3f);\n        }\n    }\n    \n    private void PlayFootstepSound()\n    {\n        if (_footstepSounds.Length > 0 && _audioSource != null)\n        {\n            AudioClip footstepClip = _footstepSounds[Random.Range(0, _footstepSounds.Length)];\n            _audioSource.PlayOneShot(footstepClip, 0.5f);\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsMounted()\n    {\n        return _isMounted;\n    }\n    \n    public bool IsRunning()\n    {\n        return _isRunning;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        if (_mountPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_mountPoint.position, 0.2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChromaticAberrationEffect\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"intensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"redOffset\",\n      \"type\": \"Vector2\",\n      \"default\": \"Vector2.zero\"\n    },\n    {\n      \"name\": \"greenOffset\",\n      \"type\": \"Vector2\",\n      \"default\": \"Vector2.zero\"\n    },\n    {\n      \"name\": \"blueOffset\",\n      \"type\": \"Vector2\",\n      \"default\": \"Vector2.zero\"\n    },\n    {\n      \"name\": \"distortionCenter\",\n      \"type\": \"Vector2\",\n      \"default\": \"Vector2(0.5, 0.5)\"\n    },\n    {\n      \"name\": \"radialIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"animateEffect\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"animationSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_chromatic_aberration\",\n      \"trigger\": \"when rendering the camera view\",\n      \"actions\": [\n        {\n          \"action\": \"separate the rendered image into red green and blue color channels\"\n        },\n        {\n          \"action\": \"offset the red channel by the red offset amount\"\n        },\n        {\n          \"action\": \"offset the green channel by the green offset amount\"\n        },\n        {\n          \"action\": \"offset the blue channel by the blue offset amount\"\n        },\n        {\n          \"action\": \"apply stronger distortion toward the edges based on radial intensity\"\n        },\n        {\n          \"action\": \"recombine the offset color channels into the final image\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_aberration\",\n      \"trigger\": \"when animate effect is enabled and every frame\",\n      \"actions\": [\n        {\n          \"action\": \"calculate oscillating values based on animation speed and time\"\n        },\n        {\n          \"action\": \"update red green and blue offsets with animated values\"\n        },\n        {\n          \"action\": \"vary the intensity smoothly over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_intensity\",\n      \"trigger\": \"when intensity value changes\",\n      \"actions\": [\n        {\n          \"action\": \"scale all color channel offsets by the intensity multiplier\"\n        },\n        {\n          \"action\": \"update the shader parameters with new offset values\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\n[System.Serializable]\npublic class ChromaticAberrationSettings\n{\n    [Range(0f, 1f)]\n    public float intensity = 0.1f;\n    [Range(0f, 5f)]\n    public float speed = 1f;\n    public bool useDistanceFromCenter = true;\n    public AnimationCurve intensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n}\n\npublic class ChromaticAberrationEffect : MonoBehaviour\n{\n    [Header(\"Chromatic Aberration Settings\")]\n    [SerializeField] private ChromaticAberrationSettings _settings = new ChromaticAberrationSettings();\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _animateIntensity = false;\n    [SerializeField] private float _animationSpeed = 1f;\n    [SerializeField] private float _minIntensity = 0f;\n    [SerializeField] private float _maxIntensity = 1f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _triggerOnPlayerEnter = false;\n    [SerializeField] private float _triggerDuration = 2f;\n    [SerializeField] private AnimationCurve _triggerCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Distance-Based Effect\")]\n    [SerializeField] private bool _useDistanceEffect = false;\n    [SerializeField] private Transform _targetTransform;\n    [SerializeField] private float _maxDistance = 10f;\n    [SerializeField] private AnimationCurve _distanceCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    private Volume _postProcessVolume;\n    private ChromaticAberration _chromaticAberration;\n    private float _baseIntensity;\n    private float _currentTriggerTime;\n    private bool _isTriggered;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupChromaticAberration();\n        _baseIntensity = _settings.intensity;\n        \n        if (_targetTransform == null)\n            _targetTransform = transform;\n            \n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n    }\n    \n    private void InitializeComponents()\n    {\n        _postProcessVolume = GetComponent<Volume>();\n        \n        if (_postProcessVolume == null)\n        {\n            _postProcessVolume = gameObject.AddComponent<Volume>();\n            _postProcessVolume.isGlobal = true;\n        }\n        \n        if (_postProcessVolume.profile == null)\n        {\n            _postProcessVolume.profile = ScriptableObject.CreateInstance<VolumeProfile>();\n        }\n    }\n    \n    private void SetupChromaticAberration()\n    {\n        if (!_postProcessVolume.profile.TryGet<ChromaticAberration>(out _chromaticAberration))\n        {\n            _chromaticAberration = _postProcessVolume.profile.Add<ChromaticAberration>(false);\n        }\n        \n        _chromaticAberration.intensity.overrideState = true;\n        _chromaticAberration.intensity.value = _settings.intensity;\n        _chromaticAberration.active = true;\n    }\n    \n    private void Update()\n    {\n        if (_chromaticAberration == null) return;\n        \n        float finalIntensity = CalculateFinalIntensity();\n        _chromaticAberration.intensity.value = finalIntensity;\n        \n        UpdateTriggerEffect();\n    }\n    \n    private float CalculateFinalIntensity()\n    {\n        float intensity = _baseIntensity;\n        \n        if (_animateIntensity)\n        {\n            float animatedValue = Mathf.Lerp(_minIntensity, _maxIntensity, \n                (Mathf.Sin(Time.time * _animationSpeed) + 1f) * 0.5f);\n            intensity = animatedValue;\n        }\n        \n        if (_useDistanceEffect && _mainCamera != null)\n        {\n            float distance = Vector3.Distance(_mainCamera.transform.position, _targetTransform.position);\n            float normalizedDistance = Mathf.Clamp01(distance / _maxDistance);\n            float distanceMultiplier = _distanceCurve.Evaluate(normalizedDistance);\n            intensity *= distanceMultiplier;\n        }\n        \n        if (_isTriggered)\n        {\n            float triggerMultiplier = _triggerCurve.Evaluate(_currentTriggerTime / _triggerDuration);\n            intensity *= triggerMultiplier;\n        }\n        \n        return Mathf.Clamp01(intensity);\n    }\n    \n    private void UpdateTriggerEffect()\n    {\n        if (_isTriggered)\n        {\n            _currentTriggerTime += Time.deltaTime;\n            \n            if (_currentTriggerTime >= _triggerDuration)\n            {\n                _isTriggered = false;\n                _currentTriggerTime = 0f;\n            }\n        }\n    }\n    \n    public void TriggerEffect()\n    {\n        _isTriggered = true;\n        _currentTriggerTime = 0f;\n    }\n    \n    public void SetIntensity(float intensity)\n    {\n        _baseIntensity = Mathf.Clamp01(intensity);\n        _settings.intensity = _baseIntensity;\n    }\n    \n    public void SetAnimationEnabled(bool enabled)\n    {\n        _animateIntensity = enabled;\n    }\n    \n    public void SetAnimationSpeed(float speed)\n    {\n        _animationSpeed = speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_triggerOnPlayerEnter && other.CompareTag(\"Player\"))\n        {\n            TriggerEffect();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_settings != null)\n        {\n            _settings.intensity = Mathf.Clamp01(_settings.intensity);\n            _settings.speed = Mathf.Max(0f, _settings.speed);\n        }\n        \n        _minIntensity = Mathf.Clamp01(_minIntensity);\n        _maxIntensity = Mathf.Clamp01(_maxIntensity);\n        _triggerDuration = Mathf.Max(0.1f, _triggerDuration);\n        _maxDistance = Mathf.Max(0.1f, _maxDistance);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_postProcessVolume != null && _postProcessVolume.profile != null)\n        {\n            if (_chromaticAberration != null)\n            {\n                _postProcessVolume.profile.Remove<ChromaticAberration>();\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpeedBoots\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"speedMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isEquipped\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"equip_boots\",\n      \"trigger\": \"when player collides with boots and presses interact key\",\n      \"actions\": [\n        {\n          \"action\": \"set equipped status to true\"\n        },\n        {\n          \"action\": \"hide boots visual\"\n        },\n        {\n          \"action\": \"increase player movement speed by speed multiplier\"\n        },\n        {\n          \"action\": \"play equip sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"unequip_boots\",\n      \"trigger\": \"when boots are equipped and player presses unequip key\",\n      \"actions\": [\n        {\n          \"action\": \"set equipped status to false\"\n        },\n        {\n          \"action\": \"restore player normal movement speed\"\n        },\n        {\n          \"action\": \"drop boots at player location\"\n        },\n        {\n          \"action\": \"show boots visual\"\n        },\n        {\n          \"action\": \"play unequip sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"speed_boost_effect\",\n      \"trigger\": \"while boots are equipped and player is moving\",\n      \"actions\": [\n        {\n          \"action\": \"apply speed multiplier to player movement\"\n        },\n        {\n          \"action\": \"create dust particle effects at feet\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpeedBoots : MonoBehaviour\n{\n    [Header(\"Speed Boost Settings\")]\n    [SerializeField] private float _speedMultiplier = 1.5f;\n    [SerializeField] private float _boostDuration = 10f;\n    [SerializeField] private bool _isPermanent = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private ParticleSystem _speedTrailEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBootsPickedUp;\n    public UnityEvent OnSpeedBoostExpired;\n    \n    private AudioSource _audioSource;\n    private bool _hasBeenPickedUp = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasBeenPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpeedBoost(other.gameObject);\n        }\n    }\n    \n    private void ApplySpeedBoost(GameObject player)\n    {\n        CharacterController characterController = player.GetComponent<CharacterController>();\n        Rigidbody playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (characterController != null)\n        {\n            ApplySpeedBoostToCharacterController(characterController);\n        }\n        else if (playerRigidbody != null)\n        {\n            ApplySpeedBoostToRigidbody(player);\n        }\n        else\n        {\n            ApplySpeedBoostToTransform(player);\n        }\n        \n        PlayPickupEffects();\n        OnBootsPickedUp?.Invoke();\n        _hasBeenPickedUp = true;\n        \n        if (!_isPermanent)\n        {\n            Invoke(nameof(RemoveSpeedBoost), _boostDuration);\n        }\n        \n        gameObject.SetActive(false);\n    }\n    \n    private void ApplySpeedBoostToCharacterController(CharacterController controller)\n    {\n        SpeedBoostComponent speedBoost = controller.gameObject.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = controller.gameObject.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void ApplySpeedBoostToRigidbody(GameObject player)\n    {\n        SpeedBoostComponent speedBoost = player.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = player.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void ApplySpeedBoostToTransform(GameObject player)\n    {\n        SpeedBoostComponent speedBoost = player.GetComponent<SpeedBoostComponent>();\n        if (speedBoost == null)\n        {\n            speedBoost = player.AddComponent<SpeedBoostComponent>();\n        }\n        \n        speedBoost.Initialize(_speedMultiplier, _boostDuration, _isPermanent, _speedTrailEffect);\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        OnSpeedBoostExpired?.Invoke();\n    }\n}\n\npublic class SpeedBoostComponent : MonoBehaviour\n{\n    private float _originalSpeed;\n    private float _speedMultiplier;\n    private float _boostDuration;\n    private bool _isPermanent;\n    private ParticleSystem _trailEffect;\n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private bool _isActive = false;\n    \n    public void Initialize(float speedMultiplier, float duration, bool isPermanent, ParticleSystem trailEffect)\n    {\n        _speedMultiplier = speedMultiplier;\n        _boostDuration = duration;\n        _isPermanent = isPermanent;\n        _trailEffect = trailEffect;\n        \n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        ApplySpeedBoost();\n        \n        if (_trailEffect != null)\n        {\n            ParticleSystem trail = Instantiate(_trailEffect, transform);\n            trail.Play();\n            \n            if (!_isPermanent)\n            {\n                Destroy(trail.gameObject, _boostDuration);\n            }\n        }\n        \n        if (!_isPermanent)\n        {\n            Invoke(nameof(RemoveSpeedBoost), _boostDuration);\n        }\n    }\n    \n    private void ApplySpeedBoost()\n    {\n        if (_isActive) return;\n        \n        _isActive = true;\n        \n        // Store original speed based on component type\n        if (_characterController != null)\n        {\n            // For CharacterController, we'll modify movement in a basic movement script\n            BasicPlayerMovement movement = GetComponent<BasicPlayerMovement>();\n            if (movement == null)\n            {\n                movement = gameObject.AddComponent<BasicPlayerMovement>();\n            }\n            movement.ApplySpeedMultiplier(_speedMultiplier);\n        }\n        else if (_rigidbody != null)\n        {\n            // For Rigidbody, we'll modify drag to simulate speed increase\n            _originalSpeed = _rigidbody.drag;\n            _rigidbody.drag = _originalSpeed / _speedMultiplier;\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        if (!_isActive) return;\n        \n        _isActive = false;\n        \n        if (_characterController != null)\n        {\n            BasicPlayerMovement movement = GetComponent<BasicPlayerMovement>();\n            if (movement != null)\n            {\n                movement.RemoveSpeedMultiplier();\n            }\n        }\n        else if (_rigidbody != null)\n        {\n            _rigidbody.drag = _originalSpeed;\n        }\n        \n        if (!_isPermanent)\n        {\n            Destroy(this);\n        }\n    }\n}\n\npublic class BasicPlayerMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _baseSpeed = 5f;\n    [SerializeField] private float _jumpForce = 5f;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _currentSpeedMultiplier = 1f;\n    private Vector3 _velocity;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n    }\n    \n    private void Update()\n    {\n        if (_characterController != null)\n        {\n            HandleCharacterControllerMovement();\n        }\n        else if (_rigidbody != null)\n        {\n            HandleRigidbodyMovement();\n        }\n    }\n    \n    private void HandleCharacterControllerMovement()\n    {\n        _isGrounded = _characterController.isGrounded;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _characterController.Move(moveDirection * _baseSpeed * _currentSpeedMultiplier * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _velocity.y = Mathf.Sqrt(_jumpForce * -2f * Physics.gravity.y);\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        _characterController.Move(_velocity * Time.deltaTime);\n    }\n    \n    private void HandleRigidbodyMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _rigidbody.MovePosition(transform.position + moveDirection * _baseSpeed * _currentSpeedMultiplier * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        }\n    }\n    \n    public void ApplySpeedMultiplier(float multiplier)\n    {\n        _currentSpeedMultiplier = multiplier;\n    }\n    \n    public void RemoveSpeedMultiplier()\n    {\n        _currentSpeedMultiplier = 1f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Quicksand\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slowdownFactor\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"sinkingSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"maxSinkDepth\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"slow_player_movement\",\n      \"trigger\": \"when player enters quicksand area\",\n      \"actions\": [\n        {\n          \"action\": \"reduce player movement speed by slowdown factor\"\n        },\n        {\n          \"action\": \"apply visual effect to show player is in quicksand\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sink_player\",\n      \"trigger\": \"while player remains in quicksand\",\n      \"actions\": [\n        {\n          \"action\": \"gradually lower player position at sinking speed\"\n        },\n        {\n          \"action\": \"stop sinking when maximum depth is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"restore_normal_movement\",\n      \"trigger\": \"when player exits quicksand area\",\n      \"actions\": [\n        {\n          \"action\": \"restore player movement speed to normal\"\n        },\n        {\n          \"action\": \"remove quicksand visual effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"create_struggle_effect\",\n      \"trigger\": \"when player tries to move while in quicksand\",\n      \"actions\": [\n        {\n          \"action\": \"play struggling animation\"\n        },\n        {\n          \"action\": \"create particle effects around player\"\n        },\n        {\n          \"action\": \"play quicksand sound effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Quicksand : MonoBehaviour\n{\n    [Header(\"Quicksand Settings\")]\n    [SerializeField] private float _slowdownFactor = 0.3f;\n    [SerializeField] private float _sinkDepth = 0.5f;\n    [SerializeField] private float _sinkSpeed = 1f;\n    [SerializeField] private float _exitSpeed = 2f;\n    [SerializeField] private bool _affectsJumping = true;\n    [SerializeField] private float _jumpReduction = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    [SerializeField] private AudioClip _strugglingSound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private string[] _affectedTags = { \"Player\", \"Enemy\", \"NPC\" };\n    \n    private Dictionary<GameObject, QuicksandData> _affectedObjects = new Dictionary<GameObject, QuicksandData>();\n    private Collider _collider;\n    \n    private class QuicksandData\n    {\n        public Vector3 originalPosition;\n        public float originalSpeed;\n        public float originalJumpForce;\n        public bool isCharacterController;\n        public CharacterController characterController;\n        public Rigidbody rigidBody;\n        public float timeInQuicksand;\n        public bool hasModifiedMovement;\n    }\n    \n    private void Start()\n    {\n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            Debug.LogError(\"Quicksand requires a Collider component!\");\n            return;\n        }\n        \n        if (!_collider.isTrigger)\n        {\n            _collider.isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateAffectedObjects();\n    }\n    \n    private void UpdateAffectedObjects()\n    {\n        var objectsToRemove = new List<GameObject>();\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            var obj = kvp.Key;\n            var data = kvp.Value;\n            \n            if (obj == null)\n            {\n                objectsToRemove.Add(obj);\n                continue;\n            }\n            \n            data.timeInQuicksand += Time.deltaTime;\n            \n            // Sink the object\n            Vector3 targetPosition = data.originalPosition - Vector3.up * _sinkDepth;\n            obj.transform.position = Vector3.MoveTowards(obj.transform.position, targetPosition, _sinkSpeed * Time.deltaTime);\n            \n            // Apply movement slowdown\n            ApplyMovementSlowdown(obj, data);\n        }\n        \n        // Remove null objects\n        foreach (var obj in objectsToRemove)\n        {\n            _affectedObjects.Remove(obj);\n        }\n    }\n    \n    private void ApplyMovementSlowdown(GameObject obj, QuicksandData data)\n    {\n        if (data.hasModifiedMovement) return;\n        \n        // Try to modify CharacterController\n        if (data.characterController != null)\n        {\n            // CharacterController speed modification would need to be handled by the movement script\n            // We'll use a different approach - modify the object's scale or add a component\n            var slowdownComponent = obj.GetComponent<QuicksandSlowdown>();\n            if (slowdownComponent == null)\n            {\n                slowdownComponent = obj.AddComponent<QuicksandSlowdown>();\n            }\n            slowdownComponent.SetSlowdownFactor(_slowdownFactor);\n            data.hasModifiedMovement = true;\n        }\n        \n        // Modify Rigidbody drag\n        if (data.rigidBody != null)\n        {\n            data.rigidBody.drag = Mathf.Max(data.rigidBody.drag, 10f * (1f - _slowdownFactor));\n            data.rigidBody.angularDrag = Mathf.Max(data.rigidBody.angularDrag, 5f * (1f - _slowdownFactor));\n            data.hasModifiedMovement = true;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!ShouldAffectObject(other.gameObject)) return;\n        \n        if (_affectedObjects.ContainsKey(other.gameObject)) return;\n        \n        var data = new QuicksandData\n        {\n            originalPosition = other.transform.position,\n            timeInQuicksand = 0f,\n            hasModifiedMovement = false\n        };\n        \n        // Store original movement data\n        data.characterController = other.GetComponent<CharacterController>();\n        data.rigidBody = other.GetComponent<Rigidbody>();\n        data.isCharacterController = data.characterController != null;\n        \n        _affectedObjects[other.gameObject] = data;\n        \n        // Play enter effects\n        PlayEnterEffects();\n        \n        // Notify the object it entered quicksand\n        other.SendMessage(\"OnEnterQuicksand\", _slowdownFactor, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_affectedObjects.ContainsKey(other.gameObject)) return;\n        \n        var data = _affectedObjects[other.gameObject];\n        \n        // Restore original position gradually\n        StartCoroutine(RestoreObjectPosition(other.gameObject, data));\n        \n        // Remove slowdown effects\n        RemoveSlowdownEffects(other.gameObject, data);\n        \n        _affectedObjects.Remove(other.gameObject);\n        \n        // Play exit effects\n        PlayExitEffects();\n        \n        // Notify the object it exited quicksand\n        other.SendMessage(\"OnExitQuicksand\", SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private System.Collections.IEnumerator RestoreObjectPosition(GameObject obj, QuicksandData data)\n    {\n        if (obj == null) yield break;\n        \n        Vector3 startPos = obj.transform.position;\n        Vector3 targetPos = data.originalPosition;\n        float journey = 0f;\n        \n        while (journey <= 1f && obj != null)\n        {\n            journey += Time.deltaTime * _exitSpeed;\n            obj.transform.position = Vector3.Lerp(startPos, targetPos, journey);\n            yield return null;\n        }\n    }\n    \n    private void RemoveSlowdownEffects(GameObject obj, QuicksandData data)\n    {\n        if (obj == null) return;\n        \n        // Remove slowdown component\n        var slowdownComponent = obj.GetComponent<QuicksandSlowdown>();\n        if (slowdownComponent != null)\n        {\n            Destroy(slowdownComponent);\n        }\n        \n        // Restore Rigidbody properties\n        if (data.rigidBody != null)\n        {\n            data.rigidBody.drag = 0f;\n            data.rigidBody.angularDrag = 0.05f;\n        }\n    }\n    \n    private bool ShouldAffectObject(GameObject obj)\n    {\n        // Check layer\n        if ((_affectedLayers.value & (1 << obj.layer)) == 0) return false;\n        \n        // Check tags\n        foreach (string tag in _affectedTags)\n        {\n            if (obj.CompareTag(tag)) return true;\n        }\n        \n        return false;\n    }\n    \n    private void PlayEnterEffects()\n    {\n        if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Play();\n        }\n        \n        if (_audioSource != null && _enterSound != null)\n        {\n            _audioSource.PlayOneShot(_enterSound);\n        }\n    }\n    \n    private void PlayExitEffects()\n    {\n        if (_audioSource != null && _exitSound != null)\n        {\n            _audioSource.PlayOneShot(_exitSound);\n        }\n        \n        if (_affectedObjects.Count == 0 && _bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = new Color(0.8f, 0.6f, 0.2f, 0.3f);\n        if (_collider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            if (_collider is BoxCollider box)\n            {\n                Gizmos.DrawCube(box.center, box.size);\n            }\n            else if (_collider is SphereCollider sphere)\n            {\n                Gizmos.DrawSphere(sphere.center, sphere.radius);\n            }\n        }\n        \n        // Draw sink depth\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position - Vector3.up * _sinkDepth, transform.localScale);\n    }\n}\n\npublic class QuicksandSlowdown : MonoBehaviour\n{\n    private float _slowdownFactor = 1f;\n    \n    public void SetSlowdownFactor(float factor)\n    {\n        _slowdownFactor = factor;\n    }\n    \n    public float GetSlowdownFactor()\n    {\n        return _slowdownFactor;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpinAxe\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"spinSpeed\",\n      \"type\": \"float\",\n      \"default\": 360\n    },\n    {\n      \"name\": \"spinDuration\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isSpinning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_spin_attack\",\n      \"trigger\": \"when attack input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set spinning state to true\"\n        },\n        {\n          \"action\": \"start rotating around vertical axis at spin speed\"\n        },\n        {\n          \"action\": \"play spinning sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_enemies_while_spinning\",\n      \"trigger\": \"when spinning and colliding with enemy\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to enemy\"\n        },\n        {\n          \"action\": \"apply knockback force to enemy\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_spin_attack\",\n      \"trigger\": \"when spin duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set spinning state to false\"\n        },\n        {\n          \"action\": \"stop rotation gradually\"\n        },\n        {\n          \"action\": \"stop spinning sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpinAxe : MonoBehaviour\n{\n    [Header(\"Axe Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _spinDuration = 1.5f;\n    [SerializeField] private float _spinSpeed = 720f;\n    [SerializeField] private float _cooldownTime = 3f;\n    [SerializeField] private float _attackRadius = 2f;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _spinEffect;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _spinSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSpinStart;\n    public UnityEvent OnSpinEnd;\n    public UnityEvent<GameObject> OnEnemyHit;\n    \n    private bool _isSpinning = false;\n    private bool _canSpin = true;\n    private float _spinTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Transform _axeTransform;\n    private Vector3 _originalRotation;\n    private System.Collections.Generic.HashSet<Collider> _hitEnemies = new System.Collections.Generic.HashSet<Collider>();\n    \n    private void Start()\n    {\n        _axeTransform = transform;\n        _originalRotation = _axeTransform.eulerAngles;\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        HandleSpinInput();\n        HandleSpinRotation();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (!_canSpin)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canSpin = true;\n            }\n        }\n    }\n    \n    private void HandleSpinInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) && _canSpin && !_isSpinning)\n        {\n            StartSpinAttack();\n        }\n    }\n    \n    private void HandleSpinRotation()\n    {\n        if (_isSpinning)\n        {\n            _spinTimer -= Time.deltaTime;\n            \n            float rotationAmount = _spinSpeed * Time.deltaTime;\n            _axeTransform.Rotate(0, 0, rotationAmount);\n            \n            CheckForEnemiesInRange();\n            \n            if (_spinTimer <= 0f)\n            {\n                EndSpinAttack();\n            }\n        }\n    }\n    \n    private void StartSpinAttack()\n    {\n        _isSpinning = true;\n        _canSpin = false;\n        _spinTimer = _spinDuration;\n        _cooldownTimer = _cooldownTime;\n        _hitEnemies.Clear();\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = true;\n            \n        if (_spinEffect != null)\n            _spinEffect.Play();\n            \n        if (_audioSource != null && _spinSound != null)\n            _audioSource.PlayOneShot(_spinSound);\n            \n        OnSpinStart?.Invoke();\n    }\n    \n    private void EndSpinAttack()\n    {\n        _isSpinning = false;\n        _axeTransform.eulerAngles = _originalRotation;\n        \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        if (_spinEffect != null)\n            _spinEffect.Stop();\n            \n        OnSpinEnd?.Invoke();\n    }\n    \n    private void CheckForEnemiesInRange()\n    {\n        Collider[] enemiesInRange = Physics.OverlapSphere(_axeTransform.position, _attackRadius, _enemyLayers);\n        \n        foreach (Collider enemy in enemiesInRange)\n        {\n            if (!_hitEnemies.Contains(enemy) && !enemy.CompareTag(\"Player\"))\n            {\n                HitEnemy(enemy);\n                _hitEnemies.Add(enemy);\n            }\n        }\n    }\n    \n    private void HitEnemy(Collider enemy)\n    {\n        // Apply damage through various methods\n        var healthComponent = enemy.GetComponent<Health>();\n        if (healthComponent != null)\n        {\n            healthComponent.TakeDamage(_damage);\n        }\n        \n        // Try alternative damage methods\n        enemy.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        enemy.SendMessage(\"OnHit\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Apply knockback\n        Rigidbody enemyRb = enemy.GetComponent<Rigidbody>();\n        if (enemyRb != null)\n        {\n            Vector3 knockbackDirection = (enemy.transform.position - _axeTransform.position).normalized;\n            enemyRb.AddForce(knockbackDirection * 500f);\n        }\n        \n        // Play hit sound\n        if (_audioSource != null && _hitSound != null)\n            _audioSource.PlayOneShot(_hitSound);\n            \n        OnEnemyHit?.Invoke(enemy.gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isSpinning ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRadius);\n    }\n    \n    [System.Serializable]\n    public class Health : MonoBehaviour\n    {\n        [SerializeField] private float _maxHealth = 100f;\n        private float _currentHealth;\n        \n        private void Start()\n        {\n            _currentHealth = _maxHealth;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            _currentHealth -= damage;\n            if (_currentHealth <= 0f)\n            {\n                Die();\n            }\n        }\n        \n        private void Die()\n        {\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PressurePlate\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"requiredWeight\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"currentWeight\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"activationThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"pressDepth\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_weight_added\",\n      \"trigger\": \"when object with rigidbody enters trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"add the mass of the entering object to current weight\"\n        },\n        {\n          \"action\": \"check if total weight meets activation requirements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_weight_removed\",\n      \"trigger\": \"when object with rigidbody exits trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"subtract the mass of the exiting object from current weight\"\n        },\n        {\n          \"action\": \"check if total weight still meets activation requirements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_plate\",\n      \"trigger\": \"when current weight exceeds required weight threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set activation state to true\"\n        },\n        {\n          \"action\": \"lower the plate by press depth amount\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"change plate material to activated appearance\"\n        },\n        {\n          \"action\": \"send activation signal to connected mechanisms\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_plate\",\n      \"trigger\": \"when current weight falls below required weight threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set activation state to false\"\n        },\n        {\n          \"action\": \"raise the plate back to original position\"\n        },\n        {\n          \"action\": \"play deactivation sound effect\"\n        },\n        {\n          \"action\": \"change plate material back to inactive appearance\"\n        },\n        {\n          \"action\": \"send deactivation signal to connected mechanisms\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when weight changes on the plate\",\n      \"actions\": [\n        {\n          \"action\": \"adjust plate height based on current weight ratio\"\n        },\n        {\n          \"action\": \"update visual indicator showing weight progress\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Pressure Plate Settings\")]\n    [SerializeField] private float _requiredWeight = 10f;\n    [SerializeField] private float _activationDelay = 0.1f;\n    [SerializeField] private bool _requiresContinuousWeight = true;\n    [SerializeField] private bool _isOneTimeUse = false;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Transform _plateTransform;\n    [SerializeField] private float _pressedHeight = -0.1f;\n    [SerializeField] private float _animationSpeed = 5f;\n    [SerializeField] private Material _activeMaterial;\n    [SerializeField] private Material _inactiveMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onActivated;\n    [SerializeField] private UnityEvent _onDeactivated;\n    \n    private List<WeightedObject> _objectsOnPlate = new List<WeightedObject>();\n    private float _currentWeight = 0f;\n    private bool _isActivated = false;\n    private bool _hasBeenUsed = false;\n    private float _originalHeight;\n    private float _activationTimer = 0f;\n    private Renderer _plateRenderer;\n    private Collider _plateCollider;\n    \n    [System.Serializable]\n    public class WeightedObject\n    {\n        public GameObject gameObject;\n        public float weight;\n        \n        public WeightedObject(GameObject obj, float w)\n        {\n            gameObject = obj;\n            weight = w;\n        }\n    }\n    \n    void Start()\n    {\n        if (_plateTransform == null)\n            _plateTransform = transform;\n            \n        _originalHeight = _plateTransform.position.y;\n        _plateRenderer = GetComponent<Renderer>();\n        _plateCollider = GetComponent<Collider>();\n        \n        if (_plateCollider != null)\n            _plateCollider.isTrigger = true;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        UpdateVisuals();\n    }\n    \n    void Update()\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        UpdatePlatePosition();\n        \n        if (_activationTimer > 0f)\n        {\n            _activationTimer -= Time.deltaTime;\n            if (_activationTimer <= 0f)\n            {\n                CheckActivation();\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        float weight = GetObjectWeight(other.gameObject);\n        if (weight > 0f)\n        {\n            WeightedObject weightedObj = new WeightedObject(other.gameObject, weight);\n            _objectsOnPlate.Add(weightedObj);\n            _currentWeight += weight;\n            \n            _activationTimer = _activationDelay;\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        WeightedObject objToRemove = _objectsOnPlate.Find(obj => obj.gameObject == other.gameObject);\n        if (objToRemove != null)\n        {\n            _objectsOnPlate.Remove(objToRemove);\n            _currentWeight -= objToRemove.weight;\n            _currentWeight = Mathf.Max(0f, _currentWeight);\n            \n            if (_requiresContinuousWeight)\n            {\n                _activationTimer = _activationDelay;\n            }\n        }\n    }\n    \n    private float GetObjectWeight(GameObject obj)\n    {\n        // Check for Rigidbody mass\n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            return rb.mass;\n        }\n        \n        // Check for player tag (default weight)\n        if (obj.CompareTag(\"Player\"))\n        {\n            return 5f;\n        }\n        \n        // Check for specific tags with predefined weights\n        if (obj.CompareTag(\"Heavy\"))\n            return 15f;\n        if (obj.CompareTag(\"Light\"))\n            return 2f;\n            \n        // Default weight for untagged objects\n        return 1f;\n    }\n    \n    private void CheckActivation()\n    {\n        bool shouldBeActive = _currentWeight >= _requiredWeight;\n        \n        if (shouldBeActive && !_isActivated)\n        {\n            ActivatePlate();\n        }\n        else if (!shouldBeActive && _isActivated && _requiresContinuousWeight)\n        {\n            DeactivatePlate();\n        }\n    }\n    \n    private void ActivatePlate()\n    {\n        if (_hasBeenUsed && _isOneTimeUse)\n            return;\n            \n        _isActivated = true;\n        _hasBeenUsed = true;\n        \n        UpdateVisuals();\n        PlaySound(_activationSound);\n        _onActivated?.Invoke();\n    }\n    \n    private void DeactivatePlate()\n    {\n        if (_isOneTimeUse && _hasBeenUsed)\n            return;\n            \n        _isActivated = false;\n        \n        UpdateVisuals();\n        PlaySound(_deactivationSound);\n        _onDeactivated?.Invoke();\n    }\n    \n    private void UpdatePlatePosition()\n    {\n        float targetHeight = _isActivated ? _originalHeight + _pressedHeight : _originalHeight;\n        Vector3 currentPos = _plateTransform.position;\n        Vector3 targetPos = new Vector3(currentPos.x, targetHeight, currentPos.z);\n        \n        _plateTransform.position = Vector3.Lerp(currentPos, targetPos, Time.deltaTime * _animationSpeed);\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_plateRenderer != null)\n        {\n            if (_isActivated && _activeMaterial != null)\n            {\n                _plateRenderer.material = _activeMaterial;\n            }\n            else if (!_isActivated && _inactiveMaterial != null)\n            {\n                _plateRenderer.material = _inactiveMaterial;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsActivated()\n    {\n        return _isActivated;\n    }\n    \n    public float GetCurrentWeight()\n    {\n        return _currentWeight;\n    }\n    \n    public float GetRequiredWeight()\n    {\n        return _requiredWeight;\n    }\n    \n    public void SetRequiredWeight(float weight)\n    {\n        _requiredWeight = weight;\n    }\n    \n    public void ResetPlate()\n    {\n        if (_isOneTimeUse)\n            return;\n            \n        _objectsOnPlate.Clear();\n        _currentWeight = 0f;\n        _isActivated = false;\n        _hasBeenUsed = false;\n        _activationTimer = 0f;\n        \n        UpdateVisuals();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActivated ? Color.green : Color.red;\n        Gizmos.DrawWireCube(transform.position, GetComponent<Collider>()?.bounds.size ?? Vector3.one);\n        \n        // Draw weight indicator\n        Gizmos.color = Color.yellow;\n        Vector3 textPos = transform.position + Vector3.up * 2f;\n        \n        #if UNITY_EDITOR\n        UnityEditor.Handles.Label(textPos, $\"Weight: {_currentWeight:F1}/{_requiredWeight:F1}\");\n        #endif\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PatrollingEnemy\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"waypoints\",\n      \"type\": \"Transform[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"patrolSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"waitTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"currentWaypointIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isWaiting\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_patrol\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set current waypoint to first waypoint in array\"\n        },\n        {\n          \"action\": \"begin moving toward current waypoint\"\n        }\n      ]\n    },\n    {\n      \"name\": \"move_to_waypoint\",\n      \"trigger\": \"when not waiting and waypoints exist\",\n      \"actions\": [\n        {\n          \"action\": \"move toward current waypoint at patrol speed\"\n        },\n        {\n          \"action\": \"face direction of movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reach_waypoint\",\n      \"trigger\": \"when arriving at current waypoint\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"start waiting for specified wait time\"\n        },\n        {\n          \"action\": \"increment waypoint index to next waypoint\"\n        },\n        {\n          \"action\": \"wrap waypoint index to beginning if at end of array\"\n        }\n      ]\n    },\n    {\n      \"name\": \"resume_patrol\",\n      \"trigger\": \"when wait time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"stop waiting\"\n        },\n        {\n          \"action\": \"resume moving toward new current waypoint\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class EnemyPatrol : MonoBehaviour\n{\n    [Header(\"Patrol Settings\")]\n    [SerializeField] private Transform[] _waypoints;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _waitTime = 2f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _loopPatrol = true;\n    [SerializeField] private bool _reverseOnEnd = true;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnPlayerLost;\n    public UnityEvent OnWaypointReached;\n    \n    private int _currentWaypointIndex = 0;\n    private bool _isWaiting = false;\n    private bool _isReversing = false;\n    private float _waitTimer = 0f;\n    private Vector3 _startPosition;\n    private bool _playerDetected = false;\n    private Transform _detectedPlayer;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_waypoints == null || _waypoints.Length == 0)\n        {\n            Debug.LogWarning($\"EnemyPatrol on {gameObject.name} has no waypoints assigned!\");\n            enabled = false;\n            return;\n        }\n        \n        ValidateWaypoints();\n        \n        if (_waypoints.Length > 0)\n        {\n            transform.position = _waypoints[0].position;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_waypoints == null || _waypoints.Length == 0) return;\n        \n        CheckForPlayer();\n        \n        if (!_playerDetected)\n        {\n            HandlePatrol();\n        }\n    }\n    \n    private void HandlePatrol()\n    {\n        if (_isWaiting)\n        {\n            _waitTimer += Time.deltaTime;\n            if (_waitTimer >= _waitTime)\n            {\n                _isWaiting = false;\n                _waitTimer = 0f;\n                MoveToNextWaypoint();\n            }\n            return;\n        }\n        \n        Transform targetWaypoint = _waypoints[_currentWaypointIndex];\n        if (targetWaypoint == null) return;\n        \n        Vector3 targetPosition = targetWaypoint.position;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n        \n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _moveSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.1f)\n        {\n            OnWaypointReached?.Invoke();\n            \n            if (_waitTime > 0f)\n            {\n                _isWaiting = true;\n            }\n            else\n            {\n                MoveToNextWaypoint();\n            }\n        }\n    }\n    \n    private void MoveToNextWaypoint()\n    {\n        if (_waypoints.Length <= 1) return;\n        \n        if (_loopPatrol)\n        {\n            _currentWaypointIndex = (_currentWaypointIndex + 1) % _waypoints.Length;\n        }\n        else if (_reverseOnEnd)\n        {\n            if (!_isReversing)\n            {\n                _currentWaypointIndex++;\n                if (_currentWaypointIndex >= _waypoints.Length)\n                {\n                    _currentWaypointIndex = _waypoints.Length - 2;\n                    _isReversing = true;\n                }\n            }\n            else\n            {\n                _currentWaypointIndex--;\n                if (_currentWaypointIndex < 0)\n                {\n                    _currentWaypointIndex = 1;\n                    _isReversing = false;\n                }\n            }\n        }\n        else\n        {\n            _currentWaypointIndex++;\n            if (_currentWaypointIndex >= _waypoints.Length)\n            {\n                _currentWaypointIndex = _waypoints.Length - 1;\n            }\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        bool playerFound = false;\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(_playerTag))\n            {\n                if (!_playerDetected)\n                {\n                    _playerDetected = true;\n                    _detectedPlayer = col.transform;\n                    OnPlayerDetected?.Invoke();\n                }\n                playerFound = true;\n                break;\n            }\n        }\n        \n        if (!playerFound && _playerDetected)\n        {\n            _playerDetected = false;\n            _detectedPlayer = null;\n            OnPlayerLost?.Invoke();\n        }\n    }\n    \n    private void ValidateWaypoints()\n    {\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            if (_waypoints[i] == null)\n            {\n                Debug.LogWarning($\"EnemyPatrol on {gameObject.name} has null waypoint at index {i}\");\n            }\n        }\n    }\n    \n    public void SetWaypoints(Transform[] newWaypoints)\n    {\n        _waypoints = newWaypoints;\n        _currentWaypointIndex = 0;\n        _isReversing = false;\n        ValidateWaypoints();\n    }\n    \n    public void AddWaypoint(Transform waypoint)\n    {\n        if (waypoint == null) return;\n        \n        Transform[] newWaypoints = new Transform[_waypoints.Length + 1];\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            newWaypoints[i] = _waypoints[i];\n        }\n        newWaypoints[_waypoints.Length] = waypoint;\n        _waypoints = newWaypoints;\n    }\n    \n    public void PausePatrol()\n    {\n        enabled = false;\n    }\n    \n    public void ResumePatrol()\n    {\n        enabled = true;\n    }\n    \n    public void ResetToStart()\n    {\n        _currentWaypointIndex = 0;\n        _isReversing = false;\n        _isWaiting = false;\n        _waitTimer = 0f;\n        _playerDetected = false;\n        _detectedPlayer = null;\n        \n        if (_waypoints != null && _waypoints.Length > 0 && _waypoints[0] != null)\n        {\n            transform.position = _waypoints[0].position;\n        }\n        else\n        {\n            transform.position = _startPosition;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_waypoints == null || _waypoints.Length == 0) return;\n        \n        Gizmos.color = Color.blue;\n        for (int i = 0; i < _waypoints.Length; i++)\n        {\n            if (_waypoints[i] == null) continue;\n            \n            Gizmos.DrawWireSphere(_waypoints[i].position, 0.5f);\n            \n            if (i < _waypoints.Length - 1 && _waypoints[i + 1] != null)\n            {\n                Gizmos.DrawLine(_waypoints[i].position, _waypoints[i + 1].position);\n            }\n            else if (_loopPatrol && i == _waypoints.Length - 1 && _waypoints[0] != null)\n            {\n                Gizmos.DrawLine(_waypoints[i].position, _waypoints[0].position);\n            }\n        }\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_waypoints.Length > 0 && _waypoints[_currentWaypointIndex] != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_waypoints[_currentWaypointIndex].position, 0.7f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PingIndicator\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pingDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"pulseScale\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_ping\",\n      \"trigger\": \"when ping is triggered\",\n      \"actions\": [\n        {\n          \"action\": \"make indicator visible\"\n        },\n        {\n          \"action\": \"set active state to true\"\n        },\n        {\n          \"action\": \"start fade in animation\"\n        },\n        {\n          \"action\": \"begin pulse scaling effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_animation\",\n      \"trigger\": \"while ping is active\",\n      \"actions\": [\n        {\n          \"action\": \"scale up to pulse scale size\"\n        },\n        {\n          \"action\": \"scale back down to normal size\"\n        },\n        {\n          \"action\": \"repeat pulsing motion smoothly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out\",\n      \"trigger\": \"when ping duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce opacity\"\n        },\n        {\n          \"action\": \"fade out at specified fade speed\"\n        },\n        {\n          \"action\": \"stop pulsing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_ping\",\n      \"trigger\": \"when fade out is complete\",\n      \"actions\": [\n        {\n          \"action\": \"make indicator invisible\"\n        },\n        {\n          \"action\": \"set active state to false\"\n        },\n        {\n          \"action\": \"reset scale to normal size\"\n        },\n        {\n          \"action\": \"reset opacity to full\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\n\npublic class PingIndicator : MonoBehaviour\n{\n    [Header(\"Ping Display\")]\n    [SerializeField] private Text _pingText;\n    [SerializeField] private Image _pingIcon;\n    [SerializeField] private string _pingPrefix = \"Ping: \";\n    [SerializeField] private string _pingSuffix = \"ms\";\n    \n    [Header(\"Update Settings\")]\n    [SerializeField] private float _updateInterval = 1f;\n    [SerializeField] private int _sampleCount = 10;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _goodPingColor = Color.green;\n    [SerializeField] private Color _averagePingColor = Color.yellow;\n    [SerializeField] private Color _badPingColor = Color.red;\n    [SerializeField] private int _goodPingThreshold = 50;\n    [SerializeField] private int _badPingThreshold = 150;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulseAnimation = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    private float[] _pingSamples;\n    private int _currentSampleIndex;\n    private float _currentPing;\n    private float _averagePing;\n    private Coroutine _updateCoroutine;\n    private Vector3 _originalScale;\n    \n    private void Start()\n    {\n        InitializePingIndicator();\n        StartPingUpdates();\n    }\n    \n    private void Update()\n    {\n        if (_enablePulseAnimation && _pingIcon != null)\n        {\n            UpdatePulseAnimation();\n        }\n    }\n    \n    private void InitializePingIndicator()\n    {\n        _pingSamples = new float[_sampleCount];\n        _currentSampleIndex = 0;\n        _currentPing = 0f;\n        _averagePing = 0f;\n        \n        if (_pingIcon != null)\n        {\n            _originalScale = _pingIcon.transform.localScale;\n        }\n        \n        if (_pingText != null)\n        {\n            _pingText.text = _pingPrefix + \"...\" + _pingSuffix;\n        }\n    }\n    \n    private void StartPingUpdates()\n    {\n        if (_updateCoroutine != null)\n        {\n            StopCoroutine(_updateCoroutine);\n        }\n        \n        _updateCoroutine = StartCoroutine(UpdatePingRoutine());\n    }\n    \n    private IEnumerator UpdatePingRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_updateInterval);\n            UpdatePing();\n        }\n    }\n    \n    private void UpdatePing()\n    {\n        _currentPing = SimulatePing();\n        \n        _pingSamples[_currentSampleIndex] = _currentPing;\n        _currentSampleIndex = (_currentSampleIndex + 1) % _sampleCount;\n        \n        CalculateAveragePing();\n        UpdateDisplay();\n        UpdateVisualFeedback();\n    }\n    \n    private float SimulatePing()\n    {\n        float basePing = Random.Range(20f, 200f);\n        float variation = Random.Range(-10f, 10f);\n        return Mathf.Max(1f, basePing + variation);\n    }\n    \n    private void CalculateAveragePing()\n    {\n        float sum = 0f;\n        int validSamples = 0;\n        \n        for (int i = 0; i < _pingSamples.Length; i++)\n        {\n            if (_pingSamples[i] > 0f)\n            {\n                sum += _pingSamples[i];\n                validSamples++;\n            }\n        }\n        \n        _averagePing = validSamples > 0 ? sum / validSamples : _currentPing;\n    }\n    \n    private void UpdateDisplay()\n    {\n        if (_pingText != null)\n        {\n            int displayPing = Mathf.RoundToInt(_averagePing);\n            _pingText.text = _pingPrefix + displayPing.ToString() + _pingSuffix;\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        Color targetColor = GetPingColor(_averagePing);\n        \n        if (_pingText != null)\n        {\n            _pingText.color = targetColor;\n        }\n        \n        if (_pingIcon != null)\n        {\n            _pingIcon.color = targetColor;\n        }\n    }\n    \n    private Color GetPingColor(float ping)\n    {\n        if (ping <= _goodPingThreshold)\n        {\n            return _goodPingColor;\n        }\n        else if (ping <= _badPingThreshold)\n        {\n            float t = (ping - _goodPingThreshold) / (_badPingThreshold - _goodPingThreshold);\n            return Color.Lerp(_goodPingColor, _averagePingColor, t);\n        }\n        else\n        {\n            float t = Mathf.Clamp01((ping - _badPingThreshold) / 100f);\n            return Color.Lerp(_averagePingColor, _badPingColor, t);\n        }\n    }\n    \n    private void UpdatePulseAnimation()\n    {\n        if (_originalScale == Vector3.zero) return;\n        \n        float pulseValue = 1f + Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n        _pingIcon.transform.localScale = _originalScale * pulseValue;\n    }\n    \n    public void SetPingValue(float ping)\n    {\n        _currentPing = Mathf.Max(1f, ping);\n        _pingSamples[_currentSampleIndex] = _currentPing;\n        _currentSampleIndex = (_currentSampleIndex + 1) % _sampleCount;\n        \n        CalculateAveragePing();\n        UpdateDisplay();\n        UpdateVisualFeedback();\n    }\n    \n    public float GetCurrentPing()\n    {\n        return _currentPing;\n    }\n    \n    public float GetAveragePing()\n    {\n        return _averagePing;\n    }\n    \n    public void ResetPingHistory()\n    {\n        for (int i = 0; i < _pingSamples.Length; i++)\n        {\n            _pingSamples[i] = 0f;\n        }\n        _currentSampleIndex = 0;\n        _averagePing = 0f;\n    }\n    \n    public void SetUpdateInterval(float interval)\n    {\n        _updateInterval = Mathf.Max(0.1f, interval);\n        StartPingUpdates();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_updateCoroutine != null)\n        {\n            StopCoroutine(_updateCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BouncingStar\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"bounceForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"bounceInterval\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"collectPoints\",\n      \"type\": \"int\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_bounce\",\n      \"trigger\": \"every bounce interval seconds\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward bounce force\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_star\",\n      \"trigger\": \"when player touches this star\",\n      \"actions\": [\n        {\n          \"action\": \"add collect points to player score\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"destroy this star object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sparkle_effect\",\n      \"trigger\": \"continuously while star exists\",\n      \"actions\": [\n        {\n          \"action\": \"rotate slowly around vertical axis\"\n        },\n        {\n          \"action\": \"emit sparkle particles\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class StarCollectible : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _bounceHeight = 2f;\n    [SerializeField] private float _bounceSpeed = 2f;\n    [SerializeField] private AnimationCurve _bounceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.up;\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _destroyDelay = 0f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectAnimationDuration = 0.5f;\n    [SerializeField] private AnimationCurve _collectScaleCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStarCollected;\n    \n    private Vector3 _startPosition;\n    private float _bounceTimer;\n    private bool _isCollected;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _bounceTimer = 0f;\n        _isCollected = false;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        UpdateBounce();\n        UpdateRotation();\n    }\n    \n    private void UpdateBounce()\n    {\n        _bounceTimer += Time.deltaTime * _bounceSpeed;\n        float normalizedTime = (_bounceTimer % (2f * Mathf.PI)) / (2f * Mathf.PI);\n        float bounceOffset = _bounceCurve.Evaluate(normalizedTime) * _bounceHeight;\n        \n        Vector3 newPosition = _startPosition;\n        newPosition.y += Mathf.Sin(_bounceTimer) * bounceOffset;\n        transform.position = newPosition;\n    }\n    \n    private void UpdateRotation()\n    {\n        transform.Rotate(_rotationAxis * _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(_playerTag))\n        {\n            CollectStar();\n        }\n    }\n    \n    private void CollectStar()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        OnStarCollected?.Invoke();\n        \n        if (_destroyOnCollect)\n        {\n            StartCoroutine(CollectAnimation());\n        }\n        else\n        {\n            DisableStar();\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_audioSource != null && _collectSound != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            \n            ParticleSystem particles = effect.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                Destroy(effect, particles.main.duration + particles.main.startLifetime.constantMax);\n            }\n            else\n            {\n                Destroy(effect, 2f);\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator CollectAnimation()\n    {\n        Vector3 originalScale = transform.localScale;\n        float timer = 0f;\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        while (timer < _collectAnimationDuration)\n        {\n            timer += Time.deltaTime;\n            float normalizedTime = timer / _collectAnimationDuration;\n            float scaleMultiplier = _collectScaleCurve.Evaluate(normalizedTime);\n            \n            transform.localScale = originalScale * scaleMultiplier;\n            \n            yield return null;\n        }\n        \n        if (_destroyDelay > 0f)\n        {\n            yield return new WaitForSeconds(_destroyDelay);\n        }\n        \n        Destroy(gameObject);\n    }\n    \n    private void DisableStar()\n    {\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    public void ResetStar()\n    {\n        _isCollected = false;\n        _bounceTimer = 0f;\n        transform.position = _startPosition;\n        transform.localScale = Vector3.one;\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = true;\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_bounceHeight < 0f)\n            _bounceHeight = 0f;\n            \n        if (_bounceSpeed < 0f)\n            _bounceSpeed = 0f;\n            \n        if (_collectAnimationDuration < 0f)\n            _collectAnimationDuration = 0f;\n            \n        if (_destroyDelay < 0f)\n            _destroyDelay = 0f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AmbientSoundZone\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeOutDuration\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"maxVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"isPlayerInside\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_fade_in\",\n      \"trigger\": \"when player enters the sound zone\",\n      \"actions\": [\n        {\n          \"action\": \"set player inside flag to true\"\n        },\n        {\n          \"action\": \"gradually increase audio volume from zero to maximum volume over fade in duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_fade_out\",\n      \"trigger\": \"when player exits the sound zone\",\n      \"actions\": [\n        {\n          \"action\": \"set player inside flag to false\"\n        },\n        {\n          \"action\": \"gradually decrease audio volume from current level to zero over fade out duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_audio\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"set audio source to loop continuously\"\n        },\n        {\n          \"action\": \"set initial volume to zero\"\n        },\n        {\n          \"action\": \"begin playing the ambient sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\n[RequireComponent(typeof(AudioSource))]\npublic class AmbientSoundZone : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip[] _ambientClips;\n    [SerializeField] private bool _playOnAwake = true;\n    [SerializeField] private bool _loop = true;\n    [SerializeField] private bool _randomizeClips = false;\n    \n    [Header(\"Volume Control\")]\n    [SerializeField] private float _baseVolume = 0.5f;\n    [SerializeField] private float _fadeInDuration = 2f;\n    [SerializeField] private float _fadeOutDuration = 2f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _useDistanceAttenuation = true;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _minDistance = 1f;\n    [SerializeField] private bool _triggerBasedZone = false;\n    \n    [Header(\"Playback Options\")]\n    [SerializeField] private float _clipChangeInterval = 30f;\n    [SerializeField] private bool _crossfade = false;\n    [SerializeField] private float _crossfadeDuration = 3f;\n    \n    private AudioSource _primaryAudioSource;\n    private AudioSource _secondaryAudioSource;\n    private bool _isPlayerInZone = false;\n    private bool _isPlaying = false;\n    private float _currentVolume = 0f;\n    private float _targetVolume = 0f;\n    private Coroutine _fadeCoroutine;\n    private Coroutine _clipChangeCoroutine;\n    private int _currentClipIndex = 0;\n    private Transform _playerTransform;\n    \n    private void Awake()\n    {\n        _primaryAudioSource = GetComponent<AudioSource>();\n        _primaryAudioSource.playOnAwake = false;\n        _primaryAudioSource.loop = _loop && !_randomizeClips;\n        _primaryAudioSource.volume = 0f;\n        \n        if (_crossfade)\n        {\n            _secondaryAudioSource = gameObject.AddComponent<AudioSource>();\n            _secondaryAudioSource.playOnAwake = false;\n            _secondaryAudioSource.loop = _loop && !_randomizeClips;\n            _secondaryAudioSource.volume = 0f;\n        }\n        \n        SetupAudioSource(_primaryAudioSource);\n        if (_secondaryAudioSource != null)\n        {\n            SetupAudioSource(_secondaryAudioSource);\n        }\n    }\n    \n    private void Start()\n    {\n        if (_playOnAwake && !_triggerBasedZone)\n        {\n            StartAmbientSound();\n        }\n        \n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _playerTransform = playerObject.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_triggerBasedZone && _useDistanceAttenuation && _playerTransform != null)\n        {\n            UpdateDistanceBasedVolume();\n        }\n        \n        UpdateVolumeSmoothing();\n    }\n    \n    private void SetupAudioSource(AudioSource audioSource)\n    {\n        if (_useDistanceAttenuation)\n        {\n            audioSource.spatialBlend = 1f;\n            audioSource.rolloffMode = AudioRolloffMode.Linear;\n            audioSource.minDistance = _minDistance;\n            audioSource.maxDistance = _maxDistance;\n        }\n        else\n        {\n            audioSource.spatialBlend = 0f;\n        }\n    }\n    \n    private void UpdateDistanceBasedVolume()\n    {\n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        float normalizedDistance = Mathf.Clamp01((distance - _minDistance) / (_maxDistance - _minDistance));\n        float distanceVolume = _volumeCurve.Evaluate(1f - normalizedDistance);\n        \n        _targetVolume = _isPlaying ? _baseVolume * distanceVolume : 0f;\n    }\n    \n    private void UpdateVolumeSmoothing()\n    {\n        if (!Mathf.Approximately(_currentVolume, _targetVolume))\n        {\n            float fadeSpeed = _targetVolume > _currentVolume ? 1f / _fadeInDuration : 1f / _fadeOutDuration;\n            _currentVolume = Mathf.MoveTowards(_currentVolume, _targetVolume, fadeSpeed * Time.deltaTime);\n            \n            _primaryAudioSource.volume = _currentVolume;\n            if (_secondaryAudioSource != null)\n            {\n                _secondaryAudioSource.volume = _currentVolume;\n            }\n        }\n    }\n    \n    public void StartAmbientSound()\n    {\n        if (_ambientClips == null || _ambientClips.Length == 0) return;\n        \n        _isPlaying = true;\n        \n        if (_triggerBasedZone)\n        {\n            _targetVolume = _baseVolume;\n        }\n        else if (_useDistanceAttenuation && _playerTransform != null)\n        {\n            UpdateDistanceBasedVolume();\n        }\n        else\n        {\n            _targetVolume = _baseVolume;\n        }\n        \n        PlayCurrentClip();\n        \n        if (_randomizeClips && _clipChangeInterval > 0f)\n        {\n            _clipChangeCoroutine = StartCoroutine(ClipChangeRoutine());\n        }\n    }\n    \n    public void StopAmbientSound()\n    {\n        _isPlaying = false;\n        _targetVolume = 0f;\n        \n        if (_clipChangeCoroutine != null)\n        {\n            StopCoroutine(_clipChangeCoroutine);\n            _clipChangeCoroutine = null;\n        }\n    }\n    \n    private void PlayCurrentClip()\n    {\n        if (_ambientClips == null || _ambientClips.Length == 0) return;\n        \n        AudioClip clipToPlay = _ambientClips[_currentClipIndex];\n        if (clipToPlay == null) return;\n        \n        if (_crossfade && _secondaryAudioSource != null && _primaryAudioSource.isPlaying)\n        {\n            StartCoroutine(CrossfadeToClip(clipToPlay));\n        }\n        else\n        {\n            _primaryAudioSource.clip = clipToPlay;\n            _primaryAudioSource.Play();\n        }\n    }\n    \n    private System.Collections.IEnumerator CrossfadeToClip(AudioClip newClip)\n    {\n        _secondaryAudioSource.clip = newClip;\n        _secondaryAudioSource.volume = 0f;\n        _secondaryAudioSource.Play();\n        \n        float timer = 0f;\n        float primaryStartVolume = _primaryAudioSource.volume;\n        \n        while (timer < _crossfadeDuration)\n        {\n            timer += Time.deltaTime;\n            float progress = timer / _crossfadeDuration;\n            \n            _primaryAudioSource.volume = Mathf.Lerp(primaryStartVolume, 0f, progress);\n            _secondaryAudioSource.volume = Mathf.Lerp(0f, _currentVolume, progress);\n            \n            yield return null;\n        }\n        \n        _primaryAudioSource.Stop();\n        \n        AudioSource temp = _primaryAudioSource;\n        _primaryAudioSource = _secondaryAudioSource;\n        _secondaryAudioSource = temp;\n    }\n    \n    private System.Collections.IEnumerator ClipChangeRoutine()\n    {\n        while (_isPlaying)\n        {\n            yield return new WaitForSeconds(_clipChangeInterval);\n            \n            if (_isPlaying && _randomizeClips)\n            {\n                int previousIndex = _currentClipIndex;\n                _currentClipIndex = Random.Range(0, _ambientClips.Length);\n                \n                if (_ambientClips.Length > 1 && _currentClipIndex == previousIndex)\n                {\n                    _currentClipIndex = (_currentClipIndex + 1) % _ambientClips.Length;\n                }\n                \n                PlayCurrentClip();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerBasedZone) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInZone = true;\n            StartAmbientSound();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_triggerBasedZone) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInZone = false;\n            StopAmbientSound();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _baseVolume = Mathf.Clamp01(_baseVolume);\n        _fadeInDuration = Mathf.Max(0.1f, _fadeInDuration);\n        _fadeOutDuration = Mathf.Max(0.1f, _fadeOutDuration);\n        _maxDistance = Mathf.Max(_minDistance + 0.1f, _maxDistance);\n        _clipChangeInterval = Mathf.Max(1f, _clipChangeInterval);\n        _crossfadeDuration = Mathf.Max(0.1f, _crossfadeDuration);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_useDistanceAttenuation)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, _minDistance);\n            \n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _maxDistance);\n        }\n        \n        if (_triggerBasedZone)\n        {\n            Collider col = GetComponent<Collider>();\n            if (col != null && col.isTrigger)\n            {\n                Gizmos.color = Color.cyan;\n                Gizmos.DrawWireCube(transform.position, col.bounds.size);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SplittingSlime\",\n  \"components\": [\n    \"Rigidbody2D\",\n    \"Collider2D\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"splitCount\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"childScale\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    },\n    {\n      \"name\": \"splitForce\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"minSplitSize\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by player attack or projectile\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"flash red briefly to indicate damage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"split_on_death\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"check if current scale is larger than minimum split size\"\n        },\n        {\n          \"action\": \"create specified number of smaller slime copies at current position\"\n        },\n        {\n          \"action\": \"set each new slime scale to current scale multiplied by child scale factor\"\n        },\n        {\n          \"action\": \"apply random outward force to each new slime\"\n        },\n        {\n          \"action\": \"destroy current slime object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_tiny_splits\",\n      \"trigger\": \"when scale would be smaller than minimum split size\",\n      \"actions\": [\n        {\n          \"action\": \"simply destroy slime without creating new copies\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SplittingSlime : MonoBehaviour\n{\n    [Header(\"Slime Properties\")]\n    [SerializeField] private int _health = 3;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _jumpForce = 5f;\n    [SerializeField] private float _jumpInterval = 2f;\n    \n    [Header(\"Splitting Behavior\")]\n    [SerializeField] private int _maxSplitGenerations = 3;\n    [SerializeField] private int _currentGeneration = 0;\n    [SerializeField] private int _splitCount = 2;\n    [SerializeField] private float _splitForce = 3f;\n    [SerializeField] private float _childSizeMultiplier = 0.7f;\n    [SerializeField] private float _childHealthMultiplier = 0.5f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Components\")]\n    [SerializeField] private GameObject _slimePrefab;\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioClip _splitSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSlimeDeath;\n    public UnityEvent OnSlimeSplit;\n    \n    private Rigidbody2D _rigidbody;\n    private SpriteRenderer _spriteRenderer;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private float _nextJumpTime;\n    private bool _isDead = false;\n    private Vector2 _moveDirection;\n    private float _directionChangeTime;\n    private float _nextDirectionChange;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody2D>();\n            _rigidbody.freezeRotation = true;\n        }\n        \n        if (_spriteRenderer == null)\n        {\n            _spriteRenderer = gameObject.AddComponent<SpriteRenderer>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Start()\n    {\n        _nextJumpTime = Time.time + _jumpInterval;\n        _nextDirectionChange = Time.time + Random.Range(1f, 3f);\n        _moveDirection = Random.insideUnitCircle.normalized;\n        \n        AdjustSizeForGeneration();\n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        FindPlayer();\n        HandleMovement();\n        HandleJumping();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObj != null)\n        {\n            _player = playerObj.transform;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (Time.time >= _nextDirectionChange)\n        {\n            if (_player != null && Vector2.Distance(transform.position, _player.position) <= _detectionRange)\n            {\n                _moveDirection = (_player.position - transform.position).normalized;\n            }\n            else\n            {\n                _moveDirection = Random.insideUnitCircle.normalized;\n            }\n            \n            _nextDirectionChange = Time.time + Random.Range(1f, 3f);\n        }\n        \n        _rigidbody.velocity = new Vector2(_moveDirection.x * _moveSpeed, _rigidbody.velocity.y);\n        \n        if (_moveDirection.x > 0)\n            _spriteRenderer.flipX = false;\n        else if (_moveDirection.x < 0)\n            _spriteRenderer.flipX = true;\n    }\n    \n    private void HandleJumping()\n    {\n        if (Time.time >= _nextJumpTime && IsGrounded())\n        {\n            _rigidbody.AddForce(Vector2.up * _jumpForce, ForceMode2D.Impulse);\n            _nextJumpTime = Time.time + _jumpInterval + Random.Range(-0.5f, 0.5f);\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        RaycastHit2D hit = Physics2D.Raycast(transform.position, Vector2.down, 0.6f);\n        return hit.collider != null && !hit.collider.isTrigger;\n    }\n    \n    private void AdjustSizeForGeneration()\n    {\n        float sizeMultiplier = Mathf.Pow(_childSizeMultiplier, _currentGeneration);\n        transform.localScale = Vector3.one * sizeMultiplier;\n        \n        _health = Mathf.Max(1, Mathf.RoundToInt(_health * Mathf.Pow(_childHealthMultiplier, _currentGeneration)));\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDead) return;\n        \n        _health -= damage;\n        \n        if (_spriteRenderer != null)\n        {\n            StartCoroutine(FlashRed());\n        }\n        \n        if (_health <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashRed()\n    {\n        Color originalColor = _spriteRenderer.color;\n        _spriteRenderer.color = Color.red;\n        yield return new WaitForSeconds(0.1f);\n        _spriteRenderer.color = originalColor;\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        \n        if (_currentGeneration < _maxSplitGenerations)\n        {\n            Split();\n        }\n        else\n        {\n            CompleteDeath();\n        }\n    }\n    \n    private void Split()\n    {\n        OnSlimeSplit?.Invoke();\n        \n        if (_splitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_splitSound);\n        }\n        \n        if (_slimePrefab != null)\n        {\n            for (int i = 0; i < _splitCount; i++)\n            {\n                Vector3 spawnPosition = transform.position + (Vector3)(Random.insideUnitCircle * 0.5f);\n                GameObject newSlime = Instantiate(_slimePrefab, spawnPosition, Quaternion.identity);\n                \n                SplittingSlime slimeScript = newSlime.GetComponent<SplittingSlime>();\n                if (slimeScript != null)\n                {\n                    slimeScript._currentGeneration = _currentGeneration + 1;\n                    slimeScript.AdjustSizeForGeneration();\n                    \n                    Rigidbody2D newRb = newSlime.GetComponent<Rigidbody2D>();\n                    if (newRb != null)\n                    {\n                        Vector2 splitDirection = Random.insideUnitCircle.normalized;\n                        newRb.AddForce(splitDirection * _splitForce, ForceMode2D.Impulse);\n                    }\n                }\n            }\n        }\n        \n        CompleteDeath();\n    }\n    \n    private void CompleteDeath()\n    {\n        OnSlimeDeath?.Invoke();\n        \n        if (_deathSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_deathEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_deathEffect, transform.position, Quaternion.identity);\n            Destroy(effect.gameObject, 2f);\n        }\n        \n        if (_audioSource != null && (_deathSound != null || _splitSound != null))\n        {\n            Destroy(gameObject, 1f);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            TakeDamage(_health);\n        }\n    }\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            TakeDamage(_health);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, Vector2.down * 0.6f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GravityFlipZone\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"flipDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"0, 1, 0\"\n    },\n    {\n      \"name\": \"flipForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"affectDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"flip_gravity_on_enter\",\n      \"trigger\": \"when object with rigidbody enters trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"reverse the gravity direction for the entering object\"\n        },\n        {\n          \"action\": \"apply upward force in the flip direction\"\n        },\n        {\n          \"action\": \"play gravity flip sound effect\"\n        },\n        {\n          \"action\": \"create visual particle effect at flip location\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_flipped_gravity\",\n      \"trigger\": \"while object remains in flip zone\",\n      \"actions\": [\n        {\n          \"action\": \"continuously apply gravity in flipped direction\"\n        },\n        {\n          \"action\": \"prevent normal gravity from affecting the object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"restore_gravity_on_exit\",\n      \"trigger\": \"when object leaves the trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal gravity direction for the object\"\n        },\n        {\n          \"action\": \"gradually transition back to standard physics\"\n        },\n        {\n          \"action\": \"fade out any lingering flip effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GravityFlipZone : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private Vector3 _newGravityDirection = Vector3.up;\n    [SerializeField] private float _gravityStrength = 9.81f;\n    [SerializeField] private bool _useGlobalGravity = false;\n    \n    [Header(\"Zone Behavior\")]\n    [SerializeField] private bool _flipOnEnter = true;\n    [SerializeField] private bool _revertOnExit = true;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectCharacterControllers = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private ParticleSystem _enterEffect;\n    [SerializeField] private ParticleSystem _exitEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectEnterZone;\n    public UnityEvent<GameObject> OnObjectExitZone;\n    \n    private Vector3 _originalGravity;\n    private System.Collections.Generic.Dictionary<GameObject, GravityData> _affectedObjects;\n    \n    private class GravityData\n    {\n        public Vector3 originalGravity;\n        public Rigidbody rigidbody;\n        public CharacterController characterController;\n        public bool wasUsingGravity;\n        \n        public GravityData(Rigidbody rb, CharacterController cc)\n        {\n            rigidbody = rb;\n            characterController = cc;\n            originalGravity = Physics.gravity;\n            wasUsingGravity = rb != null ? rb.useGravity : false;\n        }\n    }\n    \n    private void Start()\n    {\n        _originalGravity = Physics.gravity;\n        _affectedObjects = new System.Collections.Generic.Dictionary<GameObject, GravityData>();\n        \n        if (GetComponent<Collider>() == null)\n        {\n            Debug.LogWarning(\"GravityFlipZone requires a Collider component set as trigger!\");\n        }\n        else\n        {\n            GetComponent<Collider>().isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_flipOnEnter) return;\n        \n        GameObject obj = other.gameObject;\n        \n        if (_affectedObjects.ContainsKey(obj)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        CharacterController cc = other.GetComponent<CharacterController>();\n        \n        if ((!_affectRigidbodies || rb == null) && (!_affectCharacterControllers || cc == null))\n            return;\n        \n        GravityData gravityData = new GravityData(rb, cc);\n        _affectedObjects[obj] = gravityData;\n        \n        ApplyGravityFlip(obj, gravityData);\n        \n        PlayEffect(_enterEffect);\n        PlaySound(_enterSound);\n        \n        OnObjectEnterZone?.Invoke(obj);\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_revertOnExit) return;\n        \n        GameObject obj = other.gameObject;\n        \n        if (!_affectedObjects.ContainsKey(obj)) return;\n        \n        GravityData gravityData = _affectedObjects[obj];\n        RevertGravity(obj, gravityData);\n        \n        _affectedObjects.Remove(obj);\n        \n        PlayEffect(_exitEffect);\n        PlaySound(_exitSound);\n        \n        OnObjectExitZone?.Invoke(obj);\n    }\n    \n    private void ApplyGravityFlip(GameObject obj, GravityData gravityData)\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = _newGravityDirection.normalized * _gravityStrength;\n        }\n        else\n        {\n            if (gravityData.rigidbody != null && _affectRigidbodies)\n            {\n                gravityData.rigidbody.useGravity = false;\n                ApplyCustomGravityToRigidbody(gravityData.rigidbody);\n            }\n        }\n        \n        if (gravityData.characterController != null && _affectCharacterControllers)\n        {\n            CustomCharacterGravity customGravity = obj.GetComponent<CustomCharacterGravity>();\n            if (customGravity == null)\n            {\n                customGravity = obj.AddComponent<CustomCharacterGravity>();\n            }\n            customGravity.SetGravity(_newGravityDirection.normalized * _gravityStrength);\n        }\n    }\n    \n    private void RevertGravity(GameObject obj, GravityData gravityData)\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = gravityData.originalGravity;\n        }\n        else\n        {\n            if (gravityData.rigidbody != null && _affectRigidbodies)\n            {\n                gravityData.rigidbody.useGravity = gravityData.wasUsingGravity;\n            }\n        }\n        \n        if (gravityData.characterController != null && _affectCharacterControllers)\n        {\n            CustomCharacterGravity customGravity = obj.GetComponent<CustomCharacterGravity>();\n            if (customGravity != null)\n            {\n                customGravity.RevertToOriginalGravity();\n            }\n        }\n    }\n    \n    private void ApplyCustomGravityToRigidbody(Rigidbody rb)\n    {\n        if (rb != null)\n        {\n            rb.AddForce(_newGravityDirection.normalized * _gravityStrength * rb.mass, ForceMode.Acceleration);\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_useGlobalGravity)\n        {\n            foreach (var kvp in _affectedObjects)\n            {\n                GravityData gravityData = kvp.Value;\n                if (gravityData.rigidbody != null && _affectRigidbodies)\n                {\n                    ApplyCustomGravityToRigidbody(gravityData.rigidbody);\n                }\n            }\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        Gizmos.color = Color.red;\n        Vector3 arrowStart = transform.position;\n        Vector3 arrowEnd = arrowStart + _newGravityDirection.normalized * 2f;\n        Gizmos.DrawLine(arrowStart, arrowEnd);\n        Gizmos.DrawSphere(arrowEnd, 0.1f);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_useGlobalGravity)\n        {\n            Physics.gravity = _originalGravity;\n        }\n        \n        foreach (var kvp in _affectedObjects)\n        {\n            RevertGravity(kvp.Key, kvp.Value);\n        }\n    }\n}\n\npublic class CustomCharacterGravity : MonoBehaviour\n{\n    private CharacterController _characterController;\n    private Vector3 _customGravity;\n    private Vector3 _originalGravity;\n    private Vector3 _velocity;\n    private bool _isUsingCustomGravity;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _originalGravity = Vector3.down * 9.81f;\n        _customGravity = _originalGravity;\n    }\n    \n    public void SetGravity(Vector3 gravity)\n    {\n        _customGravity = gravity;\n        _isUsingCustomGravity = true;\n        _velocity = Vector3.zero;\n    }\n    \n    public void RevertToOriginalGravity()\n    {\n        _customGravity = _originalGravity;\n        _isUsingCustomGravity = false;\n        _velocity = Vector3.zero;\n    }\n    \n    private void Update()\n    {\n        if (_characterController != null && _isUsingCustomGravity)\n        {\n            if (_characterController.isGrounded)\n            {\n                _velocity.y = 0f;\n            }\n            \n            _velocity += _customGravity * Time.deltaTime;\n            _characterController.Move(_velocity * Time.deltaTime);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FlameJetTrap\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"activationDelay\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"flameDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isOnCooldown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range and trap is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"start activation delay timer\"\n        },\n        {\n          \"action\": \"play warning sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_flames\",\n      \"trigger\": \"when activation delay timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"enable flame particle system\"\n        },\n        {\n          \"action\": \"set trap to active state\"\n        },\n        {\n          \"action\": \"play flame ignition sound\"\n        },\n        {\n          \"action\": \"start flame duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_player\",\n      \"trigger\": \"when player touches flame area while trap is active\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player\"\n        },\n        {\n          \"action\": \"apply burning effect to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_flames\",\n      \"trigger\": \"when flame duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"disable flame particle system\"\n        },\n        {\n          \"action\": \"set trap to inactive state\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"set trap to cooldown state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_trap\",\n      \"trigger\": \"when cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"set trap to ready state\"\n        },\n        {\n          \"action\": \"remove cooldown state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FlameJetTrap : MonoBehaviour\n{\n    [Header(\"Flame Settings\")]\n    [SerializeField] private float _flameDuration = 2f;\n    [SerializeField] private float _cooldownDuration = 3f;\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private bool _autoActivate = true;\n    [SerializeField] private float _activationDelay = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private Light _flameLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _igniteSound;\n    [SerializeField] private AudioClip _flameLoopSound;\n    [SerializeField] private AudioClip _extinguishSound;\n    \n    [Header(\"Warning System\")]\n    [SerializeField] private GameObject _warningIndicator;\n    [SerializeField] private float _warningDuration = 1f;\n    [SerializeField] private AudioClip _warningSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFlameActivated;\n    public UnityEvent OnFlameDeactivated;\n    public UnityEvent OnTargetDamaged;\n    \n    private enum TrapState\n    {\n        Idle,\n        Warning,\n        Active,\n        Cooldown\n    }\n    \n    private TrapState _currentState = TrapState.Idle;\n    private float _stateTimer;\n    private float _damageTimer;\n    private bool _playerInRange;\n    private Collider _trapCollider;\n    \n    private void Start()\n    {\n        _trapCollider = GetComponent<Collider>();\n        if (_trapCollider == null)\n        {\n            _trapCollider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_trapCollider).radius = _detectionRadius;\n            _trapCollider.isTrigger = true;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        InitializeComponents();\n        SetState(TrapState.Idle);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_flameParticles != null)\n        {\n            var main = _flameParticles.main;\n            main.loop = true;\n            _flameParticles.Stop();\n        }\n        \n        if (_flameLight != null)\n            _flameLight.enabled = false;\n        \n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        UpdateStateMachine();\n        \n        if (_currentState == TrapState.Active)\n        {\n            UpdateDamage();\n        }\n    }\n    \n    private void UpdateStateMachine()\n    {\n        _stateTimer -= Time.deltaTime;\n        \n        switch (_currentState)\n        {\n            case TrapState.Idle:\n                if (_autoActivate && _playerInRange)\n                {\n                    SetState(TrapState.Warning);\n                }\n                break;\n                \n            case TrapState.Warning:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Active);\n                }\n                break;\n                \n            case TrapState.Active:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Cooldown);\n                }\n                break;\n                \n            case TrapState.Cooldown:\n                if (_stateTimer <= 0f)\n                {\n                    SetState(TrapState.Idle);\n                }\n                break;\n        }\n    }\n    \n    private void SetState(TrapState newState)\n    {\n        _currentState = newState;\n        \n        switch (newState)\n        {\n            case TrapState.Idle:\n                _stateTimer = 0f;\n                DeactivateFlame();\n                DeactivateWarning();\n                break;\n                \n            case TrapState.Warning:\n                _stateTimer = _warningDuration;\n                ActivateWarning();\n                break;\n                \n            case TrapState.Active:\n                _stateTimer = _flameDuration;\n                _damageTimer = 0f;\n                ActivateFlame();\n                DeactivateWarning();\n                break;\n                \n            case TrapState.Cooldown:\n                _stateTimer = _cooldownDuration;\n                DeactivateFlame();\n                break;\n        }\n    }\n    \n    private void ActivateWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(true);\n        \n        if (_audioSource != null && _warningSound != null)\n            _audioSource.PlayOneShot(_warningSound);\n    }\n    \n    private void DeactivateWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void ActivateFlame()\n    {\n        if (_flameParticles != null)\n            _flameParticles.Play();\n        \n        if (_flameLight != null)\n            _flameLight.enabled = true;\n        \n        if (_audioSource != null)\n        {\n            if (_igniteSound != null)\n                _audioSource.PlayOneShot(_igniteSound);\n            \n            if (_flameLoopSound != null)\n            {\n                _audioSource.clip = _flameLoopSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        \n        OnFlameActivated?.Invoke();\n    }\n    \n    private void DeactivateFlame()\n    {\n        if (_flameParticles != null)\n            _flameParticles.Stop();\n        \n        if (_flameLight != null)\n            _flameLight.enabled = false;\n        \n        if (_audioSource != null)\n        {\n            if (_audioSource.isPlaying && _audioSource.clip == _flameLoopSound)\n                _audioSource.Stop();\n            \n            if (_extinguishSound != null)\n                _audioSource.PlayOneShot(_extinguishSound);\n        }\n        \n        OnFlameDeactivated?.Invoke();\n    }\n    \n    private void UpdateDamage()\n    {\n        _damageTimer -= Time.deltaTime;\n        \n        if (_damageTimer <= 0f)\n        {\n            _damageTimer = _damageInterval;\n            DamageTargetsInRange();\n        }\n    }\n    \n    private void DamageTargetsInRange()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(\"Player\"))\n            {\n                // Apply damage to player\n                var playerHealth = target.GetComponent<MonoBehaviour>();\n                if (playerHealth != null)\n                {\n                    // Send damage message\n                    target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n                }\n                \n                OnTargetDamaged?.Invoke();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _targetLayerMask) != 0)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                _playerInRange = true;\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _targetLayerMask) != 0)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                _playerInRange = false;\n            }\n        }\n    }\n    \n    public void ManualActivate()\n    {\n        if (_currentState == TrapState.Idle)\n        {\n            SetState(TrapState.Warning);\n        }\n    }\n    \n    public void ForceActivate()\n    {\n        SetState(TrapState.Active);\n    }\n    \n    public void ForceDeactivate()\n    {\n        SetState(TrapState.Idle);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_currentState == TrapState.Active)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawSphere(transform.position, 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LockOnTargeting\",\n  \"components\": [\n    \"Transform\",\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"lockOnRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"lockOnAngle\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"currentTarget\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isLocked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"targetLayer\",\n      \"type\": \"LayerMask\",\n      \"default\": -1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_lock_on\",\n      \"trigger\": \"when lock on input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"find closest enemy within lock on range and angle\"\n        },\n        {\n          \"action\": \"set current target to closest valid enemy\"\n        },\n        {\n          \"action\": \"enable locked on state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_lock_on\",\n      \"trigger\": \"when locked on to target and target exists\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly rotate camera to face current target\"\n        },\n        {\n          \"action\": \"keep target centered in view\"\n        }\n      ]\n    },\n    {\n      \"name\": \"break_lock_on_input\",\n      \"trigger\": \"when lock on input is pressed while already locked on\",\n      \"actions\": [\n        {\n          \"action\": \"clear current target\"\n        },\n        {\n          \"action\": \"disable locked on state\"\n        },\n        {\n          \"action\": \"return camera control to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"break_lock_on_distance\",\n      \"trigger\": \"when current target moves beyond lock on range\",\n      \"actions\": [\n        {\n          \"action\": \"clear current target\"\n        },\n        {\n          \"action\": \"disable locked on state\"\n        },\n        {\n          \"action\": \"return camera control to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"break_lock_on_destroyed\",\n      \"trigger\": \"when current target is destroyed or becomes inactive\",\n      \"actions\": [\n        {\n          \"action\": \"clear current target\"\n        },\n        {\n          \"action\": \"disable locked on state\"\n        },\n        {\n          \"action\": \"return camera control to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"switch_targets\",\n      \"trigger\": \"when switch target input is pressed while locked on\",\n      \"actions\": [\n        {\n          \"action\": \"find next closest enemy within lock on range\"\n        },\n        {\n          \"action\": \"switch current target to next valid enemy\"\n        },\n        {\n          \"action\": \"maintain locked on state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class LockOnTargetingSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class TargetData\n    {\n        public Transform target;\n        public float distance;\n        public float angle;\n        public bool isVisible;\n        \n        public TargetData(Transform t, float d, float a, bool v)\n        {\n            target = t;\n            distance = d;\n            angle = a;\n            isVisible = v;\n        }\n    }\n\n    [Header(\"Targeting Settings\")]\n    [SerializeField] private float _maxLockOnDistance = 50f;\n    [SerializeField] private float _maxLockOnAngle = 60f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private string[] _targetTags = { \"Enemy\" };\n    \n    [Header(\"Camera Settings\")]\n    [SerializeField] private Transform _cameraTransform;\n    [SerializeField] private float _lockOnSmoothTime = 0.3f;\n    [SerializeField] private Vector3 _targetOffset = Vector3.up;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _lockOnKey = KeyCode.Tab;\n    [SerializeField] private KeyCode _switchTargetKey = KeyCode.R;\n    [SerializeField] private bool _useMouseForSwitching = true;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _lockOnIndicatorPrefab;\n    [SerializeField] private Canvas _uiCanvas;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnTargetLocked;\n    public UnityEvent OnTargetUnlocked;\n    public UnityEvent<Transform> OnTargetSwitched;\n\n    private Transform _currentTarget;\n    private List<TargetData> _availableTargets = new List<TargetData>();\n    private GameObject _lockOnIndicator;\n    private Vector3 _cameraVelocity;\n    private bool _isLockingOn = false;\n    private int _currentTargetIndex = 0;\n    private Camera _mainCamera;\n\n    public Transform CurrentTarget => _currentTarget;\n    public bool IsLockingOn => _isLockingOn;\n\n    private void Start()\n    {\n        if (_cameraTransform == null)\n            _cameraTransform = Camera.main?.transform;\n            \n        _mainCamera = _cameraTransform?.GetComponent<Camera>();\n        \n        if (_uiCanvas == null)\n            _uiCanvas = FindObjectOfType<Canvas>();\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        UpdateTargetList();\n        UpdateLockOn();\n        UpdateUI();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_lockOnKey))\n        {\n            if (_isLockingOn)\n                UnlockTarget();\n            else\n                LockOnToNearestTarget();\n        }\n\n        if (Input.GetKeyDown(_switchTargetKey) && _isLockingOn)\n        {\n            SwitchToNextTarget();\n        }\n\n        if (_useMouseForSwitching && _isLockingOn)\n        {\n            float mouseX = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(mouseX) > 0.5f)\n            {\n                if (mouseX > 0)\n                    SwitchToNextTarget();\n                else\n                    SwitchToPreviousTarget();\n            }\n        }\n    }\n\n    private void UpdateTargetList()\n    {\n        _availableTargets.Clear();\n\n        if (_cameraTransform == null) return;\n\n        Collider[] potentialTargets = Physics.OverlapSphere(transform.position, _maxLockOnDistance, _targetLayers);\n\n        foreach (Collider col in potentialTargets)\n        {\n            if (col.transform == transform) continue;\n\n            bool isValidTag = false;\n            foreach (string tag in _targetTags)\n            {\n                if (col.CompareTag(tag))\n                {\n                    isValidTag = true;\n                    break;\n                }\n            }\n\n            if (!isValidTag) continue;\n\n            Vector3 directionToTarget = (col.transform.position - _cameraTransform.position).normalized;\n            float angle = Vector3.Angle(_cameraTransform.forward, directionToTarget);\n\n            if (angle <= _maxLockOnAngle)\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                bool isVisible = IsTargetVisible(col.transform);\n\n                _availableTargets.Add(new TargetData(col.transform, distance, angle, isVisible));\n            }\n        }\n\n        _availableTargets = _availableTargets.OrderBy(t => t.distance).ToList();\n\n        if (_isLockingOn && _currentTarget != null)\n        {\n            bool currentTargetStillValid = _availableTargets.Any(t => t.target == _currentTarget);\n            if (!currentTargetStillValid)\n            {\n                UnlockTarget();\n            }\n        }\n    }\n\n    private bool IsTargetVisible(Transform target)\n    {\n        if (_cameraTransform == null || target == null) return false;\n\n        Vector3 directionToTarget = (target.position + _targetOffset - _cameraTransform.position);\n        float distanceToTarget = directionToTarget.magnitude;\n\n        if (Physics.Raycast(_cameraTransform.position, directionToTarget.normalized, out RaycastHit hit, distanceToTarget, _obstacleLayer))\n        {\n            return hit.transform == target;\n        }\n\n        return true;\n    }\n\n    public void LockOnToNearestTarget()\n    {\n        if (_availableTargets.Count == 0) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count == 0) return;\n\n        _currentTarget = visibleTargets[0].target;\n        _currentTargetIndex = 0;\n        _isLockingOn = true;\n\n        CreateLockOnIndicator();\n        OnTargetLocked?.Invoke(_currentTarget);\n    }\n\n    public void LockOnToTarget(Transform target)\n    {\n        if (target == null) return;\n\n        var targetData = _availableTargets.FirstOrDefault(t => t.target == target);\n        if (targetData == null) return;\n\n        _currentTarget = target;\n        _currentTargetIndex = _availableTargets.IndexOf(targetData);\n        _isLockingOn = true;\n\n        CreateLockOnIndicator();\n        OnTargetLocked?.Invoke(_currentTarget);\n    }\n\n    public void UnlockTarget()\n    {\n        _currentTarget = null;\n        _isLockingOn = false;\n        _currentTargetIndex = 0;\n\n        DestroyLockOnIndicator();\n        OnTargetUnlocked?.Invoke();\n    }\n\n    public void SwitchToNextTarget()\n    {\n        if (_availableTargets.Count <= 1) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count <= 1) return;\n\n        int currentVisibleIndex = visibleTargets.FindIndex(t => t.target == _currentTarget);\n        currentVisibleIndex = (currentVisibleIndex + 1) % visibleTargets.Count;\n\n        Transform previousTarget = _currentTarget;\n        _currentTarget = visibleTargets[currentVisibleIndex].target;\n        _currentTargetIndex = _availableTargets.FindIndex(t => t.target == _currentTarget);\n\n        OnTargetSwitched?.Invoke(_currentTarget);\n    }\n\n    public void SwitchToPreviousTarget()\n    {\n        if (_availableTargets.Count <= 1) return;\n\n        var visibleTargets = _availableTargets.Where(t => t.isVisible).ToList();\n        if (visibleTargets.Count <= 1) return;\n\n        int currentVisibleIndex = visibleTargets.FindIndex(t => t.target == _currentTarget);\n        currentVisibleIndex = (currentVisibleIndex - 1 + visibleTargets.Count) % visibleTargets.Count;\n\n        Transform previousTarget = _currentTarget;\n        _currentTarget = visibleTargets[currentVisibleIndex].target;\n        _currentTargetIndex = _availableTargets.FindIndex(t => t.target == _currentTarget);\n\n        OnTargetSwitched?.Invoke(_currentTarget);\n    }\n\n    private void UpdateLockOn()\n    {\n        if (!_isLockingOn || _currentTarget == null || _cameraTransform == null) return;\n\n        Vector3 targetPosition = _currentTarget.position + _targetOffset;\n        Vector3 desiredPosition = Vector3.SmoothDamp(_cameraTransform.position, targetPosition, ref _cameraVelocity, _lockOnSmoothTime);\n        \n        Vector3 direction = (targetPosition - _cameraTransform.position).normalized;\n        Quaternion targetRotation = Quaternion.LookRotation(direction);\n        _cameraTransform.rotation = Quaternion.Slerp(_cameraTransform.rotation, targetRotation, Time.deltaTime / _lockOnSmoothTime);\n    }\n\n    private void CreateLockOnIndicator()\n    {\n        if (_lockOnIndicatorPrefab == null || _uiCanvas == null) return;\n\n        DestroyLockOnIndicator();\n        _lockOnIndicator = Instantiate(_lockOnIndicatorPrefab, _uiCanvas.transform);\n    }\n\n    private void DestroyLockOnIndicator()\n    {\n        if (_lockOnIndicator != null)\n        {\n            Destroy(_lockOnIndicator);\n            _lockOnIndicator = null;\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_lockOnIndicator == null || _currentTarget == null || _mainCamera == null) return;\n\n        Vector3 screenPosition = _mainCamera.WorldToScreenPoint(_currentTarget.position + _targetOffset);\n        \n        if (screenPosition.z > 0)\n        {\n            _lockOnIndicator.transform.position = screenPosition;\n            _lockOnIndicator.SetActive(true);\n        }\n        else\n        {\n            _lockOnIndicator.SetActive(false);\n        }\n    }\n\n    public List<Transform> GetAvailableTargets()\n    {\n        return _availableTargets.Select(t => t.target).ToList();\n    }\n\n    public float GetDistanceToCurrentTarget()\n    {\n        if (_currentTarget == null) return 0f;\n        return Vector3.Distance(transform.position, _currentTarget.position);\n    }\n\n    public Vector3 GetDirectionToCurrentTarget()\n    {\n        if (_currentTarget == null) return Vector3.zero;\n        return (_currentTarget.position - transform.position).normalized;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxLockOnDistance);\n\n        if (_cameraTransform != null)\n        {\n            Gizmos.color = Color.red;\n            Vector3 leftBoundary = Quaternion.AngleAxis(-_maxLockOnAngle, _cameraTransform.up) * _cameraTransform.forward;\n            Vector3 rightBoundary = Quaternion.AngleAxis(_maxLockOnAngle, _cameraTransform.up) * _cameraTransform.forward;\n            \n            Gizmos.DrawRay(_cameraTransform.position, leftBoundary * _maxLockOnDistance);\n            Gizmos.DrawRay(_cameraTransform.position, rightBoundary * _maxLockOnDistance);\n        }\n\n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n            Gizmos.DrawWireSphere(_currentTarget.position, 1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SteamVent\",\n  \"components\": [\n    \"Collider\",\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"ventDuration\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"cooldownDuration\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_steam_vent\",\n      \"trigger\": \"when cooldown period ends\",\n      \"actions\": [\n        {\n          \"action\": \"set vent to active state\"\n        },\n        {\n          \"action\": \"start steam particle effects\"\n        },\n        {\n          \"action\": \"play steam hissing sound\"\n        },\n        {\n          \"action\": \"begin vent duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_steam_vent\",\n      \"trigger\": \"when vent duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"set vent to inactive state\"\n        },\n        {\n          \"action\": \"stop steam particle effects\"\n        },\n        {\n          \"action\": \"stop steam sound\"\n        },\n        {\n          \"action\": \"begin cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_player\",\n      \"trigger\": \"when player enters vent area while active\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to player health\"\n        },\n        {\n          \"action\": \"start continuous damage timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_damage\",\n      \"trigger\": \"when damage interval timer expires while player in vent area\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to player health\"\n        },\n        {\n          \"action\": \"reset damage interval timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_damage\",\n      \"trigger\": \"when player exits vent area\",\n      \"actions\": [\n        {\n          \"action\": \"stop continuous damage timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class SteamVent : MonoBehaviour\n{\n    [Header(\"Steam Settings\")]\n    [SerializeField] private float _steamDuration = 3f;\n    [SerializeField] private float _cooldownDuration = 5f;\n    [SerializeField] private bool _startActive = false;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _steamParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _steamSound;\n    \n    [Header(\"Warning System\")]\n    [SerializeField] private float _warningDuration = 1f;\n    [SerializeField] private GameObject _warningIndicator;\n    [SerializeField] private Light _warningLight;\n    [SerializeField] private Color _warningColor = Color.red;\n    \n    private bool _isActive = false;\n    private bool _isWarning = false;\n    private Collider _ventCollider;\n    private Color _originalLightColor;\n    private System.Collections.Generic.List<GameObject> _playersInRange = new System.Collections.Generic.List<GameObject>();\n    \n    private void Start()\n    {\n        _ventCollider = GetComponent<Collider>();\n        if (_ventCollider == null)\n        {\n            _ventCollider = gameObject.AddComponent<BoxCollider>();\n            _ventCollider.isTrigger = true;\n        }\n        \n        if (_warningLight != null)\n        {\n            _originalLightColor = _warningLight.color;\n            _warningLight.enabled = false;\n        }\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(false);\n        }\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Stop();\n        }\n        \n        if (_startActive)\n        {\n            StartCoroutine(SteamCycle());\n        }\n        else\n        {\n            StartCoroutine(SteamCycleWithDelay());\n        }\n    }\n    \n    private IEnumerator SteamCycleWithDelay()\n    {\n        yield return new WaitForSeconds(_cooldownDuration);\n        StartCoroutine(SteamCycle());\n    }\n    \n    private IEnumerator SteamCycle()\n    {\n        while (true)\n        {\n            yield return StartCoroutine(ShowWarning());\n            yield return StartCoroutine(ActivateSteam());\n            yield return new WaitForSeconds(_cooldownDuration);\n        }\n    }\n    \n    private IEnumerator ShowWarning()\n    {\n        _isWarning = true;\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(true);\n        }\n        \n        if (_warningLight != null)\n        {\n            _warningLight.enabled = true;\n            _warningLight.color = _warningColor;\n        }\n        \n        float elapsed = 0f;\n        while (elapsed < _warningDuration)\n        {\n            if (_warningLight != null)\n            {\n                _warningLight.intensity = Mathf.PingPong(Time.time * 3f, 1f) + 0.5f;\n            }\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _isWarning = false;\n        \n        if (_warningIndicator != null)\n        {\n            _warningIndicator.SetActive(false);\n        }\n        \n        if (_warningLight != null)\n        {\n            _warningLight.enabled = false;\n            _warningLight.color = _originalLightColor;\n            _warningLight.intensity = 1f;\n        }\n    }\n    \n    private IEnumerator ActivateSteam()\n    {\n        _isActive = true;\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Play();\n        }\n        \n        if (_audioSource != null && _steamSound != null)\n        {\n            _audioSource.clip = _steamSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        StartCoroutine(DamagePlayersInRange());\n        \n        yield return new WaitForSeconds(_steamDuration);\n        \n        _isActive = false;\n        \n        if (_steamParticles != null)\n        {\n            _steamParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private IEnumerator DamagePlayersInRange()\n    {\n        while (_isActive)\n        {\n            foreach (GameObject player in _playersInRange)\n            {\n                if (player != null)\n                {\n                    DamagePlayer(player);\n                }\n            }\n            yield return new WaitForSeconds(_damageInterval);\n        }\n    }\n    \n    private void DamagePlayer(GameObject player)\n    {\n        var playerScript = player.GetComponent<MonoBehaviour>();\n        if (playerScript != null)\n        {\n            player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        var rigidbody = player.GetComponent<Rigidbody>();\n        if (rigidbody != null)\n        {\n            Vector3 knockbackDirection = (player.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.5f;\n            rigidbody.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            if (!_playersInRange.Contains(other.gameObject))\n            {\n                _playersInRange.Add(other.gameObject);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playersInRange.Remove(other.gameObject);\n        }\n    }\n    \n    public void TriggerSteam()\n    {\n        if (!_isActive && !_isWarning)\n        {\n            StopAllCoroutines();\n            StartCoroutine(SteamCycle());\n        }\n    }\n    \n    public void SetActive(bool active)\n    {\n        if (active && !_isActive && !_isWarning)\n        {\n            StopAllCoroutines();\n            StartCoroutine(SteamCycle());\n        }\n        else if (!active)\n        {\n            StopAllCoroutines();\n            _isActive = false;\n            _isWarning = false;\n            \n            if (_steamParticles != null)\n            {\n                _steamParticles.Stop();\n            }\n            \n            if (_audioSource != null)\n            {\n                _audioSource.Stop();\n            }\n            \n            if (_warningIndicator != null)\n            {\n                _warningIndicator.SetActive(false);\n            }\n            \n            if (_warningLight != null)\n            {\n                _warningLight.enabled = false;\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isActive ? Color.red : (_isWarning ? Color.yellow : Color.blue);\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Mailbox\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxLetters\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"currentLetterCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"deliverySound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"openSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"open_mailbox\",\n      \"trigger\": \"when player interacts with mailbox\",\n      \"actions\": [\n        {\n          \"action\": \"open mailbox door\"\n        },\n        {\n          \"action\": \"play opening sound\"\n        },\n        {\n          \"action\": \"set mailbox state to open\"\n        }\n      ]\n    },\n    {\n      \"name\": \"close_mailbox\",\n      \"trigger\": \"when player interacts with open mailbox\",\n      \"actions\": [\n        {\n          \"action\": \"close mailbox door\"\n        },\n        {\n          \"action\": \"set mailbox state to closed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"receive_letter\",\n      \"trigger\": \"when mail carrier delivers letter\",\n      \"actions\": [\n        {\n          \"action\": \"increase letter count by one\"\n        },\n        {\n          \"action\": \"play delivery sound\"\n        },\n        {\n          \"action\": \"show visual indicator for new mail\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_letters\",\n      \"trigger\": \"when player takes letters from open mailbox\",\n      \"actions\": [\n        {\n          \"action\": \"transfer all letters to player inventory\"\n        },\n        {\n          \"action\": \"reset letter count to zero\"\n        },\n        {\n          \"action\": \"hide new mail indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_mail_indicator\",\n      \"trigger\": \"when mailbox has letters inside\",\n      \"actions\": [\n        {\n          \"action\": \"display flag or light to indicate mail present\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class Mailbox : MonoBehaviour\n{\n    [System.Serializable]\n    public class Letter\n    {\n        public string senderName;\n        public string subject;\n        [TextArea(3, 10)]\n        public string content;\n        public bool isRead;\n        public Sprite letterIcon;\n    }\n\n    [System.Serializable]\n    public class MailboxEvent : UnityEvent<Letter> { }\n\n    [Header(\"Mailbox Settings\")]\n    [SerializeField] private List<Letter> _letters = new List<Letter>();\n    [SerializeField] private Transform _letterSpawnPoint;\n    [SerializeField] private GameObject _letterPrefab;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _hasMailIndicator;\n    [SerializeField] private AudioClip _openMailboxSound;\n    [SerializeField] private AudioClip _newLetterSound;\n    [SerializeField] private ParticleSystem _mailDeliveryEffect;\n\n    [Header(\"Animation\")]\n    [SerializeField] private Animator _mailboxAnimator;\n    [SerializeField] private string _openAnimationTrigger = \"Open\";\n    [SerializeField] private string _closeAnimationTrigger = \"Close\";\n\n    [Header(\"Events\")]\n    public MailboxEvent OnLetterRead;\n    public UnityEvent OnMailboxOpened;\n    public UnityEvent OnMailboxClosed;\n    public UnityEvent OnNewLetterReceived;\n\n    private AudioSource _audioSource;\n    private bool _isOpen = false;\n    private bool _playerInRange = false;\n    private GameObject _currentPlayer;\n    private Canvas _mailboxUI;\n    private bool _hasUnreadMail = false;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        CreateMailboxUI();\n        UpdateMailIndicator();\n    }\n\n    private void Update()\n    {\n        CheckForPlayerInteraction();\n        HandleInput();\n    }\n\n    private void CheckForPlayerInteraction()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        bool playerFound = false;\n\n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                if (!_playerInRange)\n                {\n                    _playerInRange = true;\n                    _currentPlayer = col.gameObject;\n                    ShowInteractionPrompt(true);\n                }\n                playerFound = true;\n                break;\n            }\n        }\n\n        if (!playerFound && _playerInRange)\n        {\n            _playerInRange = false;\n            _currentPlayer = null;\n            ShowInteractionPrompt(false);\n            if (_isOpen)\n                CloseMailbox();\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            if (_isOpen)\n                CloseMailbox();\n            else\n                OpenMailbox();\n        }\n    }\n\n    private void OpenMailbox()\n    {\n        if (_isOpen) return;\n\n        _isOpen = true;\n        \n        if (_mailboxAnimator != null)\n            _mailboxAnimator.SetTrigger(_openAnimationTrigger);\n\n        PlaySound(_openMailboxSound);\n        ShowMailboxUI(true);\n        OnMailboxOpened?.Invoke();\n    }\n\n    private void CloseMailbox()\n    {\n        if (!_isOpen) return;\n\n        _isOpen = false;\n        \n        if (_mailboxAnimator != null)\n            _mailboxAnimator.SetTrigger(_closeAnimationTrigger);\n\n        ShowMailboxUI(false);\n        OnMailboxClosed?.Invoke();\n    }\n\n    public void AddLetter(Letter newLetter)\n    {\n        _letters.Add(newLetter);\n        PlaySound(_newLetterSound);\n        \n        if (_mailDeliveryEffect != null)\n            _mailDeliveryEffect.Play();\n\n        UpdateMailIndicator();\n        OnNewLetterReceived?.Invoke();\n\n        if (_letterPrefab != null && _letterSpawnPoint != null)\n        {\n            GameObject letterObj = Instantiate(_letterPrefab, _letterSpawnPoint.position, _letterSpawnPoint.rotation);\n            LetterItem letterItem = letterObj.GetComponent<LetterItem>();\n            if (letterItem == null)\n                letterItem = letterObj.AddComponent<LetterItem>();\n            letterItem.Initialize(newLetter);\n        }\n    }\n\n    public void ReadLetter(int letterIndex)\n    {\n        if (letterIndex >= 0 && letterIndex < _letters.Count)\n        {\n            _letters[letterIndex].isRead = true;\n            OnLetterRead?.Invoke(_letters[letterIndex]);\n            UpdateMailIndicator();\n        }\n    }\n\n    public void RemoveLetter(int letterIndex)\n    {\n        if (letterIndex >= 0 && letterIndex < _letters.Count)\n        {\n            _letters.RemoveAt(letterIndex);\n            UpdateMailIndicator();\n        }\n    }\n\n    private void UpdateMailIndicator()\n    {\n        _hasUnreadMail = false;\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n            {\n                _hasUnreadMail = true;\n                break;\n            }\n        }\n\n        if (_hasMailIndicator != null)\n            _hasMailIndicator.SetActive(_hasUnreadMail);\n    }\n\n    private void CreateMailboxUI()\n    {\n        GameObject uiObject = new GameObject(\"MailboxUI\");\n        _mailboxUI = uiObject.AddComponent<Canvas>();\n        _mailboxUI.renderMode = RenderMode.WorldSpace;\n        _mailboxUI.worldCamera = Camera.main;\n        \n        uiObject.transform.SetParent(transform);\n        uiObject.transform.localPosition = Vector3.up * 2f;\n        uiObject.transform.localScale = Vector3.one * 0.01f;\n        \n        _mailboxUI.gameObject.SetActive(false);\n    }\n\n    private void ShowMailboxUI(bool show)\n    {\n        if (_mailboxUI != null)\n            _mailboxUI.gameObject.SetActive(show);\n    }\n\n    private void ShowInteractionPrompt(bool show)\n    {\n        // This would typically show/hide UI prompt\n        // Implementation depends on your UI system\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    public int GetLetterCount()\n    {\n        return _letters.Count;\n    }\n\n    public int GetUnreadLetterCount()\n    {\n        int count = 0;\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n                count++;\n        }\n        return count;\n    }\n\n    public List<Letter> GetAllLetters()\n    {\n        return new List<Letter>(_letters);\n    }\n\n    public List<Letter> GetUnreadLetters()\n    {\n        List<Letter> unreadLetters = new List<Letter>();\n        foreach (Letter letter in _letters)\n        {\n            if (!letter.isRead)\n                unreadLetters.Add(letter);\n        }\n        return unreadLetters;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}\n\npublic class LetterItem : MonoBehaviour\n{\n    private Mailbox.Letter _letterData;\n    private bool _isCollected = false;\n\n    public void Initialize(Mailbox.Letter letter)\n    {\n        _letterData = letter;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isCollected)\n        {\n            CollectLetter();\n        }\n    }\n\n    private void CollectLetter()\n    {\n        _isCollected = true;\n        \n        // Add visual/audio feedback here\n        Destroy(gameObject, 0.1f);\n    }\n\n    public Mailbox.Letter GetLetterData()\n    {\n        return _letterData;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerTrackingTurret\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"shootCooldown\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"bulletPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"firePoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_player\",\n      \"trigger\": \"when player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"rotate turret to face player position smoothly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shoot_at_player\",\n      \"trigger\": \"when player is within detection range and turret is facing player and shoot cooldown has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"instantiate bullet at fire point\"\n        },\n        {\n          \"action\": \"launch bullet toward player position\"\n        },\n        {\n          \"action\": \"reset shoot cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_tracking\",\n      \"trigger\": \"when player moves outside detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop rotating turret\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PlayerTrackingTurret : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _fieldOfView = 90f;\n    [SerializeField] private LayerMask _obstacleLayerMask = 1;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private Transform _turretHead;\n    [SerializeField] private float _rotationSpeed = 2f;\n    [SerializeField] private bool _smoothRotation = true;\n    \n    [Header(\"Shooting\")]\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 20f;\n    [SerializeField] private float _projectileLifetime = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    \n    private Transform _player;\n    private float _nextFireTime;\n    private bool _playerInRange;\n    private bool _hasLineOfSight;\n    \n    private void Start()\n    {\n        if (_turretHead == null)\n            _turretHead = transform;\n            \n        if (_firePoint == null)\n            _firePoint = _turretHead;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        FindPlayer();\n        \n        if (_player != null)\n        {\n            CheckPlayerInRange();\n            CheckLineOfSight();\n            \n            if (_playerInRange && _hasLineOfSight)\n            {\n                RotateTowardsPlayer();\n                TryShoot();\n            }\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_player == null)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n                _player = playerObject.transform;\n        }\n    }\n    \n    private void CheckPlayerInRange()\n    {\n        if (_player == null)\n        {\n            _playerInRange = false;\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _playerInRange = distanceToPlayer <= _detectionRange;\n        \n        if (_playerInRange)\n        {\n            Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n            float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer);\n            _playerInRange = angleToPlayer <= _fieldOfView * 0.5f;\n        }\n    }\n    \n    private void CheckLineOfSight()\n    {\n        if (!_playerInRange || _player == null)\n        {\n            _hasLineOfSight = false;\n            return;\n        }\n        \n        Vector3 directionToPlayer = (_player.position - _firePoint.position).normalized;\n        float distanceToPlayer = Vector3.Distance(_firePoint.position, _player.position);\n        \n        RaycastHit hit;\n        if (Physics.Raycast(_firePoint.position, directionToPlayer, out hit, distanceToPlayer, _obstacleLayerMask))\n        {\n            _hasLineOfSight = hit.collider.CompareTag(\"Player\");\n        }\n        else\n        {\n            _hasLineOfSight = true;\n        }\n    }\n    \n    private void RotateTowardsPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 targetDirection = (_player.position - _turretHead.position).normalized;\n        targetDirection.y = 0f;\n        \n        Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n        \n        if (_smoothRotation)\n        {\n            _turretHead.rotation = Quaternion.Slerp(_turretHead.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n        else\n        {\n            _turretHead.rotation = targetRotation;\n        }\n    }\n    \n    private void TryShoot()\n    {\n        if (Time.time >= _nextFireTime && _projectilePrefab != null)\n        {\n            Shoot();\n            _nextFireTime = Time.time + (1f / _fireRate);\n        }\n    }\n    \n    private void Shoot()\n    {\n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb != null)\n        {\n            Vector3 shootDirection = _firePoint.forward;\n            if (_player != null)\n            {\n                shootDirection = (_player.position - _firePoint.position).normalized;\n            }\n            \n            projectileRb.velocity = shootDirection * _projectileSpeed;\n        }\n        \n        TurretProjectile projectileScript = projectile.GetComponent<TurretProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<TurretProjectile>();\n        }\n        projectileScript.Initialize(_projectileLifetime);\n        \n        if (_audioSource != null && _shootSound != null)\n        {\n            _audioSource.PlayOneShot(_shootSound);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Vector3 leftBoundary = Quaternion.Euler(0, -_fieldOfView * 0.5f, 0) * transform.forward * _detectionRange;\n        Vector3 rightBoundary = Quaternion.Euler(0, _fieldOfView * 0.5f, 0) * transform.forward * _detectionRange;\n        \n        Gizmos.DrawLine(transform.position, transform.position + leftBoundary);\n        Gizmos.DrawLine(transform.position, transform.position + rightBoundary);\n        \n        if (_hasLineOfSight && _player != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(_firePoint.position, _player.position);\n        }\n    }\n}\n\npublic class TurretProjectile : MonoBehaviour\n{\n    private float _lifetime;\n    private float _spawnTime;\n    \n    public void Initialize(float lifetime)\n    {\n        _lifetime = lifetime;\n        _spawnTime = Time.time;\n    }\n    \n    private void Update()\n    {\n        if (Time.time - _spawnTime >= _lifetime)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Destroy(gameObject);\n        }\n        else if (!other.isTrigger)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LaserRobot\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"laserDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"laserCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"laserRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"start tracking player position\"\n        },\n        {\n          \"action\": \"enter combat mode\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"when in combat mode and player is visible\",\n      \"actions\": [\n        {\n          \"action\": \"rotate to face player smoothly\"\n        },\n        {\n          \"action\": \"move toward player at move speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fire_laser\",\n      \"trigger\": \"when facing player and laser cooldown is ready\",\n      \"actions\": [\n        {\n          \"action\": \"create laser beam from robot to target position\"\n        },\n        {\n          \"action\": \"deal laser damage to player if hit\"\n        },\n        {\n          \"action\": \"play laser firing sound effect\"\n        },\n        {\n          \"action\": \"start laser cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"patrol_behavior\",\n      \"trigger\": \"when no player detected\",\n      \"actions\": [\n        {\n          \"action\": \"move forward slowly\"\n        },\n        {\n          \"action\": \"turn around when hitting obstacle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by player attack\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play damage sound effect\"\n        },\n        {\n          \"action\": \"flash red briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_robot\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play explosion effect\"\n        },\n        {\n          \"action\": \"destroy robot object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LaserRobot : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Laser Settings\")]\n    [SerializeField] private Transform _laserOrigin;\n    [SerializeField] private LineRenderer _laserRenderer;\n    [SerializeField] private float _laserDamage = 25f;\n    [SerializeField] private float _laserDuration = 0.5f;\n    [SerializeField] private float _laserCooldown = 2f;\n    [SerializeField] private float _laserChargeTime = 1f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _patrolRadius = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _laserChargeSound;\n    [SerializeField] private AudioClip _laserFireSound;\n    [SerializeField] private AudioClip _detectionSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _laserChargeEffect;\n    [SerializeField] private ParticleSystem _laserImpactEffect;\n    [SerializeField] private Light _laserLight;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTargetDetected;\n    public UnityEvent OnLaserFired;\n    public UnityEvent OnTargetLost;\n    \n    private enum RobotState\n    {\n        Patrolling,\n        Chasing,\n        Charging,\n        Firing,\n        Cooldown\n    }\n    \n    private RobotState _currentState = RobotState.Patrolling;\n    private Transform _currentTarget;\n    private Vector3 _patrolCenter;\n    private Vector3 _patrolDestination;\n    private float _lastLaserTime;\n    private float _chargeStartTime;\n    private bool _hasLineOfSight;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _patrolCenter = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_laserRenderer == null)\n            _laserRenderer = GetComponent<LineRenderer>();\n            \n        if (_laserOrigin == null)\n            _laserOrigin = transform;\n            \n        SetupLaserRenderer();\n        SetNewPatrolDestination();\n        \n        _lastLaserTime = -_laserCooldown;\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        UpdateStateMachine();\n        UpdateLaserVisuals();\n        UpdateAnimations();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayerMask);\n        Transform closestTarget = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, target.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = target.transform;\n                }\n            }\n        }\n        \n        if (closestTarget != null)\n        {\n            _hasLineOfSight = HasLineOfSight(closestTarget);\n            \n            if (_hasLineOfSight && _currentTarget == null)\n            {\n                _currentTarget = closestTarget;\n                OnTargetDetected?.Invoke();\n                PlaySound(_detectionSound);\n            }\n            else if (_hasLineOfSight)\n            {\n                _currentTarget = closestTarget;\n            }\n        }\n        else if (_currentTarget != null)\n        {\n            _currentTarget = null;\n            _hasLineOfSight = false;\n            OnTargetLost?.Invoke();\n        }\n    }\n    \n    private bool HasLineOfSight(Transform target)\n    {\n        Vector3 direction = target.position - _laserOrigin.position;\n        RaycastHit hit;\n        \n        if (Physics.Raycast(_laserOrigin.position, direction.normalized, out hit, direction.magnitude, _obstacleLayerMask))\n        {\n            return hit.collider.transform == target;\n        }\n        \n        return true;\n    }\n    \n    private void UpdateStateMachine()\n    {\n        switch (_currentState)\n        {\n            case RobotState.Patrolling:\n                HandlePatrolling();\n                break;\n                \n            case RobotState.Chasing:\n                HandleChasing();\n                break;\n                \n            case RobotState.Charging:\n                HandleCharging();\n                break;\n                \n            case RobotState.Firing:\n                HandleFiring();\n                break;\n                \n            case RobotState.Cooldown:\n                HandleCooldown();\n                break;\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        if (_currentTarget != null && _hasLineOfSight)\n        {\n            _currentState = RobotState.Chasing;\n            return;\n        }\n        \n        if (Vector3.Distance(transform.position, _patrolDestination) < 1f)\n        {\n            SetNewPatrolDestination();\n        }\n    }\n    \n    private void HandleChasing()\n    {\n        if (_currentTarget == null || !_hasLineOfSight)\n        {\n            _currentState = RobotState.Patrolling;\n            SetNewPatrolDestination();\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _currentTarget.position);\n        \n        if (distanceToTarget <= _attackRange && Time.time >= _lastLaserTime + _laserCooldown)\n        {\n            _currentState = RobotState.Charging;\n            _chargeStartTime = Time.time;\n            \n            if (_laserChargeEffect != null)\n                _laserChargeEffect.Play();\n                \n            PlaySound(_laserChargeSound);\n        }\n    }\n    \n    private void HandleCharging()\n    {\n        if (_currentTarget == null || !_hasLineOfSight)\n        {\n            _currentState = RobotState.Patrolling;\n            \n            if (_laserChargeEffect != null)\n                _laserChargeEffect.Stop();\n                \n            return;\n        }\n        \n        LookAtTarget(_currentTarget.position);\n        \n        if (Time.time >= _chargeStartTime + _laserChargeTime)\n        {\n            _currentState = RobotState.Firing;\n            FireLaser();\n        }\n    }\n    \n    private void HandleFiring()\n    {\n        if (Time.time >= _lastLaserTime + _laserDuration)\n        {\n            _currentState = RobotState.Cooldown;\n            DisableLaser();\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (Time.time >= _lastLaserTime + _laserCooldown)\n        {\n            if (_currentTarget != null && _hasLineOfSight)\n            {\n                _currentState = RobotState.Chasing;\n            }\n            else\n            {\n                _currentState = RobotState.Patrolling;\n                SetNewPatrolDestination();\n            }\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector3 targetPosition = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case RobotState.Patrolling:\n                targetPosition = _patrolDestination;\n                break;\n                \n            case RobotState.Chasing:\n                if (_currentTarget != null)\n                    targetPosition = _currentTarget.position;\n                break;\n                \n            case RobotState.Charging:\n            case RobotState.Firing:\n            case RobotState.Cooldown:\n                return;\n        }\n        \n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction.magnitude > 0.1f)\n        {\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            LookAtTarget(targetPosition);\n        }\n    }\n    \n    private void LookAtTarget(Vector3 targetPosition)\n    {\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        direction.y = 0;\n        \n        if (direction.magnitude > 0.1f)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void SetNewPatrolDestination()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _patrolRadius;\n        _patrolDestination = _patrolCenter + new Vector3(randomCircle.x, 0, randomCircle.y);\n    }\n    \n    private void FireLaser()\n    {\n        if (_currentTarget == null) return;\n        \n        _lastLaserTime = Time.time;\n        OnLaserFired?.Invoke();\n        PlaySound(_laserFireSound);\n        \n        Vector3 laserDirection = (_currentTarget.position - _laserOrigin.position).normalized;\n        RaycastHit hit;\n        \n        if (Physics.Raycast(_laserOrigin.position, laserDirection, out hit, _attackRange))\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                // Apply damage to player\n                var playerRigidbody = hit.collider.GetComponent<Rigidbody>();\n                if (playerRigidbody != null)\n                {\n                    playerRigidbody.AddForce(laserDirection * 500f);\n                }\n                \n                // Send damage message\n                hit.collider.SendMessage(\"TakeDamage\", _laserDamage, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            ShowLaserEffect(_laserOrigin.position, hit.point);\n            \n            if (_laserImpactEffect != null)\n            {\n                _laserImpactEffect.transform.position = hit.point;\n                _laserImpactEffect.Play();\n            }\n        }\n        else\n        {\n            Vector3 endPoint = _laserOrigin.position + laserDirection * _attackRange;\n            ShowLaserEffect(_laserOrigin.position, endPoint);\n        }\n    }\n    \n    private void ShowLaserEffect(Vector3 startPoint, Vector3 endPoint)\n    {\n        if (_laserRenderer != null)\n        {\n            _laserRenderer.enabled = true;\n            _laserRenderer.SetPosition(0, startPoint);\n            _laserRenderer.SetPosition(1, endPoint);\n        }\n        \n        if (_laserLight != null)\n        {\n            _laserLight.enabled = true;\n        }\n    }\n    \n    private void DisableLaser()\n    {\n        if (_laserRenderer != null)\n            _laserRenderer.enabled = false;\n            \n        if (_laserLight != null)\n            _laserLight.enabled = false;\n            \n        if (_laserChargeEffect != null)\n            _laserChargeEffect.Stop();\n    }\n    \n    private void UpdateLaserVisuals()\n    {\n        if (_laserRenderer != null && _laserRenderer.enabled)\n        {\n            float alpha = Mathf.PingPong(Time.time * 10f, 1f);\n            Color laserColor = _laserRenderer.material.color;\n            laserColor.a = alpha;\n            _laserRenderer.material.color = laserColor;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == RobotState.Patrolling || _currentState == RobotState.Chasing);\n        _animator.SetBool(\"IsCharging\", _currentState == RobotState.Charging);\n        _animator.SetBool(\"IsFiring\", _currentState == RobotState.Firing);\n        _animator.SetBool(\"HasTarget\", _currentTarget != null);\n    }\n    \n    private void SetupLaserRenderer()\n    {\n        if (_laserRenderer != null)\n        {\n            _laserRenderer.positionCount = 2;\n            _laserRenderer.startWidth = 0.1f;\n            _laserRenderer.endWidth = 0.05f;\n            _laserRenderer.enabled = false;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_patrolCenter, _patrolRadius);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MusicalInstrumentObject\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"Renderer\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"highNote\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"midNote\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lowNote\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"vibrationIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"vibrationDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"colorShiftSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"particleCount\",\n      \"type\": \"int\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"particleFadeTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"play_note_on_collision\",\n      \"trigger\": \"when another object collides with this object\",\n      \"actions\": [\n        {\n          \"action\": \"determine collision point height relative to object bounds\"\n        },\n        {\n          \"action\": \"play high note if collision is in upper third of object\"\n        },\n        {\n          \"action\": \"play mid note if collision is in middle third of object\"\n        },\n        {\n          \"action\": \"play low note if collision is in lower third of object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_color_with_note\",\n      \"trigger\": \"when a note starts playing\",\n      \"actions\": [\n        {\n          \"action\": \"shift object color to red if high note is playing\"\n        },\n        {\n          \"action\": \"shift object color to yellow if mid note is playing\"\n        },\n        {\n          \"action\": \"shift object color to blue if low note is playing\"\n        },\n        {\n          \"action\": \"smoothly transition color over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"vibrate_with_sound\",\n      \"trigger\": \"when a note starts playing\",\n      \"actions\": [\n        {\n          \"action\": \"shake object position randomly with vibration intensity\"\n        },\n        {\n          \"action\": \"gradually reduce vibration over vibration duration\"\n        },\n        {\n          \"action\": \"return to original position when vibration ends\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emit_particle_trail\",\n      \"trigger\": \"when a note starts playing\",\n      \"actions\": [\n        {\n          \"action\": \"spawn particles at collision point\"\n        },\n        {\n          \"action\": \"set particle color to match current object color\"\n        },\n        {\n          \"action\": \"make particles move outward from collision point\"\n        },\n        {\n          \"action\": \"fade particles out over particle fade time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_appearance\",\n      \"trigger\": \"when note finishes playing and vibration stops\",\n      \"actions\": [\n        {\n          \"action\": \"gradually return object color to original color\"\n        },\n        {\n          \"action\": \"ensure object is at rest position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class MusicalInstrument : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _baseFrequency = 220f;\n    [SerializeField] private float _frequencyRange = 880f;\n    [SerializeField] private float _noteDuration = 1f;\n    [SerializeField] private AnimationCurve _volumeCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _objectRenderer;\n    [SerializeField] private Color _lowNoteColor = Color.red;\n    [SerializeField] private Color _highNoteColor = Color.blue;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Vibration Settings\")]\n    [SerializeField] private float _vibrationIntensity = 0.1f;\n    [SerializeField] private float _vibrationFrequency = 20f;\n    [SerializeField] private AnimationCurve _vibrationCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Particle Settings\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private int _particleCount = 50;\n    [SerializeField] private float _particleLifetime = 2f;\n    [SerializeField] private float _particleSpeed = 5f;\n    [SerializeField] private Gradient _particleColorGradient;\n    \n    private Collider _collider;\n    private Vector3 _originalPosition;\n    private Color _originalColor;\n    private Color _targetColor;\n    private float _currentColorLerp = 0f;\n    private bool _isPlaying = false;\n    private Coroutine _playNoteCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupAudioSource();\n        SetupParticleSystem();\n        _originalPosition = transform.position;\n        _originalColor = _objectRenderer.material.color;\n        _targetColor = _originalColor;\n    }\n    \n    private void InitializeComponents()\n    {\n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        if (_objectRenderer == null)\n            _objectRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_particleSystem == null)\n        {\n            GameObject particleObj = new GameObject(\"ParticleSystem\");\n            particleObj.transform.SetParent(transform);\n            particleObj.transform.localPosition = Vector3.zero;\n            _particleSystem = particleObj.AddComponent<ParticleSystem>();\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource.clip = null;\n        _audioSource.loop = false;\n        _audioSource.playOnAwake = false;\n        _audioSource.volume = 0.5f;\n    }\n    \n    private void SetupParticleSystem()\n    {\n        var main = _particleSystem.main;\n        main.startLifetime = _particleLifetime;\n        main.startSpeed = _particleSpeed;\n        main.maxParticles = _particleCount;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Sphere;\n        shape.radius = 0.5f;\n        \n        var colorOverLifetime = _particleSystem.colorOverLifetime;\n        colorOverLifetime.enabled = true;\n        if (_particleColorGradient == null)\n        {\n            _particleColorGradient = new Gradient();\n            _particleColorGradient.SetKeys(\n                new GradientColorKey[] { new GradientColorKey(Color.white, 0.0f), new GradientColorKey(Color.white, 1.0f) },\n                new GradientAlphaKey[] { new GradientAlphaKey(1.0f, 0.0f), new GradientAlphaKey(0.0f, 1.0f) }\n            );\n        }\n        colorOverLifetime.color = _particleColorGradient;\n    }\n    \n    private void Update()\n    {\n        UpdateColorTransition();\n    }\n    \n    private void UpdateColorTransition()\n    {\n        if (_currentColorLerp > 0f)\n        {\n            _currentColorLerp -= Time.deltaTime * _colorTransitionSpeed;\n            _currentColorLerp = Mathf.Max(0f, _currentColorLerp);\n            \n            Color currentColor = Color.Lerp(_originalColor, _targetColor, _currentColorLerp);\n            _objectRenderer.material.color = currentColor;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Vector3 hitPoint = other.ClosestPoint(transform.position);\n            PlayNoteAtPosition(hitPoint);\n        }\n    }\n    \n    private void PlayNoteAtPosition(Vector3 hitPosition)\n    {\n        if (_isPlaying)\n        {\n            if (_playNoteCoroutine != null)\n                StopCoroutine(_playNoteCoroutine);\n        }\n        \n        float normalizedHeight = CalculateNormalizedHeight(hitPosition);\n        float frequency = _baseFrequency + (normalizedHeight * _frequencyRange);\n        \n        _playNoteCoroutine = StartCoroutine(PlayNoteCoroutine(frequency, normalizedHeight));\n    }\n    \n    private float CalculateNormalizedHeight(Vector3 hitPosition)\n    {\n        Bounds bounds = _collider.bounds;\n        float relativeY = hitPosition.y - bounds.min.y;\n        float normalizedHeight = relativeY / bounds.size.y;\n        return Mathf.Clamp01(normalizedHeight);\n    }\n    \n    private IEnumerator PlayNoteCoroutine(float frequency, float normalizedHeight)\n    {\n        _isPlaying = true;\n        \n        // Set color based on frequency\n        _targetColor = Color.Lerp(_lowNoteColor, _highNoteColor, normalizedHeight);\n        _currentColorLerp = 1f;\n        \n        // Generate and play audio\n        AudioClip noteClip = GenerateTone(frequency, _noteDuration);\n        _audioSource.clip = noteClip;\n        _audioSource.Play();\n        \n        // Emit particles\n        EmitParticles(normalizedHeight);\n        \n        // Start vibration\n        StartCoroutine(VibrateObject());\n        \n        yield return new WaitForSeconds(_noteDuration);\n        \n        _isPlaying = false;\n        \n        // Cleanup\n        if (noteClip != null)\n            DestroyImmediate(noteClip);\n    }\n    \n    private AudioClip GenerateTone(float frequency, float duration)\n    {\n        int sampleRate = 44100;\n        int sampleCount = Mathf.RoundToInt(sampleRate * duration);\n        float[] samples = new float[sampleCount];\n        \n        for (int i = 0; i < sampleCount; i++)\n        {\n            float time = (float)i / sampleRate;\n            float volume = _volumeCurve.Evaluate(time / duration);\n            samples[i] = Mathf.Sin(2 * Mathf.PI * frequency * time) * volume;\n        }\n        \n        AudioClip clip = AudioClip.Create(\"GeneratedTone\", sampleCount, 1, sampleRate, false);\n        clip.SetData(samples, 0);\n        return clip;\n    }\n    \n    private void EmitParticles(float normalizedHeight)\n    {\n        var emission = _particleSystem.emission;\n        emission.enabled = true;\n        \n        // Update particle color based on note\n        var main = _particleSystem.main;\n        Color particleColor = Color.Lerp(_lowNoteColor, _highNoteColor, normalizedHeight);\n        main.startColor = particleColor;\n        \n        // Emit burst\n        _particleSystem.Emit(_particleCount);\n        \n        StartCoroutine(DisableEmissionAfterDelay());\n    }\n    \n    private IEnumerator DisableEmissionAfterDelay()\n    {\n        yield return new WaitForSeconds(0.1f);\n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n    }\n    \n    private IEnumerator VibrateObject()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _noteDuration)\n        {\n            float normalizedTime = elapsedTime / _noteDuration;\n            float vibrationAmount = _vibrationCurve.Evaluate(normalizedTime) * _vibrationIntensity;\n            \n            Vector3 randomOffset = new Vector3(\n                Mathf.Sin(Time.time * _vibrationFrequency) * vibrationAmount,\n                Mathf.Cos(Time.time * _vibrationFrequency * 1.1f) * vibrationAmount,\n                Mathf.Sin(Time.time * _vibrationFrequency * 0.9f) * vibrationAmount\n            );\n            \n            transform.position = _originalPosition + randomOffset;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.position = _originalPosition;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_playNoteCoroutine != null)\n            StopCoroutine(_playNoteCoroutine);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FriendListDisplay\",\n  \"components\": [\n    \"Canvas\",\n    \"VerticalLayoutGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"friendItemPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"scrollView\",\n      \"type\": \"ScrollRect\",\n      \"default\": null\n    },\n    {\n      \"name\": \"emptyListMessage\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"refreshButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_friend_list\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"load friend data from storage\"\n        },\n        {\n          \"action\": \"create friend item UI elements for each friend\"\n        },\n        {\n          \"action\": \"arrange friend items in vertical layout\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_empty_message\",\n      \"trigger\": \"when friend list is empty\",\n      \"actions\": [\n        {\n          \"action\": \"display empty friends list message\"\n        },\n        {\n          \"action\": \"hide scroll view container\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refresh_friend_list\",\n      \"trigger\": \"when refresh button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"clear existing friend item displays\"\n        },\n        {\n          \"action\": \"reload friend data from server\"\n        },\n        {\n          \"action\": \"recreate friend item UI elements\"\n        },\n        {\n          \"action\": \"update scroll view content\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_friend_item_click\",\n      \"trigger\": \"when any friend item is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"open friend profile view\"\n        },\n        {\n          \"action\": \"pass selected friend data to profile\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_online_status\",\n      \"trigger\": \"when friend online status changes\",\n      \"actions\": [\n        {\n          \"action\": \"find corresponding friend item display\"\n        },\n        {\n          \"action\": \"update online indicator visual state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class FriendListDisplay : MonoBehaviour\n{\n    [System.Serializable]\n    public class Friend\n    {\n        public string username;\n        public string displayName;\n        public bool isOnline;\n        public DateTime lastSeen;\n        public Sprite avatar;\n        public int level;\n        \n        public Friend(string username, string displayName)\n        {\n            this.username = username;\n            this.displayName = displayName;\n            this.isOnline = false;\n            this.lastSeen = DateTime.Now;\n            this.level = 1;\n        }\n    }\n    \n    [System.Serializable]\n    public class FriendSelectedEvent : UnityEvent<Friend> { }\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _friendListParent;\n    [SerializeField] private GameObject _friendItemPrefab;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private Text _friendCountText;\n    [SerializeField] private Button _refreshButton;\n    [SerializeField] private InputField _searchField;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private bool _showOnlineFirst = true;\n    [SerializeField] private bool _showLastSeen = true;\n    [SerializeField] private Color _onlineColor = Color.green;\n    [SerializeField] private Color _offlineColor = Color.gray;\n    [SerializeField] private int _maxDisplayedFriends = 100;\n    \n    [Header(\"Events\")]\n    [SerializeField] private FriendSelectedEvent _onFriendSelected;\n    [SerializeField] private UnityEvent _onFriendListRefreshed;\n    \n    private List<Friend> _allFriends = new List<Friend>();\n    private List<Friend> _filteredFriends = new List<Friend>();\n    private List<GameObject> _friendItemObjects = new List<GameObject>();\n    private string _currentSearchFilter = \"\";\n    \n    private void Start()\n    {\n        InitializeUI();\n        LoadSampleFriends();\n        RefreshFriendList();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_refreshButton != null)\n            _refreshButton.onClick.AddListener(RefreshFriendList);\n            \n        if (_searchField != null)\n            _searchField.onValueChanged.AddListener(OnSearchChanged);\n    }\n    \n    private void LoadSampleFriends()\n    {\n        _allFriends.Clear();\n        \n        // Add sample friends for demonstration\n        AddFriend(\"player1\", \"Alex Thunder\", true, 25);\n        AddFriend(\"player2\", \"Sarah Storm\", false, 18);\n        AddFriend(\"player3\", \"Mike Lightning\", true, 32);\n        AddFriend(\"player4\", \"Emma Frost\", false, 12);\n        AddFriend(\"player5\", \"Jake Fire\", true, 45);\n        AddFriend(\"player6\", \"Luna Moon\", false, 8);\n        AddFriend(\"player7\", \"Rex Dragon\", true, 67);\n        AddFriend(\"player8\", \"Zoe Star\", false, 23);\n    }\n    \n    public void AddFriend(string username, string displayName, bool isOnline = false, int level = 1)\n    {\n        Friend newFriend = new Friend(username, displayName)\n        {\n            isOnline = isOnline,\n            level = level,\n            lastSeen = isOnline ? DateTime.Now : DateTime.Now.AddHours(-UnityEngine.Random.Range(1, 72))\n        };\n        \n        _allFriends.Add(newFriend);\n    }\n    \n    public void RemoveFriend(string username)\n    {\n        _allFriends.RemoveAll(f => f.username == username);\n        RefreshFriendList();\n    }\n    \n    public void RefreshFriendList()\n    {\n        FilterFriends();\n        SortFriends();\n        UpdateFriendDisplay();\n        UpdateFriendCount();\n        _onFriendListRefreshed?.Invoke();\n    }\n    \n    private void FilterFriends()\n    {\n        _filteredFriends.Clear();\n        \n        foreach (Friend friend in _allFriends)\n        {\n            if (string.IsNullOrEmpty(_currentSearchFilter) || \n                friend.displayName.ToLower().Contains(_currentSearchFilter.ToLower()) ||\n                friend.username.ToLower().Contains(_currentSearchFilter.ToLower()))\n            {\n                _filteredFriends.Add(friend);\n            }\n        }\n        \n        if (_filteredFriends.Count > _maxDisplayedFriends)\n        {\n            _filteredFriends = _filteredFriends.GetRange(0, _maxDisplayedFriends);\n        }\n    }\n    \n    private void SortFriends()\n    {\n        if (_showOnlineFirst)\n        {\n            _filteredFriends.Sort((a, b) =>\n            {\n                if (a.isOnline && !b.isOnline) return -1;\n                if (!a.isOnline && b.isOnline) return 1;\n                return string.Compare(a.displayName, b.displayName, StringComparison.OrdinalIgnoreCase);\n            });\n        }\n        else\n        {\n            _filteredFriends.Sort((a, b) => \n                string.Compare(a.displayName, b.displayName, StringComparison.OrdinalIgnoreCase));\n        }\n    }\n    \n    private void UpdateFriendDisplay()\n    {\n        ClearFriendItems();\n        \n        if (_friendListParent == null || _friendItemPrefab == null)\n            return;\n            \n        foreach (Friend friend in _filteredFriends)\n        {\n            GameObject friendItem = Instantiate(_friendItemPrefab, _friendListParent);\n            SetupFriendItem(friendItem, friend);\n            _friendItemObjects.Add(friendItem);\n        }\n        \n        if (_scrollRect != null)\n        {\n            Canvas.ForceUpdateCanvases();\n            _scrollRect.verticalNormalizedPosition = 1f;\n        }\n    }\n    \n    private void SetupFriendItem(GameObject friendItem, Friend friend)\n    {\n        // Setup display name\n        Text nameText = friendItem.transform.Find(\"NameText\")?.GetComponent<Text>();\n        if (nameText != null)\n            nameText.text = friend.displayName;\n            \n        // Setup online status\n        Image statusImage = friendItem.transform.Find(\"StatusImage\")?.GetComponent<Image>();\n        if (statusImage != null)\n            statusImage.color = friend.isOnline ? _onlineColor : _offlineColor;\n            \n        // Setup level text\n        Text levelText = friendItem.transform.Find(\"LevelText\")?.GetComponent<Text>();\n        if (levelText != null)\n            levelText.text = $\"Lv.{friend.level}\";\n            \n        // Setup last seen text\n        if (_showLastSeen)\n        {\n            Text lastSeenText = friendItem.transform.Find(\"LastSeenText\")?.GetComponent<Text>();\n            if (lastSeenText != null)\n            {\n                if (friend.isOnline)\n                {\n                    lastSeenText.text = \"Online\";\n                    lastSeenText.color = _onlineColor;\n                }\n                else\n                {\n                    TimeSpan timeDiff = DateTime.Now - friend.lastSeen;\n                    lastSeenText.text = FormatLastSeen(timeDiff);\n                    lastSeenText.color = _offlineColor;\n                }\n            }\n        }\n        \n        // Setup avatar\n        Image avatarImage = friendItem.transform.Find(\"AvatarImage\")?.GetComponent<Image>();\n        if (avatarImage != null && friend.avatar != null)\n            avatarImage.sprite = friend.avatar;\n            \n        // Setup click handler\n        Button friendButton = friendItem.GetComponent<Button>();\n        if (friendButton != null)\n        {\n            friendButton.onClick.AddListener(() => OnFriendSelected(friend));\n        }\n    }\n    \n    private string FormatLastSeen(TimeSpan timeDiff)\n    {\n        if (timeDiff.TotalMinutes < 1)\n            return \"Just now\";\n        else if (timeDiff.TotalHours < 1)\n            return $\"{(int)timeDiff.TotalMinutes}m ago\";\n        else if (timeDiff.TotalDays < 1)\n            return $\"{(int)timeDiff.TotalHours}h ago\";\n        else if (timeDiff.TotalDays < 7)\n            return $\"{(int)timeDiff.TotalDays}d ago\";\n        else\n            return \"Long ago\";\n    }\n    \n    private void ClearFriendItems()\n    {\n        foreach (GameObject item in _friendItemObjects)\n        {\n            if (item != null)\n                DestroyImmediate(item);\n        }\n        _friendItemObjects.Clear();\n    }\n    \n    private void UpdateFriendCount()\n    {\n        if (_friendCountText != null)\n        {\n            int onlineCount = 0;\n            foreach (Friend friend in _allFriends)\n            {\n                if (friend.isOnline) onlineCount++;\n            }\n            \n            _friendCountText.text = $\"Friends ({onlineCount}/{_allFriends.Count})\";\n        }\n    }\n    \n    private void OnSearchChanged(string searchText)\n    {\n        _currentSearchFilter = searchText;\n        RefreshFriendList();\n    }\n    \n    private void OnFriendSelected(Friend friend)\n    {\n        _onFriendSelected?.Invoke(friend);\n    }\n    \n    public void SetFriendOnlineStatus(string username, bool isOnline)\n    {\n        Friend friend = _allFriends.Find(f => f.username == username);\n        if (friend != null)\n        {\n            friend.isOnline = isOnline;\n            if (!isOnline)\n                friend.lastSeen = DateTime.Now;\n            RefreshFriendList();\n        }\n    }\n    \n    public void UpdateFriendLevel(string username, int newLevel)\n    {\n        Friend friend = _allFriends.Find(f => f.username == username);\n        if (friend != null)\n        {\n            friend.level = newLevel;\n            RefreshFriendList();\n        }\n    }\n    \n    public Friend GetFriend(string username)\n    {\n        return _allFriends.Find(f => f.username == username);\n    }\n    \n    public List<Friend> GetOnlineFriends()\n    {\n        return _allFriends.FindAll(f => f.isOnline);\n    }\n    \n    public int GetFriendCount()\n    {\n        return _allFriends.Count;\n    }\n    \n    public int GetOnlineFriendCount()\n    {\n        return _allFriends.FindAll(f => f.isOnline).Count;\n    }\n    \n    private void OnDestroy()\n    {\n        ClearFriendItems();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemyHealthBar\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\",\n    \"RectTransform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"healthBarFill\",\n      \"type\": \"Image\",\n      \"default\": null\n    },\n    {\n      \"name\": \"followTarget\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"heightOffset\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"smoothSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_enemy_head\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"position health bar above the enemy head with height offset\"\n        },\n        {\n          \"action\": \"make health bar face the camera\"\n        },\n        {\n          \"action\": \"smoothly interpolate position changes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_health_display\",\n      \"trigger\": \"when enemy health changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate health percentage from current and max health\"\n        },\n        {\n          \"action\": \"update fill amount of health bar image to match percentage\"\n        },\n        {\n          \"action\": \"change health bar color based on health percentage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_when_full_health\",\n      \"trigger\": \"when enemy is at full health\",\n      \"actions\": [\n        {\n          \"action\": \"make health bar invisible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_when_damaged\",\n      \"trigger\": \"when enemy takes damage\",\n      \"actions\": [\n        {\n          \"action\": \"make health bar visible\"\n        },\n        {\n          \"action\": \"briefly highlight or flash the health bar\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_when_dead\",\n      \"trigger\": \"when enemy health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"fade out health bar\"\n        },\n        {\n          \"action\": \"disable health bar after fade completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class EnemyHealthBar : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Canvas _healthBarCanvas;\n    [SerializeField] private Slider _healthSlider;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Vector3 _offset = new Vector3(0, 2f, 0);\n    [SerializeField] private Color _fullHealthColor = Color.green;\n    [SerializeField] private Color _lowHealthColor = Color.red;\n    [SerializeField] private float _lowHealthThreshold = 0.3f;\n    [SerializeField] private bool _hideWhenFull = true;\n    [SerializeField] private bool _alwaysFaceCamera = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _smoothTime = 0.1f;\n    [SerializeField] private AnimationCurve _damageCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Camera _mainCamera;\n    private float _targetHealthPercentage;\n    private float _displayHealthPercentage;\n    private float _velocity;\n    private bool _isAnimating;\n    \n    private void Awake()\n    {\n        _currentHealth = _maxHealth;\n        _targetHealthPercentage = 1f;\n        _displayHealthPercentage = 1f;\n        \n        CreateHealthBarUI();\n    }\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        UpdateHealthBar();\n    }\n    \n    private void Update()\n    {\n        if (_healthBarCanvas != null)\n        {\n            UpdatePosition();\n            UpdateRotation();\n            AnimateHealthBar();\n        }\n    }\n    \n    private void CreateHealthBarUI()\n    {\n        if (_healthBarCanvas != null) return;\n        \n        GameObject canvasGO = new GameObject(\"HealthBarCanvas\");\n        canvasGO.transform.SetParent(transform);\n        canvasGO.transform.localPosition = _offset;\n        \n        _healthBarCanvas = canvasGO.AddComponent<Canvas>();\n        _healthBarCanvas.renderMode = RenderMode.WorldSpace;\n        _healthBarCanvas.sortingOrder = 10;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ConstantWorldSize;\n        scaler.referencePixelsPerUnit = 100;\n        \n        RectTransform canvasRect = _healthBarCanvas.GetComponent<RectTransform>();\n        canvasRect.sizeDelta = new Vector2(2f, 0.3f);\n        \n        GameObject sliderGO = new GameObject(\"HealthSlider\");\n        sliderGO.transform.SetParent(canvasGO.transform, false);\n        \n        _healthSlider = sliderGO.AddComponent<Slider>();\n        _healthSlider.minValue = 0f;\n        _healthSlider.maxValue = 1f;\n        _healthSlider.value = 1f;\n        \n        RectTransform sliderRect = sliderGO.GetComponent<RectTransform>();\n        sliderRect.anchorMin = Vector2.zero;\n        sliderRect.anchorMax = Vector2.one;\n        sliderRect.sizeDelta = Vector2.zero;\n        sliderRect.anchoredPosition = Vector2.zero;\n        \n        GameObject backgroundGO = new GameObject(\"Background\");\n        backgroundGO.transform.SetParent(sliderGO.transform, false);\n        _backgroundImage = backgroundGO.AddComponent<Image>();\n        _backgroundImage.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);\n        \n        RectTransform bgRect = backgroundGO.GetComponent<RectTransform>();\n        bgRect.anchorMin = Vector2.zero;\n        bgRect.anchorMax = Vector2.one;\n        bgRect.sizeDelta = Vector2.zero;\n        bgRect.anchoredPosition = Vector2.zero;\n        \n        GameObject fillAreaGO = new GameObject(\"Fill Area\");\n        fillAreaGO.transform.SetParent(sliderGO.transform, false);\n        \n        RectTransform fillAreaRect = fillAreaGO.GetComponent<RectTransform>();\n        fillAreaRect.anchorMin = Vector2.zero;\n        fillAreaRect.anchorMax = Vector2.one;\n        fillAreaRect.sizeDelta = Vector2.zero;\n        fillAreaRect.anchoredPosition = Vector2.zero;\n        \n        GameObject fillGO = new GameObject(\"Fill\");\n        fillGO.transform.SetParent(fillAreaGO.transform, false);\n        _fillImage = fillGO.AddComponent<Image>();\n        _fillImage.color = _fullHealthColor;\n        _fillImage.type = Image.Type.Filled;\n        \n        RectTransform fillRect = fillGO.GetComponent<RectTransform>();\n        fillRect.anchorMin = Vector2.zero;\n        fillRect.anchorMax = Vector2.one;\n        fillRect.sizeDelta = Vector2.zero;\n        fillRect.anchoredPosition = Vector2.zero;\n        \n        _healthSlider.fillRect = fillRect;\n    }\n    \n    private void UpdatePosition()\n    {\n        if (_healthBarCanvas != null)\n        {\n            _healthBarCanvas.transform.position = transform.position + _offset;\n        }\n    }\n    \n    private void UpdateRotation()\n    {\n        if (_alwaysFaceCamera && _mainCamera != null && _healthBarCanvas != null)\n        {\n            Vector3 directionToCamera = _mainCamera.transform.position - _healthBarCanvas.transform.position;\n            _healthBarCanvas.transform.rotation = Quaternion.LookRotation(directionToCamera);\n        }\n    }\n    \n    private void AnimateHealthBar()\n    {\n        if (Mathf.Abs(_displayHealthPercentage - _targetHealthPercentage) > 0.01f)\n        {\n            _displayHealthPercentage = Mathf.SmoothDamp(_displayHealthPercentage, _targetHealthPercentage, ref _velocity, _smoothTime);\n            \n            if (_healthSlider != null)\n                _healthSlider.value = _displayHealthPercentage;\n                \n            UpdateHealthBarColor();\n        }\n    }\n    \n    private void UpdateHealthBar()\n    {\n        _targetHealthPercentage = _currentHealth / _maxHealth;\n        \n        UpdateHealthBarColor();\n        UpdateVisibility();\n    }\n    \n    private void UpdateHealthBarColor()\n    {\n        if (_fillImage != null)\n        {\n            float healthPercentage = _displayHealthPercentage;\n            \n            if (healthPercentage <= _lowHealthThreshold)\n            {\n                float t = healthPercentage / _lowHealthThreshold;\n                _fillImage.color = Color.Lerp(_lowHealthColor, _fullHealthColor, t);\n            }\n            else\n            {\n                _fillImage.color = _fullHealthColor;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_healthBarCanvas != null)\n        {\n            bool shouldShow = !_hideWhenFull || _currentHealth < _maxHealth;\n            _healthBarCanvas.gameObject.SetActive(shouldShow);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (damage <= 0) return;\n        \n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        UpdateHealthBar();\n        \n        if (_currentHealth <= 0)\n        {\n            OnDeath();\n        }\n    }\n    \n    public void Heal(float healAmount)\n    {\n        if (healAmount <= 0) return;\n        \n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        UpdateHealthBar();\n    }\n    \n    public void SetHealth(float newHealth)\n    {\n        _currentHealth = Mathf.Clamp(newHealth, 0, _maxHealth);\n        UpdateHealthBar();\n        \n        if (_currentHealth <= 0)\n        {\n            OnDeath();\n        }\n    }\n    \n    public void SetMaxHealth(float newMaxHealth)\n    {\n        float healthPercentage = _currentHealth / _maxHealth;\n        _maxHealth = Mathf.Max(1f, newMaxHealth);\n        _currentHealth = _maxHealth * healthPercentage;\n        UpdateHealthBar();\n    }\n    \n    private void OnDeath()\n    {\n        if (_healthBarCanvas != null)\n        {\n            _healthBarCanvas.gameObject.SetActive(false);\n        }\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n    \n    public bool IsAlive()\n    {\n        return _currentHealth > 0;\n    }\n    \n    private void OnValidate()\n    {\n        if (_maxHealth <= 0)\n            _maxHealth = 1f;\n            \n        _currentHealth = Mathf.Clamp(_currentHealth, 0, _maxHealth);\n        \n        if (Application.isPlaying)\n            UpdateHealthBar();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HoverCrosshair\",\n  \"components\": [\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"normalSprite\",\n      \"type\": \"Sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"hoverSprite\",\n      \"type\": \"Sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalColor\",\n      \"type\": \"Color\",\n      \"default\": \"white\"\n    },\n    {\n      \"name\": \"hoverColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"change_to_hover_state\",\n      \"trigger\": \"when mouse cursor enters this UI element area\",\n      \"actions\": [\n        {\n          \"action\": \"change crosshair sprite to hover sprite\"\n        },\n        {\n          \"action\": \"change crosshair color to hover color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_to_normal_state\",\n      \"trigger\": \"when mouse cursor exits this UI element area\",\n      \"actions\": [\n        {\n          \"action\": \"change crosshair sprite to normal sprite\"\n        },\n        {\n          \"action\": \"change crosshair color to normal color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class DynamicCrosshair : MonoBehaviour\n{\n    [Header(\"Crosshair Settings\")]\n    [SerializeField] private Image _crosshairImage;\n    [SerializeField] private Sprite _defaultCrosshair;\n    [SerializeField] private Sprite _hoverCrosshair;\n    [SerializeField] private Color _defaultColor = Color.white;\n    [SerializeField] private Color _hoverColor = Color.red;\n    \n    [Header(\"Raycast Settings\")]\n    [SerializeField] private Camera _playerCamera;\n    [SerializeField] private float _raycastDistance = 100f;\n    [SerializeField] private LayerMask _interactableLayerMask = -1;\n    [SerializeField] private string[] _interactableTags = { \"Interactable\", \"Enemy\", \"Pickup\" };\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useAnimation = true;\n    [SerializeField] private float _transitionSpeed = 5f;\n    [SerializeField] private float _hoverScale = 1.2f;\n    \n    private bool _isHovering = false;\n    private Vector3 _defaultScale;\n    private Color _currentColor;\n    private Vector3 _targetScale;\n    \n    private void Start()\n    {\n        if (_crosshairImage == null)\n            _crosshairImage = GetComponent<Image>();\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_crosshairImage != null)\n        {\n            _defaultScale = _crosshairImage.transform.localScale;\n            _targetScale = _defaultScale;\n            _currentColor = _defaultColor;\n            _crosshairImage.color = _currentColor;\n            \n            if (_defaultCrosshair != null)\n                _crosshairImage.sprite = _defaultCrosshair;\n        }\n    }\n    \n    private void Update()\n    {\n        CheckForHoverTarget();\n        UpdateCrosshairAppearance();\n    }\n    \n    private void CheckForHoverTarget()\n    {\n        if (_playerCamera == null) return;\n        \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f));\n        RaycastHit hit;\n        \n        bool wasHovering = _isHovering;\n        _isHovering = false;\n        \n        if (Physics.Raycast(ray, out hit, _raycastDistance, _interactableLayerMask))\n        {\n            GameObject hitObject = hit.collider.gameObject;\n            \n            foreach (string tag in _interactableTags)\n            {\n                if (hitObject.CompareTag(tag))\n                {\n                    _isHovering = true;\n                    break;\n                }\n            }\n        }\n        \n        if (_isHovering != wasHovering)\n        {\n            OnHoverStateChanged(_isHovering);\n        }\n    }\n    \n    private void OnHoverStateChanged(bool hovering)\n    {\n        if (_crosshairImage == null) return;\n        \n        if (hovering)\n        {\n            if (_hoverCrosshair != null)\n                _crosshairImage.sprite = _hoverCrosshair;\n                \n            _targetScale = _defaultScale * _hoverScale;\n        }\n        else\n        {\n            if (_defaultCrosshair != null)\n                _crosshairImage.sprite = _defaultCrosshair;\n                \n            _targetScale = _defaultScale;\n        }\n    }\n    \n    private void UpdateCrosshairAppearance()\n    {\n        if (_crosshairImage == null) return;\n        \n        Color targetColor = _isHovering ? _hoverColor : _defaultColor;\n        \n        if (_useAnimation)\n        {\n            _currentColor = Color.Lerp(_currentColor, targetColor, Time.deltaTime * _transitionSpeed);\n            _crosshairImage.transform.localScale = Vector3.Lerp(_crosshairImage.transform.localScale, _targetScale, Time.deltaTime * _transitionSpeed);\n        }\n        else\n        {\n            _currentColor = targetColor;\n            _crosshairImage.transform.localScale = _targetScale;\n        }\n        \n        _crosshairImage.color = _currentColor;\n    }\n    \n    public void SetCrosshairSprites(Sprite defaultSprite, Sprite hoverSprite)\n    {\n        _defaultCrosshair = defaultSprite;\n        _hoverCrosshair = hoverSprite;\n        \n        if (_crosshairImage != null && !_isHovering)\n            _crosshairImage.sprite = _defaultCrosshair;\n    }\n    \n    public void SetCrosshairColors(Color defaultColor, Color hoverColor)\n    {\n        _defaultColor = defaultColor;\n        _hoverColor = hoverColor;\n    }\n    \n    public void SetRaycastDistance(float distance)\n    {\n        _raycastDistance = Mathf.Max(0f, distance);\n    }\n    \n    public void AddInteractableTag(string tag)\n    {\n        if (System.Array.IndexOf(_interactableTags, tag) == -1)\n        {\n            string[] newTags = new string[_interactableTags.Length + 1];\n            _interactableTags.CopyTo(newTags, 0);\n            newTags[_interactableTags.Length] = tag;\n            _interactableTags = newTags;\n        }\n    }\n    \n    public bool IsHoveringInteractable()\n    {\n        return _isHovering;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TentacleAlien\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"attackRange\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"tentacleReach\",\n      \"type\": \"float\",\n      \"default\": 12\n    },\n    {\n      \"name\": \"attackDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"attackCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"tentacleCount\",\n      \"type\": \"int\",\n      \"default\": 4\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"start aggressive behavior\"\n        },\n        {\n          \"action\": \"play alien screech sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"approach_target\",\n      \"trigger\": \"when player is detected but outside attack range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at normal speed\"\n        },\n        {\n          \"action\": \"play movement animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"tentacle_whip_attack\",\n      \"trigger\": \"when player is within attack range and attack is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"extend random tentacle toward player\"\n        },\n        {\n          \"action\": \"deal damage if tentacle hits player\"\n        },\n        {\n          \"action\": \"play tentacle whip animation\"\n        },\n        {\n          \"action\": \"start attack cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"tentacle_grab_attack\",\n      \"trigger\": \"when player is within tentacle reach and health is below half\",\n      \"actions\": [\n        {\n          \"action\": \"extend multiple tentacles to grab player\"\n        },\n        {\n          \"action\": \"pull player toward alien body\"\n        },\n        {\n          \"action\": \"deal continuous damage while holding\"\n        },\n        {\n          \"action\": \"play grab animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"defensive_flail\",\n      \"trigger\": \"when taking damage\",\n      \"actions\": [\n        {\n          \"action\": \"flail all tentacles wildly\"\n        },\n        {\n          \"action\": \"knock back nearby objects\"\n        },\n        {\n          \"action\": \"play pain animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_sequence\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"collapse to ground\"\n        },\n        {\n          \"action\": \"tentacles go limp and retract\"\n        },\n        {\n          \"action\": \"play death sound\"\n        },\n        {\n          \"action\": \"disable all attack behaviors\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AlienTentacleController : MonoBehaviour\n{\n    [System.Serializable]\n    public class TentacleSegment\n    {\n        public Transform transform;\n        public Vector3 targetPosition;\n        public Vector3 velocity;\n        public float damping = 0.8f;\n    }\n\n    [Header(\"Alien Settings\")]\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n\n    [Header(\"Tentacle Settings\")]\n    [SerializeField] private List<TentacleSegment> _tentacles = new List<TentacleSegment>();\n    [SerializeField] private float _tentacleSpeed = 8f;\n    [SerializeField] private float _tentacleRange = 15f;\n    [SerializeField] private float _tentacleDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _segmentDistance = 1f;\n    [SerializeField] private AnimationCurve _tentacleMoveCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _hurtSound;\n    [SerializeField] private AudioClip _deathSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _attackEffect;\n    [SerializeField] private ParticleSystem _deathEffect;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnAttack;\n    public UnityEvent OnDeath;\n\n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isAttacking = false;\n    private bool _isDead = false;\n    private float _lastAttackTime;\n    private Vector3 _originalPosition;\n    private Coroutine _currentAttackCoroutine;\n\n    private enum AlienState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        Dead\n    }\n\n    private AlienState _currentState = AlienState.Idle;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n        _originalPosition = transform.position;\n\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        InitializeTentacles();\n        FindPlayer();\n    }\n\n    private void Update()\n    {\n        if (_isDead) return;\n\n        UpdateState();\n        UpdateTentacles();\n        HandleAnimations();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_isDead) return;\n\n        HandleMovement();\n    }\n\n    private void InitializeTentacles()\n    {\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform != null)\n            {\n                _tentacles[i].targetPosition = _tentacles[i].transform.position;\n                _tentacles[i].velocity = Vector3.zero;\n            }\n        }\n    }\n\n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n\n    private void UpdateState()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n\n        switch (_currentState)\n        {\n            case AlienState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                {\n                    _currentState = AlienState.Chasing;\n                    OnPlayerDetected?.Invoke();\n                }\n                break;\n\n            case AlienState.Chasing:\n                if (distanceToPlayer <= _tentacleRange && Time.time >= _lastAttackTime + _attackCooldown)\n                {\n                    _currentState = AlienState.Attacking;\n                    StartTentacleAttack();\n                }\n                else if (distanceToPlayer > _detectionRange * 1.5f)\n                {\n                    _currentState = AlienState.Idle;\n                }\n                break;\n\n            case AlienState.Attacking:\n                if (!_isAttacking)\n                {\n                    _currentState = AlienState.Chasing;\n                }\n                break;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (_currentState == AlienState.Chasing && _player != null && !_isAttacking)\n        {\n            Vector3 direction = (_player.position - transform.position).normalized;\n            direction.y = 0f;\n\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            \n            if (direction != Vector3.zero)\n            {\n                transform.rotation = Quaternion.LookRotation(direction);\n            }\n        }\n    }\n\n    private void UpdateTentacles()\n    {\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 currentPos = _tentacles[i].transform.position;\n            Vector3 targetPos = _tentacles[i].targetPosition;\n\n            _tentacles[i].velocity += (targetPos - currentPos) * _tentacleSpeed * Time.deltaTime;\n            _tentacles[i].velocity *= _tentacles[i].damping;\n\n            _tentacles[i].transform.position = currentPos + _tentacles[i].velocity * Time.deltaTime;\n\n            if (i > 0 && _tentacles[i - 1].transform != null)\n            {\n                Vector3 parentPos = _tentacles[i - 1].transform.position;\n                Vector3 currentSegmentPos = _tentacles[i].transform.position;\n                Vector3 direction = (currentSegmentPos - parentPos).normalized;\n                \n                _tentacles[i].transform.position = parentPos + direction * _segmentDistance;\n            }\n        }\n    }\n\n    private void StartTentacleAttack()\n    {\n        if (_isAttacking || _player == null) return;\n\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnAttack?.Invoke();\n        \n        if (_attackSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_attackSound);\n\n        if (_currentAttackCoroutine != null)\n            StopCoroutine(_currentAttackCoroutine);\n\n        _currentAttackCoroutine = StartCoroutine(TentacleAttackSequence());\n    }\n\n    private IEnumerator TentacleAttackSequence()\n    {\n        Vector3 playerPosition = _player.position;\n        \n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 attackPosition = playerPosition + Random.insideUnitSphere * 2f;\n            attackPosition.y = playerPosition.y;\n\n            StartCoroutine(MoveTentacleToPosition(i, attackPosition, 0.5f));\n            \n            yield return new WaitForSeconds(0.1f);\n        }\n\n        if (_attackEffect != null)\n            _attackEffect.Play();\n\n        yield return new WaitForSeconds(0.5f);\n\n        CheckTentacleHit(playerPosition);\n\n        yield return new WaitForSeconds(0.3f);\n\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform == null) continue;\n\n            Vector3 restPosition = transform.position + transform.forward * (i + 1) * _segmentDistance;\n            StartCoroutine(MoveTentacleToPosition(i, restPosition, 0.8f));\n        }\n\n        yield return new WaitForSeconds(0.8f);\n\n        _isAttacking = false;\n    }\n\n    private IEnumerator MoveTentacleToPosition(int tentacleIndex, Vector3 targetPosition, float duration)\n    {\n        if (tentacleIndex >= _tentacles.Count || _tentacles[tentacleIndex].transform == null)\n            yield break;\n\n        Vector3 startPosition = _tentacles[tentacleIndex].targetPosition;\n        float elapsed = 0f;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            float curveValue = _tentacleMoveCurve.Evaluate(t);\n\n            _tentacles[tentacleIndex].targetPosition = Vector3.Lerp(startPosition, targetPosition, curveValue);\n            yield return null;\n        }\n\n        _tentacles[tentacleIndex].targetPosition = targetPosition;\n    }\n\n    private void CheckTentacleHit(Vector3 attackCenter)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(attackCenter, 3f, _playerLayer);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                Rigidbody playerRb = hit.GetComponent<Rigidbody>();\n                if (playerRb != null)\n                {\n                    Vector3 knockbackDirection = (hit.transform.position - transform.position).normalized;\n                    playerRb.AddForce(knockbackDirection * 500f + Vector3.up * 200f);\n                }\n\n                MonoBehaviour[] playerScripts = hit.GetComponents<MonoBehaviour>();\n                foreach (MonoBehaviour script in playerScripts)\n                {\n                    script.SendMessage(\"TakeDamage\", _tentacleDamage, SendMessageOptions.DontRequireReceiver);\n                }\n            }\n        }\n    }\n\n    private void HandleAnimations()\n    {\n        if (_animator == null) return;\n\n        _animator.SetBool(\"IsChasing\", _currentState == AlienState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _isAttacking);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n\n        _health -= damage;\n\n        if (_hurtSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_hurtSound);\n\n        if (_health <= 0f)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        if (_isDead) return;\n\n        _isDead = true;\n        _currentState = AlienState.Dead;\n\n        if (_currentAttackCoroutine != null)\n        {\n            StopCoroutine(_currentAttackCoroutine);\n            _isAttacking = false;\n        }\n\n        if (_deathSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_deathSound);\n\n        if (_deathEffect != null)\n            _deathEffect.Play();\n\n        OnDeath?.Invoke();\n\n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n\n        Collider[] colliders = GetComponents<Collider>();\n        foreach (Collider col in colliders)\n        {\n            col.enabled = false;\n        }\n\n        StartCoroutine(DestroyAfterDelay(3f));\n    }\n\n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            if (_currentState == AlienState.Idle)\n            {\n                _currentState = AlienState.Chasing;\n                OnPlayerDetected?.Invoke();\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _tentacleRange);\n\n        for (int i = 0; i < _tentacles.Count; i++)\n        {\n            if (_tentacles[i].transform != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawWireSphere(_tentacles[i].transform.position, 0.5f);\n                \n                if (i > 0 && _tentacles[i - 1].transform != null)\n                {\n                    Gizmos.DrawLine(_tentacles[i - 1].transform.position, _tentacles[i].transform.position);\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Surfboard\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"buoyancyForce\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"stabilityForce\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"waveHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"waveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"tiltSensitivity\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_on_waves\",\n      \"trigger\": \"always while on water surface\",\n      \"actions\": [\n        {\n          \"action\": \"calculate wave height at current position using sine wave pattern\"\n        },\n        {\n          \"action\": \"apply upward buoyancy force to match wave height\"\n        },\n        {\n          \"action\": \"bob up and down following wave motion\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wave_physics\",\n      \"trigger\": \"when wave passes underneath\",\n      \"actions\": [\n        {\n          \"action\": \"tilt forward when going up wave\"\n        },\n        {\n          \"action\": \"tilt backward when going down wave\"\n        },\n        {\n          \"action\": \"apply forward momentum from wave energy\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stability_control\",\n      \"trigger\": \"when tilting beyond normal wave motion\",\n      \"actions\": [\n        {\n          \"action\": \"apply counter-rotation force to prevent flipping\"\n        },\n        {\n          \"action\": \"gradually return to upright position\"\n        },\n        {\n          \"action\": \"dampen excessive rolling motion\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wave_interaction\",\n      \"trigger\": \"continuously while in water\",\n      \"actions\": [\n        {\n          \"action\": \"move horizontally with wave direction\"\n        },\n        {\n          \"action\": \"create splash effects when hitting wave crests\"\n        },\n        {\n          \"action\": \"adjust rotation to follow wave surface angle\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class SurfboardController : MonoBehaviour\n{\n    [Header(\"Surfboard Physics\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _turnSpeed = 120f;\n    [SerializeField] private float _stabilityForce = 10f;\n    [SerializeField] private float _buoyancyForce = 20f;\n    \n    [Header(\"Wave Interaction\")]\n    [SerializeField] private float _waveHeight = 2f;\n    [SerializeField] private float _waveSpeed = 1f;\n    [SerializeField] private float _waveLength = 10f;\n    [SerializeField] private LayerMask _waterLayer = 1;\n    \n    [Header(\"Tilt and Balance\")]\n    [SerializeField] private float _maxTiltAngle = 30f;\n    [SerializeField] private float _tiltSpeed = 2f;\n    [SerializeField] private float _balanceRecoverySpeed = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _ridingSound;\n    \n    private Rigidbody _rigidbody;\n    private Transform _playerTransform;\n    private Vector3 _initialPosition;\n    private float _currentSpeed;\n    private float _currentTilt;\n    private bool _isOnWave;\n    private bool _isPlayerOnBoard;\n    private float _waveOffset;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        _initialPosition = transform.position;\n        _waveOffset = Random.Range(0f, Mathf.PI * 2f);\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.spatialBlend = 1f;\n        _audioSource.volume = 0.5f;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWavePosition();\n        HandleTilt();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyMovement();\n        ApplyStability();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_isPlayerOnBoard) return;\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        // Apply turning\n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            transform.Rotate(0, horizontal * _turnSpeed * Time.deltaTime, 0);\n            _currentTilt = Mathf.Lerp(_currentTilt, horizontal * _maxTiltAngle, _tiltSpeed * Time.deltaTime);\n        }\n        else\n        {\n            _currentTilt = Mathf.Lerp(_currentTilt, 0f, _balanceRecoverySpeed * Time.deltaTime);\n        }\n        \n        // Apply forward movement\n        if (vertical > 0.1f)\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, _maxSpeed * vertical, _acceleration * Time.deltaTime);\n        }\n        else\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0f, _acceleration * 0.5f * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateWavePosition()\n    {\n        float waveY = Mathf.Sin((transform.position.x / _waveLength + Time.time * _waveSpeed + _waveOffset)) * _waveHeight;\n        float targetY = _initialPosition.y + waveY;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position + Vector3.up * 5f, Vector3.down, out hit, 10f, _waterLayer))\n        {\n            targetY = hit.point.y + 0.5f;\n            _isOnWave = true;\n        }\n        else\n        {\n            _isOnWave = false;\n        }\n        \n        Vector3 targetPosition = new Vector3(transform.position.x, targetY, transform.position.z);\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 2f);\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isOnWave)\n        {\n            Vector3 buoyancy = Vector3.up * _buoyancyForce;\n            _rigidbody.AddForce(buoyancy, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        if (_isPlayerOnBoard && _currentSpeed > 0.1f)\n        {\n            Vector3 forward = transform.forward * _currentSpeed;\n            _rigidbody.AddForce(forward, ForceMode.Force);\n            \n            // Limit max velocity\n            if (_rigidbody.velocity.magnitude > _maxSpeed)\n            {\n                _rigidbody.velocity = _rigidbody.velocity.normalized * _maxSpeed;\n            }\n        }\n    }\n    \n    private void ApplyStability()\n    {\n        Vector3 stabilityTorque = Vector3.zero;\n        \n        // Roll stability\n        float rollAngle = Vector3.Angle(Vector3.up, transform.up);\n        if (rollAngle > 5f)\n        {\n            Vector3 rollCorrection = Vector3.Cross(transform.up, Vector3.up);\n            stabilityTorque += rollCorrection * _stabilityForce;\n        }\n        \n        // Pitch stability\n        Vector3 forwardProjected = Vector3.ProjectOnPlane(transform.forward, Vector3.up);\n        float pitchAngle = Vector3.Angle(transform.forward, forwardProjected);\n        if (pitchAngle > 10f)\n        {\n            Vector3 pitchCorrection = Vector3.Cross(transform.forward, forwardProjected);\n            stabilityTorque += pitchCorrection * _stabilityForce * 0.5f;\n        }\n        \n        _rigidbody.AddTorque(stabilityTorque, ForceMode.Force);\n    }\n    \n    private void HandleTilt()\n    {\n        Vector3 currentRotation = transform.eulerAngles;\n        currentRotation.z = _currentTilt;\n        transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(currentRotation), Time.deltaTime * _tiltSpeed);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_isPlayerOnBoard && _currentSpeed > 1f && _ridingSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _ridingSound)\n            {\n                _audioSource.clip = _ridingSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            _audioSource.pitch = Mathf.Lerp(0.8f, 1.5f, _currentSpeed / _maxSpeed);\n        }\n        else if (_audioSource.isPlaying && _audioSource.clip == _ridingSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerOnBoard = true;\n            _playerTransform = other.transform;\n            \n            // Position player on surfboard\n            other.transform.SetParent(transform);\n            other.transform.localPosition = Vector3.up * 0.5f;\n            \n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerOnBoard = false;\n            \n            if (_playerTransform != null)\n            {\n                _playerTransform.SetParent(null);\n                _playerTransform = null;\n            }\n            \n            _currentSpeed = 0f;\n            _currentTilt = 0f;\n            \n            if (_audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, 2f);\n        \n        Gizmos.color = Color.cyan;\n        for (int i = 0; i < 20; i++)\n        {\n            float x = transform.position.x + (i - 10) * 2f;\n            float waveY = Mathf.Sin((x / _waveLength + Time.time * _waveSpeed + _waveOffset)) * _waveHeight;\n            Vector3 wavePoint = new Vector3(x, _initialPosition.y + waveY, transform.position.z);\n            Gizmos.DrawWireSphere(wavePoint, 0.2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HackableTerminal\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isHacked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hackingTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"accessLevel\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"terminalData\",\n      \"type\": \"string\",\n      \"default\": \"SYSTEM_LOCKED\"\n    },\n    {\n      \"name\": \"hackingProgress\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"isBeingHacked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"requiredHackingSkill\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"lockoutTime\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isLockedOut\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"display_locked_interface\",\n      \"trigger\": \"when player approaches terminal and terminal is not hacked\",\n      \"actions\": [\n        {\n          \"action\": \"show locked terminal interface with blinking cursor\"\n        },\n        {\n          \"action\": \"display access denied message\"\n        },\n        {\n          \"action\": \"play electronic beeping sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_hacking_process\",\n      \"trigger\": \"when player interacts with terminal and has sufficient hacking skill\",\n      \"actions\": [\n        {\n          \"action\": \"begin hacking progress timer\"\n        },\n        {\n          \"action\": \"show hacking interface with progress bar\"\n        },\n        {\n          \"action\": \"play hacking sound effects\"\n        },\n        {\n          \"action\": \"set terminal as being hacked\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_hacking_progress\",\n      \"trigger\": \"while terminal is being hacked\",\n      \"actions\": [\n        {\n          \"action\": \"increase hacking progress over time\"\n        },\n        {\n          \"action\": \"update progress bar display\"\n        },\n        {\n          \"action\": \"show scrolling code text effect\"\n        },\n        {\n          \"action\": \"play continuous typing sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_successful_hack\",\n      \"trigger\": \"when hacking progress reaches completion\",\n      \"actions\": [\n        {\n          \"action\": \"set terminal as successfully hacked\"\n        },\n        {\n          \"action\": \"unlock terminal access\"\n        },\n        {\n          \"action\": \"display access granted message\"\n        },\n        {\n          \"action\": \"show terminal data and files\"\n        },\n        {\n          \"action\": \"play success confirmation sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_hacking_interruption\",\n      \"trigger\": \"when player moves away during hacking process\",\n      \"actions\": [\n        {\n          \"action\": \"reset hacking progress to zero\"\n        },\n        {\n          \"action\": \"hide hacking interface\"\n        },\n        {\n          \"action\": \"return terminal to locked state\"\n        },\n        {\n          \"action\": \"stop hacking sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"display_hacked_interface\",\n      \"trigger\": \"when player approaches successfully hacked terminal\",\n      \"actions\": [\n        {\n          \"action\": \"show unlocked terminal interface\"\n        },\n        {\n          \"action\": \"display available data files\"\n        },\n        {\n          \"action\": \"allow file browsing and data extraction\"\n        },\n        {\n          \"action\": \"show green access indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"trigger_security_lockout\",\n      \"trigger\": \"when hacking fails or player lacks required skill\",\n      \"actions\": [\n        {\n          \"action\": \"activate security lockout mode\"\n        },\n        {\n          \"action\": \"display warning message\"\n        },\n        {\n          \"action\": \"disable terminal interaction temporarily\"\n        },\n        {\n          \"action\": \"play alarm sound effect\"\n        },\n        {\n          \"action\": \"start lockout countdown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_security_lockout\",\n      \"trigger\": \"when lockout timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal terminal function\"\n        },\n        {\n          \"action\": \"allow new hacking attempts\"\n        },\n        {\n          \"action\": \"clear warning messages\"\n        },\n        {\n          \"action\": \"reset terminal to locked state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class HackableTerminal : MonoBehaviour\n{\n    [System.Serializable]\n    public class TerminalFile\n    {\n        public string fileName;\n        public string content;\n        public bool isLocked;\n        public string password;\n    }\n\n    [System.Serializable]\n    public class HackingPuzzle\n    {\n        public string targetWord;\n        public List<string> decoyWords;\n        public int attempts;\n    }\n\n    [Header(\"Terminal UI\")]\n    [SerializeField] private Canvas _terminalCanvas;\n    [SerializeField] private Text _terminalDisplay;\n    [SerializeField] private InputField _inputField;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Hacking Interface\")]\n    [SerializeField] private GameObject _hackingPanel;\n    [SerializeField] private Text _hackingDisplay;\n    [SerializeField] private Text _attemptsText;\n    [SerializeField] private Transform _wordContainer;\n    [SerializeField] private Button _wordButtonPrefab;\n\n    [Header(\"Terminal Settings\")]\n    [SerializeField] private float _typewriterSpeed = 0.05f;\n    [SerializeField] private int _maxDisplayLines = 20;\n    [SerializeField] private string _terminalPrompt = \"TERMINAL> \";\n    [SerializeField] private Color _successColor = Color.green;\n    [SerializeField] private Color _errorColor = Color.red;\n    [SerializeField] private Color _normalColor = Color.white;\n\n    [Header(\"Files and Security\")]\n    [SerializeField] private List<TerminalFile> _files = new List<TerminalFile>();\n    [SerializeField] private HackingPuzzle _hackingPuzzle;\n    [SerializeField] private bool _requiresHacking = true;\n    [SerializeField] private float _interactionRange = 3f;\n\n    [Header(\"Events\")]\n    public UnityEvent OnTerminalAccessed;\n    public UnityEvent OnHackingSuccess;\n    public UnityEvent OnHackingFailed;\n    public UnityEvent OnTerminalClosed;\n\n    private List<string> _displayLines = new List<string>();\n    private bool _isPlayerNear = false;\n    private bool _isTerminalOpen = false;\n    private bool _isHacked = false;\n    private bool _isHacking = false;\n    private int _currentAttempts;\n    private Transform _playerTransform;\n    private Coroutine _typewriterCoroutine;\n\n    private Dictionary<string, System.Action<string[]>> _commands;\n\n    private void Start()\n    {\n        InitializeTerminal();\n        InitializeCommands();\n        SetupUI();\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n\n    private void InitializeTerminal()\n    {\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n\n        _currentAttempts = _hackingPuzzle.attempts;\n        \n        if (_files.Count == 0)\n        {\n            _files.Add(new TerminalFile \n            { \n                fileName = \"readme.txt\", \n                content = \"Welcome to the terminal system.\", \n                isLocked = false \n            });\n            _files.Add(new TerminalFile \n            { \n                fileName = \"secure.dat\", \n                content = \"Classified information stored here.\", \n                isLocked = true, \n                password = \"admin123\" \n            });\n        }\n    }\n\n    private void InitializeCommands()\n    {\n        _commands = new Dictionary<string, System.Action<string[]>>\n        {\n            { \"help\", ShowHelp },\n            { \"ls\", ListFiles },\n            { \"dir\", ListFiles },\n            { \"cat\", ReadFile },\n            { \"type\", ReadFile },\n            { \"clear\", ClearScreen },\n            { \"cls\", ClearScreen },\n            { \"hack\", StartHacking },\n            { \"login\", AttemptLogin },\n            { \"exit\", CloseTerminal },\n            { \"quit\", CloseTerminal }\n        };\n    }\n\n    private void SetupUI()\n    {\n        if (_inputField != null)\n        {\n            _inputField.onEndEdit.AddListener(ProcessCommand);\n        }\n\n        if (_closeButton != null)\n        {\n            _closeButton.onClick.AddListener(CloseTerminal);\n        }\n\n        AddLine(\"SYSTEM INITIALIZED\");\n        AddLine(\"Type 'help' for available commands\");\n        AddLine(\"\");\n    }\n\n    private void CheckPlayerProximity()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n\n        if (_playerTransform != null)\n        {\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            bool wasNear = _isPlayerNear;\n            _isPlayerNear = distance <= _interactionRange;\n\n            if (_isPlayerNear && !wasNear)\n            {\n                ShowInteractionPrompt();\n            }\n            else if (!_isPlayerNear && wasNear)\n            {\n                HideInteractionPrompt();\n            }\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (_isPlayerNear && Input.GetKeyDown(KeyCode.E) && !_isTerminalOpen)\n        {\n            OpenTerminal();\n        }\n        else if (_isTerminalOpen && Input.GetKeyDown(KeyCode.Escape))\n        {\n            CloseTerminal();\n        }\n    }\n\n    private void ShowInteractionPrompt()\n    {\n        // This would typically show UI prompt - implement based on your UI system\n        Debug.Log(\"Press E to access terminal\");\n    }\n\n    private void HideInteractionPrompt()\n    {\n        // Hide interaction prompt\n    }\n\n    private void OpenTerminal()\n    {\n        if (_requiresHacking && !_isHacked)\n        {\n            StartHackingSequence();\n            return;\n        }\n\n        _isTerminalOpen = true;\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(true);\n\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n\n        if (_inputField != null)\n        {\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n\n        OnTerminalAccessed?.Invoke();\n        AddLine(\"Terminal access granted\");\n        AddLine(\"\");\n    }\n\n    private void CloseTerminal()\n    {\n        _isTerminalOpen = false;\n        _isHacking = false;\n\n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n\n        OnTerminalClosed?.Invoke();\n    }\n\n    private void ProcessCommand(string input)\n    {\n        if (string.IsNullOrEmpty(input) || _isHacking)\n            return;\n\n        AddLine(_terminalPrompt + input);\n        \n        string[] parts = input.ToLower().Split(' ');\n        string command = parts[0];\n\n        if (_commands.ContainsKey(command))\n        {\n            _commands[command](parts);\n        }\n        else\n        {\n            AddLine(\"Unknown command: \" + command, _errorColor);\n            AddLine(\"Type 'help' for available commands\");\n        }\n\n        AddLine(\"\");\n        \n        if (_inputField != null)\n        {\n            _inputField.text = \"\";\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n    }\n\n    private void ShowHelp(string[] args)\n    {\n        AddLine(\"Available commands:\");\n        AddLine(\"help - Show this help message\");\n        AddLine(\"ls/dir - List files\");\n        AddLine(\"cat/type [filename] - Read file content\");\n        AddLine(\"clear/cls - Clear screen\");\n        if (!_isHacked && _requiresHacking)\n            AddLine(\"hack - Start hacking sequence\");\n        AddLine(\"login [password] - Login with password\");\n        AddLine(\"exit/quit - Close terminal\");\n    }\n\n    private void ListFiles(string[] args)\n    {\n        AddLine(\"Files:\");\n        foreach (var file in _files)\n        {\n            string status = file.isLocked ? \" [LOCKED]\" : \"\";\n            AddLine(\"  \" + file.fileName + status);\n        }\n    }\n\n    private void ReadFile(string[] args)\n    {\n        if (args.Length < 2)\n        {\n            AddLine(\"Usage: cat [filename]\", _errorColor);\n            return;\n        }\n\n        string filename = args[1];\n        var file = _files.FirstOrDefault(f => f.fileName.ToLower() == filename.ToLower());\n\n        if (file == null)\n        {\n            AddLine(\"File not found: \" + filename, _errorColor);\n            return;\n        }\n\n        if (file.isLocked)\n        {\n            AddLine(\"Access denied: File is locked\", _errorColor);\n            return;\n        }\n\n        AddLine(\"--- \" + file.fileName + \" ---\");\n        string[] lines = file.content.Split('\\n');\n        foreach (string line in lines)\n        {\n            AddLine(line);\n        }\n        AddLine(\"--- End of file ---\");\n    }\n\n    private void ClearScreen(string[] args)\n    {\n        _displayLines.Clear();\n        UpdateDisplay();\n    }\n\n    private void StartHacking(string[] args)\n    {\n        if (_isHacked)\n        {\n            AddLine(\"System already compromised\", _successColor);\n            return;\n        }\n\n        StartHackingSequence();\n    }\n\n    private void AttemptLogin(string[] args)\n    {\n        if (args.Length < 2)\n        {\n            AddLine(\"Usage: login [password]\", _errorColor);\n            return;\n        }\n\n        string password = args[1];\n        var lockedFile = _files.FirstOrDefault(f => f.isLocked && f.password == password);\n\n        if (lockedFile != null)\n        {\n            lockedFile.isLocked = false;\n            AddLine(\"File unlocked: \" + lockedFile.fileName, _successColor);\n        }\n        else\n        {\n            AddLine(\"Invalid password\", _errorColor);\n        }\n    }\n\n    private void StartHackingSequence()\n    {\n        _isHacking = true;\n        _currentAttempts = _hackingPuzzle.attempts;\n\n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(true);\n\n        SetupHackingPuzzle();\n    }\n\n    private void SetupHackingPuzzle()\n    {\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"BREACH PROTOCOL INITIATED\\nSelect the correct access code:\";\n        }\n\n        UpdateAttemptsDisplay();\n        CreateWordButtons();\n    }\n\n    private void CreateWordButtons()\n    {\n        if (_wordContainer == null || _wordButtonPrefab == null)\n            return;\n\n        // Clear existing buttons\n        foreach (Transform child in _wordContainer)\n        {\n            Destroy(child.gameObject);\n        }\n\n        // Create list of all words (target + decoys)\n        List<string> allWords = new List<string>(_hackingPuzzle.decoyWords);\n        allWords.Add(_hackingPuzzle.targetWord);\n        \n        // Shuffle the words\n        for (int i = 0; i < allWords.Count; i++)\n        {\n            string temp = allWords[i];\n            int randomIndex = Random.Range(i, allWords.Count);\n            allWords[i] = allWords[randomIndex];\n            allWords[randomIndex] = temp;\n        }\n\n        // Create buttons\n        foreach (string word in allWords)\n        {\n            Button wordButton = Instantiate(_wordButtonPrefab, _wordContainer);\n            Text buttonText = wordButton.GetComponentInChildren<Text>();\n            if (buttonText != null)\n                buttonText.text = word;\n\n            wordButton.onClick.AddListener(() => OnWordSelected(word));\n        }\n    }\n\n    private void OnWordSelected(string selectedWord)\n    {\n        if (selectedWord == _hackingPuzzle.targetWord)\n        {\n            HackingSuccess();\n        }\n        else\n        {\n            _currentAttempts--;\n            UpdateAttemptsDisplay();\n\n            if (_currentAttempts <= 0)\n            {\n                HackingFailed();\n            }\n            else\n            {\n                if (_hackingDisplay != null)\n                {\n                    _hackingDisplay.text = \"ACCESS DENIED\\nIncorrect code. Try again.\";\n                }\n            }\n        }\n    }\n\n    private void HackingSuccess()\n    {\n        _isHacked = true;\n        _isHacking = false;\n\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"ACCESS GRANTED\\nSystem compromised successfully!\";\n        }\n\n        // Unlock all files\n        foreach (var file in _files)\n        {\n            file.isLocked = false;\n        }\n\n        OnHackingSuccess?.Invoke();\n        \n        StartCoroutine(DelayedOpenTerminal());\n    }\n\n    private void HackingFailed()\n    {\n        _isHacking = false;\n\n        if (_hackingDisplay != null)\n        {\n            _hackingDisplay.text = \"SECURITY BREACH DETECTED\\nTerminal locked down.\";\n        }\n\n        OnHackingFailed?.Invoke();\n        \n        StartCoroutine(DelayedCloseTerminal());\n    }\n\n    private IEnumerator DelayedOpenTerminal()\n    {\n        yield return new WaitForSeconds(2f);\n        \n        if (_hackingPanel != null)\n            _hackingPanel.SetActive(false);\n        \n        OpenTerminal();\n    }\n\n    private IEnumerator DelayedCloseTerminal()\n    {\n        yield return new WaitForSeconds(2f);\n        CloseTerminal();\n    }\n\n    private void UpdateAttemptsDisplay()\n    {\n        if (_attemptsText != null)\n        {\n            _attemptsText.text = \"Attempts remaining: \" + _currentAttempts;\n        }\n    }\n\n    private void AddLine(string text, Color? color = null)\n    {\n        _displayLines.Add(text);\n        \n        if (_displayLines.Count > _maxDisplayLines)\n        {\n            _displayLines.RemoveAt(0);\n        }\n\n        if (_typewriterCoroutine != null)\n        {\n            StopCoroutine(_typewriterCoroutine);\n        }\n\n        _typewriterCoroutine = StartCoroutine(TypewriterEffect(text, color ?? _normalColor));\n    }\n\n    private IEnumerator TypewriterEffect(string text, Color color)\n    {\n        UpdateDisplay();\n        \n        if (_terminalDisplay != null)\n        {\n            _terminalDisplay.color = color;\n        }\n\n        yield return new WaitForSeconds(_typewriterSpeed);\n        \n        if (_scrollRect != null)\n        {\n            Canvas.ForceUpdateCanvases();\n            _scrollRect.verticalNormalizedPosition = 0f;\n        }\n    }\n\n    private void UpdateDisplay()\n    {\n        if (_terminalDisplay != null)\n        {\n            _terminalDisplay.text = string.Join(\"\\n\", _display"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SlidingTilePuzzle\",\n  \"components\": [\n    \"Transform\",\n    \"Collider2D\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"gridSize\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"tileSize\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"slideSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isSliding\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"emptyPosition\",\n      \"type\": \"Vector2Int\",\n      \"default\": \"2,2\"\n    },\n    {\n      \"name\": \"currentPosition\",\n      \"type\": \"Vector2Int\",\n      \"default\": \"0,0\"\n    },\n    {\n      \"name\": \"targetPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"0,0,0\"\n    },\n    {\n      \"name\": \"shuffleCount\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isPuzzleSolved\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_puzzle\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"create grid of numbered tiles\"\n        },\n        {\n          \"action\": \"position tiles in correct order\"\n        },\n        {\n          \"action\": \"remove bottom right tile to create empty space\"\n        },\n        {\n          \"action\": \"shuffle tiles randomly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_tile_click\",\n      \"trigger\": \"when tile is clicked by player\",\n      \"actions\": [\n        {\n          \"action\": \"check if clicked tile is adjacent to empty space\"\n        },\n        {\n          \"action\": \"if adjacent and not currently sliding then start sliding tile toward empty space\"\n        }\n      ]\n    },\n    {\n      \"name\": \"slide_tile\",\n      \"trigger\": \"when tile should move to empty space\",\n      \"actions\": [\n        {\n          \"action\": \"set sliding state to true\"\n        },\n        {\n          \"action\": \"smoothly move tile from current position to empty space position\"\n        },\n        {\n          \"action\": \"update grid positions when movement completes\"\n        },\n        {\n          \"action\": \"set sliding state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_puzzle_completion\",\n      \"trigger\": \"when any tile finishes moving\",\n      \"actions\": [\n        {\n          \"action\": \"verify all tiles are in correct numerical order\"\n        },\n        {\n          \"action\": \"if puzzle is solved then display victory message\"\n        },\n        {\n          \"action\": \"if puzzle is solved then disable further tile interactions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shuffle_puzzle\",\n      \"trigger\": \"when shuffle button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"perform random valid moves to scramble tiles\"\n        },\n        {\n          \"action\": \"ensure puzzle remains solvable after shuffling\"\n        },\n        {\n          \"action\": \"reset solved state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"validate_move\",\n      \"trigger\": \"when checking if tile can move\",\n      \"actions\": [\n        {\n          \"action\": \"determine if tile shares row or column with empty space\"\n        },\n        {\n          \"action\": \"confirm tile is exactly one space away from empty position\"\n        },\n        {\n          \"action\": \"verify no other tiles are currently sliding\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SlidingTilePuzzle : MonoBehaviour\n{\n    [System.Serializable]\n    public class PuzzleTile\n    {\n        public GameObject tileObject;\n        public int correctPosition;\n        public int currentPosition;\n        public bool isEmpty;\n        \n        public PuzzleTile(GameObject obj, int correct, int current, bool empty = false)\n        {\n            tileObject = obj;\n            correctPosition = correct;\n            currentPosition = current;\n            isEmpty = empty;\n        }\n    }\n\n    [Header(\"Puzzle Configuration\")]\n    [SerializeField] private int _gridSize = 3;\n    [SerializeField] private float _tileSize = 1f;\n    [SerializeField] private float _tileSpacing = 0.1f;\n    [SerializeField] private float _slideSpeed = 5f;\n    \n    [Header(\"Tile Setup\")]\n    [SerializeField] private GameObject _tilePrefab;\n    [SerializeField] private Transform _puzzleContainer;\n    [SerializeField] private Material _tileMaterial;\n    [SerializeField] private Material _emptyTileMaterial;\n    \n    [Header(\"Input\")]\n    [SerializeField] private LayerMask _tileLayerMask = 1;\n    [SerializeField] private Camera _puzzleCamera;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _slideSFX;\n    [SerializeField] private AudioClip _completeSFX;\n    [SerializeField] private AudioClip _invalidMoveSFX;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Button _shuffleButton;\n    [SerializeField] private Button _solveButton;\n    [SerializeField] private Text _movesText;\n    [SerializeField] private Text _statusText;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPuzzleComplete;\n    public UnityEvent OnTileSlide;\n    public UnityEvent OnInvalidMove;\n\n    private PuzzleTile[,] _grid;\n    private List<PuzzleTile> _tiles;\n    private Vector2Int _emptyPosition;\n    private int _totalTiles;\n    private int _moveCount;\n    private bool _isSliding;\n    private bool _isPuzzleComplete;\n    private bool _isShuffling;\n\n    private void Start()\n    {\n        InitializePuzzle();\n        SetupUI();\n        \n        if (_puzzleCamera == null)\n            _puzzleCamera = Camera.main;\n    }\n\n    private void Update()\n    {\n        if (!_isSliding && !_isShuffling && !_isPuzzleComplete)\n        {\n            HandleInput();\n        }\n    }\n\n    private void InitializePuzzle()\n    {\n        _totalTiles = _gridSize * _gridSize;\n        _grid = new PuzzleTile[_gridSize, _gridSize];\n        _tiles = new List<PuzzleTile>();\n        _moveCount = 0;\n        _isPuzzleComplete = false;\n        \n        CreateTiles();\n        PositionTiles();\n        ShufflePuzzle();\n    }\n\n    private void CreateTiles()\n    {\n        if (_puzzleContainer == null)\n        {\n            GameObject container = new GameObject(\"Puzzle Container\");\n            _puzzleContainer = container.transform;\n        }\n\n        // Clear existing tiles\n        foreach (Transform child in _puzzleContainer)\n        {\n            if (Application.isPlaying)\n                Destroy(child.gameObject);\n            else\n                DestroyImmediate(child.gameObject);\n        }\n\n        _tiles.Clear();\n\n        // Create tiles (leave last position empty)\n        for (int i = 0; i < _totalTiles - 1; i++)\n        {\n            GameObject tileObj = Instantiate(_tilePrefab, _puzzleContainer);\n            tileObj.name = $\"Tile_{i + 1}\";\n            \n            // Add number text\n            Text numberText = tileObj.GetComponentInChildren<Text>();\n            if (numberText == null)\n            {\n                GameObject textObj = new GameObject(\"Number\");\n                textObj.transform.SetParent(tileObj.transform);\n                textObj.transform.localPosition = Vector3.zero;\n                numberText = textObj.AddComponent<Text>();\n                numberText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n                numberText.fontSize = 24;\n                numberText.alignment = TextAnchor.MiddleCenter;\n                numberText.color = Color.black;\n            }\n            numberText.text = (i + 1).ToString();\n\n            // Ensure collider exists\n            if (tileObj.GetComponent<Collider>() == null)\n            {\n                BoxCollider collider = tileObj.AddComponent<BoxCollider>();\n                collider.size = Vector3.one * _tileSize;\n            }\n\n            // Set material\n            Renderer renderer = tileObj.GetComponent<Renderer>();\n            if (renderer != null && _tileMaterial != null)\n                renderer.material = _tileMaterial;\n\n            PuzzleTile tile = new PuzzleTile(tileObj, i, i);\n            _tiles.Add(tile);\n        }\n\n        // Create empty tile (invisible)\n        GameObject emptyObj = new GameObject(\"Empty Tile\");\n        emptyObj.transform.SetParent(_puzzleContainer);\n        if (_emptyTileMaterial != null)\n        {\n            MeshRenderer emptyRenderer = emptyObj.AddComponent<MeshRenderer>();\n            emptyRenderer.material = _emptyTileMaterial;\n            MeshFilter emptyFilter = emptyObj.AddComponent<MeshFilter>();\n            emptyFilter.mesh = Resources.GetBuiltinResource<Mesh>(\"Cube\");\n            emptyObj.transform.localScale = Vector3.one * _tileSize * 0.1f; // Very small\n        }\n\n        PuzzleTile emptyTile = new PuzzleTile(emptyObj, _totalTiles - 1, _totalTiles - 1, true);\n        _tiles.Add(emptyTile);\n        _emptyPosition = new Vector2Int(_gridSize - 1, _gridSize - 1);\n    }\n\n    private void PositionTiles()\n    {\n        float startX = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n        float startZ = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n\n        for (int i = 0; i < _tiles.Count; i++)\n        {\n            int row = i / _gridSize;\n            int col = i % _gridSize;\n            \n            Vector3 position = new Vector3(\n                startX + col * (_tileSize + _tileSpacing),\n                0,\n                startZ + row * (_tileSize + _tileSpacing)\n            );\n\n            _tiles[i].tileObject.transform.localPosition = position;\n            _tiles[i].currentPosition = i;\n            _grid[row, col] = _tiles[i];\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _puzzleCamera.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n\n            if (Physics.Raycast(ray, out hit, Mathf.Infinity, _tileLayerMask))\n            {\n                PuzzleTile clickedTile = GetTileFromGameObject(hit.collider.gameObject);\n                if (clickedTile != null && !clickedTile.isEmpty)\n                {\n                    TryMoveTile(clickedTile);\n                }\n            }\n        }\n    }\n\n    private PuzzleTile GetTileFromGameObject(GameObject obj)\n    {\n        return _tiles.FirstOrDefault(tile => tile.tileObject == obj);\n    }\n\n    private void TryMoveTile(PuzzleTile tile)\n    {\n        Vector2Int tileGridPos = GetGridPosition(tile.currentPosition);\n        Vector2Int emptyGridPos = _emptyPosition;\n\n        // Check if tile is adjacent to empty space\n        int distance = Mathf.Abs(tileGridPos.x - emptyGridPos.x) + Mathf.Abs(tileGridPos.y - emptyGridPos.y);\n        \n        if (distance == 1)\n        {\n            StartCoroutine(SlideTile(tile, tileGridPos, emptyGridPos));\n        }\n        else\n        {\n            PlayInvalidMoveSound();\n            OnInvalidMove?.Invoke();\n        }\n    }\n\n    private System.Collections.IEnumerator SlideTile(PuzzleTile tile, Vector2Int fromPos, Vector2Int toPos)\n    {\n        _isSliding = true;\n        \n        Vector3 startPosition = tile.tileObject.transform.localPosition;\n        Vector3 targetPosition = GetWorldPosition(toPos);\n        \n        float elapsed = 0f;\n        float duration = 1f / _slideSpeed;\n\n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            tile.tileObject.transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);\n            yield return null;\n        }\n\n        tile.tileObject.transform.localPosition = targetPosition;\n\n        // Update grid\n        _grid[fromPos.y, fromPos.x] = _grid[toPos.y, toPos.x];\n        _grid[toPos.y, toPos.x] = tile;\n        \n        // Update positions\n        tile.currentPosition = toPos.y * _gridSize + toPos.x;\n        _emptyPosition = fromPos;\n\n        _moveCount++;\n        UpdateUI();\n        \n        PlaySlideSound();\n        OnTileSlide?.Invoke();\n        \n        _isSliding = false;\n\n        if (CheckPuzzleComplete())\n        {\n            CompletePuzzle();\n        }\n    }\n\n    private Vector2Int GetGridPosition(int index)\n    {\n        return new Vector2Int(index % _gridSize, index / _gridSize);\n    }\n\n    private Vector3 GetWorldPosition(Vector2Int gridPos)\n    {\n        float startX = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n        float startZ = -(_gridSize - 1) * (_tileSize + _tileSpacing) * 0.5f;\n\n        return new Vector3(\n            startX + gridPos.x * (_tileSize + _tileSpacing),\n            0,\n            startZ + gridPos.y * (_tileSize + _tileSpacing)\n        );\n    }\n\n    private bool CheckPuzzleComplete()\n    {\n        for (int i = 0; i < _tiles.Count; i++)\n        {\n            if (_tiles[i].currentPosition != _tiles[i].correctPosition)\n                return false;\n        }\n        return true;\n    }\n\n    private void CompletePuzzle()\n    {\n        _isPuzzleComplete = true;\n        PlayCompleteSound();\n        OnPuzzleComplete?.Invoke();\n        \n        if (_statusText != null)\n            _statusText.text = \"Puzzle Complete!\";\n    }\n\n    public void ShufflePuzzle()\n    {\n        if (_isSliding) return;\n        \n        StartCoroutine(ShuffleCoroutine());\n    }\n\n    private System.Collections.IEnumerator ShuffleCoroutine()\n    {\n        _isShuffling = true;\n        _isPuzzleComplete = false;\n        _moveCount = 0;\n\n        // Perform random valid moves\n        int shuffleMoves = _gridSize * _gridSize * 10;\n        \n        for (int i = 0; i < shuffleMoves; i++)\n        {\n            List<PuzzleTile> validTiles = GetValidMovableTiles();\n            if (validTiles.Count > 0)\n            {\n                PuzzleTile randomTile = validTiles[Random.Range(0, validTiles.Count)];\n                Vector2Int tilePos = GetGridPosition(randomTile.currentPosition);\n                \n                // Instant move without animation\n                _grid[_emptyPosition.y, _emptyPosition.x] = randomTile;\n                _grid[tilePos.y, tilePos.x] = _tiles.Last(); // empty tile\n                \n                randomTile.currentPosition = _emptyPosition.y * _gridSize + _emptyPosition.x;\n                randomTile.tileObject.transform.localPosition = GetWorldPosition(_emptyPosition);\n                \n                _emptyPosition = tilePos;\n            }\n            \n            if (i % 10 == 0)\n                yield return null; // Yield occasionally to prevent freezing\n        }\n\n        UpdateUI();\n        _isShuffling = false;\n    }\n\n    private List<PuzzleTile> GetValidMovableTiles()\n    {\n        List<PuzzleTile> validTiles = new List<PuzzleTile>();\n        \n        Vector2Int[] directions = { Vector2Int.up, Vector2Int.down, Vector2Int.left, Vector2Int.right };\n        \n        foreach (Vector2Int dir in directions)\n        {\n            Vector2Int checkPos = _emptyPosition + dir;\n            \n            if (checkPos.x >= 0 && checkPos.x < _gridSize && checkPos.y >= 0 && checkPos.y < _gridSize)\n            {\n                PuzzleTile tile = _grid[checkPos.y, checkPos.x];\n                if (tile != null && !tile.isEmpty)\n                {\n                    validTiles.Add(tile);\n                }\n            }\n        }\n        \n        return validTiles;\n    }\n\n    public void SolvePuzzle()\n    {\n        if (_isSliding || _isShuffling) return;\n        \n        StartCoroutine(SolveCoroutine());\n    }\n\n    private System.Collections.IEnumerator SolveCoroutine()\n    {\n        _isShuffling = true;\n\n        // Simple solve: move each tile to correct position\n        for (int i = 0; i < _tiles.Count - 1; i++)\n        {\n            PuzzleTile tile = _tiles[i];\n            Vector2Int targetPos = GetGridPosition(tile.correctPosition);\n            Vector2Int currentPos = GetGridPosition(tile.currentPosition);\n            \n            if (currentPos != targetPos)\n            {\n                // Move tile to correct position instantly\n                _grid[currentPos.y, currentPos.x] = _grid[targetPos.y, targetPos.x];\n                _grid[targetPos.y, targetPos.x] = tile;\n                \n                tile.currentPosition = tile.correctPosition;\n                tile.tileObject.transform.localPosition = GetWorldPosition(targetPos);\n                \n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n\n        _emptyPosition = GetGridPosition(_totalTiles - 1);\n        _moveCount = 0;\n        UpdateUI();\n        CompletePuzzle();\n        \n        _isShuffling = false;\n    }\n\n    private void SetupUI()\n    {\n        if (_shuffleButton != null)\n            _shuffleButton.onClick.AddListener(ShufflePuzzle);\n            \n        if (_solveButton != null)\n            _solveButton.onClick.AddListener(SolvePuzzle);\n            \n        UpdateUI();\n    }\n\n    private void UpdateUI()\n    {\n        if (_movesText != null)\n            _movesText.text = $\"Moves: {_moveCount}\";"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HangingBat\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"flySpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"hangingPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"isHanging\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"flightDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"returnDelay\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_approach\",\n      \"trigger\": \"when player enters detection range while bat is hanging\",\n      \"actions\": [\n        {\n          \"action\": \"play wing flapping sound\"\n        },\n        {\n          \"action\": \"set hanging state to false\"\n        },\n        {\n          \"action\": \"start flying away from player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fly_erratically\",\n      \"trigger\": \"when bat is not hanging\",\n      \"actions\": [\n        {\n          \"action\": \"move in random zigzag pattern\"\n        },\n        {\n          \"action\": \"maintain flight speed\"\n        },\n        {\n          \"action\": \"avoid walls and obstacles\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_hanging\",\n      \"trigger\": \"when flight duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"fly back toward original hanging position\"\n        },\n        {\n          \"action\": \"slow down as approaching ceiling\"\n        },\n        {\n          \"action\": \"attach to ceiling at hanging position\"\n        },\n        {\n          \"action\": \"set hanging state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_hanging\",\n      \"trigger\": \"when bat is hanging and no player nearby\",\n      \"actions\": [\n        {\n          \"action\": \"remain motionless\"\n        },\n        {\n          \"action\": \"occasionally make small squeaking sounds\"\n        },\n        {\n          \"action\": \"sway slightly as if breathing\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class HangingBat : MonoBehaviour\n{\n    [Header(\"Hanging Behavior\")]\n    [SerializeField] private float _hangHeight = 2f;\n    [SerializeField] private float _swayAmount = 0.5f;\n    [SerializeField] private float _swaySpeed = 1f;\n    [SerializeField] private bool _startHanging = true;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Flight Behavior\")]\n    [SerializeField] private float _flightSpeed = 8f;\n    [SerializeField] private float _flightHeight = 3f;\n    [SerializeField] private float _flightDuration = 5f;\n    [SerializeField] private float _returnDelay = 3f;\n    [SerializeField] private AnimationCurve _flightCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _wingFlapSpeed = 10f;\n    [SerializeField] private float _hangingRotationSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _flutterSound;\n    [SerializeField] private AudioClip _squeakSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _hangingPosition;\n    private bool _isHanging = true;\n    private bool _isFlying = false;\n    private bool _isReturning = false;\n    private float _swayTimer = 0f;\n    private float _flightTimer = 0f;\n    private Vector3 _flightStartPosition;\n    private Vector3 _flightTargetPosition;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _animator = GetComponent<Animator>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.useGravity = false;\n            _rigidbody.isKinematic = true;\n        }\n    }\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _hangingPosition = _originalPosition;\n        \n        if (_startHanging)\n        {\n            SetHangingState(true);\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _swayTimer = Random.Range(0f, Mathf.PI * 2f);\n    }\n    \n    private void Update()\n    {\n        if (_isHanging)\n        {\n            UpdateHangingBehavior();\n            CheckForPlayer();\n        }\n        else if (_isFlying)\n        {\n            UpdateFlightBehavior();\n        }\n        else if (_isReturning)\n        {\n            UpdateReturnBehavior();\n        }\n        \n        UpdateAnimations();\n    }\n    \n    private void UpdateHangingBehavior()\n    {\n        _swayTimer += Time.deltaTime * _swaySpeed;\n        \n        Vector3 swayOffset = new Vector3(\n            Mathf.Sin(_swayTimer) * _swayAmount,\n            0f,\n            Mathf.Cos(_swayTimer * 0.7f) * _swayAmount * 0.5f\n        );\n        \n        transform.position = _hangingPosition + swayOffset;\n        \n        float rotationZ = Mathf.Sin(_swayTimer) * 15f;\n        transform.rotation = Quaternion.Euler(180f, 0f, rotationZ);\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(_playerTag))\n            {\n                StartFlight();\n                break;\n            }\n        }\n    }\n    \n    private void StartFlight()\n    {\n        if (_isFlying || _isReturning) return;\n        \n        _isHanging = false;\n        _isFlying = true;\n        _flightTimer = 0f;\n        \n        _flightStartPosition = transform.position;\n        _flightTargetPosition = _originalPosition + Vector3.up * _flightHeight + \n                               new Vector3(Random.Range(-3f, 3f), 0f, Random.Range(-3f, 3f));\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = false;\n            _rigidbody.useGravity = false;\n        }\n        \n        PlaySound(_flutterSound);\n        \n        if (Random.value < 0.3f)\n        {\n            PlaySound(_squeakSound);\n        }\n    }\n    \n    private void UpdateFlightBehavior()\n    {\n        _flightTimer += Time.deltaTime;\n        float progress = _flightTimer / _flightDuration;\n        \n        if (progress >= 1f)\n        {\n            StartCoroutine(ReturnToHanging());\n            return;\n        }\n        \n        float curveValue = _flightCurve.Evaluate(progress);\n        Vector3 currentTarget = Vector3.Lerp(_flightStartPosition, _flightTargetPosition, curveValue);\n        \n        Vector3 flutterOffset = new Vector3(\n            Mathf.Sin(Time.time * _wingFlapSpeed) * 0.2f,\n            Mathf.Cos(Time.time * _wingFlapSpeed * 1.3f) * 0.1f,\n            Mathf.Sin(Time.time * _wingFlapSpeed * 0.8f) * 0.15f\n        );\n        \n        transform.position = currentTarget + flutterOffset;\n        \n        Vector3 direction = (_flightTargetPosition - _flightStartPosition).normalized;\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 3f);\n        }\n    }\n    \n    private IEnumerator ReturnToHanging()\n    {\n        _isFlying = false;\n        _isReturning = true;\n        \n        yield return new WaitForSeconds(_returnDelay);\n        \n        float returnDuration = 2f;\n        float returnTimer = 0f;\n        Vector3 returnStartPosition = transform.position;\n        \n        while (returnTimer < returnDuration)\n        {\n            returnTimer += Time.deltaTime;\n            float progress = returnTimer / returnDuration;\n            \n            transform.position = Vector3.Lerp(returnStartPosition, _hangingPosition, progress);\n            \n            Quaternion targetRotation = Quaternion.Euler(180f, 0f, 0f);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, progress);\n            \n            yield return null;\n        }\n        \n        SetHangingState(true);\n    }\n    \n    private void UpdateReturnBehavior()\n    {\n        // Handled in coroutine\n    }\n    \n    private void SetHangingState(bool hanging)\n    {\n        _isHanging = hanging;\n        _isFlying = false;\n        _isReturning = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = hanging;\n            _rigidbody.useGravity = false;\n        }\n        \n        if (hanging)\n        {\n            transform.position = _hangingPosition;\n            transform.rotation = Quaternion.Euler(180f, 0f, 0f);\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsHanging\", _isHanging);\n            _animator.SetBool(\"IsFlying\", _isFlying);\n            _animator.SetFloat(\"WingFlapSpeed\", _isFlying ? _wingFlapSpeed : 0f);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Vector3 hangPos = Application.isPlaying ? _hangingPosition : transform.position;\n        Gizmos.DrawLine(hangPos, hangPos + Vector3.up * _hangHeight);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(hangPos + Vector3.up * _flightHeight, Vector3.one * 0.5f);\n    }\n    \n    public void ForceStartFlight()\n    {\n        if (_isHanging)\n        {\n            StartFlight();\n        }\n    }\n    \n    public void ForceReturnToHanging()\n    {\n        StopAllCoroutines();\n        SetHangingState(true);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Skateboard\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"speed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 12.0\n    },\n    {\n      \"name\": \"trickDuration\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isPerformingTrick\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentTrick\",\n      \"type\": \"string\",\n      \"default\": \"none\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"move_forward\",\n      \"trigger\": \"when forward input is pressed and skateboard is grounded\",\n      \"actions\": [\n        {\n          \"action\": \"accelerate skateboard forward at specified speed\"\n        },\n        {\n          \"action\": \"play rolling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"perform_ollie\",\n      \"trigger\": \"when jump input is pressed and skateboard is grounded\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force to launch skateboard into air\"\n        },\n        {\n          \"action\": \"set grounded status to false\"\n        },\n        {\n          \"action\": \"play jump sound effect\"\n        },\n        {\n          \"action\": \"rotate skateboard slightly backward during jump\"\n        }\n      ]\n    },\n    {\n      \"name\": \"kickflip_trick\",\n      \"trigger\": \"when trick input is pressed while skateboard is airborne\",\n      \"actions\": [\n        {\n          \"action\": \"set trick performing status to true\"\n        },\n        {\n          \"action\": \"set current trick to kickflip\"\n        },\n        {\n          \"action\": \"rotate skateboard rapidly around forward axis\"\n        },\n        {\n          \"action\": \"play trick sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_skateboard\",\n      \"trigger\": \"when skateboard collides with ground after being airborne\",\n      \"actions\": [\n        {\n          \"action\": \"set grounded status to true\"\n        },\n        {\n          \"action\": \"stop all trick rotations\"\n        },\n        {\n          \"action\": \"set trick performing status to false\"\n        },\n        {\n          \"action\": \"reset current trick to none\"\n        },\n        {\n          \"action\": \"play landing sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"grind_rail\",\n      \"trigger\": \"when skateboard contacts rail object while moving\",\n      \"actions\": [\n        {\n          \"action\": \"align skateboard to rail direction\"\n        },\n        {\n          \"action\": \"slide along rail surface\"\n        },\n        {\n          \"action\": \"play grinding sound effect\"\n        },\n        {\n          \"action\": \"create sparks particle effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SkateboardController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 8f;\n    [SerializeField] private float _deceleration = 12f;\n    [SerializeField] private float _turnSpeed = 120f;\n    [SerializeField] private float _pushForce = 10f;\n    \n    [Header(\"Trick Settings\")]\n    [SerializeField] private float _jumpForce = 8f;\n    [SerializeField] private float _flipSpeed = 360f;\n    [SerializeField] private float _trickTimeWindow = 0.5f;\n    [SerializeField] private float _landingTolerance = 15f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _groundCheckDistance = 0.6f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private Transform _groundCheckPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pushSound;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _landSound;\n    [SerializeField] private AudioClip _trickSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<TrickType> OnTrickPerformed;\n    public UnityEvent<float> OnSpeedChanged;\n    public UnityEvent OnLanded;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private bool _isPerformingTrick;\n    private float _currentSpeed;\n    private float _trickTimer;\n    private Vector3 _trickRotation;\n    private TrickType _currentTrick;\n    \n    public enum TrickType\n    {\n        None,\n        Ollie,\n        Kickflip,\n        Heelflip,\n        Shuvit,\n        Treflip\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject checkPoint = new GameObject(\"GroundCheck\");\n            checkPoint.transform.SetParent(transform);\n            checkPoint.transform.localPosition = Vector3.down * 0.5f;\n            _groundCheckPoint = checkPoint.transform;\n        }\n        \n        _rigidbody.centerOfMass = Vector3.down * 0.2f;\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleInput();\n        UpdateTrickTimer();\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n        ApplyTrickRotation();\n    }\n    \n    private void CheckGrounded()\n    {\n        bool wasGrounded = _isGrounded;\n        _isGrounded = Physics.Raycast(_groundCheckPoint.position, Vector3.down, _groundCheckDistance, _groundLayer);\n        \n        if (!wasGrounded && _isGrounded)\n        {\n            OnLanded?.Invoke();\n            PlaySound(_landSound);\n            \n            if (_isPerformingTrick)\n            {\n                CompleteTrick();\n            }\n        }\n        \n        Debug.DrawRay(_groundCheckPoint.position, Vector3.down * _groundCheckDistance, _isGrounded ? Color.green : Color.red);\n    }\n    \n    private void HandleInput()\n    {\n        if (_isGrounded && !_isPerformingTrick)\n        {\n            // Push forward\n            if (Input.GetKeyDown(KeyCode.W) || Input.GetKeyDown(KeyCode.UpArrow))\n            {\n                Push();\n            }\n            \n            // Tricks\n            if (Input.GetKeyDown(KeyCode.Space))\n            {\n                PerformTrick(TrickType.Ollie);\n            }\n            else if (Input.GetKeyDown(KeyCode.Q))\n            {\n                PerformTrick(TrickType.Kickflip);\n            }\n            else if (Input.GetKeyDown(KeyCode.E))\n            {\n                PerformTrick(TrickType.Heelflip);\n            }\n            else if (Input.GetKeyDown(KeyCode.R))\n            {\n                PerformTrick(TrickType.Shuvit);\n            }\n            else if (Input.GetKeyDown(KeyCode.T))\n            {\n                PerformTrick(TrickType.Treflip);\n            }\n        }\n        \n        // Steering\n        float steerInput = Input.GetAxis(\"Horizontal\");\n        if (Mathf.Abs(steerInput) > 0.1f && _currentSpeed > 1f)\n        {\n            transform.Rotate(0, steerInput * _turnSpeed * Time.deltaTime, 0);\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_isGrounded)\n        {\n            // Apply deceleration\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0, _deceleration * Time.fixedDeltaTime);\n            \n            // Apply movement\n            Vector3 moveDirection = transform.forward * _currentSpeed;\n            _rigidbody.velocity = new Vector3(moveDirection.x, _rigidbody.velocity.y, moveDirection.z);\n        }\n    }\n    \n    private void Push()\n    {\n        _currentSpeed = Mathf.Min(_currentSpeed + _pushForce, _maxSpeed);\n        PlaySound(_pushSound);\n    }\n    \n    private void PerformTrick(TrickType trickType)\n    {\n        if (_isPerformingTrick) return;\n        \n        _isPerformingTrick = true;\n        _currentTrick = trickType;\n        _trickTimer = _trickTimeWindow;\n        \n        // Apply jump force\n        _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        \n        // Set trick rotation based on type\n        switch (trickType)\n        {\n            case TrickType.Ollie:\n                _trickRotation = Vector3.zero;\n                break;\n            case TrickType.Kickflip:\n                _trickRotation = new Vector3(_flipSpeed, 0, 0);\n                break;\n            case TrickType.Heelflip:\n                _trickRotation = new Vector3(-_flipSpeed, 0, 0);\n                break;\n            case TrickType.Shuvit:\n                _trickRotation = new Vector3(0, _flipSpeed, 0);\n                break;\n            case TrickType.Treflip:\n                _trickRotation = new Vector3(_flipSpeed, _flipSpeed, 0);\n                break;\n        }\n        \n        PlaySound(_jumpSound);\n        OnTrickPerformed?.Invoke(trickType);\n    }\n    \n    private void ApplyTrickRotation()\n    {\n        if (_isPerformingTrick && !_isGrounded)\n        {\n            Vector3 rotationThisFrame = _trickRotation * Time.fixedDeltaTime;\n            transform.Rotate(rotationThisFrame, Space.Self);\n        }\n    }\n    \n    private void UpdateTrickTimer()\n    {\n        if (_isPerformingTrick)\n        {\n            _trickTimer -= Time.deltaTime;\n            \n            if (_trickTimer <= 0 && !_isGrounded)\n            {\n                // Trick failed - didn't land in time\n                _isPerformingTrick = false;\n                _currentTrick = TrickType.None;\n                _trickRotation = Vector3.zero;\n            }\n        }\n    }\n    \n    private void CompleteTrick()\n    {\n        if (_currentTrick == TrickType.None) return;\n        \n        // Check if landed properly (board relatively upright)\n        float uprightAngle = Vector3.Angle(transform.up, Vector3.up);\n        \n        if (uprightAngle <= _landingTolerance)\n        {\n            // Successful trick landing\n            PlaySound(_trickSound);\n            Debug.Log($\"Successfully landed {_currentTrick}!\");\n        }\n        else\n        {\n            // Failed landing\n            Debug.Log($\"Failed to land {_currentTrick} properly. Angle: {uprightAngle:F1}\u00b0\");\n        }\n        \n        _isPerformingTrick = false;\n        _currentTrick = TrickType.None;\n        _trickRotation = Vector3.zero;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsGrounded()\n    {\n        return _isGrounded;\n    }\n    \n    public bool IsPerformingTrick()\n    {\n        return _isPerformingTrick;\n    }\n    \n    public TrickType GetCurrentTrick()\n    {\n        return _currentTrick;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, 0.1f);\n            Gizmos.DrawLine(_groundCheckPoint.position, _groundCheckPoint.position + Vector3.down * _groundCheckDistance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CraftingForge\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"craftingTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"currentCraftingTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"requiredMaterials\",\n      \"type\": \"List<string>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"craftedItem\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"maxTemperature\",\n      \"type\": \"float\",\n      \"default\": 1000.0\n    },\n    {\n      \"name\": \"currentTemperature\",\n      \"type\": \"float\",\n      \"default\": 20.0\n    },\n    {\n      \"name\": \"fuelLevel\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"isLit\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"light_forge\",\n      \"trigger\": \"when player interacts with forge and has fuel\",\n      \"actions\": [\n        {\n          \"action\": \"ignite the forge flames\"\n        },\n        {\n          \"action\": \"start heating up gradually\"\n        },\n        {\n          \"action\": \"play fire crackling sound\"\n        },\n        {\n          \"action\": \"emit orange glow and particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_crafting\",\n      \"trigger\": \"when player places required materials and forge is hot enough\",\n      \"actions\": [\n        {\n          \"action\": \"begin crafting process\"\n        },\n        {\n          \"action\": \"consume the materials from inventory\"\n        },\n        {\n          \"action\": \"start crafting timer\"\n        },\n        {\n          \"action\": \"play hammering and sizzling sounds\"\n        },\n        {\n          \"action\": \"show crafting progress indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_crafting\",\n      \"trigger\": \"when crafting time is finished\",\n      \"actions\": [\n        {\n          \"action\": \"create the crafted item\"\n        },\n        {\n          \"action\": \"place item in output slot\"\n        },\n        {\n          \"action\": \"play completion chime sound\"\n        },\n        {\n          \"action\": \"show success particle effects\"\n        },\n        {\n          \"action\": \"reset crafting state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_temperature\",\n      \"trigger\": \"when forge is lit and has fuel\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase temperature to maximum\"\n        },\n        {\n          \"action\": \"consume fuel over time\"\n        },\n        {\n          \"action\": \"maintain flame effects and sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cool_down\",\n      \"trigger\": \"when forge runs out of fuel or is extinguished\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease temperature\"\n        },\n        {\n          \"action\": \"dim the flame effects\"\n        },\n        {\n          \"action\": \"fade out fire sounds\"\n        },\n        {\n          \"action\": \"cancel any active crafting\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_recipe_requirements\",\n      \"trigger\": \"when player examines forge with materials in hand\",\n      \"actions\": [\n        {\n          \"action\": \"display required materials for possible recipes\"\n        },\n        {\n          \"action\": \"highlight missing materials in red\"\n        },\n        {\n          \"action\": \"show estimated crafting time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Forge : MonoBehaviour\n{\n    [System.Serializable]\n    public class CraftingMaterial\n    {\n        public string materialName;\n        public Sprite icon;\n        public int quantity;\n        \n        public CraftingMaterial(string name, Sprite sprite, int qty)\n        {\n            materialName = name;\n            icon = sprite;\n            quantity = qty;\n        }\n    }\n    \n    [System.Serializable]\n    public class CraftingRecipe\n    {\n        public string recipeName;\n        public Sprite resultIcon;\n        public List<CraftingMaterial> requiredMaterials = new List<CraftingMaterial>();\n        public GameObject resultPrefab;\n        public int craftingTime = 3;\n        public AudioClip craftingSound;\n        \n        public bool CanCraft(List<CraftingMaterial> availableMaterials)\n        {\n            foreach (var required in requiredMaterials)\n            {\n                var available = availableMaterials.FirstOrDefault(m => m.materialName == required.materialName);\n                if (available == null || available.quantity < required.quantity)\n                    return false;\n            }\n            return true;\n        }\n    }\n    \n    [Header(\"Forge Settings\")]\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private Transform _craftingPoint;\n    [SerializeField] private ParticleSystem _forgeFlames;\n    [SerializeField] private ParticleSystem _craftingEffect;\n    [SerializeField] private Light _forgeLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _forgeIdleSound;\n    [SerializeField] private AudioClip _craftingCompleteSound;\n    \n    [Header(\"Recipes\")]\n    [SerializeField] private List<CraftingRecipe> _availableRecipes = new List<CraftingRecipe>();\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _forgeUI;\n    [SerializeField] private GameObject _recipeButtonPrefab;\n    [SerializeField] private Transform _recipeContainer;\n    [SerializeField] private UnityEngine.UI.Button _closeButton;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnItemCrafted;\n    public UnityEvent OnForgeOpened;\n    public UnityEvent OnForgeClosed;\n    \n    private List<CraftingMaterial> _playerMaterials = new List<CraftingMaterial>();\n    private bool _isPlayerNearby = false;\n    private bool _isCrafting = false;\n    private float _craftingTimer = 0f;\n    private CraftingRecipe _currentRecipe;\n    private Transform _player;\n    \n    private void Start()\n    {\n        InitializeForge();\n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n        UpdateCrafting();\n        UpdateEffects();\n    }\n    \n    private void InitializeForge()\n    {\n        if (_forgeUI != null)\n            _forgeUI.gameObject.SetActive(false);\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_craftingPoint == null)\n            _craftingPoint = transform;\n            \n        if (_forgeFlames != null)\n            _forgeFlames.Play();\n            \n        PlayIdleSound();\n    }\n    \n    private void SetupUI()\n    {\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(CloseForgeUI);\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasNearby = _isPlayerNearby;\n        _isPlayerNearby = distance <= _interactionRange;\n        _player = player.transform;\n        \n        if (_isPlayerNearby && !wasNearby)\n        {\n            ShowInteractionPrompt();\n        }\n        else if (!_isPlayerNearby && wasNearby)\n        {\n            HideInteractionPrompt();\n            CloseForgeUI();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_isPlayerNearby && Input.GetKeyDown(KeyCode.E))\n        {\n            if (_forgeUI != null && _forgeUI.gameObject.activeInHierarchy)\n                CloseForgeUI();\n            else\n                OpenForgeUI();\n        }\n    }\n    \n    private void UpdateCrafting()\n    {\n        if (!_isCrafting) return;\n        \n        _craftingTimer -= Time.deltaTime;\n        \n        if (_craftingTimer <= 0f)\n        {\n            CompleteCrafting();\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        if (_forgeLight != null)\n        {\n            float intensity = _isCrafting ? 2f : 1f;\n            _forgeLight.intensity = Mathf.Lerp(_forgeLight.intensity, intensity, Time.deltaTime * 2f);\n        }\n        \n        if (_craftingEffect != null)\n        {\n            if (_isCrafting && !_craftingEffect.isPlaying)\n                _craftingEffect.Play();\n            else if (!_isCrafting && _craftingEffect.isPlaying)\n                _craftingEffect.Stop();\n        }\n    }\n    \n    private void OpenForgeUI()\n    {\n        if (_forgeUI == null) return;\n        \n        _forgeUI.gameObject.SetActive(true);\n        UpdatePlayerMaterials();\n        PopulateRecipes();\n        OnForgeOpened?.Invoke();\n        \n        Time.timeScale = 0f;\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n    \n    private void CloseForgeUI()\n    {\n        if (_forgeUI == null) return;\n        \n        _forgeUI.gameObject.SetActive(false);\n        OnForgeClosed?.Invoke();\n        \n        Time.timeScale = 1f;\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n    \n    private void UpdatePlayerMaterials()\n    {\n        _playerMaterials.Clear();\n        \n        if (_player == null) return;\n        \n        // Simulate getting materials from player inventory\n        // In a real implementation, this would interface with an inventory system\n        _playerMaterials.Add(new CraftingMaterial(\"Iron Ore\", null, 5));\n        _playerMaterials.Add(new CraftingMaterial(\"Wood\", null, 10));\n        _playerMaterials.Add(new CraftingMaterial(\"Coal\", null, 3));\n    }\n    \n    private void PopulateRecipes()\n    {\n        if (_recipeContainer == null || _recipeButtonPrefab == null) return;\n        \n        // Clear existing recipe buttons\n        foreach (Transform child in _recipeContainer)\n        {\n            if (child.gameObject != _recipeButtonPrefab)\n                Destroy(child.gameObject);\n        }\n        \n        // Create recipe buttons\n        foreach (var recipe in _availableRecipes)\n        {\n            GameObject buttonObj = Instantiate(_recipeButtonPrefab, _recipeContainer);\n            UnityEngine.UI.Button button = buttonObj.GetComponent<UnityEngine.UI.Button>();\n            \n            if (button != null)\n            {\n                button.onClick.AddListener(() => StartCrafting(recipe));\n                \n                // Update button appearance based on availability\n                bool canCraft = recipe.CanCraft(_playerMaterials);\n                button.interactable = canCraft && !_isCrafting;\n                \n                // Update button text/image if components exist\n                UnityEngine.UI.Text buttonText = button.GetComponentInChildren<UnityEngine.UI.Text>();\n                if (buttonText != null)\n                    buttonText.text = recipe.recipeName;\n                    \n                UnityEngine.UI.Image buttonImage = button.GetComponent<UnityEngine.UI.Image>();\n                if (buttonImage != null && recipe.resultIcon != null)\n                    buttonImage.sprite = recipe.resultIcon;\n            }\n            \n            buttonObj.SetActive(true);\n        }\n    }\n    \n    private void StartCrafting(CraftingRecipe recipe)\n    {\n        if (_isCrafting || !recipe.CanCraft(_playerMaterials)) return;\n        \n        _currentRecipe = recipe;\n        _isCrafting = true;\n        _craftingTimer = recipe.craftingTime;\n        \n        // Consume materials\n        foreach (var required in recipe.requiredMaterials)\n        {\n            var material = _playerMaterials.FirstOrDefault(m => m.materialName == required.materialName);\n            if (material != null)\n                material.quantity -= required.quantity;\n        }\n        \n        // Play crafting sound\n        if (_audioSource != null && recipe.craftingSound != null)\n            _audioSource.PlayOneShot(recipe.craftingSound);\n            \n        // Update UI\n        PopulateRecipes();\n    }\n    \n    private void CompleteCrafting()\n    {\n        if (_currentRecipe == null) return;\n        \n        _isCrafting = false;\n        \n        // Spawn crafted item\n        if (_currentRecipe.resultPrefab != null)\n        {\n            Vector3 spawnPosition = _craftingPoint.position + Vector3.up * 0.5f;\n            GameObject craftedItem = Instantiate(_currentRecipe.resultPrefab, spawnPosition, Quaternion.identity);\n            \n            // Add some upward force to the crafted item\n            Rigidbody rb = craftedItem.GetComponent<Rigidbody>();\n            if (rb != null)\n                rb.AddForce(Vector3.up * 3f, ForceMode.Impulse);\n        }\n        \n        // Play completion sound\n        if (_audioSource != null && _craftingCompleteSound != null)\n            _audioSource.PlayOneShot(_craftingCompleteSound);\n        \n        // Invoke event\n        OnItemCrafted?.Invoke(_currentRecipe.recipeName);\n        \n        _currentRecipe = null;\n        \n        // Update UI\n        PopulateRecipes();\n        \n        // Resume idle sound\n        Invoke(nameof(PlayIdleSound), 1f);\n    }\n    \n    private void PlayIdleSound()\n    {\n        if (_audioSource != null && _forgeIdleSound != null && !_isCrafting)\n        {\n            _audioSource.clip = _forgeIdleSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void ShowInteractionPrompt()\n    {\n        // This would typically show a UI prompt\n        Debug.Log(\"Press E to use Forge\");\n    }\n    \n    private void HideInteractionPrompt()\n    {\n        // This would typically hide the UI prompt\n    }\n    \n    public void AddMaterial(string materialName, int quantity)\n    {\n        var existing = _playerMaterials.FirstOrDefault(m => m.materialName == materialName);\n        if (existing != null)\n            existing.quantity += quantity;\n        else\n            _playerMaterials.Add(new CraftingMaterial(materialName, null, quantity));\n    }\n    \n    public bool HasMaterial(string materialName, int quantity)\n    {\n        var material = _playerMaterials.FirstOrDefault(m => m.materialName == materialName);\n        return material != null && material.quantity >= quantity;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_craftingPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(_craftingPoint.position, Vector3.one * 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VoiceChatProximity\",\n  \"components\": [\n    \"AudioSource\",\n    \"AudioListener\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHearingDistance\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"minHearingDistance\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"volumeFalloffCurve\",\n      \"type\": \"AnimationCurve\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isTransmitting\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"voiceChannel\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"adjust_voice_volume_by_distance\",\n      \"trigger\": \"when distance to other players changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate volume based on distance between players\"\n        },\n        {\n          \"action\": \"apply volume falloff curve to audio source\"\n        },\n        {\n          \"action\": \"set audio source volume to calculated value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enable_voice_transmission\",\n      \"trigger\": \"when push to talk key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"start recording microphone input\"\n        },\n        {\n          \"action\": \"set transmission state to active\"\n        },\n        {\n          \"action\": \"broadcast voice data to nearby players\"\n        }\n      ]\n    },\n    {\n      \"name\": \"disable_voice_transmission\",\n      \"trigger\": \"when push to talk key is released\",\n      \"actions\": [\n        {\n          \"action\": \"stop recording microphone input\"\n        },\n        {\n          \"action\": \"set transmission state to inactive\"\n        },\n        {\n          \"action\": \"stop broadcasting voice data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"filter_audio_by_range\",\n      \"trigger\": \"when receiving voice data from other players\",\n      \"actions\": [\n        {\n          \"action\": \"check if transmitting player is within hearing range\"\n        },\n        {\n          \"action\": \"play received audio if player is close enough\"\n        },\n        {\n          \"action\": \"ignore audio if player is too far away\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_spatial_audio\",\n      \"trigger\": \"when playing voice audio from other players\",\n      \"actions\": [\n        {\n          \"action\": \"position audio source at transmitting player location\"\n        },\n        {\n          \"action\": \"apply directional audio based on player orientation\"\n        },\n        {\n          \"action\": \"adjust stereo panning based on relative position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class ProximityVoiceChat : MonoBehaviour\n{\n    [System.Serializable]\n    public class VoiceSettings\n    {\n        [Range(0f, 100f)]\n        public float maxHearingDistance = 20f;\n        [Range(0f, 100f)]\n        public float whisperDistance = 5f;\n        [Range(0f, 100f)]\n        public float shoutDistance = 50f;\n        [Range(0f, 1f)]\n        public float minVolume = 0.1f;\n        [Range(0f, 1f)]\n        public float maxVolume = 1f;\n        public AnimationCurve volumeFalloffCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    }\n\n    [System.Serializable]\n    public class PlayerVoiceData\n    {\n        public Transform playerTransform;\n        public AudioSource audioSource;\n        public AudioClip voiceClip;\n        public bool isTalking;\n        public float talkingVolume;\n        public VoiceMode currentMode;\n        \n        public PlayerVoiceData(Transform transform, AudioSource source)\n        {\n            playerTransform = transform;\n            audioSource = source;\n            isTalking = false;\n            talkingVolume = 1f;\n            currentMode = VoiceMode.Normal;\n        }\n    }\n\n    public enum VoiceMode\n    {\n        Whisper,\n        Normal,\n        Shout\n    }\n\n    [Header(\"Voice Settings\")]\n    [SerializeField] private VoiceSettings _voiceSettings = new VoiceSettings();\n    \n    [Header(\"Audio Configuration\")]\n    [SerializeField] private AudioMixerGroup _voiceMixerGroup;\n    [SerializeField] private bool _use3DAudio = true;\n    [SerializeField] private AudioRolloffMode _rolloffMode = AudioRolloffMode.Linear;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private bool _checkLineOfSight = true;\n    [SerializeField] private float _updateRate = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform, float> OnPlayerVoiceHeard;\n    public UnityEvent<Transform> OnPlayerStartedTalking;\n    public UnityEvent<Transform> OnPlayerStoppedTalking;\n\n    private Dictionary<Transform, PlayerVoiceData> _nearbyPlayers = new Dictionary<Transform, PlayerVoiceData>();\n    private Transform _localPlayer;\n    private float _updateTimer;\n    private bool _isLocalPlayerTalking;\n    private VoiceMode _currentVoiceMode = VoiceMode.Normal;\n\n    private void Start()\n    {\n        _localPlayer = transform;\n        _updateTimer = 0f;\n        \n        if (_voiceSettings.volumeFalloffCurve.keys.Length == 0)\n        {\n            _voiceSettings.volumeFalloffCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n        }\n    }\n\n    private void Update()\n    {\n        _updateTimer += Time.deltaTime;\n        \n        if (_updateTimer >= 1f / _updateRate)\n        {\n            UpdateProximityVoice();\n            _updateTimer = 0f;\n        }\n\n        HandleVoiceInput();\n        UpdateVoiceVisualization();\n    }\n\n    private void HandleVoiceInput()\n    {\n        bool wasTalking = _isLocalPlayerTalking;\n        \n        // Simulate voice input detection (replace with actual microphone input)\n        _isLocalPlayerTalking = Input.GetKey(KeyCode.V) || Input.GetKey(KeyCode.T);\n        \n        // Voice mode switching\n        if (Input.GetKeyDown(KeyCode.Alpha1))\n            _currentVoiceMode = VoiceMode.Whisper;\n        else if (Input.GetKeyDown(KeyCode.Alpha2))\n            _currentVoiceMode = VoiceMode.Normal;\n        else if (Input.GetKeyDown(KeyCode.Alpha3))\n            _currentVoiceMode = VoiceMode.Shout;\n\n        if (_isLocalPlayerTalking && !wasTalking)\n        {\n            OnPlayerStartedTalking?.Invoke(_localPlayer);\n            BroadcastVoiceToNearbyPlayers(true);\n        }\n        else if (!_isLocalPlayerTalking && wasTalking)\n        {\n            OnPlayerStoppedTalking?.Invoke(_localPlayer);\n            BroadcastVoiceToNearbyPlayers(false);\n        }\n    }\n\n    private void UpdateProximityVoice()\n    {\n        DetectNearbyPlayers();\n        UpdatePlayerVoiceVolumes();\n        CleanupDistantPlayers();\n    }\n\n    private void DetectNearbyPlayers()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(\n            _localPlayer.position, \n            _voiceSettings.maxHearingDistance, \n            _playerLayer\n        );\n\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.transform == _localPlayer) continue;\n            \n            if (!col.CompareTag(\"Player\")) continue;\n\n            if (!_nearbyPlayers.ContainsKey(col.transform))\n            {\n                AddNewPlayer(col.transform);\n            }\n        }\n    }\n\n    private void AddNewPlayer(Transform playerTransform)\n    {\n        AudioSource audioSource = playerTransform.GetComponent<AudioSource>();\n        \n        if (audioSource == null)\n        {\n            audioSource = playerTransform.gameObject.AddComponent<AudioSource>();\n        }\n\n        ConfigureAudioSource(audioSource);\n        \n        PlayerVoiceData voiceData = new PlayerVoiceData(playerTransform, audioSource);\n        _nearbyPlayers.Add(playerTransform, voiceData);\n    }\n\n    private void ConfigureAudioSource(AudioSource audioSource)\n    {\n        audioSource.spatialBlend = _use3DAudio ? 1f : 0f;\n        audioSource.rolloffMode = _rolloffMode;\n        audioSource.maxDistance = _voiceSettings.maxHearingDistance;\n        audioSource.minDistance = 1f;\n        audioSource.loop = false;\n        audioSource.playOnAwake = false;\n        \n        if (_voiceMixerGroup != null)\n        {\n            audioSource.outputAudioMixerGroup = _voiceMixerGroup;\n        }\n    }\n\n    private void UpdatePlayerVoiceVolumes()\n    {\n        List<Transform> playersToRemove = new List<Transform>();\n\n        foreach (var kvp in _nearbyPlayers)\n        {\n            Transform playerTransform = kvp.Key;\n            PlayerVoiceData voiceData = kvp.Value;\n\n            if (playerTransform == null)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float distance = Vector3.Distance(_localPlayer.position, playerTransform.position);\n            float maxDistance = GetMaxDistanceForMode(voiceData.currentMode);\n\n            if (distance > maxDistance)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float volume = CalculateVoiceVolume(distance, voiceData.currentMode);\n            \n            if (_checkLineOfSight && !HasLineOfSight(playerTransform.position))\n            {\n                volume *= 0.5f; // Muffle voice through obstacles\n            }\n\n            voiceData.audioSource.volume = volume * voiceData.talkingVolume;\n            \n            if (voiceData.isTalking && volume > 0f)\n            {\n                OnPlayerVoiceHeard?.Invoke(playerTransform, volume);\n            }\n        }\n\n        foreach (Transform player in playersToRemove)\n        {\n            RemovePlayer(player);\n        }\n    }\n\n    private float GetMaxDistanceForMode(VoiceMode mode)\n    {\n        switch (mode)\n        {\n            case VoiceMode.Whisper:\n                return _voiceSettings.whisperDistance;\n            case VoiceMode.Shout:\n                return _voiceSettings.shoutDistance;\n            default:\n                return _voiceSettings.maxHearingDistance;\n        }\n    }\n\n    private float CalculateVoiceVolume(float distance, VoiceMode mode)\n    {\n        float maxDistance = GetMaxDistanceForMode(mode);\n        \n        if (distance >= maxDistance)\n            return 0f;\n\n        float normalizedDistance = distance / maxDistance;\n        float volumeMultiplier = _voiceSettings.volumeFalloffCurve.Evaluate(1f - normalizedDistance);\n        \n        return Mathf.Lerp(_voiceSettings.minVolume, _voiceSettings.maxVolume, volumeMultiplier);\n    }\n\n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - _localPlayer.position;\n        float distance = direction.magnitude;\n        \n        if (Physics.Raycast(_localPlayer.position + Vector3.up * 0.5f, direction.normalized, distance, _obstacleLayer))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private void CleanupDistantPlayers()\n    {\n        List<Transform> playersToRemove = new List<Transform>();\n\n        foreach (var kvp in _nearbyPlayers)\n        {\n            Transform playerTransform = kvp.Key;\n            \n            if (playerTransform == null)\n            {\n                playersToRemove.Add(playerTransform);\n                continue;\n            }\n\n            float distance = Vector3.Distance(_localPlayer.position, playerTransform.position);\n            \n            if (distance > _voiceSettings.maxHearingDistance * 1.2f) // Add buffer to prevent flickering\n            {\n                playersToRemove.Add(playerTransform);\n            }\n        }\n\n        foreach (Transform player in playersToRemove)\n        {\n            RemovePlayer(player);\n        }\n    }\n\n    private void RemovePlayer(Transform playerTransform)\n    {\n        if (_nearbyPlayers.ContainsKey(playerTransform))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[playerTransform];\n            \n            if (voiceData.audioSource != null && voiceData.audioSource.isPlaying)\n            {\n                voiceData.audioSource.Stop();\n            }\n            \n            _nearbyPlayers.Remove(playerTransform);\n        }\n    }\n\n    private void BroadcastVoiceToNearbyPlayers(bool isTalking)\n    {\n        // This would typically send network messages to other players\n        // For now, we'll simulate by updating local data\n        foreach (var kvp in _nearbyPlayers)\n        {\n            PlayerVoiceData voiceData = kvp.Value;\n            // In a real implementation, this would be received from network\n        }\n    }\n\n    private void UpdateVoiceVisualization()\n    {\n        // Visual feedback for current voice mode and talking state\n        // This could update UI elements or particle effects\n    }\n\n    public void SetPlayerTalking(Transform player, bool isTalking, VoiceMode mode = VoiceMode.Normal)\n    {\n        if (_nearbyPlayers.ContainsKey(player))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[player];\n            voiceData.isTalking = isTalking;\n            voiceData.currentMode = mode;\n\n            if (isTalking)\n            {\n                OnPlayerStartedTalking?.Invoke(player);\n            }\n            else\n            {\n                OnPlayerStoppedTalking?.Invoke(player);\n                if (voiceData.audioSource.isPlaying)\n                {\n                    voiceData.audioSource.Stop();\n                }\n            }\n        }\n    }\n\n    public void PlayVoiceClip(Transform player, AudioClip clip, float volume = 1f)\n    {\n        if (_nearbyPlayers.ContainsKey(player))\n        {\n            PlayerVoiceData voiceData = _nearbyPlayers[player];\n            voiceData.audioSource.clip = clip;\n            voiceData.talkingVolume = volume;\n            voiceData.audioSource.Play();\n        }\n    }\n\n    public void SetVoiceMode(VoiceMode mode)\n    {\n        _currentVoiceMode = mode;\n    }\n\n    public VoiceMode GetCurrentVoiceMode()\n    {\n        return _currentVoiceMode;\n    }\n\n    public bool IsPlayerInRange(Transform player)\n    {\n        return _nearbyPlayers.ContainsKey(player);\n    }\n\n    public float GetPlayerDistance(Transform player)\n    {\n        if (player == null) return float.MaxValue;\n        return Vector3.Distance(_localPlayer.position, player.position);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_localPlayer == null) return;\n\n        // Draw hearing ranges\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.whisperDistance);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.maxHearingDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_localPlayer.position, _voiceSettings.shoutDistance);\n\n        // Draw connections to nearby players\n        Gizmos.color = Color.cyan;\n        foreach (var kvp in _nearbyPlayers)\n        {\n            if (kvp.Key != null)\n            {\n                Gizmos.DrawLine(_localPlayer.position, kvp.Key.position);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ElementalWizard\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"mana\",\n      \"type\": \"float\",\n      \"default\": 150\n    },\n    {\n      \"name\": \"castingRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"manaRegenRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"fireballDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"iceShardDamage\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"lightningDamage\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"fireballManaCost\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"iceShardManaCost\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"lightningManaCost\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"castingSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"regenerate_mana\",\n      \"trigger\": \"continuously over time\",\n      \"actions\": [\n        {\n          \"action\": \"increase mana by regeneration rate per second up to maximum\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cast_fireball\",\n      \"trigger\": \"when fire attack input is pressed and mana is sufficient and target is in range\",\n      \"actions\": [\n        {\n          \"action\": \"reduce mana by fireball cost\"\n        },\n        {\n          \"action\": \"play fire casting animation\"\n        },\n        {\n          \"action\": \"create fireball projectile toward target\"\n        },\n        {\n          \"action\": \"apply fire damage to target on impact\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cast_ice_shard\",\n      \"trigger\": \"when ice attack input is pressed and mana is sufficient and target is in range\",\n      \"actions\": [\n        {\n          \"action\": \"reduce mana by ice shard cost\"\n        },\n        {\n          \"action\": \"play ice casting animation\"\n        },\n        {\n          \"action\": \"create ice shard projectile toward target\"\n        },\n        {\n          \"action\": \"apply ice damage and slow effect to target on impact\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cast_lightning_bolt\",\n      \"trigger\": \"when lightning attack input is pressed and mana is sufficient and target is in range\",\n      \"actions\": [\n        {\n          \"action\": \"reduce mana by lightning cost\"\n        },\n        {\n          \"action\": \"play lightning casting animation\"\n        },\n        {\n          \"action\": \"create instant lightning effect between wizard and target\"\n        },\n        {\n          \"action\": \"apply lightning damage and stun effect to target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wizard_movement\",\n      \"trigger\": \"when movement input is received\",\n      \"actions\": [\n        {\n          \"action\": \"move wizard in input direction at movement speed\"\n        },\n        {\n          \"action\": \"rotate wizard to face movement direction\"\n        },\n        {\n          \"action\": \"play walking animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"face_target\",\n      \"trigger\": \"when casting spell at target\",\n      \"actions\": [\n        {\n          \"action\": \"rotate wizard to face target before casting\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wizard_death\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"disable wizard controls\"\n        },\n        {\n          \"action\": \"trigger game over or respawn sequence\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class WizardController : MonoBehaviour\n{\n    [System.Serializable]\n    public enum ElementType\n    {\n        Fire,\n        Ice,\n        Lightning,\n        Earth\n    }\n\n    [System.Serializable]\n    public class ElementalSpell\n    {\n        public ElementType element;\n        public GameObject projectilePrefab;\n        public ParticleSystem castEffect;\n        public AudioClip castSound;\n        public float damage = 25f;\n        public float manaCost = 20f;\n        public float cooldown = 1f;\n        public float projectileSpeed = 10f;\n        [HideInInspector] public float lastCastTime;\n    }\n\n    [Header(\"Wizard Stats\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _maxMana = 100f;\n    [SerializeField] private float _manaRegenRate = 10f;\n    [SerializeField] private float _movementSpeed = 5f;\n\n    [Header(\"Combat\")]\n    [SerializeField] private ElementalSpell[] _spells = new ElementalSpell[4];\n    [SerializeField] private Transform _castPoint;\n    [SerializeField] private LayerMask _enemyLayers = -1;\n    [SerializeField] private float _attackRange = 15f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent<float> OnManaChanged;\n    public UnityEvent<ElementType> OnSpellCast;\n    public UnityEvent OnDeath;\n\n    private float _currentHealth;\n    private float _currentMana;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private Transform _currentTarget;\n    private bool _isDead;\n    private int _currentSpellIndex;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _currentMana = _maxMana;\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_castPoint == null)\n            _castPoint = transform;\n\n        InitializeSpells();\n        StartCoroutine(ManaRegeneration());\n    }\n\n    private void Update()\n    {\n        if (_isDead) return;\n\n        HandleInput();\n        FindTarget();\n        UpdateAnimator();\n    }\n\n    private void InitializeSpells()\n    {\n        for (int i = 0; i < _spells.Length; i++)\n        {\n            if (_spells[i] == null)\n            {\n                _spells[i] = new ElementalSpell();\n                _spells[i].element = (ElementType)i;\n            }\n        }\n    }\n\n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 movement = new Vector3(horizontal, 0, vertical) * _movementSpeed;\n        _rigidbody.velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n\n        if (Input.GetKeyDown(KeyCode.Alpha1)) CastSpell(0);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) CastSpell(1);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) CastSpell(2);\n        if (Input.GetKeyDown(KeyCode.Alpha4)) CastSpell(3);\n        \n        if (Input.GetKeyDown(KeyCode.Tab)) CycleSpell();\n        if (Input.GetMouseButtonDown(0)) CastSpell(_currentSpellIndex);\n    }\n\n    private void FindTarget()\n    {\n        Collider[] enemies = Physics.OverlapSphere(transform.position, _attackRange, _enemyLayers);\n        float closestDistance = Mathf.Infinity;\n        Transform closestEnemy = null;\n\n        foreach (Collider enemy in enemies)\n        {\n            if (enemy.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, enemy.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestEnemy = enemy.transform;\n            }\n        }\n\n        _currentTarget = closestEnemy;\n        \n        if (_currentTarget != null)\n        {\n            Vector3 direction = (_currentTarget.position - transform.position).normalized;\n            direction.y = 0;\n            transform.rotation = Quaternion.LookRotation(direction);\n        }\n    }\n\n    private void CycleSpell()\n    {\n        _currentSpellIndex = (_currentSpellIndex + 1) % _spells.Length;\n    }\n\n    private void CastSpell(int spellIndex)\n    {\n        if (spellIndex < 0 || spellIndex >= _spells.Length) return;\n        \n        ElementalSpell spell = _spells[spellIndex];\n        if (spell == null) return;\n\n        if (Time.time - spell.lastCastTime < spell.cooldown) return;\n        if (_currentMana < spell.manaCost) return;\n\n        spell.lastCastTime = Time.time;\n        _currentMana = Mathf.Max(0, _currentMana - spell.manaCost);\n        OnManaChanged?.Invoke(_currentMana / _maxMana);\n\n        StartCoroutine(PerformSpellCast(spell));\n    }\n\n    private IEnumerator PerformSpellCast(ElementalSpell spell)\n    {\n        if (_animator != null)\n            _animator.SetTrigger(\"Cast\");\n\n        if (spell.castEffect != null)\n            spell.castEffect.Play();\n\n        if (spell.castSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(spell.castSound);\n\n        yield return new WaitForSeconds(0.3f);\n\n        CreateProjectile(spell);\n        OnSpellCast?.Invoke(spell.element);\n    }\n\n    private void CreateProjectile(ElementalSpell spell)\n    {\n        if (spell.projectilePrefab == null) return;\n\n        Vector3 spawnPosition = _castPoint.position;\n        Vector3 direction = _currentTarget != null ? \n            (_currentTarget.position - spawnPosition).normalized : \n            transform.forward;\n\n        GameObject projectile = Instantiate(spell.projectilePrefab, spawnPosition, Quaternion.LookRotation(direction));\n        \n        ElementalProjectile projectileScript = projectile.GetComponent<ElementalProjectile>();\n        if (projectileScript == null)\n            projectileScript = projectile.AddComponent<ElementalProjectile>();\n\n        projectileScript.Initialize(spell.element, spell.damage, spell.projectileSpeed, direction);\n    }\n\n    private IEnumerator ManaRegeneration()\n    {\n        while (!_isDead)\n        {\n            if (_currentMana < _maxMana)\n            {\n                _currentMana = Mathf.Min(_maxMana, _currentMana + _manaRegenRate * Time.deltaTime);\n                OnManaChanged?.Invoke(_currentMana / _maxMana);\n            }\n            yield return null;\n        }\n    }\n\n    private void UpdateAnimator()\n    {\n        if (_animator == null) return;\n\n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"HasTarget\", _currentTarget != null);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n\n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_animator != null)\n            _animator.SetTrigger(\"Hit\");\n\n        if (_currentHealth <= 0)\n            Die();\n    }\n\n    private void Die()\n    {\n        _isDead = true;\n        \n        if (_animator != null)\n            _animator.SetBool(\"Dead\", true);\n\n        OnDeath?.Invoke();\n        \n        Collider col = GetComponent<Collider>();\n        if (col != null)\n            col.enabled = false;\n\n        _rigidbody.isKinematic = true;\n    }\n\n    public float GetHealthPercentage() => _currentHealth / _maxHealth;\n    public float GetManaPercentage() => _currentMana / _maxMana;\n    public ElementType GetCurrentSpellElement() => _spells[_currentSpellIndex].element;\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n    }\n}\n\npublic class ElementalProjectile : MonoBehaviour\n{\n    private WizardController.ElementType _element;\n    private float _damage;\n    private float _speed;\n    private Vector3 _direction;\n    private Rigidbody _rigidbody;\n    private bool _initialized;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        \n        _rigidbody.useGravity = false;\n        Destroy(gameObject, 5f);\n    }\n\n    private void FixedUpdate()\n    {\n        if (_initialized && _rigidbody != null)\n        {\n            _rigidbody.velocity = _direction * _speed;\n        }\n    }\n\n    public void Initialize(WizardController.ElementType element, float damage, float speed, Vector3 direction)\n    {\n        _element = element;\n        _damage = damage;\n        _speed = speed;\n        _direction = direction.normalized;\n        _initialized = true;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\")) return;\n\n        ApplyElementalEffect(other);\n        CreateImpactEffect();\n        Destroy(gameObject);\n    }\n\n    private void ApplyElementalEffect(Collider target)\n    {\n        switch (_element)\n        {\n            case WizardController.ElementType.Fire:\n                ApplyBurnEffect(target);\n                break;\n            case WizardController.ElementType.Ice:\n                ApplyFreezeEffect(target);\n                break;\n            case WizardController.ElementType.Lightning:\n                ApplyShockEffect(target);\n                break;\n            case WizardController.ElementType.Earth:\n                ApplyKnockbackEffect(target);\n                break;\n        }\n    }\n\n    private void ApplyBurnEffect(Collider target)\n    {\n        // Apply damage over time\n        StartCoroutine(BurnDamage(target));\n    }\n\n    private void ApplyFreezeEffect(Collider target)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            targetRb.velocity *= 0.1f;\n        }\n    }\n\n    private void ApplyShockEffect(Collider target)\n    {\n        // Chain lightning to nearby enemies\n        Collider[] nearbyEnemies = Physics.OverlapSphere(target.transform.position, 5f);\n        foreach (Collider enemy in nearbyEnemies)\n        {\n            if (enemy != target && !enemy.CompareTag(\"Player\"))\n            {\n                // Apply reduced damage to chained targets\n            }\n        }\n    }\n\n    private void ApplyKnockbackEffect(Collider target)\n    {\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockback = (target.transform.position - transform.position).normalized * 10f;\n            targetRb.AddForce(knockback, ForceMode.Impulse);\n        }\n    }\n\n    private IEnumerator BurnDamage(Collider target)\n    {\n        for (int i = 0; i < 3; i++)\n        {\n            yield return new WaitForSeconds(1f);\n            if (target != null)\n            {\n                // Apply burn damage\n            }\n        }\n    }\n\n    private void CreateImpactEffect()\n    {\n        // Create particle effect based on element type\n        GameObject effect = new GameObject(\"Impact Effect\");\n        effect.transform.position = transform.position;\n        \n        ParticleSystem particles = effect.AddComponent<ParticleSystem>();\n        var main = particles.main;\n        \n        switch (_element)\n        {\n            case WizardController.ElementType.Fire:\n                main.startColor = Color.red;\n                break;\n            case WizardController.ElementType.Ice:\n                main.startColor = Color.cyan;\n                break;\n            case WizardController.ElementType.Lightning:\n                main.startColor = Color.yellow;\n                break;\n            case WizardController.ElementType.Earth:\n                main.startColor = Color.brown;\n                break;\n        }\n        \n        Destroy(effect, 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"UnderwaterBreathTimer\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxBreathTime\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"currentBreathTime\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"breathDepletionRate\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"breathRecoveryRate\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"isUnderwater\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lowBreathThreshold\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"deplete_breath_underwater\",\n      \"trigger\": \"when player is underwater\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current breath time over time\"\n        },\n        {\n          \"action\": \"prevent breath time from going below zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"recover_breath_above_water\",\n      \"trigger\": \"when player is above water\",\n      \"actions\": [\n        {\n          \"action\": \"increase current breath time over time\"\n        },\n        {\n          \"action\": \"prevent breath time from exceeding maximum breath time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"trigger_low_breath_warning\",\n      \"trigger\": \"when current breath time is below low breath threshold\",\n      \"actions\": [\n        {\n          \"action\": \"display low breath warning indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"trigger_drowning\",\n      \"trigger\": \"when current breath time reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"start drowning damage over time\"\n        },\n        {\n          \"action\": \"display critical breath warning\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_drowning\",\n      \"trigger\": \"when player surfaces and breath time is above zero\",\n      \"actions\": [\n        {\n          \"action\": \"stop drowning damage\"\n        },\n        {\n          \"action\": \"hide breath warning indicators\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class UnderwaterBreathTimer : MonoBehaviour\n{\n    [Header(\"Breath Settings\")]\n    [SerializeField] private float _maxBreathTime = 30f;\n    [SerializeField] private float _breathRecoveryRate = 2f;\n    [SerializeField] private float _breathDrainRate = 1f;\n    [SerializeField] private float _lowBreathThreshold = 0.3f;\n    \n    [Header(\"Water Detection\")]\n    [SerializeField] private string _waterTag = \"Water\";\n    [SerializeField] private Transform _breathCheckPoint;\n    [SerializeField] private LayerMask _waterLayerMask = -1;\n    [SerializeField] private float _checkRadius = 0.1f;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private Slider _breathBar;\n    [SerializeField] private Image _breathBarFill;\n    [SerializeField] private GameObject _breathUI;\n    [SerializeField] private Color _normalBreathColor = Color.blue;\n    [SerializeField] private Color _lowBreathColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _drowningSound;\n    [SerializeField] private AudioClip _gasping Sound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBreathDepleted;\n    public UnityEvent OnStartDrowning;\n    public UnityEvent OnStopDrowning;\n    public UnityEvent OnSurfaced;\n    public UnityEvent OnSubmerged;\n    \n    private float _currentBreathTime;\n    private bool _isUnderwater = false;\n    private bool _isDrowning = false;\n    private float _lastDamageTime;\n    private bool _wasUnderwater = false;\n    private Coroutine _breathingCoroutine;\n    \n    private void Start()\n    {\n        _currentBreathTime = _maxBreathTime;\n        \n        if (_breathCheckPoint == null)\n            _breathCheckPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        InitializeUI();\n    }\n    \n    private void Update()\n    {\n        CheckWaterStatus();\n        UpdateBreathTimer();\n        UpdateUI();\n        HandleAudio();\n    }\n    \n    private void CheckWaterStatus()\n    {\n        bool currentlyUnderwater = IsUnderwater();\n        \n        if (currentlyUnderwater != _wasUnderwater)\n        {\n            if (currentlyUnderwater)\n            {\n                OnSubmerged?.Invoke();\n                StartBreathing();\n            }\n            else\n            {\n                OnSurfaced?.Invoke();\n                StopBreathing();\n            }\n        }\n        \n        _isUnderwater = currentlyUnderwater;\n        _wasUnderwater = currentlyUnderwater;\n    }\n    \n    private bool IsUnderwater()\n    {\n        Collider[] waterColliders = Physics.OverlapSphere(_breathCheckPoint.position, _checkRadius, _waterLayerMask);\n        \n        foreach (Collider collider in waterColliders)\n        {\n            if (collider.CompareTag(_waterTag))\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void UpdateBreathTimer()\n    {\n        if (_isUnderwater)\n        {\n            _currentBreathTime -= _breathDrainRate * Time.deltaTime;\n            _currentBreathTime = Mathf.Max(0f, _currentBreathTime);\n            \n            if (_currentBreathTime <= 0f && !_isDrowning)\n            {\n                StartDrowning();\n            }\n        }\n        else\n        {\n            if (_isDrowning)\n            {\n                StopDrowning();\n            }\n            \n            _currentBreathTime += _breathRecoveryRate * Time.deltaTime;\n            _currentBreathTime = Mathf.Min(_maxBreathTime, _currentBreathTime);\n        }\n    }\n    \n    private void StartBreathing()\n    {\n        if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Play();\n        }\n    }\n    \n    private void StopBreathing()\n    {\n        if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n        {\n            _bubbleEffect.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_gaspingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_gaspingSound);\n        }\n    }\n    \n    private void StartDrowning()\n    {\n        _isDrowning = true;\n        _lastDamageTime = Time.time;\n        OnStartDrowning?.Invoke();\n        OnBreathDepleted?.Invoke();\n    }\n    \n    private void StopDrowning()\n    {\n        _isDrowning = false;\n        OnStopDrowning?.Invoke();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isDrowning && Time.time >= _lastDamageTime + _damageInterval)\n        {\n            ApplyDrowningDamage();\n            _lastDamageTime = Time.time;\n        }\n    }\n    \n    private void ApplyDrowningDamage()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            // Try to find health component\n            var healthComponent = player.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send damage message that can be received by any health system\n                player.SendMessage(\"TakeDamage\", _damageAmount, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void InitializeUI()\n    {\n        if (_breathBar != null)\n        {\n            _breathBar.maxValue = _maxBreathTime;\n            _breathBar.value = _currentBreathTime;\n        }\n        \n        if (_breathUI != null)\n        {\n            _breathUI.SetActive(false);\n        }\n        \n        UpdateBreathBarColor();\n    }\n    \n    private void UpdateUI()\n    {\n        if (_breathUI != null)\n        {\n            _breathUI.SetActive(_isUnderwater || _currentBreathTime < _maxBreathTime);\n        }\n        \n        if (_breathBar != null)\n        {\n            _breathBar.value = _currentBreathTime;\n        }\n        \n        UpdateBreathBarColor();\n    }\n    \n    private void UpdateBreathBarColor()\n    {\n        if (_breathBarFill != null)\n        {\n            float breathPercentage = _currentBreathTime / _maxBreathTime;\n            \n            if (breathPercentage <= _lowBreathThreshold)\n            {\n                _breathBarFill.color = Color.Lerp(_lowBreathColor, _normalBreathColor, \n                    breathPercentage / _lowBreathThreshold);\n            }\n            else\n            {\n                _breathBarFill.color = _normalBreathColor;\n            }\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null) return;\n        \n        if (_isDrowning && _drowningSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _drowningSound)\n            {\n                _audioSource.clip = _drowningSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        else if (_isUnderwater && _breathingSound != null)\n        {\n            if (!_audioSource.isPlaying || _audioSource.clip != _breathingSound)\n            {\n                _audioSource.clip = _breathingSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n        }\n        else if (!_isUnderwater && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public void AddBreathTime(float amount)\n    {\n        _currentBreathTime += amount;\n        _currentBreathTime = Mathf.Min(_maxBreathTime, _currentBreathTime);\n        \n        if (_isDrowning && _currentBreathTime > 0f)\n        {\n            StopDrowning();\n        }\n    }\n    \n    public void SetMaxBreathTime(float newMaxTime)\n    {\n        float ratio = _currentBreathTime / _maxBreathTime;\n        _maxBreathTime = newMaxTime;\n        _currentBreathTime = _maxBreathTime * ratio;\n        \n        if (_breathBar != null)\n        {\n            _breathBar.maxValue = _maxBreathTime;\n        }\n    }\n    \n    public float GetBreathPercentage()\n    {\n        return _currentBreathTime / _maxBreathTime;\n    }\n    \n    public bool IsCurrentlyDrowning()\n    {\n        return _isDrowning;\n    }\n    \n    public bool IsCurrentlyUnderwater()\n    {\n        return _isUnderwater;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_breathCheckPoint != null)\n        {\n            Gizmos.color = _isUnderwater ? Color.blue : Color.green;\n            Gizmos.DrawWireSphere(_breathCheckPoint.position, _checkRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PoleVaultJump\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"runSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"plantDistance\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"vaultHeight\",\n      \"type\": \"float\",\n      \"default\": 4.0\n    },\n    {\n      \"name\": \"poleLength\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isRunning\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hasPlantedPole\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isVaulting\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_run_up\",\n      \"trigger\": \"when jump input is pressed and player is on ground\",\n      \"actions\": [\n        {\n          \"action\": \"set running state to true\"\n        },\n        {\n          \"action\": \"begin running forward at run speed\"\n        },\n        {\n          \"action\": \"play running animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"plant_pole\",\n      \"trigger\": \"when running and within plant distance of target\",\n      \"actions\": [\n        {\n          \"action\": \"set pole planted state to true\"\n        },\n        {\n          \"action\": \"stop forward movement\"\n        },\n        {\n          \"action\": \"plant pole vertically into ground\"\n        },\n        {\n          \"action\": \"play pole plant animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"begin_vault\",\n      \"trigger\": \"when pole is planted and player contacts pole\",\n      \"actions\": [\n        {\n          \"action\": \"set vaulting state to true\"\n        },\n        {\n          \"action\": \"attach player to pole\"\n        },\n        {\n          \"action\": \"begin upward swing motion around pole\"\n        },\n        {\n          \"action\": \"play vault swing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_and_clear\",\n      \"trigger\": \"when vaulting and reached maximum height\",\n      \"actions\": [\n        {\n          \"action\": \"release from pole\"\n        },\n        {\n          \"action\": \"apply forward momentum over bar\"\n        },\n        {\n          \"action\": \"enter falling state\"\n        },\n        {\n          \"action\": \"play release animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_after_vault\",\n      \"trigger\": \"when falling and contacts landing surface\",\n      \"actions\": [\n        {\n          \"action\": \"reset all vault states to false\"\n        },\n        {\n          \"action\": \"play landing animation\"\n        },\n        {\n          \"action\": \"apply landing impact\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PoleVaultJump : MonoBehaviour\n{\n    [Header(\"Pole Vault Settings\")]\n    [SerializeField] private float _runSpeed = 8f;\n    [SerializeField] private float _poleLength = 4f;\n    [SerializeField] private float _vaultForce = 15f;\n    [SerializeField] private float _minRunDistance = 5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _gravity = -9.81f;\n    [SerializeField] private float _airDrag = 0.98f;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _runKey = KeyCode.W;\n    [SerializeField] private KeyCode _plantPoleKey = KeyCode.Space;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Space;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private Transform _poleTransform;\n    [SerializeField] private LineRenderer _poleRenderer;\n    [SerializeField] private Transform _playerModel;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRunStart;\n    public UnityEvent OnPoleVault;\n    public UnityEvent OnLanding;\n    \n    private Rigidbody _rigidbody;\n    private CapsuleCollider _collider;\n    private Vector3 _velocity;\n    private Vector3 _runStartPosition;\n    private Vector3 _poleContactPoint;\n    private bool _isRunning;\n    private bool _isPoleVaulting;\n    private bool _isPoleInGround;\n    private bool _isGrounded;\n    private float _runDistance;\n    private float _vaultAngle;\n    private VaultState _currentState;\n    \n    private enum VaultState\n    {\n        Idle,\n        Running,\n        PoleContact,\n        Vaulting,\n        Airborne,\n        Landing\n    }\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<CapsuleCollider>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<CapsuleCollider>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _currentState = VaultState.Idle;\n        \n        SetupPoleVisual();\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateGroundCheck();\n        UpdateState();\n        UpdatePoleVisual();\n    }\n    \n    void FixedUpdate()\n    {\n        ApplyPhysics();\n        UpdateMovement();\n    }\n    \n    void HandleInput()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Idle:\n                if (Input.GetKeyDown(_runKey))\n                {\n                    StartRun();\n                }\n                break;\n                \n            case VaultState.Running:\n                if (Input.GetKeyUp(_runKey))\n                {\n                    StopRun();\n                }\n                else if (Input.GetKeyDown(_plantPoleKey) && _runDistance >= _minRunDistance)\n                {\n                    PlantPole();\n                }\n                break;\n                \n            case VaultState.PoleContact:\n            case VaultState.Vaulting:\n                if (Input.GetKeyDown(_releaseKey))\n                {\n                    ReleasePole();\n                }\n                break;\n        }\n    }\n    \n    void UpdateGroundCheck()\n    {\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        _isGrounded = Physics.Raycast(rayStart, Vector3.down, _groundCheckDistance + 0.1f, _groundLayer);\n    }\n    \n    void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Running:\n                _runDistance = Vector3.Distance(_runStartPosition, transform.position);\n                if (!_isRunning)\n                {\n                    _currentState = VaultState.Idle;\n                }\n                break;\n                \n            case VaultState.Vaulting:\n                if (!_isPoleInGround)\n                {\n                    _currentState = VaultState.Airborne;\n                }\n                break;\n                \n            case VaultState.Airborne:\n                if (_isGrounded && _velocity.y <= 0)\n                {\n                    _currentState = VaultState.Landing;\n                    OnLanding?.Invoke();\n                }\n                break;\n                \n            case VaultState.Landing:\n                if (_velocity.magnitude < 0.5f)\n                {\n                    _currentState = VaultState.Idle;\n                }\n                break;\n        }\n    }\n    \n    void ApplyPhysics()\n    {\n        if (!_isGrounded || _currentState == VaultState.Vaulting || _currentState == VaultState.Airborne)\n        {\n            _velocity.y += _gravity * Time.fixedDeltaTime;\n            _velocity *= _airDrag;\n        }\n        else if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = 0;\n        }\n    }\n    \n    void UpdateMovement()\n    {\n        switch (_currentState)\n        {\n            case VaultState.Running:\n                Vector3 runDirection = transform.forward;\n                _velocity = runDirection * _runSpeed;\n                break;\n                \n            case VaultState.PoleContact:\n                CalculateVaultTrajectory();\n                break;\n                \n            case VaultState.Vaulting:\n                PerformVault();\n                break;\n        }\n        \n        if (_velocity.magnitude > 0.01f)\n        {\n            _rigidbody.velocity = _velocity;\n        }\n    }\n    \n    void StartRun()\n    {\n        _isRunning = true;\n        _currentState = VaultState.Running;\n        _runStartPosition = transform.position;\n        _runDistance = 0f;\n        OnRunStart?.Invoke();\n    }\n    \n    void StopRun()\n    {\n        _isRunning = false;\n        _velocity = Vector3.zero;\n    }\n    \n    void PlantPole()\n    {\n        Vector3 poleDirection = transform.forward;\n        Vector3 poleEndPosition = transform.position + poleDirection * _poleLength;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, poleDirection, out hit, _poleLength, _groundLayer))\n        {\n            _poleContactPoint = hit.point;\n            _isPoleInGround = true;\n            _currentState = VaultState.PoleContact;\n            \n            float distanceToContact = Vector3.Distance(transform.position, _poleContactPoint);\n            _vaultAngle = Mathf.Atan2(distanceToContact, transform.position.y - _poleContactPoint.y) * Mathf.Rad2Deg;\n        }\n    }\n    \n    void CalculateVaultTrajectory()\n    {\n        Vector3 directionToPole = (_poleContactPoint - transform.position).normalized;\n        float currentSpeed = _velocity.magnitude;\n        \n        Vector3 vaultDirection = Vector3.up + directionToPole;\n        vaultDirection.Normalize();\n        \n        _velocity = vaultDirection * (currentSpeed + _vaultForce * 0.5f);\n        _currentState = VaultState.Vaulting;\n        OnPoleVault?.Invoke();\n    }\n    \n    void PerformVault()\n    {\n        Vector3 toPole = _poleContactPoint - transform.position;\n        float distanceToPole = toPole.magnitude;\n        \n        if (distanceToPole > _poleLength * 1.2f)\n        {\n            ReleasePole();\n            return;\n        }\n        \n        Vector3 centripetal = toPole.normalized * (_velocity.magnitude * _velocity.magnitude / distanceToPole);\n        _velocity += centripetal * Time.fixedDeltaTime * 0.1f;\n        \n        Vector3 upwardForce = Vector3.up * _vaultForce * Time.fixedDeltaTime;\n        _velocity += upwardForce;\n    }\n    \n    void ReleasePole()\n    {\n        _isPoleInGround = false;\n        _currentState = VaultState.Airborne;\n        \n        Vector3 releaseBoost = Vector3.up * _vaultForce * 0.3f;\n        _velocity += releaseBoost;\n    }\n    \n    void SetupPoleVisual()\n    {\n        if (_poleRenderer == null && _poleTransform != null)\n        {\n            _poleRenderer = _poleTransform.GetComponent<LineRenderer>();\n            if (_poleRenderer == null)\n            {\n                _poleRenderer = _poleTransform.gameObject.AddComponent<LineRenderer>();\n            }\n        }\n        \n        if (_poleRenderer != null)\n        {\n            _poleRenderer.positionCount = 2;\n            _poleRenderer.startWidth = 0.05f;\n            _poleRenderer.endWidth = 0.02f;\n            _poleRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n            _poleRenderer.color = Color.brown;\n        }\n    }\n    \n    void UpdatePoleVisual()\n    {\n        if (_poleRenderer == null) return;\n        \n        bool showPole = _currentState == VaultState.PoleContact || _currentState == VaultState.Vaulting;\n        _poleRenderer.enabled = showPole;\n        \n        if (showPole && _isPoleInGround)\n        {\n            Vector3 handPosition = transform.position + Vector3.up * 1.8f;\n            _poleRenderer.SetPosition(0, handPosition);\n            _poleRenderer.SetPosition(1, _poleContactPoint);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _minRunDistance);\n        \n        if (_isPoleInGround)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawSphere(_poleContactPoint, 0.2f);\n            Gizmos.DrawLine(transform.position, _poleContactPoint);\n        }\n        \n        Gizmos.color = Color.blue;\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        Gizmos.DrawRay(rayStart, Vector3.down * (_groundCheckDistance + 0.1f));\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DepthOfFieldFocus\",\n  \"components\": [\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"focusDistance\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"focusSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"aperture\",\n      \"type\": \"float\",\n      \"default\": 5.6\n    },\n    {\n      \"name\": \"focalLength\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"autoFocus\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"focusTarget\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"auto_focus_on_target\",\n      \"trigger\": \"when auto focus is enabled and focus target exists\",\n      \"actions\": [\n        {\n          \"action\": \"calculate distance to focus target\"\n        },\n        {\n          \"action\": \"smoothly adjust focus distance to target distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"manual_focus_adjustment\",\n      \"trigger\": \"when auto focus is disabled\",\n      \"actions\": [\n        {\n          \"action\": \"maintain current focus distance setting\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_depth_of_field_effect\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"set camera depth of field focus distance\"\n        },\n        {\n          \"action\": \"apply aperture setting to depth of field\"\n        },\n        {\n          \"action\": \"apply focal length to depth of field calculation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"smooth_focus_transition\",\n      \"trigger\": \"when focus distance changes\",\n      \"actions\": [\n        {\n          \"action\": \"gradually interpolate from current focus to new focus distance\"\n        },\n        {\n          \"action\": \"use focus speed to control transition rate\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\npublic class DepthOfFieldFocus : MonoBehaviour\n{\n    [Header(\"Focus Settings\")]\n    [SerializeField] private Camera _targetCamera;\n    [SerializeField] private LayerMask _focusLayerMask = -1;\n    [SerializeField] private float _focusSpeed = 5f;\n    [SerializeField] private float _minFocusDistance = 0.1f;\n    [SerializeField] private float _maxFocusDistance = 100f;\n    [SerializeField] private float _defaultFocusDistance = 10f;\n    \n    [Header(\"Auto Focus\")]\n    [SerializeField] private bool _enableAutoFocus = true;\n    [SerializeField] private float _autoFocusUpdateRate = 0.1f;\n    [SerializeField] private Vector2 _screenCenter = new Vector2(0.5f, 0.5f);\n    \n    [Header(\"Manual Focus\")]\n    [SerializeField] private bool _enableManualFocus = false;\n    [SerializeField] private KeyCode _focusKey = KeyCode.F;\n    [SerializeField] private Transform _manualFocusTarget;\n    \n    [Header(\"Depth of Field Settings\")]\n    [SerializeField] private float _aperture = 5.6f;\n    [SerializeField] private float _focalLength = 50f;\n    [SerializeField] private int _bladeCount = 5;\n    [SerializeField] private float _bladeCurvature = 1f;\n    [SerializeField] private float _bladeRotation = 0f;\n    \n    private Volume _postProcessVolume;\n    private DepthOfField _depthOfField;\n    private float _currentFocusDistance;\n    private float _targetFocusDistance;\n    private float _lastAutoFocusTime;\n    private bool _isInitialized;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _currentFocusDistance = _defaultFocusDistance;\n        _targetFocusDistance = _defaultFocusDistance;\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_targetCamera == null)\n            _targetCamera = Camera.main;\n            \n        if (_targetCamera == null)\n            _targetCamera = FindObjectOfType<Camera>();\n            \n        if (_targetCamera == null)\n        {\n            Debug.LogError(\"DepthOfFieldFocus: No camera found!\");\n            return;\n        }\n        \n        _postProcessVolume = FindObjectOfType<Volume>();\n        \n        if (_postProcessVolume == null)\n        {\n            GameObject volumeGO = new GameObject(\"Post Process Volume\");\n            _postProcessVolume = volumeGO.AddComponent<Volume>();\n            _postProcessVolume.isGlobal = true;\n        }\n        \n        if (_postProcessVolume.profile == null)\n        {\n            _postProcessVolume.profile = ScriptableObject.CreateInstance<VolumeProfile>();\n        }\n        \n        if (!_postProcessVolume.profile.TryGet<DepthOfField>(out _depthOfField))\n        {\n            _depthOfField = _postProcessVolume.profile.Add<DepthOfField>(false);\n        }\n        \n        SetupDepthOfField();\n        _isInitialized = true;\n    }\n    \n    private void SetupDepthOfField()\n    {\n        if (_depthOfField == null) return;\n        \n        _depthOfField.mode.value = DepthOfFieldMode.Bokeh;\n        _depthOfField.focusDistance.value = _currentFocusDistance;\n        _depthOfField.aperture.value = _aperture;\n        _depthOfField.focalLength.value = _focalLength;\n        _depthOfField.bladeCount.value = _bladeCount;\n        _depthOfField.bladeCurvature.value = _bladeCurvature;\n        _depthOfField.bladeRotation.value = _bladeRotation;\n        _depthOfField.active = true;\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        HandleManualFocus();\n        HandleAutoFocus();\n        UpdateFocusDistance();\n        UpdateDepthOfField();\n    }\n    \n    private void HandleManualFocus()\n    {\n        if (!_enableManualFocus) return;\n        \n        if (Input.GetKeyDown(_focusKey))\n        {\n            if (_manualFocusTarget != null)\n            {\n                FocusOnTarget(_manualFocusTarget);\n            }\n            else\n            {\n                FocusOnScreenCenter();\n            }\n        }\n    }\n    \n    private void HandleAutoFocus()\n    {\n        if (!_enableAutoFocus) return;\n        \n        if (Time.time - _lastAutoFocusTime >= _autoFocusUpdateRate)\n        {\n            FocusOnScreenCenter();\n            _lastAutoFocusTime = Time.time;\n        }\n    }\n    \n    private void FocusOnScreenCenter()\n    {\n        Vector3 screenPoint = new Vector3(\n            _screenCenter.x * Screen.width,\n            _screenCenter.y * Screen.height,\n            0f\n        );\n        \n        Ray ray = _targetCamera.ScreenPointToRay(screenPoint);\n        \n        if (Physics.Raycast(ray, out RaycastHit hit, _maxFocusDistance, _focusLayerMask))\n        {\n            float distance = Vector3.Distance(_targetCamera.transform.position, hit.point);\n            SetTargetFocusDistance(distance);\n        }\n        else\n        {\n            SetTargetFocusDistance(_defaultFocusDistance);\n        }\n    }\n    \n    private void FocusOnTarget(Transform target)\n    {\n        if (target == null) return;\n        \n        float distance = Vector3.Distance(_targetCamera.transform.position, target.position);\n        SetTargetFocusDistance(distance);\n    }\n    \n    private void SetTargetFocusDistance(float distance)\n    {\n        _targetFocusDistance = Mathf.Clamp(distance, _minFocusDistance, _maxFocusDistance);\n    }\n    \n    private void UpdateFocusDistance()\n    {\n        if (Mathf.Abs(_currentFocusDistance - _targetFocusDistance) > 0.01f)\n        {\n            _currentFocusDistance = Mathf.Lerp(\n                _currentFocusDistance,\n                _targetFocusDistance,\n                _focusSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void UpdateDepthOfField()\n    {\n        if (_depthOfField == null) return;\n        \n        _depthOfField.focusDistance.value = _currentFocusDistance;\n        _depthOfField.aperture.value = _aperture;\n        _depthOfField.focalLength.value = _focalLength;\n        _depthOfField.bladeCount.value = _bladeCount;\n        _depthOfField.bladeCurvature.value = _bladeCurvature;\n        _depthOfField.bladeRotation.value = _bladeRotation;\n    }\n    \n    public void SetFocusDistance(float distance)\n    {\n        SetTargetFocusDistance(distance);\n    }\n    \n    public void SetAperture(float aperture)\n    {\n        _aperture = Mathf.Clamp(aperture, 1f, 32f);\n    }\n    \n    public void SetFocalLength(float focalLength)\n    {\n        _focalLength = Mathf.Clamp(focalLength, 1f, 300f);\n    }\n    \n    public void EnableAutoFocus(bool enable)\n    {\n        _enableAutoFocus = enable;\n    }\n    \n    public void SetManualFocusTarget(Transform target)\n    {\n        _manualFocusTarget = target;\n    }\n    \n    public float GetCurrentFocusDistance()\n    {\n        return _currentFocusDistance;\n    }\n    \n    private void OnValidate()\n    {\n        _aperture = Mathf.Clamp(_aperture, 1f, 32f);\n        _focalLength = Mathf.Clamp(_focalLength, 1f, 300f);\n        _focusSpeed = Mathf.Max(0.1f, _focusSpeed);\n        _minFocusDistance = Mathf.Max(0.1f, _minFocusDistance);\n        _maxFocusDistance = Mathf.Max(_minFocusDistance + 0.1f, _maxFocusDistance);\n        _defaultFocusDistance = Mathf.Clamp(_defaultFocusDistance, _minFocusDistance, _maxFocusDistance);\n        _autoFocusUpdateRate = Mathf.Max(0.01f, _autoFocusUpdateRate);\n        _screenCenter.x = Mathf.Clamp01(_screenCenter.x);\n        _screenCenter.y = Mathf.Clamp01(_screenCenter.y);\n        _bladeCount = Mathf.Clamp(_bladeCount, 3, 9);\n        _bladeCurvature = Mathf.Clamp01(_bladeCurvature);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_targetCamera == null) return;\n        \n        Gizmos.color = Color.yellow;\n        Vector3 cameraPos = _targetCamera.transform.position;\n        Vector3 forward = _targetCamera.transform.forward;\n        \n        // Draw focus distance\n        Vector3 focusPoint = cameraPos + forward * _currentFocusDistance;\n        Gizmos.DrawWireSphere(focusPoint, 0.5f);\n        \n        // Draw focus ray from screen center\n        Vector3 screenPoint = new Vector3(\n            _screenCenter.x * Screen.width,\n            _screenCenter.y * Screen.height,\n            0f\n        );\n        \n        Ray ray = _targetCamera.ScreenPointToRay(screenPoint);\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(ray.origin, ray.direction * _maxFocusDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GrabThrowEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"grabRange\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"holdDistance\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"grab_enemy\",\n      \"trigger\": \"when grab input is pressed and enemy is within grab range\",\n      \"actions\": [\n        {\n          \"action\": \"disable enemy movement and physics\"\n        },\n        {\n          \"action\": \"position enemy at hold distance in front of player\"\n        },\n        {\n          \"action\": \"set enemy as grabbed state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hold_enemy\",\n      \"trigger\": \"while enemy is in grabbed state\",\n      \"actions\": [\n        {\n          \"action\": \"keep enemy positioned at hold distance from player\"\n        },\n        {\n          \"action\": \"rotate enemy to face same direction as player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"throw_enemy\",\n      \"trigger\": \"when throw input is pressed and enemy is grabbed\",\n      \"actions\": [\n        {\n          \"action\": \"release enemy from grabbed state\"\n        },\n        {\n          \"action\": \"enable enemy physics\"\n        },\n        {\n          \"action\": \"apply throw force to enemy in forward direction\"\n        },\n        {\n          \"action\": \"clear grabbed enemy reference\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_on_distance\",\n      \"trigger\": \"when grabbed enemy gets too far from player\",\n      \"actions\": [\n        {\n          \"action\": \"automatically release enemy\"\n        },\n        {\n          \"action\": \"enable enemy physics and movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GrabThrowEnemy : MonoBehaviour\n{\n    [Header(\"Grab Settings\")]\n    [SerializeField] private float _grabRange = 2f;\n    [SerializeField] private LayerMask _enemyLayer = -1;\n    [SerializeField] private Transform _holdPosition;\n    [SerializeField] private float _grabForce = 10f;\n    \n    [Header(\"Throw Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _throwUpwardForce = 5f;\n    [SerializeField] private float _maxThrowDistance = 20f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _throwKey = KeyCode.Mouse0;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnEnemyGrabbed;\n    public UnityEvent<GameObject> OnEnemyThrown;\n    public UnityEvent<GameObject> OnEnemyReleased;\n    \n    private Camera _playerCamera;\n    private GameObject _grabbedEnemy;\n    private Rigidbody _grabbedRigidbody;\n    private Collider _grabbedCollider;\n    private bool _isGrabbing;\n    private Vector3 _originalGravity;\n    \n    [System.Serializable]\n    private class EnemyState\n    {\n        public bool wasKinematic;\n        public float originalDrag;\n        public float originalAngularDrag;\n        public RigidbodyConstraints originalConstraints;\n    }\n    \n    private EnemyState _enemyState = new EnemyState();\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_holdPosition == null)\n        {\n            GameObject holdPoint = new GameObject(\"HoldPosition\");\n            holdPoint.transform.SetParent(transform);\n            holdPoint.transform.localPosition = Vector3.forward * 2f;\n            _holdPosition = holdPoint.transform;\n        }\n        \n        _originalGravity = Physics.gravity;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        \n        if (_isGrabbing && _grabbedEnemy != null)\n        {\n            UpdateGrabbedEnemy();\n        }\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_grabKey))\n        {\n            if (!_isGrabbing)\n                TryGrabEnemy();\n            else\n                ReleaseEnemy();\n        }\n        \n        if (Input.GetKeyDown(_throwKey) && _isGrabbing)\n        {\n            ThrowEnemy();\n        }\n    }\n    \n    void TryGrabEnemy()\n    {\n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        if (Physics.Raycast(rayOrigin, rayDirection, out RaycastHit hit, _grabRange, _enemyLayer))\n        {\n            GameObject enemy = hit.collider.gameObject;\n            \n            if (enemy.CompareTag(\"Enemy\"))\n            {\n                GrabEnemy(enemy);\n            }\n        }\n    }\n    \n    void GrabEnemy(GameObject enemy)\n    {\n        _grabbedEnemy = enemy;\n        _grabbedRigidbody = enemy.GetComponent<Rigidbody>();\n        _grabbedCollider = enemy.GetComponent<Collider>();\n        \n        if (_grabbedRigidbody == null)\n        {\n            _grabbedRigidbody = enemy.AddComponent<Rigidbody>();\n        }\n        \n        // Store original state\n        _enemyState.wasKinematic = _grabbedRigidbody.isKinematic;\n        _enemyState.originalDrag = _grabbedRigidbody.drag;\n        _enemyState.originalAngularDrag = _grabbedRigidbody.angularDrag;\n        _enemyState.originalConstraints = _grabbedRigidbody.constraints;\n        \n        // Configure for grabbing\n        _grabbedRigidbody.isKinematic = false;\n        _grabbedRigidbody.drag = 10f;\n        _grabbedRigidbody.angularDrag = 5f;\n        _grabbedRigidbody.constraints = RigidbodyConstraints.FreezeRotation;\n        \n        // Disable enemy AI/movement components\n        MonoBehaviour[] enemyScripts = enemy.GetComponents<MonoBehaviour>();\n        foreach (MonoBehaviour script in enemyScripts)\n        {\n            if (script != this && script.enabled)\n            {\n                script.enabled = false;\n            }\n        }\n        \n        _isGrabbing = true;\n        OnEnemyGrabbed?.Invoke(_grabbedEnemy);\n    }\n    \n    void UpdateGrabbedEnemy()\n    {\n        if (_grabbedEnemy == null || _grabbedRigidbody == null)\n        {\n            ReleaseEnemy();\n            return;\n        }\n        \n        Vector3 targetPosition = _holdPosition.position;\n        Vector3 direction = targetPosition - _grabbedEnemy.transform.position;\n        \n        _grabbedRigidbody.velocity = direction * _grabForce;\n        \n        // Keep enemy at reasonable distance\n        float distance = Vector3.Distance(transform.position, _grabbedEnemy.transform.position);\n        if (distance > _maxThrowDistance)\n        {\n            ReleaseEnemy();\n        }\n    }\n    \n    void ThrowEnemy()\n    {\n        if (_grabbedEnemy == null || _grabbedRigidbody == null)\n            return;\n            \n        Vector3 throwDirection = _playerCamera.transform.forward;\n        Vector3 throwVelocity = throwDirection * _throwForce + Vector3.up * _throwUpwardForce;\n        \n        // Restore original state\n        _grabbedRigidbody.isKinematic = _enemyState.wasKinematic;\n        _grabbedRigidbody.drag = _enemyState.originalDrag;\n        _grabbedRigidbody.angularDrag = _enemyState.originalAngularDrag;\n        _grabbedRigidbody.constraints = _enemyState.originalConstraints;\n        \n        // Apply throw force\n        _grabbedRigidbody.velocity = throwVelocity;\n        \n        // Re-enable enemy scripts after a delay\n        StartCoroutine(ReenableEnemyScripts(_grabbedEnemy, 1f));\n        \n        OnEnemyThrown?.Invoke(_grabbedEnemy);\n        \n        _grabbedEnemy = null;\n        _grabbedRigidbody = null;\n        _grabbedCollider = null;\n        _isGrabbing = false;\n    }\n    \n    void ReleaseEnemy()\n    {\n        if (_grabbedEnemy == null)\n            return;\n            \n        if (_grabbedRigidbody != null)\n        {\n            // Restore original state\n            _grabbedRigidbody.isKinematic = _enemyState.wasKinematic;\n            _grabbedRigidbody.drag = _enemyState.originalDrag;\n            _grabbedRigidbody.angularDrag = _enemyState.originalAngularDrag;\n            _grabbedRigidbody.constraints = _enemyState.originalConstraints;\n            _grabbedRigidbody.velocity = Vector3.zero;\n        }\n        \n        // Re-enable enemy scripts\n        MonoBehaviour[] enemyScripts = _grabbedEnemy.GetComponents<MonoBehaviour>();\n        foreach (MonoBehaviour script in enemyScripts)\n        {\n            if (script != this)\n            {\n                script.enabled = true;\n            }\n        }\n        \n        OnEnemyReleased?.Invoke(_grabbedEnemy);\n        \n        _grabbedEnemy = null;\n        _grabbedRigidbody = null;\n        _grabbedCollider = null;\n        _isGrabbing = false;\n    }\n    \n    System.Collections.IEnumerator ReenableEnemyScripts(GameObject enemy, float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        \n        if (enemy != null)\n        {\n            MonoBehaviour[] enemyScripts = enemy.GetComponents<MonoBehaviour>();\n            foreach (MonoBehaviour script in enemyScripts)\n            {\n                if (script != this)\n                {\n                    script.enabled = true;\n                }\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(_playerCamera.transform.position, _playerCamera.transform.forward * _grabRange);\n        }\n        \n        if (_holdPosition != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPosition.position, 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingObject\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"basePitch\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"pitchRange\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_when_player_near\",\n      \"trigger\": \"when player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force at float speed\"\n        },\n        {\n          \"action\": \"rotate clockwise around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fall_when_player_far\",\n      \"trigger\": \"when player is outside detection range\",\n      \"actions\": [\n        {\n          \"action\": \"apply downward force at fall speed\"\n        },\n        {\n          \"action\": \"rotate counterclockwise around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_sound_pitch_rising\",\n      \"trigger\": \"when moving upward\",\n      \"actions\": [\n        {\n          \"action\": \"increase audio pitch above base pitch based on upward velocity\"\n        },\n        {\n          \"action\": \"play humming sound continuously\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_sound_pitch_falling\",\n      \"trigger\": \"when moving downward\",\n      \"actions\": [\n        {\n          \"action\": \"decrease audio pitch below base pitch based on downward velocity\"\n        },\n        {\n          \"action\": \"play humming sound continuously\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FloatingObject : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _fallSpeed = 4f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchRange = 0.5f;\n    [SerializeField] private float _pitchSmoothSpeed = 2f;\n    \n    [Header(\"References\")]\n    [SerializeField] private Transform _playerTransform;\n    \n    private Vector3 _startPosition;\n    private float _currentVerticalVelocity;\n    private float _targetPitch;\n    private bool _isPlayerNear;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.loop = true;\n            _audioSource.volume = 0.5f;\n        }\n        \n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n        \n        _audioSource.pitch = _basePitch;\n        if (!_audioSource.isPlaying)\n            _audioSource.Play();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerDistance();\n        HandleMovement();\n        HandleRotation();\n        HandleAudio();\n    }\n    \n    private void CheckPlayerDistance()\n    {\n        if (_playerTransform == null)\n            return;\n            \n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        _isPlayerNear = distance <= _detectionRange;\n    }\n    \n    private void HandleMovement()\n    {\n        if (_isPlayerNear)\n        {\n            _currentVerticalVelocity = _floatSpeed;\n        }\n        else\n        {\n            _currentVerticalVelocity = -_fallSpeed;\n        }\n        \n        Vector3 movement = Vector3.up * _currentVerticalVelocity * Time.deltaTime;\n        transform.Translate(movement, Space.World);\n    }\n    \n    private void HandleRotation()\n    {\n        float rotationDirection = _currentVerticalVelocity > 0 ? -1f : 1f;\n        float rotationAmount = rotationDirection * _rotationSpeed * Time.deltaTime;\n        transform.Rotate(0, 0, rotationAmount);\n    }\n    \n    private void HandleAudio()\n    {\n        if (_audioSource == null)\n            return;\n            \n        if (_currentVerticalVelocity > 0)\n        {\n            _targetPitch = _basePitch + _pitchRange;\n        }\n        else\n        {\n            _targetPitch = _basePitch - _pitchRange;\n        }\n        \n        _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, _targetPitch, _pitchSmoothSpeed * Time.deltaTime);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Shotgun\",\n  \"components\": [\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pelletCount\",\n      \"type\": \"int\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"spreadAngle\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"range\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"ammoCapacity\",\n      \"type\": \"int\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"currentAmmo\",\n      \"type\": \"int\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"muzzleFlashPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shotgunSoundClip\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_shotgun\",\n      \"trigger\": \"when fire input is pressed and weapon is ready and has ammo\",\n      \"actions\": [\n        {\n          \"action\": \"create multiple pellets in spread pattern around aim direction\"\n        },\n        {\n          \"action\": \"apply random angle variation to each pellet within spread cone\"\n        },\n        {\n          \"action\": \"fire all pellets simultaneously in their calculated directions\"\n        },\n        {\n          \"action\": \"deal damage to any targets hit by pellets within range\"\n        },\n        {\n          \"action\": \"play shotgun firing sound effect\"\n        },\n        {\n          \"action\": \"show muzzle flash particle effect\"\n        },\n        {\n          \"action\": \"reduce current ammo by one\"\n        },\n        {\n          \"action\": \"apply recoil effect to weapon\"\n        },\n        {\n          \"action\": \"start fire rate cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_weapon\",\n      \"trigger\": \"when reload input is pressed and current ammo is less than capacity\",\n      \"actions\": [\n        {\n          \"action\": \"start reload animation\"\n        },\n        {\n          \"action\": \"play reload sound effect\"\n        },\n        {\n          \"action\": \"disable firing during reload time\"\n        },\n        {\n          \"action\": \"restore ammo to full capacity after reload duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_reload\",\n      \"trigger\": \"when attempting to fire with no ammo remaining\",\n      \"actions\": [\n        {\n          \"action\": \"play empty chamber click sound\"\n        },\n        {\n          \"action\": \"automatically start reload sequence\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Shotgun : MonoBehaviour\n{\n    [Header(\"Shotgun Settings\")]\n    [SerializeField] private int _pelletsPerShot = 8;\n    [SerializeField] private float _damage = 15f;\n    [SerializeField] private float _range = 20f;\n    [SerializeField] private float _spreadAngle = 30f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private LineRenderer _tracerPrefab;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private float _tracerDuration = 0.1f;\n    \n    [Header(\"Ammo\")]\n    [SerializeField] private int _maxAmmo = 6;\n    [SerializeField] private int _currentAmmo = 6;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnFire;\n    public UnityEvent OnReload;\n    public UnityEvent OnEmpty;\n    \n    private Transform _firePoint;\n    private AudioSource _audioSource;\n    private float _lastFireTime;\n    private bool _isReloading;\n    private Camera _playerCamera;\n    \n    private void Start()\n    {\n        _firePoint = transform.Find(\"FirePoint\");\n        if (_firePoint == null)\n        {\n            GameObject firePointObj = new GameObject(\"FirePoint\");\n            firePointObj.transform.SetParent(transform);\n            firePointObj.transform.localPosition = Vector3.forward;\n            _firePoint = firePointObj.transform;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n        {\n            _playerCamera = FindObjectOfType<Camera>();\n        }\n        \n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    private void Update()\n    {\n        if (_isReloading) return;\n        \n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            TryFire();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && _currentAmmo < _maxAmmo)\n        {\n            StartReload();\n        }\n    }\n    \n    private void TryFire()\n    {\n        if (Time.time - _lastFireTime < 1f / _fireRate) return;\n        \n        if (_currentAmmo <= 0)\n        {\n            OnEmpty?.Invoke();\n            return;\n        }\n        \n        Fire();\n        _lastFireTime = Time.time;\n    }\n    \n    private void Fire()\n    {\n        _currentAmmo--;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnFire?.Invoke();\n        \n        PlayFireSound();\n        ShowMuzzleFlash();\n        \n        Vector3 fireDirection = _firePoint.forward;\n        if (_playerCamera != null)\n        {\n            fireDirection = _playerCamera.transform.forward;\n        }\n        \n        for (int i = 0; i < _pelletsPerShot; i++)\n        {\n            Vector3 spreadDirection = ApplySpread(fireDirection);\n            FirePellet(spreadDirection);\n        }\n    }\n    \n    private Vector3 ApplySpread(Vector3 baseDirection)\n    {\n        float halfSpread = _spreadAngle * 0.5f;\n        float randomX = Random.Range(-halfSpread, halfSpread);\n        float randomY = Random.Range(-halfSpread, halfSpread);\n        \n        Quaternion spreadRotation = Quaternion.Euler(randomX, randomY, 0);\n        return spreadRotation * baseDirection;\n    }\n    \n    private void FirePellet(Vector3 direction)\n    {\n        RaycastHit hit;\n        Vector3 startPoint = _firePoint.position;\n        \n        if (Physics.Raycast(startPoint, direction, out hit, _range, _targetLayers))\n        {\n            ProcessHit(hit);\n            CreateTracer(startPoint, hit.point);\n            CreateImpactEffect(hit.point, hit.normal);\n        }\n        else\n        {\n            Vector3 endPoint = startPoint + direction * _range;\n            CreateTracer(startPoint, endPoint);\n        }\n    }\n    \n    private void ProcessHit(RaycastHit hit)\n    {\n        Rigidbody hitRigidbody = hit.collider.GetComponent<Rigidbody>();\n        if (hitRigidbody != null)\n        {\n            Vector3 force = hit.normal * -_damage * 10f;\n            hitRigidbody.AddForceAtPosition(force, hit.point, ForceMode.Impulse);\n        }\n        \n        IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n        if (damageable != null)\n        {\n            damageable.TakeDamage(_damage);\n        }\n        \n        if (hit.collider.CompareTag(\"Enemy\"))\n        {\n            Destroy(hit.collider.gameObject);\n        }\n    }\n    \n    private void CreateTracer(Vector3 start, Vector3 end)\n    {\n        if (_tracerPrefab == null) return;\n        \n        LineRenderer tracer = Instantiate(_tracerPrefab);\n        tracer.positionCount = 2;\n        tracer.SetPosition(0, start);\n        tracer.SetPosition(1, end);\n        \n        Destroy(tracer.gameObject, _tracerDuration);\n    }\n    \n    private void CreateImpactEffect(Vector3 position, Vector3 normal)\n    {\n        if (_impactEffect == null) return;\n        \n        GameObject effect = Instantiate(_impactEffect, position, Quaternion.LookRotation(normal));\n        Destroy(effect, 2f);\n    }\n    \n    private void PlayFireSound()\n    {\n        if (_fireSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_fireSound, _volume);\n        }\n    }\n    \n    private void ShowMuzzleFlash()\n    {\n        if (_muzzleFlash != null)\n        {\n            _muzzleFlash.Play();\n        }\n    }\n    \n    private void StartReload()\n    {\n        if (_isReloading) return;\n        \n        _isReloading = true;\n        OnReload?.Invoke();\n        \n        if (_reloadSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_reloadSound, _volume);\n        }\n        \n        Invoke(nameof(CompleteReload), _reloadTime);\n    }\n    \n    private void CompleteReload()\n    {\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    public void AddAmmo(int amount)\n    {\n        _currentAmmo = Mathf.Min(_currentAmmo + amount, _maxAmmo);\n        OnAmmoChanged?.Invoke(_currentAmmo);\n    }\n    \n    public bool IsReloading => _isReloading;\n    public int CurrentAmmo => _currentAmmo;\n    public int MaxAmmo => _maxAmmo;\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AchievementTracker\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"totalScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"enemiesDefeated\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"itemsCollected\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"levelsCompleted\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"playtimeMinutes\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"achievementUnlocked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"firstKillAchievement\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"speedrunAchievement\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"collectorAchievement\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_score_increase\",\n      \"trigger\": \"when player gains points\",\n      \"actions\": [\n        {\n          \"action\": \"add points to total score\"\n        },\n        {\n          \"action\": \"check if high score achievement threshold is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_enemy_defeat\",\n      \"trigger\": \"when enemy is defeated by player\",\n      \"actions\": [\n        {\n          \"action\": \"increment enemies defeated counter\"\n        },\n        {\n          \"action\": \"unlock first kill achievement if this is the first enemy\"\n        },\n        {\n          \"action\": \"check if enemy slayer achievement threshold is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_item_collection\",\n      \"trigger\": \"when player collects an item\",\n      \"actions\": [\n        {\n          \"action\": \"increment items collected counter\"\n        },\n        {\n          \"action\": \"check if collector achievement threshold is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_level_completion\",\n      \"trigger\": \"when player completes a level\",\n      \"actions\": [\n        {\n          \"action\": \"increment levels completed counter\"\n        },\n        {\n          \"action\": \"check completion time for speedrun achievement\"\n        },\n        {\n          \"action\": \"check if level master achievement threshold is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_playtime\",\n      \"trigger\": \"every frame while game is active\",\n      \"actions\": [\n        {\n          \"action\": \"add elapsed time to total playtime\"\n        },\n        {\n          \"action\": \"check if dedication achievement threshold is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"unlock_achievement\",\n      \"trigger\": \"when achievement conditions are met\",\n      \"actions\": [\n        {\n          \"action\": \"mark achievement as unlocked\"\n        },\n        {\n          \"action\": \"display achievement notification to player\"\n        },\n        {\n          \"action\": \"save achievement progress to persistent storage\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class AchievementTracker : MonoBehaviour\n{\n    [System.Serializable]\n    public class Achievement\n    {\n        [Header(\"Achievement Info\")]\n        public string id;\n        public string title;\n        [TextArea(2, 4)]\n        public string description;\n        public Sprite icon;\n        public int targetValue;\n        public bool isUnlocked;\n        public bool isHidden;\n        \n        [Header(\"Progress\")]\n        public int currentValue;\n        public DateTime unlockedDate;\n        \n        public float Progress => targetValue > 0 ? Mathf.Clamp01((float)currentValue / targetValue) : 0f;\n        public bool IsCompleted => currentValue >= targetValue;\n    }\n\n    [System.Serializable]\n    public class AchievementEvent : UnityEvent<Achievement> { }\n\n    [Header(\"Achievement Settings\")]\n    [SerializeField] private List<Achievement> _achievements = new List<Achievement>();\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _savePrefix = \"Achievement_\";\n\n    [Header(\"Events\")]\n    public AchievementEvent OnAchievementUnlocked;\n    public AchievementEvent OnAchievementProgress;\n    public UnityEvent<int> OnTotalAchievementsChanged;\n\n    [Header(\"Statistics\")]\n    [SerializeField] private int _totalKills;\n    [SerializeField] private int _totalDeaths;\n    [SerializeField] private int _totalCoinsCollected;\n    [SerializeField] private float _totalPlayTime;\n    [SerializeField] private int _levelsCompleted;\n    [SerializeField] private int _enemiesDefeated;\n    [SerializeField] private float _distanceTraveled;\n\n    private Dictionary<string, Achievement> _achievementDict;\n    private float _sessionStartTime;\n\n    private void Awake()\n    {\n        _achievementDict = new Dictionary<string, Achievement>();\n        \n        foreach (var achievement in _achievements)\n        {\n            if (!string.IsNullOrEmpty(achievement.id))\n            {\n                _achievementDict[achievement.id] = achievement;\n            }\n        }\n    }\n\n    private void Start()\n    {\n        _sessionStartTime = Time.time;\n        \n        if (_saveToPlayerPrefs)\n        {\n            LoadAchievements();\n        }\n        \n        InitializeDefaultAchievements();\n    }\n\n    private void Update()\n    {\n        _totalPlayTime += Time.deltaTime;\n        UpdatePlayTimeAchievements();\n    }\n\n    private void InitializeDefaultAchievements()\n    {\n        if (_achievements.Count == 0)\n        {\n            AddDefaultAchievements();\n        }\n    }\n\n    private void AddDefaultAchievements()\n    {\n        var defaultAchievements = new List<Achievement>\n        {\n            new Achievement\n            {\n                id = \"first_kill\",\n                title = \"First Blood\",\n                description = \"Defeat your first enemy\",\n                targetValue = 1,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"kill_streak_10\",\n                title = \"Killing Spree\",\n                description = \"Defeat 10 enemies\",\n                targetValue = 10,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"coin_collector\",\n                title = \"Coin Collector\",\n                description = \"Collect 100 coins\",\n                targetValue = 100,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"survivor\",\n                title = \"Survivor\",\n                description = \"Play for 10 minutes without dying\",\n                targetValue = 600,\n                isHidden = false\n            },\n            new Achievement\n            {\n                id = \"explorer\",\n                title = \"Explorer\",\n                description = \"Travel 1000 units\",\n                targetValue = 1000,\n                isHidden = false\n            }\n        };\n\n        foreach (var achievement in defaultAchievements)\n        {\n            AddAchievement(achievement);\n        }\n    }\n\n    public void AddAchievement(Achievement achievement)\n    {\n        if (string.IsNullOrEmpty(achievement.id)) return;\n        \n        if (!_achievementDict.ContainsKey(achievement.id))\n        {\n            _achievements.Add(achievement);\n            _achievementDict[achievement.id] = achievement;\n        }\n    }\n\n    public void IncrementStat(string statName, int value = 1)\n    {\n        switch (statName.ToLower())\n        {\n            case \"kills\":\n            case \"enemies_defeated\":\n                _totalKills += value;\n                _enemiesDefeated += value;\n                CheckKillAchievements();\n                break;\n            case \"deaths\":\n                _totalDeaths += value;\n                break;\n            case \"coins\":\n            case \"coins_collected\":\n                _totalCoinsCollected += value;\n                CheckCoinAchievements();\n                break;\n            case \"levels_completed\":\n                _levelsCompleted += value;\n                CheckLevelAchievements();\n                break;\n        }\n    }\n\n    public void AddDistance(float distance)\n    {\n        _distanceTraveled += distance;\n        CheckDistanceAchievements();\n    }\n\n    public void UnlockAchievement(string achievementId)\n    {\n        if (_achievementDict.TryGetValue(achievementId, out Achievement achievement))\n        {\n            if (!achievement.isUnlocked)\n            {\n                achievement.isUnlocked = true;\n                achievement.unlockedDate = DateTime.Now;\n                achievement.currentValue = achievement.targetValue;\n                \n                OnAchievementUnlocked?.Invoke(achievement);\n                \n                if (_saveToPlayerPrefs)\n                {\n                    SaveAchievement(achievement);\n                }\n                \n                Debug.Log($\"Achievement Unlocked: {achievement.title}\");\n            }\n        }\n    }\n\n    public void UpdateAchievementProgress(string achievementId, int currentValue)\n    {\n        if (_achievementDict.TryGetValue(achievementId, out Achievement achievement))\n        {\n            if (!achievement.isUnlocked)\n            {\n                int previousValue = achievement.currentValue;\n                achievement.currentValue = currentValue;\n                \n                OnAchievementProgress?.Invoke(achievement);\n                \n                if (achievement.IsCompleted && !achievement.isUnlocked)\n                {\n                    UnlockAchievement(achievementId);\n                }\n                else if (_saveToPlayerPrefs && previousValue != currentValue)\n                {\n                    SaveAchievement(achievement);\n                }\n            }\n        }\n    }\n\n    private void CheckKillAchievements()\n    {\n        UpdateAchievementProgress(\"first_kill\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_10\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_50\", _totalKills);\n        UpdateAchievementProgress(\"kill_streak_100\", _totalKills);\n    }\n\n    private void CheckCoinAchievements()\n    {\n        UpdateAchievementProgress(\"coin_collector\", _totalCoinsCollected);\n        UpdateAchievementProgress(\"rich_player\", _totalCoinsCollected);\n    }\n\n    private void CheckLevelAchievements()\n    {\n        UpdateAchievementProgress(\"level_complete\", _levelsCompleted);\n        UpdateAchievementProgress(\"master_player\", _levelsCompleted);\n    }\n\n    private void CheckDistanceAchievements()\n    {\n        UpdateAchievementProgress(\"explorer\", Mathf.FloorToInt(_distanceTraveled));\n        UpdateAchievementProgress(\"marathon_runner\", Mathf.FloorToInt(_distanceTraveled));\n    }\n\n    private void UpdatePlayTimeAchievements()\n    {\n        UpdateAchievementProgress(\"survivor\", Mathf.FloorToInt(_totalPlayTime));\n        UpdateAchievementProgress(\"dedicated_player\", Mathf.FloorToInt(_totalPlayTime));\n    }\n\n    public Achievement GetAchievement(string achievementId)\n    {\n        _achievementDict.TryGetValue(achievementId, out Achievement achievement);\n        return achievement;\n    }\n\n    public List<Achievement> GetAllAchievements()\n    {\n        return new List<Achievement>(_achievements);\n    }\n\n    public List<Achievement> GetUnlockedAchievements()\n    {\n        return _achievements.FindAll(a => a.isUnlocked);\n    }\n\n    public List<Achievement> GetLockedAchievements()\n    {\n        return _achievements.FindAll(a => !a.isUnlocked && !a.isHidden);\n    }\n\n    public int GetUnlockedCount()\n    {\n        return _achievements.FindAll(a => a.isUnlocked).Count;\n    }\n\n    public float GetCompletionPercentage()\n    {\n        if (_achievements.Count == 0) return 0f;\n        return (float)GetUnlockedCount() / _achievements.Count * 100f;\n    }\n\n    private void SaveAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            SaveAchievement(achievement);\n        }\n        \n        PlayerPrefs.SetInt(_savePrefix + \"TotalKills\", _totalKills);\n        PlayerPrefs.SetInt(_savePrefix + \"TotalDeaths\", _totalDeaths);\n        PlayerPrefs.SetInt(_savePrefix + \"TotalCoins\", _totalCoinsCollected);\n        PlayerPrefs.SetFloat(_savePrefix + \"TotalPlayTime\", _totalPlayTime);\n        PlayerPrefs.SetInt(_savePrefix + \"LevelsCompleted\", _levelsCompleted);\n        PlayerPrefs.SetFloat(_savePrefix + \"DistanceTraveled\", _distanceTraveled);\n        \n        PlayerPrefs.Save();\n    }\n\n    private void SaveAchievement(Achievement achievement)\n    {\n        string prefix = _savePrefix + achievement.id + \"_\";\n        PlayerPrefs.SetInt(prefix + \"Unlocked\", achievement.isUnlocked ? 1 : 0);\n        PlayerPrefs.SetInt(prefix + \"CurrentValue\", achievement.currentValue);\n        \n        if (achievement.isUnlocked)\n        {\n            PlayerPrefs.SetString(prefix + \"UnlockedDate\", achievement.unlockedDate.ToBinary().ToString());\n        }\n    }\n\n    private void LoadAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            LoadAchievement(achievement);\n        }\n        \n        _totalKills = PlayerPrefs.GetInt(_savePrefix + \"TotalKills\", 0);\n        _totalDeaths = PlayerPrefs.GetInt(_savePrefix + \"TotalDeaths\", 0);\n        _totalCoinsCollected = PlayerPrefs.GetInt(_savePrefix + \"TotalCoins\", 0);\n        _totalPlayTime = PlayerPrefs.GetFloat(_savePrefix + \"TotalPlayTime\", 0f);\n        _levelsCompleted = PlayerPrefs.GetInt(_savePrefix + \"LevelsCompleted\", 0);\n        _distanceTraveled = PlayerPrefs.GetFloat(_savePrefix + \"DistanceTraveled\", 0f);\n    }\n\n    private void LoadAchievement(Achievement achievement)\n    {\n        string prefix = _savePrefix + achievement.id + \"_\";\n        achievement.isUnlocked = PlayerPrefs.GetInt(prefix + \"Unlocked\", 0) == 1;\n        achievement.currentValue = PlayerPrefs.GetInt(prefix + \"CurrentValue\", 0);\n        \n        if (achievement.isUnlocked)\n        {\n            string dateString = PlayerPrefs.GetString(prefix + \"UnlockedDate\", \"\");\n            if (!string.IsNullOrEmpty(dateString) && long.TryParse(dateString, out long dateBinary))\n            {\n                achievement.unlockedDate = DateTime.FromBinary(dateBinary);\n            }\n        }\n    }\n\n    public void ResetAllAchievements()\n    {\n        foreach (var achievement in _achievements)\n        {\n            achievement.isUnlocked = false;\n            achievement.currentValue = 0;\n            achievement.unlockedDate = default(DateTime);\n        }\n        \n        _totalKills = 0;\n        _totalDeaths = 0;\n        _totalCoinsCollected = 0;\n        _totalPlayTime = 0f;\n        _levelsCompleted = 0;\n        _distanceTraveled = 0f;\n        \n        if (_saveToPlayerPrefs)\n        {\n            ClearSavedData();\n        }\n    }\n\n    private void ClearSavedData()\n    {\n        foreach (var achievement in _achievements)\n        {\n            string prefix = _savePrefix + achievement.id + \"_\";\n            PlayerPrefs.DeleteKey(prefix + \"Unlocked\");\n            PlayerPrefs.DeleteKey(prefix + \"CurrentValue\");\n            PlayerPrefs.DeleteKey(prefix + \"UnlockedDate\");\n        }\n        \n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalKills\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalDeaths\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalCoins\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"TotalPlayTime\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"LevelsCompleted\");\n        PlayerPrefs.DeleteKey(_savePrefix + \"DistanceTraveled\");\n        \n        PlayerPrefs.Save();\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus && _saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            SaveAchievements();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExperienceOrb\",\n  \"components\": [\n    \"Rigidbody\",\n    \"SphereCollider\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"experienceValue\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"attractionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"bobSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"bobHeight\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"lifeTime\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_and_glow\",\n      \"trigger\": \"when orb exists in the world\",\n      \"actions\": [\n        {\n          \"action\": \"gently bob up and down at bob speed and height\"\n        },\n        {\n          \"action\": \"emit soft glowing light with glow intensity\"\n        },\n        {\n          \"action\": \"slowly rotate around vertical axis\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attract_to_player\",\n      \"trigger\": \"when player enters attraction range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at move speed\"\n        },\n        {\n          \"action\": \"increase glow intensity as getting closer to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"grant_experience\",\n      \"trigger\": \"when touching player\",\n      \"actions\": [\n        {\n          \"action\": \"add experience value to player experience points\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"spawn particle effect at orb position\"\n        },\n        {\n          \"action\": \"destroy this orb\"\n        }\n      ]\n    },\n    {\n      \"name\": \"expire_over_time\",\n      \"trigger\": \"when orb has existed for life time duration\",\n      \"actions\": [\n        {\n          \"action\": \"fade out gradually over short duration\"\n        },\n        {\n          \"action\": \"destroy this orb\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExperienceOrb : MonoBehaviour\n{\n    [Header(\"Experience Settings\")]\n    [SerializeField] private int _experienceValue = 10;\n    [SerializeField] private float _attractionRange = 5f;\n    [SerializeField] private float _attractionSpeed = 8f;\n    [SerializeField] private float _collectDistance = 0.5f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.3f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private AnimationCurve _attractionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectVolume = 0.7f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _lifeTime = 30f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnExperienceCollected;\n    \n    private Transform _player;\n    private Vector3 _startPosition;\n    private bool _isBeingAttracted = false;\n    private bool _isCollected = false;\n    private float _bobTimer = 0f;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _bobTimer = Random.Range(0f, Mathf.PI * 2f);\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        _rigidbody.useGravity = false;\n        _rigidbody.isKinematic = true;\n        \n        _collider = GetComponent<Collider>();\n        if (_collider == null)\n        {\n            SphereCollider sphereCollider = gameObject.AddComponent<SphereCollider>();\n            sphereCollider.isTrigger = true;\n            sphereCollider.radius = 0.5f;\n            _collider = sphereCollider;\n        }\n        _collider.isTrigger = true;\n        \n        if (_lifeTime > 0f)\n        {\n            Destroy(gameObject, _lifeTime);\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        if (_player == null)\n        {\n            FindPlayer();\n        }\n        \n        HandleMovement();\n        HandleVisualEffects();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attractionRange && !_isBeingAttracted)\n        {\n            _isBeingAttracted = true;\n        }\n        \n        if (_isBeingAttracted)\n        {\n            Vector3 directionToPlayer = (_player.position - transform.position).normalized;\n            float attractionForce = _attractionCurve.Evaluate(1f - (distanceToPlayer / _attractionRange));\n            \n            transform.position = Vector3.MoveTowards(\n                transform.position,\n                _player.position,\n                _attractionSpeed * attractionForce * Time.deltaTime\n            );\n            \n            if (distanceToPlayer <= _collectDistance)\n            {\n                CollectOrb();\n            }\n        }\n        else\n        {\n            _bobTimer += Time.deltaTime * _bobSpeed;\n            Vector3 bobOffset = Vector3.up * Mathf.Sin(_bobTimer) * _bobHeight;\n            transform.position = _startPosition + bobOffset;\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectOrb();\n        }\n    }\n    \n    private void CollectOrb()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        \n        OnExperienceCollected?.Invoke(_experienceValue);\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.volume = _collectVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, Quaternion.identity);\n            \n            ParticleSystem particles = effect.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                Destroy(effect, particles.main.duration + particles.main.startLifetime.constantMax);\n            }\n            else\n            {\n                Destroy(effect, 2f);\n            }\n        }\n    }\n    \n    public void SetExperienceValue(int value)\n    {\n        _experienceValue = Mathf.Max(0, value);\n    }\n    \n    public int GetExperienceValue()\n    {\n        return _experienceValue;\n    }\n    \n    public void SetAttractionRange(float range)\n    {\n        _attractionRange = Mathf.Max(0f, range);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attractionRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _collectDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GlowingCrystal\",\n  \"components\": [\n    \"Light\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxGlowIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"glowSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"glow_when_player_near\",\n      \"trigger\": \"when player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"increase light intensity based on proximity to player\"\n        },\n        {\n          \"action\": \"make crystal material more emissive based on proximity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dim_when_player_far\",\n      \"trigger\": \"when player moves outside detection range\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease light intensity to zero\"\n        },\n        {\n          \"action\": \"reduce crystal material emission to normal state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_glow_effect\",\n      \"trigger\": \"when crystal is actively glowing\",\n      \"actions\": [\n        {\n          \"action\": \"create subtle pulsing effect with light intensity\"\n        },\n        {\n          \"action\": \"add gentle color shifting to the glow\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class GlowingCrystal : MonoBehaviour\n{\n    [Header(\"Glow Settings\")]\n    [SerializeField] private float _glowDistance = 5f;\n    [SerializeField] private float _maxGlowIntensity = 2f;\n    [SerializeField] private float _minGlowIntensity = 0.1f;\n    [SerializeField] private Color _glowColor = Color.cyan;\n    [SerializeField] private float _glowSpeed = 2f;\n    \n    [Header(\"Pulse Settings\")]\n    [SerializeField] private bool _enablePulse = true;\n    [SerializeField] private float _pulseSpeed = 1f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _glowSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private Light _crystalLight;\n    private Renderer _crystalRenderer;\n    private Material _crystalMaterial;\n    private AudioSource _audioSource;\n    private Transform _player;\n    private bool _isGlowing = false;\n    private float _baseIntensity;\n    private Color _originalEmissionColor;\n    private float _currentGlowIntensity;\n    \n    void Start()\n    {\n        SetupComponents();\n        FindPlayer();\n        InitializeMaterial();\n    }\n    \n    void Update()\n    {\n        if (_player != null)\n        {\n            UpdateGlow();\n        }\n        else\n        {\n            FindPlayer();\n        }\n    }\n    \n    void SetupComponents()\n    {\n        _crystalLight = GetComponent<Light>();\n        if (_crystalLight == null)\n        {\n            _crystalLight = gameObject.AddComponent<Light>();\n            _crystalLight.type = LightType.Point;\n            _crystalLight.color = _glowColor;\n            _crystalLight.intensity = _minGlowIntensity;\n            _crystalLight.range = _glowDistance * 1.5f;\n        }\n        \n        _baseIntensity = _crystalLight.intensity;\n        _currentGlowIntensity = _minGlowIntensity;\n        \n        _crystalRenderer = GetComponent<Renderer>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        _audioSource.clip = _glowSound;\n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.loop = true;\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void InitializeMaterial()\n    {\n        if (_crystalRenderer != null)\n        {\n            _crystalMaterial = _crystalRenderer.material;\n            if (_crystalMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _originalEmissionColor = _crystalMaterial.GetColor(\"_EmissionColor\");\n            }\n        }\n    }\n    \n    void UpdateGlow()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        float normalizedDistance = Mathf.Clamp01(distanceToPlayer / _glowDistance);\n        float glowFactor = 1f - normalizedDistance;\n        \n        bool shouldGlow = distanceToPlayer <= _glowDistance;\n        \n        if (shouldGlow && !_isGlowing)\n        {\n            StartGlowing();\n        }\n        else if (!shouldGlow && _isGlowing)\n        {\n            StopGlowing();\n        }\n        \n        if (shouldGlow)\n        {\n            UpdateGlowIntensity(glowFactor);\n        }\n    }\n    \n    void StartGlowing()\n    {\n        _isGlowing = true;\n        \n        if (_glowSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    void StopGlowing()\n    {\n        _isGlowing = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        _currentGlowIntensity = Mathf.Lerp(_currentGlowIntensity, _minGlowIntensity, Time.deltaTime * _glowSpeed);\n        UpdateLightAndMaterial();\n    }\n    \n    void UpdateGlowIntensity(float glowFactor)\n    {\n        float targetIntensity = Mathf.Lerp(_minGlowIntensity, _maxGlowIntensity, glowFactor);\n        \n        if (_enablePulse)\n        {\n            float pulseOffset = Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n            targetIntensity += pulseOffset * glowFactor;\n        }\n        \n        _currentGlowIntensity = Mathf.Lerp(_currentGlowIntensity, targetIntensity, Time.deltaTime * _glowSpeed);\n        UpdateLightAndMaterial();\n    }\n    \n    void UpdateLightAndMaterial()\n    {\n        if (_crystalLight != null)\n        {\n            _crystalLight.intensity = _currentGlowIntensity;\n            _crystalLight.color = _glowColor;\n        }\n        \n        if (_crystalMaterial != null && _crystalMaterial.HasProperty(\"_EmissionColor\"))\n        {\n            Color emissionColor = _glowColor * _currentGlowIntensity;\n            _crystalMaterial.SetColor(\"_EmissionColor\", emissionColor);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _glowColor;\n        Gizmos.DrawWireSphere(transform.position, _glowDistance);\n    }\n    \n    void OnDestroy()\n    {\n        if (_crystalMaterial != null)\n        {\n            if (_crystalMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _crystalMaterial.SetColor(\"_EmissionColor\", _originalEmissionColor);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GroundSlamHammer\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slamForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"slamRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"slamDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"slamCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"isSlammingDown\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canSlam\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_ground_slam\",\n      \"trigger\": \"when player presses slam input button and hammer can slam\",\n      \"actions\": [\n        {\n          \"action\": \"set hammer to slamming down state\"\n        },\n        {\n          \"action\": \"disable further slam inputs\"\n        },\n        {\n          \"action\": \"apply strong downward force to hammer\"\n        },\n        {\n          \"action\": \"play slam charging sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"impact_ground\",\n      \"trigger\": \"when hammer collides with ground while slamming down\",\n      \"actions\": [\n        {\n          \"action\": \"create shockwave effect at impact point\"\n        },\n        {\n          \"action\": \"deal damage to all enemies within slam radius\"\n        },\n        {\n          \"action\": \"knock back all objects within slam radius\"\n        },\n        {\n          \"action\": \"create screen shake effect\"\n        },\n        {\n          \"action\": \"play loud impact sound effect\"\n        },\n        {\n          \"action\": \"spawn dust and debris particles\"\n        },\n        {\n          \"action\": \"stop slamming down state\"\n        },\n        {\n          \"action\": \"start slam cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_slam_ability\",\n      \"trigger\": \"when slam cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"enable slam input again\"\n        },\n        {\n          \"action\": \"reset hammer to ready state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Hammer : MonoBehaviour\n{\n    [Header(\"Hammer Settings\")]\n    [SerializeField] private float _slamForce = 20f;\n    [SerializeField] private float _slamRadius = 5f;\n    [SerializeField] private float _slamDamage = 50f;\n    [SerializeField] private float _slamCooldown = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _raiseHeight = 2f;\n    [SerializeField] private float _raiseSpeed = 5f;\n    [SerializeField] private float _slamSpeed = 15f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _slamEffectPrefab;\n    [SerializeField] private AudioClip _slamSound;\n    [SerializeField] private float _cameraShakeIntensity = 0.5f;\n    [SerializeField] private float _cameraShakeDuration = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSlamStart;\n    public UnityEvent OnSlamHit;\n    public UnityEvent<float> OnCooldownChanged;\n    \n    private Vector3 _originalPosition;\n    private bool _isSlaming = false;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private AudioSource _audioSource;\n    private Camera _mainCamera;\n    \n    private enum HammerState\n    {\n        Idle,\n        Raising,\n        Slamming,\n        Cooldown\n    }\n    \n    private HammerState _currentState = HammerState.Idle;\n    \n    void Start()\n    {\n        _originalPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n    }\n    \n    void Update()\n    {\n        HandleCooldown();\n        HandleInput();\n        UpdateHammerMovement();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            OnCooldownChanged?.Invoke(_cooldownTimer / _slamCooldown);\n            \n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                _currentState = HammerState.Idle;\n            }\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && CanSlam())\n        {\n            StartSlam();\n        }\n    }\n    \n    private bool CanSlam()\n    {\n        return _currentState == HammerState.Idle && !_isOnCooldown;\n    }\n    \n    private void StartSlam()\n    {\n        _currentState = HammerState.Raising;\n        _isSlaming = true;\n        OnSlamStart?.Invoke();\n    }\n    \n    private void UpdateHammerMovement()\n    {\n        switch (_currentState)\n        {\n            case HammerState.Raising:\n                HandleRaising();\n                break;\n            case HammerState.Slamming:\n                HandleSlamming();\n                break;\n        }\n    }\n    \n    private void HandleRaising()\n    {\n        Vector3 targetPosition = _originalPosition + Vector3.up * _raiseHeight;\n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _raiseSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.1f)\n        {\n            _currentState = HammerState.Slamming;\n        }\n    }\n    \n    private void HandleSlamming()\n    {\n        transform.position = Vector3.MoveTowards(transform.position, _originalPosition, _slamSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, _originalPosition) < 0.1f)\n        {\n            ExecuteSlam();\n            transform.position = _originalPosition;\n            _currentState = HammerState.Cooldown;\n            _isSlaming = false;\n            _isOnCooldown = true;\n            _cooldownTimer = _slamCooldown;\n        }\n    }\n    \n    private void ExecuteSlam()\n    {\n        // Create slam effect\n        if (_slamEffectPrefab != null)\n        {\n            Instantiate(_slamEffectPrefab, _originalPosition, Quaternion.identity);\n        }\n        \n        // Play slam sound\n        if (_slamSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_slamSound);\n        }\n        \n        // Camera shake\n        if (_mainCamera != null)\n        {\n            StartCoroutine(CameraShake());\n        }\n        \n        // Find and damage targets\n        Collider[] hitColliders = Physics.OverlapSphere(_originalPosition, _slamRadius, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Apply damage to objects with health\n            var healthComponent = hitCollider.GetComponent<IDamageable>();\n            if (healthComponent != null)\n            {\n                healthComponent.TakeDamage(_slamDamage);\n            }\n            \n            // Apply knockback force\n            Rigidbody rb = hitCollider.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 forceDirection = (hitCollider.transform.position - _originalPosition).normalized;\n                forceDirection.y = 0.5f; // Add upward force\n                rb.AddForce(forceDirection * _slamForce, ForceMode.Impulse);\n            }\n            \n            // Trigger player-specific effects\n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                // Additional player effects can be added here\n                OnSlamHit?.Invoke();\n            }\n        }\n        \n        OnSlamHit?.Invoke();\n    }\n    \n    private System.Collections.IEnumerator CameraShake()\n    {\n        Vector3 originalPosition = _mainCamera.transform.position;\n        float elapsed = 0f;\n        \n        while (elapsed < _cameraShakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _cameraShakeIntensity;\n            float y = Random.Range(-1f, 1f) * _cameraShakeIntensity;\n            \n            _mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.position = originalPosition;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw slam radius\n        Gizmos.color = Color.red;\n        Vector3 center = Application.isPlaying ? _originalPosition : transform.position;\n        Gizmos.DrawWireSphere(center, _slamRadius);\n        \n        // Draw raise height\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(center, center + Vector3.up * _raiseHeight);\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n    \n    public bool IsOnCooldown => _isOnCooldown;\n    public float CooldownProgress => _isOnCooldown ? _cooldownTimer / _slamCooldown : 0f;\n    public bool IsSlaming => _isSlaming;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"UnderwaterBubbleEffects\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"bubbleSpawnRate\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"bubbleSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"maxBubbles\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"bubbleLifetime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"spawnRadius\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"surfaceHeight\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"bubblePopSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"ambientBubbleSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_bubbles_continuously\",\n      \"trigger\": \"when underwater effect is active\",\n      \"actions\": [\n        {\n          \"action\": \"spawn bubbles at random positions within spawn radius\"\n        },\n        {\n          \"action\": \"vary bubble sizes randomly\"\n        },\n        {\n          \"action\": \"set bubble transparency to semi-transparent\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_bubble_movement\",\n      \"trigger\": \"when bubbles exist in scene\",\n      \"actions\": [\n        {\n          \"action\": \"move bubbles upward toward surface\"\n        },\n        {\n          \"action\": \"add slight wobbling motion to bubbles\"\n        },\n        {\n          \"action\": \"gradually increase bubble speed as they rise\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_surface_interaction\",\n      \"trigger\": \"when bubble reaches surface height\",\n      \"actions\": [\n        {\n          \"action\": \"play bubble pop sound effect\"\n        },\n        {\n          \"action\": \"create small splash particle effect\"\n        },\n        {\n          \"action\": \"destroy bubble particle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"manage_bubble_lifetime\",\n      \"trigger\": \"when bubble exceeds maximum lifetime\",\n      \"actions\": [\n        {\n          \"action\": \"fade out bubble gradually\"\n        },\n        {\n          \"action\": \"remove bubble from scene\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_ambient_sounds\",\n      \"trigger\": \"when underwater bubble effects are active\",\n      \"actions\": [\n        {\n          \"action\": \"play looping ambient bubble sounds\"\n        },\n        {\n          \"action\": \"adjust sound volume based on bubble density\"\n        }\n      ]\n    },\n    {\n      \"name\": \"limit_bubble_count\",\n      \"trigger\": \"when bubble count exceeds maximum limit\",\n      \"actions\": [\n        {\n          \"action\": \"stop spawning new bubbles temporarily\"\n        },\n        {\n          \"action\": \"remove oldest bubbles first\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class UnderwaterBubbleEffects : MonoBehaviour\n{\n    [Header(\"Bubble Generation\")]\n    [SerializeField] private GameObject _bubblePrefab;\n    [SerializeField] private int _maxBubbles = 50;\n    [SerializeField] private float _bubbleSpawnRate = 2f;\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(10f, 1f, 10f);\n    [SerializeField] private float _bubbleLifetime = 8f;\n    \n    [Header(\"Bubble Movement\")]\n    [SerializeField] private float _minRiseSpeed = 1f;\n    [SerializeField] private float _maxRiseSpeed = 3f;\n    [SerializeField] private float _horizontalDriftStrength = 0.5f;\n    [SerializeField] private float _wavyMotionFrequency = 1f;\n    [SerializeField] private float _wavyMotionAmplitude = 0.3f;\n    \n    [Header(\"Bubble Appearance\")]\n    [SerializeField] private float _minBubbleSize = 0.1f;\n    [SerializeField] private float _maxBubbleSize = 0.5f;\n    [SerializeField] private AnimationCurve _sizeOverLifetime = AnimationCurve.Linear(0f, 1f, 1f, 0.8f);\n    [SerializeField] private AnimationCurve _alphaOverLifetime = AnimationCurve.EaseInOut(0f, 0f, 0.2f, 1f);\n    \n    [Header(\"Water Surface\")]\n    [SerializeField] private float _waterSurfaceY = 5f;\n    [SerializeField] private bool _popAtSurface = true;\n    [SerializeField] private GameObject _popEffectPrefab;\n    \n    [Header(\"Player Interaction\")]\n    [SerializeField] private bool _reactToPlayer = true;\n    [SerializeField] private float _playerDetectionRadius = 3f;\n    [SerializeField] private float _playerAvoidanceStrength = 2f;\n    \n    private List<BubbleData> _activeBubbles = new List<BubbleData>();\n    private float _nextSpawnTime;\n    private Transform _playerTransform;\n    \n    [System.Serializable]\n    private class BubbleData\n    {\n        public GameObject gameObject;\n        public Transform transform;\n        public Renderer renderer;\n        public float spawnTime;\n        public float riseSpeed;\n        public float initialSize;\n        public Vector3 driftDirection;\n        public float wavyOffset;\n        public Material material;\n        public Color originalColor;\n    }\n    \n    private void Start()\n    {\n        if (_bubblePrefab == null)\n        {\n            CreateDefaultBubblePrefab();\n        }\n        \n        FindPlayer();\n        _nextSpawnTime = Time.time + (1f / _bubbleSpawnRate);\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _nextSpawnTime && _activeBubbles.Count < _maxBubbles)\n        {\n            SpawnBubble();\n            _nextSpawnTime = Time.time + (1f / _bubbleSpawnRate);\n        }\n        \n        UpdateBubbles();\n        CleanupBubbles();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void SpawnBubble()\n    {\n        Vector3 spawnPosition = transform.position + new Vector3(\n            Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f),\n            Random.Range(-_spawnAreaSize.y * 0.5f, _spawnAreaSize.y * 0.5f),\n            Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f)\n        );\n        \n        GameObject bubbleObj = Instantiate(_bubblePrefab, spawnPosition, Quaternion.identity);\n        \n        BubbleData bubble = new BubbleData\n        {\n            gameObject = bubbleObj,\n            transform = bubbleObj.transform,\n            renderer = bubbleObj.GetComponent<Renderer>(),\n            spawnTime = Time.time,\n            riseSpeed = Random.Range(_minRiseSpeed, _maxRiseSpeed),\n            initialSize = Random.Range(_minBubbleSize, _maxBubbleSize),\n            driftDirection = new Vector3(Random.Range(-1f, 1f), 0f, Random.Range(-1f, 1f)).normalized,\n            wavyOffset = Random.Range(0f, Mathf.PI * 2f)\n        };\n        \n        if (bubble.renderer != null)\n        {\n            bubble.material = bubble.renderer.material;\n            bubble.originalColor = bubble.material.color;\n        }\n        \n        bubble.transform.localScale = Vector3.one * bubble.initialSize;\n        _activeBubbles.Add(bubble);\n    }\n    \n    private void UpdateBubbles()\n    {\n        for (int i = 0; i < _activeBubbles.Count; i++)\n        {\n            BubbleData bubble = _activeBubbles[i];\n            if (bubble.gameObject == null) continue;\n            \n            float age = Time.time - bubble.spawnTime;\n            float normalizedAge = age / _bubbleLifetime;\n            \n            // Movement\n            Vector3 movement = Vector3.up * bubble.riseSpeed * Time.deltaTime;\n            \n            // Add wavy motion\n            float wavyX = Mathf.Sin((Time.time * _wavyMotionFrequency) + bubble.wavyOffset) * _wavyMotionAmplitude;\n            float wavyZ = Mathf.Cos((Time.time * _wavyMotionFrequency * 0.7f) + bubble.wavyOffset) * _wavyMotionAmplitude;\n            movement += new Vector3(wavyX, 0f, wavyZ) * Time.deltaTime;\n            \n            // Add drift\n            movement += bubble.driftDirection * _horizontalDriftStrength * Time.deltaTime;\n            \n            // Player avoidance\n            if (_reactToPlayer && _playerTransform != null)\n            {\n                Vector3 toPlayer = _playerTransform.position - bubble.transform.position;\n                float distanceToPlayer = toPlayer.magnitude;\n                \n                if (distanceToPlayer < _playerDetectionRadius)\n                {\n                    Vector3 avoidanceForce = -toPlayer.normalized * _playerAvoidanceStrength * Time.deltaTime;\n                    avoidanceForce.y *= 0.3f; // Reduce vertical avoidance\n                    movement += avoidanceForce;\n                }\n            }\n            \n            bubble.transform.position += movement;\n            \n            // Update appearance\n            float sizeMultiplier = _sizeOverLifetime.Evaluate(normalizedAge);\n            bubble.transform.localScale = Vector3.one * (bubble.initialSize * sizeMultiplier);\n            \n            if (bubble.material != null)\n            {\n                float alpha = _alphaOverLifetime.Evaluate(normalizedAge);\n                Color color = bubble.originalColor;\n                color.a = alpha;\n                bubble.material.color = color;\n            }\n            \n            // Check if bubble reached surface\n            if (_popAtSurface && bubble.transform.position.y >= _waterSurfaceY)\n            {\n                if (_popEffectPrefab != null)\n                {\n                    Vector3 popPosition = new Vector3(bubble.transform.position.x, _waterSurfaceY, bubble.transform.position.z);\n                    Instantiate(_popEffectPrefab, popPosition, Quaternion.identity);\n                }\n                \n                DestroyBubble(i);\n                i--;\n            }\n        }\n    }\n    \n    private void CleanupBubbles()\n    {\n        for (int i = _activeBubbles.Count - 1; i >= 0; i--)\n        {\n            BubbleData bubble = _activeBubbles[i];\n            \n            if (bubble.gameObject == null || Time.time - bubble.spawnTime >= _bubbleLifetime)\n            {\n                DestroyBubble(i);\n            }\n        }\n    }\n    \n    private void DestroyBubble(int index)\n    {\n        if (index >= 0 && index < _activeBubbles.Count)\n        {\n            BubbleData bubble = _activeBubbles[index];\n            if (bubble.gameObject != null)\n            {\n                DestroyImmediate(bubble.gameObject);\n            }\n            _activeBubbles.RemoveAt(index);\n        }\n    }\n    \n    private void CreateDefaultBubblePrefab()\n    {\n        GameObject bubble = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        bubble.name = \"DefaultBubble\";\n        \n        // Remove collider\n        Collider collider = bubble.GetComponent<Collider>();\n        if (collider != null)\n        {\n            DestroyImmediate(collider);\n        }\n        \n        // Setup material\n        Renderer renderer = bubble.GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            Material bubbleMaterial = new Material(Shader.Find(\"Standard\"));\n            bubbleMaterial.SetFloat(\"_Mode\", 3); // Transparent mode\n            bubbleMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            bubbleMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            bubbleMaterial.SetInt(\"_ZWrite\", 0);\n            bubbleMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            bubbleMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            bubbleMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            bubbleMaterial.renderQueue = 3000;\n            \n            bubbleMaterial.color = new Color(0.8f, 0.9f, 1f, 0.3f);\n            bubbleMaterial.SetFloat(\"_Metallic\", 0f);\n            bubbleMaterial.SetFloat(\"_Glossiness\", 0.9f);\n            \n            renderer.material = bubbleMaterial;\n        }\n        \n        _bubblePrefab = bubble;\n        bubble.SetActive(false);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireCube(transform.position, _spawnAreaSize);\n        \n        if (_reactToPlayer && _playerTransform != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_playerTransform.position, _playerDetectionRadius);\n        }\n        \n        if (_popAtSurface)\n        {\n            Gizmos.color = Color.blue;\n            Vector3 surfaceStart = transform.position - Vector3.right * _spawnAreaSize.x * 0.5f;\n            Vector3 surfaceEnd = transform.position + Vector3.right * _spawnAreaSize.x * 0.5f;\n            surfaceStart.y = _waterSurfaceY;\n            surfaceEnd.y = _waterSurfaceY;\n            Gizmos.DrawLine(surfaceStart, surfaceEnd);\n        }\n    }\n    \n    public void SetBubbleSpawnRate(float rate)\n    {\n        _bubbleSpawnRate = Mathf.Max(0.1f, rate);\n    }\n    \n    public void SetWaterSurfaceLevel(float level)\n    {\n        _waterSurfaceY = level;\n    }\n    \n    public void ClearAllBubbles()\n    {\n        for (int i = _activeBubbles.Count - 1; i >= 0; i--)\n        {\n            DestroyBubble(i);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"KeyGate\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isLocked\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"requiredKeyName\",\n      \"type\": \"string\",\n      \"default\": \"GateKey\"\n    },\n    {\n      \"name\": \"openHeight\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"openSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"check_for_key_interaction\",\n      \"trigger\": \"when player enters trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"check if player has required key in inventory\"\n        },\n        {\n          \"action\": \"if player has key then unlock gate and remove key from inventory\"\n        },\n        {\n          \"action\": \"if player does not have key then display message that key is required\"\n        }\n      ]\n    },\n    {\n      \"name\": \"open_gate\",\n      \"trigger\": \"when gate becomes unlocked\",\n      \"actions\": [\n        {\n          \"action\": \"play gate opening sound\"\n        },\n        {\n          \"action\": \"smoothly move gate upward to open height\"\n        },\n        {\n          \"action\": \"disable gate collider when fully open\"\n        }\n      ]\n    },\n    {\n      \"name\": \"block_passage\",\n      \"trigger\": \"when gate is locked and player tries to pass through\",\n      \"actions\": [\n        {\n          \"action\": \"prevent player movement through gate area\"\n        },\n        {\n          \"action\": \"display locked gate message\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class KeyGate : MonoBehaviour\n{\n    [Header(\"Gate Settings\")]\n    [SerializeField] private string _requiredKeyTag = \"Key\";\n    [SerializeField] private float _openHeight = 3f;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private bool _stayOpen = true;\n    [SerializeField] private float _autoCloseDelay = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _unlockSound;\n    [SerializeField] private AudioClip _lockedSound;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _lockedIndicator;\n    [SerializeField] private GameObject _unlockedIndicator;\n    [SerializeField] private ParticleSystem _unlockEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGateUnlocked;\n    public UnityEvent OnGateOpened;\n    public UnityEvent OnGateClosed;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isUnlocked = false;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private AudioSource _audioSource;\n    private Collider _gateCollider;\n    private float _autoCloseTimer;\n    \n    private void Start()\n    {\n        _closedPosition = transform.position;\n        _openPosition = _closedPosition + Vector3.up * _openHeight;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _gateCollider = GetComponent<Collider>();\n        if (_gateCollider == null)\n        {\n            _gateCollider = gameObject.AddComponent<BoxCollider>();\n        }\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void Update()\n    {\n        HandleGateMovement();\n        HandleAutoClose();\n    }\n    \n    private void HandleGateMovement()\n    {\n        if (!_isMoving) return;\n        \n        Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _openSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, targetPosition) < 0.01f)\n        {\n            transform.position = targetPosition;\n            _isMoving = false;\n            \n            if (_isOpen)\n            {\n                OnGateOpened?.Invoke();\n                if (!_stayOpen)\n                {\n                    _autoCloseTimer = _autoCloseDelay;\n                }\n            }\n            else\n            {\n                OnGateClosed?.Invoke();\n                if (_gateCollider != null)\n                {\n                    _gateCollider.enabled = true;\n                }\n            }\n        }\n    }\n    \n    private void HandleAutoClose()\n    {\n        if (!_stayOpen && _isOpen && !_isMoving && _autoCloseTimer > 0f)\n        {\n            _autoCloseTimer -= Time.deltaTime;\n            if (_autoCloseTimer <= 0f)\n            {\n                CloseGate();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\")) return;\n        \n        if (!_isUnlocked)\n        {\n            if (PlayerHasKey(other))\n            {\n                UnlockGate(other);\n            }\n            else\n            {\n                PlayLockedFeedback();\n            }\n        }\n        else if (!_isOpen && !_isMoving)\n        {\n            OpenGate();\n        }\n    }\n    \n    private bool PlayerHasKey(Collider player)\n    {\n        KeyItem[] keys = player.GetComponentsInChildren<KeyItem>();\n        foreach (KeyItem key in keys)\n        {\n            if (key.CompareTag(_requiredKeyTag))\n            {\n                return true;\n            }\n        }\n        \n        GameObject[] childObjects = new GameObject[player.transform.childCount];\n        for (int i = 0; i < player.transform.childCount; i++)\n        {\n            childObjects[i] = player.transform.GetChild(i).gameObject;\n        }\n        \n        foreach (GameObject child in childObjects)\n        {\n            if (child.CompareTag(_requiredKeyTag))\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void UnlockGate(Collider player)\n    {\n        _isUnlocked = true;\n        \n        ConsumeKey(player);\n        \n        PlaySound(_unlockSound);\n        UpdateVisualFeedback();\n        \n        if (_unlockEffect != null)\n        {\n            _unlockEffect.Play();\n        }\n        \n        OnGateUnlocked?.Invoke();\n        \n        OpenGate();\n    }\n    \n    private void ConsumeKey(Collider player)\n    {\n        KeyItem[] keys = player.GetComponentsInChildren<KeyItem>();\n        foreach (KeyItem key in keys)\n        {\n            if (key.CompareTag(_requiredKeyTag))\n            {\n                Destroy(key.gameObject);\n                return;\n            }\n        }\n        \n        for (int i = 0; i < player.transform.childCount; i++)\n        {\n            GameObject child = player.transform.GetChild(i).gameObject;\n            if (child.CompareTag(_requiredKeyTag))\n            {\n                Destroy(child);\n                return;\n            }\n        }\n    }\n    \n    private void OpenGate()\n    {\n        if (_isOpen || _isMoving) return;\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        if (_gateCollider != null)\n        {\n            _gateCollider.enabled = false;\n        }\n        \n        PlaySound(_openSound);\n    }\n    \n    private void CloseGate()\n    {\n        if (!_isOpen || _isMoving) return;\n        \n        _isOpen = false;\n        _isMoving = true;\n        \n        PlaySound(_closeSound);\n    }\n    \n    private void PlayLockedFeedback()\n    {\n        PlaySound(_lockedSound);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_lockedIndicator != null)\n        {\n            _lockedIndicator.SetActive(!_isUnlocked);\n        }\n        \n        if (_unlockedIndicator != null)\n        {\n            _unlockedIndicator.SetActive(_isUnlocked);\n        }\n    }\n    \n    public void ForceUnlock()\n    {\n        _isUnlocked = true;\n        UpdateVisualFeedback();\n        OnGateUnlocked?.Invoke();\n    }\n    \n    public void ForceOpen()\n    {\n        if (_isUnlocked)\n        {\n            OpenGate();\n        }\n    }\n    \n    public void ForceClose()\n    {\n        CloseGate();\n    }\n}\n\n[System.Serializable]\npublic class KeyItem : MonoBehaviour\n{\n    [Header(\"Key Settings\")]\n    [SerializeField] private string _keyType = \"DefaultKey\";\n    \n    public string KeyType => _keyType;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FuelCanister\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fuelAmount\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"refuelRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"isBeingUsed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isEmpty\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_vehicle_proximity\",\n      \"trigger\": \"when vehicle comes within interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"show refuel prompt to player\"\n        },\n        {\n          \"action\": \"highlight canister with glow effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_refueling\",\n      \"trigger\": \"when player activates refuel action while near vehicle\",\n      \"actions\": [\n        {\n          \"action\": \"set being used state to true\"\n        },\n        {\n          \"action\": \"play fuel pouring sound effect\"\n        },\n        {\n          \"action\": \"show refueling progress indicator\"\n        },\n        {\n          \"action\": \"prevent canister from being moved\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transfer_fuel\",\n      \"trigger\": \"while refueling is active and canister has fuel\",\n      \"actions\": [\n        {\n          \"action\": \"decrease canister fuel amount over time\"\n        },\n        {\n          \"action\": \"increase vehicle fuel amount at refuel rate\"\n        },\n        {\n          \"action\": \"update progress bar display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_refueling\",\n      \"trigger\": \"when vehicle tank is full or canister becomes empty\",\n      \"actions\": [\n        {\n          \"action\": \"stop fuel pouring sound\"\n        },\n        {\n          \"action\": \"hide progress indicator\"\n        },\n        {\n          \"action\": \"set being used state to false\"\n        },\n        {\n          \"action\": \"show refuel complete message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"become_empty\",\n      \"trigger\": \"when fuel amount reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"set empty state to true\"\n        },\n        {\n          \"action\": \"change canister appearance to empty version\"\n        },\n        {\n          \"action\": \"disable refueling capability\"\n        },\n        {\n          \"action\": \"play empty container sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_refueling\",\n      \"trigger\": \"when player moves away during refueling or presses cancel\",\n      \"actions\": [\n        {\n          \"action\": \"stop fuel transfer immediately\"\n        },\n        {\n          \"action\": \"hide progress indicator\"\n        },\n        {\n          \"action\": \"set being used state to false\"\n        },\n        {\n          \"action\": \"stop all refueling sounds\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FuelCanister : MonoBehaviour\n{\n    [Header(\"Fuel Settings\")]\n    [SerializeField] private float _fuelAmount = 50f;\n    [SerializeField] private float _refuelRate = 10f;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private bool _isConsumableOnUse = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _refuelSound;\n    [SerializeField] private AudioClip _emptySound;\n    [SerializeField] private AudioClip _pickupSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _fuelParticles;\n    [SerializeField] private Material _emptyMaterial;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _bobSpeed = 2f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Canvas _fuelAmountUI;\n    [SerializeField] private UnityEngine.UI.Text _fuelAmountText;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnFuelUsed;\n    public UnityEvent OnCanisterEmpty;\n    public UnityEvent OnCanisterPickedUp;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Vector3 _originalPosition;\n    private bool _isEmpty = false;\n    private bool _isRefueling = false;\n    private GameObject _currentVehicle;\n    private Collider _collider;\n    \n    [System.Serializable]\n    public class VehicleFuelSystem\n    {\n        public float currentFuel;\n        public float maxFuel;\n        public bool needsFuel;\n        \n        public VehicleFuelSystem(float maxFuelCapacity)\n        {\n            maxFuel = maxFuelCapacity;\n            currentFuel = 0f;\n            needsFuel = true;\n        }\n        \n        public float AddFuel(float amount)\n        {\n            float previousFuel = currentFuel;\n            currentFuel = Mathf.Clamp(currentFuel + amount, 0f, maxFuel);\n            needsFuel = currentFuel < maxFuel;\n            return currentFuel - previousFuel;\n        }\n        \n        public bool IsFull()\n        {\n            return currentFuel >= maxFuel;\n        }\n        \n        public float GetFuelPercentage()\n        {\n            return currentFuel / maxFuel;\n        }\n    }\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n            _originalMaterial = _renderer.material;\n            \n        _collider = GetComponent<Collider>();\n        _originalPosition = transform.position;\n        \n        UpdateUI();\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleBobAnimation();\n        HandlePlayerInteraction();\n        UpdateUI();\n    }\n    \n    private void HandleBobAnimation()\n    {\n        if (!_isEmpty)\n        {\n            float newY = _originalPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n            transform.position = new Vector3(_originalPosition.x, newY, _originalPosition.z);\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n        bool playerInRange = distanceToPlayer <= _interactionRange;\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(playerInRange && !_isEmpty);\n        \n        if (playerInRange && Input.GetKeyDown(KeyCode.E) && !_isEmpty)\n        {\n            PickupCanister();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            VehicleController vehicle = other.GetComponentInParent<VehicleController>();\n            if (vehicle == null)\n                vehicle = other.GetComponent<VehicleController>();\n                \n            if (vehicle != null)\n            {\n                _currentVehicle = vehicle.gameObject;\n            }\n        }\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        if (_isRefueling || _isEmpty) return;\n        \n        if (other.CompareTag(\"Player\") && Input.GetKey(KeyCode.F))\n        {\n            VehicleController vehicle = other.GetComponentInParent<VehicleController>();\n            if (vehicle == null)\n                vehicle = other.GetComponent<VehicleController>();\n                \n            if (vehicle != null)\n            {\n                RefuelVehicle(vehicle);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _currentVehicle = null;\n            _isRefueling = false;\n        }\n    }\n    \n    public void RefuelVehicle(VehicleController vehicle)\n    {\n        if (_isEmpty || _fuelAmount <= 0f) return;\n        \n        VehicleFuelSystem fuelSystem = vehicle.GetComponent<VehicleFuelSystem>();\n        if (fuelSystem == null)\n        {\n            fuelSystem = vehicle.gameObject.AddComponent<VehicleFuelSystem>();\n        }\n        \n        _isRefueling = true;\n        \n        float fuelToTransfer = Mathf.Min(_refuelRate * Time.deltaTime, _fuelAmount);\n        float actualFuelTransferred = fuelSystem.AddFuel(fuelToTransfer);\n        \n        _fuelAmount -= actualFuelTransferred;\n        OnFuelUsed?.Invoke(actualFuelTransferred);\n        \n        if (_fuelParticles != null && !_fuelParticles.activeInHierarchy)\n            _fuelParticles.SetActive(true);\n        \n        PlayRefuelSound();\n        \n        if (_fuelAmount <= 0f)\n        {\n            SetEmpty();\n        }\n        \n        if (fuelSystem.IsFull())\n        {\n            _isRefueling = false;\n            if (_fuelParticles != null)\n                _fuelParticles.SetActive(false);\n        }\n    }\n    \n    private void PlayRefuelSound()\n    {\n        if (_audioSource != null && _refuelSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.clip = _refuelSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetEmpty()\n    {\n        _isEmpty = true;\n        _isRefueling = false;\n        \n        if (_renderer != null && _emptyMaterial != null)\n            _renderer.material = _emptyMaterial;\n        \n        if (_fuelParticles != null)\n            _fuelParticles.SetActive(false);\n        \n        if (_audioSource != null && _emptySound != null)\n        {\n            _audioSource.clip = _emptySound;\n            _audioSource.Play();\n        }\n        \n        OnCanisterEmpty?.Invoke();\n        \n        if (_isConsumableOnUse)\n        {\n            Invoke(nameof(DestroyCanister), 2f);\n        }\n    }\n    \n    private void PickupCanister()\n    {\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.clip = _pickupSound;\n            _audioSource.Play();\n        }\n        \n        OnCanisterPickedUp?.Invoke();\n        \n        if (_collider != null)\n            _collider.enabled = false;\n        \n        gameObject.SetActive(false);\n    }\n    \n    private void UpdateUI()\n    {\n        if (_fuelAmountText != null)\n        {\n            _fuelAmountText.text = $\"Fuel: {_fuelAmount:F1}L\";\n        }\n        \n        if (_fuelAmountUI != null)\n        {\n            _fuelAmountUI.gameObject.SetActive(!_isEmpty);\n        }\n    }\n    \n    private void DestroyCanister()\n    {\n        Destroy(gameObject);\n    }\n    \n    public float GetFuelAmount()\n    {\n        return _fuelAmount;\n    }\n    \n    public bool IsEmpty()\n    {\n        return _isEmpty;\n    }\n    \n    public void SetFuelAmount(float amount)\n    {\n        _fuelAmount = Mathf.Max(0f, amount);\n        _isEmpty = _fuelAmount <= 0f;\n        \n        if (_isEmpty)\n            SetEmpty();\n    }\n    \n    public void RefillCanister(float amount)\n    {\n        _fuelAmount += amount;\n        _isEmpty = false;\n        \n        if (_renderer != null && _originalMaterial != null)\n            _renderer.material = _originalMaterial;\n    }\n}\n\npublic class VehicleController : MonoBehaviour\n{\n    [Header(\"Vehicle Fuel\")]\n    [SerializeField] private float _maxFuel = 100f;\n    [SerializeField] private float _currentFuel = 50f;\n    [SerializeField] private float _fuelConsumptionRate = 5f;\n    [SerializeField] private UnityEngine.UI.Slider _fuelGauge;\n    \n    private FuelCanister.VehicleFuelSystem _fuelSystem;\n    \n    private void Start()\n    {\n        _fuelSystem = new FuelCanister.VehicleFuelSystem(_maxFuel);\n        _fuelSystem.currentFuel = _currentFuel;\n    }\n    \n    private void Update()\n    {\n        ConsumeFuel();\n        UpdateFuelGauge();\n    }\n    \n    private void ConsumeFuel()\n    {\n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.S))\n        {\n            _fuelSystem.AddFuel(-_fuelConsumptionRate * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateFuelGauge()\n    {\n        if (_fuelGauge != null)\n        {\n            _fuelGauge.value = _fuelSystem.GetFuelPercentage();\n        }\n    }\n    \n    public FuelCanister.VehicleFuelSystem GetFuelSystem()\n    {\n        return _fuelSystem;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FlickeringLight\",\n  \"components\": [\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"minIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"maxIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"flickerSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"random_flicker\",\n      \"trigger\": \"continuously at random intervals\",\n      \"actions\": [\n        {\n          \"action\": \"change light intensity to random value between minimum and maximum intensity\"\n        },\n        {\n          \"action\": \"wait for flicker speed duration before next change\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FlickeringLight : MonoBehaviour\n{\n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _targetLight;\n    [SerializeField] private float _originalIntensity = 1f;\n    [SerializeField] private bool _useOriginalColor = true;\n    [SerializeField] private Color _originalColor = Color.white;\n    \n    [Header(\"Flicker Behavior\")]\n    [SerializeField] private float _minFlickerInterval = 0.1f;\n    [SerializeField] private float _maxFlickerInterval = 2f;\n    [SerializeField] private float _minIntensity = 0.1f;\n    [SerializeField] private float _maxIntensity = 1.2f;\n    [SerializeField] private float _flickerSpeed = 10f;\n    \n    [Header(\"Advanced Settings\")]\n    [SerializeField] private bool _randomizeColor = false;\n    [SerializeField] private Color _flickerColorMin = Color.yellow;\n    [SerializeField] private Color _flickerColorMax = Color.orange;\n    [SerializeField] private AnimationCurve _flickerCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private bool _enableSmoothTransition = true;\n    \n    private float _nextFlickerTime;\n    private float _targetIntensity;\n    private Color _targetColor;\n    private bool _isFlickering = false;\n    private float _flickerDuration = 0.2f;\n    private float _flickerStartTime;\n    \n    private void Start()\n    {\n        if (_targetLight == null)\n        {\n            _targetLight = GetComponent<Light>();\n        }\n        \n        if (_targetLight == null)\n        {\n            Debug.LogError(\"FlickeringLight: No Light component found!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalIntensity = _targetLight.intensity;\n        if (_useOriginalColor)\n        {\n            _originalColor = _targetLight.color;\n        }\n        \n        _targetIntensity = _originalIntensity;\n        _targetColor = _originalColor;\n        \n        ScheduleNextFlicker();\n    }\n    \n    private void Update()\n    {\n        if (_targetLight == null) return;\n        \n        if (Time.time >= _nextFlickerTime && !_isFlickering)\n        {\n            StartFlicker();\n        }\n        \n        if (_isFlickering)\n        {\n            UpdateFlicker();\n        }\n        else if (_enableSmoothTransition)\n        {\n            SmoothReturnToOriginal();\n        }\n    }\n    \n    private void StartFlicker()\n    {\n        _isFlickering = true;\n        _flickerStartTime = Time.time;\n        _flickerDuration = Random.Range(0.05f, 0.3f);\n        \n        _targetIntensity = Random.Range(_minIntensity, _maxIntensity);\n        \n        if (_randomizeColor)\n        {\n            _targetColor = Color.Lerp(_flickerColorMin, _flickerColorMax, Random.value);\n        }\n        else\n        {\n            _targetColor = _originalColor;\n        }\n    }\n    \n    private void UpdateFlicker()\n    {\n        float flickerProgress = (Time.time - _flickerStartTime) / _flickerDuration;\n        \n        if (flickerProgress >= 1f)\n        {\n            _isFlickering = false;\n            ScheduleNextFlicker();\n            return;\n        }\n        \n        float curveValue = _flickerCurve.Evaluate(flickerProgress);\n        float noise = Mathf.PerlinNoise(Time.time * _flickerSpeed, 0f);\n        float flickerMultiplier = Mathf.Lerp(0.3f, 1f, noise);\n        \n        float currentIntensity = Mathf.Lerp(_originalIntensity, _targetIntensity * flickerMultiplier, curveValue);\n        Color currentColor = Color.Lerp(_originalColor, _targetColor, curveValue);\n        \n        _targetLight.intensity = currentIntensity;\n        _targetLight.color = currentColor;\n    }\n    \n    private void SmoothReturnToOriginal()\n    {\n        _targetLight.intensity = Mathf.Lerp(_targetLight.intensity, _originalIntensity, Time.deltaTime * 5f);\n        _targetLight.color = Color.Lerp(_targetLight.color, _originalColor, Time.deltaTime * 5f);\n    }\n    \n    private void ScheduleNextFlicker()\n    {\n        float interval = Random.Range(_minFlickerInterval, _maxFlickerInterval);\n        _nextFlickerTime = Time.time + interval;\n    }\n    \n    public void SetFlickerEnabled(bool enabled)\n    {\n        if (!enabled)\n        {\n            _isFlickering = false;\n            _targetLight.intensity = _originalIntensity;\n            _targetLight.color = _originalColor;\n        }\n        \n        this.enabled = enabled;\n    }\n    \n    public void TriggerFlicker()\n    {\n        if (!_isFlickering)\n        {\n            _nextFlickerTime = Time.time;\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _minFlickerInterval = Mathf.Max(0.01f, _minFlickerInterval);\n        _maxFlickerInterval = Mathf.Max(_minFlickerInterval, _maxFlickerInterval);\n        _minIntensity = Mathf.Max(0f, _minIntensity);\n        _maxIntensity = Mathf.Max(_minIntensity, _maxIntensity);\n        _flickerSpeed = Mathf.Max(0.1f, _flickerSpeed);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParachuteGlider\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"glidingSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"steeringForce\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isParachuteDeployed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"minDeployHeight\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"deploy_parachute\",\n      \"trigger\": \"when player presses deploy key and is above minimum height\",\n      \"actions\": [\n        {\n          \"action\": \"set parachute as deployed\"\n        },\n        {\n          \"action\": \"reduce falling speed significantly\"\n        },\n        {\n          \"action\": \"enable horizontal gliding movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"glide_forward\",\n      \"trigger\": \"when parachute is deployed and moving forward\",\n      \"actions\": [\n        {\n          \"action\": \"move forward at gliding speed\"\n        },\n        {\n          \"action\": \"maintain gentle downward descent\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_left\",\n      \"trigger\": \"when parachute is deployed and left input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply leftward steering force\"\n        },\n        {\n          \"action\": \"slightly tilt parachute to the left\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_right\",\n      \"trigger\": \"when parachute is deployed and right input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply rightward steering force\"\n        },\n        {\n          \"action\": \"slightly tilt parachute to the right\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_safely\",\n      \"trigger\": \"when parachute is deployed and touching ground\",\n      \"actions\": [\n        {\n          \"action\": \"reduce all movement to zero\"\n        },\n        {\n          \"action\": \"disable parachute physics\"\n        },\n        {\n          \"action\": \"transition to ground movement state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ParachuteGlider : MonoBehaviour\n{\n    [Header(\"Parachute Settings\")]\n    [SerializeField] private GameObject _parachuteModel;\n    [SerializeField] private float _deployTime = 1.5f;\n    [SerializeField] private float _packTime = 0.8f;\n    \n    [Header(\"Gliding Physics\")]\n    [SerializeField] private float _glidingGravity = 2f;\n    [SerializeField] private float _normalGravity = 9.81f;\n    [SerializeField] private float _horizontalSpeed = 8f;\n    [SerializeField] private float _maxFallSpeed = 3f;\n    [SerializeField] private float _liftForce = 5f;\n    \n    [Header(\"Controls\")]\n    [SerializeField] private KeyCode _deployKey = KeyCode.Space;\n    [SerializeField] private float _turnSpeed = 45f;\n    [SerializeField] private float _tiltAmount = 15f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 1.5f;\n    [SerializeField] private float _autoPackHeight = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isGliding = false;\n    private bool _isDeploying = false;\n    private bool _isPacking = false;\n    private float _deployTimer = 0f;\n    private float _originalDrag;\n    private Vector3 _originalScale;\n    private bool _isGrounded = false;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        \n        if (_parachuteModel != null)\n        {\n            _originalScale = _parachuteModel.transform.localScale;\n            _parachuteModel.transform.localScale = Vector3.zero;\n            _parachuteModel.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleInput();\n        UpdateParachuteAnimation();\n        \n        if (_isGliding && !_isGrounded)\n        {\n            HandleGlidingMovement();\n        }\n        \n        if (_isGrounded && _isGliding)\n        {\n            PackParachute();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGliding && !_isGrounded)\n        {\n            ApplyGlidingPhysics();\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _groundCheckDistance, _groundLayer);\n        \n        if (_isGrounded && hit.distance < _autoPackHeight && _isGliding)\n        {\n            PackParachute();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_deployKey))\n        {\n            if (!_isGliding && !_isGrounded && !_isDeploying && !_isPacking)\n            {\n                DeployParachute();\n            }\n            else if (_isGliding && !_isDeploying && !_isPacking)\n            {\n                PackParachute();\n            }\n        }\n    }\n    \n    private void HandleGlidingMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        // Horizontal movement\n        Vector3 moveDirection = new Vector3(horizontal, 0, vertical).normalized;\n        if (moveDirection.magnitude > 0.1f)\n        {\n            Vector3 targetDirection = transform.TransformDirection(moveDirection);\n            _rigidbody.AddForce(targetDirection * _horizontalSpeed, ForceMode.Acceleration);\n        }\n        \n        // Turning\n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            transform.Rotate(0, horizontal * _turnSpeed * Time.deltaTime, 0);\n            \n            // Tilt parachute\n            if (_parachuteModel != null)\n            {\n                Vector3 tiltRotation = new Vector3(0, 0, -horizontal * _tiltAmount);\n                _parachuteModel.transform.localRotation = Quaternion.Lerp(\n                    _parachuteModel.transform.localRotation,\n                    Quaternion.Euler(tiltRotation),\n                    Time.deltaTime * 3f\n                );\n            }\n        }\n        else if (_parachuteModel != null)\n        {\n            _parachuteModel.transform.localRotation = Quaternion.Lerp(\n                _parachuteModel.transform.localRotation,\n                Quaternion.identity,\n                Time.deltaTime * 3f\n            );\n        }\n        \n        // Forward lift\n        if (vertical > 0.1f)\n        {\n            _rigidbody.AddForce(transform.forward * _liftForce * vertical, ForceMode.Acceleration);\n        }\n    }\n    \n    private void ApplyGlidingPhysics()\n    {\n        // Apply custom gravity\n        _rigidbody.AddForce(Vector3.down * _glidingGravity, ForceMode.Acceleration);\n        \n        // Limit fall speed\n        if (_rigidbody.velocity.y < -_maxFallSpeed)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = -_maxFallSpeed;\n            _rigidbody.velocity = velocity;\n        }\n        \n        // Add air resistance\n        Vector3 airResistance = -_rigidbody.velocity * 0.5f;\n        airResistance.y *= 0.8f; // Less resistance on vertical movement\n        _rigidbody.AddForce(airResistance, ForceMode.Acceleration);\n    }\n    \n    private void DeployParachute()\n    {\n        if (_isDeploying || _isPacking || _isGliding) return;\n        \n        _isDeploying = true;\n        _deployTimer = 0f;\n        \n        if (_parachuteModel != null)\n        {\n            _parachuteModel.SetActive(true);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Deploy\");\n        }\n    }\n    \n    private void PackParachute()\n    {\n        if (_isPacking || !_isGliding) return;\n        \n        _isPacking = true;\n        _isGliding = false;\n        _deployTimer = 0f;\n        \n        // Restore normal physics\n        _rigidbody.drag = _originalDrag;\n        _rigidbody.useGravity = true;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Pack\");\n        }\n    }\n    \n    private void UpdateParachuteAnimation()\n    {\n        if (_isDeploying)\n        {\n            _deployTimer += Time.deltaTime;\n            float progress = _deployTimer / _deployTime;\n            \n            if (_parachuteModel != null)\n            {\n                _parachuteModel.transform.localScale = Vector3.Lerp(Vector3.zero, _originalScale, progress);\n            }\n            \n            if (progress >= 1f)\n            {\n                _isDeploying = false;\n                _isGliding = true;\n                \n                // Apply gliding physics\n                _rigidbody.drag = 3f;\n                _rigidbody.useGravity = false;\n            }\n        }\n        else if (_isPacking)\n        {\n            _deployTimer += Time.deltaTime;\n            float progress = _deployTimer / _packTime;\n            \n            if (_parachuteModel != null)\n            {\n                _parachuteModel.transform.localScale = Vector3.Lerp(_originalScale, Vector3.zero, progress);\n            }\n            \n            if (progress >= 1f)\n            {\n                _isPacking = false;\n                \n                if (_parachuteModel != null)\n                {\n                    _parachuteModel.SetActive(false);\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, Vector3.down * _groundCheckDistance);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position - Vector3.up * _autoPackHeight, 0.5f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RopeSwing\",\n  \"components\": [\n    \"Rigidbody\",\n    \"HingeJoint\",\n    \"LineRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"ropeLength\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"swingForce\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"maxSwingAngle\",\n      \"type\": \"float\",\n      \"default\": 45.0\n    },\n    {\n      \"name\": \"dampingFactor\",\n      \"type\": \"float\",\n      \"default\": 0.98\n    },\n    {\n      \"name\": \"isPlayerAttached\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"attachPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"ropeSegments\",\n      \"type\": \"int\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attach_player\",\n      \"trigger\": \"when player presses interact key while near rope\",\n      \"actions\": [\n        {\n          \"action\": \"connect player to rope at current position\"\n        },\n        {\n          \"action\": \"disable player ground movement\"\n        },\n        {\n          \"action\": \"set player as attached to rope\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detach_player\",\n      \"trigger\": \"when player releases interact key while attached\",\n      \"actions\": [\n        {\n          \"action\": \"disconnect player from rope\"\n        },\n        {\n          \"action\": \"restore player normal movement\"\n        },\n        {\n          \"action\": \"apply current swing momentum to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"swing_physics\",\n      \"trigger\": \"when player is attached and provides input\",\n      \"actions\": [\n        {\n          \"action\": \"apply pendulum physics to rope movement\"\n        },\n        {\n          \"action\": \"add player input force to swing direction\"\n        },\n        {\n          \"action\": \"limit swing angle to maximum range\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rope_visual\",\n      \"trigger\": \"continuously while rope exists\",\n      \"actions\": [\n        {\n          \"action\": \"draw rope line from anchor point to player\"\n        },\n        {\n          \"action\": \"update rope curve based on physics simulation\"\n        },\n        {\n          \"action\": \"show rope segments with realistic sag\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dampen_swing\",\n      \"trigger\": \"continuously while swinging\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce swing momentum over time\"\n        },\n        {\n          \"action\": \"apply air resistance to rope movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class RopeSwing : MonoBehaviour\n{\n    [Header(\"Rope Settings\")]\n    [SerializeField] private Transform _anchorPoint;\n    [SerializeField] private LineRenderer _ropeRenderer;\n    [SerializeField] private int _ropeSegments = 20;\n    [SerializeField] private float _ropeLength = 5f;\n    [SerializeField] private float _ropeWidth = 0.1f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _swingForce = 10f;\n    [SerializeField] private float _dampening = 0.98f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Player Interaction\")]\n    [SerializeField] private KeyCode _grabKey = KeyCode.E;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Space;\n    [SerializeField] private float _grabDistance = 2f;\n    [SerializeField] private Transform _grabPoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _grabSound;\n    [SerializeField] private AudioClip _releaseSound;\n    [SerializeField] private AudioClip _swingSound;\n    \n    private bool _isPlayerGrabbing = false;\n    private GameObject _currentPlayer;\n    private Rigidbody _playerRigidbody;\n    private Vector3 _ropeDirection;\n    private float _currentAngle = 0f;\n    private float _angularVelocity = 0f;\n    private Vector3[] _ropePositions;\n    private bool _isSwinging = false;\n    private Vector3 _lastPlayerPosition;\n    private bool _canGrab = true;\n    \n    private void Start()\n    {\n        InitializeRope();\n        SetupAudio();\n    }\n    \n    private void InitializeRope()\n    {\n        if (_anchorPoint == null)\n            _anchorPoint = transform;\n            \n        if (_grabPoint == null)\n        {\n            GameObject grabPointObj = new GameObject(\"GrabPoint\");\n            grabPointObj.transform.SetParent(transform);\n            _grabPoint = grabPointObj.transform;\n        }\n        \n        _ropePositions = new Vector3[_ropeSegments + 1];\n        \n        if (_ropeRenderer == null)\n        {\n            _ropeRenderer = GetComponent<LineRenderer>();\n            if (_ropeRenderer == null)\n                _ropeRenderer = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _ropeRenderer.positionCount = _ropeSegments + 1;\n        _ropeRenderer.startWidth = _ropeWidth;\n        _ropeRenderer.endWidth = _ropeWidth;\n        _ropeRenderer.useWorldSpace = true;\n        \n        UpdateRopeVisual();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n                _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInput();\n        UpdateRopePhysics();\n        UpdateRopeVisual();\n        CheckGroundCollision();\n    }\n    \n    private void HandlePlayerInput()\n    {\n        if (!_isPlayerGrabbing && _canGrab)\n        {\n            CheckForPlayerGrab();\n        }\n        \n        if (_isPlayerGrabbing && _currentPlayer != null)\n        {\n            HandleSwingInput();\n            \n            if (Input.GetKeyDown(_releaseKey))\n            {\n                ReleasePlayer();\n            }\n        }\n    }\n    \n    private void CheckForPlayerGrab()\n    {\n        Collider[] nearbyObjects = Physics.OverlapSphere(_grabPoint.position, _grabDistance);\n        \n        foreach (Collider col in nearbyObjects)\n        {\n            if (col.CompareTag(\"Player\") && Input.GetKeyDown(_grabKey))\n            {\n                GrabPlayer(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void GrabPlayer(GameObject player)\n    {\n        _currentPlayer = player;\n        _playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (_playerRigidbody == null)\n            return;\n            \n        _isPlayerGrabbing = true;\n        _isSwinging = true;\n        \n        // Calculate initial angle based on player position relative to anchor\n        Vector3 toPlayer = player.transform.position - _anchorPoint.position;\n        _currentAngle = Mathf.Atan2(toPlayer.x, -toPlayer.y);\n        _angularVelocity = 0f;\n        \n        // Disable player's gravity temporarily\n        _playerRigidbody.useGravity = false;\n        _playerRigidbody.velocity = Vector3.zero;\n        \n        _lastPlayerPosition = player.transform.position;\n        \n        PlaySound(_grabSound);\n    }\n    \n    private void HandleSwingInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        \n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            _angularVelocity += horizontal * _swingForce * Time.deltaTime;\n            \n            if (!_audioSource.isPlaying && _swingSound != null)\n            {\n                PlaySound(_swingSound);\n            }\n        }\n    }\n    \n    private void UpdateRopePhysics()\n    {\n        if (_isPlayerGrabbing && _currentPlayer != null && _playerRigidbody != null)\n        {\n            // Apply gravity to angular velocity\n            float gravityForce = _gravity * Mathf.Sin(_currentAngle) / _ropeLength;\n            _angularVelocity += gravityForce * Time.deltaTime;\n            \n            // Apply dampening\n            _angularVelocity *= _dampening;\n            \n            // Update angle\n            _currentAngle += _angularVelocity * Time.deltaTime;\n            \n            // Calculate new player position\n            Vector3 newPosition = _anchorPoint.position + new Vector3(\n                Mathf.Sin(_currentAngle) * _ropeLength,\n                -Mathf.Cos(_currentAngle) * _ropeLength,\n                0f\n            );\n            \n            // Move player\n            _currentPlayer.transform.position = newPosition;\n            \n            // Calculate velocity for when player releases\n            Vector3 velocity = (newPosition - _lastPlayerPosition) / Time.deltaTime;\n            _playerRigidbody.velocity = velocity;\n            \n            _lastPlayerPosition = newPosition;\n        }\n        \n        // Update grab point position\n        if (_grabPoint != null)\n        {\n            _grabPoint.position = _anchorPoint.position + new Vector3(\n                Mathf.Sin(_currentAngle) * _ropeLength,\n                -Mathf.Cos(_currentAngle) * _ropeLength,\n                0f\n            );\n        }\n    }\n    \n    private void UpdateRopeVisual()\n    {\n        if (_ropeRenderer == null || _anchorPoint == null)\n            return;\n            \n        Vector3 ropeEnd = _grabPoint != null ? _grabPoint.position : \n            _anchorPoint.position + Vector3.down * _ropeLength;\n        \n        for (int i = 0; i <= _ropeSegments; i++)\n        {\n            float t = (float)i / _ropeSegments;\n            Vector3 position = Vector3.Lerp(_anchorPoint.position, ropeEnd, t);\n            \n            // Add slight curve to rope\n            float curve = Mathf.Sin(t * Mathf.PI) * 0.5f;\n            position.x += curve * Mathf.Sign(ropeEnd.x - _anchorPoint.position.x);\n            \n            _ropePositions[i] = position;\n        }\n        \n        _ropeRenderer.SetPositions(_ropePositions);\n    }\n    \n    private void CheckGroundCollision()\n    {\n        if (_isPlayerGrabbing && _currentPlayer != null)\n        {\n            Bounds playerBounds = _currentPlayer.GetComponent<Collider>().bounds;\n            \n            if (Physics.CheckBox(playerBounds.center, playerBounds.extents, \n                _currentPlayer.transform.rotation, _groundLayer))\n            {\n                ReleasePlayer();\n            }\n        }\n    }\n    \n    private void ReleasePlayer()\n    {\n        if (_currentPlayer != null && _playerRigidbody != null)\n        {\n            _playerRigidbody.useGravity = true;\n            \n            // Add release velocity\n            Vector3 releaseVelocity = new Vector3(\n                Mathf.Cos(_currentAngle) * _angularVelocity * _ropeLength,\n                Mathf.Sin(_currentAngle) * _angularVelocity * _ropeLength,\n                0f\n            );\n            \n            _playerRigidbody.velocity += releaseVelocity;\n        }\n        \n        _isPlayerGrabbing = false;\n        _isSwinging = false;\n        _currentPlayer = null;\n        _playerRigidbody = null;\n        _angularVelocity = 0f;\n        \n        PlaySound(_releaseSound);\n        \n        // Prevent immediate re-grab\n        _canGrab = false;\n        Invoke(nameof(EnableGrab), 0.5f);\n    }\n    \n    private void EnableGrab()\n    {\n        _canGrab = true;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_anchorPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_anchorPoint.position, 0.2f);\n            \n            Vector3 ropeEnd = _anchorPoint.position + Vector3.down * _ropeLength;\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_anchorPoint.position, ropeEnd);\n            \n            if (_grabPoint != null)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawWireSphere(_grabPoint.position, _grabDistance);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LanguageLocalization\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentLanguage\",\n      \"type\": \"string\",\n      \"default\": \"English\"\n    },\n    {\n      \"name\": \"supportedLanguages\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"English\",\n        \"Spanish\",\n        \"French\",\n        \"German\",\n        \"Japanese\"\n      ]\n    },\n    {\n      \"name\": \"textDatabase\",\n      \"type\": \"Dictionary<string, Dictionary<string, string>>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"fallbackLanguage\",\n      \"type\": \"string\",\n      \"default\": \"English\"\n    },\n    {\n      \"name\": \"autoDetectSystemLanguage\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_localization\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"load text database from resources\"\n        },\n        {\n          \"action\": \"detect system language if auto detect is enabled\"\n        },\n        {\n          \"action\": \"set current language to detected language if supported\"\n        },\n        {\n          \"action\": \"set current language to fallback if detection fails\"\n        },\n        {\n          \"action\": \"notify all localized text components of language change\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_language\",\n      \"trigger\": \"when language change is requested\",\n      \"actions\": [\n        {\n          \"action\": \"check if requested language is supported\"\n        },\n        {\n          \"action\": \"update current language to requested language\"\n        },\n        {\n          \"action\": \"save language preference to player preferences\"\n        },\n        {\n          \"action\": \"broadcast language changed event to all listeners\"\n        },\n        {\n          \"action\": \"refresh all localized text in scene\"\n        }\n      ]\n    },\n    {\n      \"name\": \"get_localized_text\",\n      \"trigger\": \"when localized text is requested with key\",\n      \"actions\": [\n        {\n          \"action\": \"look up text key in current language dictionary\"\n        },\n        {\n          \"action\": \"return localized text if key exists\"\n        },\n        {\n          \"action\": \"fallback to default language if key not found in current language\"\n        },\n        {\n          \"action\": \"return key itself if not found in any language\"\n        },\n        {\n          \"action\": \"log warning if key is missing from all languages\"\n        }\n      ]\n    },\n    {\n      \"name\": \"load_language_data\",\n      \"trigger\": \"when language data needs to be loaded\",\n      \"actions\": [\n        {\n          \"action\": \"read localization files from streaming assets\"\n        },\n        {\n          \"action\": \"parse JSON or CSV language data\"\n        },\n        {\n          \"action\": \"populate text database with key value pairs\"\n        },\n        {\n          \"action\": \"validate all supported languages have required keys\"\n        },\n        {\n          \"action\": \"cache loaded data for quick access\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_missing_translation\",\n      \"trigger\": \"when translation key is not found\",\n      \"actions\": [\n        {\n          \"action\": \"attempt to use fallback language translation\"\n        },\n        {\n          \"action\": \"display original key as placeholder text\"\n        },\n        {\n          \"action\": \"log missing translation for debugging\"\n        },\n        {\n          \"action\": \"add missing key to translation report\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\n[System.Serializable]\npublic class LocalizedString\n{\n    public string key;\n    public string defaultValue;\n    \n    public LocalizedString(string key, string defaultValue = \"\")\n    {\n        this.key = key;\n        this.defaultValue = defaultValue;\n    }\n}\n\n[System.Serializable]\npublic class LanguageData\n{\n    public string languageCode;\n    public string languageName;\n    public Dictionary<string, string> translations = new Dictionary<string, string>();\n}\n\n[System.Serializable]\npublic class TranslationEntry\n{\n    public string key;\n    public string value;\n}\n\n[System.Serializable]\npublic class LanguageFile\n{\n    public string languageCode;\n    public string languageName;\n    public List<TranslationEntry> translations = new List<TranslationEntry>();\n}\n\npublic class LocalizationManager : MonoBehaviour\n{\n    [Header(\"Language Settings\")]\n    [SerializeField] private string _currentLanguageCode = \"en\";\n    [SerializeField] private string _fallbackLanguageCode = \"en\";\n    [SerializeField] private bool _autoDetectSystemLanguage = true;\n    \n    [Header(\"Language Files\")]\n    [SerializeField] private List<TextAsset> _languageFiles = new List<TextAsset>();\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnLanguageChanged = new UnityEvent<string>();\n    \n    private Dictionary<string, LanguageData> _languages = new Dictionary<string, LanguageData>();\n    private Dictionary<string, string> _currentTranslations = new Dictionary<string, string>();\n    \n    public static LocalizationManager Instance { get; private set; }\n    \n    public string CurrentLanguage => _currentLanguageCode;\n    public List<string> AvailableLanguages => new List<string>(_languages.Keys);\n    \n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n            InitializeLocalization();\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void Start()\n    {\n        LoadLanguageFiles();\n        \n        if (_autoDetectSystemLanguage)\n        {\n            DetectSystemLanguage();\n        }\n        \n        SetLanguage(_currentLanguageCode);\n    }\n    \n    private void InitializeLocalization()\n    {\n        _languages.Clear();\n        _currentTranslations.Clear();\n        \n        // Load saved language preference\n        string savedLanguage = PlayerPrefs.GetString(\"LocalizationLanguage\", \"\");\n        if (!string.IsNullOrEmpty(savedLanguage))\n        {\n            _currentLanguageCode = savedLanguage;\n        }\n    }\n    \n    private void LoadLanguageFiles()\n    {\n        foreach (TextAsset languageFile in _languageFiles)\n        {\n            if (languageFile == null) continue;\n            \n            try\n            {\n                LanguageFile langFile = JsonUtility.FromJson<LanguageFile>(languageFile.text);\n                \n                if (!_languages.ContainsKey(langFile.languageCode))\n                {\n                    _languages[langFile.languageCode] = new LanguageData\n                    {\n                        languageCode = langFile.languageCode,\n                        languageName = langFile.languageName\n                    };\n                }\n                \n                foreach (TranslationEntry entry in langFile.translations)\n                {\n                    _languages[langFile.languageCode].translations[entry.key] = entry.value;\n                }\n                \n                Debug.Log($\"Loaded language: {langFile.languageName} ({langFile.languageCode}) with {langFile.translations.Count} translations\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"Failed to load language file {languageFile.name}: {e.Message}\");\n            }\n        }\n    }\n    \n    private void DetectSystemLanguage()\n    {\n        SystemLanguage systemLang = Application.systemLanguage;\n        string detectedCode = GetLanguageCode(systemLang);\n        \n        if (_languages.ContainsKey(detectedCode))\n        {\n            _currentLanguageCode = detectedCode;\n        }\n    }\n    \n    private string GetLanguageCode(SystemLanguage systemLanguage)\n    {\n        switch (systemLanguage)\n        {\n            case SystemLanguage.English: return \"en\";\n            case SystemLanguage.Spanish: return \"es\";\n            case SystemLanguage.French: return \"fr\";\n            case SystemLanguage.German: return \"de\";\n            case SystemLanguage.Italian: return \"it\";\n            case SystemLanguage.Portuguese: return \"pt\";\n            case SystemLanguage.Russian: return \"ru\";\n            case SystemLanguage.Japanese: return \"ja\";\n            case SystemLanguage.Korean: return \"ko\";\n            case SystemLanguage.Chinese: return \"zh\";\n            case SystemLanguage.ChineseSimplified: return \"zh-CN\";\n            case SystemLanguage.ChineseTraditional: return \"zh-TW\";\n            case SystemLanguage.Dutch: return \"nl\";\n            case SystemLanguage.Polish: return \"pl\";\n            case SystemLanguage.Swedish: return \"sv\";\n            case SystemLanguage.Norwegian: return \"no\";\n            case SystemLanguage.Danish: return \"da\";\n            case SystemLanguage.Finnish: return \"fi\";\n            case SystemLanguage.Turkish: return \"tr\";\n            case SystemLanguage.Arabic: return \"ar\";\n            case SystemLanguage.Hebrew: return \"he\";\n            case SystemLanguage.Thai: return \"th\";\n            case SystemLanguage.Vietnamese: return \"vi\";\n            default: return \"en\";\n        }\n    }\n    \n    public bool SetLanguage(string languageCode)\n    {\n        if (!_languages.ContainsKey(languageCode))\n        {\n            Debug.LogWarning($\"Language '{languageCode}' not found. Using fallback language '{_fallbackLanguageCode}'\");\n            languageCode = _fallbackLanguageCode;\n            \n            if (!_languages.ContainsKey(languageCode))\n            {\n                Debug.LogError($\"Fallback language '{_fallbackLanguageCode}' not found!\");\n                return false;\n            }\n        }\n        \n        _currentLanguageCode = languageCode;\n        _currentTranslations = new Dictionary<string, string>(_languages[languageCode].translations);\n        \n        // Save language preference\n        PlayerPrefs.SetString(\"LocalizationLanguage\", languageCode);\n        PlayerPrefs.Save();\n        \n        OnLanguageChanged.Invoke(languageCode);\n        \n        Debug.Log($\"Language changed to: {GetLanguageName(languageCode)} ({languageCode})\");\n        return true;\n    }\n    \n    public string GetLocalizedString(string key, params object[] args)\n    {\n        if (string.IsNullOrEmpty(key))\n        {\n            return \"\";\n        }\n        \n        string localizedText = \"\";\n        \n        // Try current language\n        if (_currentTranslations.ContainsKey(key))\n        {\n            localizedText = _currentTranslations[key];\n        }\n        // Try fallback language\n        else if (_languages.ContainsKey(_fallbackLanguageCode) && \n                 _languages[_fallbackLanguageCode].translations.ContainsKey(key))\n        {\n            localizedText = _languages[_fallbackLanguageCode].translations[key];\n        }\n        // Return key if no translation found\n        else\n        {\n            Debug.LogWarning($\"Translation not found for key: {key}\");\n            return $\"[{key}]\";\n        }\n        \n        // Format string with arguments if provided\n        if (args != null && args.Length > 0)\n        {\n            try\n            {\n                localizedText = string.Format(localizedText, args);\n            }\n            catch (FormatException e)\n            {\n                Debug.LogError($\"String formatting error for key '{key}': {e.Message}\");\n                return localizedText;\n            }\n        }\n        \n        return localizedText;\n    }\n    \n    public string GetLocalizedString(LocalizedString localizedString, params object[] args)\n    {\n        if (localizedString == null)\n        {\n            return \"\";\n        }\n        \n        string result = GetLocalizedString(localizedString.key, args);\n        \n        // Return default value if translation not found and default is provided\n        if (result.StartsWith(\"[\") && result.EndsWith(\"]\") && !string.IsNullOrEmpty(localizedString.defaultValue))\n        {\n            return localizedString.defaultValue;\n        }\n        \n        return result;\n    }\n    \n    public string GetLanguageName(string languageCode)\n    {\n        if (_languages.ContainsKey(languageCode))\n        {\n            return _languages[languageCode].languageName;\n        }\n        return languageCode;\n    }\n    \n    public bool HasTranslation(string key)\n    {\n        return _currentTranslations.ContainsKey(key) || \n               (_languages.ContainsKey(_fallbackLanguageCode) && \n                _languages[_fallbackLanguageCode].translations.ContainsKey(key));\n    }\n    \n    public void AddTranslation(string languageCode, string key, string value)\n    {\n        if (!_languages.ContainsKey(languageCode))\n        {\n            _languages[languageCode] = new LanguageData\n            {\n                languageCode = languageCode,\n                languageName = languageCode\n            };\n        }\n        \n        _languages[languageCode].translations[key] = value;\n        \n        // Update current translations if this is the active language\n        if (languageCode == _currentLanguageCode)\n        {\n            _currentTranslations[key] = value;\n        }\n    }\n    \n    public void RemoveTranslation(string key)\n    {\n        foreach (var language in _languages.Values)\n        {\n            language.translations.Remove(key);\n        }\n        \n        _currentTranslations.Remove(key);\n    }\n    \n    public Dictionary<string, string> GetAllTranslations(string languageCode)\n    {\n        if (_languages.ContainsKey(languageCode))\n        {\n            return new Dictionary<string, string>(_languages[languageCode].translations);\n        }\n        return new Dictionary<string, string>();\n    }\n    \n    public void RefreshAllLocalizedComponents()\n    {\n        LocalizedText[] localizedTexts = FindObjectsOfType<LocalizedText>();\n        foreach (LocalizedText localizedText in localizedTexts)\n        {\n            localizedText.UpdateText();\n        }\n    }\n    \n    [ContextMenu(\"Reload Language Files\")]\n    private void ReloadLanguageFiles()\n    {\n        LoadLanguageFiles();\n        SetLanguage(_currentLanguageCode);\n        RefreshAllLocalizedComponents();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CreatureStateMachine\",\n  \"components\": [\n    \"AudioSource\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentState\",\n      \"type\": \"string\",\n      \"default\": \"idle\"\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"runSpeed\",\n      \"type\": \"float\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"chaseSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"energy\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fearThreshold\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"aggressionThreshold\",\n      \"type\": \"float\",\n      \"default\": 70\n    },\n    {\n      \"name\": \"exhaustionThreshold\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"breathingSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"questioningSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"panicSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"roarSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"tiredSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalColor\",\n      \"type\": \"Color\",\n      \"default\": \"white\"\n    },\n    {\n      \"name\": \"redColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    },\n    {\n      \"name\": \"darkColor\",\n      \"type\": \"Color\",\n      \"default\": \"black\"\n    },\n    {\n      \"name\": \"grayColor\",\n      \"type\": \"Color\",\n      \"default\": \"gray\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"idle_behavior\",\n      \"trigger\": \"when current state is idle\",\n      \"actions\": [\n        {\n          \"action\": \"remain stationary\"\n        },\n        {\n          \"action\": \"play breathing sound on loop\"\n        },\n        {\n          \"action\": \"set color to normal color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_curious\",\n      \"trigger\": \"when current state is idle and player is within detection range and energy is above exhaustion threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change current state to curious\"\n        },\n        {\n          \"action\": \"stop breathing sound\"\n        },\n        {\n          \"action\": \"play questioning sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"curious_behavior\",\n      \"trigger\": \"when current state is curious\",\n      \"actions\": [\n        {\n          \"action\": \"slowly move toward player at walk speed\"\n        },\n        {\n          \"action\": \"decrease energy gradually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_scared\",\n      \"trigger\": \"when current state is curious and energy is below fear threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change current state to scared\"\n        },\n        {\n          \"action\": \"play panic sound\"\n        },\n        {\n          \"action\": \"set color to red color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"scared_behavior\",\n      \"trigger\": \"when current state is scared\",\n      \"actions\": [\n        {\n          \"action\": \"run away from player at run speed\"\n        },\n        {\n          \"action\": \"decrease energy rapidly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_aggressive\",\n      \"trigger\": \"when current state is curious and energy is above aggression threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change current state to aggressive\"\n        },\n        {\n          \"action\": \"play roar sound\"\n        },\n        {\n          \"action\": \"set color to dark color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"aggressive_behavior\",\n      \"trigger\": \"when current state is aggressive\",\n      \"actions\": [\n        {\n          \"action\": \"chase player at chase speed\"\n        },\n        {\n          \"action\": \"decrease energy rapidly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_exhausted\",\n      \"trigger\": \"when energy falls below exhaustion threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change current state to exhausted\"\n        },\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"play tired sound\"\n        },\n        {\n          \"action\": \"set color to gray color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exhausted_behavior\",\n      \"trigger\": \"when current state is exhausted\",\n      \"actions\": [\n        {\n          \"action\": \"remain completely still\"\n        },\n        {\n          \"action\": \"slowly recover energy over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"recover_from_exhaustion\",\n      \"trigger\": \"when current state is exhausted and energy is above fear threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change current state to idle\"\n        },\n        {\n          \"action\": \"set color to normal color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class CreatureStateMachine : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _scareRange = 5f;\n    [SerializeField] private float _aggressionRange = 3f;\n    [SerializeField] private LayerMask _playerLayerMask = -1;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _curiousSpeed = 2f;\n    [SerializeField] private float _scaredSpeed = 8f;\n    [SerializeField] private float _aggressiveSpeed = 6f;\n    [SerializeField] private float _rotationSpeed = 5f;\n    \n    [Header(\"State Duration Settings\")]\n    [SerializeField] private float _curiousStateDuration = 5f;\n    [SerializeField] private float _scaredStateDuration = 3f;\n    [SerializeField] private float _aggressiveStateDuration = 8f;\n    [SerializeField] private float _exhaustedStateDuration = 4f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _questioningSound;\n    [SerializeField] private AudioClip _panicSound;\n    [SerializeField] private AudioClip _roarSound;\n    [SerializeField] private AudioClip _tiredSound;\n    [SerializeField] private float _ambientBreathingInterval = 3f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _creatureRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _scaredColor = Color.red;\n    [SerializeField] private Color _aggressiveColor = Color.black;\n    [SerializeField] private Color _exhaustedColor = Color.gray;\n    [SerializeField] private float _colorTransitionSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStateChanged;\n    public UnityEvent<CreatureState> OnSpecificStateEntered;\n    \n    public enum CreatureState\n    {\n        Idle,\n        Curious,\n        Scared,\n        Aggressive,\n        Exhausted\n    }\n    \n    private CreatureState _currentState = CreatureState.Idle;\n    private Transform _player;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Vector3 _initialPosition;\n    private float _stateTimer;\n    private float _breathingTimer;\n    private Color _targetColor;\n    private Color _currentColor;\n    private bool _hasPlayedStateSound;\n    \n    public CreatureState CurrentState => _currentState;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_creatureRenderer == null)\n        {\n            _creatureRenderer = GetComponent<Renderer>();\n        }\n        \n        _initialPosition = transform.position;\n        _targetColor = _normalColor;\n        _currentColor = _normalColor;\n        \n        if (_creatureRenderer != null)\n        {\n            _creatureRenderer.material.color = _currentColor;\n        }\n        \n        FindPlayer();\n        ChangeState(CreatureState.Idle);\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n        }\n        \n        UpdateStateLogic();\n        UpdateVisuals();\n        UpdateAudio();\n        \n        _stateTimer += Time.deltaTime;\n        _breathingTimer += Time.deltaTime;\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateStateLogic()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        switch (_currentState)\n        {\n            case CreatureState.Idle:\n                HandleIdleState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Curious:\n                HandleCuriousState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Scared:\n                HandleScaredState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Aggressive:\n                HandleAggressiveState(distanceToPlayer);\n                break;\n                \n            case CreatureState.Exhausted:\n                HandleExhaustedState();\n                break;\n        }\n    }\n    \n    void HandleIdleState(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _detectionRange && distanceToPlayer > _scareRange)\n        {\n            ChangeState(CreatureState.Curious);\n        }\n        else if (distanceToPlayer <= _scareRange && distanceToPlayer > _aggressionRange)\n        {\n            ChangeState(CreatureState.Scared);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n    }\n    \n    void HandleCuriousState(float distanceToPlayer)\n    {\n        if (distanceToPlayer <= _scareRange && distanceToPlayer > _aggressionRange)\n        {\n            ChangeState(CreatureState.Scared);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n        else if (distanceToPlayer > _detectionRange || _stateTimer >= _curiousStateDuration)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n        else\n        {\n            MoveTowardsPlayer(_curiousSpeed);\n        }\n    }\n    \n    void HandleScaredState(float distanceToPlayer)\n    {\n        if (_stateTimer >= _scaredStateDuration)\n        {\n            ChangeState(CreatureState.Exhausted);\n        }\n        else if (distanceToPlayer <= _aggressionRange)\n        {\n            ChangeState(CreatureState.Aggressive);\n        }\n        else\n        {\n            MoveAwayFromPlayer(_scaredSpeed);\n        }\n    }\n    \n    void HandleAggressiveState(float distanceToPlayer)\n    {\n        if (_stateTimer >= _aggressiveStateDuration)\n        {\n            ChangeState(CreatureState.Exhausted);\n        }\n        else if (distanceToPlayer > _detectionRange)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n        else\n        {\n            MoveTowardsPlayer(_aggressiveSpeed);\n        }\n    }\n    \n    void HandleExhaustedState()\n    {\n        if (_stateTimer >= _exhaustedStateDuration)\n        {\n            ChangeState(CreatureState.Idle);\n        }\n    }\n    \n    void MoveTowardsPlayer(float speed)\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void MoveAwayFromPlayer(float speed)\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (transform.position - _player.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_creatureRenderer == null) return;\n        \n        _currentColor = Color.Lerp(_currentColor, _targetColor, _colorTransitionSpeed * Time.deltaTime);\n        _creatureRenderer.material.color = _currentColor;\n    }\n    \n    void UpdateAudio()\n    {\n        if (_currentState == CreatureState.Idle && _breathingTimer >= _ambientBreathingInterval)\n        {\n            PlaySound(_breathingSound);\n            _breathingTimer = 0f;\n        }\n    }\n    \n    void ChangeState(CreatureState newState)\n    {\n        if (_currentState == newState) return;\n        \n        _currentState = newState;\n        _stateTimer = 0f;\n        _hasPlayedStateSound = false;\n        \n        switch (newState)\n        {\n            case CreatureState.Idle:\n                _targetColor = _normalColor;\n                _rigidbody.velocity = Vector3.zero;\n                break;\n                \n            case CreatureState.Curious:\n                _targetColor = _normalColor;\n                PlaySound(_questioningSound);\n                break;\n                \n            case CreatureState.Scared:\n                _targetColor = _scaredColor;\n                PlaySound(_panicSound);\n                break;\n                \n            case CreatureState.Aggressive:\n                _targetColor = _aggressiveColor;\n                PlaySound(_roarSound);\n                break;\n                \n            case CreatureState.Exhausted:\n                _targetColor = _exhaustedColor;\n                _rigidbody.velocity = Vector3.zero;\n                PlaySound(_tiredSound);\n                break;\n        }\n        \n        OnStateChanged?.Invoke();\n        OnSpecificStateEntered?.Invoke(newState);\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.orange;\n        Gizmos.DrawWireSphere(transform.position, _scareRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _aggressionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DashAbility\",\n  \"components\": [\n    \"Rigidbody2D\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dashForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"dashDuration\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"currentCooldown\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isDashing\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"dash_input\",\n      \"trigger\": \"when dash key is pressed and cooldown is finished and not currently dashing\",\n      \"actions\": [\n        {\n          \"action\": \"set dashing state to true\"\n        },\n        {\n          \"action\": \"apply dash force in movement direction\"\n        },\n        {\n          \"action\": \"start dash duration timer\"\n        },\n        {\n          \"action\": \"set cooldown to maximum cooldown time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_dash\",\n      \"trigger\": \"when dash duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"set dashing state to false\"\n        },\n        {\n          \"action\": \"stop applying dash force\"\n        },\n        {\n          \"action\": \"reset dash duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooldown_timer\",\n      \"trigger\": \"every frame when cooldown is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"reduce cooldown by time elapsed this frame\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DashAbility : MonoBehaviour\n{\n    [Header(\"Dash Settings\")]\n    [SerializeField] private float _dashDistance = 5f;\n    [SerializeField] private float _dashDuration = 0.2f;\n    [SerializeField] private float _dashCooldown = 2f;\n    [SerializeField] private KeyCode _dashKey = KeyCode.LeftShift;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    [SerializeField] private float _raycastRadius = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _dashEffect;\n    [SerializeField] private TrailRenderer _dashTrail;\n    [SerializeField] private float _invulnerabilityDuration = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _dashSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDashStart;\n    public UnityEvent OnDashEnd;\n    public UnityEvent OnDashCooldownComplete;\n    \n    private Rigidbody2D _rigidbody2D;\n    private Collider2D _collider2D;\n    private Vector2 _originalVelocity;\n    private bool _isDashing;\n    private bool _isOnCooldown;\n    private float _cooldownTimer;\n    private float _dashTimer;\n    private Vector2 _dashDirection;\n    private Vector2 _dashStartPosition;\n    private Vector2 _dashTargetPosition;\n    \n    public bool IsDashing => _isDashing;\n    public bool IsOnCooldown => _isOnCooldown;\n    public float CooldownProgress => _isOnCooldown ? (_dashCooldown - _cooldownTimer) / _dashCooldown : 1f;\n    \n    private void Awake()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _collider2D = GetComponent<Collider2D>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        if (_dashTrail != null)\n            _dashTrail.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateDash();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_dashKey) && CanDash())\n        {\n            Vector2 inputDirection = GetInputDirection();\n            if (inputDirection != Vector2.zero)\n            {\n                StartDash(inputDirection);\n            }\n        }\n    }\n    \n    private Vector2 GetInputDirection()\n    {\n        float horizontal = Input.GetAxisRaw(\"Horizontal\");\n        float vertical = Input.GetAxisRaw(\"Vertical\");\n        return new Vector2(horizontal, vertical).normalized;\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnDashCooldownComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateDash()\n    {\n        if (!_isDashing) return;\n        \n        _dashTimer -= Time.deltaTime;\n        \n        float dashProgress = 1f - (_dashTimer / _dashDuration);\n        Vector2 currentPosition = Vector2.Lerp(_dashStartPosition, _dashTargetPosition, dashProgress);\n        transform.position = currentPosition;\n        \n        if (_dashTimer <= 0f)\n        {\n            EndDash();\n        }\n    }\n    \n    private bool CanDash()\n    {\n        return !_isDashing && !_isOnCooldown && _rigidbody2D != null;\n    }\n    \n    private void StartDash(Vector2 direction)\n    {\n        _dashDirection = direction;\n        _dashStartPosition = transform.position;\n        \n        Vector2 targetPosition = _dashStartPosition + (_dashDirection * _dashDistance);\n        RaycastHit2D hit = Physics2D.CircleCast(_dashStartPosition, _raycastRadius, _dashDirection, _dashDistance, _obstacleLayerMask);\n        \n        if (hit.collider != null && hit.collider != _collider2D)\n        {\n            _dashTargetPosition = hit.point - (_dashDirection * _raycastRadius);\n        }\n        else\n        {\n            _dashTargetPosition = targetPosition;\n        }\n        \n        _isDashing = true;\n        _dashTimer = _dashDuration;\n        _originalVelocity = _rigidbody2D.velocity;\n        _rigidbody2D.velocity = Vector2.zero;\n        _rigidbody2D.isKinematic = true;\n        \n        if (_collider2D != null && _invulnerabilityDuration > 0f)\n        {\n            _collider2D.enabled = false;\n            Invoke(nameof(RestoreCollider), _invulnerabilityDuration);\n        }\n        \n        if (_dashTrail != null)\n            _dashTrail.enabled = true;\n        \n        if (_dashEffect != null)\n            _dashEffect.Play();\n        \n        if (_audioSource != null && _dashSound != null)\n            _audioSource.PlayOneShot(_dashSound);\n        \n        OnDashStart?.Invoke();\n    }\n    \n    private void EndDash()\n    {\n        _isDashing = false;\n        _rigidbody2D.isKinematic = false;\n        _rigidbody2D.velocity = _originalVelocity;\n        \n        _isOnCooldown = true;\n        _cooldownTimer = _dashCooldown;\n        \n        if (_dashTrail != null)\n            _dashTrail.enabled = false;\n        \n        OnDashEnd?.Invoke();\n    }\n    \n    private void RestoreCollider()\n    {\n        if (_collider2D != null)\n            _collider2D.enabled = true;\n    }\n    \n    public void SetDashDistance(float distance)\n    {\n        _dashDistance = Mathf.Max(0f, distance);\n    }\n    \n    public void SetDashCooldown(float cooldown)\n    {\n        _dashCooldown = Mathf.Max(0f, cooldown);\n    }\n    \n    public void ResetCooldown()\n    {\n        _isOnCooldown = false;\n        _cooldownTimer = 0f;\n    }\n    \n    public void ForceDash(Vector2 direction)\n    {\n        if (!_isDashing && direction != Vector2.zero)\n        {\n            StartDash(direction.normalized);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _raycastRadius);\n        \n        if (_isDashing)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_dashStartPosition, _dashTargetPosition);\n        }\n        else\n        {\n            Vector2 inputDir = GetInputDirection();\n            if (inputDir != Vector2.zero)\n            {\n                Gizmos.color = Color.green;\n                Gizmos.DrawRay(transform.position, inputDir * _dashDistance);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ArcherEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"optimalDistance\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"shootCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"arrowPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shootPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"int\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"enter combat state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_distance\",\n      \"trigger\": \"when player is too close to optimal distance\",\n      \"actions\": [\n        {\n          \"action\": \"move backward away from player at move speed\"\n        },\n        {\n          \"action\": \"continue facing player while moving\"\n        }\n      ]\n    },\n    {\n      \"name\": \"approach_player\",\n      \"trigger\": \"when player is too far from optimal distance but within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"move forward toward player at move speed\"\n        },\n        {\n          \"action\": \"stop when reaching optimal distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shoot_arrow\",\n      \"trigger\": \"when player is at optimal distance and shoot cooldown is ready\",\n      \"actions\": [\n        {\n          \"action\": \"play shooting animation\"\n        },\n        {\n          \"action\": \"instantiate arrow at shoot point\"\n        },\n        {\n          \"action\": \"launch arrow toward player position\"\n        },\n        {\n          \"action\": \"start shoot cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_player\",\n      \"trigger\": \"when player leaves detection range\",\n      \"actions\": [\n        {\n          \"action\": \"return to idle state\"\n        },\n        {\n          \"action\": \"stop all movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt animation\"\n        },\n        {\n          \"action\": \"if health reaches zero then destroy self\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ArcherEnemy : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _loseTargetRange = 20f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n\n    [Header(\"Combat\")]\n    [SerializeField] private float _preferredDistance = 8f;\n    [SerializeField] private float _minDistance = 5f;\n    [SerializeField] private float _maxDistance = 12f;\n    [SerializeField] private float _shootCooldown = 2f;\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _shootPoint;\n    [SerializeField] private float _arrowSpeed = 10f;\n\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _backpedalSpeed = 4f;\n    [SerializeField] private float _strafeSpeed = 3.5f;\n    [SerializeField] private float _rotationSpeed = 5f;\n\n    [Header(\"Health\")]\n    [SerializeField] private int _maxHealth = 50;\n    [SerializeField] private float _hitStunDuration = 0.3f;\n\n    [Header(\"Events\")]\n    public UnityEvent OnPlayerDetected;\n    public UnityEvent OnPlayerLost;\n    public UnityEvent OnArrowShot;\n    public UnityEvent OnDeath;\n\n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private int _currentHealth;\n    private float _lastShootTime;\n    private float _hitStunEndTime;\n    private bool _hasTarget;\n    private Vector3 _lastKnownPlayerPosition;\n    private float _strafeDirection = 1f;\n    private float _strafeTimer;\n\n    private enum State\n    {\n        Idle,\n        Pursuing,\n        Maintaining,\n        Retreating,\n        Strafing,\n        Stunned,\n        Dead\n    }\n\n    private State _currentState = State.Idle;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _currentHealth = _maxHealth;\n\n        if (_shootPoint == null)\n            _shootPoint = transform;\n\n        if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n    }\n\n    private void Update()\n    {\n        if (_currentState == State.Dead) return;\n\n        HandleTargetDetection();\n        UpdateState();\n        HandleShooting();\n        UpdateAnimations();\n    }\n\n    private void FixedUpdate()\n    {\n        if (_currentState == State.Dead || _currentState == State.Stunned) return;\n\n        HandleMovement();\n        HandleRotation();\n    }\n\n    private void HandleTargetDetection()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        \n        if (player == null)\n        {\n            if (_hasTarget)\n            {\n                LoseTarget();\n            }\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n\n        if (!_hasTarget && distanceToPlayer <= _detectionRange)\n        {\n            if (HasLineOfSight(player.transform.position))\n            {\n                AcquireTarget(player.transform);\n            }\n        }\n        else if (_hasTarget && distanceToPlayer > _loseTargetRange)\n        {\n            LoseTarget();\n        }\n        else if (_hasTarget)\n        {\n            _lastKnownPlayerPosition = player.transform.position;\n        }\n    }\n\n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - _shootPoint.position;\n        float distance = direction.magnitude;\n        \n        return !Physics.Raycast(_shootPoint.position, direction.normalized, distance, _obstacleLayer);\n    }\n\n    private void AcquireTarget(Transform playerTransform)\n    {\n        _player = playerTransform;\n        _hasTarget = true;\n        _lastKnownPlayerPosition = playerTransform.position;\n        OnPlayerDetected?.Invoke();\n    }\n\n    private void LoseTarget()\n    {\n        _player = null;\n        _hasTarget = false;\n        _currentState = State.Idle;\n        OnPlayerLost?.Invoke();\n    }\n\n    private void UpdateState()\n    {\n        if (Time.time < _hitStunEndTime)\n        {\n            _currentState = State.Stunned;\n            return;\n        }\n\n        if (!_hasTarget)\n        {\n            _currentState = State.Idle;\n            return;\n        }\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _lastKnownPlayerPosition);\n\n        if (distanceToPlayer < _minDistance)\n        {\n            _currentState = State.Retreating;\n        }\n        else if (distanceToPlayer > _maxDistance)\n        {\n            _currentState = State.Pursuing;\n        }\n        else\n        {\n            _strafeTimer += Time.deltaTime;\n            if (_strafeTimer > 2f)\n            {\n                _strafeDirection *= -1f;\n                _strafeTimer = 0f;\n            }\n            _currentState = State.Strafing;\n        }\n    }\n\n    private void HandleMovement()\n    {\n        if (!_hasTarget || _rigidbody == null) return;\n\n        Vector3 moveDirection = Vector3.zero;\n        Vector3 toPlayer = (_lastKnownPlayerPosition - transform.position).normalized;\n        Vector3 strafeDirection = Vector3.Cross(toPlayer, Vector3.up) * _strafeDirection;\n\n        switch (_currentState)\n        {\n            case State.Pursuing:\n                moveDirection = toPlayer * _moveSpeed;\n                break;\n\n            case State.Retreating:\n                moveDirection = -toPlayer * _backpedalSpeed;\n                break;\n\n            case State.Strafing:\n                moveDirection = strafeDirection * _strafeSpeed;\n                break;\n        }\n\n        if (moveDirection != Vector3.zero)\n        {\n            _rigidbody.velocity = new Vector3(moveDirection.x, _rigidbody.velocity.y, moveDirection.z);\n        }\n        else\n        {\n            _rigidbody.velocity = new Vector3(0, _rigidbody.velocity.y, 0);\n        }\n    }\n\n    private void HandleRotation()\n    {\n        if (!_hasTarget) return;\n\n        Vector3 lookDirection = (_lastKnownPlayerPosition - transform.position).normalized;\n        lookDirection.y = 0;\n\n        if (lookDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(lookDirection);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.fixedDeltaTime);\n        }\n    }\n\n    private void HandleShooting()\n    {\n        if (!_hasTarget || _currentState == State.Stunned) return;\n        if (Time.time < _lastShootTime + _shootCooldown) return;\n\n        float distanceToPlayer = Vector3.Distance(transform.position, _lastKnownPlayerPosition);\n        if (distanceToPlayer <= _maxDistance && HasLineOfSight(_lastKnownPlayerPosition))\n        {\n            ShootArrow();\n        }\n    }\n\n    private void ShootArrow()\n    {\n        if (_arrowPrefab == null) return;\n\n        Vector3 shootDirection = (_lastKnownPlayerPosition - _shootPoint.position).normalized;\n        GameObject arrow = Instantiate(_arrowPrefab, _shootPoint.position, Quaternion.LookRotation(shootDirection));\n        \n        Rigidbody arrowRb = arrow.GetComponent<Rigidbody>();\n        if (arrowRb != null)\n        {\n            arrowRb.velocity = shootDirection * _arrowSpeed;\n        }\n\n        Arrow arrowComponent = arrow.GetComponent<Arrow>();\n        if (arrowComponent == null)\n        {\n            arrowComponent = arrow.AddComponent<Arrow>();\n        }\n        arrowComponent.Initialize(10, 5f);\n\n        _lastShootTime = Time.time;\n        OnArrowShot?.Invoke();\n    }\n\n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n\n        _animator.SetBool(\"HasTarget\", _hasTarget);\n        _animator.SetFloat(\"Speed\", _rigidbody != null ? _rigidbody.velocity.magnitude : 0f);\n        _animator.SetBool(\"IsRetreating\", _currentState == State.Retreating);\n        _animator.SetBool(\"IsStunned\", _currentState == State.Stunned);\n    }\n\n    public void TakeDamage(int damage)\n    {\n        if (_currentState == State.Dead) return;\n\n        _currentHealth -= damage;\n        _hitStunEndTime = Time.time + _hitStunDuration;\n\n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        _currentState = State.Dead;\n        _hasTarget = false;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n\n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Die\");\n        }\n\n        OnDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState != State.Dead)\n        {\n            if (!_hasTarget)\n            {\n                AcquireTarget(other.transform);\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _minDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _preferredDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _maxDistance);\n    }\n\n    [System.Serializable]\n    public class Arrow : MonoBehaviour\n    {\n        private int _damage;\n        private float _lifetime;\n        private float _spawnTime;\n\n        public void Initialize(int damage, float lifetime)\n        {\n            _damage = damage;\n            _lifetime = lifetime;\n            _spawnTime = Time.time;\n        }\n\n        private void Update()\n        {\n            if (Time.time > _spawnTime + _lifetime)\n            {\n                Destroy(gameObject);\n            }\n        }\n\n        private void OnTriggerEnter(Collider other)\n        {\n            if (other.CompareTag(\"Player\"))\n            {\n                ArcherEnemy archer = other.GetComponent<ArcherEnemy>();\n                if (archer != null)\n                {\n                    archer.TakeDamage(_damage);\n                }\n                Destroy(gameObject);\n            }\n            else if (!other.isTrigger)\n            {\n                Destroy(gameObject);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FoodItem\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"staminaRestoreAmount\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isConsumed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"restore_stamina_on_pickup\",\n      \"trigger\": \"when player touches this food item\",\n      \"actions\": [\n        {\n          \"action\": \"increase player stamina by stamina restore amount\"\n        },\n        {\n          \"action\": \"mark this food item as consumed\"\n        },\n        {\n          \"action\": \"destroy this food item\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_multiple_consumption\",\n      \"trigger\": \"when player tries to interact with already consumed food\",\n      \"actions\": [\n        {\n          \"action\": \"do nothing\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FoodItem : MonoBehaviour\n{\n    [Header(\"Food Properties\")]\n    [SerializeField] private float _staminaRestoreAmount = 25f;\n    [SerializeField] private bool _destroyOnUse = true;\n    [SerializeField] private float _interactionRange = 2f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _consumeEffect;\n    [SerializeField] private AudioClip _consumeSound;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    \n    [Header(\"UI\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnStaminaRestore;\n    public UnityEvent OnFoodConsumed;\n    \n    private Renderer _renderer;\n    private Color _originalColor;\n    private AudioSource _audioSource;\n    private bool _isPlayerInRange = false;\n    private GameObject _currentPlayer;\n    private Camera _mainCamera;\n    \n    [System.Serializable]\n    public class PlayerStamina\n    {\n        public float currentStamina = 100f;\n        public float maxStamina = 100f;\n        \n        public void RestoreStamina(float amount)\n        {\n            currentStamina = Mathf.Min(currentStamina + amount, maxStamina);\n        }\n        \n        public float GetStaminaPercentage()\n        {\n            return currentStamina / maxStamina;\n        }\n    }\n    \n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _mainCamera = Camera.main;\n        \n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n        \n        SetupCollider();\n    }\n    \n    private void SetupCollider()\n    {\n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            SphereCollider sphereCol = gameObject.AddComponent<SphereCollider>();\n            sphereCol.isTrigger = true;\n            sphereCol.radius = _interactionRange;\n        }\n        else\n        {\n            col.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPlayerInRange && _currentPlayer != null)\n        {\n            if (Input.GetKeyDown(_interactionKey))\n            {\n                ConsumeFoodItem();\n            }\n            \n            UpdateInteractionPromptPosition();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInRange = true;\n            _currentPlayer = other.gameObject;\n            ShowInteractionPrompt();\n            HighlightItem(true);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerInRange = false;\n            _currentPlayer = null;\n            HideInteractionPrompt();\n            HighlightItem(false);\n        }\n    }\n    \n    private void ConsumeFoodItem()\n    {\n        if (_currentPlayer == null) return;\n        \n        PlayerStamina playerStamina = _currentPlayer.GetComponent<PlayerStamina>();\n        if (playerStamina == null)\n        {\n            playerStamina = _currentPlayer.AddComponent<PlayerStamina>();\n        }\n        \n        float previousStamina = playerStamina.currentStamina;\n        playerStamina.RestoreStamina(_staminaRestoreAmount);\n        float actualRestored = playerStamina.currentStamina - previousStamina;\n        \n        OnStaminaRestore?.Invoke(actualRestored);\n        OnFoodConsumed?.Invoke();\n        \n        PlayConsumeEffects();\n        \n        Debug.Log($\"Restored {actualRestored} stamina. Current: {playerStamina.currentStamina}/{playerStamina.maxStamina}\");\n        \n        if (_destroyOnUse)\n        {\n            HideInteractionPrompt();\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void PlayConsumeEffects()\n    {\n        if (_consumeEffect != null)\n        {\n            GameObject effect = Instantiate(_consumeEffect, transform.position, transform.rotation);\n            Destroy(effect, 3f);\n        }\n        \n        if (_consumeSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_consumeSound);\n        }\n    }\n    \n    private void HighlightItem(bool highlight)\n    {\n        if (_renderer == null) return;\n        \n        if (highlight)\n        {\n            _renderer.material.color = _highlightColor;\n        }\n        else\n        {\n            _renderer.material.color = _originalColor;\n        }\n    }\n    \n    private void ShowInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(true);\n        }\n    }\n    \n    private void HideInteractionPrompt()\n    {\n        if (_interactionPrompt != null)\n        {\n            _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void UpdateInteractionPromptPosition()\n    {\n        if (_interactionPrompt == null || _mainCamera == null) return;\n        \n        Vector3 screenPos = _mainCamera.WorldToScreenPoint(transform.position + Vector3.up * 2f);\n        _interactionPrompt.transform.position = screenPos;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n    \n    public void SetStaminaRestoreAmount(float amount)\n    {\n        _staminaRestoreAmount = Mathf.Max(0f, amount);\n    }\n    \n    public float GetStaminaRestoreAmount()\n    {\n        return _staminaRestoreAmount;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ItemPickupNotification\",\n  \"components\": [\n    \"Canvas\",\n    \"Text\",\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"slideDistance\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"notificationText\",\n      \"type\": \"string\",\n      \"default\": \"Item Collected!\"\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_pickup_notification\",\n      \"trigger\": \"when item is collected by player\",\n      \"actions\": [\n        {\n          \"action\": \"display notification text with item name\"\n        },\n        {\n          \"action\": \"make notification visible on screen\"\n        },\n        {\n          \"action\": \"slide notification in from top of screen\"\n        },\n        {\n          \"action\": \"set notification as currently visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out_notification\",\n      \"trigger\": \"when display duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade out notification opacity\"\n        },\n        {\n          \"action\": \"slide notification upward while fading\"\n        },\n        {\n          \"action\": \"hide notification when fully transparent\"\n        },\n        {\n          \"action\": \"set notification as not visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_notification_text\",\n      \"trigger\": \"when new item pickup occurs while notification is visible\",\n      \"actions\": [\n        {\n          \"action\": \"update text to show new item name\"\n        },\n        {\n          \"action\": \"reset display timer to full duration\"\n        },\n        {\n          \"action\": \"briefly pulse notification size for emphasis\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ItemPickupNotification : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _notificationCanvas;\n    [SerializeField] private GameObject _notificationPrefab;\n    [SerializeField] private Transform _notificationParent;\n    \n    [Header(\"Notification Settings\")]\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _fadeInDuration = 0.3f;\n    [SerializeField] private float _fadeOutDuration = 0.5f;\n    [SerializeField] private Vector3 _slideOffset = new Vector3(0, 50f, 0);\n    [SerializeField] private int _maxNotifications = 5;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pickupSound;\n    \n    private Queue<NotificationData> _notificationQueue = new Queue<NotificationData>();\n    private List<GameObject> _activeNotifications = new List<GameObject>();\n    \n    [System.Serializable]\n    public class NotificationData\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public Color backgroundColor = Color.white;\n        public string description;\n        \n        public NotificationData(string name, Sprite icon, string desc = \"\")\n        {\n            itemName = name;\n            itemIcon = icon;\n            description = desc;\n        }\n    }\n    \n    private void Start()\n    {\n        if (_notificationCanvas == null)\n            _notificationCanvas = FindObjectOfType<Canvas>();\n            \n        if (_notificationParent == null && _notificationCanvas != null)\n            _notificationParent = _notificationCanvas.transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        CreateNotificationPrefab();\n    }\n    \n    private void CreateNotificationPrefab()\n    {\n        if (_notificationPrefab != null) return;\n        \n        _notificationPrefab = new GameObject(\"NotificationPrefab\");\n        _notificationPrefab.transform.SetParent(_notificationParent, false);\n        \n        RectTransform rectTransform = _notificationPrefab.AddComponent<RectTransform>();\n        rectTransform.sizeDelta = new Vector2(300f, 80f);\n        \n        Image background = _notificationPrefab.AddComponent<Image>();\n        background.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);\n        \n        GameObject iconObject = new GameObject(\"Icon\");\n        iconObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform iconRect = iconObject.AddComponent<RectTransform>();\n        iconRect.sizeDelta = new Vector2(60f, 60f);\n        iconRect.anchoredPosition = new Vector2(-100f, 0f);\n        Image iconImage = iconObject.AddComponent<Image>();\n        \n        GameObject textObject = new GameObject(\"Text\");\n        textObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform textRect = textObject.AddComponent<RectTransform>();\n        textRect.sizeDelta = new Vector2(200f, 60f);\n        textRect.anchoredPosition = new Vector2(50f, 10f);\n        Text itemText = textObject.AddComponent<Text>();\n        itemText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        itemText.fontSize = 16;\n        itemText.color = Color.white;\n        itemText.alignment = TextAnchor.MiddleLeft;\n        \n        GameObject descObject = new GameObject(\"Description\");\n        descObject.transform.SetParent(_notificationPrefab.transform, false);\n        RectTransform descRect = descObject.AddComponent<RectTransform>();\n        descRect.sizeDelta = new Vector2(200f, 30f);\n        descRect.anchoredPosition = new Vector2(50f, -15f);\n        Text descText = descObject.AddComponent<Text>();\n        descText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n        descText.fontSize = 12;\n        descText.color = new Color(0.8f, 0.8f, 0.8f, 1f);\n        descText.alignment = TextAnchor.MiddleLeft;\n        \n        CanvasGroup canvasGroup = _notificationPrefab.AddComponent<CanvasGroup>();\n        canvasGroup.alpha = 0f;\n        \n        _notificationPrefab.SetActive(false);\n    }\n    \n    public void ShowNotification(string itemName, Sprite itemIcon = null, string description = \"\")\n    {\n        NotificationData data = new NotificationData(itemName, itemIcon, description);\n        _notificationQueue.Enqueue(data);\n        \n        if (_audioSource != null && _pickupSound != null)\n            _audioSource.PlayOneShot(_pickupSound);\n            \n        ProcessNotificationQueue();\n    }\n    \n    public void ShowNotification(NotificationData data)\n    {\n        _notificationQueue.Enqueue(data);\n        \n        if (_audioSource != null && _pickupSound != null)\n            _audioSource.PlayOneShot(_pickupSound);\n            \n        ProcessNotificationQueue();\n    }\n    \n    private void ProcessNotificationQueue()\n    {\n        if (_notificationQueue.Count == 0) return;\n        if (_activeNotifications.Count >= _maxNotifications) return;\n        \n        NotificationData data = _notificationQueue.Dequeue();\n        GameObject notification = CreateNotification(data);\n        \n        if (notification != null)\n        {\n            _activeNotifications.Add(notification);\n            StartCoroutine(AnimateNotification(notification));\n        }\n    }\n    \n    private GameObject CreateNotification(NotificationData data)\n    {\n        if (_notificationPrefab == null || _notificationParent == null) return null;\n        \n        GameObject notification = Instantiate(_notificationPrefab, _notificationParent);\n        notification.SetActive(true);\n        \n        RectTransform rectTransform = notification.GetComponent<RectTransform>();\n        rectTransform.anchorMin = new Vector2(1f, 1f);\n        rectTransform.anchorMax = new Vector2(1f, 1f);\n        rectTransform.pivot = new Vector2(1f, 1f);\n        \n        float yOffset = -10f - (_activeNotifications.Count * 90f);\n        rectTransform.anchoredPosition = new Vector2(-10f, yOffset);\n        \n        Image background = notification.GetComponent<Image>();\n        if (background != null)\n            background.color = data.backgroundColor;\n        \n        Transform iconTransform = notification.transform.Find(\"Icon\");\n        if (iconTransform != null)\n        {\n            Image iconImage = iconTransform.GetComponent<Image>();\n            if (iconImage != null && data.itemIcon != null)\n            {\n                iconImage.sprite = data.itemIcon;\n                iconImage.color = Color.white;\n            }\n            else if (iconImage != null)\n            {\n                iconImage.color = Color.clear;\n            }\n        }\n        \n        Transform textTransform = notification.transform.Find(\"Text\");\n        if (textTransform != null)\n        {\n            Text itemText = textTransform.GetComponent<Text>();\n            if (itemText != null)\n                itemText.text = data.itemName;\n        }\n        \n        Transform descTransform = notification.transform.Find(\"Description\");\n        if (descTransform != null)\n        {\n            Text descText = descTransform.GetComponent<Text>();\n            if (descText != null)\n                descText.text = data.description;\n        }\n        \n        return notification;\n    }\n    \n    private IEnumerator AnimateNotification(GameObject notification)\n    {\n        if (notification == null) yield break;\n        \n        CanvasGroup canvasGroup = notification.GetComponent<CanvasGroup>();\n        RectTransform rectTransform = notification.GetComponent<RectTransform>();\n        \n        if (canvasGroup == null || rectTransform == null) yield break;\n        \n        Vector3 originalPosition = rectTransform.anchoredPosition;\n        Vector3 startPosition = originalPosition + _slideOffset;\n        rectTransform.anchoredPosition = startPosition;\n        \n        float elapsedTime = 0f;\n        while (elapsedTime < _fadeInDuration)\n        {\n            if (notification == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeInDuration;\n            \n            canvasGroup.alpha = Mathf.Lerp(0f, 1f, progress);\n            rectTransform.anchoredPosition = Vector3.Lerp(startPosition, originalPosition, progress);\n            \n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        rectTransform.anchoredPosition = originalPosition;\n        \n        yield return new WaitForSeconds(_displayDuration);\n        \n        elapsedTime = 0f;\n        while (elapsedTime < _fadeOutDuration)\n        {\n            if (notification == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeOutDuration;\n            \n            canvasGroup.alpha = Mathf.Lerp(1f, 0f, progress);\n            rectTransform.anchoredPosition = Vector3.Lerp(originalPosition, startPosition, progress);\n            \n            yield return null;\n        }\n        \n        if (notification != null)\n        {\n            _activeNotifications.Remove(notification);\n            Destroy(notification);\n            \n            UpdateNotificationPositions();\n            ProcessNotificationQueue();\n        }\n    }\n    \n    private void UpdateNotificationPositions()\n    {\n        for (int i = 0; i < _activeNotifications.Count; i++)\n        {\n            if (_activeNotifications[i] != null)\n            {\n                RectTransform rectTransform = _activeNotifications[i].GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    float yOffset = -10f - (i * 90f);\n                    Vector2 targetPosition = new Vector2(-10f, yOffset);\n                    StartCoroutine(SmoothMoveToPosition(rectTransform, targetPosition, 0.3f));\n                }\n            }\n        }\n    }\n    \n    private IEnumerator SmoothMoveToPosition(RectTransform rectTransform, Vector2 targetPosition, float duration)\n    {\n        Vector2 startPosition = rectTransform.anchoredPosition;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            if (rectTransform == null) yield break;\n            \n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / duration;\n            \n            rectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, progress);\n            \n            yield return null;\n        }\n        \n        if (rectTransform != null)\n            rectTransform.anchoredPosition = targetPosition;\n    }\n    \n    public void ClearAllNotifications()\n    {\n        StopAllCoroutines();\n        \n        foreach (GameObject notification in _activeNotifications)\n        {\n            if (notification != null)\n                Destroy(notification);\n        }\n        \n        _activeNotifications.Clear();\n        _notificationQueue.Clear();\n    }\n    \n    private void OnDestroy()\n    {\n        ClearAllNotifications();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwarmAgent\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swarmRadius\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"separationDistance\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"alignmentWeight\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"cohesionWeight\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"separationWeight\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"neighborDetectionRadius\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"swarmCenter\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"isLeader\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"targetPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_nearby_swarm_members\",\n      \"trigger\": \"continuously during gameplay\",\n      \"actions\": [\n        {\n          \"action\": \"scan for other swarm agents within neighbor detection radius\"\n        },\n        {\n          \"action\": \"store list of nearby swarm members for coordination\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_separation_force\",\n      \"trigger\": \"when nearby swarm members are too close\",\n      \"actions\": [\n        {\n          \"action\": \"determine direction away from overcrowded neighbors\"\n        },\n        {\n          \"action\": \"apply separation force to maintain minimum distance between agents\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_alignment_force\",\n      \"trigger\": \"when coordinating with nearby swarm members\",\n      \"actions\": [\n        {\n          \"action\": \"observe movement direction of neighboring agents\"\n        },\n        {\n          \"action\": \"adjust own movement direction to match average neighbor direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_cohesion_force\",\n      \"trigger\": \"when maintaining swarm unity\",\n      \"actions\": [\n        {\n          \"action\": \"find center position of nearby swarm members\"\n        },\n        {\n          \"action\": \"apply gentle force toward the local group center\"\n        }\n      ]\n    },\n    {\n      \"name\": \"follow_swarm_leader\",\n      \"trigger\": \"when not designated as leader and leader exists\",\n      \"actions\": [\n        {\n          \"action\": \"locate the designated swarm leader\"\n        },\n        {\n          \"action\": \"move toward leader position while maintaining swarm behaviors\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lead_swarm_movement\",\n      \"trigger\": \"when designated as swarm leader\",\n      \"actions\": [\n        {\n          \"action\": \"move toward the assigned target position\"\n        },\n        {\n          \"action\": \"broadcast movement intentions to nearby swarm members\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combine_movement_forces\",\n      \"trigger\": \"every frame during active movement\",\n      \"actions\": [\n        {\n          \"action\": \"blend separation, alignment, and cohesion forces with appropriate weights\"\n        },\n        {\n          \"action\": \"limit combined force to maximum speed threshold\"\n        },\n        {\n          \"action\": \"apply final movement vector to agent position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"avoid_obstacles\",\n      \"trigger\": \"when obstacles detected in movement path\",\n      \"actions\": [\n        {\n          \"action\": \"detect solid obstacles ahead of current movement direction\"\n        },\n        {\n          \"action\": \"calculate avoidance vector around detected obstacles\"\n        },\n        {\n          \"action\": \"blend obstacle avoidance with swarm coordination forces\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_swarm_boundaries\",\n      \"trigger\": \"when moving too far from swarm center\",\n      \"actions\": [\n        {\n          \"action\": \"check distance from overall swarm center position\"\n        },\n        {\n          \"action\": \"apply return force when exceeding maximum swarm radius\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class SwarmAI : MonoBehaviour\n{\n    [Header(\"Swarm Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _separationRadius = 2f;\n    [SerializeField] private float _alignmentRadius = 5f;\n    [SerializeField] private float _cohesionRadius = 8f;\n    \n    [Header(\"Movement Forces\")]\n    [SerializeField] private float _separationForce = 2f;\n    [SerializeField] private float _alignmentForce = 1f;\n    [SerializeField] private float _cohesionForce = 1f;\n    [SerializeField] private float _seekForce = 1.5f;\n    [SerializeField] private float _maxSpeed = 5f;\n    [SerializeField] private float _maxForce = 3f;\n    \n    [Header(\"Target Settings\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _followPlayer = true;\n    [SerializeField] private float _wanderRadius = 15f;\n    [SerializeField] private float _wanderChangeInterval = 3f;\n    \n    [Header(\"Avoidance\")]\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n    [SerializeField] private float _avoidanceRadius = 3f;\n    [SerializeField] private float _avoidanceForce = 4f;\n    \n    private Vector3 _velocity;\n    private Vector3 _wanderTarget;\n    private float _wanderTimer;\n    private List<SwarmAI> _neighbors;\n    private static List<SwarmAI> _allAgents = new List<SwarmAI>();\n    \n    private void Start()\n    {\n        _allAgents.Add(this);\n        _neighbors = new List<SwarmAI>();\n        _velocity = Random.insideUnitSphere * 2f;\n        _velocity.y = 0f;\n        \n        if (_followPlayer && _target == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _target = player.transform;\n        }\n        \n        GenerateWanderTarget();\n    }\n    \n    private void OnDestroy()\n    {\n        _allAgents.Remove(this);\n    }\n    \n    private void Update()\n    {\n        UpdateNeighbors();\n        Vector3 steeringForce = CalculateSteeringForce();\n        ApplyForce(steeringForce);\n        Move();\n        \n        _wanderTimer += Time.deltaTime;\n        if (_wanderTimer >= _wanderChangeInterval)\n        {\n            GenerateWanderTarget();\n            _wanderTimer = 0f;\n        }\n    }\n    \n    private void UpdateNeighbors()\n    {\n        _neighbors.Clear();\n        \n        foreach (SwarmAI agent in _allAgents)\n        {\n            if (agent == this) continue;\n            \n            float distance = Vector3.Distance(transform.position, agent.transform.position);\n            if (distance <= _detectionRadius)\n            {\n                _neighbors.Add(agent);\n            }\n        }\n    }\n    \n    private Vector3 CalculateSteeringForce()\n    {\n        Vector3 separation = CalculateSeparation();\n        Vector3 alignment = CalculateAlignment();\n        Vector3 cohesion = CalculateCohesion();\n        Vector3 seek = CalculateSeek();\n        Vector3 avoidance = CalculateObstacleAvoidance();\n        \n        Vector3 totalForce = separation * _separationForce +\n                           alignment * _alignmentForce +\n                           cohesion * _cohesionForce +\n                           seek * _seekForce +\n                           avoidance * _avoidanceForce;\n        \n        return Vector3.ClampMagnitude(totalForce, _maxForce);\n    }\n    \n    private Vector3 CalculateSeparation()\n    {\n        Vector3 steer = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _separationRadius)\n            {\n                Vector3 diff = transform.position - neighbor.transform.position;\n                diff.Normalize();\n                diff /= distance; // Weight by distance\n                steer += diff;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            steer /= count;\n            steer.Normalize();\n            steer *= _maxSpeed;\n            steer -= _velocity;\n        }\n        \n        return steer;\n    }\n    \n    private Vector3 CalculateAlignment()\n    {\n        Vector3 sum = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _alignmentRadius)\n            {\n                sum += neighbor._velocity;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            sum /= count;\n            sum.Normalize();\n            sum *= _maxSpeed;\n            Vector3 steer = sum - _velocity;\n            return steer;\n        }\n        \n        return Vector3.zero;\n    }\n    \n    private Vector3 CalculateCohesion()\n    {\n        Vector3 sum = Vector3.zero;\n        int count = 0;\n        \n        foreach (SwarmAI neighbor in _neighbors)\n        {\n            float distance = Vector3.Distance(transform.position, neighbor.transform.position);\n            if (distance > 0 && distance < _cohesionRadius)\n            {\n                sum += neighbor.transform.position;\n                count++;\n            }\n        }\n        \n        if (count > 0)\n        {\n            sum /= count;\n            return Seek(sum);\n        }\n        \n        return Vector3.zero;\n    }\n    \n    private Vector3 CalculateSeek()\n    {\n        Vector3 targetPos;\n        \n        if (_target != null)\n        {\n            targetPos = _target.position;\n        }\n        else\n        {\n            targetPos = _wanderTarget;\n        }\n        \n        return Seek(targetPos);\n    }\n    \n    private Vector3 Seek(Vector3 target)\n    {\n        Vector3 desired = target - transform.position;\n        desired.Normalize();\n        desired *= _maxSpeed;\n        \n        Vector3 steer = desired - _velocity;\n        return steer;\n    }\n    \n    private Vector3 CalculateObstacleAvoidance()\n    {\n        Vector3 avoidanceForce = Vector3.zero;\n        \n        Collider[] obstacles = Physics.OverlapSphere(transform.position, _avoidanceRadius, _obstacleLayer);\n        \n        foreach (Collider obstacle in obstacles)\n        {\n            Vector3 directionAway = transform.position - obstacle.ClosestPoint(transform.position);\n            if (directionAway.magnitude > 0)\n            {\n                directionAway.Normalize();\n                float distance = Vector3.Distance(transform.position, obstacle.ClosestPoint(transform.position));\n                directionAway /= distance; // Weight by distance\n                avoidanceForce += directionAway;\n            }\n        }\n        \n        return avoidanceForce;\n    }\n    \n    private void ApplyForce(Vector3 force)\n    {\n        _velocity += force * Time.deltaTime;\n        _velocity = Vector3.ClampMagnitude(_velocity, _maxSpeed);\n    }\n    \n    private void Move()\n    {\n        transform.position += _velocity * Time.deltaTime;\n        \n        if (_velocity.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(_velocity);\n        }\n    }\n    \n    private void GenerateWanderTarget()\n    {\n        Vector2 randomCircle = Random.insideUnitCircle * _wanderRadius;\n        _wanderTarget = transform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _separationRadius);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _alignmentRadius);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _cohesionRadius);\n        \n        Gizmos.color = Color.magenta;\n        Gizmos.DrawWireSphere(transform.position, _avoidanceRadius);\n        \n        if (_target != null)\n        {\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n        \n        Gizmos.color = Color.white;\n        Gizmos.DrawSphere(_wanderTarget, 0.5f);\n        \n        Gizmos.color = Color.black;\n        Gizmos.DrawRay(transform.position, _velocity);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExplosivePendulum\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"bellSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shockwaveEffect\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"bottomThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"hasTriggeredExplosion\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"natural_pendulum_swing\",\n      \"trigger\": \"always active\",\n      \"actions\": [\n        {\n          \"action\": \"allow physics to naturally swing the pendulum using gravity and momentum\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_bottom_position\",\n      \"trigger\": \"when pendulum reaches the bottom of its swing arc\",\n      \"actions\": [\n        {\n          \"action\": \"check if pendulum is at lowest point and moving slowly\"\n        },\n        {\n          \"action\": \"prepare to trigger explosion if not already triggered this swing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explosive_impact\",\n      \"trigger\": \"when pendulum is at bottom position and has not exploded this swing\",\n      \"actions\": [\n        {\n          \"action\": \"find all rigidbodies within explosion radius\"\n        },\n        {\n          \"action\": \"apply explosive force outward from pendulum position to each rigidbody\"\n        },\n        {\n          \"action\": \"play bell sound effect\"\n        },\n        {\n          \"action\": \"trigger shockwave particle effect at pendulum position\"\n        },\n        {\n          \"action\": \"mark explosion as triggered for this swing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_explosion_trigger\",\n      \"trigger\": \"when pendulum swings away from bottom position after explosion\",\n      \"actions\": [\n        {\n          \"action\": \"reset explosion trigger flag to allow next swing to explode\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplosivePendulum : MonoBehaviour\n{\n    [Header(\"Pendulum Physics\")]\n    [SerializeField] private Transform _pivotPoint;\n    [SerializeField] private float _pendulumLength = 5f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _damping = 0.995f;\n    [SerializeField] private float _initialAngle = 45f;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _explosionRadius = 10f;\n    [SerializeField] private float _upwardModifier = 3f;\n    [SerializeField] private float _bottomThreshold = 0.1f;\n    [SerializeField] private float _explosionCooldown = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _bellSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _shockwaveEffect;\n    [SerializeField] private GameObject _shockwavePrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnExplosion;\n    \n    private float _currentAngle;\n    private float _angularVelocity;\n    private bool _canExplode = true;\n    private float _lastExplosionTime;\n    private Vector3 _restPosition;\n    private bool _wasAtBottom;\n    \n    private void Start()\n    {\n        InitializePendulum();\n        SetupAudio();\n        SetupEffects();\n    }\n    \n    private void InitializePendulum()\n    {\n        if (_pivotPoint == null)\n            _pivotPoint = transform.parent != null ? transform.parent : transform;\n            \n        _currentAngle = _initialAngle * Mathf.Deg2Rad;\n        _angularVelocity = 0f;\n        _restPosition = _pivotPoint.position + Vector3.down * _pendulumLength;\n        \n        UpdatePendulumPosition();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n                _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.volume = _volume;\n    }\n    \n    private void SetupEffects()\n    {\n        if (_shockwaveEffect == null)\n        {\n            _shockwaveEffect = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        UpdatePendulumPhysics();\n        UpdatePendulumPosition();\n        CheckForExplosion();\n    }\n    \n    private void UpdatePendulumPhysics()\n    {\n        float angularAcceleration = -(_gravity / _pendulumLength) * Mathf.Sin(_currentAngle);\n        _angularVelocity += angularAcceleration * Time.fixedDeltaTime;\n        _angularVelocity *= _damping;\n        _currentAngle += _angularVelocity * Time.fixedDeltaTime;\n    }\n    \n    private void UpdatePendulumPosition()\n    {\n        Vector3 pendulumPosition = _pivotPoint.position + new Vector3(\n            Mathf.Sin(_currentAngle) * _pendulumLength,\n            -Mathf.Cos(_currentAngle) * _pendulumLength,\n            0f\n        );\n        \n        transform.position = pendulumPosition;\n        \n        Vector3 direction = (transform.position - _pivotPoint.position).normalized;\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, -direction);\n    }\n    \n    private void CheckForExplosion()\n    {\n        bool isAtBottom = IsAtBottomOfSwing();\n        \n        if (isAtBottom && !_wasAtBottom && _canExplode && Time.time - _lastExplosionTime > _explosionCooldown)\n        {\n            TriggerExplosion();\n        }\n        \n        _wasAtBottom = isAtBottom;\n    }\n    \n    private bool IsAtBottomOfSwing()\n    {\n        return Mathf.Abs(_currentAngle) < _bottomThreshold;\n    }\n    \n    private void TriggerExplosion()\n    {\n        _canExplode = false;\n        _lastExplosionTime = Time.time;\n        \n        ApplyExplosiveForce();\n        PlayBellSound();\n        CreateShockwaveEffect();\n        OnExplosion?.Invoke();\n        \n        Invoke(nameof(ResetExplosionCooldown), _explosionCooldown);\n    }\n    \n    private void ApplyExplosiveForce()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.gameObject == gameObject) continue;\n            \n            Rigidbody rb = col.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, _upwardModifier, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void PlayBellSound()\n    {\n        if (_audioSource != null && _bellSound != null)\n        {\n            _audioSource.PlayOneShot(_bellSound, _volume);\n        }\n    }\n    \n    private void CreateShockwaveEffect()\n    {\n        if (_shockwaveEffect != null)\n        {\n            _shockwaveEffect.transform.position = transform.position;\n            _shockwaveEffect.Play();\n        }\n        \n        if (_shockwavePrefab != null)\n        {\n            GameObject shockwave = Instantiate(_shockwavePrefab, transform.position, Quaternion.identity);\n            Destroy(shockwave, 5f);\n        }\n    }\n    \n    private void ResetExplosionCooldown()\n    {\n        _canExplode = true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsAtBottomOfSwing() && _canExplode)\n        {\n            Rigidbody otherRb = other.GetComponent<Rigidbody>();\n            if (otherRb != null)\n            {\n                TriggerExplosion();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_pivotPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_pivotPoint.position, 0.1f);\n            Gizmos.DrawLine(_pivotPoint.position, transform.position);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n            \n            Gizmos.color = Color.green;\n            Vector3 bottomPosition = _pivotPoint.position + Vector3.down * _pendulumLength;\n            Gizmos.DrawWireSphere(bottomPosition, _bottomThreshold * _pendulumLength);\n        }\n    }\n    \n    public void SetPendulumAngle(float angleInDegrees)\n    {\n        _currentAngle = angleInDegrees * Mathf.Deg2Rad;\n        _angularVelocity = 0f;\n        UpdatePendulumPosition();\n    }\n    \n    public void AddImpulse(float impulse)\n    {\n        _angularVelocity += impulse;\n    }\n    \n    public float GetCurrentAngle()\n    {\n        return _currentAngle * Mathf.Rad2Deg;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CoinMagnet\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"attractionRange\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"attractionForce\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attract_coins\",\n      \"trigger\": \"when coin is within attraction range\",\n      \"actions\": [\n        {\n          \"action\": \"pull coin toward magnet with attraction force\"\n        },\n        {\n          \"action\": \"increase coin movement speed as it gets closer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_coin\",\n      \"trigger\": \"when coin touches magnet\",\n      \"actions\": [\n        {\n          \"action\": \"destroy the coin\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class CoinMagnet : MonoBehaviour\n{\n    [Header(\"Magnet Settings\")]\n    [SerializeField] private float _attractionRadius = 5f;\n    [SerializeField] private float _attractionForce = 10f;\n    [SerializeField] private float _maxAttractionSpeed = 15f;\n    [SerializeField] private LayerMask _coinLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _magnetEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attractionSound;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showGizmos = true;\n    \n    private List<Rigidbody> _attractedCoins = new List<Rigidbody>();\n    private SphereCollider _detectionCollider;\n    \n    void Start()\n    {\n        SetupDetectionCollider();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    void SetupDetectionCollider()\n    {\n        _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _attractionRadius;\n    }\n    \n    void FixedUpdate()\n    {\n        AttractCoins();\n        CleanupNullReferences();\n    }\n    \n    void AttractCoins()\n    {\n        for (int i = _attractedCoins.Count - 1; i >= 0; i--)\n        {\n            if (_attractedCoins[i] == null)\n            {\n                _attractedCoins.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody coinRb = _attractedCoins[i];\n            Vector3 direction = (transform.position - coinRb.transform.position).normalized;\n            float distance = Vector3.Distance(transform.position, coinRb.transform.position);\n            \n            if (distance > _attractionRadius)\n            {\n                _attractedCoins.RemoveAt(i);\n                continue;\n            }\n            \n            float forceMagnitude = _attractionForce / Mathf.Max(distance, 0.1f);\n            Vector3 force = direction * forceMagnitude;\n            \n            coinRb.AddForce(force, ForceMode.Force);\n            \n            if (coinRb.velocity.magnitude > _maxAttractionSpeed)\n            {\n                coinRb.velocity = coinRb.velocity.normalized * _maxAttractionSpeed;\n            }\n        }\n    }\n    \n    void CleanupNullReferences()\n    {\n        _attractedCoins.RemoveAll(coin => coin == null);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (IsValidCoin(other))\n        {\n            Rigidbody coinRb = other.GetComponent<Rigidbody>();\n            if (coinRb != null && !_attractedCoins.Contains(coinRb))\n            {\n                _attractedCoins.Add(coinRb);\n                PlayAttractionEffect();\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        if (IsValidCoin(other))\n        {\n            Rigidbody coinRb = other.GetComponent<Rigidbody>();\n            if (coinRb != null)\n            {\n                _attractedCoins.Remove(coinRb);\n            }\n        }\n    }\n    \n    bool IsValidCoin(Collider other)\n    {\n        return other.CompareTag(\"Coin\") && \n               (_coinLayerMask.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    void PlayAttractionEffect()\n    {\n        if (_magnetEffect != null && !_magnetEffect.isPlaying)\n        {\n            _magnetEffect.Play();\n        }\n        \n        if (_audioSource != null && _attractionSound != null)\n        {\n            _audioSource.PlayOneShot(_attractionSound);\n        }\n    }\n    \n    public void SetAttractionRadius(float radius)\n    {\n        _attractionRadius = Mathf.Max(0f, radius);\n        if (_detectionCollider != null)\n        {\n            _detectionCollider.radius = _attractionRadius;\n        }\n    }\n    \n    public void SetAttractionForce(float force)\n    {\n        _attractionForce = Mathf.Max(0f, force);\n    }\n    \n    public int GetAttractedCoinCount()\n    {\n        return _attractedCoins.Count;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_showGizmos)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _attractionRadius);\n            \n            Gizmos.color = Color.red;\n            foreach (var coin in _attractedCoins)\n            {\n                if (coin != null)\n                {\n                    Gizmos.DrawLine(transform.position, coin.transform.position);\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SkillPointOrb\",\n  \"components\": [\n    \"Rigidbody\",\n    \"SphereCollider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"skillPointValue\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90.0\n    },\n    {\n      \"name\": \"attractionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"attractionSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"pulseSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"idle_floating\",\n      \"trigger\": \"when orb is spawned and not collected\",\n      \"actions\": [\n        {\n          \"action\": \"float up and down smoothly at specified height and speed\"\n        },\n        {\n          \"action\": \"rotate continuously around vertical axis at rotation speed\"\n        },\n        {\n          \"action\": \"pulse glow intensity using sine wave pattern\"\n        },\n        {\n          \"action\": \"emit magical particle effects around orb\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attract_to_player\",\n      \"trigger\": \"when player enters attraction range and orb is not collected\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player position at attraction speed\"\n        },\n        {\n          \"action\": \"increase glow intensity as orb gets closer to player\"\n        },\n        {\n          \"action\": \"play attraction sound effect\"\n        },\n        {\n          \"action\": \"increase particle emission rate\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_skill_points\",\n      \"trigger\": \"when orb collides with player\",\n      \"actions\": [\n        {\n          \"action\": \"add skill point value to player skill points\"\n        },\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"create bright flash particle burst\"\n        },\n        {\n          \"action\": \"display floating text showing skill points gained\"\n        },\n        {\n          \"action\": \"mark orb as collected\"\n        },\n        {\n          \"action\": \"destroy orb after brief delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"despawn_timer\",\n      \"trigger\": \"when orb exists for extended time without being collected\",\n      \"actions\": [\n        {\n          \"action\": \"start blinking glow effect to indicate despawn warning\"\n        },\n        {\n          \"action\": \"gradually fade out orb transparency\"\n        },\n        {\n          \"action\": \"destroy orb after fade completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SkillPointOrb : MonoBehaviour\n{\n    [Header(\"Orb Settings\")]\n    [SerializeField] private int _skillPointValue = 1;\n    [SerializeField] private float _collectRadius = 2f;\n    [SerializeField] private bool _autoCollect = true;\n    [SerializeField] private float _lifeTime = 30f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private bool _floatMovement = true;\n    [SerializeField] private float _floatSpeed = 1f;\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _attractionSpeed = 8f;\n    [SerializeField] private float _attractionRange = 5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnSkillPointCollected;\n    public UnityEvent OnOrbDestroyed;\n    \n    private Transform _player;\n    private Vector3 _startPosition;\n    private float _timeAlive;\n    private bool _isBeingCollected;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Vector3 _originalScale;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _originalScale = transform.localScale;\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n            _collider.radius = _collectRadius;\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        _timeAlive += Time.deltaTime;\n        \n        if (_timeAlive >= _lifeTime && !_isBeingCollected)\n        {\n            DestroyOrb();\n            return;\n        }\n        \n        if (_isBeingCollected)\n        {\n            MoveTowardsPlayer();\n            return;\n        }\n        \n        if (_floatMovement)\n        {\n            FloatAnimation();\n        }\n        \n        PulseEffect();\n        \n        if (_autoCollect && _player != null)\n        {\n            CheckForPlayerProximity();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    private void FloatAnimation()\n    {\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatAmplitude;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        \n        transform.Rotate(0, 50f * Time.deltaTime, 0);\n    }\n    \n    private void PulseEffect()\n    {\n        if (_renderer != null)\n        {\n            float pulse = 1f + Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n            transform.localScale = _originalScale * pulse;\n            \n            if (_originalMaterial != null)\n            {\n                Color color = _originalMaterial.color;\n                color.a = 0.7f + Mathf.Sin(Time.time * _pulseSpeed) * 0.3f;\n                _renderer.material.color = color;\n            }\n        }\n    }\n    \n    private void CheckForPlayerProximity()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attractionRange && !_isBeingCollected)\n        {\n            _isBeingCollected = true;\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        transform.position += direction * _attractionSpeed * Time.deltaTime;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= 0.5f)\n        {\n            CollectOrb();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isBeingCollected)\n        {\n            if (_autoCollect)\n            {\n                _isBeingCollected = true;\n            }\n            else\n            {\n                CollectOrb();\n            }\n        }\n    }\n    \n    private void CollectOrb()\n    {\n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        OnSkillPointCollected?.Invoke(_skillPointValue);\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n            Destroy(gameObject, _collectSound.length);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n    }\n    \n    private void DestroyOrb()\n    {\n        OnOrbDestroyed?.Invoke();\n        Destroy(gameObject);\n    }\n    \n    public void SetSkillPointValue(int value)\n    {\n        _skillPointValue = Mathf.Max(1, value);\n    }\n    \n    public int GetSkillPointValue()\n    {\n        return _skillPointValue;\n    }\n    \n    public void ForceCollect()\n    {\n        if (!_isBeingCollected)\n        {\n            _isBeingCollected = true;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_originalMaterial != null)\n        {\n            Destroy(_originalMaterial);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CollectibleCoin\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"collectSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_spin\",\n      \"trigger\": \"every frame while coin exists\",\n      \"actions\": [\n        {\n          \"action\": \"rotate coin around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_coin\",\n      \"trigger\": \"when player touches coin\",\n      \"actions\": [\n        {\n          \"action\": \"play collect sound\"\n        },\n        {\n          \"action\": \"destroy coin object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Coin : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 180, 0);\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _collectSoundVolume = 1f;\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _destroyDelay = 0.1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _collectEffectDuration = 2f;\n    \n    private AudioSource _audioSource;\n    private bool _isCollected = false;\n    private Collider _coinCollider;\n    private Renderer _coinRenderer;\n    \n    private void Start()\n    {\n        SetupAudioSource();\n        CacheComponents();\n    }\n    \n    private void Update()\n    {\n        if (!_isCollected)\n        {\n            RotateCoin();\n        }\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _collectSound;\n        _audioSource.volume = _collectSoundVolume;\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    private void CacheComponents()\n    {\n        _coinCollider = GetComponent<Collider>();\n        _coinRenderer = GetComponent<Renderer>();\n        \n        if (_coinCollider == null)\n        {\n            Debug.LogWarning($\"Coin {gameObject.name} is missing a Collider component!\");\n        }\n        else\n        {\n            _coinCollider.isTrigger = true;\n        }\n    }\n    \n    private void RotateCoin()\n    {\n        transform.Rotate(_rotationSpeed * Time.deltaTime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        DisableVisuals();\n        \n        if (_destroyOnCollect)\n        {\n            Destroy(gameObject, _destroyDelay);\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            Destroy(effect, _collectEffectDuration);\n        }\n    }\n    \n    private void DisableVisuals()\n    {\n        if (_coinRenderer != null)\n        {\n            _coinRenderer.enabled = false;\n        }\n        \n        if (_coinCollider != null)\n        {\n            _coinCollider.enabled = false;\n        }\n    }\n    \n    public void ResetCoin()\n    {\n        _isCollected = false;\n        \n        if (_coinRenderer != null)\n        {\n            _coinRenderer.enabled = true;\n        }\n        \n        if (_coinCollider != null)\n        {\n            _coinCollider.enabled = true;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Teleporter\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"destinationPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"teleportCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"requiresPlayerTag\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"teleportEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isOnCooldown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"teleport_player\",\n      \"trigger\": \"when player enters teleporter trigger area and teleporter is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"play teleport effect at current position\"\n        },\n        {\n          \"action\": \"move player to destination position\"\n        },\n        {\n          \"action\": \"play teleport effect at destination position\"\n        },\n        {\n          \"action\": \"activate teleporter cooldown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_cooldown\",\n      \"trigger\": \"when cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"disable teleporter cooldown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when teleporter is ready to use\",\n      \"actions\": [\n        {\n          \"action\": \"display ready indicator or glow effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Teleporter : MonoBehaviour\n{\n    [Header(\"Teleporter Settings\")]\n    [SerializeField] private Transform _destinationPoint;\n    [SerializeField] private bool _isTwoWay = true;\n    [SerializeField] private float _teleportCooldown = 2f;\n    [SerializeField] private LayerMask _teleportLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _teleportEffect;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private float _effectDuration = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _useScaleAnimation = true;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    [SerializeField] private float _animationDuration = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectTeleported;\n    public UnityEvent OnTeleportActivated;\n    \n    private AudioSource _audioSource;\n    private bool _canTeleport = true;\n    private Teleporter _linkedTeleporter;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _teleportSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        FindLinkedTeleporter();\n        \n        if (_destinationPoint == null)\n        {\n            Debug.LogWarning($\"Teleporter {gameObject.name} has no destination point assigned!\");\n        }\n    }\n    \n    private void FindLinkedTeleporter()\n    {\n        if (_destinationPoint != null)\n        {\n            _linkedTeleporter = _destinationPoint.GetComponent<Teleporter>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canTeleport || _destinationPoint == null)\n            return;\n            \n        if (!IsValidTeleportTarget(other))\n            return;\n            \n        StartCoroutine(TeleportSequence(other.gameObject));\n    }\n    \n    private bool IsValidTeleportTarget(Collider other)\n    {\n        int objectLayer = 1 << other.gameObject.layer;\n        return (_teleportLayers.value & objectLayer) != 0;\n    }\n    \n    private System.Collections.IEnumerator TeleportSequence(GameObject target)\n    {\n        _canTeleport = false;\n        \n        if (_linkedTeleporter != null)\n        {\n            _linkedTeleporter._canTeleport = false;\n        }\n        \n        OnTeleportActivated.Invoke();\n        \n        if (_useScaleAnimation)\n        {\n            yield return StartCoroutine(AnimateScale(target, true));\n        }\n        \n        if (_teleportEffect != null)\n        {\n            _teleportEffect.Play();\n        }\n        \n        if (_audioSource != null && _teleportSound != null)\n        {\n            _audioSource.PlayOneShot(_teleportSound);\n        }\n        \n        yield return new WaitForSeconds(_effectDuration * 0.5f);\n        \n        PerformTeleport(target);\n        \n        OnObjectTeleported.Invoke(target);\n        \n        yield return new WaitForSeconds(_effectDuration * 0.5f);\n        \n        if (_useScaleAnimation)\n        {\n            yield return StartCoroutine(AnimateScale(target, false));\n        }\n        \n        yield return new WaitForSeconds(_teleportCooldown);\n        \n        _canTeleport = true;\n        \n        if (_linkedTeleporter != null)\n        {\n            _linkedTeleporter._canTeleport = true;\n        }\n    }\n    \n    private void PerformTeleport(GameObject target)\n    {\n        CharacterController characterController = target.GetComponent<CharacterController>();\n        Rigidbody targetRigidbody = target.GetComponent<Rigidbody>();\n        \n        if (characterController != null)\n        {\n            characterController.enabled = false;\n            target.transform.position = _destinationPoint.position;\n            target.transform.rotation = _destinationPoint.rotation;\n            characterController.enabled = true;\n        }\n        else\n        {\n            target.transform.position = _destinationPoint.position;\n            target.transform.rotation = _destinationPoint.rotation;\n        }\n        \n        if (targetRigidbody != null)\n        {\n            targetRigidbody.velocity = Vector3.zero;\n            targetRigidbody.angularVelocity = Vector3.zero;\n        }\n    }\n    \n    private System.Collections.IEnumerator AnimateScale(GameObject target, bool scaleDown)\n    {\n        Vector3 originalScale = target.transform.localScale;\n        Vector3 targetScale = scaleDown ? Vector3.zero : originalScale;\n        Vector3 startScale = scaleDown ? originalScale : Vector3.zero;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / _animationDuration;\n            float curveValue = _scaleCurve.Evaluate(normalizedTime);\n            \n            target.transform.localScale = Vector3.Lerp(startScale, targetScale, curveValue);\n            \n            yield return null;\n        }\n        \n        target.transform.localScale = targetScale;\n    }\n    \n    public void SetDestination(Transform newDestination)\n    {\n        _destinationPoint = newDestination;\n        FindLinkedTeleporter();\n    }\n    \n    public void ActivateTeleporter()\n    {\n        _canTeleport = true;\n    }\n    \n    public void DeactivateTeleporter()\n    {\n        _canTeleport = false;\n    }\n    \n    public void TeleportObject(GameObject target)\n    {\n        if (_canTeleport && _destinationPoint != null && IsValidTeleportTarget(target.GetComponent<Collider>()))\n        {\n            StartCoroutine(TeleportSequence(target));\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_destinationPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _destinationPoint.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_destinationPoint.position, 1f);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GroundPoundAttack\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"chargeTime\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"poundForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"damageRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"shakeIntensity\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"isCharging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isPounding\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_ground_pound\",\n      \"trigger\": \"when ground pound input is pressed and character is in air\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to true\"\n        },\n        {\n          \"action\": \"freeze horizontal movement\"\n        },\n        {\n          \"action\": \"play charging animation\"\n        },\n        {\n          \"action\": \"play charging sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_pound\",\n      \"trigger\": \"when charge time has elapsed while charging\",\n      \"actions\": [\n        {\n          \"action\": \"set pounding state to true\"\n        },\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"apply downward force with pound strength\"\n        },\n        {\n          \"action\": \"play pound animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"impact_ground\",\n      \"trigger\": \"when character hits ground while pounding\",\n      \"actions\": [\n        {\n          \"action\": \"create damage area around impact point with damage radius\"\n        },\n        {\n          \"action\": \"deal damage to all enemies within damage area\"\n        },\n        {\n          \"action\": \"shake camera with shake intensity\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"spawn dust particle effects\"\n        },\n        {\n          \"action\": \"set pounding state to false\"\n        },\n        {\n          \"action\": \"restore normal movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_pound\",\n      \"trigger\": \"when character touches wall while charging or pounding\",\n      \"actions\": [\n        {\n          \"action\": \"set charging state to false\"\n        },\n        {\n          \"action\": \"set pounding state to false\"\n        },\n        {\n          \"action\": \"restore normal movement\"\n        },\n        {\n          \"action\": \"stop charging effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GroundPoundAttack : MonoBehaviour\n{\n    [Header(\"Ground Pound Settings\")]\n    [SerializeField] private float _poundForce = 20f;\n    [SerializeField] private float _poundRadius = 5f;\n    [SerializeField] private float _poundDamage = 50f;\n    [SerializeField] private float _chargeTime = 0.5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private LayerMask _enemyLayer = -1;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _poundKey = KeyCode.Q;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _chargingEffect;\n    [SerializeField] private GameObject _impactEffect;\n    [SerializeField] private ParticleSystem _dustParticles;\n    [SerializeField] private float _cameraShakeIntensity = 0.5f;\n    [SerializeField] private float _cameraShakeDuration = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _chargeSound;\n    [SerializeField] private AudioClip _impactSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGroundPoundStart;\n    public UnityEvent OnGroundPoundImpact;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Camera _mainCamera;\n    private bool _isCharging = false;\n    private bool _isPounding = false;\n    private bool _isOnCooldown = false;\n    private float _chargeTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Vector3 _originalCameraPosition;\n    private float _cameraShakeTimer = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _mainCamera = Camera.main;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_mainCamera != null)\n        {\n            _originalCameraPosition = _mainCamera.transform.localPosition;\n        }\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCharging();\n        UpdateCooldown();\n        UpdateCameraShake();\n    }\n    \n    private void HandleInput()\n    {\n        if (_isOnCooldown || _isPounding) return;\n        \n        if (Input.GetKeyDown(_poundKey) && !_isCharging && IsGrounded())\n        {\n            StartCharging();\n        }\n        \n        if (Input.GetKeyUp(_poundKey) && _isCharging)\n        {\n            if (_chargeTimer >= _chargeTime)\n            {\n                ExecuteGroundPound();\n            }\n            else\n            {\n                CancelCharging();\n            }\n        }\n    }\n    \n    private void UpdateCharging()\n    {\n        if (!_isCharging) return;\n        \n        _chargeTimer += Time.deltaTime;\n        \n        if (Input.GetKey(_poundKey))\n        {\n            if (_chargeTimer >= _chargeTime && !_isPounding)\n            {\n                ExecuteGroundPound();\n            }\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_isOnCooldown) return;\n        \n        _cooldownTimer -= Time.deltaTime;\n        if (_cooldownTimer <= 0f)\n        {\n            _isOnCooldown = false;\n        }\n    }\n    \n    private void UpdateCameraShake()\n    {\n        if (_cameraShakeTimer <= 0f || _mainCamera == null) return;\n        \n        _cameraShakeTimer -= Time.deltaTime;\n        \n        if (_cameraShakeTimer > 0f)\n        {\n            Vector3 shakeOffset = Random.insideUnitSphere * _cameraShakeIntensity;\n            _mainCamera.transform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n        else\n        {\n            _mainCamera.transform.localPosition = _originalCameraPosition;\n        }\n    }\n    \n    private void StartCharging()\n    {\n        _isCharging = true;\n        _chargeTimer = 0f;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(true);\n        }\n        \n        PlaySound(_chargeSound);\n        OnGroundPoundStart?.Invoke();\n    }\n    \n    private void CancelCharging()\n    {\n        _isCharging = false;\n        _chargeTimer = 0f;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n    }\n    \n    private void ExecuteGroundPound()\n    {\n        _isCharging = false;\n        _isPounding = true;\n        \n        if (_chargingEffect != null)\n        {\n            _chargingEffect.SetActive(false);\n        }\n        \n        _rigidbody.velocity = Vector3.down * _poundForce;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_isPounding) return;\n        \n        if (IsInLayerMask(collision.gameObject.layer, _groundLayer))\n        {\n            PerformGroundImpact();\n        }\n    }\n    \n    private void PerformGroundImpact()\n    {\n        _isPounding = false;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        Vector3 impactPosition = transform.position;\n        \n        // Create impact effect\n        if (_impactEffect != null)\n        {\n            Instantiate(_impactEffect, impactPosition, Quaternion.identity);\n        }\n        \n        // Play dust particles\n        if (_dustParticles != null)\n        {\n            _dustParticles.transform.position = impactPosition;\n            _dustParticles.Play();\n        }\n        \n        // Camera shake\n        if (_mainCamera != null)\n        {\n            _cameraShakeTimer = _cameraShakeDuration;\n        }\n        \n        // Play impact sound\n        PlaySound(_impactSound);\n        \n        // Deal damage to enemies in radius\n        DealDamageInRadius(impactPosition);\n        \n        // Apply knockback to rigidbodies in radius\n        ApplyKnockbackInRadius(impactPosition);\n        \n        OnGroundPoundImpact?.Invoke();\n    }\n    \n    private void DealDamageInRadius(Vector3 center)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(center, _poundRadius, _enemyLayer);\n        float totalDamage = 0f;\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Try to find health component or similar\n            var healthComponent = hitCollider.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Send damage message if the object can receive it\n                hitCollider.SendMessage(\"TakeDamage\", _poundDamage, SendMessageOptions.DontRequireReceiver);\n                totalDamage += _poundDamage;\n            }\n            \n            // Alternative: destroy objects with specific tags\n            if (hitCollider.CompareTag(\"Enemy\") || hitCollider.CompareTag(\"Destructible\"))\n            {\n                Destroy(hitCollider.gameObject);\n                totalDamage += _poundDamage;\n            }\n        }\n        \n        if (totalDamage > 0f)\n        {\n            OnDamageDealt?.Invoke(totalDamage);\n        }\n    }\n    \n    private void ApplyKnockbackInRadius(Vector3 center)\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(center, _poundRadius);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject == gameObject) continue;\n            \n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                Vector3 direction = (hitCollider.transform.position - center).normalized;\n                float distance = Vector3.Distance(center, hitCollider.transform.position);\n                float knockbackForce = Mathf.Lerp(_poundForce, 0f, distance / _poundRadius);\n                \n                hitRigidbody.AddForce(direction * knockbackForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private bool IsGrounded()\n    {\n        float rayDistance = 1.1f;\n        return Physics.Raycast(transform.position, Vector3.down, rayDistance, _groundLayer);\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _poundRadius);\n        \n        if (_isCharging)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _poundRadius * 0.5f);\n        }\n    }\n    \n    public bool IsOnCooldown => _isOnCooldown;\n    public bool IsCharging => _isCharging;\n    public bool IsPounding => _isPounding;\n    public float CooldownProgress => _isOnCooldown ? (1f - _cooldownTimer / _cooldownTime) : 1f;\n    public float ChargeProgress => _isCharging ? Mathf.Clamp01(_chargeTimer / _chargeTime) : 0f;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TutorialMessageSystem\",\n  \"components\": [\n    \"Canvas\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"messageDisplayDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"fadeOutDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"currentMessageIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isDisplayingMessage\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"tutorialMessages\",\n      \"type\": \"string[]\",\n      \"default\": []\n    },\n    {\n      \"name\": \"messageText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"autoAdvance\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_next_message\",\n      \"trigger\": \"when tutorial system is activated or next message is requested\",\n      \"actions\": [\n        {\n          \"action\": \"display current tutorial message from the message array\"\n        },\n        {\n          \"action\": \"fade in the message text smoothly\"\n        },\n        {\n          \"action\": \"mark system as currently displaying message\"\n        },\n        {\n          \"action\": \"start timer for message display duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_current_message\",\n      \"trigger\": \"when message display timer expires or skip input is received\",\n      \"actions\": [\n        {\n          \"action\": \"fade out the message text smoothly\"\n        },\n        {\n          \"action\": \"mark system as not displaying message\"\n        },\n        {\n          \"action\": \"increment current message index\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_advance_messages\",\n      \"trigger\": \"when auto advance is enabled and current message finishes displaying\",\n      \"actions\": [\n        {\n          \"action\": \"automatically show next message in sequence\"\n        },\n        {\n          \"action\": \"continue until all messages are shown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"skip_message\",\n      \"trigger\": \"when player presses skip input while message is displaying\",\n      \"actions\": [\n        {\n          \"action\": \"immediately hide current message\"\n        },\n        {\n          \"action\": \"advance to next message if available\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_tutorial\",\n      \"trigger\": \"when all tutorial messages have been displayed\",\n      \"actions\": [\n        {\n          \"action\": \"hide tutorial message system\"\n        },\n        {\n          \"action\": \"reset message index to beginning\"\n        },\n        {\n          \"action\": \"notify other systems that tutorial is complete\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class TutorialMessageSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class TutorialMessage\n    {\n        [Header(\"Message Content\")]\n        public string title;\n        [TextArea(3, 6)]\n        public string description;\n        public Sprite icon;\n        \n        [Header(\"Display Settings\")]\n        public float displayDuration = 5f;\n        public bool requiresInput = false;\n        public KeyCode inputKey = KeyCode.Space;\n        \n        [Header(\"Trigger Settings\")]\n        public TriggerType triggerType = TriggerType.Manual;\n        public string triggerTag = \"Player\";\n        public float triggerDelay = 0f;\n        \n        [Header(\"Events\")]\n        public UnityEvent onMessageShow;\n        public UnityEvent onMessageHide;\n        \n        [HideInInspector]\n        public bool hasBeenShown = false;\n    }\n    \n    public enum TriggerType\n    {\n        Manual,\n        OnStart,\n        OnTriggerEnter,\n        OnCollisionEnter,\n        OnKeyPress,\n        Timed\n    }\n    \n    [Header(\"Tutorial Messages\")]\n    [SerializeField] private List<TutorialMessage> _tutorialMessages = new List<TutorialMessage>();\n    [SerializeField] private bool _showMessagesOnce = true;\n    [SerializeField] private bool _showInOrder = false;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _messagePanel;\n    [SerializeField] private Text _titleText;\n    [SerializeField] private Text _descriptionText;\n    [SerializeField] private Image _iconImage;\n    [SerializeField] private Button _continueButton;\n    [SerializeField] private Text _inputPromptText;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useAnimations = true;\n    [SerializeField] private float _fadeInDuration = 0.5f;\n    [SerializeField] private float _fadeOutDuration = 0.3f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _showMessageSound;\n    [SerializeField] private AudioClip _hideMessageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTutorialStart;\n    public UnityEvent OnTutorialComplete;\n    public UnityEvent<int> OnMessageChanged;\n    \n    private int _currentMessageIndex = 0;\n    private bool _isShowingMessage = false;\n    private Coroutine _currentDisplayCoroutine;\n    private Coroutine _currentAnimationCoroutine;\n    private CanvasGroup _panelCanvasGroup;\n    private float _startTime;\n    \n    private void Awake()\n    {\n        InitializeComponents();\n    }\n    \n    private void Start()\n    {\n        _startTime = Time.time;\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(false);\n            \n        CheckForStartTriggers();\n    }\n    \n    private void Update()\n    {\n        CheckForKeyPressTriggers();\n        CheckForTimedTriggers();\n        HandleInputDuringMessage();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        CheckForTriggerMessages(other.gameObject, TriggerType.OnTriggerEnter);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        CheckForTriggerMessages(collision.gameObject, TriggerType.OnCollisionEnter);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_messagePanel != null)\n        {\n            _panelCanvasGroup = _messagePanel.GetComponent<CanvasGroup>();\n            if (_panelCanvasGroup == null)\n                _panelCanvasGroup = _messagePanel.AddComponent<CanvasGroup>();\n        }\n        \n        if (_continueButton != null)\n            _continueButton.onClick.AddListener(HideCurrentMessage);\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void CheckForStartTriggers()\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            if (_tutorialMessages[i].triggerType == TriggerType.OnStart)\n            {\n                if (_tutorialMessages[i].triggerDelay > 0)\n                    StartCoroutine(ShowMessageDelayed(i, _tutorialMessages[i].triggerDelay));\n                else\n                    ShowMessage(i);\n                    \n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForKeyPressTriggers()\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == TriggerType.OnKeyPress && \n                Input.GetKeyDown(message.inputKey) &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                ShowMessage(i);\n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForTimedTriggers()\n    {\n        float currentTime = Time.time - _startTime;\n        \n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == TriggerType.Timed && \n                currentTime >= message.triggerDelay &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                ShowMessage(i);\n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void CheckForTriggerMessages(GameObject other, TriggerType triggerType)\n    {\n        for (int i = 0; i < _tutorialMessages.Count; i++)\n        {\n            var message = _tutorialMessages[i];\n            if (message.triggerType == triggerType &&\n                other.CompareTag(message.triggerTag) &&\n                (!_showMessagesOnce || !message.hasBeenShown))\n            {\n                if (message.triggerDelay > 0)\n                    StartCoroutine(ShowMessageDelayed(i, message.triggerDelay));\n                else\n                    ShowMessage(i);\n                    \n                if (_showInOrder) break;\n            }\n        }\n    }\n    \n    private void HandleInputDuringMessage()\n    {\n        if (!_isShowingMessage) return;\n        \n        var currentMessage = _tutorialMessages[_currentMessageIndex];\n        if (currentMessage.requiresInput && Input.GetKeyDown(currentMessage.inputKey))\n        {\n            HideCurrentMessage();\n        }\n    }\n    \n    public void ShowMessage(int messageIndex)\n    {\n        if (messageIndex < 0 || messageIndex >= _tutorialMessages.Count) return;\n        if (_isShowingMessage) return;\n        if (_showMessagesOnce && _tutorialMessages[messageIndex].hasBeenShown) return;\n        \n        _currentMessageIndex = messageIndex;\n        var message = _tutorialMessages[messageIndex];\n        \n        _isShowingMessage = true;\n        message.hasBeenShown = true;\n        \n        SetupMessageUI(message);\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(true);\n            \n        PlaySound(_showMessageSound);\n        \n        if (_useAnimations)\n        {\n            if (_currentAnimationCoroutine != null)\n                StopCoroutine(_currentAnimationCoroutine);\n            _currentAnimationCoroutine = StartCoroutine(AnimateMessageIn());\n        }\n        else if (_panelCanvasGroup != null)\n        {\n            _panelCanvasGroup.alpha = 1f;\n        }\n        \n        message.onMessageShow?.Invoke();\n        OnMessageChanged?.Invoke(messageIndex);\n        \n        if (!message.requiresInput && message.displayDuration > 0)\n        {\n            _currentDisplayCoroutine = StartCoroutine(HideMessageAfterDelay(message.displayDuration));\n        }\n    }\n    \n    public void ShowNextMessage()\n    {\n        if (_showInOrder && _currentMessageIndex + 1 < _tutorialMessages.Count)\n        {\n            ShowMessage(_currentMessageIndex + 1);\n        }\n    }\n    \n    public void HideCurrentMessage()\n    {\n        if (!_isShowingMessage) return;\n        \n        var message = _tutorialMessages[_currentMessageIndex];\n        \n        if (_currentDisplayCoroutine != null)\n        {\n            StopCoroutine(_currentDisplayCoroutine);\n            _currentDisplayCoroutine = null;\n        }\n        \n        PlaySound(_hideMessageSound);\n        \n        if (_useAnimations)\n        {\n            if (_currentAnimationCoroutine != null)\n                StopCoroutine(_currentAnimationCoroutine);\n            _currentAnimationCoroutine = StartCoroutine(AnimateMessageOut());\n        }\n        else\n        {\n            CompleteHideMessage();\n        }\n        \n        message.onMessageHide?.Invoke();\n    }\n    \n    private void CompleteHideMessage()\n    {\n        _isShowingMessage = false;\n        \n        if (_messagePanel != null)\n            _messagePanel.SetActive(false);\n            \n        if (_showInOrder)\n            ShowNextMessage();\n            \n        CheckTutorialComplete();\n    }\n    \n    private void SetupMessageUI(TutorialMessage message)\n    {\n        if (_titleText != null)\n            _titleText.text = message.title;\n            \n        if (_descriptionText != null)\n            _descriptionText.text = message.description;\n            \n        if (_iconImage != null)\n        {\n            _iconImage.sprite = message.icon;\n            _iconImage.gameObject.SetActive(message.icon != null);\n        }\n        \n        if (_continueButton != null)\n            _continueButton.gameObject.SetActive(!message.requiresInput);\n            \n        if (_inputPromptText != null)\n        {\n            _inputPromptText.gameObject.SetActive(message.requiresInput);\n            if (message.requiresInput)\n                _inputPromptText.text = $\"Press {message.inputKey} to continue\";\n        }\n    }\n    \n    private void CheckTutorialComplete()\n    {\n        bool allShown = true;\n        foreach (var message in _tutorialMessages)\n        {\n            if (!message.hasBeenShown)\n            {\n                allShown = false;\n                break;\n            }\n        }\n        \n        if (allShown)\n            OnTutorialComplete?.Invoke();\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n    \n    private IEnumerator ShowMessageDelayed(int messageIndex, float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        ShowMessage(messageIndex);\n    }\n    \n    private IEnumerator HideMessageAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        HideCurrentMessage();\n    }\n    \n    private IEnumerator AnimateMessageIn()\n    {\n        if (_panelCanvasGroup == null) yield break;\n        \n        _panelCanvasGroup.alpha = 0f;\n        float elapsed = 0f;\n        \n        while (elapsed < _fadeInDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeInDuration;\n            _panelCanvasGroup.alpha = _animationCurve.Evaluate(progress);\n            yield return null;\n        }\n        \n        _panelCanvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator AnimateMessageOut()\n    {\n        if (_panelCanvasGroup == null)\n        {\n            CompleteHideMessage();\n            yield break;\n        }\n        \n        float startAlpha = _panelCanvasGroup.alpha;\n        float elapsed = 0f;\n        \n        while (elapsed < _fadeOutDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _fadeOutDuration;\n            _panelCanvasGroup.alpha = startAlpha * (1f - _animationCurve.Evaluate(progress));\n            yield return null;\n        }\n        \n        _panelCanvasGroup.alpha = 0f;\n        CompleteHideMessage();\n    }\n    \n    public void ResetTutorial()\n    {\n        foreach (var message in _tutorialMessages)\n        {\n            message.hasBeenShown = false;\n        }\n        \n        if (_isShowingMessage)\n            HideCurrentMessage();\n            \n        _currentMessageIndex = 0;\n        _startTime = Time.time;\n    }\n    \n    public void SkipTutorial()\n    {\n        foreach (var message in _tutorialMessages)\n        {\n            message.hasBeenShown = true;\n        }\n        \n        if (_isShowingMessage)\n            HideCurrentMessage();\n            \n        OnTutorialComplete?.Invoke();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingBoat\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"buoyancyForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"waterLevel\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"dampening\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_buoyancy\",\n      \"trigger\": \"when boat is below water surface\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force proportional to how deep underwater the boat is\"\n        },\n        {\n          \"action\": \"reduce vertical velocity to create dampening effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stabilize_rotation\",\n      \"trigger\": \"when boat is tilted\",\n      \"actions\": [\n        {\n          \"action\": \"apply torque to return boat to upright position\"\n        },\n        {\n          \"action\": \"reduce angular velocity for stability\"\n        }\n      ]\n    },\n    {\n      \"name\": \"water_resistance\",\n      \"trigger\": \"when boat is moving through water\",\n      \"actions\": [\n        {\n          \"action\": \"apply drag force opposite to movement direction\"\n        },\n        {\n          \"action\": \"reduce velocity over time when no input is applied\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FloatingBoat : MonoBehaviour\n{\n    [Header(\"Buoyancy Settings\")]\n    [SerializeField] private float _buoyancyForce = 15f;\n    [SerializeField] private float _waterLevel = 0f;\n    [SerializeField] private float _waterDrag = 0.99f;\n    [SerializeField] private float _waterAngularDrag = 0.5f;\n    \n    [Header(\"Float Points\")]\n    [SerializeField] private Transform[] _floatPoints;\n    [SerializeField] private float _underwaterDrag = 3f;\n    [SerializeField] private float _underwaterAngularDrag = 1f;\n    \n    [Header(\"Wave Settings\")]\n    [SerializeField] private bool _useWaves = true;\n    [SerializeField] private float _waveHeight = 0.5f;\n    [SerializeField] private float _waveSpeed = 1f;\n    [SerializeField] private float _waveLength = 10f;\n    \n    [Header(\"Stability\")]\n    [SerializeField] private float _stabilityForce = 50f;\n    [SerializeField] private float _stabilityTorque = 50f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isUnderwater;\n    private int _underwaterCount;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n        \n        if (_floatPoints == null || _floatPoints.Length == 0)\n        {\n            CreateDefaultFloatPoints();\n        }\n    }\n    \n    private void CreateDefaultFloatPoints()\n    {\n        _floatPoints = new Transform[4];\n        Bounds bounds = GetComponent<Collider>()?.bounds ?? new Bounds(transform.position, Vector3.one);\n        \n        GameObject frontLeft = new GameObject(\"FloatPoint_FrontLeft\");\n        GameObject frontRight = new GameObject(\"FloatPoint_FrontRight\");\n        GameObject backLeft = new GameObject(\"FloatPoint_BackLeft\");\n        GameObject backRight = new GameObject(\"FloatPoint_BackRight\");\n        \n        frontLeft.transform.SetParent(transform);\n        frontRight.transform.SetParent(transform);\n        backLeft.transform.SetParent(transform);\n        backRight.transform.SetParent(transform);\n        \n        Vector3 size = bounds.size;\n        frontLeft.transform.localPosition = new Vector3(-size.x * 0.4f, -size.y * 0.5f, size.z * 0.4f);\n        frontRight.transform.localPosition = new Vector3(size.x * 0.4f, -size.y * 0.5f, size.z * 0.4f);\n        backLeft.transform.localPosition = new Vector3(-size.x * 0.4f, -size.y * 0.5f, -size.z * 0.4f);\n        backRight.transform.localPosition = new Vector3(size.x * 0.4f, -size.y * 0.5f, -size.z * 0.4f);\n        \n        _floatPoints[0] = frontLeft.transform;\n        _floatPoints[1] = frontRight.transform;\n        _floatPoints[2] = backLeft.transform;\n        _floatPoints[3] = backRight.transform;\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyStability();\n        UpdateDrag();\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        _underwaterCount = 0;\n        \n        foreach (Transform floatPoint in _floatPoints)\n        {\n            if (floatPoint == null) continue;\n            \n            float waterHeight = GetWaterHeightAtPosition(floatPoint.position);\n            float difference = floatPoint.position.y - waterHeight;\n            \n            if (difference < 0)\n            {\n                _underwaterCount++;\n                Vector3 buoyancyForceVector = Vector3.up * _buoyancyForce * Mathf.Abs(difference);\n                _rigidbody.AddForceAtPosition(buoyancyForceVector, floatPoint.position, ForceMode.Force);\n            }\n        }\n        \n        _isUnderwater = _underwaterCount > 0;\n    }\n    \n    private float GetWaterHeightAtPosition(Vector3 position)\n    {\n        if (!_useWaves)\n        {\n            return _waterLevel;\n        }\n        \n        float wave1 = Mathf.Sin((position.x / _waveLength + Time.time * _waveSpeed) * 2 * Mathf.PI) * _waveHeight;\n        float wave2 = Mathf.Sin((position.z / _waveLength + Time.time * _waveSpeed * 0.8f) * 2 * Mathf.PI) * _waveHeight * 0.5f;\n        \n        return _waterLevel + wave1 + wave2;\n    }\n    \n    private void ApplyStability()\n    {\n        Vector3 stabilityTorqueVector = Vector3.Cross(transform.up, Vector3.up);\n        _rigidbody.AddTorque(stabilityTorqueVector * _stabilityTorque, ForceMode.Force);\n        \n        Vector3 stabilityForceVector = Vector3.up * _stabilityForce;\n        _rigidbody.AddForce(stabilityForceVector * (Vector3.Dot(Vector3.down, transform.up) + 1) * 0.5f, ForceMode.Force);\n    }\n    \n    private void UpdateDrag()\n    {\n        if (_isUnderwater)\n        {\n            float dragMultiplier = (float)_underwaterCount / _floatPoints.Length;\n            _rigidbody.drag = Mathf.Lerp(_originalDrag, _underwaterDrag, dragMultiplier);\n            _rigidbody.angularDrag = Mathf.Lerp(_originalAngularDrag, _underwaterAngularDrag, dragMultiplier);\n        }\n        else\n        {\n            _rigidbody.drag = _originalDrag;\n            _rigidbody.angularDrag = _originalAngularDrag;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_floatPoints == null) return;\n        \n        Gizmos.color = Color.blue;\n        foreach (Transform floatPoint in _floatPoints)\n        {\n            if (floatPoint != null)\n            {\n                Gizmos.DrawWireSphere(floatPoint.position, 0.2f);\n            }\n        }\n        \n        Gizmos.color = Color.cyan;\n        Vector3 waterPlaneSize = new Vector3(20f, 0.1f, 20f);\n        Gizmos.DrawCube(new Vector3(transform.position.x, _waterLevel, transform.position.z), waterPlaneSize);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"JumpingFish\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"jumpCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"swimSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"waterLevel\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isInWater\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"lastJumpTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"swim_underwater\",\n      \"trigger\": \"when fish is below water level\",\n      \"actions\": [\n        {\n          \"action\": \"move randomly in horizontal directions at swim speed\"\n        },\n        {\n          \"action\": \"apply slight upward movement toward water surface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"jump_from_water\",\n      \"trigger\": \"when fish reaches water surface and jump cooldown has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"apply strong upward force to launch fish into air\"\n        },\n        {\n          \"action\": \"record current time as last jump time\"\n        },\n        {\n          \"action\": \"mark fish as no longer in water\"\n        }\n      ]\n    },\n    {\n      \"name\": \"arc_through_air\",\n      \"trigger\": \"when fish is above water level\",\n      \"actions\": [\n        {\n          \"action\": \"allow gravity to pull fish downward\"\n        },\n        {\n          \"action\": \"maintain forward momentum from jump\"\n        }\n      ]\n    },\n    {\n      \"name\": \"splash_back_into_water\",\n      \"trigger\": \"when fish falls back below water level\",\n      \"actions\": [\n        {\n          \"action\": \"mark fish as back in water\"\n        },\n        {\n          \"action\": \"reduce vertical velocity to simulate water resistance\"\n        },\n        {\n          \"action\": \"resume swimming behavior\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class JumpingFish : MonoBehaviour\n{\n    [Header(\"Jump Settings\")]\n    [SerializeField] private float _jumpForce = 10f;\n    [SerializeField] private float _jumpInterval = 3f;\n    [SerializeField] private float _jumpVariation = 1f;\n    [SerializeField] private float _waterLevel = 0f;\n    [SerializeField] private AnimationCurve _jumpCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _swimSpeed = 2f;\n    [SerializeField] private float _swimRadius = 5f;\n    [SerializeField] private bool _randomSwimming = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _rotationSpeed = 180f;\n    [SerializeField] private float _splashEffectDuration = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _startPosition;\n    private Vector3 _swimTarget;\n    private float _nextJumpTime;\n    private bool _isJumping;\n    private bool _isInWater;\n    private float _jumpStartTime;\n    private Vector3 _jumpStartPosition;\n    private Vector3 _jumpTargetPosition;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _startPosition = transform.position;\n        _swimTarget = _startPosition;\n        _nextJumpTime = Time.time + Random.Range(_jumpInterval - _jumpVariation, _jumpInterval + _jumpVariation);\n        _isInWater = transform.position.y <= _waterLevel;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupRigidbody();\n        GenerateNewSwimTarget();\n    }\n    \n    private void SetupRigidbody()\n    {\n        _rigidbody.drag = _isInWater ? 5f : 0.5f;\n        _rigidbody.angularDrag = 3f;\n        _rigidbody.useGravity = !_isInWater;\n    }\n    \n    private void Update()\n    {\n        CheckWaterState();\n        HandleJumping();\n        HandleSwimming();\n        HandleRotation();\n    }\n    \n    private void CheckWaterState()\n    {\n        bool wasInWater = _isInWater;\n        _isInWater = transform.position.y <= _waterLevel;\n        \n        if (wasInWater != _isInWater)\n        {\n            SetupRigidbody();\n            \n            if (_isInWater)\n            {\n                OnEnterWater();\n            }\n            else\n            {\n                OnExitWater();\n            }\n        }\n    }\n    \n    private void OnEnterWater()\n    {\n        PlaySplashEffect();\n        PlaySound(_splashSound);\n        _isJumping = false;\n        GenerateNewSwimTarget();\n    }\n    \n    private void OnExitWater()\n    {\n        PlaySplashEffect();\n        PlaySound(_jumpSound);\n    }\n    \n    private void HandleJumping()\n    {\n        if (_isInWater && !_isJumping && Time.time >= _nextJumpTime)\n        {\n            StartJump();\n        }\n    }\n    \n    private void StartJump()\n    {\n        _isJumping = true;\n        _jumpStartTime = Time.time;\n        _jumpStartPosition = transform.position;\n        \n        Vector3 jumpDirection = Vector3.up + Random.insideUnitSphere * 0.3f;\n        jumpDirection.y = Mathf.Abs(jumpDirection.y);\n        jumpDirection.Normalize();\n        \n        _rigidbody.velocity = jumpDirection * _jumpForce;\n        \n        _nextJumpTime = Time.time + Random.Range(_jumpInterval - _jumpVariation, _jumpInterval + _jumpVariation);\n    }\n    \n    private void HandleSwimming()\n    {\n        if (!_isInWater || _isJumping) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _swimTarget);\n        \n        if (distanceToTarget < 0.5f)\n        {\n            GenerateNewSwimTarget();\n        }\n        \n        Vector3 direction = (_swimTarget - transform.position).normalized;\n        direction.y = 0f;\n        \n        _rigidbody.AddForce(direction * _swimSpeed, ForceMode.Force);\n        \n        Vector3 velocity = _rigidbody.velocity;\n        velocity.y = Mathf.Lerp(velocity.y, 0f, Time.deltaTime * 2f);\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void GenerateNewSwimTarget()\n    {\n        if (_randomSwimming)\n        {\n            Vector2 randomCircle = Random.insideUnitCircle * _swimRadius;\n            _swimTarget = _startPosition + new Vector3(randomCircle.x, 0f, randomCircle.y);\n        }\n        else\n        {\n            float angle = Time.time * 0.5f;\n            _swimTarget = _startPosition + new Vector3(\n                Mathf.Cos(angle) * _swimRadius,\n                0f,\n                Mathf.Sin(angle) * _swimRadius\n            );\n        }\n        \n        _swimTarget.y = _waterLevel - 0.5f;\n    }\n    \n    private void HandleRotation()\n    {\n        Vector3 targetDirection;\n        \n        if (_isInWater && !_isJumping)\n        {\n            targetDirection = (_swimTarget - transform.position).normalized;\n            if (targetDirection.magnitude < 0.1f)\n            {\n                targetDirection = transform.forward;\n            }\n        }\n        else\n        {\n            targetDirection = _rigidbody.velocity.normalized;\n            if (targetDirection.magnitude < 0.1f)\n            {\n                targetDirection = transform.forward;\n            }\n        }\n        \n        if (targetDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n            transform.rotation = Quaternion.RotateTowards(\n                transform.rotation,\n                targetRotation,\n                _rotationSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void PlaySplashEffect()\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = new Vector3(transform.position.x, _waterLevel, transform.position.z);\n            _splashEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(_startPosition, _swimRadius);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawLine(new Vector3(-10f, _waterLevel, -10f), new Vector3(10f, _waterLevel, 10f));\n        \n        if (_isInWater)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _swimTarget);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WindTunnel\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"windForce\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"windDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    },\n    {\n      \"name\": \"turbulenceIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"windSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"particleEffect\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_wind_force\",\n      \"trigger\": \"when object with rigidbody enters wind tunnel area\",\n      \"actions\": [\n        {\n          \"action\": \"apply continuous force in wind direction to the rigidbody\"\n        },\n        {\n          \"action\": \"add random turbulence variations to the force\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_wind_force\",\n      \"trigger\": \"when object with rigidbody exits wind tunnel area\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying wind force to the rigidbody\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_wind_effects\",\n      \"trigger\": \"when any object enters wind tunnel area\",\n      \"actions\": [\n        {\n          \"action\": \"play wind sound effect\"\n        },\n        {\n          \"action\": \"activate particle system showing wind flow\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_wind_effects\",\n      \"trigger\": \"when no objects remain in wind tunnel area\",\n      \"actions\": [\n        {\n          \"action\": \"stop wind sound effect\"\n        },\n        {\n          \"action\": \"deactivate particle system\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WindTunnel : MonoBehaviour\n{\n    [Header(\"Wind Settings\")]\n    [SerializeField] private float _windForce = 10f;\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private bool _useLocalDirection = true;\n    [SerializeField] private float _maxWindDistance = 20f;\n    [SerializeField] private AnimationCurve _forceFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    [Header(\"Affected Objects\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private string[] _affectedTags = { \"Player\", \"Debris\", \"Projectile\" };\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectParticles = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _windParticles;\n    [SerializeField] private bool _createWindParticles = true;\n    [SerializeField] private int _particleCount = 100;\n    [SerializeField] private float _particleSpeed = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _windSound;\n    [SerializeField] private float _baseVolume = 0.5f;\n    [SerializeField] private float _basePitch = 1f;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private float _updateFrequency = 0.1f;\n    \n    private List<Rigidbody> _affectedRigidbodies = new List<Rigidbody>();\n    private List<ParticleSystem> _affectedParticleSystems = new List<ParticleSystem>();\n    private float _lastUpdateTime;\n    private Vector3 _worldWindDirection;\n    \n    private void Start()\n    {\n        SetupAudio();\n        SetupParticles();\n        UpdateWindDirection();\n    }\n    \n    private void Update()\n    {\n        UpdateWindDirection();\n        \n        if (Time.time - _lastUpdateTime >= _updateFrequency)\n        {\n            DetectAffectedObjects();\n            _lastUpdateTime = Time.time;\n        }\n        \n        ApplyWindForces();\n        UpdateAudioEffects();\n    }\n    \n    private void UpdateWindDirection()\n    {\n        _worldWindDirection = _useLocalDirection ? transform.TransformDirection(_windDirection.normalized) : _windDirection.normalized;\n    }\n    \n    private void DetectAffectedObjects()\n    {\n        _affectedRigidbodies.Clear();\n        _affectedParticleSystems.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _affectedLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!IsValidTarget(col.gameObject))\n                continue;\n                \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance > _maxWindDistance)\n                continue;\n            \n            if (_affectRigidbodies)\n            {\n                Rigidbody rb = col.GetComponent<Rigidbody>();\n                if (rb != null && !_affectedRigidbodies.Contains(rb))\n                {\n                    _affectedRigidbodies.Add(rb);\n                }\n            }\n            \n            if (_affectParticles)\n            {\n                ParticleSystem ps = col.GetComponent<ParticleSystem>();\n                if (ps != null && !_affectedParticleSystems.Contains(ps))\n                {\n                    _affectedParticleSystems.Add(ps);\n                }\n            }\n        }\n    }\n    \n    private bool IsValidTarget(GameObject target)\n    {\n        if (_affectedTags.Length > 0)\n        {\n            foreach (string tag in _affectedTags)\n            {\n                if (target.CompareTag(tag))\n                    return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    \n    private void ApplyWindForces()\n    {\n        foreach (Rigidbody rb in _affectedRigidbodies)\n        {\n            if (rb == null) continue;\n            \n            Vector3 directionToObject = rb.transform.position - transform.position;\n            float distance = directionToObject.magnitude;\n            \n            if (distance > _maxWindDistance) continue;\n            \n            float normalizedDistance = distance / _maxWindDistance;\n            float forceMultiplier = _forceFalloff.Evaluate(normalizedDistance);\n            \n            Vector3 windForceVector = _worldWindDirection * _windForce * forceMultiplier;\n            \n            // Apply drag factor based on object's velocity opposing wind\n            float dragFactor = Mathf.Clamp01(1f - Vector3.Dot(rb.velocity.normalized, _worldWindDirection));\n            windForceVector *= (0.5f + dragFactor * 0.5f);\n            \n            rb.AddForce(windForceVector, ForceMode.Force);\n        }\n        \n        foreach (ParticleSystem ps in _affectedParticleSystems)\n        {\n            if (ps == null) continue;\n            \n            var velocityOverLifetime = ps.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n            \n            float distance = Vector3.Distance(transform.position, ps.transform.position);\n            float normalizedDistance = distance / _maxWindDistance;\n            float forceMultiplier = _forceFalloff.Evaluate(normalizedDistance);\n            \n            Vector3 particleWind = _worldWindDirection * _windForce * forceMultiplier * 0.1f;\n            velocityOverLifetime.x = particleWind.x;\n            velocityOverLifetime.y = particleWind.y;\n            velocityOverLifetime.z = particleWind.z;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_windSound != null)\n        {\n            _audioSource.clip = _windSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _baseVolume;\n            _audioSource.pitch = _basePitch;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (_createWindParticles && _windParticles == null)\n        {\n            GameObject particleObject = new GameObject(\"WindParticles\");\n            particleObject.transform.SetParent(transform);\n            particleObject.transform.localPosition = Vector3.zero;\n            \n            _windParticles = particleObject.AddComponent<ParticleSystem>();\n            \n            var main = _windParticles.main;\n            main.startLifetime = 2f;\n            main.startSpeed = _particleSpeed;\n            main.maxParticles = _particleCount;\n            main.startSize = 0.1f;\n            main.startColor = new Color(1f, 1f, 1f, 0.3f);\n            \n            var emission = _windParticles.emission;\n            emission.rateOverTime = _particleCount * 0.5f;\n            \n            var shape = _windParticles.shape;\n            shape.enabled = true;\n            shape.shapeType = ParticleSystemShapeType.Box;\n            shape.scale = new Vector3(_detectionRadius, _detectionRadius, 1f);\n            \n            var velocityOverLifetime = _windParticles.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        }\n        \n        if (_windParticles != null)\n        {\n            var velocityOverLifetime = _windParticles.velocityOverLifetime;\n            Vector3 particleVelocity = _worldWindDirection * _particleSpeed;\n            velocityOverLifetime.x = particleVelocity.x;\n            velocityOverLifetime.y = particleVelocity.y;\n            velocityOverLifetime.z = particleVelocity.z;\n        }\n    }\n    \n    private void UpdateAudioEffects()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float intensity = Mathf.Clamp01(_affectedRigidbodies.Count / 10f);\n            _audioSource.volume = _baseVolume * (0.5f + intensity * 0.5f);\n            _audioSource.pitch = _basePitch * (0.8f + intensity * 0.4f);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxWindDistance);\n        \n        Gizmos.color = Color.red;\n        Vector3 windDir = _useLocalDirection ? transform.TransformDirection(_windDirection.normalized) : _windDirection.normalized;\n        Gizmos.DrawRay(transform.position, windDir * _maxWindDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n    }\n    \n    public void SetWindForce(float force)\n    {\n        _windForce = force;\n    }\n    \n    public void SetWindDirection(Vector3 direction)\n    {\n        _windDirection = direction.normalized;\n        UpdateWindDirection();\n    }\n    \n    public void ToggleWind(bool enabled)\n    {\n        this.enabled = enabled;\n        \n        if (_windParticles != null)\n        {\n            if (enabled)\n                _windParticles.Play();\n            else\n                _windParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (enabled)\n                _audioSource.Play();\n            else\n                _audioSource.Stop();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HoverboardFloating\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hoverHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"hoverForce\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"stabilityForce\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"maxFloatDistance\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"maintain_hover_height\",\n      \"trigger\": \"when ground is detected below the hoverboard\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force to maintain desired hover height above ground\"\n        },\n        {\n          \"action\": \"adjust force strength based on distance from ground\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stabilize_rotation\",\n      \"trigger\": \"when hoverboard tilts or rotates\",\n      \"actions\": [\n        {\n          \"action\": \"apply counter-torque to keep hoverboard level\"\n        },\n        {\n          \"action\": \"dampen rotational movement for stability\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ground_following\",\n      \"trigger\": \"when terrain height changes below hoverboard\",\n      \"actions\": [\n        {\n          \"action\": \"adjust hover height to follow ground contours\"\n        },\n        {\n          \"action\": \"maintain smooth floating motion over uneven surfaces\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fall_when_too_high\",\n      \"trigger\": \"when no ground is detected within maximum float distance\",\n      \"actions\": [\n        {\n          \"action\": \"reduce hover force gradually\"\n        },\n        {\n          \"action\": \"allow hoverboard to descend under gravity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HoverboardController : MonoBehaviour\n{\n    [Header(\"Hover Settings\")]\n    [SerializeField] private float _hoverHeight = 1.5f;\n    [SerializeField] private float _hoverForce = 300f;\n    [SerializeField] private float _hoverDamping = 50f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 10f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    \n    [Header(\"Tilt Effects\")]\n    [SerializeField] private float _maxTiltAngle = 15f;\n    [SerializeField] private float _tiltSpeed = 3f;\n    \n    [Header(\"Hover Points\")]\n    [SerializeField] private Transform[] _hoverPoints;\n    \n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private Vector3 _moveInput;\n    private float _turnInput;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.centerOfMass = Vector3.down * 0.5f;\n        \n        if (_hoverPoints == null || _hoverPoints.Length == 0)\n        {\n            CreateDefaultHoverPoints();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        ApplyTiltEffect();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyHoverForce();\n        ApplyMovement();\n        ApplyTurning();\n    }\n    \n    private void HandleInput()\n    {\n        _moveInput.x = Input.GetAxis(\"Horizontal\");\n        _moveInput.z = Input.GetAxis(\"Vertical\");\n        _turnInput = Input.GetAxis(\"Horizontal\");\n    }\n    \n    private void ApplyHoverForce()\n    {\n        foreach (Transform hoverPoint in _hoverPoints)\n        {\n            if (hoverPoint == null) continue;\n            \n            RaycastHit hit;\n            Vector3 rayStart = hoverPoint.position;\n            Vector3 rayDirection = -hoverPoint.up;\n            \n            if (Physics.Raycast(rayStart, rayDirection, out hit, _hoverHeight * 2f, _groundLayer))\n            {\n                float distance = hit.distance;\n                float hoverRatio = (_hoverHeight - distance) / _hoverHeight;\n                \n                if (hoverRatio > 0)\n                {\n                    Vector3 force = hoverPoint.up * _hoverForce * hoverRatio;\n                    Vector3 velocity = _rigidbody.GetPointVelocity(hoverPoint.position);\n                    float dampingForce = Vector3.Dot(velocity, hoverPoint.up) * _hoverDamping;\n                    \n                    _rigidbody.AddForceAtPosition(force - hoverPoint.up * dampingForce, hoverPoint.position);\n                }\n            }\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        Vector3 worldMoveInput = transform.TransformDirection(_moveInput);\n        worldMoveInput.y = 0;\n        \n        if (_moveInput.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, _moveSpeed, _acceleration * Time.fixedDeltaTime);\n        }\n        else\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0, _deceleration * Time.fixedDeltaTime);\n        }\n        \n        Vector3 targetVelocity = worldMoveInput.normalized * _currentSpeed;\n        Vector3 velocityChange = targetVelocity - new Vector3(_rigidbody.velocity.x, 0, _rigidbody.velocity.z);\n        \n        _rigidbody.AddForce(velocityChange, ForceMode.VelocityChange);\n    }\n    \n    private void ApplyTurning()\n    {\n        if (Mathf.Abs(_turnInput) > 0.1f)\n        {\n            float torque = _turnInput * _turnSpeed * Time.fixedDeltaTime;\n            _rigidbody.AddTorque(transform.up * torque);\n        }\n    }\n    \n    private void ApplyTiltEffect()\n    {\n        float forwardTilt = -_moveInput.z * _maxTiltAngle;\n        float sideTilt = _moveInput.x * _maxTiltAngle;\n        \n        Quaternion targetRotation = Quaternion.Euler(forwardTilt, transform.eulerAngles.y, sideTilt);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _tiltSpeed * Time.deltaTime);\n    }\n    \n    private void CreateDefaultHoverPoints()\n    {\n        _hoverPoints = new Transform[4];\n        \n        Vector3[] positions = {\n            new Vector3(-0.5f, 0, 0.5f),   // Front Left\n            new Vector3(0.5f, 0, 0.5f),    // Front Right\n            new Vector3(-0.5f, 0, -0.5f),  // Back Left\n            new Vector3(0.5f, 0, -0.5f)    // Back Right\n        };\n        \n        for (int i = 0; i < positions.Length; i++)\n        {\n            GameObject hoverPoint = new GameObject($\"HoverPoint_{i}\");\n            hoverPoint.transform.SetParent(transform);\n            hoverPoint.transform.localPosition = positions[i];\n            _hoverPoints[i] = hoverPoint.transform;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_hoverPoints == null) return;\n        \n        Gizmos.color = Color.blue;\n        foreach (Transform hoverPoint in _hoverPoints)\n        {\n            if (hoverPoint == null) continue;\n            \n            Vector3 start = hoverPoint.position;\n            Vector3 end = start - hoverPoint.up * _hoverHeight * 2f;\n            \n            Gizmos.DrawLine(start, end);\n            Gizmos.DrawWireSphere(start - hoverPoint.up * _hoverHeight, 0.1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HitFlashEffect\",\n  \"components\": [\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"flashColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.red\"\n    },\n    {\n      \"name\": \"flashDuration\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.white\"\n    },\n    {\n      \"name\": \"isFlashing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"flashTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_flash_on_damage\",\n      \"trigger\": \"when this object takes damage\",\n      \"actions\": [\n        {\n          \"action\": \"change renderer material color to flash color\"\n        },\n        {\n          \"action\": \"set flashing state to true\"\n        },\n        {\n          \"action\": \"reset flash timer to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_flash_effect\",\n      \"trigger\": \"every frame while flashing\",\n      \"actions\": [\n        {\n          \"action\": \"increase flash timer by frame time\"\n        },\n        {\n          \"action\": \"if flash timer exceeds flash duration then stop flashing and restore original color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"store_original_color\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"save the current material color as original color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class HitFlashEffect : MonoBehaviour\n{\n    [Header(\"Flash Settings\")]\n    [SerializeField] private Color _flashColor = Color.red;\n    [SerializeField] private float _flashDuration = 0.1f;\n    [SerializeField] private int _flashCount = 1;\n    [SerializeField] private float _flashInterval = 0.05f;\n    \n    [Header(\"Component References\")]\n    [SerializeField] private Renderer _targetRenderer;\n    [SerializeField] private SpriteRenderer _spriteRenderer;\n    \n    private Material _originalMaterial;\n    private Color _originalColor;\n    private bool _isFlashing = false;\n    private Coroutine _flashCoroutine;\n    \n    private void Start()\n    {\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n            \n        if (_spriteRenderer == null)\n            _spriteRenderer = GetComponent<SpriteRenderer>();\n            \n        if (_targetRenderer != null)\n        {\n            _originalMaterial = _targetRenderer.material;\n        }\n        \n        if (_spriteRenderer != null)\n        {\n            _originalColor = _spriteRenderer.color;\n        }\n    }\n    \n    public void TriggerFlash()\n    {\n        if (_isFlashing)\n        {\n            StopFlash();\n        }\n        \n        _flashCoroutine = StartCoroutine(FlashRoutine());\n    }\n    \n    public void TriggerFlash(Color flashColor)\n    {\n        _flashColor = flashColor;\n        TriggerFlash();\n    }\n    \n    public void TriggerFlash(float duration)\n    {\n        _flashDuration = duration;\n        TriggerFlash();\n    }\n    \n    public void TriggerFlash(Color flashColor, float duration)\n    {\n        _flashColor = flashColor;\n        _flashDuration = duration;\n        TriggerFlash();\n    }\n    \n    public void StopFlash()\n    {\n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n            _flashCoroutine = null;\n        }\n        \n        _isFlashing = false;\n        RestoreOriginalAppearance();\n    }\n    \n    private IEnumerator FlashRoutine()\n    {\n        _isFlashing = true;\n        \n        for (int i = 0; i < _flashCount; i++)\n        {\n            ApplyFlashEffect();\n            yield return new WaitForSeconds(_flashDuration);\n            \n            RestoreOriginalAppearance();\n            \n            if (i < _flashCount - 1)\n            {\n                yield return new WaitForSeconds(_flashInterval);\n            }\n        }\n        \n        _isFlashing = false;\n        _flashCoroutine = null;\n    }\n    \n    private void ApplyFlashEffect()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = _flashColor;\n        }\n        else if (_targetRenderer != null)\n        {\n            _targetRenderer.material.color = _flashColor;\n        }\n    }\n    \n    private void RestoreOriginalAppearance()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = _originalColor;\n        }\n        else if (_targetRenderer != null && _originalMaterial != null)\n        {\n            _targetRenderer.material.color = _originalMaterial.color;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\") || other.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\") || collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            TriggerFlash();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_flashDuration < 0.01f)\n            _flashDuration = 0.01f;\n            \n        if (_flashCount < 1)\n            _flashCount = 1;\n            \n        if (_flashInterval < 0f)\n            _flashInterval = 0f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FireStaff\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"burnDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"burnDuration\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"fireRange\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"manaCost\",\n      \"type\": \"int\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"cast_fire_spell\",\n      \"trigger\": \"when player presses fire button and has enough mana and staff is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"consume mana from player\"\n        },\n        {\n          \"action\": \"play fire casting sound effect\"\n        },\n        {\n          \"action\": \"create flame projectile that travels forward\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"show fire particle effects from staff tip\"\n        }\n      ]\n    },\n    {\n      \"name\": \"burn_target\",\n      \"trigger\": \"when flame projectile hits enemy or flammable object\",\n      \"actions\": [\n        {\n          \"action\": \"apply burn damage over time to target\"\n        },\n        {\n          \"action\": \"create burning visual effects on target\"\n        },\n        {\n          \"action\": \"play burning sound effect\"\n        },\n        {\n          \"action\": \"set target on fire for burn duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spread_fire\",\n      \"trigger\": \"when burning target is near other flammable objects\",\n      \"actions\": [\n        {\n          \"action\": \"ignite nearby flammable objects\"\n        },\n        {\n          \"action\": \"create fire spread particle effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class FireStaff : MonoBehaviour\n{\n    [Header(\"Fire Staff Settings\")]\n    [SerializeField] private float _fireRange = 10f;\n    [SerializeField] private float _fireDamage = 25f;\n    [SerializeField] private float _burnDuration = 3f;\n    [SerializeField] private float _burnDamagePerSecond = 5f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private ParticleSystem _castEffect;\n    [SerializeField] private LineRenderer _fireBeam;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private Transform _firePoint;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private bool _canCast = true;\n    private Camera _playerCamera;\n    private Dictionary<GameObject, BurnEffect> _burningTargets = new Dictionary<GameObject, BurnEffect>();\n    \n    [System.Serializable]\n    public class BurnEffect\n    {\n        public float remainingTime;\n        public Coroutine burnCoroutine;\n        public ParticleSystem burnParticles;\n        \n        public BurnEffect(float duration)\n        {\n            remainingTime = duration;\n        }\n    }\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n            \n        if (_fireBeam != null)\n        {\n            _fireBeam.enabled = false;\n            _fireBeam.startWidth = 0.1f;\n            _fireBeam.endWidth = 0.05f;\n        }\n        \n        if (_fireLight != null)\n        {\n            _fireLight.enabled = false;\n            _fireLight.color = Color.red;\n            _fireLight.intensity = 2f;\n        }\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateVisualEffects();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && _canCast)\n        {\n            CastFire();\n        }\n    }\n    \n    void CastFire()\n    {\n        if (_playerCamera == null) return;\n        \n        _canCast = false;\n        \n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        if (_firePoint != null)\n        {\n            rayOrigin = _firePoint.position;\n            rayDirection = (_playerCamera.transform.position + _playerCamera.transform.forward * _fireRange - _firePoint.position).normalized;\n        }\n        \n        RaycastHit hit;\n        Vector3 targetPoint;\n        \n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _fireRange, _targetLayers))\n        {\n            targetPoint = hit.point;\n            ProcessFireHit(hit);\n        }\n        else\n        {\n            targetPoint = rayOrigin + rayDirection * _fireRange;\n        }\n        \n        StartCoroutine(FireEffectCoroutine(rayOrigin, targetPoint));\n        StartCoroutine(CooldownCoroutine());\n        \n        PlayCastSound();\n    }\n    \n    void ProcessFireHit(RaycastHit hit)\n    {\n        GameObject target = hit.collider.gameObject;\n        \n        // Apply immediate damage\n        ApplyDamage(target, _fireDamage);\n        \n        // Apply burn effect\n        ApplyBurnEffect(target);\n        \n        PlayHitSound();\n    }\n    \n    void ApplyDamage(GameObject target, float damage)\n    {\n        // Try different common health component patterns\n        var health = target.GetComponent<MonoBehaviour>();\n        if (health != null)\n        {\n            // Use SendMessage as a fallback for unknown health systems\n            target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // If target has Rigidbody, add force\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * damage * 0.1f, ForceMode.Impulse);\n        }\n    }\n    \n    void ApplyBurnEffect(GameObject target)\n    {\n        if (_burningTargets.ContainsKey(target))\n        {\n            // Refresh burn duration\n            _burningTargets[target].remainingTime = _burnDuration;\n            return;\n        }\n        \n        BurnEffect burnEffect = new BurnEffect(_burnDuration);\n        \n        // Create burn particles\n        if (_fireParticles != null)\n        {\n            GameObject burnParticleObj = Instantiate(_fireParticles.gameObject, target.transform.position, Quaternion.identity);\n            burnEffect.burnParticles = burnParticleObj.GetComponent<ParticleSystem>();\n            burnParticleObj.transform.SetParent(target.transform);\n        }\n        \n        burnEffect.burnCoroutine = StartCoroutine(BurnCoroutine(target, burnEffect));\n        _burningTargets[target] = burnEffect;\n    }\n    \n    IEnumerator BurnCoroutine(GameObject target, BurnEffect burnEffect)\n    {\n        while (burnEffect.remainingTime > 0 && target != null)\n        {\n            ApplyDamage(target, _burnDamagePerSecond);\n            burnEffect.remainingTime -= 1f;\n            yield return new WaitForSeconds(1f);\n        }\n        \n        // Clean up\n        if (_burningTargets.ContainsKey(target))\n        {\n            if (burnEffect.burnParticles != null)\n                Destroy(burnEffect.burnParticles.gameObject);\n            _burningTargets.Remove(target);\n        }\n    }\n    \n    IEnumerator FireEffectCoroutine(Vector3 startPoint, Vector3 endPoint)\n    {\n        // Enable visual effects\n        if (_fireBeam != null)\n        {\n            _fireBeam.enabled = true;\n            _fireBeam.SetPosition(0, startPoint);\n            _fireBeam.SetPosition(1, endPoint);\n        }\n        \n        if (_fireLight != null)\n        {\n            _fireLight.enabled = true;\n        }\n        \n        if (_castEffect != null)\n        {\n            _castEffect.Play();\n        }\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        // Disable visual effects\n        if (_fireBeam != null)\n            _fireBeam.enabled = false;\n            \n        if (_fireLight != null)\n            _fireLight.enabled = false;\n    }\n    \n    IEnumerator CooldownCoroutine()\n    {\n        yield return new WaitForSeconds(_cooldownTime);\n        _canCast = true;\n    }\n    \n    void UpdateVisualEffects()\n    {\n        if (_fireParticles != null)\n        {\n            if (_canCast)\n            {\n                if (!_fireParticles.isPlaying)\n                    _fireParticles.Play();\n            }\n            else\n            {\n                if (_fireParticles.isPlaying)\n                    _fireParticles.Stop();\n            }\n        }\n    }\n    \n    void PlayCastSound()\n    {\n        if (_audioSource != null && _castSound != null)\n        {\n            _audioSource.PlayOneShot(_castSound);\n        }\n    }\n    \n    void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        // Clean up all burning effects\n        foreach (var kvp in _burningTargets)\n        {\n            if (kvp.Value.burnCoroutine != null)\n                StopCoroutine(kvp.Value.burnCoroutine);\n            if (kvp.Value.burnParticles != null)\n                Destroy(kvp.Value.burnParticles.gameObject);\n        }\n        _burningTargets.Clear();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 origin = _firePoint != null ? _firePoint.position : transform.position;\n        Vector3 direction = transform.forward;\n        \n        if (_playerCamera != null)\n            direction = _playerCamera.transform.forward;\n            \n        Gizmos.DrawRay(origin, direction * _fireRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CrouchCrawlMovement\",\n  \"components\": [\n    \"CharacterController\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"crouchSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"crawlSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"standingHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"crouchHeight\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"crawlHeight\",\n      \"type\": \"float\",\n      \"default\": 0.6\n    },\n    {\n      \"name\": \"transitionSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"currentMovementState\",\n      \"type\": \"string\",\n      \"default\": \"standing\"\n    },\n    {\n      \"name\": \"isMoving\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_crouch_mode\",\n      \"trigger\": \"when crouch input is pressed while standing\",\n      \"actions\": [\n        {\n          \"action\": \"set movement state to crouching\"\n        },\n        {\n          \"action\": \"smoothly reduce character height to crouch height\"\n        },\n        {\n          \"action\": \"play crouch animation\"\n        },\n        {\n          \"action\": \"reduce movement speed to crouch speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_crouch_mode\",\n      \"trigger\": \"when crouch input is released while crouching and there is space above\",\n      \"actions\": [\n        {\n          \"action\": \"set movement state to standing\"\n        },\n        {\n          \"action\": \"smoothly increase character height to standing height\"\n        },\n        {\n          \"action\": \"play stand animation\"\n        },\n        {\n          \"action\": \"restore movement speed to walk speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enter_crawl_mode\",\n      \"trigger\": \"when crouch input is held and crawl input is pressed while crouching\",\n      \"actions\": [\n        {\n          \"action\": \"set movement state to crawling\"\n        },\n        {\n          \"action\": \"smoothly reduce character height to crawl height\"\n        },\n        {\n          \"action\": \"play crawl idle animation\"\n        },\n        {\n          \"action\": \"reduce movement speed to crawl speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_crawl_mode\",\n      \"trigger\": \"when crawl input is released while crawling\",\n      \"actions\": [\n        {\n          \"action\": \"set movement state to crouching\"\n        },\n        {\n          \"action\": \"smoothly increase character height to crouch height\"\n        },\n        {\n          \"action\": \"play crouch animation\"\n        },\n        {\n          \"action\": \"increase movement speed to crouch speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"crouch_movement\",\n      \"trigger\": \"when movement input is received while in crouching state\",\n      \"actions\": [\n        {\n          \"action\": \"move character in input direction at crouch speed\"\n        },\n        {\n          \"action\": \"play crouch walk animation\"\n        },\n        {\n          \"action\": \"set is moving to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"crawl_movement\",\n      \"trigger\": \"when movement input is received while in crawling state\",\n      \"actions\": [\n        {\n          \"action\": \"move character in input direction at crawl speed\"\n        },\n        {\n          \"action\": \"play crawl movement animation\"\n        },\n        {\n          \"action\": \"set is moving to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_movement\",\n      \"trigger\": \"when no movement input is received\",\n      \"actions\": [\n        {\n          \"action\": \"stop character movement\"\n        },\n        {\n          \"action\": \"play appropriate idle animation based on current state\"\n        },\n        {\n          \"action\": \"set is moving to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_overhead_clearance\",\n      \"trigger\": \"when attempting to stand up from crouch or crawl\",\n      \"actions\": [\n        {\n          \"action\": \"check if there is sufficient space above character\"\n        },\n        {\n          \"action\": \"prevent standing if obstacle is detected overhead\"\n        },\n        {\n          \"action\": \"maintain current posture if blocked\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CrouchCrawlMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _walkSpeed = 5f;\n    [SerializeField] private float _crouchSpeed = 2.5f;\n    [SerializeField] private float _crawlSpeed = 1.5f;\n    [SerializeField] private float _acceleration = 10f;\n    [SerializeField] private float _deceleration = 10f;\n    \n    [Header(\"Stance Settings\")]\n    [SerializeField] private float _standingHeight = 2f;\n    [SerializeField] private float _crouchHeight = 1.2f;\n    [SerializeField] private float _crawlHeight = 0.6f;\n    [SerializeField] private float _stanceTransitionSpeed = 8f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _crouchKey = KeyCode.LeftControl;\n    [SerializeField] private KeyCode _crawlKey = KeyCode.C;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Ceiling Check\")]\n    [SerializeField] private float _ceilingCheckDistance = 0.1f;\n    [SerializeField] private LayerMask _ceilingLayerMask = 1;\n    \n    private CharacterController _characterController;\n    private Camera _playerCamera;\n    private Vector3 _moveDirection;\n    private Vector3 _velocity;\n    private float _currentSpeed;\n    private float _targetHeight;\n    private float _currentCameraHeight;\n    private bool _isGrounded;\n    private MovementStance _currentStance = MovementStance.Standing;\n    \n    private enum MovementStance\n    {\n        Standing,\n        Crouching,\n        Crawling\n    }\n    \n    void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _playerCamera = GetComponentInChildren<Camera>();\n        \n        if (_characterController == null)\n        {\n            Debug.LogError(\"CharacterController component required!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_playerCamera == null)\n        {\n            _playerCamera = Camera.main;\n        }\n        \n        _targetHeight = _standingHeight;\n        _currentCameraHeight = _standingHeight - 0.1f;\n        _characterController.height = _standingHeight;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        HandleStanceTransition();\n        HandleMovement();\n        UpdateCameraPosition();\n    }\n    \n    void HandleInput()\n    {\n        bool crouchInput = Input.GetKey(_crouchKey);\n        bool crawlInput = Input.GetKey(_crawlKey);\n        \n        MovementStance desiredStance = MovementStance.Standing;\n        \n        if (crawlInput)\n        {\n            desiredStance = MovementStance.Crawling;\n        }\n        else if (crouchInput)\n        {\n            desiredStance = MovementStance.Crouching;\n        }\n        \n        if (desiredStance != _currentStance)\n        {\n            if (CanChangeStance(desiredStance))\n            {\n                _currentStance = desiredStance;\n                UpdateTargetHeight();\n            }\n        }\n    }\n    \n    bool CanChangeStance(MovementStance newStance)\n    {\n        if (newStance == MovementStance.Standing || newStance == MovementStance.Crouching)\n        {\n            float checkHeight = newStance == MovementStance.Standing ? _standingHeight : _crouchHeight;\n            return !CheckCeiling(checkHeight);\n        }\n        return true;\n    }\n    \n    bool CheckCeiling(float checkHeight)\n    {\n        Vector3 rayStart = transform.position + Vector3.up * _characterController.height * 0.5f;\n        Vector3 rayEnd = transform.position + Vector3.up * (checkHeight * 0.5f + _ceilingCheckDistance);\n        \n        return Physics.Raycast(rayStart, Vector3.up, Vector3.Distance(rayStart, rayEnd), _ceilingLayerMask);\n    }\n    \n    void UpdateTargetHeight()\n    {\n        switch (_currentStance)\n        {\n            case MovementStance.Standing:\n                _targetHeight = _standingHeight;\n                break;\n            case MovementStance.Crouching:\n                _targetHeight = _crouchHeight;\n                break;\n            case MovementStance.Crawling:\n                _targetHeight = _crawlHeight;\n                break;\n        }\n    }\n    \n    void HandleStanceTransition()\n    {\n        if (Mathf.Abs(_characterController.height - _targetHeight) > 0.01f)\n        {\n            float newHeight = Mathf.Lerp(_characterController.height, _targetHeight, Time.deltaTime * _stanceTransitionSpeed);\n            \n            Vector3 centerOffset = Vector3.up * (newHeight - _characterController.height) * 0.5f;\n            _characterController.height = newHeight;\n            _characterController.center = Vector3.up * newHeight * 0.5f;\n            \n            transform.position += centerOffset;\n        }\n    }\n    \n    void HandleMovement()\n    {\n        _isGrounded = CheckGrounded();\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 inputDirection = new Vector3(horizontal, 0, vertical).normalized;\n        Vector3 worldDirection = transform.TransformDirection(inputDirection);\n        \n        float targetSpeed = GetCurrentMaxSpeed();\n        if (inputDirection.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, targetSpeed, Time.deltaTime * _acceleration);\n        }\n        else\n        {\n            _currentSpeed = Mathf.Lerp(_currentSpeed, 0f, Time.deltaTime * _deceleration);\n        }\n        \n        _moveDirection = worldDirection * _currentSpeed;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        \n        Vector3 finalMovement = _moveDirection + Vector3.up * _velocity.y;\n        _characterController.Move(finalMovement * Time.deltaTime);\n    }\n    \n    float GetCurrentMaxSpeed()\n    {\n        switch (_currentStance)\n        {\n            case MovementStance.Standing:\n                return _walkSpeed;\n            case MovementStance.Crouching:\n                return _crouchSpeed;\n            case MovementStance.Crawling:\n                return _crawlSpeed;\n            default:\n                return _walkSpeed;\n        }\n    }\n    \n    bool CheckGrounded()\n    {\n        Vector3 rayStart = transform.position + Vector3.up * 0.1f;\n        return Physics.Raycast(rayStart, Vector3.down, _characterController.height * 0.5f + _groundCheckDistance, _groundLayerMask);\n    }\n    \n    void UpdateCameraPosition()\n    {\n        if (_playerCamera != null)\n        {\n            float targetCameraHeight = _targetHeight - 0.1f;\n            _currentCameraHeight = Mathf.Lerp(_currentCameraHeight, targetCameraHeight, Time.deltaTime * _stanceTransitionSpeed);\n            \n            Vector3 cameraPosition = _playerCamera.transform.localPosition;\n            cameraPosition.y = _currentCameraHeight;\n            _playerCamera.transform.localPosition = cameraPosition;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_characterController != null)\n        {\n            Gizmos.color = Color.green;\n            Vector3 groundCheckStart = transform.position + Vector3.up * 0.1f;\n            Vector3 groundCheckEnd = groundCheckStart + Vector3.down * (_characterController.height * 0.5f + _groundCheckDistance);\n            Gizmos.DrawLine(groundCheckStart, groundCheckEnd);\n            \n            Gizmos.color = Color.red;\n            Vector3 ceilingCheckStart = transform.position + Vector3.up * _characterController.height * 0.5f;\n            Vector3 ceilingCheckEnd = ceilingCheckStart + Vector3.up * _ceilingCheckDistance;\n            Gizmos.DrawLine(ceilingCheckStart, ceilingCheckEnd);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Shop\",\n  \"components\": [\n    \"Canvas\",\n    \"GraphicRaycaster\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"itemPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"itemContainer\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"playerCurrency\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currencyText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"purchaseSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_shop\",\n      \"trigger\": \"when shop starts\",\n      \"actions\": [\n        {\n          \"action\": \"create item display for each available item\"\n        },\n        {\n          \"action\": \"show item name price and icon for each item\"\n        },\n        {\n          \"action\": \"update currency display with current player money\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_item_purchase\",\n      \"trigger\": \"when player clicks on item purchase button\",\n      \"actions\": [\n        {\n          \"action\": \"check if player has enough currency for selected item\"\n        },\n        {\n          \"action\": \"deduct item cost from player currency if affordable\"\n        },\n        {\n          \"action\": \"add purchased item to player inventory\"\n        },\n        {\n          \"action\": \"update currency display with new amount\"\n        },\n        {\n          \"action\": \"play purchase confirmation sound\"\n        },\n        {\n          \"action\": \"show purchase success message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_insufficient_funds\",\n      \"trigger\": \"when player tries to buy item without enough money\",\n      \"actions\": [\n        {\n          \"action\": \"show insufficient funds warning message\"\n        },\n        {\n          \"action\": \"highlight currency display briefly\"\n        },\n        {\n          \"action\": \"prevent purchase from completing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_item_availability\",\n      \"trigger\": \"when player currency changes\",\n      \"actions\": [\n        {\n          \"action\": \"check affordability of each displayed item\"\n        },\n        {\n          \"action\": \"dim or disable purchase buttons for unaffordable items\"\n        },\n        {\n          \"action\": \"highlight affordable items\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System;\n\npublic class Shop : MonoBehaviour\n{\n    [System.Serializable]\n    public class ShopItem\n    {\n        [Header(\"Item Info\")]\n        public string itemName;\n        public string description;\n        public Sprite icon;\n        public int price;\n        public int maxQuantity = 1;\n        \n        [Header(\"Item Data\")]\n        public GameObject itemPrefab;\n        public bool isConsumable = false;\n        \n        [HideInInspector]\n        public int currentQuantity = 0;\n    }\n\n    [System.Serializable]\n    public class ShopItemUI\n    {\n        public GameObject itemPanel;\n        public Image itemIcon;\n        public Text itemName;\n        public Text itemDescription;\n        public Text itemPrice;\n        public Text quantityText;\n        public Button purchaseButton;\n        public Button sellButton;\n        \n        [HideInInspector]\n        public ShopItem linkedItem;\n    }\n\n    [Header(\"Shop Configuration\")]\n    [SerializeField] private List<ShopItem> _shopItems = new List<ShopItem>();\n    [SerializeField] private GameObject _shopPanel;\n    [SerializeField] private GameObject _itemUIPrefab;\n    [SerializeField] private Transform _itemContainer;\n    [SerializeField] private ScrollRect _scrollRect;\n    \n    [Header(\"Player Currency\")]\n    [SerializeField] private int _playerMoney = 1000;\n    [SerializeField] private Text _moneyDisplay;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private Button _closeShopButton;\n    [SerializeField] private Text _shopTitle;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _purchaseSound;\n    [SerializeField] private AudioClip _sellSound;\n    [SerializeField] private AudioClip _errorSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string, int> OnItemPurchased;\n    public UnityEvent<string, int> OnItemSold;\n    public UnityEvent<int> OnMoneyChanged;\n    \n    private List<ShopItemUI> _itemUIElements = new List<ShopItemUI>();\n    private bool _isShopOpen = false;\n    private Dictionary<string, int> _playerInventory = new Dictionary<string, int>();\n\n    private void Start()\n    {\n        InitializeShop();\n        UpdateMoneyDisplay();\n        \n        if (_closeShopButton != null)\n            _closeShopButton.onClick.AddListener(CloseShop);\n            \n        CloseShop();\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape) && _isShopOpen)\n        {\n            CloseShop();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            OpenShop();\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            CloseShop();\n        }\n    }\n\n    private void InitializeShop()\n    {\n        if (_itemContainer == null || _itemUIPrefab == null) return;\n\n        foreach (Transform child in _itemContainer)\n        {\n            if (Application.isPlaying)\n                Destroy(child.gameObject);\n            else\n                DestroyImmediate(child.gameObject);\n        }\n\n        _itemUIElements.Clear();\n\n        for (int i = 0; i < _shopItems.Count; i++)\n        {\n            CreateItemUI(_shopItems[i]);\n        }\n    }\n\n    private void CreateItemUI(ShopItem item)\n    {\n        GameObject itemUI = Instantiate(_itemUIPrefab, _itemContainer);\n        ShopItemUI uiElement = new ShopItemUI();\n\n        uiElement.itemPanel = itemUI;\n        uiElement.itemIcon = itemUI.transform.Find(\"Icon\")?.GetComponent<Image>();\n        uiElement.itemName = itemUI.transform.Find(\"ItemName\")?.GetComponent<Text>();\n        uiElement.itemDescription = itemUI.transform.Find(\"Description\")?.GetComponent<Text>();\n        uiElement.itemPrice = itemUI.transform.Find(\"Price\")?.GetComponent<Text>();\n        uiElement.quantityText = itemUI.transform.Find(\"Quantity\")?.GetComponent<Text>();\n        uiElement.purchaseButton = itemUI.transform.Find(\"PurchaseButton\")?.GetComponent<Button>();\n        uiElement.sellButton = itemUI.transform.Find(\"SellButton\")?.GetComponent<Button>();\n        uiElement.linkedItem = item;\n\n        if (uiElement.itemIcon != null && item.icon != null)\n            uiElement.itemIcon.sprite = item.icon;\n\n        if (uiElement.itemName != null)\n            uiElement.itemName.text = item.itemName;\n\n        if (uiElement.itemDescription != null)\n            uiElement.itemDescription.text = item.description;\n\n        if (uiElement.itemPrice != null)\n            uiElement.itemPrice.text = \"$\" + item.price.ToString();\n\n        if (uiElement.purchaseButton != null)\n        {\n            uiElement.purchaseButton.onClick.AddListener(() => PurchaseItem(item));\n        }\n\n        if (uiElement.sellButton != null)\n        {\n            uiElement.sellButton.onClick.AddListener(() => SellItem(item));\n        }\n\n        _itemUIElements.Add(uiElement);\n        UpdateItemUI(uiElement);\n    }\n\n    private void UpdateItemUI(ShopItemUI uiElement)\n    {\n        if (uiElement.linkedItem == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(uiElement.linkedItem.itemName);\n        \n        if (uiElement.quantityText != null)\n        {\n            uiElement.quantityText.text = \"Owned: \" + ownedQuantity.ToString();\n        }\n\n        bool canPurchase = _playerMoney >= uiElement.linkedItem.price && \n                          ownedQuantity < uiElement.linkedItem.maxQuantity;\n        \n        if (uiElement.purchaseButton != null)\n        {\n            uiElement.purchaseButton.interactable = canPurchase;\n        }\n\n        bool canSell = ownedQuantity > 0;\n        if (uiElement.sellButton != null)\n        {\n            uiElement.sellButton.interactable = canSell;\n            uiElement.sellButton.gameObject.SetActive(canSell);\n        }\n    }\n\n    private void UpdateAllItemUI()\n    {\n        foreach (var uiElement in _itemUIElements)\n        {\n            UpdateItemUI(uiElement);\n        }\n    }\n\n    public void OpenShop()\n    {\n        if (_shopPanel != null)\n        {\n            _shopPanel.SetActive(true);\n            _isShopOpen = true;\n            UpdateAllItemUI();\n            Time.timeScale = 0f;\n        }\n    }\n\n    public void CloseShop()\n    {\n        if (_shopPanel != null)\n        {\n            _shopPanel.SetActive(false);\n            _isShopOpen = false;\n            Time.timeScale = 1f;\n        }\n    }\n\n    public void PurchaseItem(ShopItem item)\n    {\n        if (item == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(item.itemName);\n        \n        if (_playerMoney >= item.price && ownedQuantity < item.maxQuantity)\n        {\n            _playerMoney -= item.price;\n            AddItemToInventory(item.itemName, 1);\n            \n            UpdateMoneyDisplay();\n            UpdateAllItemUI();\n            \n            PlaySound(_purchaseSound);\n            OnItemPurchased?.Invoke(item.itemName, 1);\n            OnMoneyChanged?.Invoke(_playerMoney);\n            \n            Debug.Log($\"Purchased {item.itemName} for ${item.price}\");\n        }\n        else\n        {\n            PlaySound(_errorSound);\n            string reason = _playerMoney < item.price ? \"Not enough money!\" : \"Maximum quantity reached!\";\n            Debug.Log($\"Cannot purchase {item.itemName}: {reason}\");\n        }\n    }\n\n    public void SellItem(ShopItem item)\n    {\n        if (item == null) return;\n\n        int ownedQuantity = GetPlayerItemQuantity(item.itemName);\n        \n        if (ownedQuantity > 0)\n        {\n            int sellPrice = Mathf.RoundToInt(item.price * 0.5f);\n            _playerMoney += sellPrice;\n            RemoveItemFromInventory(item.itemName, 1);\n            \n            UpdateMoneyDisplay();\n            UpdateAllItemUI();\n            \n            PlaySound(_sellSound);\n            OnItemSold?.Invoke(item.itemName, 1);\n            OnMoneyChanged?.Invoke(_playerMoney);\n            \n            Debug.Log($\"Sold {item.itemName} for ${sellPrice}\");\n        }\n        else\n        {\n            PlaySound(_errorSound);\n            Debug.Log($\"Cannot sell {item.itemName}: You don't own any!\");\n        }\n    }\n\n    private void AddItemToInventory(string itemName, int quantity)\n    {\n        if (_playerInventory.ContainsKey(itemName))\n        {\n            _playerInventory[itemName] += quantity;\n        }\n        else\n        {\n            _playerInventory[itemName] = quantity;\n        }\n    }\n\n    private void RemoveItemFromInventory(string itemName, int quantity)\n    {\n        if (_playerInventory.ContainsKey(itemName))\n        {\n            _playerInventory[itemName] = Mathf.Max(0, _playerInventory[itemName] - quantity);\n            \n            if (_playerInventory[itemName] == 0)\n            {\n                _playerInventory.Remove(itemName);\n            }\n        }\n    }\n\n    private int GetPlayerItemQuantity(string itemName)\n    {\n        return _playerInventory.ContainsKey(itemName) ? _playerInventory[itemName] : 0;\n    }\n\n    private void UpdateMoneyDisplay()\n    {\n        if (_moneyDisplay != null)\n        {\n            _moneyDisplay.text = \"$\" + _playerMoney.ToString();\n        }\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n\n    public void AddMoney(int amount)\n    {\n        _playerMoney += amount;\n        UpdateMoneyDisplay();\n        OnMoneyChanged?.Invoke(_playerMoney);\n    }\n\n    public bool HasMoney(int amount)\n    {\n        return _playerMoney >= amount;\n    }\n\n    public int GetMoney()\n    {\n        return _playerMoney;\n    }\n\n    public bool HasItem(string itemName, int quantity = 1)\n    {\n        return GetPlayerItemQuantity(itemName) >= quantity;\n    }\n\n    public Dictionary<string, int> GetInventory()\n    {\n        return new Dictionary<string, int>(_playerInventory);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Bicycle\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pedalingSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"brakeForce\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"isPedaling\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_pedaling\",\n      \"trigger\": \"when forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set pedaling state to true\"\n        },\n        {\n          \"action\": \"play pedaling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_pedaling\",\n      \"trigger\": \"when forward input is released\",\n      \"actions\": [\n        {\n          \"action\": \"set pedaling state to false\"\n        },\n        {\n          \"action\": \"stop pedaling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"accelerate_bicycle\",\n      \"trigger\": \"when pedaling is active\",\n      \"actions\": [\n        {\n          \"action\": \"increase current speed toward max speed using acceleration\"\n        },\n        {\n          \"action\": \"move bicycle forward at current speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"coast_bicycle\",\n      \"trigger\": \"when not pedaling and not braking\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce current speed due to friction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake_bicycle\",\n      \"trigger\": \"when brake input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current speed using brake force\"\n        },\n        {\n          \"action\": \"play braking sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_bicycle\",\n      \"trigger\": \"when horizontal input is detected and bicycle is moving\",\n      \"actions\": [\n        {\n          \"action\": \"rotate bicycle left or right based on input at turn speed\"\n        },\n        {\n          \"action\": \"lean bicycle slightly in turn direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_bicycle\",\n      \"trigger\": \"when current speed reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"return bicycle to upright position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Bicycle : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _turnSpeed = 90f;\n    [SerializeField] private float _minSpeedForTurning = 1f;\n    \n    [Header(\"Pedaling Settings\")]\n    [SerializeField] private float _pedalForce = 10f;\n    [SerializeField] private float _pedalCooldown = 0.2f;\n    [SerializeField] private float _pedalDecayRate = 2f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _groundCheckDistance = 1.1f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _gravity = -20f;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _frontWheel;\n    [SerializeField] private Transform _backWheel;\n    [SerializeField] private Transform _pedals;\n    [SerializeField] private Transform _handlebars;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pedalSound;\n    [SerializeField] private AudioClip _wheelSound;\n    \n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    private float _pedalPower;\n    private float _lastPedalTime;\n    private bool _isGrounded;\n    private float _verticalVelocity;\n    private float _wheelRotation;\n    private float _pedalRotation;\n    private Vector3 _moveDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.freezeRotation = true;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdatePedalPower();\n        CheckGrounded();\n        UpdateVisuals();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n        HandleGravity();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.W))\n        {\n            Pedal();\n        }\n        \n        if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.S))\n        {\n            Brake();\n        }\n    }\n    \n    private void Pedal()\n    {\n        if (Time.time - _lastPedalTime >= _pedalCooldown && _isGrounded)\n        {\n            _pedalPower = Mathf.Min(_pedalPower + _pedalForce, _maxSpeed);\n            _lastPedalTime = Time.time;\n            \n            if (_audioSource != null && _pedalSound != null)\n            {\n                _audioSource.PlayOneShot(_pedalSound, 0.5f);\n            }\n        }\n    }\n    \n    private void Brake()\n    {\n        _pedalPower = Mathf.Max(_pedalPower - _deceleration * Time.deltaTime, 0f);\n    }\n    \n    private void UpdatePedalPower()\n    {\n        if (Time.time - _lastPedalTime > _pedalCooldown)\n        {\n            _pedalPower = Mathf.Max(_pedalPower - _pedalDecayRate * Time.deltaTime, 0f);\n        }\n        \n        _currentSpeed = _pedalPower;\n    }\n    \n    private void HandleMovement()\n    {\n        if (!_isGrounded) return;\n        \n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        \n        if (_currentSpeed > _minSpeedForTurning)\n        {\n            float turnAmount = horizontalInput * _turnSpeed * Time.fixedDeltaTime;\n            transform.Rotate(0, turnAmount, 0);\n        }\n        \n        _moveDirection = transform.forward * _currentSpeed;\n        Vector3 targetVelocity = new Vector3(_moveDirection.x, _rigidbody.velocity.y, _moveDirection.z);\n        _rigidbody.velocity = targetVelocity;\n    }\n    \n    private void HandleGravity()\n    {\n        if (!_isGrounded)\n        {\n            _verticalVelocity += _gravity * Time.fixedDeltaTime;\n            Vector3 velocity = _rigidbody.velocity;\n            velocity.y = _verticalVelocity;\n            _rigidbody.velocity = velocity;\n        }\n        else\n        {\n            _verticalVelocity = 0f;\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit hit;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, _groundCheckDistance, _groundLayer);\n        \n        if (_isGrounded && _verticalVelocity < 0)\n        {\n            _verticalVelocity = 0f;\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        float wheelSpeed = _currentSpeed * 50f;\n        _wheelRotation += wheelSpeed * Time.deltaTime;\n        \n        if (_frontWheel != null)\n        {\n            _frontWheel.localRotation = Quaternion.Euler(_wheelRotation, 0, 0);\n        }\n        \n        if (_backWheel != null)\n        {\n            _backWheel.localRotation = Quaternion.Euler(_wheelRotation, 0, 0);\n        }\n        \n        if (_pedals != null && Time.time - _lastPedalTime < _pedalCooldown * 2f)\n        {\n            _pedalRotation += 360f * Time.deltaTime;\n            _pedals.localRotation = Quaternion.Euler(0, 0, _pedalRotation);\n        }\n        \n        if (_handlebars != null)\n        {\n            float steerAngle = Input.GetAxis(\"Horizontal\") * 30f;\n            _handlebars.localRotation = Quaternion.Euler(0, steerAngle, 0);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _wheelSound != null)\n        {\n            if (_currentSpeed > 0.1f && _isGrounded)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _wheelSound;\n                    _audioSource.Play();\n                }\n                \n                _audioSource.pitch = Mathf.Lerp(0.5f, 2f, _currentSpeed / _maxSpeed);\n                _audioSource.volume = Mathf.Lerp(0.1f, 0.8f, _currentSpeed / _maxSpeed);\n            }\n            else\n            {\n                if (_audioSource.isPlaying && _audioSource.clip == _wheelSound)\n                {\n                    _audioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * _groundCheckDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(transform.position, transform.position + _moveDirection.normalized * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SuperSpeedBurst\",\n  \"components\": [\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"burstSpeed\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"burstDuration\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"normalSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_speed_burst\",\n      \"trigger\": \"when space key is pressed and cooldown is finished\",\n      \"actions\": [\n        {\n          \"action\": \"set movement speed to burst speed value\"\n        },\n        {\n          \"action\": \"start burst duration timer\"\n        },\n        {\n          \"action\": \"play speed boost visual effect\"\n        },\n        {\n          \"action\": \"play speed boost sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_speed_burst\",\n      \"trigger\": \"when burst duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"restore movement speed to normal speed value\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"stop speed boost visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_activation_during_cooldown\",\n      \"trigger\": \"when space key is pressed and cooldown is active\",\n      \"actions\": [\n        {\n          \"action\": \"ignore input and display cooldown indicator\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SuperSpeedBurst : MonoBehaviour\n{\n    [Header(\"Speed Settings\")]\n    [SerializeField] private float _speedMultiplier = 3f;\n    [SerializeField] private float _burstDuration = 2f;\n    [SerializeField] private float _cooldownTime = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _activationKey = KeyCode.LeftShift;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _speedTrailEffect;\n    [SerializeField] private GameObject _speedAura;\n    [SerializeField] private Color _speedTintColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSpeedBurstActivated;\n    public UnityEvent OnSpeedBurstDeactivated;\n    public UnityEvent OnCooldownComplete;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _originalSpeed;\n    private bool _isSpeedActive = false;\n    private bool _isOnCooldown = false;\n    private float _burstTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Renderer _renderer;\n    private Color _originalColor;\n    private Camera _playerCamera;\n    private float _originalFOV;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponent<Renderer>();\n        _playerCamera = Camera.main;\n        \n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer != null)\n            _originalColor = _renderer.material.color;\n        \n        if (_playerCamera != null)\n            _originalFOV = _playerCamera.fieldOfView;\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateTimers();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_activationKey) && !_isSpeedActive && !_isOnCooldown)\n        {\n            ActivateSpeedBurst();\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_isSpeedActive)\n        {\n            _burstTimer -= Time.deltaTime;\n            if (_burstTimer <= 0f)\n            {\n                DeactivateSpeedBurst();\n            }\n        }\n        \n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownComplete?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_isSpeedActive && _renderer != null)\n        {\n            float lerpValue = Mathf.PingPong(Time.time * 2f, 1f);\n            _renderer.material.color = Color.Lerp(_originalColor, _speedTintColor, lerpValue * 0.5f);\n        }\n    }\n    \n    public void ActivateSpeedBurst()\n    {\n        if (_isSpeedActive || _isOnCooldown) return;\n        \n        _isSpeedActive = true;\n        _burstTimer = _burstDuration;\n        \n        ApplySpeedBoost();\n        ActivateVisualEffects();\n        PlayActivationSound();\n        \n        OnSpeedBurstActivated?.Invoke();\n    }\n    \n    private void DeactivateSpeedBurst()\n    {\n        if (!_isSpeedActive) return;\n        \n        _isSpeedActive = false;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        RemoveSpeedBoost();\n        DeactivateVisualEffects();\n        PlayDeactivationSound();\n        \n        OnSpeedBurstDeactivated?.Invoke();\n    }\n    \n    private void ApplySpeedBoost()\n    {\n        if (_characterController != null)\n        {\n            // For CharacterController, we'll modify movement in a separate movement script\n            // This component will provide the speed multiplier\n        }\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.drag *= 0.5f; // Reduce drag for smoother movement\n        }\n        \n        // Increase camera FOV for speed effect\n        if (_playerCamera != null)\n        {\n            StartCoroutine(LerpCameraFOV(_originalFOV + 10f, 0.2f));\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.drag /= 0.5f; // Restore original drag\n        }\n        \n        // Restore camera FOV\n        if (_playerCamera != null)\n        {\n            StartCoroutine(LerpCameraFOV(_originalFOV, 0.3f));\n        }\n    }\n    \n    private void ActivateVisualEffects()\n    {\n        if (_speedTrailEffect != null)\n            _speedTrailEffect.Play();\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(true);\n    }\n    \n    private void DeactivateVisualEffects()\n    {\n        if (_speedTrailEffect != null)\n            _speedTrailEffect.Stop();\n        \n        if (_speedAura != null)\n            _speedAura.SetActive(false);\n        \n        if (_renderer != null)\n            _renderer.material.color = _originalColor;\n    }\n    \n    private void PlayActivationSound()\n    {\n        if (_audioSource != null && _activationSound != null)\n        {\n            _audioSource.pitch = Random.Range(0.9f, 1.1f);\n            _audioSource.PlayOneShot(_activationSound);\n        }\n    }\n    \n    private void PlayDeactivationSound()\n    {\n        if (_audioSource != null && _deactivationSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_deactivationSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator LerpCameraFOV(float targetFOV, float duration)\n    {\n        if (_playerCamera == null) yield break;\n        \n        float startFOV = _playerCamera.fieldOfView;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            _playerCamera.fieldOfView = Mathf.Lerp(startFOV, targetFOV, t);\n            yield return null;\n        }\n        \n        _playerCamera.fieldOfView = targetFOV;\n    }\n    \n    public float GetSpeedMultiplier()\n    {\n        return _isSpeedActive ? _speedMultiplier : 1f;\n    }\n    \n    public bool IsSpeedActive()\n    {\n        return _isSpeedActive;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (!_isOnCooldown) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n    \n    public float GetBurstProgress()\n    {\n        if (!_isSpeedActive) return 0f;\n        return _burstTimer / _burstDuration;\n    }\n    \n    private void OnDisable()\n    {\n        if (_isSpeedActive)\n        {\n            DeactivateSpeedBurst();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DamageNumber\",\n  \"components\": [\n    \"TextMeshPro\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"lifetime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_damage_text\",\n      \"trigger\": \"when damage number is created\",\n      \"actions\": [\n        {\n          \"action\": \"set text to display damage amount\"\n        },\n        {\n          \"action\": \"set text color to red for damage\"\n        },\n        {\n          \"action\": \"start floating upward movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"float_upward\",\n      \"trigger\": \"every frame while active\",\n      \"actions\": [\n        {\n          \"action\": \"move upward at float speed\"\n        },\n        {\n          \"action\": \"gradually fade out text opacity\"\n        },\n        {\n          \"action\": \"reduce remaining lifetime\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_when_expired\",\n      \"trigger\": \"when lifetime reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"destroy this damage number object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\npublic class DamageNumber : MonoBehaviour\n{\n    [Header(\"Damage Display\")]\n    [SerializeField] private TextMeshProUGUI _damageText;\n    [SerializeField] private float _damage;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private float _fadeSpeed = 1f;\n    [SerializeField] private float _lifetime = 2f;\n    [SerializeField] private Vector3 _floatDirection = Vector3.up;\n    [SerializeField] private AnimationCurve _scaleCurve = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 1f);\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _criticalColor = Color.red;\n    [SerializeField] private Color _healColor = Color.green;\n    [SerializeField] private float _criticalThreshold = 50f;\n    [SerializeField] private bool _randomizeDirection = true;\n    [SerializeField] private float _randomAngle = 30f;\n    \n    private Vector3 _startPosition;\n    private float _timer;\n    private CanvasGroup _canvasGroup;\n    private RectTransform _rectTransform;\n    private bool _isInitialized;\n    \n    public enum DamageType\n    {\n        Normal,\n        Critical,\n        Heal\n    }\n    \n    private void Awake()\n    {\n        _rectTransform = GetComponent<RectTransform>();\n        _canvasGroup = GetComponent<CanvasGroup>();\n        \n        if (_canvasGroup == null)\n        {\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n        }\n        \n        if (_damageText == null)\n        {\n            _damageText = GetComponent<TextMeshProUGUI>();\n            if (_damageText == null)\n            {\n                _damageText = GetComponentInChildren<TextMeshProUGUI>();\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        if (!_isInitialized)\n        {\n            Initialize(10f, DamageType.Normal);\n        }\n    }\n    \n    public void Initialize(float damage, DamageType damageType = DamageType.Normal)\n    {\n        _damage = damage;\n        _startPosition = transform.position;\n        _timer = 0f;\n        _isInitialized = true;\n        \n        SetupText(damageType);\n        SetupDirection();\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = 1f;\n        }\n        \n        transform.localScale = Vector3.zero;\n    }\n    \n    private void SetupText(DamageType damageType)\n    {\n        if (_damageText == null) return;\n        \n        string displayText = Mathf.Abs(_damage).ToString(\"F0\");\n        Color textColor = _normalColor;\n        \n        switch (damageType)\n        {\n            case DamageType.Critical:\n                displayText = \"CRIT! \" + displayText;\n                textColor = _criticalColor;\n                break;\n            case DamageType.Heal:\n                displayText = \"+\" + displayText;\n                textColor = _healColor;\n                break;\n            case DamageType.Normal:\n                if (_damage >= _criticalThreshold)\n                {\n                    textColor = _criticalColor;\n                }\n                break;\n        }\n        \n        _damageText.text = displayText;\n        _damageText.color = textColor;\n    }\n    \n    private void SetupDirection()\n    {\n        if (_randomizeDirection)\n        {\n            float randomX = Random.Range(-_randomAngle, _randomAngle);\n            float randomY = Random.Range(-_randomAngle * 0.5f, _randomAngle);\n            \n            Vector3 randomDirection = Quaternion.Euler(0, 0, randomX) * _floatDirection;\n            randomDirection.y += randomY * 0.01f;\n            _floatDirection = randomDirection.normalized;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isInitialized) return;\n        \n        _timer += Time.deltaTime;\n        float normalizedTime = _timer / _lifetime;\n        \n        if (normalizedTime >= 1f)\n        {\n            DestroyDamageNumber();\n            return;\n        }\n        \n        UpdatePosition(normalizedTime);\n        UpdateScale(normalizedTime);\n        UpdateAlpha(normalizedTime);\n    }\n    \n    private void UpdatePosition(float normalizedTime)\n    {\n        float movementProgress = _movementCurve.Evaluate(normalizedTime);\n        Vector3 offset = _floatDirection * (_floatSpeed * movementProgress * _timer);\n        transform.position = _startPosition + offset;\n    }\n    \n    private void UpdateScale(float normalizedTime)\n    {\n        float scaleValue = _scaleCurve.Evaluate(normalizedTime);\n        transform.localScale = Vector3.one * scaleValue;\n    }\n    \n    private void UpdateAlpha(float normalizedTime)\n    {\n        if (_canvasGroup == null) return;\n        \n        float alpha = 1f - (normalizedTime * _fadeSpeed);\n        alpha = Mathf.Clamp01(alpha);\n        _canvasGroup.alpha = alpha;\n    }\n    \n    private void DestroyDamageNumber()\n    {\n        if (gameObject != null)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public static DamageNumber Create(Vector3 worldPosition, float damage, DamageType damageType = DamageType.Normal, Transform parent = null)\n    {\n        GameObject damageNumberPrefab = Resources.Load<GameObject>(\"DamageNumber\");\n        \n        if (damageNumberPrefab == null)\n        {\n            GameObject newObj = new GameObject(\"DamageNumber\");\n            Canvas canvas = FindObjectOfType<Canvas>();\n            if (canvas != null)\n            {\n                newObj.transform.SetParent(canvas.transform, false);\n            }\n            \n            TextMeshProUGUI text = newObj.AddComponent<TextMeshProUGUI>();\n            text.text = \"0\";\n            text.fontSize = 24;\n            text.alignment = TextAlignmentOptions.Center;\n            \n            DamageNumber damageNumber = newObj.AddComponent<DamageNumber>();\n            damageNumber._damageText = text;\n            \n            RectTransform rect = newObj.GetComponent<RectTransform>();\n            rect.sizeDelta = new Vector2(100, 50);\n            \n            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPosition);\n            rect.position = screenPos;\n            \n            damageNumber.Initialize(damage, damageType);\n            return damageNumber;\n        }\n        else\n        {\n            GameObject instance = Instantiate(damageNumberPrefab, parent);\n            instance.transform.position = worldPosition;\n            \n            DamageNumber damageNumber = instance.GetComponent<DamageNumber>();\n            if (damageNumber != null)\n            {\n                damageNumber.Initialize(damage, damageType);\n            }\n            \n            return damageNumber;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpeedBoostPickup\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"speedMultiplier\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"boostDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"collect_pickup\",\n      \"trigger\": \"when player touches this pickup\",\n      \"actions\": [\n        {\n          \"action\": \"mark pickup as collected\"\n        },\n        {\n          \"action\": \"increase player movement speed by speed multiplier\"\n        },\n        {\n          \"action\": \"start boost duration timer\"\n        },\n        {\n          \"action\": \"hide pickup visual\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_speed_boost\",\n      \"trigger\": \"when boost duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"restore player movement speed to normal\"\n        },\n        {\n          \"action\": \"destroy pickup object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpeedBoostPickup : MonoBehaviour\n{\n    [Header(\"Speed Boost Settings\")]\n    [SerializeField] private float _speedMultiplier = 2f;\n    [SerializeField] private float _boostDuration = 5f;\n    [SerializeField] private bool _stackable = false;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isPickedUp) return;\n        \n        // Rotate the pickup\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        // Bob up and down\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpeedBoost(other.gameObject);\n            PickupItem();\n        }\n    }\n    \n    private void ApplySpeedBoost(GameObject player)\n    {\n        SpeedBoostEffect boostEffect = player.GetComponent<SpeedBoostEffect>();\n        \n        if (boostEffect == null)\n        {\n            boostEffect = player.AddComponent<SpeedBoostEffect>();\n        }\n        \n        boostEffect.ApplySpeedBoost(_speedMultiplier, _boostDuration, _stackable);\n    }\n    \n    private void PickupItem()\n    {\n        _isPickedUp = true;\n        \n        // Play pickup sound\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn pickup effect\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        // Invoke event\n        OnPickedUp?.Invoke();\n        \n        // Hide visual components\n        Renderer renderer = GetComponent<Renderer>();\n        if (renderer != null) renderer.enabled = false;\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null) collider.enabled = false;\n        \n        // Destroy after sound finishes\n        float destroyDelay = _pickupSound != null ? _pickupSound.length : 0.1f;\n        Destroy(gameObject, destroyDelay);\n    }\n}\n\npublic class SpeedBoostEffect : MonoBehaviour\n{\n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _originalSpeed;\n    private float _currentMultiplier = 1f;\n    private float _boostEndTime;\n    private bool _hasActiveBoost = false;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        // Store original speed from a basic movement script if it exists\n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            _originalSpeed = movement.moveSpeed;\n        }\n        else\n        {\n            _originalSpeed = 5f; // Default fallback speed\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasActiveBoost && Time.time >= _boostEndTime)\n        {\n            RemoveSpeedBoost();\n        }\n    }\n    \n    public void ApplySpeedBoost(float multiplier, float duration, bool stackable)\n    {\n        if (stackable)\n        {\n            _currentMultiplier *= multiplier;\n        }\n        else\n        {\n            _currentMultiplier = Mathf.Max(_currentMultiplier, multiplier);\n        }\n        \n        _boostEndTime = Time.time + duration;\n        _hasActiveBoost = true;\n        \n        UpdateMovementSpeed();\n    }\n    \n    private void UpdateMovementSpeed()\n    {\n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            movement.moveSpeed = _originalSpeed * _currentMultiplier;\n        }\n    }\n    \n    private void RemoveSpeedBoost()\n    {\n        _currentMultiplier = 1f;\n        _hasActiveBoost = false;\n        \n        BasicMovement movement = GetComponent<BasicMovement>();\n        if (movement != null)\n        {\n            movement.moveSpeed = _originalSpeed;\n        }\n    }\n}\n\npublic class BasicMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    public float moveSpeed = 5f;\n    public float jumpForce = 8f;\n    \n    private CharacterController _controller;\n    private Rigidbody _rigidbody;\n    private Vector3 _velocity;\n    private bool _isGrounded;\n    \n    private void Start()\n    {\n        _controller = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n    }\n    \n    private void Update()\n    {\n        if (_controller != null)\n        {\n            HandleCharacterControllerMovement();\n        }\n        else if (_rigidbody != null)\n        {\n            HandleRigidbodyMovement();\n        }\n    }\n    \n    private void HandleCharacterControllerMovement()\n    {\n        _isGrounded = _controller.isGrounded;\n        \n        if (_isGrounded && _velocity.y < 0)\n        {\n            _velocity.y = -2f;\n        }\n        \n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _controller.Move(moveDirection * moveSpeed * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _velocity.y = Mathf.Sqrt(jumpForce * -2f * Physics.gravity.y);\n        }\n        \n        _velocity.y += Physics.gravity.y * Time.deltaTime;\n        _controller.Move(_velocity * Time.deltaTime);\n    }\n    \n    private void HandleRigidbodyMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        Vector3 direction = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (direction.magnitude >= 0.1f)\n        {\n            Vector3 moveDirection = transform.right * horizontal + transform.forward * vertical;\n            _rigidbody.MovePosition(transform.position + moveDirection * moveSpeed * Time.deltaTime);\n        }\n        \n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            _rigidbody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DialogueNPC\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dialogueOptions\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"Hello there!\",\n        \"How can I help you?\",\n        \"Goodbye!\"\n      ]\n    },\n    {\n      \"name\": \"currentDialogueIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isInConversation\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"interactionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"conversationCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"lastInteractionTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_dialogue\",\n      \"trigger\": \"when player enters interaction range and presses interaction key\",\n      \"actions\": [\n        {\n          \"action\": \"set conversation state to active\"\n        },\n        {\n          \"action\": \"display first dialogue option to player\"\n        },\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"record current interaction time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cycle_dialogue\",\n      \"trigger\": \"when in conversation and player presses interaction key again\",\n      \"actions\": [\n        {\n          \"action\": \"advance to next dialogue option\"\n        },\n        {\n          \"action\": \"display current dialogue text\"\n        },\n        {\n          \"action\": \"reset to first option if reached end of dialogue list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_conversation\",\n      \"trigger\": \"when player moves outside interaction range or after cooldown period\",\n      \"actions\": [\n        {\n          \"action\": \"set conversation state to inactive\"\n        },\n        {\n          \"action\": \"hide dialogue display\"\n        },\n        {\n          \"action\": \"reset dialogue index to beginning\"\n        },\n        {\n          \"action\": \"return to idle animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_interaction_prompt\",\n      \"trigger\": \"when player is within interaction range and not in conversation\",\n      \"actions\": [\n        {\n          \"action\": \"display interaction prompt above NPC\"\n        },\n        {\n          \"action\": \"highlight NPC with outline or glow effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_interaction_prompt\",\n      \"trigger\": \"when player moves outside interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"hide interaction prompt\"\n        },\n        {\n          \"action\": \"remove highlight effect from NPC\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class DialogueNPC : MonoBehaviour\n{\n    [System.Serializable]\n    public class DialogueOption\n    {\n        [TextArea(2, 4)]\n        public string optionText;\n        [TextArea(3, 6)]\n        public string responseText;\n        public bool endsConversation;\n        public UnityEvent onOptionSelected;\n    }\n\n    [System.Serializable]\n    public class DialogueSequence\n    {\n        [TextArea(3, 6)]\n        public string initialText;\n        public List<DialogueOption> options = new List<DialogueOption>();\n    }\n\n    [Header(\"NPC Settings\")]\n    [SerializeField] private string _npcName = \"NPC\";\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n\n    [Header(\"Dialogue Content\")]\n    [SerializeField] private List<DialogueSequence> _dialogueSequences = new List<DialogueSequence>();\n    [SerializeField] private int _currentSequenceIndex = 0;\n    [SerializeField] private bool _canRepeatDialogue = true;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _dialogueCanvas;\n    [SerializeField] private Text _npcNameText;\n    [SerializeField] private Text _dialogueText;\n    [SerializeField] private Transform _optionsParent;\n    [SerializeField] private Button _optionButtonPrefab;\n    [SerializeField] private Button _closeButton;\n\n    [Header(\"Interaction Prompt\")]\n    [SerializeField] private Canvas _promptCanvas;\n    [SerializeField] private Text _promptText;\n\n    [Header(\"Events\")]\n    public UnityEvent OnDialogueStart;\n    public UnityEvent OnDialogueEnd;\n\n    private Transform _player;\n    private bool _playerInRange = false;\n    private bool _dialogueActive = false;\n    private List<Button> _currentOptionButtons = new List<Button>();\n\n    private void Start()\n    {\n        InitializeUI();\n        SetupDefaultDialogue();\n    }\n\n    private void Update()\n    {\n        CheckPlayerDistance();\n        HandleInput();\n    }\n\n    private void InitializeUI()\n    {\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(false);\n\n        if (_promptCanvas != null)\n            _promptCanvas.gameObject.SetActive(false);\n\n        if (_closeButton != null)\n            _closeButton.onClick.AddListener(EndDialogue);\n\n        if (_npcNameText != null)\n            _npcNameText.text = _npcName;\n\n        if (_promptText != null)\n            _promptText.text = $\"Press {_interactionKey} to talk\";\n    }\n\n    private void SetupDefaultDialogue()\n    {\n        if (_dialogueSequences.Count == 0)\n        {\n            DialogueSequence defaultSequence = new DialogueSequence();\n            defaultSequence.initialText = \"Hello there! How can I help you?\";\n            \n            DialogueOption option1 = new DialogueOption();\n            option1.optionText = \"Just looking around.\";\n            option1.responseText = \"Feel free to explore! Let me know if you need anything.\";\n            option1.endsConversation = true;\n            \n            DialogueOption option2 = new DialogueOption();\n            option2.optionText = \"What is this place?\";\n            option2.responseText = \"This is a peaceful village where travelers often stop to rest.\";\n            option2.endsConversation = false;\n            \n            defaultSequence.options.Add(option1);\n            defaultSequence.options.Add(option2);\n            _dialogueSequences.Add(defaultSequence);\n        }\n    }\n\n    private void CheckPlayerDistance()\n    {\n        if (_player == null)\n        {\n            GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObj != null)\n                _player = playerObj.transform;\n            return;\n        }\n\n        float distance = Vector3.Distance(transform.position, _player.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange;\n\n        if (_playerInRange && !wasInRange)\n            ShowPrompt();\n        else if (!_playerInRange && wasInRange)\n            HidePrompt();\n    }\n\n    private void HandleInput()\n    {\n        if (_playerInRange && !_dialogueActive && Input.GetKeyDown(_interactionKey))\n        {\n            StartDialogue();\n        }\n    }\n\n    private void ShowPrompt()\n    {\n        if (_promptCanvas != null && !_dialogueActive)\n            _promptCanvas.gameObject.SetActive(true);\n    }\n\n    private void HidePrompt()\n    {\n        if (_promptCanvas != null)\n            _promptCanvas.gameObject.SetActive(false);\n    }\n\n    public void StartDialogue()\n    {\n        if (_dialogueActive || _dialogueSequences.Count == 0)\n            return;\n\n        _dialogueActive = true;\n        HidePrompt();\n\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(true);\n\n        DisplayCurrentSequence();\n        OnDialogueStart?.Invoke();\n\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n\n    private void DisplayCurrentSequence()\n    {\n        if (_currentSequenceIndex >= _dialogueSequences.Count)\n        {\n            if (_canRepeatDialogue)\n                _currentSequenceIndex = 0;\n            else\n            {\n                EndDialogue();\n                return;\n            }\n        }\n\n        DialogueSequence currentSequence = _dialogueSequences[_currentSequenceIndex];\n        \n        if (_dialogueText != null)\n            _dialogueText.text = currentSequence.initialText;\n\n        ClearOptionButtons();\n        CreateOptionButtons(currentSequence.options);\n    }\n\n    private void ClearOptionButtons()\n    {\n        foreach (Button button in _currentOptionButtons)\n        {\n            if (button != null)\n                DestroyImmediate(button.gameObject);\n        }\n        _currentOptionButtons.Clear();\n    }\n\n    private void CreateOptionButtons(List<DialogueOption> options)\n    {\n        if (_optionsParent == null || _optionButtonPrefab == null)\n            return;\n\n        for (int i = 0; i < options.Count; i++)\n        {\n            DialogueOption option = options[i];\n            Button optionButton = Instantiate(_optionButtonPrefab, _optionsParent);\n            \n            Text buttonText = optionButton.GetComponentInChildren<Text>();\n            if (buttonText != null)\n                buttonText.text = option.optionText;\n\n            int optionIndex = i;\n            optionButton.onClick.AddListener(() => SelectOption(optionIndex));\n            \n            _currentOptionButtons.Add(optionButton);\n        }\n    }\n\n    private void SelectOption(int optionIndex)\n    {\n        if (_currentSequenceIndex >= _dialogueSequences.Count)\n            return;\n\n        DialogueSequence currentSequence = _dialogueSequences[_currentSequenceIndex];\n        if (optionIndex >= currentSequence.options.Count)\n            return;\n\n        DialogueOption selectedOption = currentSequence.options[optionIndex];\n        \n        if (_dialogueText != null)\n            _dialogueText.text = selectedOption.responseText;\n\n        selectedOption.onOptionSelected?.Invoke();\n\n        ClearOptionButtons();\n\n        if (selectedOption.endsConversation)\n        {\n            Invoke(nameof(EndDialogue), 2f);\n        }\n        else\n        {\n            _currentSequenceIndex++;\n            Invoke(nameof(DisplayCurrentSequence), 2f);\n        }\n    }\n\n    public void EndDialogue()\n    {\n        if (!_dialogueActive)\n            return;\n\n        _dialogueActive = false;\n        ClearOptionButtons();\n\n        if (_dialogueCanvas != null)\n            _dialogueCanvas.gameObject.SetActive(false);\n\n        if (_playerInRange)\n            ShowPrompt();\n\n        OnDialogueEnd?.Invoke();\n\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n\n    public void SetDialogueSequence(int sequenceIndex)\n    {\n        if (sequenceIndex >= 0 && sequenceIndex < _dialogueSequences.Count)\n            _currentSequenceIndex = sequenceIndex;\n    }\n\n    public void AddDialogueSequence(DialogueSequence newSequence)\n    {\n        _dialogueSequences.Add(newSequence);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n\n    private void OnDisable()\n    {\n        if (_dialogueActive)\n            EndDialogue();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldPickup\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"armorAmount\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"pickupSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"pickupEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"pickup_shield\",\n      \"trigger\": \"when player touches this shield pickup\",\n      \"actions\": [\n        {\n          \"action\": \"add armor amount to player's current armor\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"spawn pickup visual effect at current position\"\n        },\n        {\n          \"action\": \"destroy this shield pickup object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ShieldPickup : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private int _armorAmount = 25;\n    [SerializeField] private int _maxArmor = 100;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent<int> _onArmorAdded;\n    \n    private AudioSource _audioSource;\n    private Vector3 _startPosition;\n    private bool _isPickedUp = false;\n    \n    [System.Serializable]\n    public class PlayerArmor\n    {\n        public int currentArmor;\n        public int maxArmor;\n        \n        public PlayerArmor(int maxArmor)\n        {\n            this.maxArmor = maxArmor;\n            this.currentArmor = 0;\n        }\n        \n        public int AddArmor(int amount)\n        {\n            int oldArmor = currentArmor;\n            currentArmor = Mathf.Clamp(currentArmor + amount, 0, maxArmor);\n            return currentArmor - oldArmor;\n        }\n    }\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n    \n    void Update()\n    {\n        if (_isPickedUp) return;\n        \n        AnimatePickup();\n    }\n    \n    void AnimatePickup()\n    {\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        \n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PlayerArmor playerArmor = other.GetComponent<PlayerArmor>();\n            if (playerArmor == null)\n            {\n                playerArmor = other.gameObject.AddComponent<PlayerArmorComponent>().armor;\n            }\n            \n            int armorAdded = playerArmor.AddArmor(_armorAmount);\n            \n            if (armorAdded > 0)\n            {\n                PickupShield(armorAdded);\n            }\n        }\n    }\n    \n    void PickupShield(int armorAdded)\n    {\n        _isPickedUp = true;\n        \n        if (_pickupEffect != null)\n        {\n            _pickupEffect.Play();\n        }\n        \n        if (_pickupSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        _onArmorAdded?.Invoke(armorAdded);\n        \n        GetComponent<Collider>().enabled = false;\n        GetComponent<Renderer>().enabled = false;\n        \n        Destroy(gameObject, _pickupSound != null ? _pickupSound.length : 0.1f);\n    }\n    \n    public class PlayerArmorComponent : MonoBehaviour\n    {\n        public PlayerArmor armor;\n        \n        void Awake()\n        {\n            armor = new PlayerArmor(100);\n        }\n        \n        public int GetCurrentArmor()\n        {\n            return armor.currentArmor;\n        }\n        \n        public int GetMaxArmor()\n        {\n            return armor.maxArmor;\n        }\n        \n        public void TakeDamage(int damage)\n        {\n            armor.currentArmor = Mathf.Max(0, armor.currentArmor - damage);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PauseMenu\",\n  \"components\": [\n    \"Canvas\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isGamePaused\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"resumeButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"settingsButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"mainMenuButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"quitButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"toggle_pause_menu\",\n      \"trigger\": \"when escape key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"toggle pause menu visibility\"\n        },\n        {\n          \"action\": \"toggle game time scale between zero and one\"\n        },\n        {\n          \"action\": \"toggle cursor lock state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"resume_game\",\n      \"trigger\": \"when resume button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"hide pause menu\"\n        },\n        {\n          \"action\": \"set game time scale to one\"\n        },\n        {\n          \"action\": \"lock cursor to center of screen\"\n        },\n        {\n          \"action\": \"set game paused state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"open_settings\",\n      \"trigger\": \"when settings button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"open settings menu panel\"\n        },\n        {\n          \"action\": \"hide main pause menu options\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_main_menu\",\n      \"trigger\": \"when main menu button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"load main menu scene\"\n        },\n        {\n          \"action\": \"set game time scale to one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"quit_game\",\n      \"trigger\": \"when quit button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"close application\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_menu\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"hide pause menu\"\n        },\n        {\n          \"action\": \"assign button click events\"\n        },\n        {\n          \"action\": \"set initial pause state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Audio;\nusing UnityEngine.SceneManagement;\n\npublic class PauseMenu : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _pauseMenuPanel;\n    [SerializeField] private GameObject _optionsPanel;\n    [SerializeField] private Button _resumeButton;\n    [SerializeField] private Button _optionsButton;\n    [SerializeField] private Button _mainMenuButton;\n    [SerializeField] private Button _quitButton;\n    [SerializeField] private Button _backButton;\n    \n    [Header(\"Audio Options\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    [SerializeField] private Toggle _muteToggle;\n    \n    [Header(\"Graphics Options\")]\n    [SerializeField] private Dropdown _qualityDropdown;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Slider _brightnessSlider;\n    \n    [Header(\"Gameplay Options\")]\n    [SerializeField] private Slider _mouseSensitivitySlider;\n    [SerializeField] private Toggle _invertYToggle;\n    [SerializeField] private Dropdown _difficultyDropdown;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private string _mainMenuSceneName = \"MainMenu\";\n    [SerializeField] private KeyCode _pauseKey = KeyCode.Escape;\n    \n    private bool _isPaused = false;\n    private Resolution[] _resolutions;\n    private float _originalTimeScale;\n    \n    private void Start()\n    {\n        _originalTimeScale = Time.timeScale;\n        InitializeUI();\n        SetupResolutions();\n        LoadSettings();\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_pauseKey))\n        {\n            if (_isPaused)\n                ResumeGame();\n            else\n                PauseGame();\n        }\n    }\n    \n    private void InitializeUI()\n    {\n        if (_resumeButton != null)\n            _resumeButton.onClick.AddListener(ResumeGame);\n        if (_optionsButton != null)\n            _optionsButton.onClick.AddListener(OpenOptions);\n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.AddListener(LoadMainMenu);\n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(QuitGame);\n        if (_backButton != null)\n            _backButton.onClick.AddListener(CloseOptions);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.AddListener(SetMasterVolume);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.AddListener(SetMusicVolume);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.AddListener(SetSFXVolume);\n        if (_muteToggle != null)\n            _muteToggle.onValueChanged.AddListener(SetMute);\n        \n        if (_qualityDropdown != null)\n        {\n            _qualityDropdown.ClearOptions();\n            _qualityDropdown.AddOptions(new System.Collections.Generic.List<string>(QualitySettings.names));\n            _qualityDropdown.value = QualitySettings.GetQualityLevel();\n            _qualityDropdown.onValueChanged.AddListener(SetQuality);\n        }\n        \n        if (_fullscreenToggle != null)\n        {\n            _fullscreenToggle.isOn = Screen.fullScreen;\n            _fullscreenToggle.onValueChanged.AddListener(SetFullscreen);\n        }\n        \n        if (_brightnessSlider != null)\n            _brightnessSlider.onValueChanged.AddListener(SetBrightness);\n        \n        if (_mouseSensitivitySlider != null)\n            _mouseSensitivitySlider.onValueChanged.AddListener(SetMouseSensitivity);\n        if (_invertYToggle != null)\n            _invertYToggle.onValueChanged.AddListener(SetInvertY);\n        \n        if (_difficultyDropdown != null)\n        {\n            _difficultyDropdown.ClearOptions();\n            _difficultyDropdown.AddOptions(new System.Collections.Generic.List<string> { \"Easy\", \"Normal\", \"Hard\" });\n            _difficultyDropdown.onValueChanged.AddListener(SetDifficulty);\n        }\n        \n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(SetResolution);\n    }\n    \n    private void SetupResolutions()\n    {\n        if (_resolutionDropdown == null) return;\n        \n        _resolutions = Screen.resolutions;\n        _resolutionDropdown.ClearOptions();\n        \n        System.Collections.Generic.List<string> options = new System.Collections.Generic.List<string>();\n        int currentResolutionIndex = 0;\n        \n        for (int i = 0; i < _resolutions.Length; i++)\n        {\n            string option = _resolutions[i].width + \" x \" + _resolutions[i].height;\n            options.Add(option);\n            \n            if (_resolutions[i].width == Screen.currentResolution.width &&\n                _resolutions[i].height == Screen.currentResolution.height)\n            {\n                currentResolutionIndex = i;\n            }\n        }\n        \n        _resolutionDropdown.AddOptions(options);\n        _resolutionDropdown.value = currentResolutionIndex;\n        _resolutionDropdown.RefreshShownValue();\n    }\n    \n    public void PauseGame()\n    {\n        _isPaused = true;\n        Time.timeScale = 0f;\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(true);\n        \n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n    }\n    \n    public void ResumeGame()\n    {\n        _isPaused = false;\n        Time.timeScale = _originalTimeScale;\n        \n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n        \n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n    }\n    \n    public void OpenOptions()\n    {\n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(false);\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(true);\n    }\n    \n    public void CloseOptions()\n    {\n        if (_optionsPanel != null)\n            _optionsPanel.SetActive(false);\n        if (_pauseMenuPanel != null)\n            _pauseMenuPanel.SetActive(true);\n    }\n    \n    public void LoadMainMenu()\n    {\n        Time.timeScale = _originalTimeScale;\n        SceneManager.LoadScene(_mainMenuSceneName);\n    }\n    \n    public void QuitGame()\n    {\n        SaveSettings();\n        Application.Quit();\n    }\n    \n    public void SetMasterVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"MasterVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetMusicVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"MusicVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetSFXVolume(float volume)\n    {\n        if (_audioMixer != null)\n            _audioMixer.SetFloat(\"SFXVolume\", Mathf.Log10(volume) * 20);\n    }\n    \n    public void SetMute(bool isMuted)\n    {\n        if (_audioMixer != null)\n        {\n            if (isMuted)\n                _audioMixer.SetFloat(\"MasterVolume\", -80f);\n            else if (_masterVolumeSlider != null)\n                SetMasterVolume(_masterVolumeSlider.value);\n        }\n    }\n    \n    public void SetQuality(int qualityIndex)\n    {\n        QualitySettings.SetQualityLevel(qualityIndex);\n    }\n    \n    public void SetFullscreen(bool isFullscreen)\n    {\n        Screen.fullScreen = isFullscreen;\n    }\n    \n    public void SetResolution(int resolutionIndex)\n    {\n        if (_resolutions != null && resolutionIndex < _resolutions.Length)\n        {\n            Resolution resolution = _resolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);\n        }\n    }\n    \n    public void SetBrightness(float brightness)\n    {\n        RenderSettings.ambientIntensity = brightness;\n    }\n    \n    public void SetMouseSensitivity(float sensitivity)\n    {\n        PlayerPrefs.SetFloat(\"MouseSensitivity\", sensitivity);\n    }\n    \n    public void SetInvertY(bool invert)\n    {\n        PlayerPrefs.SetInt(\"InvertY\", invert ? 1 : 0);\n    }\n    \n    public void SetDifficulty(int difficulty)\n    {\n        PlayerPrefs.SetInt(\"Difficulty\", difficulty);\n    }\n    \n    private void LoadSettings()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            float masterVolume = PlayerPrefs.GetFloat(\"MasterVolume\", 0.75f);\n            _masterVolumeSlider.value = masterVolume;\n            SetMasterVolume(masterVolume);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            float musicVolume = PlayerPrefs.GetFloat(\"MusicVolume\", 0.75f);\n            _musicVolumeSlider.value = musicVolume;\n            SetMusicVolume(musicVolume);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            float sfxVolume = PlayerPrefs.GetFloat(\"SFXVolume\", 0.75f);\n            _sfxVolumeSlider.value = sfxVolume;\n            SetSFXVolume(sfxVolume);\n        }\n        \n        if (_muteToggle != null)\n        {\n            bool isMuted = PlayerPrefs.GetInt(\"Mute\", 0) == 1;\n            _muteToggle.isOn = isMuted;\n            SetMute(isMuted);\n        }\n        \n        if (_brightnessSlider != null)\n        {\n            float brightness = PlayerPrefs.GetFloat(\"Brightness\", 1f);\n            _brightnessSlider.value = brightness;\n            SetBrightness(brightness);\n        }\n        \n        if (_mouseSensitivitySlider != null)\n        {\n            float sensitivity = PlayerPrefs.GetFloat(\"MouseSensitivity\", 2f);\n            _mouseSensitivitySlider.value = sensitivity;\n        }\n        \n        if (_invertYToggle != null)\n        {\n            bool invertY = PlayerPrefs.GetInt(\"InvertY\", 0) == 1;\n            _invertYToggle.isOn = invertY;\n        }\n        \n        if (_difficultyDropdown != null)\n        {\n            int difficulty = PlayerPrefs.GetInt(\"Difficulty\", 1);\n            _difficultyDropdown.value = difficulty;\n        }\n    }\n    \n    private void SaveSettings()\n    {\n        if (_masterVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MasterVolume\", _masterVolumeSlider.value);\n        if (_musicVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MusicVolume\", _musicVolumeSlider.value);\n        if (_sfxVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"SFXVolume\", _sfxVolumeSlider.value);\n        if (_muteToggle != null)\n            PlayerPrefs.SetInt(\"Mute\", _muteToggle.isOn ? 1 : 0);\n        if (_brightnessSlider != null)\n            PlayerPrefs.SetFloat(\"Brightness\", _brightnessSlider.value);\n        if (_mouseSensitivitySlider != null)\n            PlayerPrefs.SetFloat(\"MouseSensitivity\", _mouseSensitivitySlider.value);\n        if (_invertYToggle != null)\n            PlayerPrefs.SetInt(\"InvertY\", _invertYToggle.isOn ? 1 : 0);\n        if (_difficultyDropdown != null)\n            PlayerPrefs.SetInt(\"Difficulty\", _difficultyDropdown.value);\n        \n        PlayerPrefs.Save();\n    }\n    \n    private void OnDestroy()\n    {\n        SaveSettings();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InventoryGrid\",\n  \"components\": [\n    \"Canvas\",\n    \"GridLayoutGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"gridWidth\",\n      \"type\": \"int\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"gridHeight\",\n      \"type\": \"int\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"slotPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"itemDatabase\",\n      \"type\": \"ScriptableObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"maxStackSize\",\n      \"type\": \"int\",\n      \"default\": 99\n    },\n    {\n      \"name\": \"selectedSlot\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_grid\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"create grid slots based on width and height\"\n        },\n        {\n          \"action\": \"assign unique coordinates to each slot\"\n        },\n        {\n          \"action\": \"setup visual layout with proper spacing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"add_item_to_inventory\",\n      \"trigger\": \"when item is added to inventory\",\n      \"actions\": [\n        {\n          \"action\": \"find first available slot that can hold the item\"\n        },\n        {\n          \"action\": \"check if item can stack with existing items\"\n        },\n        {\n          \"action\": \"place item in appropriate slot\"\n        },\n        {\n          \"action\": \"update slot visual display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_item_from_slot\",\n      \"trigger\": \"when item is removed from slot\",\n      \"actions\": [\n        {\n          \"action\": \"clear item data from slot\"\n        },\n        {\n          \"action\": \"update slot visual to show empty state\"\n        },\n        {\n          \"action\": \"return removed item data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_slot_click\",\n      \"trigger\": \"when player clicks on inventory slot\",\n      \"actions\": [\n        {\n          \"action\": \"select the clicked slot\"\n        },\n        {\n          \"action\": \"highlight selected slot visually\"\n        },\n        {\n          \"action\": \"show item tooltip if slot contains item\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drag_item_between_slots\",\n      \"trigger\": \"when player drags item from one slot to another\",\n      \"actions\": [\n        {\n          \"action\": \"validate if target slot can accept the item\"\n        },\n        {\n          \"action\": \"swap items between slots if both contain items\"\n        },\n        {\n          \"action\": \"move item to empty target slot\"\n        },\n        {\n          \"action\": \"update both slot visuals\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stack_items\",\n      \"trigger\": \"when stackable items are combined\",\n      \"actions\": [\n        {\n          \"action\": \"check if items are of same type\"\n        },\n        {\n          \"action\": \"verify total quantity does not exceed stack limit\"\n        },\n        {\n          \"action\": \"combine item quantities in target slot\"\n        },\n        {\n          \"action\": \"clear source slot if fully transferred\"\n        }\n      ]\n    },\n    {\n      \"name\": \"split_item_stack\",\n      \"trigger\": \"when player right clicks on stacked item\",\n      \"actions\": [\n        {\n          \"action\": \"divide item stack into two equal parts\"\n        },\n        {\n          \"action\": \"keep half in original slot\"\n        },\n        {\n          \"action\": \"place other half in cursor for placement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sort_inventory\",\n      \"trigger\": \"when sort button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"group items by type and rarity\"\n        },\n        {\n          \"action\": \"arrange items in organized grid pattern\"\n        },\n        {\n          \"action\": \"stack similar items together when possible\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing System.Collections.Generic;\nusing System;\n\npublic class InventoryGridSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class InventoryItem\n    {\n        public string itemName;\n        public Sprite itemIcon;\n        public int stackSize = 1;\n        public int currentStack = 1;\n        public ItemType itemType;\n        \n        public InventoryItem(string name, Sprite icon, ItemType type, int stack = 1)\n        {\n            itemName = name;\n            itemIcon = icon;\n            itemType = type;\n            stackSize = stack;\n            currentStack = 1;\n        }\n    }\n    \n    public enum ItemType\n    {\n        Consumable,\n        Equipment,\n        Material,\n        Quest\n    }\n    \n    [System.Serializable]\n    public class GridSlot\n    {\n        public InventoryItem item;\n        public bool isEmpty = true;\n        public Vector2Int gridPosition;\n        \n        public void SetItem(InventoryItem newItem)\n        {\n            item = newItem;\n            isEmpty = false;\n        }\n        \n        public void ClearSlot()\n        {\n            item = null;\n            isEmpty = true;\n        }\n    }\n    \n    [Header(\"Grid Settings\")]\n    [SerializeField] private int _gridWidth = 8;\n    [SerializeField] private int _gridHeight = 6;\n    [SerializeField] private float _slotSize = 64f;\n    [SerializeField] private float _slotSpacing = 4f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Transform _gridParent;\n    [SerializeField] private GameObject _slotPrefab;\n    [SerializeField] private Canvas _inventoryCanvas;\n    \n    [Header(\"Drag and Drop\")]\n    [SerializeField] private GameObject _dragPreviewPrefab;\n    [SerializeField] private LayerMask _slotLayerMask = -1;\n    \n    private GridSlot[,] _inventoryGrid;\n    private GameObject[,] _slotObjects;\n    private Camera _uiCamera;\n    private InventorySlotUI _draggedSlot;\n    private GameObject _dragPreview;\n    private bool _isDragging;\n    \n    public event Action<InventoryItem> OnItemAdded;\n    public event Action<InventoryItem> OnItemRemoved;\n    public event Action OnInventoryChanged;\n    \n    private void Start()\n    {\n        _uiCamera = _inventoryCanvas.worldCamera ?? Camera.main;\n        InitializeGrid();\n        CreateGridUI();\n    }\n    \n    private void Update()\n    {\n        HandleDragAndDrop();\n    }\n    \n    private void InitializeGrid()\n    {\n        _inventoryGrid = new GridSlot[_gridWidth, _gridHeight];\n        _slotObjects = new GameObject[_gridWidth, _gridHeight];\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                _inventoryGrid[x, y] = new GridSlot();\n                _inventoryGrid[x, y].gridPosition = new Vector2Int(x, y);\n            }\n        }\n    }\n    \n    private void CreateGridUI()\n    {\n        if (_gridParent == null || _slotPrefab == null) return;\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                GameObject slotObj = Instantiate(_slotPrefab, _gridParent);\n                RectTransform slotRect = slotObj.GetComponent<RectTransform>();\n                \n                float posX = x * (_slotSize + _slotSpacing);\n                float posY = -y * (_slotSize + _slotSpacing);\n                slotRect.anchoredPosition = new Vector2(posX, posY);\n                slotRect.sizeDelta = new Vector2(_slotSize, _slotSize);\n                \n                InventorySlotUI slotUI = slotObj.GetComponent<InventorySlotUI>();\n                if (slotUI == null)\n                    slotUI = slotObj.AddComponent<InventorySlotUI>();\n                \n                slotUI.Initialize(new Vector2Int(x, y), this);\n                _slotObjects[x, y] = slotObj;\n            }\n        }\n    }\n    \n    public bool AddItem(InventoryItem item)\n    {\n        if (item == null) return false;\n        \n        // Try to stack with existing items first\n        if (TryStackItem(item)) return true;\n        \n        // Find empty slot\n        Vector2Int emptySlot = FindEmptySlot();\n        if (emptySlot.x == -1) return false;\n        \n        _inventoryGrid[emptySlot.x, emptySlot.y].SetItem(item);\n        UpdateSlotUI(emptySlot.x, emptySlot.y);\n        \n        OnItemAdded?.Invoke(item);\n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    public bool RemoveItem(Vector2Int gridPos)\n    {\n        if (!IsValidPosition(gridPos) || _inventoryGrid[gridPos.x, gridPos.y].isEmpty)\n            return false;\n        \n        InventoryItem removedItem = _inventoryGrid[gridPos.x, gridPos.y].item;\n        _inventoryGrid[gridPos.x, gridPos.y].ClearSlot();\n        UpdateSlotUI(gridPos.x, gridPos.y);\n        \n        OnItemRemoved?.Invoke(removedItem);\n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    public bool MoveItem(Vector2Int fromPos, Vector2Int toPos)\n    {\n        if (!IsValidPosition(fromPos) || !IsValidPosition(toPos))\n            return false;\n        \n        if (_inventoryGrid[fromPos.x, fromPos.y].isEmpty)\n            return false;\n        \n        // Swap items\n        GridSlot fromSlot = _inventoryGrid[fromPos.x, fromPos.y];\n        GridSlot toSlot = _inventoryGrid[toPos.x, toPos.y];\n        \n        _inventoryGrid[toPos.x, toPos.y] = fromSlot;\n        _inventoryGrid[fromPos.x, fromPos.y] = toSlot;\n        \n        _inventoryGrid[toPos.x, toPos.y].gridPosition = toPos;\n        _inventoryGrid[fromPos.x, fromPos.y].gridPosition = fromPos;\n        \n        UpdateSlotUI(fromPos.x, fromPos.y);\n        UpdateSlotUI(toPos.x, toPos.y);\n        \n        OnInventoryChanged?.Invoke();\n        return true;\n    }\n    \n    private bool TryStackItem(InventoryItem item)\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                GridSlot slot = _inventoryGrid[x, y];\n                if (!slot.isEmpty && slot.item.itemName == item.itemName)\n                {\n                    if (slot.item.currentStack < slot.item.stackSize)\n                    {\n                        int spaceLeft = slot.item.stackSize - slot.item.currentStack;\n                        int toAdd = Mathf.Min(spaceLeft, item.currentStack);\n                        slot.item.currentStack += toAdd;\n                        item.currentStack -= toAdd;\n                        \n                        UpdateSlotUI(x, y);\n                        \n                        if (item.currentStack <= 0)\n                            return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    private Vector2Int FindEmptySlot()\n    {\n        for (int y = 0; y < _gridHeight; y++)\n        {\n            for (int x = 0; x < _gridWidth; x++)\n            {\n                if (_inventoryGrid[x, y].isEmpty)\n                    return new Vector2Int(x, y);\n            }\n        }\n        return new Vector2Int(-1, -1);\n    }\n    \n    private bool IsValidPosition(Vector2Int pos)\n    {\n        return pos.x >= 0 && pos.x < _gridWidth && pos.y >= 0 && pos.y < _gridHeight;\n    }\n    \n    private void UpdateSlotUI(int x, int y)\n    {\n        if (_slotObjects[x, y] != null)\n        {\n            InventorySlotUI slotUI = _slotObjects[x, y].GetComponent<InventorySlotUI>();\n            if (slotUI != null)\n            {\n                slotUI.UpdateSlot(_inventoryGrid[x, y]);\n            }\n        }\n    }\n    \n    private void HandleDragAndDrop()\n    {\n        if (_isDragging && _dragPreview != null)\n        {\n            Vector3 mousePos = Input.mousePosition;\n            _dragPreview.transform.position = mousePos;\n        }\n    }\n    \n    public void StartDrag(InventorySlotUI slotUI)\n    {\n        if (slotUI.GridSlot.isEmpty) return;\n        \n        _draggedSlot = slotUI;\n        _isDragging = true;\n        \n        if (_dragPreviewPrefab != null)\n        {\n            _dragPreview = Instantiate(_dragPreviewPrefab, _inventoryCanvas.transform);\n            Image previewImage = _dragPreview.GetComponent<Image>();\n            if (previewImage != null)\n            {\n                previewImage.sprite = slotUI.GridSlot.item.itemIcon;\n            }\n        }\n    }\n    \n    public void EndDrag(InventorySlotUI targetSlot)\n    {\n        if (!_isDragging || _draggedSlot == null) return;\n        \n        if (targetSlot != null && targetSlot != _draggedSlot)\n        {\n            MoveItem(_draggedSlot.GridPosition, targetSlot.GridPosition);\n        }\n        \n        _isDragging = false;\n        _draggedSlot = null;\n        \n        if (_dragPreview != null)\n        {\n            Destroy(_dragPreview);\n            _dragPreview = null;\n        }\n    }\n    \n    public GridSlot GetSlot(Vector2Int position)\n    {\n        if (!IsValidPosition(position)) return null;\n        return _inventoryGrid[position.x, position.y];\n    }\n    \n    public List<InventoryItem> GetAllItems()\n    {\n        List<InventoryItem> items = new List<InventoryItem>();\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (!_inventoryGrid[x, y].isEmpty)\n                {\n                    items.Add(_inventoryGrid[x, y].item);\n                }\n            }\n        }\n        \n        return items;\n    }\n    \n    public void ClearInventory()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                _inventoryGrid[x, y].ClearSlot();\n                UpdateSlotUI(x, y);\n            }\n        }\n        \n        OnInventoryChanged?.Invoke();\n    }\n}\n\npublic class InventorySlotUI : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler\n{\n    [Header(\"UI Components\")]\n    [SerializeField] private Image _itemIcon;\n    [SerializeField] private Text _stackText;\n    [SerializeField] private Image _background;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    \n    private Vector2Int _gridPosition;\n    private InventoryGridSystem _inventorySystem;\n    private InventoryGridSystem.GridSlot _gridSlot;\n    \n    public Vector2Int GridPosition => _gridPosition;\n    public InventoryGridSystem.GridSlot GridSlot => _gridSlot;\n    \n    public void Initialize(Vector2Int position, InventoryGridSystem inventorySystem)\n    {\n        _gridPosition = position;\n        _inventorySystem = inventorySystem;\n        \n        if (_itemIcon == null) _itemIcon = GetComponentInChildren<Image>();\n        if (_stackText == null) _stackText = GetComponentInChildren<Text>();\n        if (_background == null) _background = GetComponent<Image>();\n        \n        UpdateSlot(_inventorySystem.GetSlot(_gridPosition));\n    }\n    \n    public void UpdateSlot(InventoryGridSystem.GridSlot slot)\n    {\n        _gridSlot = slot;\n        \n        if (slot == null || slot.isEmpty)\n        {\n            if (_itemIcon != null) _itemIcon.sprite = null;\n            if (_itemIcon != null) _itemIcon.color = Color.clear;\n            if (_stackText != null) _stackText.text = \"\";\n        }\n        else\n        {\n            if (_itemIcon != null)\n            {\n                _itemIcon.sprite = slot.item.itemIcon;\n                _itemIcon.color = Color.white;\n            }\n            \n            if (_stackText != null)\n            {\n                _stackText.text = slot.item.currentStack > 1 ? slot.item.currentStack.ToString() : \"\";\n            }\n        }\n    }\n    \n    public void OnPointerDown(PointerEventData eventData)\n    {\n        if (_inventorySystem != null && !_gridSlot.isEmpty)\n        {\n            _inventorySystem.StartDrag(this);\n        }\n    }\n    \n    public void OnPointerUp(PointerEventData eventData)\n    {\n        if (_inventorySystem != null)\n        {\n            _inventorySystem.EndDrag(this);\n        }\n    }\n    \n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        if (_background != null)\n        {\n            _background.color = _highlightColor;\n        }\n    }\n    \n    public void OnPointerExit(PointerEventData eventData)\n    {\n        if (_background != null)\n        {\n            _background.color = _normalColor;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PressurePlate\",\n  \"components\": [\n    \"AudioSource\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"timerDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"rewardPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"clickSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"successSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.gray\"\n    },\n    {\n      \"name\": \"activatedColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.green\"\n    },\n    {\n      \"name\": \"activationCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isWeightApplied\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isTimerRunning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_weight_applied\",\n      \"trigger\": \"when object with weight enters detection area\",\n      \"actions\": [\n        {\n          \"action\": \"set weight applied status to true\"\n        },\n        {\n          \"action\": \"play click sound\"\n        },\n        {\n          \"action\": \"change plate color to green\"\n        },\n        {\n          \"action\": \"start five second timer\"\n        },\n        {\n          \"action\": \"set timer running status to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_weight_removed\",\n      \"trigger\": \"when object with weight leaves detection area\",\n      \"actions\": [\n        {\n          \"action\": \"set weight applied status to false\"\n        },\n        {\n          \"action\": \"change plate color back to normal\"\n        },\n        {\n          \"action\": \"stop timer\"\n        },\n        {\n          \"action\": \"reset timer to zero\"\n        },\n        {\n          \"action\": \"set timer running status to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"timer_countdown\",\n      \"trigger\": \"when timer is running and weight is still applied\",\n      \"actions\": [\n        {\n          \"action\": \"decrease timer by elapsed time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"timer_completion\",\n      \"trigger\": \"when timer reaches zero and weight is still applied\",\n      \"actions\": [\n        {\n          \"action\": \"play success sound\"\n        },\n        {\n          \"action\": \"spawn reward object at plate location\"\n        },\n        {\n          \"action\": \"increment activation count by one\"\n        },\n        {\n          \"action\": \"stop timer\"\n        },\n        {\n          \"action\": \"set timer running status to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _plateRenderer;\n    [SerializeField] private Color _defaultColor = Color.gray;\n    [SerializeField] private Color _pressedColor = Color.green;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _clickSound;\n    [SerializeField] private AudioClip _successSound;\n    \n    [Header(\"Reward Settings\")]\n    [SerializeField] private GameObject _rewardPrefab;\n    [SerializeField] private Transform _rewardSpawnPoint;\n    [SerializeField] private float _activationTime = 5f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private LayerMask _detectionLayers = -1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlatePressed;\n    public UnityEvent OnPlateReleased;\n    public UnityEvent OnActivationComplete;\n    \n    private bool _isPressed = false;\n    private bool _isActivating = false;\n    private int _activationCount = 0;\n    private Coroutine _activationCoroutine;\n    private Collider _plateCollider;\n    private Material _plateMaterial;\n    \n    public int ActivationCount => _activationCount;\n    public bool IsPressed => _isPressed;\n    public bool IsActivating => _isActivating;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetPlateColor(_defaultColor);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_plateRenderer == null)\n            _plateRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_plateCollider == null)\n            _plateCollider = GetComponent<Collider>();\n            \n        if (_rewardSpawnPoint == null)\n            _rewardSpawnPoint = transform;\n            \n        if (_plateRenderer != null)\n        {\n            _plateMaterial = _plateRenderer.material;\n        }\n        \n        if (_plateCollider != null && !_plateCollider.isTrigger)\n        {\n            Debug.LogWarning($\"PressurePlate '{gameObject.name}' collider should be set as trigger!\");\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (ShouldDetectObject(other))\n        {\n            PressPlate();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (ShouldDetectObject(other))\n        {\n            if (!HasAnyValidObjectsOnPlate())\n            {\n                ReleasePlate();\n            }\n        }\n    }\n    \n    private bool ShouldDetectObject(Collider other)\n    {\n        if (string.IsNullOrEmpty(_targetTag))\n            return IsInDetectionLayer(other.gameObject);\n            \n        return other.CompareTag(_targetTag) && IsInDetectionLayer(other.gameObject);\n    }\n    \n    private bool IsInDetectionLayer(GameObject obj)\n    {\n        return (_detectionLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    private bool HasAnyValidObjectsOnPlate()\n    {\n        Collider[] overlapping = Physics.OverlapBox(\n            _plateCollider.bounds.center,\n            _plateCollider.bounds.extents,\n            transform.rotation,\n            _detectionLayers\n        );\n        \n        foreach (var collider in overlapping)\n        {\n            if (ShouldDetectObject(collider))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    private void PressPlate()\n    {\n        if (_isPressed) return;\n        \n        _isPressed = true;\n        SetPlateColor(_pressedColor);\n        PlayClickSound();\n        OnPlatePressed?.Invoke();\n        \n        StartActivationTimer();\n    }\n    \n    private void ReleasePlate()\n    {\n        if (!_isPressed) return;\n        \n        _isPressed = false;\n        _isActivating = false;\n        SetPlateColor(_defaultColor);\n        OnPlateReleased?.Invoke();\n        \n        StopActivationTimer();\n    }\n    \n    private void StartActivationTimer()\n    {\n        if (_activationCoroutine != null)\n            StopCoroutine(_activationCoroutine);\n            \n        _activationCoroutine = StartCoroutine(ActivationCountdown());\n    }\n    \n    private void StopActivationTimer()\n    {\n        if (_activationCoroutine != null)\n        {\n            StopCoroutine(_activationCoroutine);\n            _activationCoroutine = null;\n        }\n    }\n    \n    private IEnumerator ActivationCountdown()\n    {\n        _isActivating = true;\n        yield return new WaitForSeconds(_activationTime);\n        \n        if (_isPressed)\n        {\n            CompleteActivation();\n        }\n        \n        _isActivating = false;\n    }\n    \n    private void CompleteActivation()\n    {\n        _activationCount++;\n        PlaySuccessSound();\n        SpawnReward();\n        OnActivationComplete?.Invoke();\n    }\n    \n    private void SetPlateColor(Color color)\n    {\n        if (_plateMaterial != null)\n        {\n            _plateMaterial.color = color;\n        }\n    }\n    \n    private void PlayClickSound()\n    {\n        if (_audioSource != null && _clickSound != null)\n        {\n            _audioSource.PlayOneShot(_clickSound);\n        }\n    }\n    \n    private void PlaySuccessSound()\n    {\n        if (_audioSource != null && _successSound != null)\n        {\n            _audioSource.PlayOneShot(_successSound);\n        }\n    }\n    \n    private void SpawnReward()\n    {\n        if (_rewardPrefab != null && _rewardSpawnPoint != null)\n        {\n            Vector3 spawnPosition = _rewardSpawnPoint.position + Vector3.up * 0.5f;\n            Instantiate(_rewardPrefab, spawnPosition, _rewardSpawnPoint.rotation);\n        }\n    }\n    \n    public void ResetActivationCount()\n    {\n        _activationCount = 0;\n    }\n    \n    public void ForcePress()\n    {\n        PressPlate();\n    }\n    \n    public void ForceRelease()\n    {\n        ReleasePlate();\n    }\n    \n    private void OnValidate()\n    {\n        if (_activationTime < 0f)\n            _activationTime = 0f;\n    }\n    \n    private void OnDestroy()\n    {\n        StopActivationTimer();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StealthEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"ambushRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"ambushSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"hideTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isHidden\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isAmbushing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"playerTarget\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_hidden\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"make enemy invisible\"\n        },\n        {\n          \"action\": \"set hidden state to true\"\n        },\n        {\n          \"action\": \"find player object in scene\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range and enemy is hidden\",\n      \"actions\": [\n        {\n          \"action\": \"start tracking player position\"\n        },\n        {\n          \"action\": \"begin moving stealthily toward player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stealth_movement\",\n      \"trigger\": \"when tracking player and not ambushing\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at slow stealth speed\"\n        },\n        {\n          \"action\": \"maintain invisibility\"\n        },\n        {\n          \"action\": \"avoid making noise\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prepare_ambush\",\n      \"trigger\": \"when player is within ambush range and enemy is hidden\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"position behind or beside player\"\n        },\n        {\n          \"action\": \"wait for optimal ambush moment\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_ambush\",\n      \"trigger\": \"when ready to ambush and player is in range\",\n      \"actions\": [\n        {\n          \"action\": \"become visible instantly\"\n        },\n        {\n          \"action\": \"set ambushing state to true\"\n        },\n        {\n          \"action\": \"rush toward player at high speed\"\n        },\n        {\n          \"action\": \"play ambush sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attack_player\",\n      \"trigger\": \"when ambushing and reaches player\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player\"\n        },\n        {\n          \"action\": \"play attack animation\"\n        },\n        {\n          \"action\": \"knock player backward\"\n        }\n      ]\n    },\n    {\n      \"name\": \"retreat_after_ambush\",\n      \"trigger\": \"when ambush attack is complete\",\n      \"actions\": [\n        {\n          \"action\": \"move away from player quickly\"\n        },\n        {\n          \"action\": \"become invisible after short delay\"\n        },\n        {\n          \"action\": \"reset to hidden state\"\n        },\n        {\n          \"action\": \"wait before next ambush opportunity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_player\",\n      \"trigger\": \"when player leaves detection range for extended time\",\n      \"actions\": [\n        {\n          \"action\": \"stop tracking player\"\n        },\n        {\n          \"action\": \"return to original hiding position\"\n        },\n        {\n          \"action\": \"reset to patrol state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class StealthEnemy : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _ambushRadius = 3f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private LayerMask _obstacleLayer = 1;\n    \n    [Header(\"Stealth Settings\")]\n    [SerializeField] private float _stealthDuration = 5f;\n    [SerializeField] private float _visibilityTransitionSpeed = 2f;\n    [SerializeField] private float _minAlpha = 0.1f;\n    [SerializeField] private float _maxAlpha = 1f;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _ambushSpeed = 8f;\n    [SerializeField] private float _retreatSpeed = 6f;\n    [SerializeField] private float _circleDistance = 8f;\n    \n    [Header(\"Attack Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _attackRange = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _ambushSound;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _retreatSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnPlayerAttacked;\n    public UnityEvent OnAmbushTriggered;\n    public UnityEvent OnStealthActivated;\n    \n    private enum EnemyState\n    {\n        Patrolling,\n        Stalking,\n        Ambushing,\n        Attacking,\n        Retreating,\n        Cooldown\n    }\n    \n    private EnemyState _currentState = EnemyState.Patrolling;\n    private Transform _player;\n    private Renderer _renderer;\n    private Material _material;\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _lastKnownPlayerPosition;\n    private float _stealthTimer;\n    private float _attackTimer;\n    private float _currentAlpha;\n    private bool _playerInRange;\n    private bool _hasLineOfSight;\n    private float _circleAngle;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _material = new Material(_renderer.material);\n            _renderer.material = _material;\n            _currentAlpha = _maxAlpha;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.freezeRotation = true;\n        \n        _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n        \n        SetStealth(false);\n    }\n    \n    private void Update()\n    {\n        if (_player == null)\n        {\n            _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n            return;\n        }\n        \n        UpdatePlayerDetection();\n        UpdateState();\n        UpdateVisibility();\n        UpdateTimers();\n    }\n    \n    private void UpdatePlayerDetection()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _playerInRange = distanceToPlayer <= _detectionRadius;\n        \n        if (_playerInRange)\n        {\n            _hasLineOfSight = HasLineOfSight(_player.position);\n            if (_hasLineOfSight)\n            {\n                _lastKnownPlayerPosition = _player.position;\n            }\n        }\n        else\n        {\n            _hasLineOfSight = false;\n        }\n    }\n    \n    private void UpdateState()\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Patrolling:\n                HandlePatrolling();\n                break;\n            case EnemyState.Stalking:\n                HandleStalking();\n                break;\n            case EnemyState.Ambushing:\n                HandleAmbushing();\n                break;\n            case EnemyState.Attacking:\n                HandleAttacking();\n                break;\n            case EnemyState.Retreating:\n                HandleRetreating();\n                break;\n            case EnemyState.Cooldown:\n                HandleCooldown();\n                break;\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        if (_playerInRange && _hasLineOfSight)\n        {\n            ChangeState(EnemyState.Stalking);\n            return;\n        }\n        \n        // Simple patrol around original position\n        Vector3 patrolTarget = _originalPosition + new Vector3(\n            Mathf.Sin(Time.time * 0.5f) * 3f,\n            0,\n            Mathf.Cos(Time.time * 0.5f) * 3f\n        );\n        \n        MoveTowards(patrolTarget, _moveSpeed * 0.5f);\n    }\n    \n    private void HandleStalking()\n    {\n        if (!_playerInRange)\n        {\n            ChangeState(EnemyState.Patrolling);\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _ambushRadius)\n        {\n            ChangeState(EnemyState.Ambushing);\n            return;\n        }\n        \n        // Circle around player while maintaining distance\n        _circleAngle += Time.deltaTime * 0.5f;\n        Vector3 circlePosition = _player.position + new Vector3(\n            Mathf.Sin(_circleAngle) * _circleDistance,\n            0,\n            Mathf.Cos(_circleAngle) * _circleDistance\n        );\n        \n        MoveTowards(circlePosition, _moveSpeed);\n        SetStealth(true);\n    }\n    \n    private void HandleAmbushing()\n    {\n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (distanceToPlayer <= _attackRange)\n        {\n            ChangeState(EnemyState.Attacking);\n            return;\n        }\n        \n        // Rush towards player\n        MoveTowards(_player.position, _ambushSpeed);\n        SetStealth(false);\n        \n        // Play ambush sound once\n        if (_audioSource != null && _ambushSound != null && !_audioSource.isPlaying)\n        {\n            _audioSource.PlayOneShot(_ambushSound);\n            OnAmbushTriggered?.Invoke();\n        }\n    }\n    \n    private void HandleAttacking()\n    {\n        if (_attackTimer <= 0f)\n        {\n            PerformAttack();\n            _attackTimer = _attackCooldown;\n            ChangeState(EnemyState.Retreating);\n        }\n    }\n    \n    private void HandleRetreating()\n    {\n        Vector3 retreatDirection = (transform.position - _player.position).normalized;\n        Vector3 retreatTarget = transform.position + retreatDirection * 5f;\n        \n        MoveTowards(retreatTarget, _retreatSpeed);\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer >= _detectionRadius * 0.8f)\n        {\n            ChangeState(EnemyState.Cooldown);\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_stealthTimer <= 0f)\n        {\n            ChangeState(EnemyState.Patrolling);\n        }\n    }\n    \n    private void ChangeState(EnemyState newState)\n    {\n        _currentState = newState;\n        \n        switch (newState)\n        {\n            case EnemyState.Stalking:\n                _stealthTimer = _stealthDuration;\n                OnStealthActivated?.Invoke();\n                break;\n            case EnemyState.Retreating:\n                if (_audioSource != null && _retreatSound != null)\n                {\n                    _audioSource.PlayOneShot(_retreatSound);\n                }\n                break;\n            case EnemyState.Cooldown:\n                _stealthTimer = _stealthDuration * 0.5f;\n                SetStealth(true);\n                break;\n        }\n    }\n    \n    private void MoveTowards(Vector3 target, float speed)\n    {\n        Vector3 direction = (target - transform.position).normalized;\n        direction.y = 0; // Keep movement on horizontal plane\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = new Vector3(direction.x * speed, _rigidbody.velocity.y, direction.z * speed);\n        }\n        else\n        {\n            transform.position += direction * speed * Time.deltaTime;\n        }\n        \n        // Face movement direction\n        if (direction != Vector3.zero)\n        {\n            transform.rotation = Quaternion.LookRotation(direction);\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            // Deal damage to player\n            var playerHealth = _player.GetComponent<MonoBehaviour>();\n            if (playerHealth != null)\n            {\n                OnPlayerAttacked?.Invoke(_attackDamage);\n            }\n            \n            if (_audioSource != null && _attackSound != null)\n            {\n                _audioSource.PlayOneShot(_attackSound);\n            }\n        }\n    }\n    \n    private void SetStealth(bool stealthed)\n    {\n        float targetAlpha = stealthed ? _minAlpha : _maxAlpha;\n        _currentAlpha = Mathf.MoveTowards(_currentAlpha, targetAlpha, _visibilityTransitionSpeed * Time.deltaTime);\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_material != null)\n        {\n            Color color = _material.color;\n            color.a = _currentAlpha;\n            _material.color = color;\n        }\n    }\n    \n    private void UpdateTimers()\n    {\n        if (_stealthTimer > 0f)\n        {\n            _stealthTimer -= Time.deltaTime;\n        }\n        \n        if (_attackTimer > 0f)\n        {\n            _attackTimer -= Time.deltaTime;\n        }\n    }\n    \n    private bool HasLineOfSight(Vector3 targetPosition)\n    {\n        Vector3 direction = targetPosition - transform.position;\n        float distance = direction.magnitude;\n        \n        if (Physics.Raycast(transform.position + Vector3.up * 0.5f, direction.normalized, out RaycastHit hit, distance, _obstacleLayer))\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState == EnemyState.Ambushing)\n        {\n            ChangeState(EnemyState.Attacking);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Detection radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCircle(transform.position, _detectionRadius);\n        \n        // Ambush radius\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCircle(transform.position, _ambushRadius);\n        \n        // Attack range\n        Gizmos.color = Color.magenta;\n        Gizmos.DrawWireCircle(transform.position, _attackRange);\n        \n        // Line of sight\n        if (_player != null && _hasLineOfSight)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position + Vector3.up * 0.5f, _player.position + Vector3.up * 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HealthPickup\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healAmount\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isUsed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"heal_player_on_touch\",\n      \"trigger\": \"when player touches this pickup and pickup has not been used\",\n      \"actions\": [\n        {\n          \"action\": \"increase player health by heal amount\"\n        },\n        {\n          \"action\": \"mark pickup as used\"\n        },\n        {\n          \"action\": \"destroy this pickup object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthPickup : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _healAmount = 25;\n    [SerializeField] private int _maxHealth = 100;\n    \n    [Header(\"Pickup Settings\")]\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private GameObject _pickupEffect;\n    [SerializeField] private float _effectDuration = 2f;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent<int> _onHealthPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        AnimatePickup();\n    }\n    \n    private void AnimatePickup()\n    {\n        if (_rotationSpeed > 0)\n        {\n            transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n        }\n        \n        if (_bobHeight > 0 && _bobSpeed > 0)\n        {\n            float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n            transform.position = new Vector3(transform.position.x, newY, transform.position.z);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            HealPlayer(other.gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            HealPlayer(collision.gameObject);\n        }\n    }\n    \n    private void HealPlayer(GameObject player)\n    {\n        PlayerHealthComponent playerHealth = player.GetComponent<PlayerHealthComponent>();\n        \n        if (playerHealth == null)\n        {\n            playerHealth = player.GetComponentInChildren<PlayerHealthComponent>();\n        }\n        \n        if (playerHealth == null)\n        {\n            playerHealth = player.AddComponent<PlayerHealthComponent>();\n            playerHealth.Initialize(_maxHealth);\n        }\n        \n        int actualHealAmount = playerHealth.Heal(_healAmount);\n        \n        if (actualHealAmount > 0)\n        {\n            PlayPickupEffects();\n            _onHealthPickedUp?.Invoke(actualHealAmount);\n            \n            if (_destroyOnPickup)\n            {\n                if (_audioSource != null && _pickupSound != null)\n                {\n                    _audioSource.PlayOneShot(_pickupSound);\n                    StartCoroutine(DestroyAfterSound());\n                }\n                else\n                {\n                    Destroy(gameObject);\n                }\n            }\n        }\n    }\n    \n    private void PlayPickupEffects()\n    {\n        if (_pickupEffect != null)\n        {\n            GameObject effect = Instantiate(_pickupEffect, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n        \n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n    }\n    \n    private System.Collections.IEnumerator DestroyAfterSound()\n    {\n        GetComponent<Collider>().enabled = false;\n        GetComponent<Renderer>().enabled = false;\n        \n        yield return new WaitForSeconds(_pickupSound.length);\n        Destroy(gameObject);\n    }\n    \n    [System.Serializable]\n    public class PlayerHealthComponent : MonoBehaviour\n    {\n        [SerializeField] private int _currentHealth;\n        [SerializeField] private int _maxHealth = 100;\n        \n        public int CurrentHealth => _currentHealth;\n        public int MaxHealth => _maxHealth;\n        public bool IsFullHealth => _currentHealth >= _maxHealth;\n        \n        private void Start()\n        {\n            if (_currentHealth <= 0)\n            {\n                _currentHealth = _maxHealth;\n            }\n        }\n        \n        public void Initialize(int maxHealth)\n        {\n            _maxHealth = maxHealth;\n            _currentHealth = maxHealth;\n        }\n        \n        public int Heal(int amount)\n        {\n            if (amount <= 0 || IsFullHealth) return 0;\n            \n            int previousHealth = _currentHealth;\n            _currentHealth = Mathf.Min(_currentHealth + amount, _maxHealth);\n            \n            return _currentHealth - previousHealth;\n        }\n        \n        public void TakeDamage(int amount)\n        {\n            if (amount <= 0) return;\n            \n            _currentHealth = Mathf.Max(_currentHealth - amount, 0);\n        }\n        \n        public void SetHealth(int health)\n        {\n            _currentHealth = Mathf.Clamp(health, 0, _maxHealth);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SleepingBed\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isOccupied\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"sleepDuration\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"comfortLevel\",\n      \"type\": \"float\",\n      \"default\": 7.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"allow_player_to_sleep\",\n      \"trigger\": \"when player interacts with bed and bed is not occupied\",\n      \"actions\": [\n        {\n          \"action\": \"mark bed as occupied\"\n        },\n        {\n          \"action\": \"start sleep sequence for player\"\n        },\n        {\n          \"action\": \"fade screen to black\"\n        },\n        {\n          \"action\": \"restore player health and energy over sleep duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wake_up_player\",\n      \"trigger\": \"when sleep duration is complete or player chooses to wake up\",\n      \"actions\": [\n        {\n          \"action\": \"fade screen back to normal\"\n        },\n        {\n          \"action\": \"mark bed as unoccupied\"\n        },\n        {\n          \"action\": \"end sleep sequence\"\n        },\n        {\n          \"action\": \"apply rested status effects to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_interaction_prompt\",\n      \"trigger\": \"when player is near bed and bed is not occupied\",\n      \"actions\": [\n        {\n          \"action\": \"display sleep interaction prompt\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_interaction_prompt\",\n      \"trigger\": \"when player moves away from bed\",\n      \"actions\": [\n        {\n          \"action\": \"hide sleep interaction prompt\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Bed : MonoBehaviour\n{\n    [Header(\"Sleep Settings\")]\n    [SerializeField] private float _sleepDuration = 8f;\n    [SerializeField] private bool _requireNightTime = true;\n    [SerializeField] private float _nightStartHour = 20f;\n    [SerializeField] private float _nightEndHour = 6f;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Renderer _bedRenderer;\n    [SerializeField] private Material _occupiedMaterial;\n    [SerializeField] private Material _defaultMaterial;\n    \n    [Header(\"Sleep Effects\")]\n    [SerializeField] private GameObject _sleepParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sleepSound;\n    [SerializeField] private AudioClip _wakeUpSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSleepStart;\n    public UnityEvent OnSleepEnd;\n    public UnityEvent<float> OnSleepProgress;\n    \n    private bool _isOccupied = false;\n    private bool _isSleeping = false;\n    private float _sleepTimer = 0f;\n    private Transform _sleepingPlayer;\n    private Vector3 _originalPlayerPosition;\n    private bool _playerInRange = false;\n    private Camera _playerCamera;\n    private bool _originalCameraState;\n    \n    [System.Serializable]\n    public class SleepData\n    {\n        public bool isComplete;\n        public float timeSlept;\n        public float restBonus;\n    }\n    \n    private void Start()\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(false);\n            \n        if (_bedRenderer != null && _defaultMaterial != null)\n            _bedRenderer.material = _defaultMaterial;\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInteraction();\n        UpdateSleep();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(_playerTag);\n        if (player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        bool wasInRange = _playerInRange;\n        _playerInRange = distance <= _interactionRange && !_isSleeping;\n        \n        if (_playerInRange && !wasInRange)\n        {\n            ShowInteractionPrompt(true);\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            ShowInteractionPrompt(false);\n        }\n    }\n    \n    private void HandleInteraction()\n    {\n        if (!_playerInRange || !Input.GetKeyDown(_interactionKey)) return;\n        \n        if (!_isSleeping && !_isOccupied)\n        {\n            if (CanSleep())\n            {\n                StartSleep();\n            }\n        }\n        else if (_isSleeping)\n        {\n            WakeUp();\n        }\n    }\n    \n    private bool CanSleep()\n    {\n        if (!_requireNightTime) return true;\n        \n        float currentHour = System.DateTime.Now.Hour;\n        \n        if (_nightStartHour > _nightEndHour)\n        {\n            return currentHour >= _nightStartHour || currentHour <= _nightEndHour;\n        }\n        else\n        {\n            return currentHour >= _nightStartHour && currentHour <= _nightEndHour;\n        }\n    }\n    \n    private void StartSleep()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(_playerTag);\n        if (player == null) return;\n        \n        _sleepingPlayer = player.transform;\n        _originalPlayerPosition = _sleepingPlayer.position;\n        _isSleeping = true;\n        _isOccupied = true;\n        _sleepTimer = 0f;\n        \n        // Position player on bed\n        Vector3 bedPosition = transform.position + Vector3.up * 0.5f;\n        _sleepingPlayer.position = bedPosition;\n        \n        // Disable player movement\n        MonoBehaviour[] playerScripts = _sleepingPlayer.GetComponents<MonoBehaviour>();\n        foreach (var script in playerScripts)\n        {\n            if (script.GetType().Name.Contains(\"Movement\") || \n                script.GetType().Name.Contains(\"Controller\"))\n            {\n                script.enabled = false;\n            }\n        }\n        \n        // Handle camera\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_playerCamera != null)\n        {\n            _originalCameraState = _playerCamera.enabled;\n            _playerCamera.enabled = false;\n        }\n        \n        // Visual and audio feedback\n        UpdateBedVisuals(true);\n        PlaySound(_sleepSound);\n        \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(true);\n            \n        ShowInteractionPrompt(false);\n        OnSleepStart?.Invoke();\n    }\n    \n    private void UpdateSleep()\n    {\n        if (!_isSleeping) return;\n        \n        _sleepTimer += Time.deltaTime;\n        float progress = _sleepTimer / _sleepDuration;\n        \n        OnSleepProgress?.Invoke(progress);\n        \n        if (_sleepTimer >= _sleepDuration)\n        {\n            CompleteSleep();\n        }\n    }\n    \n    private void CompleteSleep()\n    {\n        WakeUp();\n        \n        // Provide sleep benefits\n        SleepData sleepData = new SleepData\n        {\n            isComplete = true,\n            timeSlept = _sleepDuration,\n            restBonus = 1f\n        };\n        \n        // You could send this data to other systems here\n        Debug.Log($\"Sleep completed! Rested for {_sleepDuration} seconds\");\n    }\n    \n    private void WakeUp()\n    {\n        if (!_isSleeping) return;\n        \n        _isSleeping = false;\n        _isOccupied = false;\n        \n        if (_sleepingPlayer != null)\n        {\n            // Re-enable player movement\n            MonoBehaviour[] playerScripts = _sleepingPlayer.GetComponents<MonoBehaviour>();\n            foreach (var script in playerScripts)\n            {\n                if (script.GetType().Name.Contains(\"Movement\") || \n                    script.GetType().Name.Contains(\"Controller\"))\n                {\n                    script.enabled = true;\n                }\n            }\n            \n            // Restore camera\n            if (_playerCamera != null)\n                _playerCamera.enabled = _originalCameraState;\n        }\n        \n        // Visual and audio feedback\n        UpdateBedVisuals(false);\n        PlaySound(_wakeUpSound);\n        \n        if (_sleepParticles != null)\n            _sleepParticles.SetActive(false);\n            \n        _sleepingPlayer = null;\n        OnSleepEnd?.Invoke();\n    }\n    \n    private void UpdateBedVisuals(bool occupied)\n    {\n        if (_bedRenderer == null) return;\n        \n        if (occupied && _occupiedMaterial != null)\n        {\n            _bedRenderer.material = _occupiedMaterial;\n        }\n        else if (!occupied && _defaultMaterial != null)\n        {\n            _bedRenderer.material = _defaultMaterial;\n        }\n    }\n    \n    private void ShowInteractionPrompt(bool show)\n    {\n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(show);\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public bool IsOccupied()\n    {\n        return _isOccupied;\n    }\n    \n    public bool IsSleeping()\n    {\n        return _isSleeping;\n    }\n    \n    public float GetSleepProgress()\n    {\n        return _isSleeping ? _sleepTimer / _sleepDuration : 0f;\n    }\n    \n    public void ForceWakeUp()\n    {\n        if (_isSleeping)\n            WakeUp();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwimmingController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxOxygen\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentOxygen\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"oxygenDepletionRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"oxygenRecoveryRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"swimSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"isUnderwater\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isDrowning\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_water\",\n      \"trigger\": \"when player enters water trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"set underwater status to true\"\n        },\n        {\n          \"action\": \"enable swimming movement controls\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_water\",\n      \"trigger\": \"when player exits water trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"set underwater status to false\"\n        },\n        {\n          \"action\": \"disable swimming movement controls\"\n        },\n        {\n          \"action\": \"restore normal movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"swim_movement\",\n      \"trigger\": \"when underwater and movement input is detected\",\n      \"actions\": [\n        {\n          \"action\": \"move player in input direction at swim speed\"\n        },\n        {\n          \"action\": \"apply water resistance to movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deplete_oxygen\",\n      \"trigger\": \"when underwater every second\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current oxygen by depletion rate\"\n        },\n        {\n          \"action\": \"update oxygen meter display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"recover_oxygen\",\n      \"trigger\": \"when above water surface every second\",\n      \"actions\": [\n        {\n          \"action\": \"increase current oxygen by recovery rate up to maximum\"\n        },\n        {\n          \"action\": \"update oxygen meter display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_drowning\",\n      \"trigger\": \"when current oxygen reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"set drowning status to true\"\n        },\n        {\n          \"action\": \"begin taking drowning damage over time\"\n        },\n        {\n          \"action\": \"display drowning warning effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_drowning\",\n      \"trigger\": \"when drowning and oxygen is restored above zero\",\n      \"actions\": [\n        {\n          \"action\": \"set drowning status to false\"\n        },\n        {\n          \"action\": \"stop taking drowning damage\"\n        },\n        {\n          \"action\": \"remove drowning warning effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class SwimmingController : MonoBehaviour\n{\n    [System.Serializable]\n    public class SwimmingEvents\n    {\n        public UnityEvent OnStartSwimming;\n        public UnityEvent OnStopSwimming;\n        public UnityEvent OnOxygenDepleted;\n        public UnityEvent OnOxygenRestored;\n    }\n\n    [Header(\"Swimming Settings\")]\n    [SerializeField] private float _swimSpeed = 3f;\n    [SerializeField] private float _swimUpForce = 5f;\n    [SerializeField] private float _swimDownForce = 3f;\n    [SerializeField] private float _waterDrag = 5f;\n    [SerializeField] private float _waterAngularDrag = 5f;\n    [SerializeField] private LayerMask _waterLayer = 1;\n\n    [Header(\"Oxygen System\")]\n    [SerializeField] private float _maxOxygen = 100f;\n    [SerializeField] private float _oxygenDepletionRate = 10f;\n    [SerializeField] private float _oxygenRestoreRate = 20f;\n    [SerializeField] private float _lowOxygenThreshold = 25f;\n    [SerializeField] private bool _canDrownWhenOxygenDepleted = true;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Slider _oxygenMeter;\n    [SerializeField] private Image _oxygenFill;\n    [SerializeField] private Color _normalOxygenColor = Color.cyan;\n    [SerializeField] private Color _lowOxygenColor = Color.red;\n    [SerializeField] private GameObject _oxygenUI;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _breathingSound;\n    [SerializeField] private AudioClip _drowningSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _splashEffect;\n\n    [Header(\"Events\")]\n    [SerializeField] private SwimmingEvents _events;\n\n    private Rigidbody _rigidbody;\n    private bool _isSwimming = false;\n    private bool _isUnderwater = false;\n    private float _currentOxygen;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    private bool _isDrowning = false;\n    private float _breathingTimer = 0f;\n    private float _breathingInterval = 2f;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n\n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n        _currentOxygen = _maxOxygen;\n\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n\n        InitializeUI();\n    }\n\n    private void Update()\n    {\n        HandleSwimmingInput();\n        UpdateOxygenSystem();\n        UpdateUI();\n        UpdateEffects();\n    }\n\n    private void HandleSwimmingInput()\n    {\n        if (!_isSwimming) return;\n\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        bool swimUp = Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.E);\n        bool swimDown = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.Q);\n\n        Vector3 swimDirection = Vector3.zero;\n\n        // Horizontal movement\n        swimDirection += transform.right * horizontal;\n        swimDirection += transform.forward * vertical;\n\n        // Vertical movement\n        if (swimUp)\n        {\n            swimDirection += Vector3.up;\n        }\n        else if (swimDown)\n        {\n            swimDirection += Vector3.down;\n        }\n\n        // Apply swimming force\n        if (swimDirection.magnitude > 0.1f)\n        {\n            swimDirection.Normalize();\n            Vector3 force = swimDirection * _swimSpeed;\n            \n            if (swimDirection.y > 0)\n            {\n                force.y *= _swimUpForce / _swimSpeed;\n            }\n            else if (swimDirection.y < 0)\n            {\n                force.y *= _swimDownForce / _swimSpeed;\n            }\n\n            _rigidbody.AddForce(force, ForceMode.Acceleration);\n        }\n    }\n\n    private void UpdateOxygenSystem()\n    {\n        if (_isUnderwater)\n        {\n            _currentOxygen -= _oxygenDepletionRate * Time.deltaTime;\n            _currentOxygen = Mathf.Max(0f, _currentOxygen);\n\n            if (_currentOxygen <= 0f && !_isDrowning)\n            {\n                StartDrowning();\n            }\n\n            // Breathing sound effect\n            _breathingTimer += Time.deltaTime;\n            if (_breathingTimer >= _breathingInterval && _breathingSound != null)\n            {\n                _audioSource.PlayOneShot(_breathingSound, 0.3f);\n                _breathingTimer = 0f;\n            }\n        }\n        else if (_isSwimming && !_isUnderwater)\n        {\n            // Restore oxygen when at surface\n            _currentOxygen += _oxygenRestoreRate * Time.deltaTime;\n            _currentOxygen = Mathf.Min(_maxOxygen, _currentOxygen);\n\n            if (_isDrowning && _currentOxygen > _lowOxygenThreshold)\n            {\n                StopDrowning();\n            }\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_oxygenMeter != null)\n        {\n            _oxygenMeter.value = _currentOxygen / _maxOxygen;\n        }\n\n        if (_oxygenFill != null)\n        {\n            _oxygenFill.color = _currentOxygen <= _lowOxygenThreshold ? _lowOxygenColor : _normalOxygenColor;\n        }\n\n        if (_oxygenUI != null)\n        {\n            _oxygenUI.SetActive(_isSwimming);\n        }\n    }\n\n    private void UpdateEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            if (_isUnderwater && _currentOxygen > 0f)\n            {\n                if (!_bubbleEffect.isPlaying)\n                {\n                    _bubbleEffect.Play();\n                }\n            }\n            else\n            {\n                if (_bubbleEffect.isPlaying)\n                {\n                    _bubbleEffect.Stop();\n                }\n            }\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            StartSwimming();\n            \n            if (_splashEffect != null)\n            {\n                _splashEffect.transform.position = other.ClosestPoint(transform.position);\n                _splashEffect.Play();\n            }\n\n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            // Check if player is fully submerged\n            Vector3 waterSurface = other.bounds.max;\n            waterSurface.x = transform.position.x;\n            waterSurface.z = transform.position.z;\n\n            _isUnderwater = transform.position.y < waterSurface.y - 0.5f;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (IsWaterLayer(other.gameObject.layer))\n        {\n            StopSwimming();\n            _isUnderwater = false;\n\n            if (_splashEffect != null)\n            {\n                _splashEffect.transform.position = other.ClosestPoint(transform.position);\n                _splashEffect.Play();\n            }\n\n            if (_splashSound != null && _audioSource != null)\n            {\n                _audioSource.PlayOneShot(_splashSound);\n            }\n        }\n    }\n\n    private void StartSwimming()\n    {\n        if (_isSwimming) return;\n\n        _isSwimming = true;\n        _rigidbody.drag = _waterDrag;\n        _rigidbody.angularDrag = _waterAngularDrag;\n        \n        _events?.OnStartSwimming?.Invoke();\n    }\n\n    private void StopSwimming()\n    {\n        if (!_isSwimming) return;\n\n        _isSwimming = false;\n        _rigidbody.drag = _originalDrag;\n        _rigidbody.angularDrag = _originalAngularDrag;\n        \n        if (_isDrowning)\n        {\n            StopDrowning();\n        }\n\n        _events?.OnStopSwimming?.Invoke();\n    }\n\n    private void StartDrowning()\n    {\n        _isDrowning = true;\n        \n        if (_drowningSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_drowningSound);\n        }\n\n        _events?.OnOxygenDepleted?.Invoke();\n\n        if (_canDrownWhenOxygenDepleted)\n        {\n            // Apply damage or death logic here\n            Debug.Log(\"Player is drowning!\");\n        }\n    }\n\n    private void StopDrowning()\n    {\n        _isDrowning = false;\n        _events?.OnOxygenRestored?.Invoke();\n    }\n\n    private bool IsWaterLayer(int layer)\n    {\n        return (_waterLayer.value & (1 << layer)) != 0;\n    }\n\n    private void InitializeUI()\n    {\n        if (_oxygenMeter != null)\n        {\n            _oxygenMeter.minValue = 0f;\n            _oxygenMeter.maxValue = 1f;\n            _oxygenMeter.value = 1f;\n        }\n\n        if (_oxygenUI != null)\n        {\n            _oxygenUI.SetActive(false);\n        }\n    }\n\n    public float GetOxygenPercentage()\n    {\n        return _currentOxygen / _maxOxygen;\n    }\n\n    public bool IsSwimming()\n    {\n        return _isSwimming;\n    }\n\n    public bool IsUnderwater()\n    {\n        return _isUnderwater;\n    }\n\n    public bool IsDrowning()\n    {\n        return _isDrowning;\n    }\n\n    public void RestoreOxygen(float amount)\n    {\n        _currentOxygen = Mathf.Min(_maxOxygen, _currentOxygen + amount);\n    }\n\n    public void SetMaxOxygen(float newMaxOxygen)\n    {\n        _maxOxygen = newMaxOxygen;\n        _currentOxygen = Mathf.Min(_currentOxygen, _maxOxygen);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingGem\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    },\n    {\n      \"name\": \"sparkleInterval\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_up_and_down\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"move up and down in a smooth sine wave pattern at float height and float speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_continuously\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emit_sparkles\",\n      \"trigger\": \"every sparkle interval seconds\",\n      \"actions\": [\n        {\n          \"action\": \"emit sparkle particles around the gem\"\n        },\n        {\n          \"action\": \"play sparkle sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_gem\",\n      \"trigger\": \"when player touches this gem\",\n      \"actions\": [\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"emit burst of sparkle particles\"\n        },\n        {\n          \"action\": \"destroy this gem object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class FloatingGem : MonoBehaviour\n{\n    [Header(\"Floating Animation\")]\n    [SerializeField] private float _floatAmplitude = 0.5f;\n    [SerializeField] private float _floatSpeed = 2f;\n    [SerializeField] private bool _randomizeStartPosition = true;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 90, 0);\n    \n    [Header(\"Sparkle Effects\")]\n    [SerializeField] private ParticleSystem _sparkleParticles;\n    [SerializeField] private Light _gemLight;\n    [SerializeField] private float _lightIntensityMin = 0.5f;\n    [SerializeField] private float _lightIntensityMax = 1.5f;\n    [SerializeField] private float _lightPulseSpeed = 3f;\n    \n    [Header(\"Collection\")]\n    [SerializeField] private bool _canBeCollected = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private GameObject _collectEffect;\n    \n    private Vector3 _startPosition;\n    private float _timeOffset;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private bool _isCollected = false;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_randomizeStartPosition)\n        {\n            _timeOffset = Random.Range(0f, Mathf.PI * 2f);\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_sparkleParticles == null)\n        {\n            _sparkleParticles = GetComponentInChildren<ParticleSystem>();\n        }\n        \n        if (_gemLight == null)\n        {\n            _gemLight = GetComponentInChildren<Light>();\n        }\n        \n        if (_sparkleParticles != null)\n        {\n            _sparkleParticles.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isCollected) return;\n        \n        AnimateFloating();\n        AnimateRotation();\n        AnimateLight();\n    }\n    \n    private void AnimateFloating()\n    {\n        float newY = _startPosition.y + Mathf.Sin((Time.time * _floatSpeed) + _timeOffset) * _floatAmplitude;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n    }\n    \n    private void AnimateRotation()\n    {\n        transform.Rotate(_rotationSpeed * Time.deltaTime);\n    }\n    \n    private void AnimateLight()\n    {\n        if (_gemLight != null)\n        {\n            float intensity = Mathf.Lerp(_lightIntensityMin, _lightIntensityMax, \n                (Mathf.Sin(Time.time * _lightPulseSpeed) + 1f) * 0.5f);\n            _gemLight.intensity = intensity;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_canBeCollected || _isCollected) return;\n        \n        if (other.CompareTag(_playerTag))\n        {\n            CollectGem();\n        }\n    }\n    \n    private void CollectGem()\n    {\n        _isCollected = true;\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, transform.rotation);\n        }\n        \n        if (_sparkleParticles != null)\n        {\n            _sparkleParticles.Stop();\n        }\n        \n        StartCoroutine(DestroyAfterSound());\n    }\n    \n    private IEnumerator DestroyAfterSound()\n    {\n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        GetComponent<Collider>().enabled = false;\n        \n        float waitTime = 0f;\n        if (_collectSound != null)\n        {\n            waitTime = _collectSound.length;\n        }\n        \n        yield return new WaitForSeconds(waitTime);\n        \n        Destroy(gameObject);\n    }\n    \n    public void SetFloatParameters(float amplitude, float speed)\n    {\n        _floatAmplitude = amplitude;\n        _floatSpeed = speed;\n    }\n    \n    public void SetRotationSpeed(Vector3 rotationSpeed)\n    {\n        _rotationSpeed = rotationSpeed;\n    }\n    \n    public void EnableCollection(bool enable)\n    {\n        _canBeCollected = enable;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SavePoint\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"saveRadius\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"activationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_approach\",\n      \"trigger\": \"when player enters save point area\",\n      \"actions\": [\n        {\n          \"action\": \"check if save point is not already activated\"\n        },\n        {\n          \"action\": \"activate save point if conditions are met\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_save_point\",\n      \"trigger\": \"when save point becomes activated\",\n      \"actions\": [\n        {\n          \"action\": \"save current game progress to file\"\n        },\n        {\n          \"action\": \"save player position and stats\"\n        },\n        {\n          \"action\": \"save current level state\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"increase visual glow effect\"\n        },\n        {\n          \"action\": \"mark save point as permanently activated\"\n        },\n        {\n          \"action\": \"display save confirmation message to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_visual_state\",\n      \"trigger\": \"continuously while save point exists\",\n      \"actions\": [\n        {\n          \"action\": \"pulse glow effect if activated\"\n        },\n        {\n          \"action\": \"remain dim if not yet activated\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_repeat_visits\",\n      \"trigger\": \"when activated player enters area again\",\n      \"actions\": [\n        {\n          \"action\": \"update save file with current progress\"\n        },\n        {\n          \"action\": \"play gentle confirmation sound\"\n        },\n        {\n          \"action\": \"briefly brighten glow effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System;\n\npublic class SavePoint : MonoBehaviour\n{\n    [Header(\"Save Point Settings\")]\n    [SerializeField] private float _activationRange = 2f;\n    [SerializeField] private bool _autoSave = true;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private string _savePointId = \"\";\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _activeIndicator;\n    [SerializeField] private ParticleSystem _saveEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _saveSound;\n    [SerializeField] private Color _activeColor = Color.green;\n    [SerializeField] private Color _inactiveColor = Color.gray;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerSaved;\n    public UnityEvent OnSavePointActivated;\n    \n    private bool _isActivated = false;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private Transform _player;\n    private Renderer _renderer;\n    private Material _material;\n    private Color _originalColor;\n    \n    [System.Serializable]\n    public class SaveData\n    {\n        public Vector3 position;\n        public Quaternion rotation;\n        public string savePointId;\n        public float timestamp;\n        public int health;\n        public int score;\n        \n        public SaveData(Vector3 pos, Quaternion rot, string id)\n        {\n            position = pos;\n            rotation = rot;\n            savePointId = id;\n            timestamp = Time.time;\n            health = 100;\n            score = 0;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeSavePoint();\n        LoadSavePointState();\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        CheckPlayerProximity();\n        UpdateVisuals();\n    }\n    \n    private void InitializeSavePoint()\n    {\n        if (string.IsNullOrEmpty(_savePointId))\n        {\n            _savePointId = \"SavePoint_\" + transform.position.ToString();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _originalColor = _material.color;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_activeIndicator != null)\n        {\n            _activeIndicator.SetActive(false);\n        }\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n            }\n        }\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        if (_player == null)\n        {\n            GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObject != null)\n            {\n                _player = playerObject.transform;\n            }\n            return;\n        }\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        \n        if (distance <= _activationRange && !_isOnCooldown)\n        {\n            if (_autoSave && !_isActivated)\n            {\n                ActivateSavePoint();\n            }\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_material != null)\n        {\n            Color targetColor = _isActivated ? _activeColor : _inactiveColor;\n            _material.color = Color.Lerp(_material.color, targetColor, Time.deltaTime * 2f);\n        }\n        \n        if (_activeIndicator != null)\n        {\n            _activeIndicator.SetActive(_isActivated);\n        }\n    }\n    \n    public void ActivateSavePoint()\n    {\n        if (_isOnCooldown) return;\n        \n        _isActivated = true;\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n        \n        SavePlayerProgress();\n        PlaySaveEffects();\n        \n        OnSavePointActivated.Invoke();\n        OnPlayerSaved.Invoke();\n    }\n    \n    private void SavePlayerProgress()\n    {\n        if (_player == null) return;\n        \n        SaveData saveData = new SaveData(_player.position, _player.rotation, _savePointId);\n        \n        // Save additional player data if available\n        GameObject playerObject = _player.gameObject;\n        \n        // Try to get health from various possible components\n        var healthComponent = playerObject.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to find health-related fields\n            var fields = healthComponent.GetType().GetFields();\n            foreach (var field in fields)\n            {\n                if (field.Name.ToLower().Contains(\"health\") && field.FieldType == typeof(int))\n                {\n                    saveData.health = (int)field.GetValue(healthComponent);\n                    break;\n                }\n            }\n        }\n        \n        string jsonData = JsonUtility.ToJson(saveData);\n        PlayerPrefs.SetString(\"SavePoint_\" + _savePointId, jsonData);\n        PlayerPrefs.SetString(\"LastSavePoint\", _savePointId);\n        PlayerPrefs.Save();\n        \n        Debug.Log($\"Progress saved at {_savePointId}\");\n    }\n    \n    public void LoadPlayerProgress()\n    {\n        string jsonData = PlayerPrefs.GetString(\"SavePoint_\" + _savePointId, \"\");\n        \n        if (!string.IsNullOrEmpty(jsonData))\n        {\n            SaveData saveData = JsonUtility.FromJson<SaveData>(jsonData);\n            \n            if (_player != null)\n            {\n                // Disable character controller if present\n                var characterController = _player.GetComponent<CharacterController>();\n                if (characterController != null)\n                {\n                    characterController.enabled = false;\n                }\n                \n                _player.position = saveData.position;\n                _player.rotation = saveData.rotation;\n                \n                // Re-enable character controller\n                if (characterController != null)\n                {\n                    characterController.enabled = true;\n                }\n                \n                Debug.Log($\"Progress loaded from {_savePointId}\");\n            }\n        }\n    }\n    \n    private void LoadSavePointState()\n    {\n        string lastSavePoint = PlayerPrefs.GetString(\"LastSavePoint\", \"\");\n        if (lastSavePoint == _savePointId)\n        {\n            _isActivated = true;\n        }\n    }\n    \n    private void PlaySaveEffects()\n    {\n        if (_saveEffect != null)\n        {\n            _saveEffect.Play();\n        }\n        \n        if (_audioSource != null && _saveSound != null)\n        {\n            _audioSource.PlayOneShot(_saveSound);\n        }\n    }\n    \n    public static void LoadLastSavePoint()\n    {\n        string lastSavePointId = PlayerPrefs.GetString(\"LastSavePoint\", \"\");\n        \n        if (!string.IsNullOrEmpty(lastSavePointId))\n        {\n            SavePoint[] savePoints = FindObjectsOfType<SavePoint>();\n            \n            foreach (SavePoint savePoint in savePoints)\n            {\n                if (savePoint._savePointId == lastSavePointId)\n                {\n                    savePoint.LoadPlayerProgress();\n                    break;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_autoSave && !_isOnCooldown)\n        {\n            ActivateSavePoint();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _activeColor;\n        Gizmos.DrawWireSphere(transform.position, _activationRange);\n    }\n    \n    public bool IsActivated => _isActivated;\n    public string SavePointId => _savePointId;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StaminaBar\",\n  \"components\": [\n    \"UI.Slider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"recoveryRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"recoveryDelay\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"isRecovering\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lastUsedTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_stamina_bar\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set slider maximum value to max stamina\"\n        },\n        {\n          \"action\": \"set slider current value to current stamina\"\n        }\n      ]\n    },\n    {\n      \"name\": \"consume_stamina\",\n      \"trigger\": \"when stamina is consumed\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current stamina by consumed amount\"\n        },\n        {\n          \"action\": \"prevent stamina from going below zero\"\n        },\n        {\n          \"action\": \"record current time as last used time\"\n        },\n        {\n          \"action\": \"stop recovery process\"\n        },\n        {\n          \"action\": \"update slider visual to show current stamina\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_recovery\",\n      \"trigger\": \"when enough time has passed since last stamina use\",\n      \"actions\": [\n        {\n          \"action\": \"begin stamina recovery process\"\n        }\n      ]\n    },\n    {\n      \"name\": \"recover_stamina\",\n      \"trigger\": \"when recovering and stamina is not full\",\n      \"actions\": [\n        {\n          \"action\": \"increase current stamina by recovery rate over time\"\n        },\n        {\n          \"action\": \"prevent stamina from exceeding maximum\"\n        },\n        {\n          \"action\": \"update slider visual to show current stamina\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_recovery_when_full\",\n      \"trigger\": \"when stamina reaches maximum during recovery\",\n      \"actions\": [\n        {\n          \"action\": \"stop recovery process\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_visual\",\n      \"trigger\": \"when stamina value changes\",\n      \"actions\": [\n        {\n          \"action\": \"update slider fill to represent current stamina percentage\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class StaminaBar : MonoBehaviour\n{\n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _currentStamina;\n    [SerializeField] private float _staminaRecoveryRate = 20f;\n    [SerializeField] private float _staminaRecoveryDelay = 2f;\n    [SerializeField] private float _lowStaminaThreshold = 20f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Slider _staminaSlider;\n    [SerializeField] private Image _staminaFillImage;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalColor = Color.green;\n    [SerializeField] private Color _lowStaminaColor = Color.red;\n    [SerializeField] private Color _depletedColor = Color.gray;\n    [SerializeField] private bool _hideWhenFull = true;\n    [SerializeField] private float _fadeSpeed = 2f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStaminaDepleted;\n    public UnityEvent OnStaminaLow;\n    public UnityEvent OnStaminaRecovered;\n    \n    private float _lastStaminaUseTime;\n    private bool _isRecovering;\n    private bool _wasLowStamina;\n    private bool _wasDepleted;\n    private float _targetAlpha = 1f;\n    private float _pulseTimer;\n    \n    private void Start()\n    {\n        InitializeStamina();\n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        HandleStaminaRecovery();\n        UpdateUI();\n        HandleVisualEffects();\n    }\n    \n    private void InitializeStamina()\n    {\n        _currentStamina = _maxStamina;\n        _lastStaminaUseTime = Time.time;\n        _isRecovering = false;\n        _wasLowStamina = false;\n        _wasDepleted = false;\n    }\n    \n    private void SetupUI()\n    {\n        if (_staminaSlider != null)\n        {\n            _staminaSlider.maxValue = _maxStamina;\n            _staminaSlider.value = _currentStamina;\n        }\n        \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void HandleStaminaRecovery()\n    {\n        bool shouldRecover = Time.time - _lastStaminaUseTime >= _staminaRecoveryDelay;\n        \n        if (shouldRecover && _currentStamina < _maxStamina)\n        {\n            if (!_isRecovering)\n            {\n                _isRecovering = true;\n            }\n            \n            _currentStamina += _staminaRecoveryRate * Time.deltaTime;\n            _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n            \n            if (_currentStamina >= _maxStamina)\n            {\n                _currentStamina = _maxStamina;\n                _isRecovering = false;\n                OnStaminaRecovered?.Invoke();\n            }\n        }\n        else if (!shouldRecover)\n        {\n            _isRecovering = false;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_staminaSlider != null)\n        {\n            _staminaSlider.value = _currentStamina;\n        }\n        \n        UpdateStaminaColor();\n        UpdateVisibility();\n        CheckStaminaThresholds();\n    }\n    \n    private void UpdateStaminaColor()\n    {\n        if (_staminaFillImage == null) return;\n        \n        Color targetColor;\n        \n        if (_currentStamina <= 0f)\n        {\n            targetColor = _depletedColor;\n        }\n        else if (_currentStamina <= _lowStaminaThreshold)\n        {\n            targetColor = _lowStaminaColor;\n        }\n        else\n        {\n            targetColor = _normalColor;\n        }\n        \n        _staminaFillImage.color = targetColor;\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (!_hideWhenFull)\n        {\n            _targetAlpha = 1f;\n        }\n        else\n        {\n            _targetAlpha = (_currentStamina >= _maxStamina && !_isRecovering) ? 0f : 1f;\n        }\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha, _targetAlpha, _fadeSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        if (!_enablePulseEffect || _staminaFillImage == null) return;\n        \n        if (_currentStamina <= _lowStaminaThreshold && _currentStamina > 0f)\n        {\n            _pulseTimer += Time.deltaTime * _pulseSpeed;\n            float pulseValue = Mathf.Sin(_pulseTimer) * _pulseIntensity;\n            Color currentColor = _staminaFillImage.color;\n            currentColor.a = Mathf.Clamp01(1f + pulseValue);\n            _staminaFillImage.color = currentColor;\n        }\n        else\n        {\n            _pulseTimer = 0f;\n            if (_staminaFillImage.color.a != 1f)\n            {\n                Color currentColor = _staminaFillImage.color;\n                currentColor.a = 1f;\n                _staminaFillImage.color = currentColor;\n            }\n        }\n    }\n    \n    private void CheckStaminaThresholds()\n    {\n        bool isLowStamina = _currentStamina <= _lowStaminaThreshold && _currentStamina > 0f;\n        bool isDepleted = _currentStamina <= 0f;\n        \n        if (isDepleted && !_wasDepleted)\n        {\n            OnStaminaDepleted?.Invoke();\n            _wasDepleted = true;\n        }\n        else if (!isDepleted)\n        {\n            _wasDepleted = false;\n        }\n        \n        if (isLowStamina && !_wasLowStamina)\n        {\n            OnStaminaLow?.Invoke();\n            _wasLowStamina = true;\n        }\n        else if (!isLowStamina)\n        {\n            _wasLowStamina = false;\n        }\n    }\n    \n    public void UseStamina(float amount)\n    {\n        if (amount <= 0f) return;\n        \n        _currentStamina -= amount;\n        _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n        _lastStaminaUseTime = Time.time;\n        _isRecovering = false;\n    }\n    \n    public void RestoreStamina(float amount)\n    {\n        if (amount <= 0f) return;\n        \n        _currentStamina += amount;\n        _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n    }\n    \n    public void SetMaxStamina(float newMaxStamina)\n    {\n        if (newMaxStamina <= 0f) return;\n        \n        float ratio = _currentStamina / _maxStamina;\n        _maxStamina = newMaxStamina;\n        _currentStamina = _maxStamina * ratio;\n        \n        if (_staminaSlider != null)\n        {\n            _staminaSlider.maxValue = _maxStamina;\n        }\n    }\n    \n    public bool HasStamina(float amount)\n    {\n        return _currentStamina >= amount;\n    }\n    \n    public bool CanUseStamina(float amount)\n    {\n        return _currentStamina >= amount;\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _maxStamina > 0f ? _currentStamina / _maxStamina : 0f;\n    }\n    \n    public float GetCurrentStamina()\n    {\n        return _currentStamina;\n    }\n    \n    public float GetMaxStamina()\n    {\n        return _maxStamina;\n    }\n    \n    public bool IsRecovering()\n    {\n        return _isRecovering;\n    }\n    \n    public bool IsEmpty()\n    {\n        return _currentStamina <= 0f;\n    }\n    \n    public bool IsFull()\n    {\n        return _currentStamina >= _maxStamina;\n    }\n    \n    public bool IsLow()\n    {\n        return _currentStamina <= _lowStaminaThreshold;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RecursiveRealityObject\",\n  \"components\": [\n    \"MeshRenderer\",\n    \"AudioSource\",\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"recursionDepth\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"miniatureScale\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"zoomThreshold\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"baseFrequency\",\n      \"type\": \"float\",\n      \"default\": 440.0\n    },\n    {\n      \"name\": \"frequencyMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"renderTexture\",\n      \"type\": \"RenderTexture\",\n      \"default\": null\n    },\n    {\n      \"name\": \"recursiveCamera\",\n      \"type\": \"Camera\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentDepthLevel\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isZoomedIn\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_recursive_scene\",\n      \"trigger\": \"when object starts\",\n      \"actions\": [\n        {\n          \"action\": \"create render texture for miniature scene\"\n        },\n        {\n          \"action\": \"setup recursive camera to capture entire scene\"\n        },\n        {\n          \"action\": \"apply render texture to object material\"\n        },\n        {\n          \"action\": \"create miniature version of entire scene at reduced scale\"\n        },\n        {\n          \"action\": \"position miniature scene inside this object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_zoom_level\",\n      \"trigger\": \"when main camera distance to object changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate camera proximity to object surface\"\n        },\n        {\n          \"action\": \"determine current zoom level based on distance\"\n        },\n        {\n          \"action\": \"update zoom state when threshold is crossed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reveal_recursive_layer\",\n      \"trigger\": \"when zoom level exceeds threshold\",\n      \"actions\": [\n        {\n          \"action\": \"increase recursion depth level\"\n        },\n        {\n          \"action\": \"make miniature scene visible and interactive\"\n        },\n        {\n          \"action\": \"create another recursive object inside miniature scene\"\n        },\n        {\n          \"action\": \"scale down all elements in revealed layer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_depth_musical_note\",\n      \"trigger\": \"when recursion depth level changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate musical frequency based on current depth\"\n        },\n        {\n          \"action\": \"multiply base frequency by depth multiplier\"\n        },\n        {\n          \"action\": \"play musical note at calculated frequency\"\n        },\n        {\n          \"action\": \"adjust note duration based on zoom speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_recursive_texture\",\n      \"trigger\": \"every frame while active\",\n      \"actions\": [\n        {\n          \"action\": \"render current scene state to texture\"\n        },\n        {\n          \"action\": \"apply updated texture to material\"\n        },\n        {\n          \"action\": \"ensure recursive camera captures all scene elements\"\n        },\n        {\n          \"action\": \"maintain texture resolution across recursion levels\"\n        }\n      ]\n    },\n    {\n      \"name\": \"manage_infinite_recursion\",\n      \"trigger\": \"when maximum recursion depth is reached\",\n      \"actions\": [\n        {\n          \"action\": \"loop back to first recursion level\"\n        },\n        {\n          \"action\": \"create seamless transition between deepest and surface level\"\n        },\n        {\n          \"action\": \"reset musical note sequence to beginning\"\n        },\n        {\n          \"action\": \"maintain visual continuity during loop\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class RecursiveRealityObject : MonoBehaviour\n{\n    [System.Serializable]\n    public class RecursionLevel\n    {\n        public Camera levelCamera;\n        public RenderTexture renderTexture;\n        public Transform miniatureScene;\n        public AudioSource audioSource;\n        public float pitch = 1f;\n        public bool isActive = false;\n    }\n\n    [Header(\"Recursion Settings\")]\n    [SerializeField] private int _maxRecursionDepth = 5;\n    [SerializeField] private float _scaleReduction = 0.1f;\n    [SerializeField] private Vector3 _miniatureOffset = Vector3.zero;\n    [SerializeField] private LayerMask _renderLayers = -1;\n\n    [Header(\"Render Settings\")]\n    [SerializeField] private int _textureResolution = 512;\n    [SerializeField] private Material _displayMaterial;\n    [SerializeField] private Renderer _targetRenderer;\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _baseNote;\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchMultiplier = 1.5f;\n    [SerializeField] private float _volumeReduction = 0.7f;\n    [SerializeField] private float _maxAudioDistance = 50f;\n\n    [Header(\"Zoom Detection\")]\n    [SerializeField] private float _zoomThreshold = 5f;\n    [SerializeField] private Transform _viewerTransform;\n    [SerializeField] private bool _autoDetectMainCamera = true;\n\n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.1f;\n    [SerializeField] private bool _enableLOD = true;\n    [SerializeField] private float _lodDistance = 100f;\n\n    private List<RecursionLevel> _recursionLevels = new List<RecursionLevel>();\n    private Transform _originalScene;\n    private float _lastUpdateTime;\n    private int _currentActiveDepth = 0;\n    private bool _isInitialized = false;\n\n    private void Start()\n    {\n        InitializeRecursion();\n    }\n\n    private void Update()\n    {\n        if (!_isInitialized) return;\n\n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            UpdateRecursionLevels();\n            _lastUpdateTime = Time.time;\n        }\n    }\n\n    private void InitializeRecursion()\n    {\n        if (_autoDetectMainCamera && _viewerTransform == null)\n        {\n            Camera mainCam = Camera.main;\n            if (mainCam != null)\n                _viewerTransform = mainCam.transform;\n        }\n\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n\n        if (_displayMaterial == null && _targetRenderer != null)\n            _displayMaterial = _targetRenderer.material;\n\n        CreateOriginalSceneReference();\n        SetupRecursionLevels();\n        _isInitialized = true;\n    }\n\n    private void CreateOriginalSceneReference()\n    {\n        GameObject sceneRoot = new GameObject(\"OriginalSceneReference\");\n        _originalScene = sceneRoot.transform;\n\n        Transform[] allObjects = FindObjectsOfType<Transform>();\n        foreach (Transform obj in allObjects)\n        {\n            if (obj.parent == null && obj != transform && obj != sceneRoot.transform)\n            {\n                GameObject copy = Instantiate(obj.gameObject, _originalScene);\n                copy.name = obj.name + \"_Reference\";\n            }\n        }\n    }\n\n    private void SetupRecursionLevels()\n    {\n        for (int i = 0; i < _maxRecursionDepth; i++)\n        {\n            RecursionLevel level = CreateRecursionLevel(i);\n            _recursionLevels.Add(level);\n        }\n    }\n\n    private RecursionLevel CreateRecursionLevel(int depth)\n    {\n        RecursionLevel level = new RecursionLevel();\n\n        // Create render texture\n        level.renderTexture = new RenderTexture(_textureResolution, _textureResolution, 16);\n        level.renderTexture.name = $\"RecursionTexture_Level_{depth}\";\n\n        // Create camera for this level\n        GameObject cameraObj = new GameObject($\"RecursionCamera_Level_{depth}\");\n        cameraObj.transform.SetParent(transform);\n        level.levelCamera = cameraObj.AddComponent<Camera>();\n        \n        ConfigureCamera(level.levelCamera, depth);\n        level.levelCamera.targetTexture = level.renderTexture;\n\n        // Create miniature scene\n        level.miniatureScene = CreateMiniatureScene(depth);\n\n        // Setup audio\n        level.audioSource = gameObject.AddComponent<AudioSource>();\n        ConfigureAudio(level.audioSource, depth);\n        level.pitch = _basePitch * Mathf.Pow(_pitchMultiplier, depth);\n\n        return level;\n    }\n\n    private void ConfigureCamera(Camera cam, int depth)\n    {\n        Camera mainCam = Camera.main;\n        if (mainCam != null)\n        {\n            cam.fieldOfView = mainCam.fieldOfView;\n            cam.nearClipPlane = mainCam.nearClipPlane;\n            cam.farClipPlane = mainCam.farClipPlane;\n        }\n\n        cam.cullingMask = _renderLayers;\n        cam.enabled = false;\n    }\n\n    private Transform CreateMiniatureScene(int depth)\n    {\n        if (_originalScene == null) return null;\n\n        GameObject miniature = new GameObject($\"MiniatureScene_Level_{depth}\");\n        miniature.transform.SetParent(transform);\n\n        float scale = Mathf.Pow(_scaleReduction, depth + 1);\n        miniature.transform.localScale = Vector3.one * scale;\n        miniature.transform.localPosition = _miniatureOffset * (depth + 1);\n\n        // Copy scene objects\n        foreach (Transform child in _originalScene)\n        {\n            GameObject copy = Instantiate(child.gameObject, miniature.transform);\n            \n            // Ensure recursive objects in miniature also have this script\n            RecursiveRealityObject recursiveScript = copy.GetComponent<RecursiveRealityObject>();\n            if (recursiveScript != null && recursiveScript != this)\n            {\n                recursiveScript._maxRecursionDepth = Mathf.Max(0, _maxRecursionDepth - depth - 1);\n            }\n        }\n\n        return miniature.transform;\n    }\n\n    private void ConfigureAudio(AudioSource audioSource, int depth)\n    {\n        audioSource.clip = _baseNote;\n        audioSource.volume = Mathf.Pow(_volumeReduction, depth);\n        audioSource.pitch = _basePitch * Mathf.Pow(_pitchMultiplier, depth);\n        audioSource.spatialBlend = 1f;\n        audioSource.maxDistance = _maxAudioDistance;\n        audioSource.rolloffMode = AudioRolloffMode.Linear;\n        audioSource.playOnAwake = false;\n        audioSource.loop = true;\n    }\n\n    private void UpdateRecursionLevels()\n    {\n        if (_viewerTransform == null) return;\n\n        float distanceToViewer = Vector3.Distance(_viewerTransform.position, transform.position);\n        int targetDepth = CalculateTargetDepth(distanceToViewer);\n\n        UpdateActiveDepth(targetDepth);\n        UpdateCameraPositions();\n        UpdateRenderTextures();\n        UpdateAudio();\n    }\n\n    private int CalculateTargetDepth(float distance)\n    {\n        if (_enableLOD && distance > _lodDistance)\n            return 0;\n\n        float zoomFactor = _zoomThreshold / Mathf.Max(distance, 0.1f);\n        int depth = Mathf.FloorToInt(Mathf.Log(zoomFactor, 2f));\n        return Mathf.Clamp(depth, 0, _maxRecursionDepth - 1);\n    }\n\n    private void UpdateActiveDepth(int targetDepth)\n    {\n        if (targetDepth == _currentActiveDepth) return;\n\n        // Deactivate old levels\n        for (int i = _currentActiveDepth; i < _recursionLevels.Count; i++)\n        {\n            if (i < _recursionLevels.Count)\n            {\n                _recursionLevels[i].isActive = false;\n                _recursionLevels[i].levelCamera.enabled = false;\n                if (_recursionLevels[i].audioSource.isPlaying)\n                    _recursionLevels[i].audioSource.Stop();\n            }\n        }\n\n        // Activate new levels\n        for (int i = 0; i <= targetDepth && i < _recursionLevels.Count; i++)\n        {\n            _recursionLevels[i].isActive = true;\n            _recursionLevels[i].levelCamera.enabled = true;\n        }\n\n        _currentActiveDepth = targetDepth;\n    }\n\n    private void UpdateCameraPositions()\n    {\n        if (_viewerTransform == null) return;\n\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            if (!_recursionLevels[i].isActive) continue;\n\n            RecursionLevel level = _recursionLevels[i];\n            \n            // Position camera to look at miniature scene\n            Vector3 cameraOffset = _viewerTransform.position - transform.position;\n            float scale = Mathf.Pow(_scaleReduction, i + 1);\n            \n            level.levelCamera.transform.position = level.miniatureScene.position + cameraOffset * scale;\n            level.levelCamera.transform.LookAt(level.miniatureScene.position);\n        }\n    }\n\n    private void UpdateRenderTextures()\n    {\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            if (!_recursionLevels[i].isActive) continue;\n\n            RecursionLevel level = _recursionLevels[i];\n            level.levelCamera.Render();\n\n            // Apply texture to material\n            if (_displayMaterial != null && i == 0)\n            {\n                _displayMaterial.mainTexture = level.renderTexture;\n            }\n        }\n    }\n\n    private void UpdateAudio()\n    {\n        for (int i = 0; i < _recursionLevels.Count; i++)\n        {\n            RecursionLevel level = _recursionLevels[i];\n            \n            if (level.isActive && !level.audioSource.isPlaying)\n            {\n                level.audioSource.Play();\n            }\n            else if (!level.isActive && level.audioSource.isPlaying)\n            {\n                level.audioSource.Stop();\n            }\n        }\n    }\n\n    private void OnDestroy()\n    {\n        foreach (RecursionLevel level in _recursionLevels)\n        {\n            if (level.renderTexture != null)\n            {\n                level.renderTexture.Release();\n                DestroyImmediate(level.renderTexture);\n            }\n        }\n    }\n\n    private void OnValidate()\n    {\n        _maxRecursionDepth = Mathf.Clamp(_maxRecursionDepth, 1, 10);\n        _scaleReduction = Mathf.Clamp01(_scaleReduction);\n        _textureResolution = Mathf.ClosestPowerOfTwo(Mathf.Clamp(_textureResolution, 64, 2048));\n        _updateInterval = Mathf.Max(0.01f, _updateInterval);\n    }\n\n    public void SetRecursionDepth(int depth)\n    {\n        _maxRecursionDepth = Mathf.Clamp(depth, 1, 10);\n        if (_isInitialized)\n        {\n            ClearRecursionLevels();\n            SetupRecursionLevels();\n        }\n    }\n\n    private void ClearRecursionLevels()\n    {\n        foreach (RecursionLevel level in _recursionLevels)\n        {\n            if (level.levelCamera != null)\n                DestroyImmediate(level.levelCamera.gameObject);\n            if (level.renderTexture != null)\n            {\n                level.renderTexture.Release();\n                DestroyImmediate(level.renderTexture);\n            }\n            if (level.miniatureScene != null)\n                DestroyImmediate(level.miniatureScene.gameObject);\n        }\n        _recursionLevels.Clear();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ComputerTerminal\",\n  \"components\": [\n    \"Canvas\",\n    \"Text\",\n    \"Image\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"terminalText\",\n      \"type\": \"string\",\n      \"default\": \"SYSTEM READY\"\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"typingSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.05\n    },\n    {\n      \"name\": \"screenGlow\",\n      \"type\": \"Color\",\n      \"default\": \"green\"\n    },\n    {\n      \"name\": \"maxLines\",\n      \"type\": \"int\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_terminal\",\n      \"trigger\": \"when player interacts with terminal\",\n      \"actions\": [\n        {\n          \"action\": \"turn on screen display\"\n        },\n        {\n          \"action\": \"play startup sound effect\"\n        },\n        {\n          \"action\": \"begin displaying terminal text with typing effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"type_text_effect\",\n      \"trigger\": \"when displaying new text\",\n      \"actions\": [\n        {\n          \"action\": \"reveal characters one by one at typing speed\"\n        },\n        {\n          \"action\": \"play keyboard typing sound for each character\"\n        },\n        {\n          \"action\": \"add cursor blinking effect at end of current line\"\n        }\n      ]\n    },\n    {\n      \"name\": \"scroll_text\",\n      \"trigger\": \"when text exceeds maximum visible lines\",\n      \"actions\": [\n        {\n          \"action\": \"scroll older text upward\"\n        },\n        {\n          \"action\": \"remove oldest lines from display\"\n        },\n        {\n          \"action\": \"keep newest text at bottom of screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"screen_flicker\",\n      \"trigger\": \"randomly while terminal is active\",\n      \"actions\": [\n        {\n          \"action\": \"briefly dim screen brightness\"\n        },\n        {\n          \"action\": \"add slight static visual effect\"\n        },\n        {\n          \"action\": \"play subtle electrical humming sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_terminal\",\n      \"trigger\": \"when player moves away from interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"fade screen to black\"\n        },\n        {\n          \"action\": \"stop all terminal sounds\"\n        },\n        {\n          \"action\": \"reset text display to initial state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ComputerTerminal : MonoBehaviour\n{\n    [Header(\"Terminal Display\")]\n    [SerializeField] private Canvas _terminalCanvas;\n    [SerializeField] private Text _terminalText;\n    [SerializeField] private ScrollRect _scrollRect;\n    [SerializeField] private InputField _inputField;\n    [SerializeField] private Button _submitButton;\n    \n    [Header(\"Terminal Settings\")]\n    [SerializeField] private float _typewriterSpeed = 0.05f;\n    [SerializeField] private int _maxLines = 20;\n    [SerializeField] private string _promptSymbol = \"> \";\n    [SerializeField] private Color _inputColor = Color.green;\n    [SerializeField] private Color _outputColor = Color.white;\n    [SerializeField] private Color _errorColor = Color.red;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private float _interactionDistance = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private GameObject _interactionPrompt;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _keyPressSound;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _errorSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTerminalActivated;\n    public UnityEvent OnTerminalDeactivated;\n    public UnityEvent<string> OnCommandExecuted;\n    \n    private List<string> _terminalLines = new List<string>();\n    private Dictionary<string, System.Action<string[]>> _commands = new Dictionary<string, System.Action<string[]>>();\n    private Transform _player;\n    private bool _isActive = false;\n    private bool _isTyping = false;\n    private Coroutine _typewriterCoroutine;\n    \n    [System.Serializable]\n    public class TerminalCommand\n    {\n        public string command;\n        public string description;\n        public string response;\n    }\n    \n    [Header(\"Predefined Commands\")]\n    [SerializeField] private TerminalCommand[] _predefinedCommands = new TerminalCommand[]\n    {\n        new TerminalCommand { command = \"help\", description = \"Show available commands\", response = \"\" },\n        new TerminalCommand { command = \"clear\", description = \"Clear terminal screen\", response = \"\" },\n        new TerminalCommand { command = \"status\", description = \"Show system status\", response = \"System Status: ONLINE\\nCPU Usage: 23%\\nMemory: 4.2GB/8GB\" },\n        new TerminalCommand { command = \"date\", description = \"Show current date\", response = \"\" },\n        new TerminalCommand { command = \"whoami\", description = \"Show current user\", response = \"User: Administrator\" }\n    };\n    \n    void Start()\n    {\n        InitializeTerminal();\n        SetupCommands();\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        _player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n        \n        if (_submitButton != null)\n            _submitButton.onClick.AddListener(ProcessInput);\n            \n        if (_inputField != null)\n        {\n            _inputField.onEndEdit.AddListener(OnInputEndEdit);\n        }\n    }\n    \n    void Update()\n    {\n        CheckPlayerDistance();\n        HandleInput();\n    }\n    \n    void InitializeTerminal()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        AddLine(\"Terminal initialized...\", _outputColor);\n        AddLine(\"Type 'help' for available commands\", _outputColor);\n        AddLine(\"\", _outputColor);\n    }\n    \n    void SetupCommands()\n    {\n        _commands.Clear();\n        _commands.Add(\"help\", ExecuteHelp);\n        _commands.Add(\"clear\", ExecuteClear);\n        _commands.Add(\"status\", ExecuteStatus);\n        _commands.Add(\"date\", ExecuteDate);\n        _commands.Add(\"whoami\", ExecuteWhoAmI);\n        _commands.Add(\"echo\", ExecuteEcho);\n        _commands.Add(\"exit\", ExecuteExit);\n        \n        foreach (var cmd in _predefinedCommands)\n        {\n            if (!_commands.ContainsKey(cmd.command.ToLower()))\n            {\n                _commands.Add(cmd.command.ToLower(), (args) => ExecuteCustomCommand(cmd));\n            }\n        }\n    }\n    \n    void CheckPlayerDistance()\n    {\n        if (_player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        bool inRange = distance <= _interactionDistance;\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(inRange && !_isActive);\n    }\n    \n    void HandleInput()\n    {\n        if (_player == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _player.position);\n        \n        if (distance <= _interactionDistance && Input.GetKeyDown(_interactionKey))\n        {\n            if (!_isActive)\n                ActivateTerminal();\n            else\n                DeactivateTerminal();\n        }\n        \n        if (_isActive && Input.GetKeyDown(KeyCode.Escape))\n        {\n            DeactivateTerminal();\n        }\n    }\n    \n    void OnInputEndEdit(string input)\n    {\n        if (Input.GetKeyDown(KeyCode.Return) || Input.GetKeyDown(KeyCode.KeypadEnter))\n        {\n            ProcessInput();\n        }\n    }\n    \n    void ActivateTerminal()\n    {\n        _isActive = true;\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(true);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n        \n        if (_inputField != null)\n        {\n            _inputField.Select();\n            _inputField.ActivateInputField();\n        }\n        \n        OnTerminalActivated.Invoke();\n    }\n    \n    void DeactivateTerminal()\n    {\n        _isActive = false;\n        \n        if (_terminalCanvas != null)\n            _terminalCanvas.gameObject.SetActive(false);\n            \n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n        \n        OnTerminalDeactivated.Invoke();\n    }\n    \n    void ProcessInput()\n    {\n        if (_inputField == null || string.IsNullOrEmpty(_inputField.text.Trim()) || _isTyping)\n            return;\n            \n        string input = _inputField.text.Trim();\n        AddLine(_promptSymbol + input, _inputColor);\n        \n        PlaySound(_enterSound);\n        \n        string[] parts = input.ToLower().Split(' ');\n        string command = parts[0];\n        \n        if (_commands.ContainsKey(command))\n        {\n            _commands[command](parts);\n            OnCommandExecuted.Invoke(input);\n        }\n        else\n        {\n            AddLine($\"Command '{command}' not recognized. Type 'help' for available commands.\", _errorColor);\n            PlaySound(_errorSound);\n        }\n        \n        _inputField.text = \"\";\n        _inputField.Select();\n        _inputField.ActivateInputField();\n    }\n    \n    void AddLine(string text, Color color)\n    {\n        if (_isTyping && _typewriterCoroutine != null)\n        {\n            StopCoroutine(_typewriterCoroutine);\n            _isTyping = false;\n        }\n        \n        _terminalLines.Add($\"<color=#{ColorUtility.ToHtmlStringRGB(color)}>{text}</color>\");\n        \n        while (_terminalLines.Count > _maxLines)\n        {\n            _terminalLines.RemoveAt(0);\n        }\n        \n        if (_typewriterSpeed > 0)\n        {\n            _typewriterCoroutine = StartCoroutine(TypewriterEffect());\n        }\n        else\n        {\n            UpdateTerminalDisplay();\n        }\n    }\n    \n    void AddLineWithTypewriter(string text, Color color)\n    {\n        _typewriterCoroutine = StartCoroutine(TypewriterLine(text, color));\n    }\n    \n    IEnumerator TypewriterLine(string text, Color color)\n    {\n        _isTyping = true;\n        string coloredText = $\"<color=#{ColorUtility.ToHtmlStringRGB(color)}>\";\n        _terminalLines.Add(coloredText);\n        \n        for (int i = 0; i < text.Length; i++)\n        {\n            _terminalLines[_terminalLines.Count - 1] = coloredText + text.Substring(0, i + 1) + \"</color>\";\n            UpdateTerminalDisplay();\n            \n            if (_keyPressSound != null && i % 3 == 0)\n                PlaySound(_keyPressSound);\n                \n            yield return new WaitForSeconds(_typewriterSpeed);\n        }\n        \n        _isTyping = false;\n    }\n    \n    IEnumerator TypewriterEffect()\n    {\n        _isTyping = true;\n        yield return new WaitForSeconds(_typewriterSpeed);\n        UpdateTerminalDisplay();\n        _isTyping = false;\n    }\n    \n    void UpdateTerminalDisplay()\n    {\n        if (_terminalText != null)\n        {\n            _terminalText.text = string.Join(\"\\n\", _terminalLines);\n            \n            if (_scrollRect != null)\n            {\n                Canvas.ForceUpdateCanvases();\n                _scrollRect.verticalNormalizedPosition = 0f;\n            }\n        }\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    // Command Implementations\n    void ExecuteHelp(string[] args)\n    {\n        AddLine(\"Available Commands:\", _outputColor);\n        AddLine(\"==================\", _outputColor);\n        \n        foreach (var cmd in _predefinedCommands)\n        {\n            AddLine($\"{cmd.command.PadRight(12)} - {cmd.description}\", _outputColor);\n        }\n        \n        AddLine(\"echo [text]  - Echo text back\", _outputColor);\n        AddLine(\"exit         - Close terminal\", _outputColor);\n    }\n    \n    void ExecuteClear(string[] args)\n    {\n        _terminalLines.Clear();\n        UpdateTerminalDisplay();\n    }\n    \n    void ExecuteStatus(string[] args)\n    {\n        var statusCmd = System.Array.Find(_predefinedCommands, cmd => cmd.command == \"status\");\n        if (statusCmd != null && !string.IsNullOrEmpty(statusCmd.response))\n        {\n            string[] lines = statusCmd.response.Split('\\n');\n            foreach (string line in lines)\n            {\n                AddLine(line, _outputColor);\n            }\n        }\n    }\n    \n    void ExecuteDate(string[] args)\n    {\n        AddLine(System.DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), _outputColor);\n    }\n    \n    void ExecuteWhoAmI(string[] args)\n    {\n        var whoamiCmd = System.Array.Find(_predefinedCommands, cmd => cmd.command == \"whoami\");\n        if (whoamiCmd != null && !string.IsNullOrEmpty(whoamiCmd.response))\n        {\n            AddLine(whoamiCmd.response, _outputColor);\n        }\n    }\n    \n    void ExecuteEcho(string[] args)\n    {\n        if (args.Length > 1)\n        {\n            string echoText = string.Join(\" \", args, 1, args.Length - 1);\n            AddLine(echoText, _outputColor);\n        }\n        else\n        {\n            AddLine(\"Usage: echo [text]\", _errorColor);\n        }\n    }\n    \n    void ExecuteExit(string[] args)\n    {\n        AddLine(\"Closing terminal...\", _outputColor);\n        StartCoroutine(DelayedDeactivate());\n    }\n    \n    void ExecuteCustomCommand(TerminalCommand cmd)\n    {\n        if (!string.IsNullOrEmpty(cmd.response))\n        {\n            string[] lines = cmd.response.Split('\\n');\n            foreach (string line in lines)\n            {\n                AddLine(line, _outputColor);\n            }\n        }\n    }\n    \n    IEnumerator DelayedDeactivate()\n    {\n        yield return new WaitForSeconds(1f);\n        DeactivateTerminal();\n    }\n    \n    public void AddCustomCommand(string command, string description, string response)\n    {\n        var newCommand = new TerminalCommand\n        {\n            command = command.ToLower(),\n            description = description,\n            response = response\n        };\n        \n        _commands[command.ToLower()] = (args) => ExecuteCustomCommand(newCommand);\n    }\n    \n    public void ExecuteCommand(string commandLine)\n    {\n        if (_inputField != null)\n        {\n            _inputField.text = commandLine;\n            ProcessInput();\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _interactionDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WindZone\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"windForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"windDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    },\n    {\n      \"name\": \"affectRigidbodies\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"affectParticles\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"push_rigidbody_objects\",\n      \"trigger\": \"when rigidbody object enters wind zone\",\n      \"actions\": [\n        {\n          \"action\": \"apply continuous force to rigidbody in wind direction with wind force strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_pushing_rigidbody\",\n      \"trigger\": \"when rigidbody object exits wind zone\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying wind force to the rigidbody\"\n        }\n      ]\n    },\n    {\n      \"name\": \"affect_particle_systems\",\n      \"trigger\": \"when particle system enters wind zone\",\n      \"actions\": [\n        {\n          \"action\": \"apply wind force to particles in the specified direction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class WindZone : MonoBehaviour\n{\n    [Header(\"Wind Properties\")]\n    [SerializeField] private float _windStrength = 10f;\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private bool _normalizeDirection = true;\n    \n    [Header(\"Wind Variation\")]\n    [SerializeField] private bool _enableTurbulence = true;\n    [SerializeField] private float _turbulenceStrength = 2f;\n    [SerializeField] private float _turbulenceFrequency = 1f;\n    [SerializeField] private bool _enableGustiness = false;\n    [SerializeField] private float _gustStrength = 5f;\n    [SerializeField] private float _gustFrequency = 0.5f;\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _useColliderBounds = true;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectParticles = true;\n    \n    [Header(\"Force Application\")]\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    [SerializeField] private bool _useDistanceFalloff = true;\n    [SerializeField] private AnimationCurve _falloffCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showGizmos = true;\n    [SerializeField] private Color _gizmoColor = Color.cyan;\n    \n    private Collider _zoneCollider;\n    private List<Rigidbody> _affectedRigidbodies = new List<Rigidbody>();\n    private List<ParticleSystem> _affectedParticles = new List<ParticleSystem>();\n    private Vector3 _normalizedDirection;\n    private float _turbulenceOffset;\n    private float _gustOffset;\n    \n    private void Start()\n    {\n        _zoneCollider = GetComponent<Collider>();\n        if (_zoneCollider == null)\n        {\n            Debug.LogWarning(\"WindZone requires a Collider component to define the wind area.\");\n        }\n        else\n        {\n            _zoneCollider.isTrigger = true;\n        }\n        \n        UpdateWindDirection();\n        \n        _turbulenceOffset = Random.Range(0f, 100f);\n        _gustOffset = Random.Range(0f, 100f);\n    }\n    \n    private void Update()\n    {\n        if (_normalizeDirection)\n        {\n            UpdateWindDirection();\n        }\n        \n        ApplyWindForces();\n    }\n    \n    private void UpdateWindDirection()\n    {\n        _normalizedDirection = _windDirection.normalized;\n    }\n    \n    private void ApplyWindForces()\n    {\n        float currentTime = Time.time;\n        Vector3 finalWindDirection = _normalizedDirection;\n        float finalWindStrength = _windStrength;\n        \n        // Apply turbulence\n        if (_enableTurbulence)\n        {\n            Vector3 turbulence = new Vector3(\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset, 0f) - 0.5f,\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset + 100f, 0f) - 0.5f,\n                Mathf.PerlinNoise(currentTime * _turbulenceFrequency + _turbulenceOffset + 200f, 0f) - 0.5f\n            );\n            \n            finalWindDirection += turbulence * _turbulenceStrength * 0.1f;\n            finalWindDirection = finalWindDirection.normalized;\n        }\n        \n        // Apply gustiness\n        if (_enableGustiness)\n        {\n            float gustMultiplier = 1f + (Mathf.PerlinNoise(currentTime * _gustFrequency + _gustOffset, 0f) - 0.5f) * _gustStrength * 0.2f;\n            finalWindStrength *= gustMultiplier;\n        }\n        \n        // Apply forces to rigidbodies\n        if (_affectRigidbodies)\n        {\n            for (int i = _affectedRigidbodies.Count - 1; i >= 0; i--)\n            {\n                if (_affectedRigidbodies[i] == null)\n                {\n                    _affectedRigidbodies.RemoveAt(i);\n                    continue;\n                }\n                \n                ApplyWindToRigidbody(_affectedRigidbodies[i], finalWindDirection, finalWindStrength);\n            }\n        }\n        \n        // Apply forces to particle systems\n        if (_affectParticles)\n        {\n            for (int i = _affectedParticles.Count - 1; i >= 0; i--)\n            {\n                if (_affectedParticles[i] == null)\n                {\n                    _affectedParticles.RemoveAt(i);\n                    continue;\n                }\n                \n                ApplyWindToParticles(_affectedParticles[i], finalWindDirection, finalWindStrength);\n            }\n        }\n    }\n    \n    private void ApplyWindToRigidbody(Rigidbody rb, Vector3 windDirection, float windStrength)\n    {\n        if (rb == null) return;\n        \n        float distanceMultiplier = 1f;\n        \n        if (_useDistanceFalloff && _zoneCollider != null)\n        {\n            Vector3 closestPoint = _zoneCollider.ClosestPoint(rb.position);\n            float distance = Vector3.Distance(rb.position, closestPoint);\n            float maxDistance = GetMaxDistanceInCollider();\n            \n            if (maxDistance > 0f)\n            {\n                float normalizedDistance = Mathf.Clamp01(distance / maxDistance);\n                distanceMultiplier = _falloffCurve.Evaluate(normalizedDistance);\n            }\n        }\n        \n        Vector3 force = windDirection * windStrength * distanceMultiplier * Time.deltaTime;\n        rb.AddForce(force, _forceMode);\n    }\n    \n    private void ApplyWindToParticles(ParticleSystem particles, Vector3 windDirection, float windStrength)\n    {\n        if (particles == null) return;\n        \n        var externalForces = particles.externalForces;\n        if (externalForces.enabled)\n        {\n            // If external forces are already enabled, we can't directly control them\n            // This is a limitation of Unity's particle system\n            return;\n        }\n        \n        var velocityOverLifetime = particles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        \n        float effectiveStrength = windStrength * 0.1f; // Scale down for particles\n        velocityOverLifetime.x = new ParticleSystem.MinMaxCurve(windDirection.x * effectiveStrength);\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(windDirection.y * effectiveStrength);\n        velocityOverLifetime.z = new ParticleSystem.MinMaxCurve(windDirection.z * effectiveStrength);\n    }\n    \n    private float GetMaxDistanceInCollider()\n    {\n        if (_zoneCollider == null) return 1f;\n        \n        Bounds bounds = _zoneCollider.bounds;\n        return Mathf.Max(bounds.size.x, bounds.size.y, bounds.size.z) * 0.5f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!IsInAffectedLayers(other.gameObject)) return;\n        \n        if (_affectRigidbodies)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && !_affectedRigidbodies.Contains(rb))\n            {\n                _affectedRigidbodies.Add(rb);\n            }\n        }\n        \n        if (_affectParticles)\n        {\n            ParticleSystem particles = other.GetComponent<ParticleSystem>();\n            if (particles != null && !_affectedParticles.Contains(particles))\n            {\n                _affectedParticles.Add(particles);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!IsInAffectedLayers(other.gameObject)) return;\n        \n        if (_affectRigidbodies)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                _affectedRigidbodies.Remove(rb);\n            }\n        }\n        \n        if (_affectParticles)\n        {\n            ParticleSystem particles = other.GetComponent<ParticleSystem>();\n            if (particles != null)\n            {\n                _affectedParticles.Remove(particles);\n                \n                // Reset particle velocity when leaving wind zone\n                var velocityOverLifetime = particles.velocityOverLifetime;\n                velocityOverLifetime.enabled = false;\n            }\n        }\n    }\n    \n    private bool IsInAffectedLayers(GameObject obj)\n    {\n        return (_affectedLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    public void SetWindDirection(Vector3 direction)\n    {\n        _windDirection = direction;\n        UpdateWindDirection();\n    }\n    \n    public void SetWindStrength(float strength)\n    {\n        _windStrength = Mathf.Max(0f, strength);\n    }\n    \n    public Vector3 GetCurrentWindDirection()\n    {\n        return _normalizedDirection;\n    }\n    \n    public float GetCurrentWindStrength()\n    {\n        return _windStrength;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Gizmos.color = _gizmoColor;\n        \n        if (_zoneCollider != null)\n        {\n            Gizmos.matrix = transform.localToWorldMatrix;\n            \n            if (_zoneCollider is BoxCollider box)\n            {\n                Gizmos.DrawWireCube(box.center, box.size);\n            }\n            else if (_zoneCollider is SphereCollider sphere)\n            {\n                Gizmos.DrawWireSphere(sphere.center, sphere.radius);\n            }\n            else if (_zoneCollider is CapsuleCollider capsule)\n            {\n                Gizmos.DrawWireCube(capsule.center, new Vector3(capsule.radius * 2, capsule.height, capsule.radius * 2));\n            }\n        }\n        \n        // Draw wind direction arrows\n        Gizmos.matrix = Matrix4x4.identity;\n        Gizmos.color = Color.yellow;\n        \n        Vector3 center = transform.position;\n        Vector3 windDir = transform.TransformDirection(_windDirection.normalized);\n        \n        for (int i = 0; i < 5; i++)\n        {\n            Vector3 offset = Random.insideUnitSphere * 2f;\n            offset.y = Mathf.Abs(offset.y);\n            Vector3 start = center + offset;\n            Vector3 end = start + windDir * 3f;\n            \n            Gizmos.DrawLine(start, end);\n            \n            // Arrow head\n            Vector3 arrowHead1 = end - windDir * 0.5f + Vector3.Cross(windDir, Vector3.up) * 0.3f;\n            Vector3 arrowHead2 = end - windDir * 0.5f - Vector3.Cross(windDir, Vector3.up) * 0.3f;\n            Gizmos.DrawLine(end, arrowHead1);\n            Gizmos.DrawLine(end, arrowHead2);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MushroomPowerUp\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"bounceHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"pointValue\",\n      \"type\": \"int\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"growthMultiplier\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_from_block\",\n      \"trigger\": \"when spawned from question block\",\n      \"actions\": [\n        {\n          \"action\": \"emerge upward from block slowly\"\n        },\n        {\n          \"action\": \"play mushroom spawn sound\"\n        },\n        {\n          \"action\": \"become solid after fully emerged\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ground_movement\",\n      \"trigger\": \"when touching ground\",\n      \"actions\": [\n        {\n          \"action\": \"move horizontally at constant speed\"\n        },\n        {\n          \"action\": \"change direction when hitting wall or obstacle\"\n        },\n        {\n          \"action\": \"fall when reaching edge of platform\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_collection\",\n      \"trigger\": \"when player touches mushroom\",\n      \"actions\": [\n        {\n          \"action\": \"make player grow larger\"\n        },\n        {\n          \"action\": \"give player points\"\n        },\n        {\n          \"action\": \"play power up sound\"\n        },\n        {\n          \"action\": \"destroy mushroom object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bounce_physics\",\n      \"trigger\": \"when hitting ground after falling\",\n      \"actions\": [\n        {\n          \"action\": \"bounce slightly upward\"\n        },\n        {\n          \"action\": \"continue horizontal movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MushroomPowerUp : MonoBehaviour\n{\n    [Header(\"Power-Up Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _bounceForce = 5f;\n    [SerializeField] private int _scoreValue = 100;\n    [SerializeField] private float _lifeTime = 10f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private bool _moveOnSpawn = true;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private LayerMask _wallLayer = 1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnScoreAdded;\n    public UnityEvent OnPowerUpCollected;\n    \n    private Rigidbody2D _rigidbody;\n    private SpriteRenderer _spriteRenderer;\n    private Collider2D _collider;\n    private AudioSource _audioSource;\n    private bool _isMoving;\n    private int _moveDirection = 1;\n    private float _groundCheckDistance = 0.6f;\n    private float _wallCheckDistance = 0.6f;\n    private bool _isCollected;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        _collider = GetComponent<Collider2D>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody2D>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider2D>();\n        }\n        \n        _collider.isTrigger = true;\n    }\n    \n    private void Start()\n    {\n        InitializePowerUp();\n        \n        if (_spawnSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_spawnSound);\n        }\n        \n        Destroy(gameObject, _lifeTime);\n    }\n    \n    private void InitializePowerUp()\n    {\n        _isMoving = _moveOnSpawn;\n        _moveDirection = Random.Range(0, 2) == 0 ? -1 : 1;\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.gravityScale = 1f;\n            _rigidbody.freezeRotation = true;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isCollected || !_isMoving) return;\n        \n        HandleMovement();\n        CheckForObstacles();\n    }\n    \n    private void HandleMovement()\n    {\n        if (_rigidbody == null) return;\n        \n        Vector2 velocity = _rigidbody.velocity;\n        velocity.x = _moveSpeed * _moveDirection;\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void CheckForObstacles()\n    {\n        Vector2 rayOrigin = transform.position;\n        Vector2 rayDirection = Vector2.right * _moveDirection;\n        \n        RaycastHit2D wallHit = Physics2D.Raycast(rayOrigin, rayDirection, _wallCheckDistance, _wallLayer);\n        if (wallHit.collider != null)\n        {\n            _moveDirection *= -1;\n            return;\n        }\n        \n        Vector2 groundCheckOrigin = rayOrigin + rayDirection * 0.5f;\n        RaycastHit2D groundHit = Physics2D.Raycast(groundCheckOrigin, Vector2.down, _groundCheckDistance, _groundLayer);\n        if (groundHit.collider == null)\n        {\n            _moveDirection *= -1;\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectPowerUp(other.gameObject);\n        }\n    }\n    \n    private void CollectPowerUp(GameObject player)\n    {\n        _isCollected = true;\n        _isMoving = false;\n        \n        ApplyPowerUpEffect(player);\n        PlayCollectEffects();\n        AddScore();\n        \n        OnPowerUpCollected?.Invoke();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.enabled = false;\n        }\n        \n        Destroy(gameObject, 0.5f);\n    }\n    \n    private void ApplyPowerUpEffect(GameObject player)\n    {\n        PlayerGrowthEffect growthEffect = player.GetComponent<PlayerGrowthEffect>();\n        if (growthEffect == null)\n        {\n            growthEffect = player.AddComponent<PlayerGrowthEffect>();\n        }\n        \n        growthEffect.GrowPlayer();\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectEffect != null)\n        {\n            Instantiate(_collectEffect, transform.position, Quaternion.identity);\n        }\n        \n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n    }\n    \n    private void AddScore()\n    {\n        OnScoreAdded?.Invoke(_scoreValue);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector2 rayOrigin = transform.position;\n        Vector2 rayDirection = Vector2.right * _moveDirection;\n        Gizmos.DrawRay(rayOrigin, rayDirection * _wallCheckDistance);\n        \n        Gizmos.color = Color.blue;\n        Vector2 groundCheckOrigin = rayOrigin + rayDirection * 0.5f;\n        Gizmos.DrawRay(groundCheckOrigin, Vector2.down * _groundCheckDistance);\n    }\n}\n\npublic class PlayerGrowthEffect : MonoBehaviour\n{\n    [SerializeField] private float _growthScale = 1.5f;\n    [SerializeField] private float _growthDuration = 0.3f;\n    [SerializeField] private AnimationCurve _growthCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Vector3 _originalScale;\n    private Vector3 _targetScale;\n    private bool _isGrowing;\n    private float _growthTimer;\n    \n    private void Awake()\n    {\n        _originalScale = transform.localScale;\n        _targetScale = _originalScale * _growthScale;\n    }\n    \n    public void GrowPlayer()\n    {\n        if (_isGrowing) return;\n        \n        StartCoroutine(GrowthCoroutine());\n    }\n    \n    private System.Collections.IEnumerator GrowthCoroutine()\n    {\n        _isGrowing = true;\n        _growthTimer = 0f;\n        Vector3 startScale = transform.localScale;\n        \n        while (_growthTimer < _growthDuration)\n        {\n            _growthTimer += Time.deltaTime;\n            float progress = _growthTimer / _growthDuration;\n            float curveValue = _growthCurve.Evaluate(progress);\n            \n            transform.localScale = Vector3.Lerp(startScale, _targetScale, curveValue);\n            yield return null;\n        }\n        \n        transform.localScale = _targetScale;\n        _isGrowing = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TeleportingNinja\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"teleportRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"teleportCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"start tracking player position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"teleport_behind_player\",\n      \"trigger\": \"when teleport cooldown has elapsed and player is within teleport range\",\n      \"actions\": [\n        {\n          \"action\": \"calculate position behind player\"\n        },\n        {\n          \"action\": \"instantly move to position behind player\"\n        },\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"reset teleport cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_player\",\n      \"trigger\": \"when player exits detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop tracking player\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class TeleportingNinja : MonoBehaviour\n{\n    [Header(\"Teleport Settings\")]\n    [SerializeField] private float _teleportRange = 10f;\n    [SerializeField] private float _teleportCooldown = 3f;\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _teleportDistance = 2f;\n    \n    [Header(\"Combat Settings\")]\n    [SerializeField] private float _attackDamage = 25f;\n    [SerializeField] private float _attackRange = 1.5f;\n    [SerializeField] private float _attackCooldown = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _teleportEffect;\n    [SerializeField] private AudioClip _teleportSound;\n    [SerializeField] private AudioClip _attackSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTeleport;\n    public UnityEvent OnAttack;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private Transform _player;\n    private float _lastTeleportTime;\n    private float _lastAttackTime;\n    private bool _isPlayerInRange;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Rigidbody _rigidbody;\n    \n    private enum NinjaState\n    {\n        Idle,\n        Stalking,\n        Teleporting,\n        Attacking\n    }\n    \n    private NinjaState _currentState = NinjaState.Idle;\n    \n    void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _animator = GetComponent<Animator>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.freezeRotation = true;\n        }\n        \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        _isPlayerInRange = distanceToPlayer <= _detectionRange;\n        \n        UpdateState(distanceToPlayer);\n        HandleBehavior();\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateState(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case NinjaState.Idle:\n                if (_isPlayerInRange)\n                    _currentState = NinjaState.Stalking;\n                break;\n                \n            case NinjaState.Stalking:\n                if (!_isPlayerInRange)\n                    _currentState = NinjaState.Idle;\n                else if (CanTeleport() && distanceToPlayer > _teleportDistance)\n                    _currentState = NinjaState.Teleporting;\n                else if (distanceToPlayer <= _attackRange && CanAttack())\n                    _currentState = NinjaState.Attacking;\n                break;\n                \n            case NinjaState.Teleporting:\n                _currentState = NinjaState.Stalking;\n                break;\n                \n            case NinjaState.Attacking:\n                _currentState = NinjaState.Stalking;\n                break;\n        }\n    }\n    \n    void HandleBehavior()\n    {\n        switch (_currentState)\n        {\n            case NinjaState.Teleporting:\n                TeleportBehindPlayer();\n                break;\n                \n            case NinjaState.Attacking:\n                AttackPlayer();\n                break;\n                \n            case NinjaState.Stalking:\n                LookAtPlayer();\n                break;\n        }\n    }\n    \n    bool CanTeleport()\n    {\n        return Time.time >= _lastTeleportTime + _teleportCooldown;\n    }\n    \n    bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    void TeleportBehindPlayer()\n    {\n        if (_player == null || !CanTeleport()) return;\n        \n        Vector3 playerForward = _player.forward;\n        Vector3 teleportPosition = _player.position - playerForward * _teleportDistance;\n        \n        // Ensure teleport position is on the ground\n        RaycastHit hit;\n        if (Physics.Raycast(teleportPosition + Vector3.up * 5f, Vector3.down, out hit, 10f))\n        {\n            teleportPosition.y = hit.point.y;\n        }\n        \n        // Check if teleport position is valid (not inside walls)\n        if (!Physics.CheckSphere(teleportPosition, 0.5f))\n        {\n            // Play teleport effect at current position\n            if (_teleportEffect != null)\n                _teleportEffect.Play();\n                \n            // Play sound\n            if (_teleportSound != null && _audioSource != null)\n                _audioSource.PlayOneShot(_teleportSound);\n            \n            // Teleport\n            transform.position = teleportPosition;\n            transform.LookAt(_player);\n            \n            // Play teleport effect at new position\n            if (_teleportEffect != null)\n            {\n                Invoke(nameof(PlayTeleportEffectDelayed), 0.1f);\n            }\n            \n            _lastTeleportTime = Time.time;\n            \n            if (_animator != null)\n                _animator.SetTrigger(\"Teleport\");\n                \n            OnTeleport?.Invoke();\n        }\n    }\n    \n    void PlayTeleportEffectDelayed()\n    {\n        if (_teleportEffect != null)\n            _teleportEffect.Play();\n    }\n    \n    void AttackPlayer()\n    {\n        if (_player == null || !CanAttack()) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        if (distanceToPlayer <= _attackRange)\n        {\n            // Play attack animation\n            if (_animator != null)\n                _animator.SetTrigger(\"Attack\");\n            \n            // Play attack sound\n            if (_attackSound != null && _audioSource != null)\n                _audioSource.PlayOneShot(_attackSound);\n            \n            // Deal damage to player\n            DealDamageToPlayer();\n            \n            _lastAttackTime = Time.time;\n            OnAttack?.Invoke();\n        }\n    }\n    \n    void DealDamageToPlayer()\n    {\n        if (_player == null) return;\n        \n        // Try to find health component on player\n        var healthComponent = _player.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a generic way to deal damage\n            _player.SendMessage(\"TakeDamage\", _attackDamage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        OnDamageDealt?.Invoke(_attackDamage);\n    }\n    \n    void LookAtPlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0; // Keep ninja upright\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 5f);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw attack range\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        // Draw teleport range\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _teleportRange);\n        \n        // Show teleport position if player exists\n        if (_player != null)\n        {\n            Vector3 teleportPos = _player.position - _player.forward * _teleportDistance;\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawWireSphere(teleportPos, 0.5f);\n            Gizmos.DrawLine(transform.position, teleportPos);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ThunderLightning\",\n  \"components\": [\n    \"AudioSource\",\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"minInterval\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"maxInterval\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"lightningDuration\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"thunderDelay\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"lightningIntensity\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"flashCount\",\n      \"type\": \"int\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_lightning_storm\",\n      \"trigger\": \"when random interval timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"reset timer with random interval between min and max\"\n        },\n        {\n          \"action\": \"start lightning flash sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lightning_flash\",\n      \"trigger\": \"when lightning sequence starts\",\n      \"actions\": [\n        {\n          \"action\": \"rapidly flash light on and off multiple times\"\n        },\n        {\n          \"action\": \"set light intensity to maximum during flashes\"\n        },\n        {\n          \"action\": \"illuminate entire scene briefly\"\n        },\n        {\n          \"action\": \"schedule thunder sound after delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"thunder_sound\",\n      \"trigger\": \"when thunder delay timer expires after lightning\",\n      \"actions\": [\n        {\n          \"action\": \"play thunder audio clip\"\n        },\n        {\n          \"action\": \"shake camera slightly for impact effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ambient_setup\",\n      \"trigger\": \"when object starts\",\n      \"actions\": [\n        {\n          \"action\": \"set light to disabled initially\"\n        },\n        {\n          \"action\": \"configure light as directional with white color\"\n        },\n        {\n          \"action\": \"start first random interval timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ThunderLightning : MonoBehaviour\n{\n    [Header(\"Lightning Settings\")]\n    [SerializeField] private Light _lightningLight;\n    [SerializeField] private float _lightningIntensity = 8f;\n    [SerializeField] private Color _lightningColor = Color.white;\n    [SerializeField] private float _lightningDuration = 0.1f;\n    [SerializeField] private int _minFlashes = 1;\n    [SerializeField] private int _maxFlashes = 3;\n    [SerializeField] private float _flashInterval = 0.05f;\n    \n    [Header(\"Thunder Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _thunderSounds;\n    [SerializeField] private float _minThunderDelay = 0.5f;\n    [SerializeField] private float _maxThunderDelay = 3f;\n    [SerializeField] private float _thunderVolume = 1f;\n    \n    [Header(\"Storm Settings\")]\n    [SerializeField] private bool _autoStorm = true;\n    [SerializeField] private float _minStormInterval = 5f;\n    [SerializeField] private float _maxStormInterval = 15f;\n    [SerializeField] private bool _randomIntensity = true;\n    \n    [Header(\"Environment Effects\")]\n    [SerializeField] private ParticleSystem _rainParticles;\n    [SerializeField] private Material _skyboxMaterial;\n    [SerializeField] private string _skyboxTintProperty = \"_Tint\";\n    [SerializeField] private Color _stormSkyTint = new Color(0.3f, 0.3f, 0.4f, 1f);\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLightningStrike;\n    public UnityEvent OnThunderRoll;\n    public UnityEvent OnStormStart;\n    public UnityEvent OnStormEnd;\n    \n    private float _originalLightIntensity;\n    private Color _originalLightColor;\n    private Color _originalSkyTint;\n    private bool _isStorming = false;\n    private Coroutine _stormCoroutine;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        \n        if (_lightningLight == null)\n        {\n            _lightningLight = GetComponent<Light>();\n            if (_lightningLight == null)\n            {\n                GameObject lightGO = new GameObject(\"Lightning Light\");\n                lightGO.transform.SetParent(transform);\n                _lightningLight = lightGO.AddComponent<Light>();\n                _lightningLight.type = LightType.Directional;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _originalLightIntensity = _lightningLight.intensity;\n        _originalLightColor = _lightningLight.color;\n        _lightningLight.intensity = 0f;\n        \n        if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n        {\n            _originalSkyTint = _skyboxMaterial.GetColor(_skyboxTintProperty);\n        }\n        \n        if (_autoStorm)\n        {\n            _stormCoroutine = StartCoroutine(AutoStormRoutine());\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_stormCoroutine != null)\n        {\n            StopCoroutine(_stormCoroutine);\n        }\n        \n        if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n        {\n            _skyboxMaterial.SetColor(_skyboxTintProperty, _originalSkyTint);\n        }\n    }\n    \n    public void TriggerLightningStrike()\n    {\n        StartCoroutine(LightningStrikeRoutine());\n    }\n    \n    public void StartStorm()\n    {\n        if (!_isStorming)\n        {\n            _isStorming = true;\n            OnStormStart?.Invoke();\n            \n            if (_rainParticles != null && !_rainParticles.isPlaying)\n            {\n                _rainParticles.Play();\n            }\n            \n            if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n            {\n                StartCoroutine(ChangeSkyTint(_stormSkyTint, 2f));\n            }\n        }\n    }\n    \n    public void EndStorm()\n    {\n        if (_isStorming)\n        {\n            _isStorming = false;\n            OnStormEnd?.Invoke();\n            \n            if (_rainParticles != null && _rainParticles.isPlaying)\n            {\n                _rainParticles.Stop();\n            }\n            \n            if (_skyboxMaterial != null && _skyboxMaterial.HasProperty(_skyboxTintProperty))\n            {\n                StartCoroutine(ChangeSkyTint(_originalSkyTint, 3f));\n            }\n        }\n    }\n    \n    private IEnumerator AutoStormRoutine()\n    {\n        while (true)\n        {\n            float waitTime = Random.Range(_minStormInterval, _maxStormInterval);\n            yield return new WaitForSeconds(waitTime);\n            \n            if (!_isStorming)\n            {\n                StartStorm();\n                \n                int lightningStrikes = Random.Range(3, 8);\n                for (int i = 0; i < lightningStrikes; i++)\n                {\n                    yield return new WaitForSeconds(Random.Range(1f, 4f));\n                    TriggerLightningStrike();\n                }\n                \n                yield return new WaitForSeconds(Random.Range(5f, 10f));\n                EndStorm();\n            }\n        }\n    }\n    \n    private IEnumerator LightningStrikeRoutine()\n    {\n        OnLightningStrike?.Invoke();\n        \n        int flashCount = Random.Range(_minFlashes, _maxFlashes + 1);\n        float intensity = _randomIntensity ? Random.Range(_lightningIntensity * 0.7f, _lightningIntensity * 1.3f) : _lightningIntensity;\n        \n        for (int i = 0; i < flashCount; i++)\n        {\n            _lightningLight.intensity = intensity;\n            _lightningLight.color = _lightningColor;\n            \n            if (_mainCamera != null)\n            {\n                StartCoroutine(CameraShake(0.1f, 0.2f));\n            }\n            \n            yield return new WaitForSeconds(_lightningDuration);\n            \n            _lightningLight.intensity = 0f;\n            \n            if (i < flashCount - 1)\n            {\n                yield return new WaitForSeconds(_flashInterval);\n            }\n        }\n        \n        float thunderDelay = Random.Range(_minThunderDelay, _maxThunderDelay);\n        yield return new WaitForSeconds(thunderDelay);\n        \n        PlayThunder();\n    }\n    \n    private void PlayThunder()\n    {\n        if (_thunderSounds != null && _thunderSounds.Length > 0 && _audioSource != null)\n        {\n            AudioClip thunderClip = _thunderSounds[Random.Range(0, _thunderSounds.Length)];\n            _audioSource.clip = thunderClip;\n            _audioSource.volume = _thunderVolume;\n            _audioSource.Play();\n            \n            OnThunderRoll?.Invoke();\n        }\n    }\n    \n    private IEnumerator CameraShake(float duration, float magnitude)\n    {\n        if (_mainCamera == null) yield break;\n        \n        Vector3 originalPosition = _mainCamera.transform.localPosition;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float x = Random.Range(-1f, 1f) * magnitude;\n            float y = Random.Range(-1f, 1f) * magnitude;\n            \n            _mainCamera.transform.localPosition = new Vector3(originalPosition.x + x, originalPosition.y + y, originalPosition.z);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.localPosition = originalPosition;\n    }\n    \n    private IEnumerator ChangeSkyTint(Color targetColor, float duration)\n    {\n        if (_skyboxMaterial == null || !_skyboxMaterial.HasProperty(_skyboxTintProperty))\n            yield break;\n        \n        Color startColor = _skyboxMaterial.GetColor(_skyboxTintProperty);\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            Color currentColor = Color.Lerp(startColor, targetColor, t);\n            _skyboxMaterial.SetColor(_skyboxTintProperty, currentColor);\n            yield return null;\n        }\n        \n        _skyboxMaterial.SetColor(_skyboxTintProperty, targetColor);\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            TriggerLightningStrike();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.K))\n        {\n            if (_isStorming)\n                EndStorm();\n            else\n                StartStorm();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"QuickDrawKatana\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"drawSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"sheatheSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"slashDamage\",\n      \"type\": \"int\",\n      \"default\": 75\n    },\n    {\n      \"name\": \"isSheathed\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isDrawing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"drawRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"quick_draw_attack\",\n      \"trigger\": \"when player presses attack button and katana is sheathed\",\n      \"actions\": [\n        {\n          \"action\": \"play quick draw sound effect\"\n        },\n        {\n          \"action\": \"set drawing state to true\"\n        },\n        {\n          \"action\": \"rapidly move katana from sheathed to drawn position\"\n        },\n        {\n          \"action\": \"create slash effect in front of player\"\n        },\n        {\n          \"action\": \"deal damage to enemies within draw range\"\n        },\n        {\n          \"action\": \"set sheathed state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sheathe_katana\",\n      \"trigger\": \"when player presses sheathe button and katana is drawn\",\n      \"actions\": [\n        {\n          \"action\": \"play sheathing sound effect\"\n        },\n        {\n          \"action\": \"smoothly move katana to sheathed position\"\n        },\n        {\n          \"action\": \"set sheathed state to true\"\n        },\n        {\n          \"action\": \"reset drawing state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"normal_slash\",\n      \"trigger\": \"when player presses attack button and katana is already drawn\",\n      \"actions\": [\n        {\n          \"action\": \"play slash sound effect\"\n        },\n        {\n          \"action\": \"create sword swing animation\"\n        },\n        {\n          \"action\": \"deal damage to enemies in slash arc\"\n        },\n        {\n          \"action\": \"apply brief screen shake effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"draw_stance_ready\",\n      \"trigger\": \"when katana is sheathed and enemy is nearby\",\n      \"actions\": [\n        {\n          \"action\": \"highlight katana with subtle glow effect\"\n        },\n        {\n          \"action\": \"increase player movement speed slightly\"\n        },\n        {\n          \"action\": \"show quick draw prompt to player\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Katana : MonoBehaviour\n{\n    [Header(\"Katana Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Quick Draw\")]\n    [SerializeField] private float _quickDrawWindow = 0.3f;\n    [SerializeField] private float _quickDrawDamageMultiplier = 2f;\n    [SerializeField] private float _quickDrawRange = 3f;\n    [SerializeField] private KeyCode _quickDrawKey = KeyCode.Q;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _drawSpeed = 2f;\n    [SerializeField] private float _sheatheSpeed = 1.5f;\n    [SerializeField] private Transform _katanaModel;\n    [SerializeField] private Transform _sheathedPosition;\n    [SerializeField] private Transform _drawnPosition;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private ParticleSystem _quickDrawEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drawSound;\n    [SerializeField] private AudioClip _sheatheSound;\n    [SerializeField] private AudioClip _slashSound;\n    [SerializeField] private AudioClip _quickDrawSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnAttack;\n    public UnityEvent OnQuickDraw;\n    public UnityEvent OnDraw;\n    public UnityEvent OnSheathe;\n    \n    private bool _isDrawn = false;\n    private bool _isQuickDrawReady = true;\n    private bool _isAnimating = false;\n    private float _lastDrawTime;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class HitInfo\n    {\n        public GameObject target;\n        public float damage;\n        public Vector3 hitPoint;\n        public Vector3 hitDirection;\n    }\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_katanaModel == null)\n            _katanaModel = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_sheathedPosition == null)\n        {\n            GameObject sheathed = new GameObject(\"SheathedPosition\");\n            sheathed.transform.SetParent(transform.parent);\n            sheathed.transform.localPosition = new Vector3(0.5f, -0.5f, 0.5f);\n            sheathed.transform.localRotation = Quaternion.Euler(0, 0, 45);\n            _sheathedPosition = sheathed.transform;\n        }\n        \n        if (_drawnPosition == null)\n        {\n            GameObject drawn = new GameObject(\"DrawnPosition\");\n            drawn.transform.SetParent(transform.parent);\n            drawn.transform.localPosition = new Vector3(0.3f, 0, 0.8f);\n            drawn.transform.localRotation = Quaternion.identity;\n            _drawnPosition = drawn.transform;\n        }\n        \n        SetKatanaPosition(_sheathedPosition);\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateQuickDrawWindow();\n    }\n    \n    void HandleInput()\n    {\n        if (_isAnimating) return;\n        \n        if (Input.GetKeyDown(_quickDrawKey))\n        {\n            if (!_isDrawn && _isQuickDrawReady)\n            {\n                PerformQuickDraw();\n            }\n            else if (!_isDrawn)\n            {\n                DrawKatana();\n            }\n            else\n            {\n                SheatheKatana();\n            }\n        }\n        \n        if (_isDrawn && Input.GetMouseButtonDown(0))\n        {\n            PerformAttack();\n        }\n    }\n    \n    void UpdateQuickDrawWindow()\n    {\n        if (!_isQuickDrawReady && Time.time - _lastDrawTime > _quickDrawWindow)\n        {\n            _isQuickDrawReady = true;\n        }\n    }\n    \n    void PerformQuickDraw()\n    {\n        if (_isAnimating) return;\n        \n        _isQuickDrawReady = false;\n        _lastDrawTime = Time.time;\n        \n        StartCoroutine(QuickDrawSequence());\n    }\n    \n    System.Collections.IEnumerator QuickDrawSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_quickDrawSound);\n        OnQuickDraw?.Invoke();\n        \n        if (_quickDrawEffect != null)\n            _quickDrawEffect.Play();\n        \n        float drawTime = 1f / (_drawSpeed * 2f);\n        yield return StartCoroutine(AnimateToPosition(_drawnPosition, drawTime));\n        \n        PerformQuickDrawAttack();\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        float sheatheTime = 1f / (_sheatheSpeed * 2f);\n        yield return StartCoroutine(AnimateToPosition(_sheathedPosition, sheatheTime));\n        \n        _isDrawn = false;\n        _isAnimating = false;\n        \n        PlaySound(_sheatheSound);\n        OnSheathe?.Invoke();\n    }\n    \n    void PerformQuickDrawAttack()\n    {\n        float damage = _damage * _quickDrawDamageMultiplier;\n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.5f, attackDirection, _quickDrawRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            ProcessHit(hit.collider.gameObject, damage, hit.point, attackDirection);\n        }\n        \n        if (_slashEffect != null)\n        {\n            _slashEffect.transform.position = attackOrigin + attackDirection * (_quickDrawRange * 0.5f);\n            _slashEffect.Play();\n        }\n        \n        OnAttack?.Invoke(damage);\n    }\n    \n    void DrawKatana()\n    {\n        if (_isDrawn || _isAnimating) return;\n        \n        StartCoroutine(DrawSequence());\n    }\n    \n    System.Collections.IEnumerator DrawSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_drawSound);\n        OnDraw?.Invoke();\n        \n        float drawTime = 1f / _drawSpeed;\n        yield return StartCoroutine(AnimateToPosition(_drawnPosition, drawTime));\n        \n        _isDrawn = true;\n        _isAnimating = false;\n    }\n    \n    void SheatheKatana()\n    {\n        if (!_isDrawn || _isAnimating) return;\n        \n        StartCoroutine(SheatheSequence());\n    }\n    \n    System.Collections.IEnumerator SheatheSequence()\n    {\n        _isAnimating = true;\n        \n        PlaySound(_sheatheSound);\n        \n        float sheatheTime = 1f / _sheatheSpeed;\n        yield return StartCoroutine(AnimateToPosition(_sheathedPosition, sheatheTime));\n        \n        _isDrawn = false;\n        _isAnimating = false;\n        \n        OnSheathe?.Invoke();\n    }\n    \n    System.Collections.IEnumerator AnimateToPosition(Transform targetTransform, float duration)\n    {\n        Vector3 startPos = _katanaModel.position;\n        Quaternion startRot = _katanaModel.rotation;\n        Vector3 targetPos = targetTransform.position;\n        Quaternion targetRot = targetTransform.rotation;\n        \n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            _katanaModel.position = Vector3.Lerp(startPos, targetPos, t);\n            _katanaModel.rotation = Quaternion.Lerp(startRot, targetRot, t);\n            \n            yield return null;\n        }\n        \n        _katanaModel.position = targetPos;\n        _katanaModel.rotation = targetRot;\n    }\n    \n    void SetKatanaPosition(Transform targetTransform)\n    {\n        _katanaModel.position = targetTransform.position;\n        _katanaModel.rotation = targetTransform.rotation;\n    }\n    \n    void PerformAttack()\n    {\n        if (!_isDrawn || _isAnimating) return;\n        \n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        RaycastHit[] hits = Physics.SphereCastAll(attackOrigin, 0.3f, attackDirection, _attackRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.gameObject == gameObject) continue;\n            \n            ProcessHit(hit.collider.gameObject, _damage, hit.point, attackDirection);\n        }\n        \n        PlaySound(_slashSound);\n        \n        if (_slashEffect != null)\n        {\n            _slashEffect.transform.position = attackOrigin + attackDirection * (_attackRange * 0.5f);\n            _slashEffect.Play();\n        }\n        \n        OnAttack?.Invoke(_damage);\n    }\n    \n    void ProcessHit(GameObject target, float damage, Vector3 hitPoint, Vector3 hitDirection)\n    {\n        if (target.CompareTag(\"Player\")) return;\n        \n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            targetRb.AddForce(hitDirection * 10f, ForceMode.Impulse);\n        }\n        \n        HitInfo hitInfo = new HitInfo\n        {\n            target = target,\n            damage = damage,\n            hitPoint = hitPoint,\n            hitDirection = hitDirection\n        };\n        \n        target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        target.SendMessage(\"OnKatanaHit\", hitInfo, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_katanaModel == null) return;\n        \n        Vector3 attackOrigin = _katanaModel.position;\n        Vector3 attackDirection = _playerCamera != null ? _playerCamera.transform.forward : transform.forward;\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(attackOrigin + attackDirection * _attackRange, 0.3f);\n        Gizmos.DrawLine(attackOrigin, attackOrigin + attackDirection * _attackRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(attackOrigin + attackDirection * _quickDrawRange, 0.5f);\n        Gizmos.DrawLine(attackOrigin, attackOrigin + attackDirection * _quickDrawRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DustParticles\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"particleCount\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"driftSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"lightIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"particleSize\",\n      \"type\": \"float\",\n      \"default\": 0.01\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_dust_particles\",\n      \"trigger\": \"when scene starts\",\n      \"actions\": [\n        {\n          \"action\": \"create small floating dust particles in the air\"\n        },\n        {\n          \"action\": \"set particles to drift slowly and randomly\"\n        },\n        {\n          \"action\": \"make particles visible only when illuminated by light\"\n        }\n      ]\n    },\n    {\n      \"name\": \"illuminate_particles\",\n      \"trigger\": \"when light shines on particles\",\n      \"actions\": [\n        {\n          \"action\": \"make dust particles glow and become visible\"\n        },\n        {\n          \"action\": \"adjust particle brightness based on light intensity\"\n        },\n        {\n          \"action\": \"create sparkling effect on illuminated dust\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_movement\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"move particles in gentle floating motion\"\n        },\n        {\n          \"action\": \"add subtle random movement to simulate air currents\"\n        },\n        {\n          \"action\": \"keep particles within light beam area\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_in_darkness\",\n      \"trigger\": \"when particles move away from light\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade particles to invisible\"\n        },\n        {\n          \"action\": \"reduce particle opacity in dark areas\"\n        },\n        {\n          \"action\": \"maintain particle positions but hide them\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class DustParticlesInLight : MonoBehaviour\n{\n    [Header(\"Particle Settings\")]\n    [SerializeField] private int _maxParticles = 100;\n    [SerializeField] private float _particleSize = 0.02f;\n    [SerializeField] private float _particleSizeVariation = 0.01f;\n    [SerializeField] private Material _dustMaterial;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _driftSpeed = 0.5f;\n    [SerializeField] private float _driftVariation = 0.3f;\n    [SerializeField] private float _floatAmplitude = 0.1f;\n    [SerializeField] private float _floatFrequency = 1f;\n    \n    [Header(\"Light Detection\")]\n    [SerializeField] private LayerMask _lightLayerMask = -1;\n    [SerializeField] private float _lightDetectionRadius = 10f;\n    [SerializeField] private float _fadeDistance = 2f;\n    \n    [Header(\"Spawn Area\")]\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(5f, 5f, 5f);\n    [SerializeField] private float _respawnHeight = 3f;\n    \n    private List<DustParticle> _particles = new List<DustParticle>();\n    private Light[] _nearbyLights;\n    private Camera _mainCamera;\n    \n    [System.Serializable]\n    private class DustParticle\n    {\n        public GameObject gameObject;\n        public Renderer renderer;\n        public Vector3 velocity;\n        public float floatOffset;\n        public float baseAlpha;\n        public Vector3 startPosition;\n        public float lifetime;\n        public float maxLifetime;\n        \n        public DustParticle(GameObject go, Renderer rend)\n        {\n            gameObject = go;\n            renderer = rend;\n            floatOffset = Random.Range(0f, Mathf.PI * 2f);\n            baseAlpha = Random.Range(0.1f, 0.3f);\n            maxLifetime = Random.Range(10f, 30f);\n            lifetime = 0f;\n        }\n    }\n    \n    void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        if (_dustMaterial == null)\n        {\n            _dustMaterial = CreateDefaultDustMaterial();\n        }\n        \n        InitializeParticles();\n        InvokeRepeating(nameof(UpdateLightSources), 0f, 1f);\n    }\n    \n    void Update()\n    {\n        UpdateParticles();\n        UpdateParticleVisibility();\n    }\n    \n    private Material CreateDefaultDustMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.color = new Color(1f, 1f, 1f, 0.2f);\n        mat.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n        mat.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n        mat.SetInt(\"_ZWrite\", 0);\n        mat.DisableKeyword(\"_ALPHATEST_ON\");\n        mat.EnableKeyword(\"_ALPHABLEND_ON\");\n        mat.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n        mat.renderQueue = 3000;\n        return mat;\n    }\n    \n    private void InitializeParticles()\n    {\n        for (int i = 0; i < _maxParticles; i++)\n        {\n            CreateParticle();\n        }\n    }\n    \n    private void CreateParticle()\n    {\n        GameObject particleGO = GameObject.CreatePrimitive(PrimitiveType.Quad);\n        particleGO.name = \"DustParticle\";\n        particleGO.transform.SetParent(transform);\n        \n        DestroyImmediate(particleGO.GetComponent<Collider>());\n        \n        Renderer renderer = particleGO.GetComponent<Renderer>();\n        renderer.material = _dustMaterial;\n        renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n        renderer.receiveShadows = false;\n        \n        float size = _particleSize + Random.Range(-_particleSizeVariation, _particleSizeVariation);\n        particleGO.transform.localScale = Vector3.one * size;\n        \n        Vector3 spawnPos = GetRandomSpawnPosition();\n        particleGO.transform.position = spawnPos;\n        \n        DustParticle particle = new DustParticle(particleGO, renderer);\n        particle.startPosition = spawnPos;\n        particle.velocity = new Vector3(\n            Random.Range(-_driftVariation, _driftVariation),\n            Random.Range(-_driftSpeed * 0.5f, _driftSpeed * 0.5f),\n            Random.Range(-_driftVariation, _driftVariation)\n        );\n        \n        _particles.Add(particle);\n    }\n    \n    private Vector3 GetRandomSpawnPosition()\n    {\n        return transform.position + new Vector3(\n            Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f),\n            Random.Range(-_spawnAreaSize.y * 0.5f, _spawnAreaSize.y * 0.5f),\n            Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f)\n        );\n    }\n    \n    private void UpdateParticles()\n    {\n        for (int i = 0; i < _particles.Count; i++)\n        {\n            DustParticle particle = _particles[i];\n            if (particle.gameObject == null) continue;\n            \n            particle.lifetime += Time.deltaTime;\n            \n            Vector3 floatMotion = new Vector3(\n                Mathf.Sin(Time.time * _floatFrequency + particle.floatOffset) * _floatAmplitude,\n                Mathf.Cos(Time.time * _floatFrequency * 0.7f + particle.floatOffset) * _floatAmplitude * 0.5f,\n                Mathf.Sin(Time.time * _floatFrequency * 1.3f + particle.floatOffset) * _floatAmplitude * 0.3f\n            );\n            \n            Vector3 movement = (particle.velocity * _driftSpeed + floatMotion) * Time.deltaTime;\n            particle.gameObject.transform.position += movement;\n            \n            if (_mainCamera != null)\n            {\n                Vector3 dirToCamera = _mainCamera.transform.position - particle.gameObject.transform.position;\n                particle.gameObject.transform.rotation = Quaternion.LookRotation(dirToCamera);\n            }\n            \n            if (particle.gameObject.transform.position.y > transform.position.y + _respawnHeight ||\n                particle.lifetime > particle.maxLifetime ||\n                Vector3.Distance(particle.gameObject.transform.position, transform.position) > _spawnAreaSize.magnitude)\n            {\n                RespawnParticle(particle);\n            }\n        }\n    }\n    \n    private void RespawnParticle(DustParticle particle)\n    {\n        Vector3 newPos = GetRandomSpawnPosition();\n        newPos.y = transform.position.y - _spawnAreaSize.y * 0.5f;\n        particle.gameObject.transform.position = newPos;\n        particle.startPosition = newPos;\n        particle.lifetime = 0f;\n        particle.maxLifetime = Random.Range(10f, 30f);\n        \n        particle.velocity = new Vector3(\n            Random.Range(-_driftVariation, _driftVariation),\n            Random.Range(-_driftSpeed * 0.5f, _driftSpeed * 0.5f),\n            Random.Range(-_driftVariation, _driftVariation)\n        );\n    }\n    \n    private void UpdateParticleVisibility()\n    {\n        if (_nearbyLights == null) return;\n        \n        foreach (DustParticle particle in _particles)\n        {\n            if (particle.gameObject == null) continue;\n            \n            float lightInfluence = CalculateLightInfluence(particle.gameObject.transform.position);\n            float alpha = particle.baseAlpha * lightInfluence;\n            \n            Color currentColor = particle.renderer.material.color;\n            currentColor.a = alpha;\n            particle.renderer.material.color = currentColor;\n            \n            particle.renderer.enabled = alpha > 0.01f;\n        }\n    }\n    \n    private float CalculateLightInfluence(Vector3 position)\n    {\n        float totalInfluence = 0f;\n        \n        foreach (Light light in _nearbyLights)\n        {\n            if (light == null || !light.enabled) continue;\n            \n            float distance = Vector3.Distance(position, light.transform.position);\n            float lightRange = light.range;\n            \n            if (distance > lightRange) continue;\n            \n            float influence = 1f - (distance / lightRange);\n            influence = Mathf.Pow(influence, 2f);\n            \n            if (light.type == LightType.Spot)\n            {\n                Vector3 dirToParticle = (position - light.transform.position).normalized;\n                float angle = Vector3.Angle(light.transform.forward, dirToParticle);\n                float spotAngle = light.spotAngle * 0.5f;\n                \n                if (angle > spotAngle)\n                {\n                    influence *= Mathf.Max(0f, 1f - (angle - spotAngle) / _fadeDistance);\n                }\n            }\n            \n            influence *= light.intensity;\n            totalInfluence += influence;\n        }\n        \n        return Mathf.Clamp01(totalInfluence);\n    }\n    \n    private void UpdateLightSources()\n    {\n        Collider[] lightColliders = Physics.OverlapSphere(transform.position, _lightDetectionRadius, _lightLayerMask);\n        List<Light> lights = new List<Light>();\n        \n        foreach (Collider col in lightColliders)\n        {\n            Light light = col.GetComponent<Light>();\n            if (light != null)\n            {\n                lights.Add(light);\n            }\n        }\n        \n        Light[] allLights = FindObjectsOfType<Light>();\n        foreach (Light light in allLights)\n        {\n            if (Vector3.Distance(light.transform.position, transform.position) <= _lightDetectionRadius)\n            {\n                if (!lights.Contains(light))\n                {\n                    lights.Add(light);\n                }\n            }\n        }\n        \n        _nearbyLights = lights.ToArray();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireCube(transform.position, _spawnAreaSize);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _lightDetectionRadius);\n    }\n    \n    void OnDestroy()\n    {\n        foreach (DustParticle particle in _particles)\n        {\n            if (particle.gameObject != null)\n            {\n                DestroyImmediate(particle.gameObject);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RespawnCountdown\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"countdownTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"currentTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"isCountingDown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_countdown\",\n      \"trigger\": \"when respawn countdown is initiated\",\n      \"actions\": [\n        {\n          \"action\": \"set countdown timer to full countdown time\"\n        },\n        {\n          \"action\": \"enable countdown state\"\n        },\n        {\n          \"action\": \"display countdown UI\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_countdown\",\n      \"trigger\": \"every frame while countdown is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease countdown timer by elapsed time\"\n        },\n        {\n          \"action\": \"update countdown display with remaining time\"\n        },\n        {\n          \"action\": \"play countdown sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_countdown\",\n      \"trigger\": \"when countdown timer reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"disable countdown state\"\n        },\n        {\n          \"action\": \"hide countdown UI\"\n        },\n        {\n          \"action\": \"trigger respawn event\"\n        },\n        {\n          \"action\": \"play respawn sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_countdown\",\n      \"trigger\": \"when countdown is cancelled\",\n      \"actions\": [\n        {\n          \"action\": \"stop countdown timer\"\n        },\n        {\n          \"action\": \"disable countdown state\"\n        },\n        {\n          \"action\": \"hide countdown UI\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RespawnCountdown : MonoBehaviour\n{\n    [Header(\"Countdown Settings\")]\n    [SerializeField] private float _countdownDuration = 5f;\n    [SerializeField] private bool _startOnAwake = false;\n    [SerializeField] private bool _hideUIWhenNotActive = true;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _countdownText;\n    [SerializeField] private Image _countdownFillImage;\n    [SerializeField] private GameObject _countdownPanel;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private bool _enablePulseEffect = true;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1.2f);\n    [SerializeField] private Color _startColor = Color.red;\n    [SerializeField] private Color _endColor = Color.green;\n    [SerializeField] private bool _enableColorTransition = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _tickSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private bool _playTickOnEachSecond = true;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCountdownStart;\n    public UnityEvent OnCountdownTick;\n    public UnityEvent OnCountdownComplete;\n    public UnityEvent OnCountdownCancelled;\n    \n    private float _currentTime;\n    private bool _isCountingDown = false;\n    private Coroutine _countdownCoroutine;\n    private Vector3 _originalScale;\n    private int _lastSecond = -1;\n    \n    private void Awake()\n    {\n        if (_countdownText != null)\n            _originalScale = _countdownText.transform.localScale;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetUIVisibility(false);\n    }\n    \n    private void Start()\n    {\n        if (_startOnAwake)\n            StartCountdown();\n    }\n    \n    public void StartCountdown()\n    {\n        StartCountdown(_countdownDuration);\n    }\n    \n    public void StartCountdown(float duration)\n    {\n        if (_isCountingDown)\n            StopCountdown();\n            \n        _countdownDuration = duration;\n        _currentTime = _countdownDuration;\n        _isCountingDown = true;\n        _lastSecond = -1;\n        \n        SetUIVisibility(true);\n        OnCountdownStart?.Invoke();\n        \n        _countdownCoroutine = StartCoroutine(CountdownRoutine());\n    }\n    \n    public void StopCountdown()\n    {\n        if (_countdownCoroutine != null)\n        {\n            StopCoroutine(_countdownCoroutine);\n            _countdownCoroutine = null;\n        }\n        \n        _isCountingDown = false;\n        SetUIVisibility(false);\n        OnCountdownCancelled?.Invoke();\n    }\n    \n    public void PauseCountdown()\n    {\n        if (_countdownCoroutine != null)\n        {\n            StopCoroutine(_countdownCoroutine);\n            _countdownCoroutine = null;\n        }\n    }\n    \n    public void ResumeCountdown()\n    {\n        if (_isCountingDown && _countdownCoroutine == null)\n        {\n            _countdownCoroutine = StartCoroutine(CountdownRoutine());\n        }\n    }\n    \n    private IEnumerator CountdownRoutine()\n    {\n        while (_currentTime > 0f)\n        {\n            UpdateUI();\n            CheckForSecondTick();\n            \n            _currentTime -= Time.deltaTime;\n            yield return null;\n        }\n        \n        _currentTime = 0f;\n        _isCountingDown = false;\n        UpdateUI();\n        \n        PlaySound(_completeSound);\n        OnCountdownComplete?.Invoke();\n        \n        if (_hideUIWhenNotActive)\n        {\n            yield return new WaitForSeconds(0.5f);\n            SetUIVisibility(false);\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        float normalizedTime = _currentTime / _countdownDuration;\n        \n        if (_countdownText != null)\n        {\n            int displaySeconds = Mathf.CeilToInt(_currentTime);\n            _countdownText.text = displaySeconds.ToString();\n            \n            if (_enableColorTransition)\n            {\n                _countdownText.color = Color.Lerp(_endColor, _startColor, normalizedTime);\n            }\n            \n            if (_enablePulseEffect)\n            {\n                float pulseValue = _pulseCurve.Evaluate(Time.time % 1f);\n                _countdownText.transform.localScale = _originalScale * pulseValue;\n            }\n        }\n        \n        if (_countdownFillImage != null)\n        {\n            _countdownFillImage.fillAmount = normalizedTime;\n            \n            if (_enableColorTransition)\n            {\n                _countdownFillImage.color = Color.Lerp(_endColor, _startColor, normalizedTime);\n            }\n        }\n        \n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(0.5f, 1f, normalizedTime);\n        }\n    }\n    \n    private void CheckForSecondTick()\n    {\n        int currentSecond = Mathf.CeilToInt(_currentTime);\n        \n        if (currentSecond != _lastSecond && currentSecond > 0)\n        {\n            _lastSecond = currentSecond;\n            OnCountdownTick?.Invoke();\n            \n            if (_playTickOnEachSecond)\n                PlaySound(_tickSound);\n        }\n    }\n    \n    private void SetUIVisibility(bool visible)\n    {\n        if (_countdownPanel != null)\n            _countdownPanel.SetActive(visible);\n        else if (_countdownText != null)\n            _countdownText.gameObject.SetActive(visible);\n            \n        if (_canvasGroup != null)\n            _canvasGroup.alpha = visible ? 1f : 0f;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetRemainingTime()\n    {\n        return _currentTime;\n    }\n    \n    public float GetNormalizedTime()\n    {\n        return _countdownDuration > 0 ? _currentTime / _countdownDuration : 0f;\n    }\n    \n    public bool IsCountingDown()\n    {\n        return _isCountingDown;\n    }\n    \n    public void AddTime(float additionalTime)\n    {\n        _currentTime += additionalTime;\n        _currentTime = Mathf.Max(0f, _currentTime);\n    }\n    \n    public void SetRemainingTime(float time)\n    {\n        _currentTime = Mathf.Max(0f, time);\n    }\n    \n    private void OnValidate()\n    {\n        _countdownDuration = Mathf.Max(0.1f, _countdownDuration);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GameOverScreen\",\n  \"components\": [\n    \"Canvas\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"restartButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"mainMenuButton\",\n      \"type\": \"Button\",\n      \"default\": null\n    },\n    {\n      \"name\": \"gameOverText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"finalScoreText\",\n      \"type\": \"Text\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_game_over_screen\",\n      \"trigger\": \"when game over event is received\",\n      \"actions\": [\n        {\n          \"action\": \"make screen visible\"\n        },\n        {\n          \"action\": \"fade in screen gradually over specified duration\"\n        },\n        {\n          \"action\": \"display final score in score text\"\n        },\n        {\n          \"action\": \"enable restart and main menu buttons\"\n        }\n      ]\n    },\n    {\n      \"name\": \"restart_game\",\n      \"trigger\": \"when restart button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"reload current game scene\"\n        },\n        {\n          \"action\": \"hide game over screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_main_menu\",\n      \"trigger\": \"when main menu button is clicked\",\n      \"actions\": [\n        {\n          \"action\": \"load main menu scene\"\n        },\n        {\n          \"action\": \"hide game over screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_input_shortcuts\",\n      \"trigger\": \"when R key is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"restart game immediately\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class GameOverScreen : MonoBehaviour\n{\n    [Header(\"UI Elements\")]\n    [SerializeField] private GameObject _gameOverPanel;\n    [SerializeField] private Text _gameOverText;\n    [SerializeField] private Text _finalScoreText;\n    [SerializeField] private Text _highScoreText;\n    [SerializeField] private Button _restartButton;\n    [SerializeField] private Button _mainMenuButton;\n    [SerializeField] private Button _quitButton;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 1f;\n    [SerializeField] private float _delayBeforeShow = 0.5f;\n    [SerializeField] private AnimationCurve _fadeInCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _gameOverSound;\n    [SerializeField] private AudioClip _buttonClickSound;\n    \n    [Header(\"Scene Management\")]\n    [SerializeField] private string _gameSceneName = \"GameScene\";\n    [SerializeField] private string _mainMenuSceneName = \"MainMenu\";\n    \n    private CanvasGroup _canvasGroup;\n    private int _currentScore;\n    private int _highScore;\n    private bool _isShowing = false;\n    \n    private void Awake()\n    {\n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupButtons();\n        HideGameOverScreen();\n    }\n    \n    private void Start()\n    {\n        LoadHighScore();\n    }\n    \n    private void SetupButtons()\n    {\n        if (_restartButton != null)\n            _restartButton.onClick.AddListener(RestartGame);\n            \n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.AddListener(GoToMainMenu);\n            \n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(QuitGame);\n    }\n    \n    public void ShowGameOverScreen(int finalScore = 0)\n    {\n        if (_isShowing) return;\n        \n        _currentScore = finalScore;\n        UpdateHighScore();\n        StartCoroutine(ShowGameOverCoroutine());\n    }\n    \n    private IEnumerator ShowGameOverCoroutine()\n    {\n        _isShowing = true;\n        \n        yield return new WaitForSeconds(_delayBeforeShow);\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(true);\n            \n        PlayGameOverSound();\n        UpdateScoreTexts();\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.unscaledDeltaTime;\n            float normalizedTime = elapsedTime / _fadeInDuration;\n            float curveValue = _fadeInCurve.Evaluate(normalizedTime);\n            \n            _canvasGroup.alpha = curveValue;\n            \n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n        _canvasGroup.interactable = true;\n        _canvasGroup.blocksRaycasts = true;\n    }\n    \n    public void HideGameOverScreen()\n    {\n        _isShowing = false;\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n            \n        _canvasGroup.alpha = 0f;\n        _canvasGroup.interactable = false;\n        _canvasGroup.blocksRaycasts = false;\n    }\n    \n    private void UpdateScoreTexts()\n    {\n        if (_finalScoreText != null)\n            _finalScoreText.text = \"Final Score: \" + _currentScore.ToString();\n            \n        if (_highScoreText != null)\n            _highScoreText.text = \"High Score: \" + _highScore.ToString();\n            \n        if (_gameOverText != null && _currentScore >= _highScore && _currentScore > 0)\n            _gameOverText.text = \"NEW HIGH SCORE!\";\n    }\n    \n    private void UpdateHighScore()\n    {\n        if (_currentScore > _highScore)\n        {\n            _highScore = _currentScore;\n            SaveHighScore();\n        }\n    }\n    \n    private void LoadHighScore()\n    {\n        _highScore = PlayerPrefs.GetInt(\"HighScore\", 0);\n    }\n    \n    private void SaveHighScore()\n    {\n        PlayerPrefs.SetInt(\"HighScore\", _highScore);\n        PlayerPrefs.Save();\n    }\n    \n    private void PlayGameOverSound()\n    {\n        if (_audioSource != null && _gameOverSound != null)\n            _audioSource.PlayOneShot(_gameOverSound);\n    }\n    \n    private void PlayButtonClickSound()\n    {\n        if (_audioSource != null && _buttonClickSound != null)\n            _audioSource.PlayOneShot(_buttonClickSound);\n    }\n    \n    public void RestartGame()\n    {\n        PlayButtonClickSound();\n        Time.timeScale = 1f;\n        SceneManager.LoadScene(_gameSceneName);\n    }\n    \n    public void GoToMainMenu()\n    {\n        PlayButtonClickSound();\n        Time.timeScale = 1f;\n        SceneManager.LoadScene(_mainMenuSceneName);\n    }\n    \n    public void QuitGame()\n    {\n        PlayButtonClickSound();\n        \n#if UNITY_EDITOR\n        UnityEditor.EditorApplication.isPlaying = false;\n#else\n        Application.Quit();\n#endif\n    }\n    \n    private void OnDestroy()\n    {\n        if (_restartButton != null)\n            _restartButton.onClick.RemoveAllListeners();\n            \n        if (_mainMenuButton != null)\n            _mainMenuButton.onClick.RemoveAllListeners();\n            \n        if (_quitButton != null)\n            _quitButton.onClick.RemoveAllListeners();\n    }\n    \n    public void SetScore(int score)\n    {\n        _currentScore = score;\n    }\n    \n    public int GetHighScore()\n    {\n        return _highScore;\n    }\n    \n    public bool IsShowing()\n    {\n        return _isShowing;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Scythe\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"sweepDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"sweepRange\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"sweepDuration\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"isSwinging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"onCooldown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_sweep_attack\",\n      \"trigger\": \"when attack input is pressed and not currently swinging and not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"set swinging state to true\"\n        },\n        {\n          \"action\": \"begin sweeping animation\"\n        },\n        {\n          \"action\": \"rotate scythe in wide arc motion\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_enemies_in_range\",\n      \"trigger\": \"while sweeping and enemy enters sweep range\",\n      \"actions\": [\n        {\n          \"action\": \"deal sweep damage to enemy\"\n        },\n        {\n          \"action\": \"apply knockback force to enemy\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_sweep_attack\",\n      \"trigger\": \"when sweep duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set swinging state to false\"\n        },\n        {\n          \"action\": \"return scythe to idle position\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"set cooldown state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_cooldown\",\n      \"trigger\": \"when cooldown time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set cooldown state to false\"\n        },\n        {\n          \"action\": \"enable attack input detection\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ScytheWeapon : MonoBehaviour\n{\n    [Header(\"Attack Settings\")]\n    [SerializeField] private float _attackDamage = 50f;\n    [SerializeField] private float _attackRange = 3f;\n    [SerializeField] private float _sweepAngle = 120f;\n    [SerializeField] private float _attackDuration = 0.5f;\n    [SerializeField] private float _attackCooldown = 1f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Transform _scytheModel;\n    [SerializeField] private float _sweepSpeed = 360f;\n    [SerializeField] private AnimationCurve _sweepCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _slashEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swooshSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent OnAttackStarted;\n    public UnityEvent OnAttackCompleted;\n    \n    private bool _isAttacking = false;\n    private bool _canAttack = true;\n    private float _lastAttackTime;\n    private Vector3 _originalRotation;\n    private HashSet<Collider> _hitTargets = new HashSet<Collider>();\n    \n    private void Start()\n    {\n        if (_scytheModel == null)\n            _scytheModel = transform;\n            \n        _originalRotation = _scytheModel.localEulerAngles;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && _canAttack)\n        {\n            StartAttack();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canAttack && Time.time >= _lastAttackTime + _attackCooldown)\n        {\n            _canAttack = true;\n        }\n    }\n    \n    public void StartAttack()\n    {\n        if (_isAttacking || !_canAttack) return;\n        \n        StartCoroutine(PerformSweepAttack());\n    }\n    \n    private IEnumerator PerformSweepAttack()\n    {\n        _isAttacking = true;\n        _canAttack = false;\n        _lastAttackTime = Time.time;\n        _hitTargets.Clear();\n        \n        OnAttackStarted?.Invoke();\n        \n        if (_audioSource != null && _swooshSound != null)\n            _audioSource.PlayOneShot(_swooshSound);\n            \n        if (_slashEffect != null)\n            _slashEffect.Play();\n        \n        float elapsedTime = 0f;\n        float startAngle = -_sweepAngle * 0.5f;\n        float endAngle = _sweepAngle * 0.5f;\n        \n        while (elapsedTime < _attackDuration)\n        {\n            float progress = elapsedTime / _attackDuration;\n            float curveValue = _sweepCurve.Evaluate(progress);\n            float currentAngle = Mathf.Lerp(startAngle, endAngle, curveValue);\n            \n            _scytheModel.localEulerAngles = _originalRotation + new Vector3(0, 0, currentAngle);\n            \n            CheckForTargets(currentAngle);\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        _scytheModel.localEulerAngles = _originalRotation;\n        _isAttacking = false;\n        \n        OnAttackCompleted?.Invoke();\n    }\n    \n    private void CheckForTargets(float currentAngle)\n    {\n        Vector3 attackDirection = Quaternion.Euler(0, 0, currentAngle) * transform.right;\n        Vector3 attackOrigin = transform.position;\n        \n        Collider[] hitColliders = Physics.OverlapSphere(attackOrigin, _attackRange, _targetLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (_hitTargets.Contains(hitCollider) || hitCollider.transform == transform)\n                continue;\n                \n            Vector3 directionToTarget = (hitCollider.transform.position - attackOrigin).normalized;\n            float angleToTarget = Vector3.Angle(transform.right, directionToTarget);\n            \n            if (angleToTarget <= _sweepAngle * 0.5f)\n            {\n                DealDamage(hitCollider);\n                _hitTargets.Add(hitCollider);\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        if (_audioSource != null && _hitSound != null)\n            _audioSource.PlayOneShot(_hitSound);\n        \n        // Try to damage using common health interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to call common damage methods\n            var damageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (damageMethod != null)\n            {\n                damageMethod.Invoke(healthComponent, new object[] { _attackDamage });\n            }\n            else\n            {\n                // Try alternative method names\n                var altMethod = healthComponent.GetType().GetMethod(\"Damage\");\n                if (altMethod != null)\n                {\n                    altMethod.Invoke(healthComponent, new object[] { _attackDamage });\n                }\n            }\n        }\n        \n        // Apply knockback\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * 10f, ForceMode.Impulse);\n        }\n        \n        OnDamageDealt?.Invoke(_attackDamage);\n        \n        // Destroy objects tagged as destructible\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target.gameObject);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        // Draw sweep arc\n        Vector3 leftBound = Quaternion.Euler(0, 0, -_sweepAngle * 0.5f) * transform.right * _attackRange;\n        Vector3 rightBound = Quaternion.Euler(0, 0, _sweepAngle * 0.5f) * transform.right * _attackRange;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(transform.position, transform.position + leftBound);\n        Gizmos.DrawLine(transform.position, transform.position + rightBound);\n        \n        // Draw arc\n        for (int i = 0; i < 20; i++)\n        {\n            float angle1 = Mathf.Lerp(-_sweepAngle * 0.5f, _sweepAngle * 0.5f, i / 19f);\n            float angle2 = Mathf.Lerp(-_sweepAngle * 0.5f, _sweepAngle * 0.5f, (i + 1) / 19f);\n            \n            Vector3 point1 = transform.position + Quaternion.Euler(0, 0, angle1) * transform.right * _attackRange;\n            Vector3 point2 = transform.position + Quaternion.Euler(0, 0, angle2) * transform.right * _attackRange;\n            \n            Gizmos.DrawLine(point1, point2);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WallJumpSlide\",\n  \"components\": [\n    \"Rigidbody2D\",\n    \"Collider2D\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"wallJumpForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"wallSlideSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"wallJumpDirection\",\n      \"type\": \"Vector2\",\n      \"default\": \"1,1\"\n    },\n    {\n      \"name\": \"isWallSliding\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canWallJump\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"wallJumpCooldown\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_wall_contact\",\n      \"trigger\": \"when touching a wall on the left or right side\",\n      \"actions\": [\n        {\n          \"action\": \"enable wall jump ability\"\n        },\n        {\n          \"action\": \"prepare for wall sliding\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_wall_slide\",\n      \"trigger\": \"when touching wall and moving downward and not grounded\",\n      \"actions\": [\n        {\n          \"action\": \"set wall sliding state to true\"\n        },\n        {\n          \"action\": \"reduce downward velocity to wall slide speed\"\n        },\n        {\n          \"action\": \"play wall slide particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"perform_wall_jump\",\n      \"trigger\": \"when jump input pressed while wall sliding or touching wall\",\n      \"actions\": [\n        {\n          \"action\": \"apply wall jump force away from wall and upward\"\n        },\n        {\n          \"action\": \"disable wall jump temporarily for cooldown period\"\n        },\n        {\n          \"action\": \"stop wall sliding\"\n        },\n        {\n          \"action\": \"play wall jump sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_wall_slide\",\n      \"trigger\": \"when no longer touching wall or becomes grounded\",\n      \"actions\": [\n        {\n          \"action\": \"set wall sliding state to false\"\n        },\n        {\n          \"action\": \"restore normal gravity\"\n        },\n        {\n          \"action\": \"stop wall slide particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wall_jump_cooldown\",\n      \"trigger\": \"when wall jump cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"re-enable wall jump ability\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class WallJumpSlide : MonoBehaviour\n{\n    [Header(\"Wall Detection\")]\n    [SerializeField] private LayerMask _wallLayerMask = 1;\n    [SerializeField] private float _wallCheckDistance = 0.6f;\n    [SerializeField] private Transform _wallCheckPoint;\n    \n    [Header(\"Wall Slide\")]\n    [SerializeField] private float _wallSlideSpeed = 2f;\n    [SerializeField] private float _wallSlideGravityScale = 0.3f;\n    \n    [Header(\"Wall Jump\")]\n    [SerializeField] private float _wallJumpForce = 15f;\n    [SerializeField] private Vector2 _wallJumpDirection = new Vector2(1f, 1.2f);\n    [SerializeField] private float _wallJumpTime = 0.2f;\n    [SerializeField] private float _wallJumpCooldown = 0.1f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    [SerializeField] private Transform _groundCheckPoint;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _jumpKey = KeyCode.Space;\n    \n    private Rigidbody2D _rigidbody;\n    private bool _isTouchingWall;\n    private bool _isWallSliding;\n    private bool _isWallJumping;\n    private bool _isGrounded;\n    private float _wallJumpTimer;\n    private float _wallJumpCooldownTimer;\n    private float _originalGravityScale;\n    private int _wallDirection;\n    private float _horizontalInput;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody2D>();\n        _originalGravityScale = _rigidbody.gravityScale;\n        \n        if (_wallCheckPoint == null)\n        {\n            GameObject wallCheck = new GameObject(\"WallCheck\");\n            wallCheck.transform.SetParent(transform);\n            wallCheck.transform.localPosition = new Vector3(0.5f, 0f, 0f);\n            _wallCheckPoint = wallCheck.transform;\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheck = new GameObject(\"GroundCheck\");\n            groundCheck.transform.SetParent(transform);\n            groundCheck.transform.localPosition = new Vector3(0f, -0.5f, 0f);\n            _groundCheckPoint = groundCheck.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        _horizontalInput = Input.GetAxisRaw(\"Horizontal\");\n        \n        CheckWallTouch();\n        CheckGrounded();\n        HandleWallSlide();\n        HandleWallJump();\n        \n        if (_wallJumpTimer > 0)\n        {\n            _wallJumpTimer -= Time.deltaTime;\n        }\n        else\n        {\n            _isWallJumping = false;\n        }\n        \n        if (_wallJumpCooldownTimer > 0)\n        {\n            _wallJumpCooldownTimer -= Time.deltaTime;\n        }\n    }\n    \n    private void CheckWallTouch()\n    {\n        _isTouchingWall = false;\n        _wallDirection = 0;\n        \n        // Check right wall\n        RaycastHit2D rightHit = Physics2D.Raycast(_wallCheckPoint.position, Vector2.right, _wallCheckDistance, _wallLayerMask);\n        if (rightHit.collider != null)\n        {\n            _isTouchingWall = true;\n            _wallDirection = 1;\n        }\n        else\n        {\n            // Check left wall\n            RaycastHit2D leftHit = Physics2D.Raycast(_wallCheckPoint.position, Vector2.left, _wallCheckDistance, _wallLayerMask);\n            if (leftHit.collider != null)\n            {\n                _isTouchingWall = true;\n                _wallDirection = -1;\n            }\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        RaycastHit2D hit = Physics2D.Raycast(_groundCheckPoint.position, Vector2.down, _groundCheckDistance, _groundLayerMask);\n        _isGrounded = hit.collider != null;\n    }\n    \n    private void HandleWallSlide()\n    {\n        if (_isTouchingWall && !_isGrounded && _rigidbody.velocity.y < 0 && !_isWallJumping)\n        {\n            bool shouldSlide = (_wallDirection == 1 && _horizontalInput > 0) || (_wallDirection == -1 && _horizontalInput < 0);\n            \n            if (shouldSlide)\n            {\n                _isWallSliding = true;\n                _rigidbody.gravityScale = _wallSlideGravityScale;\n                \n                if (_rigidbody.velocity.y < -_wallSlideSpeed)\n                {\n                    _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, -_wallSlideSpeed);\n                }\n            }\n            else\n            {\n                StopWallSlide();\n            }\n        }\n        else\n        {\n            StopWallSlide();\n        }\n    }\n    \n    private void StopWallSlide()\n    {\n        if (_isWallSliding)\n        {\n            _isWallSliding = false;\n            _rigidbody.gravityScale = _originalGravityScale;\n        }\n    }\n    \n    private void HandleWallJump()\n    {\n        if (Input.GetKeyDown(_jumpKey) && _isWallSliding && _wallJumpCooldownTimer <= 0)\n        {\n            PerformWallJump();\n        }\n    }\n    \n    private void PerformWallJump()\n    {\n        _isWallJumping = true;\n        _isWallSliding = false;\n        _wallJumpTimer = _wallJumpTime;\n        _wallJumpCooldownTimer = _wallJumpCooldown;\n        \n        _rigidbody.gravityScale = _originalGravityScale;\n        \n        Vector2 jumpDirection = new Vector2(_wallJumpDirection.x * -_wallDirection, _wallJumpDirection.y);\n        jumpDirection.Normalize();\n        \n        _rigidbody.velocity = new Vector2(0f, 0f);\n        _rigidbody.AddForce(jumpDirection * _wallJumpForce, ForceMode2D.Impulse);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_wallCheckPoint != null)\n        {\n            Gizmos.color = _isTouchingWall ? Color.red : Color.green;\n            Gizmos.DrawRay(_wallCheckPoint.position, Vector3.right * _wallCheckDistance);\n            Gizmos.DrawRay(_wallCheckPoint.position, Vector3.left * _wallCheckDistance);\n        }\n        \n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.red : Color.blue;\n            Gizmos.DrawRay(_groundCheckPoint.position, Vector3.down * _groundCheckDistance);\n        }\n        \n        if (_isWallSliding)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LowHealthWarning\",\n  \"components\": [\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healthThreshold\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"flashSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"warningColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"monitor_health\",\n      \"trigger\": \"when player health drops below threshold\",\n      \"actions\": [\n        {\n          \"action\": \"start flashing the warning overlay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"flash_warning\",\n      \"trigger\": \"while health is below threshold\",\n      \"actions\": [\n        {\n          \"action\": \"fade warning color in and out at flash speed\"\n        },\n        {\n          \"action\": \"alternate between transparent and warning color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_warning\",\n      \"trigger\": \"when player health rises above threshold\",\n      \"actions\": [\n        {\n          \"action\": \"stop flashing\"\n        },\n        {\n          \"action\": \"hide warning overlay\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class LowHealthWarning : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth = 100f;\n    [SerializeField] private float _lowHealthThreshold = 25f;\n    \n    [Header(\"Flash Settings\")]\n    [SerializeField] private Image _warningOverlay;\n    [SerializeField] private Color _flashColor = new Color(1f, 0f, 0f, 0.3f);\n    [SerializeField] private float _flashSpeed = 2f;\n    [SerializeField] private AnimationCurve _flashCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _warningSound;\n    [SerializeField] private float _soundInterval = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLowHealthStart;\n    public UnityEvent OnLowHealthEnd;\n    public UnityEvent OnHealthChanged;\n    \n    private bool _isLowHealth = false;\n    private float _flashTimer = 0f;\n    private float _soundTimer = 0f;\n    private Color _originalColor;\n    private Canvas _warningCanvas;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        UpdateHealthState();\n    }\n    \n    private void Update()\n    {\n        if (_isLowHealth)\n        {\n            UpdateFlashEffect();\n            UpdateWarningSound();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_warningOverlay == null)\n        {\n            CreateWarningOverlay();\n        }\n        \n        _originalColor = _warningOverlay.color;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.playOnAwake = false;\n        _audioSource.loop = false;\n    }\n    \n    private void CreateWarningOverlay()\n    {\n        GameObject canvasGO = new GameObject(\"LowHealthWarningCanvas\");\n        canvasGO.transform.SetParent(transform);\n        \n        _warningCanvas = canvasGO.AddComponent<Canvas>();\n        _warningCanvas.renderMode = RenderMode.ScreenSpaceOverlay;\n        _warningCanvas.sortingOrder = 100;\n        \n        CanvasScaler scaler = canvasGO.AddComponent<CanvasScaler>();\n        scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;\n        scaler.referenceResolution = new Vector2(1920, 1080);\n        \n        canvasGO.AddComponent<GraphicRaycaster>();\n        \n        GameObject overlayGO = new GameObject(\"WarningOverlay\");\n        overlayGO.transform.SetParent(canvasGO.transform, false);\n        \n        _warningOverlay = overlayGO.AddComponent<Image>();\n        _warningOverlay.color = Color.clear;\n        \n        RectTransform rectTransform = _warningOverlay.rectTransform;\n        rectTransform.anchorMin = Vector2.zero;\n        rectTransform.anchorMax = Vector2.one;\n        rectTransform.offsetMin = Vector2.zero;\n        rectTransform.offsetMax = Vector2.zero;\n    }\n    \n    private void UpdateFlashEffect()\n    {\n        _flashTimer += Time.deltaTime * _flashSpeed;\n        \n        float curveValue = _flashCurve.Evaluate(Mathf.PingPong(_flashTimer, 1f));\n        Color targetColor = Color.Lerp(Color.clear, _flashColor, curveValue);\n        \n        _warningOverlay.color = targetColor;\n    }\n    \n    private void UpdateWarningSound()\n    {\n        if (_warningSound == null || _audioSource == null) return;\n        \n        _soundTimer += Time.deltaTime;\n        \n        if (_soundTimer >= _soundInterval)\n        {\n            _audioSource.PlayOneShot(_warningSound);\n            _soundTimer = 0f;\n        }\n    }\n    \n    private void UpdateHealthState()\n    {\n        bool shouldShowWarning = _currentHealth <= _lowHealthThreshold && _currentHealth > 0f;\n        \n        if (shouldShowWarning && !_isLowHealth)\n        {\n            StartLowHealthWarning();\n        }\n        else if (!shouldShowWarning && _isLowHealth)\n        {\n            StopLowHealthWarning();\n        }\n        \n        OnHealthChanged?.Invoke();\n    }\n    \n    private void StartLowHealthWarning()\n    {\n        _isLowHealth = true;\n        _flashTimer = 0f;\n        _soundTimer = 0f;\n        \n        if (_warningCanvas != null)\n        {\n            _warningCanvas.gameObject.SetActive(true);\n        }\n        \n        OnLowHealthStart?.Invoke();\n    }\n    \n    private void StopLowHealthWarning()\n    {\n        _isLowHealth = false;\n        \n        if (_warningOverlay != null)\n        {\n            _warningOverlay.color = Color.clear;\n        }\n        \n        if (_warningCanvas != null)\n        {\n            _warningCanvas.gameObject.SetActive(false);\n        }\n        \n        OnLowHealthEnd?.Invoke();\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (damage < 0f) return;\n        \n        _currentHealth = Mathf.Max(0f, _currentHealth - damage);\n        UpdateHealthState();\n    }\n    \n    public void Heal(float healAmount)\n    {\n        if (healAmount < 0f) return;\n        \n        _currentHealth = Mathf.Min(_maxHealth, _currentHealth + healAmount);\n        UpdateHealthState();\n    }\n    \n    public void SetHealth(float health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        UpdateHealthState();\n    }\n    \n    public void SetMaxHealth(float maxHealth)\n    {\n        if (maxHealth <= 0f) return;\n        \n        float healthPercentage = _currentHealth / _maxHealth;\n        _maxHealth = maxHealth;\n        _currentHealth = _maxHealth * healthPercentage;\n        UpdateHealthState();\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _maxHealth > 0f ? _currentHealth / _maxHealth : 0f;\n    }\n    \n    public bool IsLowHealth()\n    {\n        return _isLowHealth;\n    }\n    \n    private void OnValidate()\n    {\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _lowHealthThreshold = Mathf.Clamp(_lowHealthThreshold, 0f, _maxHealth);\n        _flashSpeed = Mathf.Max(0.1f, _flashSpeed);\n        _soundInterval = Mathf.Max(0.1f, _soundInterval);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TeamColorIndicator\",\n  \"components\": [\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"teamColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.white\"\n    },\n    {\n      \"name\": \"isFlashing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"flashSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_team_color\",\n      \"trigger\": \"when object starts\",\n      \"actions\": [\n        {\n          \"action\": \"set renderer material color to team color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_team_color\",\n      \"trigger\": \"when team color changes\",\n      \"actions\": [\n        {\n          \"action\": \"set renderer material color to new team color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"flash_indicator\",\n      \"trigger\": \"when flashing is enabled\",\n      \"actions\": [\n        {\n          \"action\": \"alternate between team color and transparent at flash speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_flashing\",\n      \"trigger\": \"when flashing is disabled\",\n      \"actions\": [\n        {\n          \"action\": \"set renderer material color to solid team color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class TeamColorIndicator : MonoBehaviour\n{\n    [System.Serializable]\n    public class TeamData\n    {\n        public string teamName;\n        public Color teamColor;\n        public Sprite teamIcon;\n    }\n\n    [Header(\"Team Configuration\")]\n    [SerializeField] private TeamData[] _teams = new TeamData[]\n    {\n        new TeamData { teamName = \"Red Team\", teamColor = Color.red },\n        new TeamData { teamName = \"Blue Team\", teamColor = Color.blue },\n        new TeamData { teamName = \"Green Team\", teamColor = Color.green },\n        new TeamData { teamName = \"Yellow Team\", teamColor = Color.yellow }\n    };\n    \n    [SerializeField] private int _currentTeamIndex = 0;\n\n    [Header(\"Visual Components\")]\n    [SerializeField] private Renderer _meshRenderer;\n    [SerializeField] private SpriteRenderer _spriteRenderer;\n    [SerializeField] private Image _uiImage;\n    [SerializeField] private Text _teamNameText;\n    [SerializeField] private Light _indicatorLight;\n    [SerializeField] private ParticleSystem _particleEffect;\n\n    [Header(\"Material Properties\")]\n    [SerializeField] private string _colorPropertyName = \"_Color\";\n    [SerializeField] private string _emissionPropertyName = \"_EmissionColor\";\n    [SerializeField] private bool _useEmission = false;\n    [SerializeField] private float _emissionIntensity = 1.0f;\n\n    [Header(\"Animation\")]\n    [SerializeField] private bool _enablePulse = false;\n    [SerializeField] private float _pulseSpeed = 2.0f;\n    [SerializeField] private float _pulseMinIntensity = 0.5f;\n    [SerializeField] private float _pulseMaxIntensity = 1.0f;\n\n    [Header(\"Events\")]\n    public UnityEngine.Events.UnityEvent<int> OnTeamChanged;\n    public UnityEngine.Events.UnityEvent<string> OnTeamNameChanged;\n    public UnityEngine.Events.UnityEvent<Color> OnTeamColorChanged;\n\n    private Material _originalMaterial;\n    private Material _instanceMaterial;\n    private Color _originalColor;\n    private float _pulseTimer;\n\n    public int CurrentTeamIndex \n    { \n        get => _currentTeamIndex; \n        set => SetTeam(value); \n    }\n\n    public TeamData CurrentTeam \n    { \n        get => _teams[_currentTeamIndex]; \n    }\n\n    public Color CurrentTeamColor \n    { \n        get => _teams[_currentTeamIndex].teamColor; \n    }\n\n    public string CurrentTeamName \n    { \n        get => _teams[_currentTeamIndex].teamName; \n    }\n\n    private void Start()\n    {\n        InitializeMaterials();\n        ApplyTeamColor();\n    }\n\n    private void Update()\n    {\n        if (_enablePulse)\n        {\n            UpdatePulseEffect();\n        }\n    }\n\n    private void InitializeMaterials()\n    {\n        if (_meshRenderer != null && _meshRenderer.material != null)\n        {\n            _originalMaterial = _meshRenderer.material;\n            _instanceMaterial = new Material(_originalMaterial);\n            _meshRenderer.material = _instanceMaterial;\n            _originalColor = _instanceMaterial.color;\n        }\n    }\n\n    public void SetTeam(int teamIndex)\n    {\n        if (teamIndex < 0 || teamIndex >= _teams.Length)\n        {\n            Debug.LogWarning($\"Invalid team index: {teamIndex}. Must be between 0 and {_teams.Length - 1}\");\n            return;\n        }\n\n        _currentTeamIndex = teamIndex;\n        ApplyTeamColor();\n        \n        OnTeamChanged?.Invoke(_currentTeamIndex);\n        OnTeamNameChanged?.Invoke(CurrentTeamName);\n        OnTeamColorChanged?.Invoke(CurrentTeamColor);\n    }\n\n    public void SetTeamByName(string teamName)\n    {\n        for (int i = 0; i < _teams.Length; i++)\n        {\n            if (_teams[i].teamName.Equals(teamName, System.StringComparison.OrdinalIgnoreCase))\n            {\n                SetTeam(i);\n                return;\n            }\n        }\n        Debug.LogWarning($\"Team with name '{teamName}' not found\");\n    }\n\n    public void NextTeam()\n    {\n        SetTeam((_currentTeamIndex + 1) % _teams.Length);\n    }\n\n    public void PreviousTeam()\n    {\n        SetTeam((_currentTeamIndex - 1 + _teams.Length) % _teams.Length);\n    }\n\n    private void ApplyTeamColor()\n    {\n        if (_currentTeamIndex >= _teams.Length) return;\n\n        Color teamColor = _teams[_currentTeamIndex].teamColor;\n        Sprite teamIcon = _teams[_currentTeamIndex].teamIcon;\n\n        // Apply to mesh renderer\n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.SetColor(_colorPropertyName, teamColor);\n            \n            if (_useEmission && _instanceMaterial.HasProperty(_emissionPropertyName))\n            {\n                _instanceMaterial.SetColor(_emissionPropertyName, teamColor * _emissionIntensity);\n                _instanceMaterial.EnableKeyword(\"_EMISSION\");\n            }\n        }\n\n        // Apply to sprite renderer\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = teamColor;\n            if (teamIcon != null)\n            {\n                _spriteRenderer.sprite = teamIcon;\n            }\n        }\n\n        // Apply to UI image\n        if (_uiImage != null)\n        {\n            _uiImage.color = teamColor;\n            if (teamIcon != null)\n            {\n                _uiImage.sprite = teamIcon;\n            }\n        }\n\n        // Apply to text\n        if (_teamNameText != null)\n        {\n            _teamNameText.text = _teams[_currentTeamIndex].teamName;\n            _teamNameText.color = teamColor;\n        }\n\n        // Apply to light\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.color = teamColor;\n        }\n\n        // Apply to particle system\n        if (_particleEffect != null)\n        {\n            var main = _particleEffect.main;\n            main.startColor = teamColor;\n        }\n    }\n\n    private void UpdatePulseEffect()\n    {\n        _pulseTimer += Time.deltaTime * _pulseSpeed;\n        float pulseValue = Mathf.Lerp(_pulseMinIntensity, _pulseMaxIntensity, \n            (Mathf.Sin(_pulseTimer) + 1.0f) * 0.5f);\n\n        Color baseColor = _teams[_currentTeamIndex].teamColor;\n        Color pulsedColor = baseColor * pulseValue;\n\n        if (_instanceMaterial != null)\n        {\n            _instanceMaterial.SetColor(_colorPropertyName, pulsedColor);\n        }\n\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.color = pulsedColor;\n        }\n\n        if (_uiImage != null)\n        {\n            _uiImage.color = pulsedColor;\n        }\n\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.intensity = pulseValue;\n        }\n    }\n\n    public void TogglePulse()\n    {\n        _enablePulse = !_enablePulse;\n        if (!_enablePulse)\n        {\n            ApplyTeamColor();\n        }\n    }\n\n    public void SetPulseEnabled(bool enabled)\n    {\n        _enablePulse = enabled;\n        if (!_enablePulse)\n        {\n            ApplyTeamColor();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_instanceMaterial != null)\n        {\n            DestroyImmediate(_instanceMaterial);\n        }\n    }\n\n    private void OnValidate()\n    {\n        if (_teams == null || _teams.Length == 0)\n        {\n            _teams = new TeamData[]\n            {\n                new TeamData { teamName = \"Red Team\", teamColor = Color.red },\n                new TeamData { teamName = \"Blue Team\", teamColor = Color.blue }\n            };\n        }\n\n        _currentTeamIndex = Mathf.Clamp(_currentTeamIndex, 0, _teams.Length - 1);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HotAirBalloon\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"windStrength\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"bobIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"maxHeight\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"minHeight\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_buoyancy\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force to simulate hot air lift\"\n        }\n      ]\n    },\n    {\n      \"name\": \"gentle_bobbing\",\n      \"trigger\": \"continuously while floating\",\n      \"actions\": [\n        {\n          \"action\": \"add subtle up and down movement using sine wave pattern\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wind_drift\",\n      \"trigger\": \"continuously while in air\",\n      \"actions\": [\n        {\n          \"action\": \"apply horizontal force to simulate wind pushing the balloon\"\n        }\n      ]\n    },\n    {\n      \"name\": \"height_limit\",\n      \"trigger\": \"when balloon reaches maximum height\",\n      \"actions\": [\n        {\n          \"action\": \"reduce upward force to prevent going too high\"\n        }\n      ]\n    },\n    {\n      \"name\": \"minimum_altitude\",\n      \"trigger\": \"when balloon drops below minimum height\",\n      \"actions\": [\n        {\n          \"action\": \"increase upward force to maintain floating altitude\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HotAirBalloon : MonoBehaviour\n{\n    [Header(\"Balloon Physics\")]\n    [SerializeField] private float _baseFloatForce = 10f;\n    [SerializeField] private float _maxAltitude = 50f;\n    [SerializeField] private float _windStrength = 2f;\n    [SerializeField] private float _bobAmplitude = 0.5f;\n    [SerializeField] private float _bobFrequency = 1f;\n    \n    [Header(\"Heat Control\")]\n    [SerializeField] private float _heatDecayRate = 1f;\n    [SerializeField] private float _maxHeat = 100f;\n    [SerializeField] private float _minFloatHeat = 20f;\n    [SerializeField] private KeyCode _heatKey = KeyCode.Space;\n    [SerializeField] private float _heatIncreaseRate = 30f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _flameParticles;\n    [SerializeField] private Transform _basket;\n    [SerializeField] private Transform _balloon;\n    [SerializeField] private float _basketSwayAmount = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _flameAudioSource;\n    [SerializeField] private AudioClip _flameSound;\n    \n    private Rigidbody _rigidbody;\n    private float _currentHeat;\n    private float _bobTimer;\n    private Vector3 _windDirection;\n    private float _windTimer;\n    private Vector3 _initialBasketPosition;\n    private Vector3 _initialBalloonPosition;\n    private bool _isPlayerControlled;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        \n        _currentHeat = _maxHeat * 0.7f;\n        _windDirection = new Vector3(Random.Range(-1f, 1f), 0, Random.Range(-1f, 1f)).normalized;\n        \n        if (_basket != null)\n            _initialBasketPosition = _basket.localPosition;\n        if (_balloon != null)\n            _initialBalloonPosition = _balloon.localPosition;\n            \n        if (_flameAudioSource == null && _flameSound != null)\n        {\n            _flameAudioSource = gameObject.AddComponent<AudioSource>();\n            _flameAudioSource.clip = _flameSound;\n            _flameAudioSource.loop = true;\n            _flameAudioSource.playOnAwake = false;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateHeat();\n        UpdateVisualEffects();\n        UpdateAudio();\n        _bobTimer += Time.deltaTime;\n        _windTimer += Time.deltaTime;\n        \n        if (_windTimer >= 5f)\n        {\n            _windDirection = new Vector3(Random.Range(-1f, 1f), 0, Random.Range(-1f, 1f)).normalized;\n            _windTimer = 0f;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyFloatForce();\n        ApplyWindForce();\n        ApplyBobbing();\n        LimitAltitude();\n        UpdateBasketSway();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKey(_heatKey))\n        {\n            _currentHeat = Mathf.Min(_currentHeat + _heatIncreaseRate * Time.deltaTime, _maxHeat);\n            _isPlayerControlled = true;\n        }\n        else\n        {\n            _isPlayerControlled = false;\n        }\n    }\n    \n    private void UpdateHeat()\n    {\n        _currentHeat = Mathf.Max(_currentHeat - _heatDecayRate * Time.deltaTime, 0f);\n    }\n    \n    private void ApplyFloatForce()\n    {\n        if (_currentHeat > _minFloatHeat)\n        {\n            float heatRatio = (_currentHeat - _minFloatHeat) / (_maxHeat - _minFloatHeat);\n            float floatForce = _baseFloatForce * heatRatio;\n            \n            Vector3 upwardForce = Vector3.up * floatForce;\n            _rigidbody.AddForce(upwardForce, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyWindForce()\n    {\n        Vector3 windForce = _windDirection * _windStrength;\n        windForce.y = 0f;\n        _rigidbody.AddForce(windForce, ForceMode.Force);\n    }\n    \n    private void ApplyBobbing()\n    {\n        float bobOffset = Mathf.Sin(_bobTimer * _bobFrequency) * _bobAmplitude;\n        Vector3 bobForce = Vector3.up * bobOffset;\n        _rigidbody.AddForce(bobForce, ForceMode.Force);\n    }\n    \n    private void LimitAltitude()\n    {\n        if (transform.position.y > _maxAltitude)\n        {\n            Vector3 downwardForce = Vector3.down * (_baseFloatForce * 2f);\n            _rigidbody.AddForce(downwardForce, ForceMode.Force);\n        }\n    }\n    \n    private void UpdateBasketSway()\n    {\n        if (_basket != null)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            float swayX = -velocity.x * _basketSwayAmount * 0.1f;\n            float swayZ = -velocity.z * _basketSwayAmount * 0.1f;\n            \n            Vector3 targetPosition = _initialBasketPosition + new Vector3(swayX, 0, swayZ);\n            _basket.localPosition = Vector3.Lerp(_basket.localPosition, targetPosition, Time.deltaTime * 2f);\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_flameParticles != null)\n        {\n            var emission = _flameParticles.emission;\n            \n            if (_isPlayerControlled && _currentHeat < _maxHeat)\n            {\n                if (!_flameParticles.isPlaying)\n                    _flameParticles.Play();\n                    \n                emission.rateOverTime = Mathf.Lerp(10f, 50f, (_currentHeat / _maxHeat));\n            }\n            else\n            {\n                if (_flameParticles.isPlaying)\n                    _flameParticles.Stop();\n            }\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_flameAudioSource != null)\n        {\n            if (_isPlayerControlled && _currentHeat < _maxHeat)\n            {\n                if (!_flameAudioSource.isPlaying)\n                    _flameAudioSource.Play();\n                    \n                _flameAudioSource.volume = Mathf.Lerp(0.1f, 0.8f, (_currentHeat / _maxHeat));\n            }\n            else\n            {\n                if (_flameAudioSource.isPlaying)\n                    _flameAudioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerControlled = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerControlled = false;\n        }\n    }\n    \n    public float GetHeatPercentage()\n    {\n        return _currentHeat / _maxHeat;\n    }\n    \n    public bool IsFloating()\n    {\n        return _currentHeat > _minFloatHeat;\n    }\n    \n    public void AddHeat(float amount)\n    {\n        _currentHeat = Mathf.Min(_currentHeat + amount, _maxHeat);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Grenade\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionDelay\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 1000.0\n    },\n    {\n      \"name\": \"hasExploded\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_countdown\",\n      \"trigger\": \"when grenade is created or thrown\",\n      \"actions\": [\n        {\n          \"action\": \"start countdown timer for explosion delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode\",\n      \"trigger\": \"when countdown timer reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect at grenade position\"\n        },\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"find all objects within explosion radius\"\n        },\n        {\n          \"action\": \"apply explosion damage to damageable objects in range\"\n        },\n        {\n          \"action\": \"apply explosion force to rigidbodies in range\"\n        },\n        {\n          \"action\": \"mark grenade as exploded\"\n        },\n        {\n          \"action\": \"destroy grenade object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class Grenade : MonoBehaviour\n{\n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionDelay = 3f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _damage = 100f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private ParticleSystem _fuseParticles;\n    [SerializeField] private Light _fuseLight;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _fuseSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _bounceForce = 0.3f;\n    [SerializeField] private int _maxBounces = 3;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _hasExploded = false;\n    private bool _fuseStarted = false;\n    private int _bounceCount = 0;\n    private float _fuseTimer = 0f;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Start()\n    {\n        StartFuse();\n    }\n    \n    private void Update()\n    {\n        if (_fuseStarted && !_hasExploded)\n        {\n            _fuseTimer += Time.deltaTime;\n            \n            UpdateFuseEffects();\n            \n            if (_fuseTimer >= _explosionDelay)\n            {\n                Explode();\n            }\n        }\n    }\n    \n    private void StartFuse()\n    {\n        _fuseStarted = true;\n        _fuseTimer = 0f;\n        \n        if (_fuseParticles != null)\n            _fuseParticles.Play();\n            \n        if (_fuseLight != null)\n            _fuseLight.enabled = true;\n            \n        if (_audioSource != null && _fuseSound != null)\n        {\n            _audioSource.clip = _fuseSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void UpdateFuseEffects()\n    {\n        float timeRemaining = _explosionDelay - _fuseTimer;\n        float normalizedTime = 1f - (timeRemaining / _explosionDelay);\n        \n        if (_fuseLight != null)\n        {\n            _fuseLight.intensity = Mathf.Lerp(0.5f, 2f, normalizedTime);\n            \n            if (timeRemaining < 1f)\n            {\n                _fuseLight.intensity *= Mathf.Sin(Time.time * 20f) * 0.5f + 1f;\n            }\n        }\n        \n        if (_fuseParticles != null && timeRemaining < 1f)\n        {\n            var emission = _fuseParticles.emission;\n            emission.rateOverTime = Mathf.Lerp(10f, 50f, normalizedTime);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded || _bounceCount >= _maxBounces)\n            return;\n            \n        _bounceCount++;\n        \n        Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n        _rigidbody.velocity = bounceDirection * _bounceForce * _rigidbody.velocity.magnitude;\n        \n        if (_audioSource != null && !_audioSource.isPlaying)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.2f);\n            _audioSource.PlayOneShot(_fuseSound, 0.3f);\n        }\n    }\n    \n    private void Explode()\n    {\n        if (_hasExploded)\n            return;\n            \n        _hasExploded = true;\n        \n        CreateExplosionEffects();\n        ApplyExplosionDamage();\n        ApplyExplosionForce();\n        \n        Destroy(gameObject, 0.1f);\n    }\n    \n    private void CreateExplosionEffects()\n    {\n        if (_explosionPrefab != null)\n        {\n            GameObject explosion = Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n            Destroy(explosion, 5f);\n        }\n        \n        if (_audioSource != null && _explosionSound != null)\n        {\n            _audioSource.Stop();\n            _audioSource.loop = false;\n            _audioSource.clip = _explosionSound;\n            _audioSource.volume = 1f;\n            _audioSource.Play();\n        }\n        \n        if (_fuseParticles != null)\n            _fuseParticles.Stop();\n            \n        if (_fuseLight != null)\n            _fuseLight.enabled = false;\n            \n        if (_collider != null)\n            _collider.enabled = false;\n            \n        GetComponent<Renderer>().enabled = false;\n    }\n    \n    private void ApplyExplosionDamage()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider == _collider)\n                continue;\n                \n            float distance = Vector3.Distance(transform.position, hitCollider.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            float finalDamage = _damage * damageMultiplier;\n            \n            if (hitCollider.CompareTag(\"Player\"))\n            {\n                ApplyDamageToTarget(hitCollider.gameObject, finalDamage);\n            }\n            else if (hitCollider.CompareTag(\"Enemy\"))\n            {\n                ApplyDamageToTarget(hitCollider.gameObject, finalDamage);\n            }\n            \n            Destructible destructible = hitCollider.GetComponent<Destructible>();\n            if (destructible != null)\n            {\n                destructible.TakeDamage(finalDamage);\n            }\n        }\n    }\n    \n    private void ApplyDamageToTarget(GameObject target, float damage)\n    {\n        target.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n        \n        CharacterController controller = target.GetComponent<CharacterController>();\n        if (controller != null)\n        {\n            target.SendMessage(\"OnExplosionHit\", damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n    \n    private void ApplyExplosionForce()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _affectedLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider == _collider)\n                continue;\n                \n            Rigidbody hitRigidbody = hitCollider.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, 3f);\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius * 0.5f);\n    }\n    \n    public void SetExplosionDelay(float delay)\n    {\n        _explosionDelay = delay;\n    }\n    \n    public void SetExplosionRadius(float radius)\n    {\n        _explosionRadius = radius;\n    }\n    \n    public void SetDamage(float damage)\n    {\n        _damage = damage;\n    }\n    \n    public void ExplodeImmediately()\n    {\n        _fuseTimer = _explosionDelay;\n    }\n}\n\npublic class Destructible : MonoBehaviour\n{\n    [Header(\"Destructible Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private GameObject _destroyedPrefab;\n    \n    private float _currentHealth;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0f)\n        {\n            DestroyObject();\n        }\n    }\n    \n    private void DestroyObject()\n    {\n        if (_destroyedPrefab != null)\n        {\n            Instantiate(_destroyedPrefab, transform.position, transform.rotation);\n        }\n        \n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParticleFountain\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"LineRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"spawnRate\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"connectionDistance\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"particleLifetime\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"fountainForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"activeParticles\",\n      \"type\": \"List<ParticleData>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"connectionLines\",\n      \"type\": \"List<LineRenderer>\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_particles_continuously\",\n      \"trigger\": \"every frame based on spawn rate timing\",\n      \"actions\": [\n        {\n          \"action\": \"create new particle with physics rigidbody\"\n        },\n        {\n          \"action\": \"apply upward fountain force to particle\"\n        },\n        {\n          \"action\": \"assign unique color based on current spawn time\"\n        },\n        {\n          \"action\": \"add particle to active particles list\"\n        },\n        {\n          \"action\": \"set particle lifetime countdown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_nearest_particles\",\n      \"trigger\": \"every frame for each active particle\",\n      \"actions\": [\n        {\n          \"action\": \"find closest other particle to current particle\"\n        },\n        {\n          \"action\": \"calculate distance to nearest particle\"\n        },\n        {\n          \"action\": \"store nearest particle reference for current particle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"create_connection_lines\",\n      \"trigger\": \"when particle has nearest neighbor within connection distance\",\n      \"actions\": [\n        {\n          \"action\": \"create visual line between particle and nearest neighbor\"\n        },\n        {\n          \"action\": \"update line position to follow both particles\"\n        },\n        {\n          \"action\": \"set line color based on average of both particle colors\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_distant_connections\",\n      \"trigger\": \"when particles move beyond connection distance\",\n      \"actions\": [\n        {\n          \"action\": \"destroy visual line between particles\"\n        },\n        {\n          \"action\": \"remove line from active connections list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cleanup_expired_particles\",\n      \"trigger\": \"when particle lifetime reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"destroy particle and its physics body\"\n        },\n        {\n          \"action\": \"remove all connection lines involving this particle\"\n        },\n        {\n          \"action\": \"remove particle from active particles list\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ParticleFountain : MonoBehaviour\n{\n    [Header(\"Fountain Settings\")]\n    [SerializeField] private float _spawnRate = 100f;\n    [SerializeField] private float _fountainForce = 10f;\n    [SerializeField] private float _spawnRadius = 0.5f;\n    [SerializeField] private float _particleLifetime = 5f;\n    \n    [Header(\"Connection Settings\")]\n    [SerializeField] private float _connectionDistance = 2f;\n    [SerializeField] private Material _lineMaterial;\n    [SerializeField] private float _lineWidth = 0.02f;\n    \n    [Header(\"Particle Prefab\")]\n    [SerializeField] private GameObject _particlePrefab;\n    \n    private List<FountainParticle> _activeParticles = new List<FountainParticle>();\n    private float _lastSpawnTime;\n    private float _spawnInterval;\n    private LineRenderer _lineRenderer;\n    \n    [System.Serializable]\n    public class FountainParticle\n    {\n        public GameObject gameObject;\n        public Rigidbody rigidbody;\n        public Renderer renderer;\n        public float spawnTime;\n        public float lifetime;\n        public FountainParticle nearestParticle;\n        public float distanceToNearest;\n        \n        public FountainParticle(GameObject go, float time)\n        {\n            gameObject = go;\n            rigidbody = go.GetComponent<Rigidbody>();\n            renderer = go.GetComponent<Renderer>();\n            spawnTime = time;\n            lifetime = 0f;\n            distanceToNearest = float.MaxValue;\n        }\n        \n        public bool IsValid()\n        {\n            return gameObject != null;\n        }\n        \n        public Vector3 Position\n        {\n            get { return gameObject != null ? gameObject.transform.position : Vector3.zero; }\n        }\n    }\n    \n    void Start()\n    {\n        _spawnInterval = 1f / _spawnRate;\n        _lastSpawnTime = Time.time;\n        \n        SetupLineRenderer();\n        CreateParticlePrefabIfNeeded();\n    }\n    \n    void Update()\n    {\n        SpawnParticles();\n        UpdateParticles();\n        FindNearestParticles();\n        DrawConnections();\n        CleanupDeadParticles();\n    }\n    \n    void SetupLineRenderer()\n    {\n        _lineRenderer = GetComponent<LineRenderer>();\n        if (_lineRenderer == null)\n        {\n            _lineRenderer = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _lineRenderer.material = _lineMaterial != null ? _lineMaterial : CreateDefaultLineMaterial();\n        _lineRenderer.startWidth = _lineWidth;\n        _lineRenderer.endWidth = _lineWidth;\n        _lineRenderer.useWorldSpace = true;\n        _lineRenderer.positionCount = 0;\n    }\n    \n    Material CreateDefaultLineMaterial()\n    {\n        Material mat = new Material(Shader.Find(\"Sprites/Default\"));\n        mat.color = Color.white;\n        return mat;\n    }\n    \n    void CreateParticlePrefabIfNeeded()\n    {\n        if (_particlePrefab == null)\n        {\n            _particlePrefab = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            _particlePrefab.transform.localScale = Vector3.one * 0.1f;\n            \n            Rigidbody rb = _particlePrefab.GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = _particlePrefab.AddComponent<Rigidbody>();\n            }\n            rb.mass = 0.1f;\n            rb.drag = 0.5f;\n            \n            _particlePrefab.SetActive(false);\n        }\n    }\n    \n    void SpawnParticles()\n    {\n        while (Time.time - _lastSpawnTime >= _spawnInterval)\n        {\n            SpawnSingleParticle();\n            _lastSpawnTime += _spawnInterval;\n        }\n    }\n    \n    void SpawnSingleParticle()\n    {\n        Vector3 spawnPosition = transform.position + Random.insideUnitSphere * _spawnRadius;\n        GameObject particle = Instantiate(_particlePrefab, spawnPosition, Random.rotation);\n        particle.SetActive(true);\n        \n        Rigidbody rb = particle.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 force = (Vector3.up + Random.insideUnitSphere * 0.3f).normalized * _fountainForce;\n            rb.AddForce(force, ForceMode.Impulse);\n        }\n        \n        FountainParticle fountainParticle = new FountainParticle(particle, Time.time);\n        SetParticleColor(fountainParticle);\n        _activeParticles.Add(fountainParticle);\n    }\n    \n    void SetParticleColor(FountainParticle particle)\n    {\n        if (particle.renderer != null)\n        {\n            float hue = (particle.spawnTime * 0.1f) % 1f;\n            Color color = Color.HSVToRGB(hue, 0.8f, 1f);\n            particle.renderer.material.color = color;\n        }\n    }\n    \n    void UpdateParticles()\n    {\n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            if (_activeParticles[i].IsValid())\n            {\n                _activeParticles[i].lifetime = Time.time - _activeParticles[i].spawnTime;\n            }\n        }\n    }\n    \n    void FindNearestParticles()\n    {\n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            FountainParticle current = _activeParticles[i];\n            if (!current.IsValid()) continue;\n            \n            current.nearestParticle = null;\n            current.distanceToNearest = float.MaxValue;\n            \n            for (int j = 0; j < _activeParticles.Count; j++)\n            {\n                if (i == j) continue;\n                \n                FountainParticle other = _activeParticles[j];\n                if (!other.IsValid()) continue;\n                \n                float distance = Vector3.Distance(current.Position, other.Position);\n                \n                if (distance < current.distanceToNearest && distance <= _connectionDistance)\n                {\n                    current.distanceToNearest = distance;\n                    current.nearestParticle = other;\n                }\n            }\n        }\n    }\n    \n    void DrawConnections()\n    {\n        List<Vector3> linePositions = new List<Vector3>();\n        \n        for (int i = 0; i < _activeParticles.Count; i++)\n        {\n            FountainParticle particle = _activeParticles[i];\n            if (!particle.IsValid() || particle.nearestParticle == null || !particle.nearestParticle.IsValid())\n                continue;\n            \n            linePositions.Add(particle.Position);\n            linePositions.Add(particle.nearestParticle.Position);\n        }\n        \n        _lineRenderer.positionCount = linePositions.Count;\n        if (linePositions.Count > 0)\n        {\n            _lineRenderer.SetPositions(linePositions.ToArray());\n        }\n    }\n    \n    void CleanupDeadParticles()\n    {\n        for (int i = _activeParticles.Count - 1; i >= 0; i--)\n        {\n            FountainParticle particle = _activeParticles[i];\n            \n            if (!particle.IsValid() || particle.lifetime > _particleLifetime)\n            {\n                if (particle.IsValid())\n                {\n                    DestroyImmediate(particle.gameObject);\n                }\n                _activeParticles.RemoveAt(i);\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _connectionDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PhasingGhost\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"phaseSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"wanderRadius\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"phaseOpacity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_phasing\",\n      \"trigger\": \"always active\",\n      \"actions\": [\n        {\n          \"action\": \"disable collision with walls and solid objects\"\n        },\n        {\n          \"action\": \"set material transparency to phase opacity level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ethereal_movement\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"float smoothly through the air\"\n        },\n        {\n          \"action\": \"ignore gravity effects\"\n        },\n        {\n          \"action\": \"move in random wandering pattern within wander radius\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ghostly_appearance\",\n      \"trigger\": \"when spawned\",\n      \"actions\": [\n        {\n          \"action\": \"make renderer semi-transparent\"\n        },\n        {\n          \"action\": \"add subtle floating animation\"\n        },\n        {\n          \"action\": \"emit faint ethereal glow effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wall_traversal\",\n      \"trigger\": \"when encountering any solid surface\",\n      \"actions\": [\n        {\n          \"action\": \"continue moving through the obstacle unimpeded\"\n        },\n        {\n          \"action\": \"maintain current movement direction and speed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class GhostController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _phaseSpeed = 5f;\n    [SerializeField] private float _rotationSpeed = 2f;\n    \n    [Header(\"AI Behavior\")]\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private float _wanderRadius = 10f;\n    [SerializeField] private float _wanderTimer = 3f;\n    [SerializeField] private LayerMask _wallLayers = -1;\n    \n    [Header(\"Phasing\")]\n    [SerializeField] private float _phaseTransparency = 0.3f;\n    [SerializeField] private float _normalTransparency = 0.7f;\n    [SerializeField] private float _fadeSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _ghostSound;\n    [SerializeField] private float _soundInterval = 2f;\n    \n    private Vector3 _targetPosition;\n    private Vector3 _wanderTarget;\n    private float _wanderTimer_current;\n    private float _soundTimer;\n    private bool _isPhasing;\n    private bool _chasingPlayer;\n    \n    private Transform _playerTransform;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _ghostMaterial;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.freezeRotation = true;\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n        \n        if (_renderer != null)\n        {\n            _ghostMaterial = _renderer.material;\n            SetTransparency(_normalTransparency);\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = _ghostSound;\n        _audioSource.loop = false;\n        _audioSource.spatialBlend = 1f;\n        \n        _wanderTimer_current = _wanderTimer;\n        SetNewWanderTarget();\n    }\n    \n    private void Update()\n    {\n        DetectPlayer();\n        HandleMovement();\n        HandlePhasing();\n        HandleAudio();\n        UpdateTransparency();\n    }\n    \n    private void DetectPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        \n        if (player != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, player.transform.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                _playerTransform = player.transform;\n                _chasingPlayer = true;\n                _targetPosition = _playerTransform.position;\n            }\n            else\n            {\n                _chasingPlayer = false;\n                _playerTransform = null;\n            }\n        }\n        else\n        {\n            _chasingPlayer = false;\n            _playerTransform = null;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_chasingPlayer && _playerTransform != null)\n        {\n            _targetPosition = _playerTransform.position;\n            MoveTowardsTarget(_phaseSpeed);\n        }\n        else\n        {\n            HandleWandering();\n        }\n        \n        RotateTowardsTarget();\n    }\n    \n    private void HandleWandering()\n    {\n        _wanderTimer_current -= Time.deltaTime;\n        \n        if (_wanderTimer_current <= 0f || Vector3.Distance(transform.position, _wanderTarget) < 1f)\n        {\n            SetNewWanderTarget();\n            _wanderTimer_current = _wanderTimer;\n        }\n        \n        _targetPosition = _wanderTarget;\n        MoveTowardsTarget(_moveSpeed);\n    }\n    \n    private void SetNewWanderTarget()\n    {\n        Vector3 randomDirection = Random.insideUnitSphere * _wanderRadius;\n        randomDirection += transform.position;\n        randomDirection.y = transform.position.y;\n        _wanderTarget = randomDirection;\n    }\n    \n    private void MoveTowardsTarget(float speed)\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        _rigidbody.velocity = direction * speed;\n    }\n    \n    private void RotateTowardsTarget()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandlePhasing()\n    {\n        Vector3 direction = (_targetPosition - transform.position).normalized;\n        RaycastHit hit;\n        \n        bool wallInPath = Physics.Raycast(transform.position, direction, out hit, 2f, _wallLayers);\n        \n        if (wallInPath || _chasingPlayer)\n        {\n            if (!_isPhasing)\n            {\n                StartPhasing();\n            }\n        }\n        else\n        {\n            if (_isPhasing)\n            {\n                StopPhasing();\n            }\n        }\n    }\n    \n    private void StartPhasing()\n    {\n        _isPhasing = true;\n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void StopPhasing()\n    {\n        _isPhasing = false;\n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void UpdateTransparency()\n    {\n        if (_ghostMaterial == null) return;\n        \n        float targetAlpha = _isPhasing ? _phaseTransparency : _normalTransparency;\n        Color currentColor = _ghostMaterial.color;\n        currentColor.a = Mathf.Lerp(currentColor.a, targetAlpha, _fadeSpeed * Time.deltaTime);\n        _ghostMaterial.color = currentColor;\n    }\n    \n    private void SetTransparency(float alpha)\n    {\n        if (_ghostMaterial == null) return;\n        \n        Color color = _ghostMaterial.color;\n        color.a = alpha;\n        _ghostMaterial.color = color;\n        \n        if (_ghostMaterial.HasProperty(\"_Mode\"))\n        {\n            _ghostMaterial.SetFloat(\"_Mode\", 3);\n            _ghostMaterial.SetInt(\"_SrcBlend\", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);\n            _ghostMaterial.SetInt(\"_DstBlend\", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);\n            _ghostMaterial.SetInt(\"_ZWrite\", 0);\n            _ghostMaterial.DisableKeyword(\"_ALPHATEST_ON\");\n            _ghostMaterial.EnableKeyword(\"_ALPHABLEND_ON\");\n            _ghostMaterial.DisableKeyword(\"_ALPHAPREMULTIPLY_ON\");\n            _ghostMaterial.renderQueue = 3000;\n        }\n    }\n    \n    private void HandleAudio()\n    {\n        _soundTimer -= Time.deltaTime;\n        \n        if (_soundTimer <= 0f && _ghostSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_ghostSound);\n            _soundTimer = _soundInterval;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Debug.Log(\"Ghost touched player!\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _wanderRadius);\n        \n        if (_chasingPlayer && _playerTransform != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _playerTransform.position);\n        }\n        else\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _wanderTarget);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwingingAxePendulum\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swingForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"maxSwingAngle\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"damping\",\n      \"type\": \"float\",\n      \"default\": 0.98\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_pendulum\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"apply initial swing force to start pendulum motion\"\n        },\n        {\n          \"action\": \"set pivot point for swinging motion\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_swing\",\n      \"trigger\": \"every frame while swinging\",\n      \"actions\": [\n        {\n          \"action\": \"apply gravitational force to maintain pendulum motion\"\n        },\n        {\n          \"action\": \"limit swing angle to maximum swing angle\"\n        },\n        {\n          \"action\": \"apply damping to gradually reduce swing over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_player\",\n      \"trigger\": \"when axe blade collides with player\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player\"\n        },\n        {\n          \"action\": \"apply knockback force to player in swing direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"environmental_collision\",\n      \"trigger\": \"when axe hits wall or obstacle\",\n      \"actions\": [\n        {\n          \"action\": \"reduce swing momentum\"\n        },\n        {\n          \"action\": \"create impact sound effect\"\n        },\n        {\n          \"action\": \"bounce back slightly from collision point\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SwingingAxePendulum : MonoBehaviour\n{\n    [Header(\"Pendulum Settings\")]\n    [SerializeField] private float _swingAngle = 45f;\n    [SerializeField] private float _swingSpeed = 2f;\n    [SerializeField] private bool _startSwingingOnAwake = true;\n    [SerializeField] private float _delayBeforeStart = 0f;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 50;\n    [SerializeField] private float _damageForce = 10f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _hitParticles;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    \n    private bool _isSwinging = false;\n    private float _currentAngle = 0f;\n    private float _swingDirection = 1f;\n    private AudioSource _audioSource;\n    private Vector3 _initialRotation;\n    private float _startDelay;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _initialRotation = transform.eulerAngles;\n        _startDelay = _delayBeforeStart;\n    }\n    \n    private void Start()\n    {\n        if (_startSwingingOnAwake && _delayBeforeStart <= 0f)\n        {\n            StartSwinging();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_startSwingingOnAwake && _startDelay > 0f)\n        {\n            _startDelay -= Time.deltaTime;\n            if (_startDelay <= 0f)\n            {\n                StartSwinging();\n            }\n        }\n        \n        if (_isSwinging)\n        {\n            UpdateSwing();\n        }\n    }\n    \n    private void UpdateSwing()\n    {\n        _currentAngle += _swingSpeed * _swingDirection * Time.deltaTime * 90f;\n        \n        if (_currentAngle >= _swingAngle)\n        {\n            _currentAngle = _swingAngle;\n            _swingDirection = -1f;\n            PlaySwingSound();\n        }\n        else if (_currentAngle <= -_swingAngle)\n        {\n            _currentAngle = -_swingAngle;\n            _swingDirection = 1f;\n            PlaySwingSound();\n        }\n        \n        Vector3 rotation = _initialRotation;\n        rotation.z += _currentAngle;\n        transform.eulerAngles = rotation;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsInLayerMask(other.gameObject.layer, _damageableLayers))\n        {\n            DealDamage(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsInLayerMask(collision.gameObject.layer, _damageableLayers))\n        {\n            DealDamage(collision.collider);\n            \n            if (_hitParticles != null)\n            {\n                _hitParticles.transform.position = collision.contacts[0].point;\n                _hitParticles.Play();\n            }\n        }\n    }\n    \n    private void DealDamage(Collider target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            Rigidbody targetRb = target.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n                targetRb.AddForce(forceDirection * _damageForce, ForceMode.Impulse);\n            }\n            \n            PlayHitSound();\n        }\n        \n        IDamageable damageable = target.GetComponent<IDamageable>();\n        if (damageable != null)\n        {\n            damageable.TakeDamage(_damage);\n        }\n    }\n    \n    private void PlaySwingSound()\n    {\n        if (_swingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_swingSound, _audioVolume);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound, _audioVolume);\n        }\n    }\n    \n    private bool IsInLayerMask(int layer, LayerMask layerMask)\n    {\n        return (layerMask.value & (1 << layer)) != 0;\n    }\n    \n    public void StartSwinging()\n    {\n        _isSwinging = true;\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n    }\n    \n    public void StopSwinging()\n    {\n        _isSwinging = false;\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n    }\n    \n    public void SetSwingSpeed(float speed)\n    {\n        _swingSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetSwingAngle(float angle)\n    {\n        _swingAngle = Mathf.Clamp(angle, 0f, 90f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Vector3 leftSwing = Quaternion.Euler(0, 0, -_swingAngle) * Vector3.down;\n        Vector3 rightSwing = Quaternion.Euler(0, 0, _swingAngle) * Vector3.down;\n        \n        Gizmos.DrawRay(transform.position, leftSwing * 2f);\n        Gizmos.DrawRay(transform.position, rightSwing * 2f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 0.1f);\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(int damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BreakableWall\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"shatterForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"fragmentCount\",\n      \"type\": \"int\",\n      \"default\": 8\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"shatter_on_impact\",\n      \"trigger\": \"when collision occurs with sufficient force\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by collision force amount\"\n        },\n        {\n          \"action\": \"check if health reaches zero or below\"\n        }\n      ]\n    },\n    {\n      \"name\": \"break_wall\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"create multiple fragment pieces at wall position\"\n        },\n        {\n          \"action\": \"apply explosive force to each fragment in random directions\"\n        },\n        {\n          \"action\": \"play shattering sound effect\"\n        },\n        {\n          \"action\": \"spawn particle effect at break location\"\n        },\n        {\n          \"action\": \"destroy original wall object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_damage\",\n      \"trigger\": \"when health decreases but wall not broken\",\n      \"actions\": [\n        {\n          \"action\": \"display cracks on wall surface based on damage amount\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class BreakableWall : MonoBehaviour\n{\n    [Header(\"Breaking Settings\")]\n    [SerializeField] private float _breakForce = 10f;\n    [SerializeField] private float _health = 100f;\n    [SerializeField] private bool _breakOnAnyImpact = false;\n    [SerializeField] private string[] _breakableTags = { \"Player\", \"Projectile\" };\n    \n    [Header(\"Shatter Effects\")]\n    [SerializeField] private GameObject _shatterPrefab;\n    [SerializeField] private int _fragmentCount = 20;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private Material _fragmentMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnWallBroken;\n    \n    private bool _isBroken = false;\n    private Collider _wallCollider;\n    private MeshRenderer _meshRenderer;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _wallCollider = GetComponent<Collider>();\n        _meshRenderer = GetComponent<MeshRenderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.playOnAwake = false;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isBroken) return;\n        \n        bool canBreak = _breakOnAnyImpact;\n        \n        if (!canBreak)\n        {\n            foreach (string tag in _breakableTags)\n            {\n                if (collision.gameObject.CompareTag(tag))\n                {\n                    canBreak = true;\n                    break;\n                }\n            }\n        }\n        \n        if (canBreak)\n        {\n            float impactForce = collision.relativeVelocity.magnitude;\n            \n            if (impactForce >= _breakForce)\n            {\n                TakeDamage(_health);\n            }\n            else\n            {\n                TakeDamage(impactForce * 10f);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isBroken) return;\n        \n        foreach (string tag in _breakableTags)\n        {\n            if (other.CompareTag(tag))\n            {\n                TakeDamage(_health);\n                break;\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isBroken) return;\n        \n        _health -= damage;\n        \n        if (_health <= 0f)\n        {\n            BreakWall();\n        }\n    }\n    \n    public void BreakWall()\n    {\n        if (_isBroken) return;\n        \n        _isBroken = true;\n        \n        PlayBreakSound();\n        CreateShatterEffect();\n        OnWallBroken?.Invoke();\n        \n        if (_wallCollider != null)\n            _wallCollider.enabled = false;\n        \n        if (_meshRenderer != null)\n            _meshRenderer.enabled = false;\n        \n        StartCoroutine(DestroyAfterDelay(5f));\n    }\n    \n    private void PlayBreakSound()\n    {\n        if (_breakSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _breakSound;\n            _audioSource.volume = _volume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void CreateShatterEffect()\n    {\n        Vector3 center = transform.position;\n        Bounds bounds = GetComponent<Renderer>().bounds;\n        \n        if (_shatterPrefab != null)\n        {\n            GameObject shatterEffect = Instantiate(_shatterPrefab, center, transform.rotation);\n            Destroy(shatterEffect, 10f);\n        }\n        else\n        {\n            CreateProceduralFragments(center, bounds);\n        }\n    }\n    \n    private void CreateProceduralFragments(Vector3 center, Bounds bounds)\n    {\n        for (int i = 0; i < _fragmentCount; i++)\n        {\n            GameObject fragment = CreateFragment(bounds);\n            \n            Vector3 randomPos = new Vector3(\n                Random.Range(bounds.min.x, bounds.max.x),\n                Random.Range(bounds.min.y, bounds.max.y),\n                Random.Range(bounds.min.z, bounds.max.z)\n            );\n            \n            fragment.transform.position = randomPos;\n            \n            Rigidbody rb = fragment.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                Vector3 explosionDir = (randomPos - center).normalized;\n                rb.AddForce(explosionDir * _explosionForce + Vector3.up * _explosionForce * 0.5f);\n                rb.AddTorque(Random.insideUnitSphere * _explosionForce);\n            }\n            \n            Destroy(fragment, Random.Range(3f, 8f));\n        }\n    }\n    \n    private GameObject CreateFragment(Bounds bounds)\n    {\n        GameObject fragment = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        \n        float scale = Random.Range(0.1f, 0.3f);\n        fragment.transform.localScale = Vector3.one * scale;\n        \n        Rigidbody rb = fragment.AddComponent<Rigidbody>();\n        rb.mass = scale;\n        \n        if (_fragmentMaterial != null)\n        {\n            fragment.GetComponent<Renderer>().material = _fragmentMaterial;\n        }\n        else if (_meshRenderer != null && _meshRenderer.material != null)\n        {\n            fragment.GetComponent<Renderer>().material = _meshRenderer.material;\n        }\n        \n        fragment.AddComponent<FragmentBehavior>();\n        \n        return fragment;\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    public void ForceBreak()\n    {\n        BreakWall();\n    }\n    \n    public bool IsBroken()\n    {\n        return _isBroken;\n    }\n    \n    public float GetHealth()\n    {\n        return _health;\n    }\n    \n    private class FragmentBehavior : MonoBehaviour\n    {\n        private void Start()\n        {\n            StartCoroutine(FadeOut());\n        }\n        \n        private IEnumerator FadeOut()\n        {\n            yield return new WaitForSeconds(2f);\n            \n            Renderer renderer = GetComponent<Renderer>();\n            Material material = renderer.material;\n            Color originalColor = material.color;\n            \n            float fadeTime = 1f;\n            float elapsed = 0f;\n            \n            while (elapsed < fadeTime)\n            {\n                elapsed += Time.deltaTime;\n                float alpha = Mathf.Lerp(1f, 0f, elapsed / fadeTime);\n                material.color = new Color(originalColor.r, originalColor.g, originalColor.b, alpha);\n                yield return null;\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpeedMotionBlur\",\n  \"components\": [\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"blurIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"speedThreshold\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxBlurAmount\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_motion_blur_on_high_speed\",\n      \"trigger\": \"when object velocity exceeds speed threshold\",\n      \"actions\": [\n        {\n          \"action\": \"calculate blur amount based on current velocity\"\n        },\n        {\n          \"action\": \"apply motion blur effect to camera or renderer\"\n        },\n        {\n          \"action\": \"clamp blur amount to maximum blur limit\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reduce_motion_blur_on_slow_speed\",\n      \"trigger\": \"when object velocity falls below speed threshold\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce motion blur intensity\"\n        },\n        {\n          \"action\": \"disable motion blur effect when velocity is very low\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_blur_direction\",\n      \"trigger\": \"when object changes movement direction\",\n      \"actions\": [\n        {\n          \"action\": \"update motion blur direction based on velocity vector\"\n        },\n        {\n          \"action\": \"smooth transition between blur directions\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering.PostProcessing;\n\npublic class SpeedMotionBlur : MonoBehaviour\n{\n    [Header(\"Motion Blur Settings\")]\n    [SerializeField] private PostProcessVolume _postProcessVolume;\n    [SerializeField] private float _speedThreshold = 5f;\n    [SerializeField] private float _maxBlurIntensity = 0.8f;\n    [SerializeField] private float _blurTransitionSpeed = 2f;\n    [SerializeField] private AnimationCurve _blurCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Speed Detection\")]\n    [SerializeField] private Transform _targetTransform;\n    [SerializeField] private bool _useRigidbody = true;\n    [SerializeField] private bool _detectVerticalSpeed = true;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    \n    private MotionBlur _motionBlur;\n    private Rigidbody _rigidbody;\n    private Vector3 _lastPosition;\n    private float _currentSpeed;\n    private float _targetBlurIntensity;\n    private float _currentBlurIntensity;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupMotionBlur();\n        \n        if (_targetTransform == null)\n            _targetTransform = transform;\n            \n        _lastPosition = _targetTransform.position;\n    }\n    \n    void InitializeComponents()\n    {\n        if (_postProcessVolume == null)\n            _postProcessVolume = FindObjectOfType<PostProcessVolume>();\n            \n        if (_postProcessVolume == null)\n        {\n            Debug.LogError(\"SpeedMotionBlur: No PostProcessVolume found in scene!\");\n            enabled = false;\n            return;\n        }\n        \n        if (_useRigidbody && _targetTransform != null)\n            _rigidbody = _targetTransform.GetComponent<Rigidbody>();\n    }\n    \n    void SetupMotionBlur()\n    {\n        if (_postProcessVolume.profile.TryGetSettings(out _motionBlur))\n        {\n            _motionBlur.enabled.value = true;\n            _motionBlur.shutterAngle.value = 0f;\n        }\n        else\n        {\n            Debug.LogError(\"SpeedMotionBlur: MotionBlur effect not found in PostProcess profile!\");\n            enabled = false;\n        }\n    }\n    \n    void Update()\n    {\n        CalculateSpeed();\n        UpdateMotionBlur();\n        \n        if (_showDebugInfo)\n            DisplayDebugInfo();\n    }\n    \n    void CalculateSpeed()\n    {\n        if (_targetTransform == null) return;\n        \n        if (_useRigidbody && _rigidbody != null)\n        {\n            Vector3 velocity = _rigidbody.velocity;\n            if (!_detectVerticalSpeed)\n                velocity.y = 0f;\n                \n            _currentSpeed = velocity.magnitude;\n        }\n        else\n        {\n            Vector3 currentPosition = _targetTransform.position;\n            Vector3 deltaPosition = currentPosition - _lastPosition;\n            \n            if (!_detectVerticalSpeed)\n                deltaPosition.y = 0f;\n                \n            _currentSpeed = deltaPosition.magnitude / Time.deltaTime;\n            _lastPosition = currentPosition;\n        }\n    }\n    \n    void UpdateMotionBlur()\n    {\n        if (_motionBlur == null) return;\n        \n        float speedRatio = Mathf.Clamp01((_currentSpeed - _speedThreshold) / _speedThreshold);\n        _targetBlurIntensity = _blurCurve.Evaluate(speedRatio) * _maxBlurIntensity;\n        \n        _currentBlurIntensity = Mathf.Lerp(_currentBlurIntensity, _targetBlurIntensity, \n            Time.deltaTime * _blurTransitionSpeed);\n        \n        float shutterAngle = _currentBlurIntensity * 360f;\n        _motionBlur.shutterAngle.value = shutterAngle;\n    }\n    \n    void DisplayDebugInfo()\n    {\n        Debug.Log($\"Speed: {_currentSpeed:F2} | Blur Intensity: {_currentBlurIntensity:F3} | Shutter Angle: {_motionBlur.shutterAngle.value:F1}\");\n    }\n    \n    public void SetSpeedThreshold(float threshold)\n    {\n        _speedThreshold = Mathf.Max(0f, threshold);\n    }\n    \n    public void SetMaxBlurIntensity(float intensity)\n    {\n        _maxBlurIntensity = Mathf.Clamp01(intensity);\n    }\n    \n    public void SetBlurTransitionSpeed(float speed)\n    {\n        _blurTransitionSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void EnableMotionBlur(bool enable)\n    {\n        if (_motionBlur != null)\n            _motionBlur.enabled.value = enable;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public float GetCurrentBlurIntensity()\n    {\n        return _currentBlurIntensity;\n    }\n    \n    void OnValidate()\n    {\n        _speedThreshold = Mathf.Max(0f, _speedThreshold);\n        _maxBlurIntensity = Mathf.Clamp01(_maxBlurIntensity);\n        _blurTransitionSpeed = Mathf.Max(0.1f, _blurTransitionSpeed);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RangedMeleeEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"meleeRange\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"rangedRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"meleeDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"rangedDamage\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"meleeAttackCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"rangedAttackCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"projectilePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"projectileSpawnPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"start pursuing player\"\n        },\n        {\n          \"action\": \"play alert animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pursue_player\",\n      \"trigger\": \"when player is detected and not in attack range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at move speed\"\n        },\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"play walking animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"melee_attack\",\n      \"trigger\": \"when player is within melee range and melee attack is ready\",\n      \"actions\": [\n        {\n          \"action\": \"stop movement\"\n        },\n        {\n          \"action\": \"play melee attack animation\"\n        },\n        {\n          \"action\": \"deal melee damage to player\"\n        },\n        {\n          \"action\": \"start melee attack cooldown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ranged_attack\",\n      \"trigger\": \"when player is within ranged range but outside melee range and ranged attack is ready\",\n      \"actions\": [\n        {\n          \"action\": \"stop movement\"\n        },\n        {\n          \"action\": \"face toward player\"\n        },\n        {\n          \"action\": \"play ranged attack animation\"\n        },\n        {\n          \"action\": \"spawn projectile at spawn point toward player\"\n        },\n        {\n          \"action\": \"start ranged attack cooldown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt animation\"\n        },\n        {\n          \"action\": \"interrupt current attack if attacking\"\n        }\n      ]\n    },\n    {\n      \"name\": \"die\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"disable collider\"\n        },\n        {\n          \"action\": \"destroy game object after animation completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_player\",\n      \"trigger\": \"when player leaves detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop pursuing player\"\n        },\n        {\n          \"action\": \"return to idle state\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Enemy : MonoBehaviour\n{\n    [Header(\"Health\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 180f;\n    \n    [Header(\"Combat Ranges\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _meleeRange = 2f;\n    [SerializeField] private float _rangedRange = 8f;\n    [SerializeField] private float _attackCooldown = 2f;\n    \n    [Header(\"Melee Attack\")]\n    [SerializeField] private float _meleeDamage = 25f;\n    [SerializeField] private float _meleeAttackDuration = 0.5f;\n    \n    [Header(\"Ranged Attack\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _projectileSpeed = 10f;\n    [SerializeField] private float _rangedDamage = 15f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnMeleeAttack;\n    public UnityEvent OnRangedAttack;\n    \n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private float _lastAttackTime;\n    private bool _isAttacking;\n    private EnemyState _currentState;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        MeleeAttacking,\n        RangedAttacking,\n        Dead\n    }\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _currentState = EnemyState.Idle;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_firePoint == null)\n        {\n            GameObject firePointObj = new GameObject(\"FirePoint\");\n            firePointObj.transform.SetParent(transform);\n            firePointObj.transform.localPosition = Vector3.forward;\n            _firePoint = firePointObj.transform;\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        if (_currentState == EnemyState.Dead) return;\n        \n        FindPlayer();\n        UpdateState();\n        HandleState();\n    }\n    \n    private void FindPlayer()\n    {\n        if (_player == null)\n        {\n            GameObject playerObj = GameObject.FindGameObjectWithTag(\"Player\");\n            if (playerObj != null)\n            {\n                _player = playerObj.transform;\n            }\n        }\n    }\n    \n    private void UpdateState()\n    {\n        if (_player == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        if (_isAttacking) return;\n        \n        if (distanceToPlayer > _detectionRange)\n        {\n            _currentState = EnemyState.Idle;\n        }\n        else if (distanceToPlayer <= _meleeRange && CanAttack())\n        {\n            _currentState = EnemyState.MeleeAttacking;\n        }\n        else if (distanceToPlayer <= _rangedRange && distanceToPlayer > _meleeRange && CanAttack())\n        {\n            _currentState = EnemyState.RangedAttacking;\n        }\n        else if (distanceToPlayer <= _detectionRange)\n        {\n            _currentState = EnemyState.Chasing;\n        }\n    }\n    \n    private void HandleState()\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                break;\n                \n            case EnemyState.Chasing:\n                ChasePlayer();\n                break;\n                \n            case EnemyState.MeleeAttacking:\n                PerformMeleeAttack();\n                break;\n                \n            case EnemyState.RangedAttacking:\n                PerformRangedAttack();\n                break;\n        }\n    }\n    \n    private void ChasePlayer()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = (_player.position - transform.position).normalized;\n        direction.y = 0;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.deltaTime);\n        \n        if (direction != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void PerformMeleeAttack()\n    {\n        if (_isAttacking) return;\n        \n        StartCoroutine(MeleeAttackCoroutine());\n    }\n    \n    private System.Collections.IEnumerator MeleeAttackCoroutine()\n    {\n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnMeleeAttack?.Invoke();\n        \n        yield return new WaitForSeconds(_meleeAttackDuration);\n        \n        if (_player != null && Vector3.Distance(transform.position, _player.position) <= _meleeRange)\n        {\n            DealDamageToPlayer(_meleeDamage);\n        }\n        \n        _isAttacking = false;\n    }\n    \n    private void PerformRangedAttack()\n    {\n        if (_isAttacking) return;\n        \n        _isAttacking = true;\n        _lastAttackTime = Time.time;\n        \n        OnRangedAttack?.Invoke();\n        \n        FireProjectile();\n        \n        Invoke(nameof(ResetAttacking), 0.5f);\n    }\n    \n    private void FireProjectile()\n    {\n        if (_projectilePrefab == null || _player == null) return;\n        \n        Vector3 direction = (_player.position - _firePoint.position).normalized;\n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, Quaternion.LookRotation(direction));\n        \n        EnemyProjectile projectileScript = projectile.GetComponent<EnemyProjectile>();\n        if (projectileScript == null)\n        {\n            projectileScript = projectile.AddComponent<EnemyProjectile>();\n        }\n        \n        projectileScript.Initialize(direction, _projectileSpeed, _rangedDamage);\n    }\n    \n    private void ResetAttacking()\n    {\n        _isAttacking = false;\n    }\n    \n    private bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    private void DealDamageToPlayer(float damage)\n    {\n        if (_player == null) return;\n        \n        _player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_currentState == EnemyState.Dead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _currentState = EnemyState.Dead;\n        OnDeath?.Invoke();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        Collider[] colliders = GetComponents<Collider>();\n        foreach (Collider col in colliders)\n        {\n            col.enabled = false;\n        }\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _rangedRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _meleeRange);\n    }\n}\n\npublic class EnemyProjectile : MonoBehaviour\n{\n    private Vector3 _direction;\n    private float _speed;\n    private float _damage;\n    private float _lifetime = 5f;\n    \n    public void Initialize(Vector3 direction, float speed, float damage)\n    {\n        _direction = direction;\n        _speed = speed;\n        _damage = damage;\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void Update()\n    {\n        transform.Translate(_direction * _speed * Time.deltaTime, Space.World);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            other.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            Destroy(gameObject);\n        }\n        else if (!other.isTrigger && !other.CompareTag(\"Enemy\"))\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DroppingSpider\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dropHeight\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"dropSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"waitTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isDropping\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isWaiting\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"originalHeight\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_below\",\n      \"trigger\": \"when player enters detection range directly below spider\",\n      \"actions\": [\n        {\n          \"action\": \"store current height as original height\"\n        },\n        {\n          \"action\": \"set dropping state to true\"\n        },\n        {\n          \"action\": \"play dropping animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drop_down\",\n      \"trigger\": \"when spider is in dropping state\",\n      \"actions\": [\n        {\n          \"action\": \"move downward at drop speed\"\n        },\n        {\n          \"action\": \"disable gravity temporarily\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_on_ground\",\n      \"trigger\": \"when spider touches ground while dropping\",\n      \"actions\": [\n        {\n          \"action\": \"set dropping state to false\"\n        },\n        {\n          \"action\": \"set waiting state to true\"\n        },\n        {\n          \"action\": \"play landing animation\"\n        },\n        {\n          \"action\": \"enable gravity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wait_after_landing\",\n      \"trigger\": \"when spider is in waiting state\",\n      \"actions\": [\n        {\n          \"action\": \"remain stationary for wait time duration\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_back_up\",\n      \"trigger\": \"when wait time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set waiting state to false\"\n        },\n        {\n          \"action\": \"move upward at climb speed toward original height\"\n        },\n        {\n          \"action\": \"play climbing animation\"\n        },\n        {\n          \"action\": \"disable gravity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reach_original_position\",\n      \"trigger\": \"when spider reaches original height\",\n      \"actions\": [\n        {\n          \"action\": \"stop upward movement\"\n        },\n        {\n          \"action\": \"play hanging animation\"\n        },\n        {\n          \"action\": \"reset to initial state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SpiderDrop : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    [SerializeField] private float _detectionHeight = 10f;\n    \n    [Header(\"Drop Behavior\")]\n    [SerializeField] private float _dropSpeed = 8f;\n    [SerializeField] private float _dropDelay = 0.5f;\n    [SerializeField] private float _maxDropDistance = 15f;\n    [SerializeField] private bool _returnToStart = true;\n    [SerializeField] private float _returnSpeed = 3f;\n    [SerializeField] private float _returnDelay = 2f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _dropSound;\n    [SerializeField] private AudioClip _landSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDropStart;\n    public UnityEvent OnLanded;\n    public UnityEvent OnReturnComplete;\n    \n    private enum SpiderState\n    {\n        Waiting,\n        Dropping,\n        OnGround,\n        Returning\n    }\n    \n    private SpiderState _currentState = SpiderState.Waiting;\n    private Vector3 _startPosition;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Transform _playerTransform;\n    private float _dropTimer;\n    private float _returnTimer;\n    private bool _hasDropped;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n    }\n    \n    private void Update()\n    {\n        switch (_currentState)\n        {\n            case SpiderState.Waiting:\n                HandleWaitingState();\n                break;\n            case SpiderState.Dropping:\n                HandleDroppingState();\n                break;\n            case SpiderState.OnGround:\n                HandleGroundState();\n                break;\n            case SpiderState.Returning:\n                HandleReturningState();\n                break;\n        }\n    }\n    \n    private void HandleWaitingState()\n    {\n        if (_hasDropped && !_returnToStart)\n            return;\n            \n        DetectPlayer();\n        \n        if (_playerTransform != null && _dropTimer > 0f)\n        {\n            _dropTimer -= Time.deltaTime;\n            if (_dropTimer <= 0f)\n            {\n                StartDrop();\n            }\n        }\n    }\n    \n    private void HandleDroppingState()\n    {\n        if (IsGrounded() || HasDroppedMaxDistance())\n        {\n            Land();\n        }\n    }\n    \n    private void HandleGroundState()\n    {\n        if (_returnToStart)\n        {\n            _returnTimer -= Time.deltaTime;\n            if (_returnTimer <= 0f)\n            {\n                StartReturn();\n            }\n        }\n    }\n    \n    private void HandleReturningState()\n    {\n        Vector3 direction = (_startPosition - transform.position).normalized;\n        transform.position += direction * _returnSpeed * Time.deltaTime;\n        \n        if (Vector3.Distance(transform.position, _startPosition) < 0.1f)\n        {\n            transform.position = _startPosition;\n            _currentState = SpiderState.Waiting;\n            _hasDropped = false;\n            _rigidbody.isKinematic = true;\n            _rigidbody.useGravity = false;\n            OnReturnComplete?.Invoke();\n        }\n    }\n    \n    private void DetectPlayer()\n    {\n        Vector3 detectionCenter = transform.position;\n        detectionCenter.y -= _detectionHeight * 0.5f;\n        \n        Collider[] hits = Physics.OverlapCylinder(\n            detectionCenter - Vector3.up * _detectionHeight * 0.5f,\n            detectionCenter + Vector3.up * _detectionHeight * 0.5f,\n            _detectionRadius,\n            _playerLayer\n        );\n        \n        Transform closestPlayer = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider hit in hits)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestPlayer = hit.transform;\n                }\n            }\n        }\n        \n        if (closestPlayer != null && _playerTransform == null)\n        {\n            _playerTransform = closestPlayer;\n            _dropTimer = _dropDelay;\n        }\n        else if (closestPlayer == null)\n        {\n            _playerTransform = null;\n            _dropTimer = 0f;\n        }\n    }\n    \n    private void StartDrop()\n    {\n        _currentState = SpiderState.Dropping;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        _rigidbody.velocity = Vector3.down * _dropSpeed;\n        \n        PlaySound(_dropSound);\n        OnDropStart?.Invoke();\n    }\n    \n    private void Land()\n    {\n        _currentState = SpiderState.OnGround;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _returnTimer = _returnDelay;\n        _hasDropped = true;\n        _playerTransform = null;\n        \n        PlaySound(_landSound);\n        OnLanded?.Invoke();\n    }\n    \n    private void StartReturn()\n    {\n        _currentState = SpiderState.Returning;\n    }\n    \n    private bool IsGrounded()\n    {\n        return Physics.Raycast(transform.position, Vector3.down, _groundCheckDistance, _groundLayer);\n    }\n    \n    private bool HasDroppedMaxDistance()\n    {\n        return Vector3.Distance(transform.position, _startPosition) >= _maxDropDistance;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && _currentState == SpiderState.Dropping)\n        {\n            // Handle player collision during drop\n            Land();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = transform.position;\n        center.y -= _detectionHeight * 0.5f;\n        Gizmos.DrawWireCylinder(center, _detectionRadius, _detectionHeight);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, 0.2f);\n        \n        if (Application.isPlaying)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_startPosition, 0.3f);\n        }\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawRay(transform.position, Vector3.down * _groundCheckDistance);\n    }\n}\n\npublic static class PhysicsExtensions\n{\n    public static Collider[] OverlapCylinder(Vector3 point0, Vector3 point1, float radius, LayerMask layerMask)\n    {\n        // Simplified cylinder overlap using capsule\n        return Physics.OverlapCapsule(point0, point1, radius, layerMask);\n    }\n    \n    public static void DrawWireCylinder(this Gizmos gizmos, Vector3 center, float radius, float height)\n    {\n        Vector3 top = center + Vector3.up * height * 0.5f;\n        Vector3 bottom = center - Vector3.up * height * 0.5f;\n        \n        // Draw circles\n        DrawCircle(top, radius);\n        DrawCircle(bottom, radius);\n        \n        // Draw connecting lines\n        Gizmos.DrawLine(top + Vector3.forward * radius, bottom + Vector3.forward * radius);\n        Gizmos.DrawLine(top - Vector3.forward * radius, bottom - Vector3.forward * radius);\n        Gizmos.DrawLine(top + Vector3.right * radius, bottom + Vector3.right * radius);\n        Gizmos.DrawLine(top - Vector3.right * radius, bottom - Vector3.right * radius);\n    }\n    \n    private static void DrawCircle(Vector3 center, float radius)\n    {\n        int segments = 16;\n        float angleStep = 360f / segments;\n        Vector3 prevPoint = center + Vector3.forward * radius;\n        \n        for (int i = 1; i <= segments; i++)\n        {\n            float angle = i * angleStep * Mathf.Deg2Rad;\n            Vector3 newPoint = center + new Vector3(Mathf.Sin(angle), 0, Mathf.Cos(angle)) * radius;\n            Gizmos.DrawLine(prevPoint, newPoint);\n            prevPoint = newPoint;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HomingMissile\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"target\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"speed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"turnRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"lifetime\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"every frame while target exists\",\n      \"actions\": [\n        {\n          \"action\": \"calculate direction toward target\"\n        },\n        {\n          \"action\": \"rotate toward target at turn rate\"\n        },\n        {\n          \"action\": \"move forward at speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_on_contact\",\n      \"trigger\": \"when colliding with any object\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to all objects within explosion radius\"\n        },\n        {\n          \"action\": \"create explosion effect\"\n        },\n        {\n          \"action\": \"destroy missile\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_on_proximity\",\n      \"trigger\": \"when target is within explosion radius\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to all objects within explosion radius\"\n        },\n        {\n          \"action\": \"create explosion effect\"\n        },\n        {\n          \"action\": \"destroy missile\"\n        }\n      ]\n    },\n    {\n      \"name\": \"self_destruct\",\n      \"trigger\": \"when lifetime expires\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect\"\n        },\n        {\n          \"action\": \"destroy missile\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HomingMissile : MonoBehaviour\n{\n    [Header(\"Targeting\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private float _detectionRange = 50f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _speed = 15f;\n    [SerializeField] private float _rotationSpeed = 200f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _maxSpeed = 25f;\n    \n    [Header(\"Homing Behavior\")]\n    [SerializeField] private float _homingStrength = 2f;\n    [SerializeField] private float _predictionTime = 0.5f;\n    [SerializeField] private bool _useLeadTargeting = true;\n    \n    [Header(\"Lifetime\")]\n    [SerializeField] private float _lifeTime = 10f;\n    [SerializeField] private float _armingDelay = 0.5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionDamage = 100f;\n    [SerializeField] private TrailRenderer _trailRenderer;\n    [SerializeField] private ParticleSystem _thrusterParticles;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentVelocity;\n    private float _currentSpeed;\n    private float _timeAlive;\n    private bool _isArmed;\n    private bool _hasExploded;\n    private Vector3 _lastTargetPosition;\n    private Vector3 _targetVelocity;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _currentSpeed = _speed;\n        _currentVelocity = transform.forward * _currentSpeed;\n        \n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = true;\n        }\n        \n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Play();\n        }\n        \n        FindInitialTarget();\n    }\n    \n    private void Update()\n    {\n        _timeAlive += Time.deltaTime;\n        \n        if (_timeAlive >= _lifeTime)\n        {\n            Explode();\n            return;\n        }\n        \n        if (_timeAlive >= _armingDelay)\n        {\n            _isArmed = true;\n        }\n        \n        if (_target == null)\n        {\n            FindTarget();\n        }\n        \n        UpdateTargetVelocity();\n        UpdateMovement();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_hasExploded) return;\n        \n        _rigidbody.velocity = _currentVelocity;\n    }\n    \n    private void FindInitialTarget()\n    {\n        if (_target != null) return;\n        FindTarget();\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] potentialTargets = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayers);\n        \n        float closestDistance = float.MaxValue;\n        Transform closestTarget = null;\n        \n        foreach (Collider col in potentialTargets)\n        {\n            if (col.transform == transform) continue;\n            \n            if (!string.IsNullOrEmpty(_targetTag) && !col.CompareTag(_targetTag)) continue;\n            \n            float distance = Vector3.Distance(transform.position, col.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = col.transform;\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void UpdateTargetVelocity()\n    {\n        if (_target == null) return;\n        \n        Vector3 currentTargetPosition = _target.position;\n        _targetVelocity = (currentTargetPosition - _lastTargetPosition) / Time.deltaTime;\n        _lastTargetPosition = currentTargetPosition;\n    }\n    \n    private void UpdateMovement()\n    {\n        if (_target == null)\n        {\n            // Continue straight if no target\n            _currentVelocity = transform.forward * _currentSpeed;\n            return;\n        }\n        \n        Vector3 targetPosition = _target.position;\n        \n        // Lead targeting - predict where target will be\n        if (_useLeadTargeting)\n        {\n            targetPosition += _targetVelocity * _predictionTime;\n        }\n        \n        Vector3 directionToTarget = (targetPosition - transform.position).normalized;\n        Vector3 desiredVelocity = directionToTarget * _currentSpeed;\n        \n        // Apply homing behavior\n        _currentVelocity = Vector3.Lerp(_currentVelocity, desiredVelocity, _homingStrength * Time.deltaTime);\n        \n        // Accelerate over time\n        _currentSpeed = Mathf.Min(_currentSpeed + _acceleration * Time.deltaTime, _maxSpeed);\n        _currentVelocity = _currentVelocity.normalized * _currentSpeed;\n        \n        // Rotate to face movement direction\n        if (_currentVelocity != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(_currentVelocity);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasExploded || !_isArmed) return;\n        \n        if (other.transform == transform) return;\n        \n        // Check if we hit our target or any valid target\n        bool isValidTarget = false;\n        \n        if (_target != null && other.transform == _target)\n        {\n            isValidTarget = true;\n        }\n        else if (!string.IsNullOrEmpty(_targetTag) && other.CompareTag(_targetTag))\n        {\n            isValidTarget = true;\n        }\n        else if ((_targetLayers.value & (1 << other.gameObject.layer)) != 0)\n        {\n            isValidTarget = true;\n        }\n        \n        if (isValidTarget)\n        {\n            Explode();\n        }\n    }\n    \n    private void Explode()\n    {\n        if (_hasExploded) return;\n        _hasExploded = true;\n        \n        // Apply explosion damage\n        ApplyExplosionDamage();\n        \n        // Spawn explosion effect\n        if (_explosionPrefab != null)\n        {\n            GameObject explosion = Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n            Destroy(explosion, 5f);\n        }\n        \n        // Stop particles\n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        // Disable trail\n        if (_trailRenderer != null)\n        {\n            _trailRenderer.enabled = false;\n        }\n        \n        // Destroy missile\n        Destroy(gameObject);\n    }\n    \n    private void ApplyExplosionDamage()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, hit.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            float damage = _explosionDamage * damageMultiplier;\n            \n            // Try to apply damage through various common interfaces\n            MonoBehaviour[] components = hit.GetComponents<MonoBehaviour>();\n            foreach (MonoBehaviour component in components)\n            {\n                // Use reflection to find damage methods\n                var damageMethod = component.GetType().GetMethod(\"TakeDamage\");\n                if (damageMethod != null)\n                {\n                    damageMethod.Invoke(component, new object[] { damage });\n                    break;\n                }\n            }\n            \n            // Apply physics force\n            Rigidbody hitRigidbody = hit.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                Vector3 forceDirection = (hit.transform.position - transform.position).normalized;\n                float forceMultiplier = 1f - (distance / _explosionRadius);\n                hitRigidbody.AddForce(forceDirection * _explosionDamage * forceMultiplier, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public void SetTarget(Transform target)\n    {\n        _target = target;\n    }\n    \n    public void SetTargetTag(string tag)\n    {\n        _targetTag = tag;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw explosion radius\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        // Draw line to target\n        if (_target != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RetreatingEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"lowHealthThreshold\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"retreatSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"normalSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isRetreating\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current health by damage amount\"\n        },\n        {\n          \"action\": \"clamp current health to minimum of zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_retreat_condition\",\n      \"trigger\": \"when current health drops below low health threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set retreating state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"retreat_behavior\",\n      \"trigger\": \"when retreating state is true\",\n      \"actions\": [\n        {\n          \"action\": \"move away from player at retreat speed\"\n        },\n        {\n          \"action\": \"face away from player direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"normal_behavior\",\n      \"trigger\": \"when retreating state is false and player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at normal speed\"\n        },\n        {\n          \"action\": \"face toward player direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_retreat\",\n      \"trigger\": \"when retreating and current health is restored above low health threshold\",\n      \"actions\": [\n        {\n          \"action\": \"set retreating state to false\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class EnemyRetreat : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _retreatHealthThreshold = 30f;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _normalSpeed = 3.5f;\n    [SerializeField] private float _retreatSpeed = 6f;\n    [SerializeField] private float _retreatDistance = 15f;\n    [SerializeField] private float _stopRetreatDistance = 20f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private LayerMask _playerLayer = 1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Renderer _enemyRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _retreatColor = Color.yellow;\n    \n    private float _currentHealth;\n    private bool _isRetreating = false;\n    private Transform _player;\n    private NavMeshAgent _navAgent;\n    private Vector3 _retreatTarget;\n    private Material _enemyMaterial;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        Retreating\n    }\n    \n    private EnemyState _currentState = EnemyState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _navAgent = GetComponent<NavMeshAgent>();\n        \n        if (_navAgent == null)\n        {\n            Debug.LogError(\"NavMeshAgent component required on \" + gameObject.name);\n            enabled = false;\n            return;\n        }\n        \n        _navAgent.speed = _normalSpeed;\n        \n        if (_enemyRenderer != null)\n        {\n            _enemyMaterial = _enemyRenderer.material;\n            _enemyMaterial.color = _normalColor;\n        }\n        \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        UpdateState(distanceToPlayer);\n        HandleMovement(distanceToPlayer);\n        UpdateVisuals();\n    }\n    \n    void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n    \n    void UpdateState(float distanceToPlayer)\n    {\n        if (_currentHealth <= _retreatHealthThreshold)\n        {\n            if (!_isRetreating)\n            {\n                StartRetreat();\n            }\n            \n            if (distanceToPlayer >= _stopRetreatDistance)\n            {\n                _currentState = EnemyState.Idle;\n            }\n            else\n            {\n                _currentState = EnemyState.Retreating;\n            }\n        }\n        else\n        {\n            _isRetreating = false;\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                _currentState = EnemyState.Chasing;\n            }\n            else\n            {\n                _currentState = EnemyState.Idle;\n            }\n        }\n    }\n    \n    void HandleMovement(float distanceToPlayer)\n    {\n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                _navAgent.SetDestination(transform.position);\n                _navAgent.speed = _normalSpeed;\n                break;\n                \n            case EnemyState.Chasing:\n                _navAgent.SetDestination(_player.position);\n                _navAgent.speed = _normalSpeed;\n                break;\n                \n            case EnemyState.Retreating:\n                if (Vector3.Distance(transform.position, _retreatTarget) < 2f || !_navAgent.hasPath)\n                {\n                    CalculateRetreatTarget();\n                }\n                _navAgent.SetDestination(_retreatTarget);\n                _navAgent.speed = _retreatSpeed;\n                break;\n        }\n    }\n    \n    void StartRetreat()\n    {\n        _isRetreating = true;\n        CalculateRetreatTarget();\n    }\n    \n    void CalculateRetreatTarget()\n    {\n        Vector3 directionAwayFromPlayer = (transform.position - _player.position).normalized;\n        Vector3 potentialTarget = transform.position + directionAwayFromPlayer * _retreatDistance;\n        \n        NavMeshHit hit;\n        if (NavMesh.SamplePosition(potentialTarget, out hit, _retreatDistance, NavMesh.AllAreas))\n        {\n            _retreatTarget = hit.position;\n        }\n        else\n        {\n            Vector3[] alternativeDirections = {\n                Quaternion.Euler(0, 45, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, -45, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, 90, 0) * directionAwayFromPlayer,\n                Quaternion.Euler(0, -90, 0) * directionAwayFromPlayer\n            };\n            \n            foreach (Vector3 direction in alternativeDirections)\n            {\n                Vector3 testTarget = transform.position + direction * _retreatDistance;\n                if (NavMesh.SamplePosition(testTarget, out hit, _retreatDistance, NavMesh.AllAreas))\n                {\n                    _retreatTarget = hit.position;\n                    return;\n                }\n            }\n            \n            _retreatTarget = transform.position;\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_enemyMaterial != null)\n        {\n            Color targetColor = _isRetreating ? _retreatColor : _normalColor;\n            _enemyMaterial.color = Color.Lerp(_enemyMaterial.color, targetColor, Time.deltaTime * 3f);\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth = Mathf.Max(0, _currentHealth - damage);\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    void Die()\n    {\n        Destroy(gameObject);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _player = other.transform;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _retreatDistance);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _stopRetreatDistance);\n        \n        if (_isRetreating && Application.isPlaying)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _retreatTarget);\n            Gizmos.DrawWireSphere(_retreatTarget, 1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Torch\",\n  \"components\": [\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"lightIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"lightRange\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"flickerSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isLit\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"illuminate_area\",\n      \"trigger\": \"when torch is lit\",\n      \"actions\": [\n        {\n          \"action\": \"emit light with specified intensity and range\"\n        },\n        {\n          \"action\": \"cast warm orange colored light\"\n        }\n      ]\n    },\n    {\n      \"name\": \"flicker_effect\",\n      \"trigger\": \"continuously while lit\",\n      \"actions\": [\n        {\n          \"action\": \"randomly vary light intensity slightly\"\n        },\n        {\n          \"action\": \"create flickering flame effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"toggle_torch\",\n      \"trigger\": \"when player interacts with torch\",\n      \"actions\": [\n        {\n          \"action\": \"switch between lit and unlit states\"\n        },\n        {\n          \"action\": \"turn light on or off based on current state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"extinguish_torch\",\n      \"trigger\": \"when torch becomes unlit\",\n      \"actions\": [\n        {\n          \"action\": \"turn off light component\"\n        },\n        {\n          \"action\": \"stop flickering effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Torch : MonoBehaviour\n{\n    [Header(\"Light Settings\")]\n    [SerializeField] private Light torchLight;\n    [SerializeField] private float lightIntensity = 2f;\n    [SerializeField] private float lightRange = 10f;\n    [SerializeField] private Color lightColor = Color.orange;\n    \n    [Header(\"Flame Effect\")]\n    [SerializeField] private ParticleSystem flameParticles;\n    [SerializeField] private AudioSource fireAudioSource;\n    [SerializeField] private AudioClip fireSound;\n    \n    [Header(\"Flickering\")]\n    [SerializeField] private bool enableFlickering = true;\n    [SerializeField] private float flickerSpeed = 5f;\n    [SerializeField] private float flickerIntensity = 0.3f;\n    [SerializeField] private AnimationCurve flickerCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool canBeToggled = true;\n    [SerializeField] private KeyCode toggleKey = KeyCode.E;\n    [SerializeField] private float interactionRange = 3f;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private bool useFuelSystem = false;\n    [SerializeField] private float maxFuelTime = 300f;\n    [SerializeField] private float currentFuel = 300f;\n    \n    private bool _isLit = true;\n    private float _baseIntensity;\n    private float _flickerTime;\n    private Transform _playerTransform;\n    private bool _playerInRange;\n    \n    private void Start()\n    {\n        SetupTorchLight();\n        SetupAudio();\n        SetupParticles();\n        FindPlayer();\n        \n        _baseIntensity = lightIntensity;\n        currentFuel = maxFuelTime;\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        UpdateFlickering();\n        UpdateFuelSystem();\n    }\n    \n    private void SetupTorchLight()\n    {\n        if (torchLight == null)\n        {\n            torchLight = GetComponentInChildren<Light>();\n            if (torchLight == null)\n            {\n                GameObject lightObject = new GameObject(\"TorchLight\");\n                lightObject.transform.SetParent(transform);\n                lightObject.transform.localPosition = Vector3.up * 0.5f;\n                torchLight = lightObject.AddComponent<Light>();\n            }\n        }\n        \n        torchLight.type = LightType.Point;\n        torchLight.intensity = lightIntensity;\n        torchLight.range = lightRange;\n        torchLight.color = lightColor;\n        torchLight.shadows = LightShadows.Soft;\n    }\n    \n    private void SetupAudio()\n    {\n        if (fireAudioSource == null)\n        {\n            fireAudioSource = GetComponent<AudioSource>();\n            if (fireAudioSource == null)\n            {\n                fireAudioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        fireAudioSource.clip = fireSound;\n        fireAudioSource.loop = true;\n        fireAudioSource.volume = 0.3f;\n        fireAudioSource.spatialBlend = 1f;\n        \n        if (_isLit && fireSound != null)\n        {\n            fireAudioSource.Play();\n        }\n    }\n    \n    private void SetupParticles()\n    {\n        if (flameParticles == null)\n        {\n            flameParticles = GetComponentInChildren<ParticleSystem>();\n        }\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = _isLit;\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (!canBeToggled || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        _playerInRange = distanceToPlayer <= interactionRange;\n        \n        if (_playerInRange && Input.GetKeyDown(toggleKey))\n        {\n            ToggleTorch();\n        }\n    }\n    \n    private void UpdateFlickering()\n    {\n        if (!enableFlickering || !_isLit) return;\n        \n        _flickerTime += Time.deltaTime * flickerSpeed;\n        float flickerValue = flickerCurve.Evaluate(Mathf.PingPong(_flickerTime, 1f));\n        float flickerOffset = (flickerValue - 0.5f) * flickerIntensity;\n        \n        torchLight.intensity = _baseIntensity + flickerOffset;\n        \n        if (flameParticles != null)\n        {\n            var velocityOverLifetime = flameParticles.velocityOverLifetime;\n            velocityOverLifetime.enabled = true;\n            velocityOverLifetime.space = ParticleSystemSimulationSpace.Local;\n            velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(2f + flickerOffset * 0.5f);\n        }\n    }\n    \n    private void UpdateFuelSystem()\n    {\n        if (!useFuelSystem || !_isLit) return;\n        \n        currentFuel -= Time.deltaTime;\n        \n        if (currentFuel <= 0f)\n        {\n            currentFuel = 0f;\n            ExtinguishTorch();\n        }\n        else if (currentFuel < maxFuelTime * 0.1f)\n        {\n            // Torch is running low on fuel, increase flickering\n            flickerIntensity = Mathf.Lerp(0.3f, 0.8f, 1f - (currentFuel / (maxFuelTime * 0.1f)));\n        }\n    }\n    \n    public void ToggleTorch()\n    {\n        if (_isLit)\n        {\n            ExtinguishTorch();\n        }\n        else\n        {\n            LightTorch();\n        }\n    }\n    \n    public void LightTorch()\n    {\n        if (useFuelSystem && currentFuel <= 0f) return;\n        \n        _isLit = true;\n        torchLight.enabled = true;\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = true;\n            flameParticles.Play();\n        }\n        \n        if (fireAudioSource != null && fireSound != null)\n        {\n            fireAudioSource.Play();\n        }\n    }\n    \n    public void ExtinguishTorch()\n    {\n        _isLit = false;\n        torchLight.enabled = false;\n        \n        if (flameParticles != null)\n        {\n            var emission = flameParticles.emission;\n            emission.enabled = false;\n            flameParticles.Stop();\n        }\n        \n        if (fireAudioSource != null)\n        {\n            fireAudioSource.Stop();\n        }\n    }\n    \n    public void AddFuel(float fuelAmount)\n    {\n        if (!useFuelSystem) return;\n        \n        currentFuel = Mathf.Min(currentFuel + fuelAmount, maxFuelTime);\n    }\n    \n    public bool IsLit()\n    {\n        return _isLit;\n    }\n    \n    public float GetFuelPercentage()\n    {\n        if (!useFuelSystem) return 1f;\n        return currentFuel / maxFuelTime;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw light range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, lightRange);\n        \n        // Draw interaction range\n        if (canBeToggled)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(transform.position, interactionRange);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DarknessZone\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"visionReduction\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"darknessIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"player_enters_darkness\",\n      \"trigger\": \"when player enters the darkness zone\",\n      \"actions\": [\n        {\n          \"action\": \"reduce player vision range by vision reduction amount\"\n        },\n        {\n          \"action\": \"gradually darken the screen based on darkness intensity\"\n        },\n        {\n          \"action\": \"apply dark visual overlay effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_exits_darkness\",\n      \"trigger\": \"when player exits the darkness zone\",\n      \"actions\": [\n        {\n          \"action\": \"restore player vision range to normal\"\n        },\n        {\n          \"action\": \"gradually brighten the screen back to normal\"\n        },\n        {\n          \"action\": \"remove dark visual overlay effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_darkness_effect\",\n      \"trigger\": \"while player remains inside the darkness zone\",\n      \"actions\": [\n        {\n          \"action\": \"maintain reduced vision range\"\n        },\n        {\n          \"action\": \"keep dark visual effects active\"\n        },\n        {\n          \"action\": \"limit visibility of distant objects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.Universal;\n\npublic class DarknessZone : MonoBehaviour\n{\n    [Header(\"Darkness Settings\")]\n    [SerializeField] private float _darknessIntensity = 0.8f;\n    [SerializeField] private float _transitionSpeed = 2f;\n    [SerializeField] private float _visionRadius = 5f;\n    [SerializeField] private bool _useGlobalVolumeProfile = true;\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _playerLight;\n    [SerializeField] private float _originalLightIntensity = 1f;\n    [SerializeField] private float _darknessLightIntensity = 0.2f;\n    \n    [Header(\"Fog Settings\")]\n    [SerializeField] private bool _enableFog = true;\n    [SerializeField] private Color _fogColor = Color.black;\n    [SerializeField] private float _fogDensity = 0.1f;\n    [SerializeField] private FogMode _fogMode = FogMode.ExponentialSquared;\n    \n    [Header(\"Post Processing\")]\n    [SerializeField] private Volume _darknessVolume;\n    [SerializeField] private AnimationCurve _darknessTransition = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    private bool _playerInZone = false;\n    private float _currentDarknessLevel = 0f;\n    private Camera _playerCamera;\n    private GameObject _playerObject;\n    \n    // Original environment settings\n    private float _originalAmbientIntensity;\n    private Color _originalAmbientColor;\n    private bool _originalFogEnabled;\n    private Color _originalFogColor;\n    private float _originalFogDensity;\n    private FogMode _originalFogMode;\n    private float _originalCameraFarClip;\n    \n    // Vision limitation components\n    private GameObject _visionMask;\n    private SphereCollider _visionCollider;\n    \n    private void Start()\n    {\n        InitializeDarknessZone();\n        StoreOriginalSettings();\n        CreateVisionMask();\n    }\n    \n    private void Update()\n    {\n        UpdateDarknessEffect();\n        UpdateVisionLimitation();\n    }\n    \n    private void InitializeDarknessZone()\n    {\n        if (GetComponent<Collider>() == null)\n        {\n            BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();\n            boxCollider.isTrigger = true;\n        }\n        \n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n        {\n            _playerCamera = FindObjectOfType<Camera>();\n        }\n        \n        if (_darknessVolume == null)\n        {\n            _darknessVolume = FindObjectOfType<Volume>();\n        }\n    }\n    \n    private void StoreOriginalSettings()\n    {\n        _originalAmbientIntensity = RenderSettings.ambientIntensity;\n        _originalAmbientColor = RenderSettings.ambientLight;\n        _originalFogEnabled = RenderSettings.fog;\n        _originalFogColor = RenderSettings.fogColor;\n        _originalFogDensity = RenderSettings.fogDensity;\n        _originalFogMode = RenderSettings.fogMode;\n        \n        if (_playerCamera != null)\n        {\n            _originalCameraFarClip = _playerCamera.farClipPlane;\n        }\n        \n        if (_playerLight == null)\n        {\n            GameObject lightObject = GameObject.FindWithTag(\"Player\");\n            if (lightObject != null)\n            {\n                _playerLight = lightObject.GetComponentInChildren<Light>();\n            }\n        }\n        \n        if (_playerLight != null)\n        {\n            _originalLightIntensity = _playerLight.intensity;\n        }\n    }\n    \n    private void CreateVisionMask()\n    {\n        _visionMask = new GameObject(\"VisionMask\");\n        _visionMask.transform.SetParent(transform);\n        _visionMask.SetActive(false);\n        \n        _visionCollider = _visionMask.AddComponent<SphereCollider>();\n        _visionCollider.isTrigger = true;\n        _visionCollider.radius = _visionRadius;\n        \n        Rigidbody rb = _visionMask.AddComponent<Rigidbody>();\n        rb.isKinematic = true;\n        rb.useGravity = false;\n    }\n    \n    private void UpdateDarknessEffect()\n    {\n        float targetDarkness = _playerInZone ? _darknessIntensity : 0f;\n        _currentDarknessLevel = Mathf.MoveTowards(_currentDarknessLevel, targetDarkness, _transitionSpeed * Time.deltaTime);\n        \n        float transitionValue = _darknessTransition.Evaluate(_currentDarknessLevel / _darknessIntensity);\n        \n        ApplyAmbientLighting(transitionValue);\n        ApplyFogEffect(transitionValue);\n        ApplyLightIntensity(transitionValue);\n        ApplyCameraSettings(transitionValue);\n        ApplyPostProcessing(transitionValue);\n    }\n    \n    private void ApplyAmbientLighting(float intensity)\n    {\n        RenderSettings.ambientIntensity = Mathf.Lerp(_originalAmbientIntensity, _originalAmbientIntensity * (1f - intensity), intensity);\n        RenderSettings.ambientLight = Color.Lerp(_originalAmbientColor, Color.black, intensity * 0.5f);\n    }\n    \n    private void ApplyFogEffect(float intensity)\n    {\n        if (_enableFog)\n        {\n            RenderSettings.fog = true;\n            RenderSettings.fogColor = Color.Lerp(_originalFogColor, _fogColor, intensity);\n            RenderSettings.fogDensity = Mathf.Lerp(_originalFogDensity, _fogDensity, intensity);\n            RenderSettings.fogMode = _fogMode;\n        }\n    }\n    \n    private void ApplyLightIntensity(float intensity)\n    {\n        if (_playerLight != null)\n        {\n            _playerLight.intensity = Mathf.Lerp(_originalLightIntensity, _darknessLightIntensity, intensity);\n        }\n    }\n    \n    private void ApplyCameraSettings(float intensity)\n    {\n        if (_playerCamera != null)\n        {\n            float reducedFarClip = _originalCameraFarClip * (1f - intensity * 0.7f);\n            _playerCamera.farClipPlane = Mathf.Max(reducedFarClip, 10f);\n        }\n    }\n    \n    private void ApplyPostProcessing(float intensity)\n    {\n        if (_darknessVolume != null)\n        {\n            _darknessVolume.weight = intensity;\n        }\n    }\n    \n    private void UpdateVisionLimitation()\n    {\n        if (_playerInZone && _playerObject != null && _visionMask != null)\n        {\n            _visionMask.transform.position = _playerObject.transform.position;\n            _visionMask.SetActive(true);\n        }\n        else if (_visionMask != null)\n        {\n            _visionMask.SetActive(false);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInZone = true;\n            _playerObject = other.gameObject;\n            \n            if (_playerCamera == null)\n            {\n                _playerCamera = other.GetComponentInChildren<Camera>();\n            }\n            \n            if (_playerLight == null)\n            {\n                _playerLight = other.GetComponentInChildren<Light>();\n                if (_playerLight != null)\n                {\n                    _originalLightIntensity = _playerLight.intensity;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInZone = false;\n            _playerObject = null;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        RestoreOriginalSettings();\n    }\n    \n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus)\n        {\n            RestoreOriginalSettings();\n        }\n    }\n    \n    private void RestoreOriginalSettings()\n    {\n        RenderSettings.ambientIntensity = _originalAmbientIntensity;\n        RenderSettings.ambientLight = _originalAmbientColor;\n        RenderSettings.fog = _originalFogEnabled;\n        RenderSettings.fogColor = _originalFogColor;\n        RenderSettings.fogDensity = _originalFogDensity;\n        RenderSettings.fogMode = _originalFogMode;\n        \n        if (_playerCamera != null)\n        {\n            _playerCamera.farClipPlane = _originalCameraFarClip;\n        }\n        \n        if (_playerLight != null)\n        {\n            _playerLight.intensity = _originalLightIntensity;\n        }\n        \n        if (_darknessVolume != null)\n        {\n            _darknessVolume.weight = 0f;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.black;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        if (_playerInZone && _playerObject != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(_playerObject.transform.position, _visionRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CirclingFlyingEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"circleRadius\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"flyingHeight\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"circlingSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"centerPoint\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_circle_center\",\n      \"trigger\": \"when the game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set the center point to current position\"\n        },\n        {\n          \"action\": \"move to flying height above center point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"circle_overhead\",\n      \"trigger\": \"continuously during gameplay\",\n      \"actions\": [\n        {\n          \"action\": \"move in circular pattern around center point\"\n        },\n        {\n          \"action\": \"maintain constant flying height\"\n        },\n        {\n          \"action\": \"rotate to face movement direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_to_terrain\",\n      \"trigger\": \"when flying over varying terrain heights\",\n      \"actions\": [\n        {\n          \"action\": \"maintain consistent height above ground level\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FlyingEnemy : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _circleRadius = 10f;\n    [SerializeField] private float _circleSpeed = 2f;\n    [SerializeField] private float _hoverHeight = 8f;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Target Settings\")]\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _followPlayer = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Vertical Movement\")]\n    [SerializeField] private float _bobAmount = 0.5f;\n    [SerializeField] private float _bobSpeed = 3f;\n    \n    [Header(\"Rotation\")]\n    [SerializeField] private bool _faceMovementDirection = true;\n    [SerializeField] private float _rotationSpeed = 5f;\n    \n    private Vector3 _centerPoint;\n    private float _currentAngle;\n    private float _bobTimer;\n    private Vector3 _lastPosition;\n    private GameObject _player;\n    \n    private void Start()\n    {\n        if (_followPlayer)\n        {\n            _player = GameObject.FindGameObjectWithTag(_playerTag);\n            if (_player != null)\n            {\n                _target = _player.transform;\n            }\n        }\n        \n        if (_target == null)\n        {\n            _centerPoint = transform.position;\n        }\n        else\n        {\n            _centerPoint = new Vector3(_target.position.x, _target.position.y + _hoverHeight, _target.position.z);\n        }\n        \n        _lastPosition = transform.position;\n        _currentAngle = Random.Range(0f, 360f);\n    }\n    \n    private void Update()\n    {\n        UpdateCenterPoint();\n        UpdateCircularMovement();\n        UpdateVerticalBobbing();\n        UpdateRotation();\n    }\n    \n    private void UpdateCenterPoint()\n    {\n        if (_target != null)\n        {\n            Vector3 targetCenter = new Vector3(_target.position.x, _target.position.y + _hoverHeight, _target.position.z);\n            _centerPoint = Vector3.Lerp(_centerPoint, targetCenter, Time.deltaTime * 2f);\n        }\n    }\n    \n    private void UpdateCircularMovement()\n    {\n        float angleIncrement = _circleSpeed * Time.deltaTime;\n        if (!_clockwise)\n        {\n            angleIncrement = -angleIncrement;\n        }\n        \n        _currentAngle += angleIncrement;\n        if (_currentAngle >= 360f)\n        {\n            _currentAngle -= 360f;\n        }\n        else if (_currentAngle < 0f)\n        {\n            _currentAngle += 360f;\n        }\n        \n        float radians = _currentAngle * Mathf.Deg2Rad;\n        Vector3 circlePosition = new Vector3(\n            _centerPoint.x + Mathf.Cos(radians) * _circleRadius,\n            _centerPoint.y,\n            _centerPoint.z + Mathf.Sin(radians) * _circleRadius\n        );\n        \n        transform.position = circlePosition;\n    }\n    \n    private void UpdateVerticalBobbing()\n    {\n        _bobTimer += Time.deltaTime * _bobSpeed;\n        float bobOffset = Mathf.Sin(_bobTimer) * _bobAmount;\n        \n        Vector3 currentPos = transform.position;\n        currentPos.y += bobOffset;\n        transform.position = currentPos;\n    }\n    \n    private void UpdateRotation()\n    {\n        if (_faceMovementDirection)\n        {\n            Vector3 movementDirection = transform.position - _lastPosition;\n            if (movementDirection.magnitude > 0.01f)\n            {\n                Quaternion targetRotation = Quaternion.LookRotation(movementDirection);\n                transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n        }\n        \n        _lastPosition = transform.position;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_playerTag))\n        {\n            // Handle player collision\n            Debug.Log(\"Flying enemy detected player\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = Application.isPlaying ? _centerPoint : transform.position;\n        \n        // Draw circle path\n        for (int i = 0; i < 36; i++)\n        {\n            float angle1 = i * 10f * Mathf.Deg2Rad;\n            float angle2 = (i + 1) * 10f * Mathf.Deg2Rad;\n            \n            Vector3 point1 = new Vector3(\n                center.x + Mathf.Cos(angle1) * _circleRadius,\n                center.y,\n                center.z + Mathf.Sin(angle1) * _circleRadius\n            );\n            \n            Vector3 point2 = new Vector3(\n                center.x + Mathf.Cos(angle2) * _circleRadius,\n                center.y,\n                center.z + Mathf.Sin(angle2) * _circleRadius\n            );\n            \n            Gizmos.DrawLine(point1, point2);\n        }\n        \n        // Draw center point\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, 0.5f);\n        \n        // Draw hover height indicator\n        if (_target != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(_target.position, center);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SprintController\",\n  \"components\": [\n    \"CharacterController\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"staminaDrainRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"staminaRegenRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"sprintSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"isSprinting\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_sprinting\",\n      \"trigger\": \"when sprint key is pressed and stamina is above zero\",\n      \"actions\": [\n        {\n          \"action\": \"set sprinting state to true\"\n        },\n        {\n          \"action\": \"increase movement speed to sprint speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drain_stamina_while_sprinting\",\n      \"trigger\": \"while sprinting is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current stamina by drain rate over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_sprinting_no_stamina\",\n      \"trigger\": \"when current stamina reaches zero while sprinting\",\n      \"actions\": [\n        {\n          \"action\": \"set sprinting state to false\"\n        },\n        {\n          \"action\": \"reduce movement speed to walk speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_sprinting_key_release\",\n      \"trigger\": \"when sprint key is released\",\n      \"actions\": [\n        {\n          \"action\": \"set sprinting state to false\"\n        },\n        {\n          \"action\": \"reduce movement speed to walk speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_stamina\",\n      \"trigger\": \"while not sprinting and stamina is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increase current stamina by regeneration rate over time\"\n        },\n        {\n          \"action\": \"clamp stamina to maximum value\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SprintSystem : MonoBehaviour\n{\n    [Header(\"Sprint Settings\")]\n    [SerializeField] private float _normalSpeed = 5f;\n    [SerializeField] private float _sprintSpeed = 8f;\n    [SerializeField] private KeyCode _sprintKey = KeyCode.LeftShift;\n    \n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    [SerializeField] private float _regenDelay = 1f;\n    [SerializeField] private float _minStaminaToSprint = 10f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sprintSound;\n    [SerializeField] private AudioClip _exhaustedSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float, float> OnStaminaChanged;\n    public UnityEvent OnSprintStarted;\n    public UnityEvent OnSprintStopped;\n    public UnityEvent OnExhausted;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private float _currentStamina;\n    private bool _isSprinting;\n    private bool _canSprint = true;\n    private float _lastSprintTime;\n    private Vector3 _moveDirection;\n    private bool _isMoving;\n    \n    private void Start()\n    {\n        _currentStamina = _maxStamina;\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleSprinting();\n        HandleStamina();\n        HandleMovement();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        _moveDirection = new Vector3(horizontal, 0f, vertical).normalized;\n        _isMoving = _moveDirection.magnitude > 0.1f;\n        \n        bool sprintInput = Input.GetKey(_sprintKey);\n        bool shouldSprint = sprintInput && _isMoving && _canSprint && _currentStamina >= _minStaminaToSprint;\n        \n        if (shouldSprint && !_isSprinting)\n        {\n            StartSprint();\n        }\n        else if ((!sprintInput || !_isMoving || _currentStamina <= 0f) && _isSprinting)\n        {\n            StopSprint();\n        }\n    }\n    \n    private void HandleSprinting()\n    {\n        if (_isSprinting && _currentStamina > 0f)\n        {\n            _currentStamina -= _staminaDrainRate * Time.deltaTime;\n            _lastSprintTime = Time.time;\n            \n            if (_currentStamina <= 0f)\n            {\n                _currentStamina = 0f;\n                StopSprint();\n                OnExhausted?.Invoke();\n                \n                if (_audioSource && _exhaustedSound)\n                    _audioSource.PlayOneShot(_exhaustedSound);\n            }\n        }\n    }\n    \n    private void HandleStamina()\n    {\n        if (!_isSprinting && _currentStamina < _maxStamina)\n        {\n            if (Time.time - _lastSprintTime >= _regenDelay)\n            {\n                _currentStamina += _staminaRegenRate * Time.deltaTime;\n                _currentStamina = Mathf.Clamp(_currentStamina, 0f, _maxStamina);\n            }\n        }\n        \n        _canSprint = _currentStamina >= _minStaminaToSprint;\n        OnStaminaChanged?.Invoke(_currentStamina, _maxStamina);\n    }\n    \n    private void HandleMovement()\n    {\n        if (!_isMoving) return;\n        \n        float currentSpeed = _isSprinting ? _sprintSpeed : _normalSpeed;\n        Vector3 movement = transform.TransformDirection(_moveDirection) * currentSpeed;\n        \n        if (_characterController != null)\n        {\n            movement.y = -9.81f;\n            _characterController.Move(movement * Time.deltaTime);\n        }\n        else if (_rigidbody != null)\n        {\n            Vector3 velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n            _rigidbody.velocity = velocity;\n        }\n        else\n        {\n            transform.Translate(movement * Time.deltaTime, Space.World);\n        }\n    }\n    \n    private void StartSprint()\n    {\n        _isSprinting = true;\n        OnSprintStarted?.Invoke();\n        \n        if (_audioSource && _sprintSound)\n        {\n            _audioSource.clip = _sprintSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void StopSprint()\n    {\n        _isSprinting = false;\n        OnSprintStopped?.Invoke();\n        \n        if (_audioSource && _audioSource.isPlaying && _audioSource.clip == _sprintSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsSprinting()\n    {\n        return _isSprinting;\n    }\n    \n    public bool CanSprint()\n    {\n        return _canSprint;\n    }\n    \n    public void RestoreStamina(float amount)\n    {\n        _currentStamina = Mathf.Clamp(_currentStamina + amount, 0f, _maxStamina);\n    }\n    \n    public void DrainStamina(float amount)\n    {\n        _currentStamina = Mathf.Clamp(_currentStamina - amount, 0f, _maxStamina);\n        \n        if (_currentStamina <= 0f && _isSprinting)\n        {\n            StopSprint();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Spaceship\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"thrustPower\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"forward_thrust\",\n      \"trigger\": \"when thrust input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply forward force based on thrust power\"\n        },\n        {\n          \"action\": \"limit velocity to maximum speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_left\",\n      \"trigger\": \"when left rotation input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate spaceship left at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_right\",\n      \"trigger\": \"when right rotation input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate spaceship right at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_in_space\",\n      \"trigger\": \"when no thrust input is active\",\n      \"actions\": [\n        {\n          \"action\": \"maintain current velocity with no additional forces\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SpaceshipController : MonoBehaviour\n{\n    [Header(\"Thrust Settings\")]\n    [SerializeField] private float _thrustForce = 10f;\n    [SerializeField] private float _rotationSpeed = 100f;\n    [SerializeField] private float _maxVelocity = 20f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _thrustKey = KeyCode.W;\n    [SerializeField] private KeyCode _leftRotateKey = KeyCode.A;\n    [SerializeField] private KeyCode _rightRotateKey = KeyCode.D;\n    [SerializeField] private KeyCode _reverseKey = KeyCode.S;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _thrustParticles;\n    [SerializeField] private AudioSource _thrustAudioSource;\n    [SerializeField] private Transform _thrustPoint;\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private float _drag = 0.98f;\n    [SerializeField] private float _angularDrag = 0.95f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isThrusting;\n    private Vector3 _thrustDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 0f;\n        _rigidbody.angularDrag = 0f;\n        \n        if (_thrustPoint == null)\n        {\n            _thrustPoint = transform;\n        }\n        \n        if (_thrustParticles != null)\n        {\n            _thrustParticles.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleVisualEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleThrust();\n        HandleRotation();\n        ApplyDrag();\n        ClampVelocity();\n    }\n    \n    private void HandleInput()\n    {\n        _isThrusting = Input.GetKey(_thrustKey) || Input.GetKey(_reverseKey);\n        \n        if (Input.GetKey(_thrustKey))\n        {\n            _thrustDirection = transform.forward;\n        }\n        else if (Input.GetKey(_reverseKey))\n        {\n            _thrustDirection = -transform.forward;\n        }\n        else\n        {\n            _thrustDirection = Vector3.zero;\n        }\n    }\n    \n    private void HandleThrust()\n    {\n        if (_isThrusting && _thrustDirection != Vector3.zero)\n        {\n            Vector3 thrustForceVector = _thrustDirection * _thrustForce;\n            _rigidbody.AddForce(thrustForceVector, ForceMode.Force);\n        }\n    }\n    \n    private void HandleRotation()\n    {\n        float rotationInput = 0f;\n        \n        if (Input.GetKey(_leftRotateKey))\n        {\n            rotationInput = -1f;\n        }\n        else if (Input.GetKey(_rightRotateKey))\n        {\n            rotationInput = 1f;\n        }\n        \n        if (Mathf.Abs(rotationInput) > 0.1f)\n        {\n            Vector3 torque = transform.up * rotationInput * _rotationSpeed;\n            _rigidbody.AddTorque(torque, ForceMode.Force);\n        }\n    }\n    \n    private void ApplyDrag()\n    {\n        _rigidbody.velocity *= _drag;\n        _rigidbody.angularVelocity *= _angularDrag;\n    }\n    \n    private void ClampVelocity()\n    {\n        if (_rigidbody.velocity.magnitude > _maxVelocity)\n        {\n            _rigidbody.velocity = _rigidbody.velocity.normalized * _maxVelocity;\n        }\n    }\n    \n    private void HandleVisualEffects()\n    {\n        if (_thrustParticles != null)\n        {\n            if (_isThrusting && Input.GetKey(_thrustKey))\n            {\n                if (!_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Play();\n                }\n            }\n            else\n            {\n                if (_thrustParticles.isPlaying)\n                {\n                    _thrustParticles.Stop();\n                }\n            }\n        }\n        \n        if (_thrustAudioSource != null)\n        {\n            if (_isThrusting)\n            {\n                if (!_thrustAudioSource.isPlaying)\n                {\n                    _thrustAudioSource.Play();\n                }\n            }\n            else\n            {\n                if (_thrustAudioSource.isPlaying)\n                {\n                    _thrustAudioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    public void SetThrustForce(float force)\n    {\n        _thrustForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetMaxVelocity(float maxVel)\n    {\n        _maxVelocity = Mathf.Max(0f, maxVel);\n    }\n    \n    public Vector3 GetVelocity()\n    {\n        return _rigidbody != null ? _rigidbody.velocity : Vector3.zero;\n    }\n    \n    public float GetSpeed()\n    {\n        return _rigidbody != null ? _rigidbody.velocity.magnitude : 0f;\n    }\n    \n    public bool IsThrusting()\n    {\n        return _isThrusting;\n    }\n    \n    private void OnValidate()\n    {\n        _thrustForce = Mathf.Max(0f, _thrustForce);\n        _rotationSpeed = Mathf.Max(0f, _rotationSpeed);\n        _maxVelocity = Mathf.Max(0f, _maxVelocity);\n        _drag = Mathf.Clamp01(_drag);\n        _angularDrag = Mathf.Clamp01(_angularDrag);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerNameTag\",\n  \"components\": [\n    \"Canvas\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"playerName\",\n      \"type\": \"string\",\n      \"default\": \"Player\"\n    },\n    {\n      \"name\": \"offsetHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"followSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_name_tag\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"display player name in text component\"\n        },\n        {\n          \"action\": \"position canvas above player head at offset height\"\n        },\n        {\n          \"action\": \"make canvas face camera\"\n        }\n      ]\n    },\n    {\n      \"name\": \"follow_player\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"move smoothly to position above player head\"\n        },\n        {\n          \"action\": \"rotate to always face camera\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_name\",\n      \"trigger\": \"when player name changes\",\n      \"actions\": [\n        {\n          \"action\": \"update displayed text with new player name\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class PlayerNameTag : MonoBehaviour\n{\n    [Header(\"Name Tag Settings\")]\n    [SerializeField] private string _playerName = \"Player\";\n    [SerializeField] private float _heightOffset = 2.0f;\n    [SerializeField] private bool _alwaysFaceCamera = true;\n    [SerializeField] private float _fadeDistance = 20.0f;\n    [SerializeField] private bool _hideWhenTooClose = true;\n    [SerializeField] private float _minDistance = 2.0f;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Canvas _nameTagCanvas;\n    [SerializeField] private Text _nameText;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _nameColor = Color.white;\n    [SerializeField] private int _fontSize = 24;\n    [SerializeField] private Font _font;\n    \n    private Camera _mainCamera;\n    private Transform _playerTransform;\n    private Vector3 _originalScale;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        _playerTransform = transform;\n        \n        CreateNameTagUI();\n        SetupCanvas();\n        UpdateNameDisplay();\n        \n        if (_nameTagCanvas != null)\n            _originalScale = _nameTagCanvas.transform.localScale;\n    }\n    \n    private void CreateNameTagUI()\n    {\n        if (_nameTagCanvas == null)\n        {\n            GameObject canvasGO = new GameObject(\"NameTagCanvas\");\n            canvasGO.transform.SetParent(transform);\n            canvasGO.transform.localPosition = Vector3.up * _heightOffset;\n            \n            _nameTagCanvas = canvasGO.AddComponent<Canvas>();\n            _canvasGroup = canvasGO.AddComponent<CanvasGroup>();\n            canvasGO.AddComponent<CanvasScaler>();\n        }\n        \n        if (_nameText == null)\n        {\n            GameObject textGO = new GameObject(\"NameText\");\n            textGO.transform.SetParent(_nameTagCanvas.transform);\n            \n            _nameText = textGO.AddComponent<Text>();\n            \n            RectTransform rectTransform = _nameText.GetComponent<RectTransform>();\n            rectTransform.anchorMin = Vector2.zero;\n            rectTransform.anchorMax = Vector2.one;\n            rectTransform.offsetMin = Vector2.zero;\n            rectTransform.offsetMax = Vector2.zero;\n        }\n    }\n    \n    private void SetupCanvas()\n    {\n        if (_nameTagCanvas == null) return;\n        \n        _nameTagCanvas.renderMode = RenderMode.WorldSpace;\n        _nameTagCanvas.worldCamera = _mainCamera;\n        \n        RectTransform canvasRect = _nameTagCanvas.GetComponent<RectTransform>();\n        canvasRect.sizeDelta = new Vector2(200, 50);\n        canvasRect.localScale = Vector3.one * 0.01f;\n    }\n    \n    private void UpdateNameDisplay()\n    {\n        if (_nameText == null) return;\n        \n        _nameText.text = _playerName;\n        _nameText.color = _nameColor;\n        _nameText.fontSize = _fontSize;\n        _nameText.alignment = TextAnchor.MiddleCenter;\n        \n        if (_font != null)\n            _nameText.font = _font;\n    }\n    \n    private void Update()\n    {\n        if (_mainCamera == null || _nameTagCanvas == null) return;\n        \n        HandleCameraFacing();\n        HandleDistanceFading();\n        UpdatePosition();\n    }\n    \n    private void HandleCameraFacing()\n    {\n        if (!_alwaysFaceCamera) return;\n        \n        Vector3 directionToCamera = _mainCamera.transform.position - _nameTagCanvas.transform.position;\n        directionToCamera.y = 0;\n        \n        if (directionToCamera != Vector3.zero)\n        {\n            Quaternion lookRotation = Quaternion.LookRotation(-directionToCamera);\n            _nameTagCanvas.transform.rotation = lookRotation;\n        }\n    }\n    \n    private void HandleDistanceFading()\n    {\n        if (_canvasGroup == null) return;\n        \n        float distance = Vector3.Distance(_mainCamera.transform.position, _playerTransform.position);\n        \n        if (_hideWhenTooClose && distance < _minDistance)\n        {\n            _canvasGroup.alpha = 0f;\n            return;\n        }\n        \n        if (distance > _fadeDistance)\n        {\n            _canvasGroup.alpha = 0f;\n        }\n        else\n        {\n            float fadeRatio = 1f - (distance / _fadeDistance);\n            _canvasGroup.alpha = Mathf.Clamp01(fadeRatio);\n        }\n    }\n    \n    private void UpdatePosition()\n    {\n        if (_nameTagCanvas == null) return;\n        \n        Vector3 targetPosition = _playerTransform.position + Vector3.up * _heightOffset;\n        _nameTagCanvas.transform.position = targetPosition;\n    }\n    \n    public void SetPlayerName(string newName)\n    {\n        _playerName = newName;\n        UpdateNameDisplay();\n    }\n    \n    public void SetNameColor(Color newColor)\n    {\n        _nameColor = newColor;\n        UpdateNameDisplay();\n    }\n    \n    public void SetHeightOffset(float newOffset)\n    {\n        _heightOffset = newOffset;\n    }\n    \n    public void ShowNameTag()\n    {\n        if (_nameTagCanvas != null)\n            _nameTagCanvas.gameObject.SetActive(true);\n    }\n    \n    public void HideNameTag()\n    {\n        if (_nameTagCanvas != null)\n            _nameTagCanvas.gameObject.SetActive(false);\n    }\n    \n    private void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            UpdateNameDisplay();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ObstacleSlider\",\n  \"components\": [\n    \"Rigidbody\",\n    \"CapsuleCollider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slideSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"slideDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"obstacleDetectionDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"slideHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"normalHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isSliding\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_obstacle_ahead\",\n      \"trigger\": \"when moving forward and obstacle is detected ahead within detection distance\",\n      \"actions\": [\n        {\n          \"action\": \"check if obstacle can be slid under by examining its height\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initiate_slide\",\n      \"trigger\": \"when slide input is pressed and obstacle ahead can be slid under\",\n      \"actions\": [\n        {\n          \"action\": \"set sliding state to true\"\n        },\n        {\n          \"action\": \"reduce character height to slide height\"\n        },\n        {\n          \"action\": \"increase forward movement speed to slide speed\"\n        },\n        {\n          \"action\": \"start slide duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_slide_movement\",\n      \"trigger\": \"while sliding state is active\",\n      \"actions\": [\n        {\n          \"action\": \"move forward at slide speed\"\n        },\n        {\n          \"action\": \"keep character at reduced height\"\n        },\n        {\n          \"action\": \"prevent jumping or standing actions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_slide\",\n      \"trigger\": \"when slide duration timer expires or obstacle is cleared\",\n      \"actions\": [\n        {\n          \"action\": \"set sliding state to false\"\n        },\n        {\n          \"action\": \"restore character height to normal height\"\n        },\n        {\n          \"action\": \"return movement speed to normal\"\n        },\n        {\n          \"action\": \"allow normal movement actions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"slide_collision_handling\",\n      \"trigger\": \"while sliding and collision occurs with obstacle sides\",\n      \"actions\": [\n        {\n          \"action\": \"maintain slide momentum\"\n        },\n        {\n          \"action\": \"prevent getting stuck on obstacle edges\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SlideController : MonoBehaviour\n{\n    [Header(\"Slide Settings\")]\n    [SerializeField] private float _slideDuration = 1f;\n    [SerializeField] private float _slideSpeed = 8f;\n    [SerializeField] private float _slideHeight = 0.5f;\n    [SerializeField] private KeyCode _slideKey = KeyCode.S;\n    [SerializeField] private KeyCode _slideKeyAlt = KeyCode.LeftControl;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _normalHeight = 2f;\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private float _groundCheckDistance = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _slideSound;\n    [SerializeField] private AudioClip _slideEndSound;\n    \n    private Rigidbody _rigidbody;\n    private CapsuleCollider _capsuleCollider;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    \n    private bool _isSliding = false;\n    private bool _isGrounded = false;\n    private float _slideTimer = 0f;\n    private float _originalHeight;\n    private Vector3 _originalCenter;\n    private Vector3 _slideDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _capsuleCollider = GetComponent<CapsuleCollider>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_capsuleCollider != null)\n        {\n            _originalHeight = _capsuleCollider.height;\n            _originalCenter = _capsuleCollider.center;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void Update()\n    {\n        CheckGrounded();\n        HandleSlideInput();\n        UpdateSlide();\n    }\n    \n    private void CheckGrounded()\n    {\n        if (Physics.Raycast(transform.position, Vector3.down, _groundCheckDistance + 0.1f, _obstacleLayer))\n        {\n            _isGrounded = true;\n        }\n        else\n        {\n            _isGrounded = false;\n        }\n    }\n    \n    private void HandleSlideInput()\n    {\n        if (!_isSliding && _isGrounded && (Input.GetKeyDown(_slideKey) || Input.GetKeyDown(_slideKeyAlt)))\n        {\n            StartSlide();\n        }\n        \n        if (_isSliding && (Input.GetKeyUp(_slideKey) && Input.GetKeyUp(_slideKeyAlt)))\n        {\n            EndSlide();\n        }\n    }\n    \n    private void UpdateSlide()\n    {\n        if (_isSliding)\n        {\n            _slideTimer += Time.deltaTime;\n            \n            if (_slideTimer >= _slideDuration)\n            {\n                EndSlide();\n            }\n            else\n            {\n                ApplySlideMovement();\n            }\n        }\n    }\n    \n    private void StartSlide()\n    {\n        _isSliding = true;\n        _slideTimer = 0f;\n        _slideDirection = transform.forward;\n        \n        if (_capsuleCollider != null)\n        {\n            _capsuleCollider.height = _slideHeight;\n            _capsuleCollider.center = new Vector3(_originalCenter.x, _slideHeight * 0.5f, _originalCenter.z);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsSliding\", true);\n        }\n        \n        if (_audioSource != null && _slideSound != null)\n        {\n            _audioSource.PlayOneShot(_slideSound);\n        }\n    }\n    \n    private void EndSlide()\n    {\n        if (!CanStandUp())\n        {\n            return;\n        }\n        \n        _isSliding = false;\n        _slideTimer = 0f;\n        \n        if (_capsuleCollider != null)\n        {\n            _capsuleCollider.height = _originalHeight;\n            _capsuleCollider.center = _originalCenter;\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(\"IsSliding\", false);\n        }\n        \n        if (_audioSource != null && _slideEndSound != null)\n        {\n            _audioSource.PlayOneShot(_slideEndSound);\n        }\n    }\n    \n    private bool CanStandUp()\n    {\n        Vector3 checkPosition = transform.position + Vector3.up * (_normalHeight - _slideHeight);\n        return !Physics.CheckSphere(checkPosition, 0.4f, _obstacleLayer);\n    }\n    \n    private void ApplySlideMovement()\n    {\n        if (_rigidbody != null && _isGrounded)\n        {\n            Vector3 slideVelocity = _slideDirection * _slideSpeed;\n            slideVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = slideVelocity;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Obstacle\") && _isSliding)\n        {\n            Debug.Log(\"Successfully slid under obstacle!\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position + Vector3.down * _groundCheckDistance, 0.1f);\n        \n        if (_isSliding)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(transform.position, new Vector3(1f, _slideHeight, 1f));\n        }\n        else\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, new Vector3(1f, _normalHeight, 1f));\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Key\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"doorId\",\n      \"type\": \"string\",\n      \"default\": \"door1\"\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"collect_key\",\n      \"trigger\": \"when player touches this key\",\n      \"actions\": [\n        {\n          \"action\": \"mark key as collected\"\n        },\n        {\n          \"action\": \"add this key to player inventory\"\n        },\n        {\n          \"action\": \"make key invisible\"\n        },\n        {\n          \"action\": \"disable key collision\"\n        },\n        {\n          \"action\": \"play key collection sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Key : MonoBehaviour\n{\n    [Header(\"Key Settings\")]\n    [SerializeField] private string _keyID = \"DefaultKey\";\n    [SerializeField] private bool _destroyOnPickup = true;\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private GameObject _pickupEffect;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnKeyPickedUp;\n    \n    private Vector3 _startPosition;\n    private AudioSource _audioSource;\n    private bool _isPickedUp = false;\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _pickupSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n    }\n    \n    void Update()\n    {\n        if (_isPickedUp) return;\n        \n        // Bobbing animation\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n        \n        // Rotation animation\n        transform.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isPickedUp) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            PickupKey(other.gameObject);\n        }\n    }\n    \n    private void PickupKey(GameObject player)\n    {\n        _isPickedUp = true;\n        \n        // Add key to player's inventory\n        PlayerKeyInventory inventory = player.GetComponent<PlayerKeyInventory>();\n        if (inventory == null)\n        {\n            inventory = player.AddComponent<PlayerKeyInventory>();\n        }\n        \n        inventory.AddKey(_keyID);\n        \n        // Play pickup sound\n        if (_audioSource != null && _pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        // Spawn pickup effect\n        if (_pickupEffect != null)\n        {\n            Instantiate(_pickupEffect, transform.position, transform.rotation);\n        }\n        \n        // Invoke event\n        OnKeyPickedUp?.Invoke(_keyID);\n        \n        // Destroy or hide the key\n        if (_destroyOnPickup)\n        {\n            if (_audioSource != null && _pickupSound != null)\n            {\n                Destroy(gameObject, _pickupSound.length);\n                GetComponent<Renderer>().enabled = false;\n                GetComponent<Collider>().enabled = false;\n            }\n            else\n            {\n                Destroy(gameObject);\n            }\n        }\n        else\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n\npublic class PlayerKeyInventory : MonoBehaviour\n{\n    private System.Collections.Generic.List<string> _keys = new System.Collections.Generic.List<string>();\n    \n    public void AddKey(string keyID)\n    {\n        if (!_keys.Contains(keyID))\n        {\n            _keys.Add(keyID);\n        }\n    }\n    \n    public bool HasKey(string keyID)\n    {\n        return _keys.Contains(keyID);\n    }\n    \n    public void RemoveKey(string keyID)\n    {\n        _keys.Remove(keyID);\n    }\n    \n    public System.Collections.Generic.List<string> GetAllKeys()\n    {\n        return new System.Collections.Generic.List<string>(_keys);\n    }\n}\n\npublic class Door : MonoBehaviour\n{\n    [Header(\"Door Settings\")]\n    [SerializeField] private string _requiredKeyID = \"DefaultKey\";\n    [SerializeField] private bool _consumeKeyOnUse = true;\n    [SerializeField] private float _openSpeed = 2f;\n    [SerializeField] private Vector3 _openOffset = new Vector3(0, 3f, 0);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _unlockSound;\n    [SerializeField] private AudioClip _lockedSound;\n    [SerializeField] private AudioClip _openSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _lockedIndicator;\n    [SerializeField] private GameObject _unlockedIndicator;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDoorUnlocked;\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorLocked;\n    \n    private Vector3 _closedPosition;\n    private Vector3 _openPosition;\n    private bool _isOpen = false;\n    private bool _isMoving = false;\n    private AudioSource _audioSource;\n    \n    void Start()\n    {\n        _closedPosition = transform.position;\n        _openPosition = _closedPosition + _openOffset;\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        UpdateVisualIndicators();\n    }\n    \n    void Update()\n    {\n        if (_isMoving)\n        {\n            Vector3 targetPosition = _isOpen ? _openPosition : _closedPosition;\n            transform.position = Vector3.MoveTowards(transform.position, targetPosition, _openSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(transform.position, targetPosition) < 0.01f)\n            {\n                transform.position = targetPosition;\n                _isMoving = false;\n                \n                if (_isOpen)\n                {\n                    OnDoorOpened?.Invoke();\n                }\n            }\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isMoving)\n        {\n            TryOpenDoor(other.gameObject);\n        }\n    }\n    \n    private void TryOpenDoor(GameObject player)\n    {\n        PlayerKeyInventory inventory = player.GetComponent<PlayerKeyInventory>();\n        \n        if (inventory != null && inventory.HasKey(_requiredKeyID))\n        {\n            UnlockAndOpenDoor(inventory);\n        }\n        else\n        {\n            PlayLockedFeedback();\n        }\n    }\n    \n    private void UnlockAndOpenDoor(PlayerKeyInventory inventory)\n    {\n        if (_consumeKeyOnUse)\n        {\n            inventory.RemoveKey(_requiredKeyID);\n        }\n        \n        _isOpen = true;\n        _isMoving = true;\n        \n        // Play unlock sound\n        if (_unlockSound != null)\n        {\n            _audioSource.PlayOneShot(_unlockSound);\n        }\n        \n        // Play open sound after a delay\n        if (_openSound != null)\n        {\n            Invoke(nameof(PlayOpenSound), 0.5f);\n        }\n        \n        UpdateVisualIndicators();\n        OnDoorUnlocked?.Invoke();\n    }\n    \n    private void PlayOpenSound()\n    {\n        if (_openSound != null)\n        {\n            _audioSource.PlayOneShot(_openSound);\n        }\n    }\n    \n    private void PlayLockedFeedback()\n    {\n        if (_lockedSound != null)\n        {\n            _audioSource.PlayOneShot(_lockedSound);\n        }\n        \n        OnDoorLocked?.Invoke();\n    }\n    \n    private void UpdateVisualIndicators()\n    {\n        if (_lockedIndicator != null)\n        {\n            _lockedIndicator.SetActive(!_isOpen);\n        }\n        \n        if (_unlockedIndicator != null)\n        {\n            _unlockedIndicator.SetActive(_isOpen);\n        }\n    }\n    \n    public void CloseDoor()\n    {\n        if (_isOpen && !_isMoving)\n        {\n            _isOpen = false;\n            _isMoving = true;\n        }\n    }\n    \n    public bool IsOpen()\n    {\n        return _isOpen;\n    }\n    \n    public string GetRequiredKeyID()\n    {\n        return _requiredKeyID;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FireCrackling\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"crackleIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"emberCount\",\n      \"type\": \"int\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"fireSize\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_crackling\",\n      \"trigger\": \"always active\",\n      \"actions\": [\n        {\n          \"action\": \"play crackling fire sound continuously\"\n        },\n        {\n          \"action\": \"emit orange and red flame particles upward\"\n        },\n        {\n          \"action\": \"create flickering light effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"random_crackle_pops\",\n      \"trigger\": \"randomly every few seconds\",\n      \"actions\": [\n        {\n          \"action\": \"play sharp crackling pop sound\"\n        },\n        {\n          \"action\": \"briefly increase particle emission rate\"\n        },\n        {\n          \"action\": \"create small spark burst effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ember_generation\",\n      \"trigger\": \"continuously while fire is active\",\n      \"actions\": [\n        {\n          \"action\": \"spawn glowing ember particles\"\n        },\n        {\n          \"action\": \"make embers float upward and fade out\"\n        },\n        {\n          \"action\": \"give embers random drift movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"intensity_variation\",\n      \"trigger\": \"based on crackling intensity setting\",\n      \"actions\": [\n        {\n          \"action\": \"adjust flame particle size and speed\"\n        },\n        {\n          \"action\": \"modify crackling sound volume\"\n        },\n        {\n          \"action\": \"change ember spawn frequency\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FireCrackling : MonoBehaviour\n{\n    [Header(\"Fire Settings\")]\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private ParticleSystem _emberParticles;\n    [SerializeField] private Light _fireLight;\n    [SerializeField] private AudioSource _crackleAudioSource;\n    \n    [Header(\"Crackling Audio\")]\n    [SerializeField] private AudioClip[] _crackleClips;\n    [SerializeField] private float _minCrackleInterval = 1f;\n    [SerializeField] private float _maxCrackleInterval = 4f;\n    [SerializeField] private float _crackleVolumeMin = 0.3f;\n    [SerializeField] private float _crackleVolumeMax = 0.8f;\n    \n    [Header(\"Fire Light Animation\")]\n    [SerializeField] private float _baseLightIntensity = 2f;\n    [SerializeField] private float _lightFlickerAmount = 0.5f;\n    [SerializeField] private float _lightFlickerSpeed = 8f;\n    [SerializeField] private Color _baseLightColor = Color.yellow;\n    [SerializeField] private Color _flickerLightColor = new Color(1f, 0.6f, 0.2f);\n    \n    [Header(\"Ember Settings\")]\n    [SerializeField] private int _maxEmbers = 20;\n    [SerializeField] private float _emberSpawnRate = 2f;\n    [SerializeField] private float _emberLifetime = 3f;\n    [SerializeField] private Vector3 _emberSpawnArea = new Vector3(1f, 0.5f, 1f);\n    [SerializeField] private float _emberUpwardForce = 2f;\n    [SerializeField] private float _emberRandomForce = 1f;\n    \n    [Header(\"Fire Intensity\")]\n    [SerializeField] private float _fireIntensity = 1f;\n    [SerializeField] private bool _isLit = true;\n    \n    private float _nextCrackleTime;\n    private float _nextEmberSpawnTime;\n    private List<EmberParticle> _activeEmbers = new List<EmberParticle>();\n    private float _lightFlickerOffset;\n    \n    [System.Serializable]\n    private class EmberParticle\n    {\n        public GameObject gameObject;\n        public Rigidbody rigidbody;\n        public Light light;\n        public float lifetime;\n        public float maxLifetime;\n        public Color startColor;\n        \n        public EmberParticle(GameObject go, float life)\n        {\n            gameObject = go;\n            rigidbody = go.GetComponent<Rigidbody>();\n            light = go.GetComponent<Light>();\n            maxLifetime = life;\n            lifetime = life;\n            startColor = light ? light.color : Color.red;\n        }\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _lightFlickerOffset = Random.Range(0f, 100f);\n        _nextCrackleTime = Time.time + Random.Range(_minCrackleInterval, _maxCrackleInterval);\n        _nextEmberSpawnTime = Time.time + (1f / _emberSpawnRate);\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_fireLight == null)\n            _fireLight = GetComponent<Light>();\n            \n        if (_crackleAudioSource == null)\n            _crackleAudioSource = GetComponent<AudioSource>();\n            \n        if (_fireParticles == null)\n            _fireParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (!_isLit) return;\n        \n        UpdateFireLight();\n        HandleCrackling();\n        HandleEmberSpawning();\n        UpdateEmbers();\n        UpdateParticleIntensity();\n    }\n    \n    private void UpdateFireLight()\n    {\n        if (_fireLight == null) return;\n        \n        float flicker = Mathf.PerlinNoise(Time.time * _lightFlickerSpeed, _lightFlickerOffset);\n        float intensity = _baseLightIntensity + (flicker - 0.5f) * _lightFlickerAmount;\n        intensity *= _fireIntensity;\n        \n        _fireLight.intensity = Mathf.Max(0f, intensity);\n        _fireLight.color = Color.Lerp(_baseLightColor, _flickerLightColor, flicker * 0.5f);\n    }\n    \n    private void HandleCrackling()\n    {\n        if (Time.time >= _nextCrackleTime && _crackleClips.Length > 0 && _crackleAudioSource != null)\n        {\n            PlayCrackleSound();\n            _nextCrackleTime = Time.time + Random.Range(_minCrackleInterval, _maxCrackleInterval);\n        }\n    }\n    \n    private void PlayCrackleSound()\n    {\n        AudioClip clip = _crackleClips[Random.Range(0, _crackleClips.Length)];\n        float volume = Random.Range(_crackleVolumeMin, _crackleVolumeMax) * _fireIntensity;\n        float pitch = Random.Range(0.8f, 1.2f);\n        \n        _crackleAudioSource.pitch = pitch;\n        _crackleAudioSource.PlayOneShot(clip, volume);\n    }\n    \n    private void HandleEmberSpawning()\n    {\n        if (Time.time >= _nextEmberSpawnTime && _activeEmbers.Count < _maxEmbers)\n        {\n            SpawnEmber();\n            _nextEmberSpawnTime = Time.time + (1f / (_emberSpawnRate * _fireIntensity));\n        }\n    }\n    \n    private void SpawnEmber()\n    {\n        GameObject ember = CreateEmberGameObject();\n        EmberParticle emberParticle = new EmberParticle(ember, _emberLifetime);\n        \n        Vector3 spawnPos = transform.position + new Vector3(\n            Random.Range(-_emberSpawnArea.x * 0.5f, _emberSpawnArea.x * 0.5f),\n            Random.Range(0f, _emberSpawnArea.y),\n            Random.Range(-_emberSpawnArea.z * 0.5f, _emberSpawnArea.z * 0.5f)\n        );\n        \n        ember.transform.position = spawnPos;\n        \n        Vector3 force = Vector3.up * _emberUpwardForce + Random.insideUnitSphere * _emberRandomForce;\n        emberParticle.rigidbody.AddForce(force, ForceMode.Impulse);\n        \n        _activeEmbers.Add(emberParticle);\n    }\n    \n    private GameObject CreateEmberGameObject()\n    {\n        GameObject ember = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        ember.name = \"Ember\";\n        ember.transform.localScale = Vector3.one * Random.Range(0.02f, 0.05f);\n        \n        Destroy(ember.GetComponent<Collider>());\n        \n        Rigidbody rb = ember.AddComponent<Rigidbody>();\n        rb.mass = 0.01f;\n        rb.drag = 2f;\n        rb.angularDrag = 5f;\n        \n        Light emberLight = ember.AddComponent<Light>();\n        emberLight.type = LightType.Point;\n        emberLight.color = new Color(1f, 0.4f, 0.1f);\n        emberLight.intensity = Random.Range(0.5f, 1.5f);\n        emberLight.range = Random.Range(0.5f, 1.5f);\n        \n        Renderer renderer = ember.GetComponent<Renderer>();\n        Material mat = new Material(Shader.Find(\"Standard\"));\n        mat.SetColor(\"_Color\", Color.red);\n        mat.SetColor(\"_EmissionColor\", Color.red * 2f);\n        mat.EnableKeyword(\"_EMISSION\");\n        renderer.material = mat;\n        \n        return ember;\n    }\n    \n    private void UpdateEmbers()\n    {\n        for (int i = _activeEmbers.Count - 1; i >= 0; i--)\n        {\n            EmberParticle ember = _activeEmbers[i];\n            ember.lifetime -= Time.deltaTime;\n            \n            if (ember.lifetime <= 0f || ember.gameObject == null)\n            {\n                if (ember.gameObject != null)\n                    Destroy(ember.gameObject);\n                _activeEmbers.RemoveAt(i);\n                continue;\n            }\n            \n            float lifetimeRatio = ember.lifetime / ember.maxLifetime;\n            \n            if (ember.light != null)\n            {\n                ember.light.intensity *= lifetimeRatio;\n                ember.light.color = Color.Lerp(Color.black, ember.startColor, lifetimeRatio);\n            }\n            \n            if (ember.gameObject != null)\n            {\n                Renderer renderer = ember.gameObject.GetComponent<Renderer>();\n                if (renderer != null && renderer.material != null)\n                {\n                    Color emberColor = Color.Lerp(Color.black, Color.red, lifetimeRatio);\n                    renderer.material.SetColor(\"_Color\", emberColor);\n                    renderer.material.SetColor(\"_EmissionColor\", emberColor * lifetimeRatio * 2f);\n                }\n            }\n        }\n    }\n    \n    private void UpdateParticleIntensity()\n    {\n        UpdateParticleSystem(_fireParticles, _fireIntensity);\n        UpdateParticleSystem(_smokeParticles, _fireIntensity * 0.8f);\n        UpdateParticleSystem(_emberParticles, _fireIntensity);\n    }\n    \n    private void UpdateParticleSystem(ParticleSystem particles, float intensity)\n    {\n        if (particles == null) return;\n        \n        var emission = particles.emission;\n        var main = particles.main;\n        \n        emission.rateOverTime = emission.rateOverTime.constant * intensity;\n        main.startLifetime = main.startLifetime.constant * (0.5f + intensity * 0.5f);\n    }\n    \n    public void SetFireIntensity(float intensity)\n    {\n        _fireIntensity = Mathf.Clamp01(intensity);\n    }\n    \n    public void ExtinguishFire()\n    {\n        _isLit = false;\n        _fireIntensity = 0f;\n        \n        if (_fireParticles != null) _fireParticles.Stop();\n        if (_emberParticles != null) _emberParticles.Stop();\n        if (_fireLight != null) _fireLight.intensity = 0f;\n        \n        foreach (var ember in _activeEmbers)\n        {\n            if (ember.gameObject != null)\n                Destroy(ember.gameObject);\n        }\n        _activeEmbers.Clear();\n    }\n    \n    public void LightFire()\n    {\n        _isLit = true;\n        _fireIntensity = 1f;\n        \n        if (_fireParticles != null) _fireParticles.Play();\n        if (_emberParticles != null) _emberParticles.Play();\n        if (_smokeParticles != null) _smokeParticles.Play();\n    }\n    \n    private void OnDestroy()\n    {\n        foreach (var ember in _activeEmbers)\n        {\n            if (ember.gameObject != null)\n                Destroy(ember.gameObject);\n        }\n        _activeEmbers.Clear();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ActivationLever\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"rotationAngle\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"activationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"mechanismToActivate\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_lever\",\n      \"trigger\": \"when player interacts with lever\",\n      \"actions\": [\n        {\n          \"action\": \"rotate lever to activated position\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"set activation state to true\"\n        },\n        {\n          \"action\": \"send activation signal to connected mechanism\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_lever\",\n      \"trigger\": \"when player interacts with activated lever\",\n      \"actions\": [\n        {\n          \"action\": \"rotate lever back to default position\"\n        },\n        {\n          \"action\": \"play deactivation sound effect\"\n        },\n        {\n          \"action\": \"set activation state to false\"\n        },\n        {\n          \"action\": \"send deactivation signal to connected mechanism\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Lever : MonoBehaviour\n{\n    [Header(\"Lever Settings\")]\n    [SerializeField] private bool _isActivated = false;\n    [SerializeField] private bool _canBeToggled = true;\n    [SerializeField] private float _activationDistance = 2f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Transform _leverHandle;\n    [SerializeField] private float _rotationAngle = 45f;\n    [SerializeField] private float _animationSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _deactivationSound;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _interactionPrompt;\n    [SerializeField] private Light _indicatorLight;\n    [SerializeField] private Color _activeColor = Color.green;\n    [SerializeField] private Color _inactiveColor = Color.red;\n    [SerializeField] private ParticleSystem _activationEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLeverActivated;\n    public UnityEvent OnLeverDeactivated;\n    public UnityEvent<bool> OnLeverStateChanged;\n    \n    private Transform _player;\n    private bool _playerInRange = false;\n    private Vector3 _originalRotation;\n    private Vector3 _targetRotation;\n    private bool _isAnimating = false;\n    \n    private void Start()\n    {\n        if (_leverHandle != null)\n        {\n            _originalRotation = _leverHandle.localEulerAngles;\n            _targetRotation = _originalRotation;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n            \n        UpdateVisualState();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n        AnimateLever();\n    }\n    \n    private void CheckForPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _player = player.transform;\n            float distance = Vector3.Distance(transform.position, _player.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _activationDistance;\n            \n            if (_playerInRange != wasInRange)\n            {\n                if (_interactionPrompt != null)\n                    _interactionPrompt.SetActive(_playerInRange);\n            }\n        }\n        else\n        {\n            _playerInRange = false;\n            if (_interactionPrompt != null)\n                _interactionPrompt.SetActive(false);\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_playerInRange && Input.GetKeyDown(_interactionKey) && !_isAnimating)\n        {\n            if (_canBeToggled || !_isActivated)\n            {\n                ToggleLever();\n            }\n        }\n    }\n    \n    private void AnimateLever()\n    {\n        if (_leverHandle != null && _isAnimating)\n        {\n            _leverHandle.localEulerAngles = Vector3.Lerp(_leverHandle.localEulerAngles, _targetRotation, Time.deltaTime * _animationSpeed);\n            \n            if (Vector3.Distance(_leverHandle.localEulerAngles, _targetRotation) < 0.1f)\n            {\n                _leverHandle.localEulerAngles = _targetRotation;\n                _isAnimating = false;\n            }\n        }\n    }\n    \n    public void ToggleLever()\n    {\n        if (_isAnimating) return;\n        \n        _isActivated = !_isActivated;\n        UpdateLeverState();\n    }\n    \n    public void ActivateLever()\n    {\n        if (_isActivated || _isAnimating) return;\n        \n        _isActivated = true;\n        UpdateLeverState();\n    }\n    \n    public void DeactivateLever()\n    {\n        if (!_isActivated || _isAnimating) return;\n        \n        _isActivated = false;\n        UpdateLeverState();\n    }\n    \n    private void UpdateLeverState()\n    {\n        if (_leverHandle != null)\n        {\n            _targetRotation = _originalRotation + (_isActivated ? Vector3.forward * _rotationAngle : Vector3.zero);\n            _isAnimating = true;\n        }\n        \n        PlaySound();\n        UpdateVisualState();\n        TriggerEffects();\n        InvokeEvents();\n    }\n    \n    private void PlaySound()\n    {\n        if (_audioSource != null)\n        {\n            AudioClip clipToPlay = _isActivated ? _activationSound : _deactivationSound;\n            if (clipToPlay != null)\n            {\n                _audioSource.PlayOneShot(clipToPlay);\n            }\n        }\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_indicatorLight != null)\n        {\n            _indicatorLight.color = _isActivated ? _activeColor : _inactiveColor;\n            _indicatorLight.enabled = _isActivated;\n        }\n    }\n    \n    private void TriggerEffects()\n    {\n        if (_activationEffect != null && _isActivated)\n        {\n            _activationEffect.Play();\n        }\n    }\n    \n    private void InvokeEvents()\n    {\n        if (_isActivated)\n        {\n            OnLeverActivated?.Invoke();\n        }\n        else\n        {\n            OnLeverDeactivated?.Invoke();\n        }\n        \n        OnLeverStateChanged?.Invoke(_isActivated);\n    }\n    \n    public bool IsActivated()\n    {\n        return _isActivated;\n    }\n    \n    public void SetCanBeToggled(bool canToggle)\n    {\n        _canBeToggled = canToggle;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _activationDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExplosiveCrate\",\n  \"components\": [\n    \"Rigidbody\",\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 1000.0\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"fuseTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"isArmed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by projectile or explosion\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"show damage visual effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"arm_explosive\",\n      \"trigger\": \"when health drops to zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"set armed state to true\"\n        },\n        {\n          \"action\": \"play arming beep sound\"\n        },\n        {\n          \"action\": \"start flashing warning light\"\n        },\n        {\n          \"action\": \"begin countdown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode\",\n      \"trigger\": \"when countdown timer reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion visual effect at crate position\"\n        },\n        {\n          \"action\": \"play loud explosion sound\"\n        },\n        {\n          \"action\": \"apply explosive force to all nearby rigidbodies\"\n        },\n        {\n          \"action\": \"deal damage to all objects within explosion radius\"\n        },\n        {\n          \"action\": \"destroy the crate object\"\n        },\n        {\n          \"action\": \"spawn debris particles\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chain_reaction\",\n      \"trigger\": \"when caught in another explosion\",\n      \"actions\": [\n        {\n          \"action\": \"immediately set health to zero\"\n        },\n        {\n          \"action\": \"trigger armed state without delay\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExplosiveCrate : MonoBehaviour\n{\n    [Header(\"Explosion Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _upwardModifier = 3f;\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private LayerMask _explosionLayers = -1;\n    \n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private bool _explodeOnDestroy = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 0.3f;\n    \n    [Header(\"Chain Reaction\")]\n    [SerializeField] private bool _canChainReact = true;\n    [SerializeField] private float _chainReactionDelay = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnExplode;\n    public UnityEvent<float> OnDamaged;\n    \n    private float _currentHealth;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _audioSource = GetComponent<AudioSource>();\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasExploded) return;\n        \n        if (other.CompareTag(\"Player\") || other.name.Contains(\"Projectile\") || other.name.Contains(\"Bullet\"))\n        {\n            TakeDamage(_maxHealth);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded) return;\n        \n        float impactForce = collision.relativeVelocity.magnitude;\n        if (impactForce > 10f)\n        {\n            TakeDamage(impactForce * 2f);\n        }\n    }\n    \n    public void TakeDamage(float damageAmount)\n    {\n        if (_hasExploded) return;\n        \n        _currentHealth -= damageAmount;\n        OnDamaged?.Invoke(damageAmount);\n        \n        if (_currentHealth <= 0f)\n        {\n            Explode();\n        }\n        else\n        {\n            StartCoroutine(DamageFlash());\n        }\n    }\n    \n    public void Explode()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        \n        // Create explosion effect\n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n        \n        // Play explosion sound\n        if (_explosionSound != null && _audioSource != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n        \n        // Apply explosion force and damage\n        ApplyExplosionEffects();\n        \n        // Trigger camera shake\n        StartCoroutine(CameraShake());\n        \n        // Invoke event\n        OnExplode?.Invoke();\n        \n        // Hide visual components\n        if (_renderer != null) _renderer.enabled = false;\n        if (_collider != null) _collider.enabled = false;\n        \n        // Destroy after a short delay to allow effects to play\n        Destroy(gameObject, 2f);\n    }\n    \n    private void ApplyExplosionEffects()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, _explosionRadius, _explosionLayers);\n        \n        foreach (Collider hit in hitColliders)\n        {\n            if (hit == _collider) continue;\n            \n            // Apply force to rigidbodies\n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius, _upwardModifier);\n            }\n            \n            // Damage other explosive crates for chain reactions\n            if (_canChainReact)\n            {\n                ExplosiveCrate otherCrate = hit.GetComponent<ExplosiveCrate>();\n                if (otherCrate != null && !otherCrate._hasExploded)\n                {\n                    StartCoroutine(ChainReactionDelay(otherCrate));\n                }\n            }\n            \n            // Apply damage to objects with health\n            IDamageable damageable = hit.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                float damageMultiplier = Mathf.Clamp01(1f - (distance / _explosionRadius));\n                damageable.TakeDamage(_damage * damageMultiplier);\n            }\n            \n            // Damage player if hit\n            if (hit.CompareTag(\"Player\"))\n            {\n                // Send damage message to player\n                hit.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ChainReactionDelay(ExplosiveCrate otherCrate)\n    {\n        yield return new WaitForSeconds(_chainReactionDelay);\n        if (otherCrate != null)\n        {\n            otherCrate.Explode();\n        }\n    }\n    \n    private System.Collections.IEnumerator DamageFlash()\n    {\n        if (_renderer == null) yield break;\n        \n        Color originalColor = _renderer.material.color;\n        _renderer.material.color = Color.red;\n        \n        yield return new WaitForSeconds(0.1f);\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = originalColor;\n        }\n    }\n    \n    private System.Collections.IEnumerator CameraShake()\n    {\n        Camera mainCamera = Camera.main;\n        if (mainCamera == null) yield break;\n        \n        Vector3 originalPosition = mainCamera.transform.position;\n        float elapsed = 0f;\n        \n        while (elapsed < _shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * _shakeIntensity;\n            float y = Random.Range(-1f, 1f) * _shakeIntensity;\n            \n            mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        mainCamera.transform.position = originalPosition;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FallingLeaf\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"swayAmount\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    },\n    {\n      \"name\": \"despawnHeight\",\n      \"type\": \"float\",\n      \"default\": -10.0\n    },\n    {\n      \"name\": \"windStrength\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_falling\",\n      \"trigger\": \"when leaf spawns or detaches from tree\",\n      \"actions\": [\n        {\n          \"action\": \"begin falling downward at fall speed\"\n        },\n        {\n          \"action\": \"apply gentle swaying motion side to side\"\n        },\n        {\n          \"action\": \"start random rotation around all axes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sway_in_wind\",\n      \"trigger\": \"continuously while falling\",\n      \"actions\": [\n        {\n          \"action\": \"drift horizontally based on wind strength\"\n        },\n        {\n          \"action\": \"vary fall speed slightly for natural movement\"\n        },\n        {\n          \"action\": \"adjust sway amount based on wind conditions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_naturally\",\n      \"trigger\": \"continuously while falling\",\n      \"actions\": [\n        {\n          \"action\": \"rotate slowly around random axes\"\n        },\n        {\n          \"action\": \"change rotation speed occasionally for variation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"despawn_when_low\",\n      \"trigger\": \"when leaf falls below despawn height\",\n      \"actions\": [\n        {\n          \"action\": \"destroy the leaf object\"\n        },\n        {\n          \"action\": \"remove from scene to maintain performance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_on_ground\",\n      \"trigger\": \"when leaf collides with ground or solid surface\",\n      \"actions\": [\n        {\n          \"action\": \"stop falling motion\"\n        },\n        {\n          \"action\": \"settle onto surface naturally\"\n        },\n        {\n          \"action\": \"reduce rotation to gentle rocking motion\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class FallingLeaves : MonoBehaviour\n{\n    [Header(\"Leaf Settings\")]\n    [SerializeField] private GameObject[] _leafPrefabs;\n    [SerializeField] private int _maxLeaves = 50;\n    [SerializeField] private float _spawnRate = 2f;\n    [SerializeField] private float _leafLifetime = 10f;\n    \n    [Header(\"Spawn Area\")]\n    [SerializeField] private Vector3 _spawnAreaSize = new Vector3(20f, 5f, 20f);\n    [SerializeField] private float _spawnHeight = 10f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _fallSpeed = 2f;\n    [SerializeField] private float _swayAmount = 1f;\n    [SerializeField] private float _swaySpeed = 1f;\n    [SerializeField] private float _rotationSpeed = 30f;\n    [SerializeField] private Vector3 _windDirection = Vector3.right;\n    [SerializeField] private float _windStrength = 0.5f;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    \n    private List<LeafController> _activeLeaves = new List<LeafController>();\n    private float _nextSpawnTime;\n    \n    [System.Serializable]\n    public class LeafController\n    {\n        public GameObject leafObject;\n        public Vector3 startPosition;\n        public float swayOffset;\n        public float spawnTime;\n        public bool hasLanded;\n        public Vector3 rotationAxis;\n        \n        public LeafController(GameObject leaf, Vector3 startPos, float time)\n        {\n            leafObject = leaf;\n            startPosition = startPos;\n            swayOffset = Random.Range(0f, Mathf.PI * 2f);\n            spawnTime = time;\n            hasLanded = false;\n            rotationAxis = Random.onUnitSphere;\n        }\n    }\n    \n    void Start()\n    {\n        if (_leafPrefabs == null || _leafPrefabs.Length == 0)\n        {\n            Debug.LogWarning(\"No leaf prefabs assigned to FallingLeaves component!\");\n            return;\n        }\n        \n        _nextSpawnTime = Time.time + (1f / _spawnRate);\n    }\n    \n    void Update()\n    {\n        if (_leafPrefabs != null && _leafPrefabs.Length > 0)\n        {\n            SpawnLeaves();\n        }\n        \n        UpdateLeaves();\n        CleanupLeaves();\n    }\n    \n    void SpawnLeaves()\n    {\n        if (Time.time >= _nextSpawnTime && _activeLeaves.Count < _maxLeaves)\n        {\n            Vector3 spawnPosition = GetRandomSpawnPosition();\n            GameObject leafPrefab = _leafPrefabs[Random.Range(0, _leafPrefabs.Length)];\n            \n            if (leafPrefab != null)\n            {\n                GameObject newLeaf = Instantiate(leafPrefab, spawnPosition, Random.rotation);\n                \n                Rigidbody rb = newLeaf.GetComponent<Rigidbody>();\n                if (rb == null)\n                {\n                    rb = newLeaf.AddComponent<Rigidbody>();\n                }\n                \n                rb.useGravity = false;\n                rb.drag = 2f;\n                rb.angularDrag = 5f;\n                \n                Collider col = newLeaf.GetComponent<Collider>();\n                if (col == null)\n                {\n                    col = newLeaf.AddComponent<BoxCollider>();\n                }\n                col.isTrigger = false;\n                \n                LeafController leafController = new LeafController(newLeaf, spawnPosition, Time.time);\n                _activeLeaves.Add(leafController);\n            }\n            \n            _nextSpawnTime = Time.time + (1f / _spawnRate) + Random.Range(-0.2f, 0.2f);\n        }\n    }\n    \n    Vector3 GetRandomSpawnPosition()\n    {\n        Vector3 basePosition = transform.position;\n        float x = Random.Range(-_spawnAreaSize.x * 0.5f, _spawnAreaSize.x * 0.5f);\n        float y = _spawnHeight + Random.Range(0f, _spawnAreaSize.y);\n        float z = Random.Range(-_spawnAreaSize.z * 0.5f, _spawnAreaSize.z * 0.5f);\n        \n        return basePosition + new Vector3(x, y, z);\n    }\n    \n    void UpdateLeaves()\n    {\n        for (int i = _activeLeaves.Count - 1; i >= 0; i--)\n        {\n            LeafController leaf = _activeLeaves[i];\n            \n            if (leaf.leafObject == null)\n            {\n                _activeLeaves.RemoveAt(i);\n                continue;\n            }\n            \n            if (!leaf.hasLanded)\n            {\n                UpdateFallingLeaf(leaf);\n                CheckGroundCollision(leaf);\n            }\n            else\n            {\n                UpdateGroundedLeaf(leaf);\n            }\n        }\n    }\n    \n    void UpdateFallingLeaf(LeafController leaf)\n    {\n        Transform leafTransform = leaf.leafObject.transform;\n        \n        float swayX = Mathf.Sin((Time.time + leaf.swayOffset) * _swaySpeed) * _swayAmount;\n        float swayZ = Mathf.Cos((Time.time + leaf.swayOffset) * _swaySpeed * 0.7f) * _swayAmount * 0.5f;\n        \n        Vector3 movement = new Vector3(swayX, -_fallSpeed, swayZ) * Time.deltaTime;\n        movement += _windDirection.normalized * _windStrength * Time.deltaTime;\n        \n        leafTransform.position += movement;\n        \n        leafTransform.Rotate(leaf.rotationAxis * _rotationSpeed * Time.deltaTime);\n        \n        Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.velocity = movement / Time.deltaTime;\n        }\n    }\n    \n    void CheckGroundCollision(LeafController leaf)\n    {\n        Transform leafTransform = leaf.leafObject.transform;\n        \n        if (Physics.Raycast(leafTransform.position, Vector3.down, _groundCheckDistance, _groundLayer))\n        {\n            leaf.hasLanded = true;\n            \n            Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.velocity = Vector3.zero;\n                rb.angularVelocity = Vector3.zero;\n                rb.useGravity = true;\n                rb.drag = 10f;\n            }\n        }\n    }\n    \n    void UpdateGroundedLeaf(LeafController leaf)\n    {\n        Vector3 windForce = _windDirection.normalized * _windStrength * 0.1f;\n        \n        Rigidbody rb = leaf.leafObject.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.AddForce(windForce, ForceMode.Force);\n        }\n    }\n    \n    void CleanupLeaves()\n    {\n        for (int i = _activeLeaves.Count - 1; i >= 0; i--)\n        {\n            LeafController leaf = _activeLeaves[i];\n            \n            if (leaf.leafObject == null || Time.time - leaf.spawnTime > _leafLifetime)\n            {\n                if (leaf.leafObject != null)\n                {\n                    DestroyImmediate(leaf.leafObject);\n                }\n                _activeLeaves.RemoveAt(i);\n            }\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireCube(transform.position + Vector3.up * (_spawnHeight + _spawnAreaSize.y * 0.5f), _spawnAreaSize);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(transform.position, _windDirection.normalized * 3f);\n    }\n    \n    void OnDestroy()\n    {\n        for (int i = 0; i < _activeLeaves.Count; i++)\n        {\n            if (_activeLeaves[i].leafObject != null)\n            {\n                DestroyImmediate(_activeLeaves[i].leafObject);\n            }\n        }\n        _activeLeaves.Clear();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HealingMeditation\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healingAmount\",\n      \"type\": \"float\",\n      \"default\": 25.0\n    },\n    {\n      \"name\": \"meditationDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"healingRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentMeditationTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_meditation\",\n      \"trigger\": \"when player presses meditation key\",\n      \"actions\": [\n        {\n          \"action\": \"set meditation state to active\"\n        },\n        {\n          \"action\": \"play calming meditation sound\"\n        },\n        {\n          \"action\": \"start healing particle effects\"\n        },\n        {\n          \"action\": \"begin glowing aura around character\"\n        },\n        {\n          \"action\": \"reset meditation timer to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"meditation_healing\",\n      \"trigger\": \"while meditation is active and duration not exceeded\",\n      \"actions\": [\n        {\n          \"action\": \"increase meditation timer\"\n        },\n        {\n          \"action\": \"gradually restore player health\"\n        },\n        {\n          \"action\": \"emit healing energy particles\"\n        },\n        {\n          \"action\": \"pulse healing aura brightness\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_meditation\",\n      \"trigger\": \"when meditation duration is reached\",\n      \"actions\": [\n        {\n          \"action\": \"apply full healing amount to player\"\n        },\n        {\n          \"action\": \"stop meditation sound\"\n        },\n        {\n          \"action\": \"fade out particle effects\"\n        },\n        {\n          \"action\": \"disable healing aura\"\n        },\n        {\n          \"action\": \"set meditation state to inactive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interrupt_meditation\",\n      \"trigger\": \"when player moves or takes damage during meditation\",\n      \"actions\": [\n        {\n          \"action\": \"cancel meditation immediately\"\n        },\n        {\n          \"action\": \"stop all healing effects\"\n        },\n        {\n          \"action\": \"fade out meditation sound\"\n        },\n        {\n          \"action\": \"disable particle systems\"\n        },\n        {\n          \"action\": \"set meditation state to inactive\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class HealingMeditation : MonoBehaviour\n{\n    [System.Serializable]\n    public class HealingEvent : UnityEvent<float> { }\n    \n    [Header(\"Meditation Settings\")]\n    [SerializeField] private float _healingAmount = 25f;\n    [SerializeField] private float _meditationDuration = 5f;\n    [SerializeField] private float _cooldownTime = 10f;\n    [SerializeField] private float _detectionRadius = 2f;\n    [SerializeField] private KeyCode _meditationKey = KeyCode.E;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _healingParticles;\n    [SerializeField] private Light _meditationLight;\n    [SerializeField] private Color _healingColor = Color.green;\n    [SerializeField] private AnimationCurve _healingCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _meditationStartSound;\n    [SerializeField] private AudioClip _healingCompleteSound;\n    [SerializeField] private AudioClip _ambientMeditationLoop;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _meditationUI;\n    [SerializeField] private UnityEngine.UI.Slider _progressSlider;\n    [SerializeField] private UnityEngine.UI.Text _instructionText;\n    [SerializeField] private UnityEngine.UI.Text _cooldownText;\n    \n    [Header(\"Events\")]\n    public HealingEvent OnHealingComplete;\n    public UnityEvent OnMeditationStart;\n    public UnityEvent OnMeditationInterrupted;\n    \n    private bool _isMeditating = false;\n    private bool _isOnCooldown = false;\n    private float _meditationProgress = 0f;\n    private float _cooldownTimer = 0f;\n    private GameObject _currentPlayer;\n    private Coroutine _meditationCoroutine;\n    private Vector3 _originalLightIntensity;\n    private Color _originalLightColor;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupInitialState();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_meditationLight != null)\n        {\n            _originalLightIntensity = new Vector3(_meditationLight.intensity, 0, 0);\n            _originalLightColor = _meditationLight.color;\n        }\n        \n        if (OnHealingComplete == null)\n            OnHealingComplete = new HealingEvent();\n    }\n    \n    private void SetupInitialState()\n    {\n        if (_meditationUI != null)\n            _meditationUI.gameObject.SetActive(false);\n            \n        if (_healingParticles != null)\n            _healingParticles.SetActive(false);\n            \n        if (_meditationLight != null)\n            _meditationLight.enabled = false;\n    }\n    \n    private void Update()\n    {\n        HandleCooldown();\n        HandlePlayerInput();\n        UpdateUI();\n    }\n    \n    private void HandleCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                _cooldownTimer = 0f;\n            }\n        }\n    }\n    \n    private void HandlePlayerInput()\n    {\n        if (_currentPlayer != null && !_isOnCooldown)\n        {\n            if (Input.GetKeyDown(_meditationKey) && !_isMeditating)\n            {\n                StartMeditation();\n            }\n            else if (Input.GetKeyUp(_meditationKey) && _isMeditating)\n            {\n                InterruptMeditation();\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_meditationUI != null)\n        {\n            bool shouldShowUI = _currentPlayer != null && !_isOnCooldown;\n            _meditationUI.gameObject.SetActive(shouldShowUI);\n            \n            if (shouldShowUI)\n            {\n                if (_progressSlider != null)\n                    _progressSlider.value = _meditationProgress;\n                    \n                if (_instructionText != null)\n                {\n                    if (_isMeditating)\n                        _instructionText.text = \"Hold \" + _meditationKey + \" to meditate...\";\n                    else\n                        _instructionText.text = \"Press \" + _meditationKey + \" to start meditation\";\n                }\n            }\n        }\n        \n        if (_cooldownText != null)\n        {\n            if (_isOnCooldown)\n            {\n                _cooldownText.gameObject.SetActive(true);\n                _cooldownText.text = \"Cooldown: \" + Mathf.Ceil(_cooldownTimer).ToString() + \"s\";\n            }\n            else\n            {\n                _cooldownText.gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _currentPlayer = other.gameObject;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            _currentPlayer = null;\n            if (_isMeditating)\n                InterruptMeditation();\n        }\n    }\n    \n    private void StartMeditation()\n    {\n        if (_isMeditating || _isOnCooldown || _currentPlayer == null)\n            return;\n            \n        _isMeditating = true;\n        _meditationProgress = 0f;\n        \n        OnMeditationStart?.Invoke();\n        \n        if (_audioSource != null && _meditationStartSound != null)\n            _audioSource.PlayOneShot(_meditationStartSound);\n            \n        if (_healingParticles != null)\n            _healingParticles.SetActive(true);\n            \n        if (_meditationLight != null)\n        {\n            _meditationLight.enabled = true;\n            _meditationLight.color = _healingColor;\n        }\n        \n        _meditationCoroutine = StartCoroutine(MeditationProcess());\n        \n        if (_audioSource != null && _ambientMeditationLoop != null)\n        {\n            _audioSource.clip = _ambientMeditationLoop;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void InterruptMeditation()\n    {\n        if (!_isMeditating)\n            return;\n            \n        _isMeditating = false;\n        \n        if (_meditationCoroutine != null)\n        {\n            StopCoroutine(_meditationCoroutine);\n            _meditationCoroutine = null;\n        }\n        \n        OnMeditationInterrupted?.Invoke();\n        ResetMeditationEffects();\n    }\n    \n    private IEnumerator MeditationProcess()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _meditationDuration)\n        {\n            if (!Input.GetKey(_meditationKey))\n            {\n                InterruptMeditation();\n                yield break;\n            }\n            \n            elapsedTime += Time.deltaTime;\n            _meditationProgress = elapsedTime / _meditationDuration;\n            \n            UpdateMeditationEffects(_meditationProgress);\n            \n            yield return null;\n        }\n        \n        CompleteMeditation();\n    }\n    \n    private void UpdateMeditationEffects(float progress)\n    {\n        float curveValue = _healingCurve.Evaluate(progress);\n        \n        if (_meditationLight != null)\n        {\n            _meditationLight.intensity = _originalLightIntensity.x * curveValue;\n        }\n    }\n    \n    private void CompleteMeditation()\n    {\n        _isMeditating = false;\n        _meditationProgress = 1f;\n        \n        if (_audioSource != null && _healingCompleteSound != null)\n            _audioSource.PlayOneShot(_healingCompleteSound);\n            \n        OnHealingComplete?.Invoke(_healingAmount);\n        \n        StartCooldown();\n        ResetMeditationEffects();\n    }\n    \n    private void ResetMeditationEffects()\n    {\n        if (_healingParticles != null)\n            _healingParticles.SetActive(false);\n            \n        if (_meditationLight != null)\n        {\n            _meditationLight.enabled = false;\n            _meditationLight.color = _originalLightColor;\n            _meditationLight.intensity = _originalLightIntensity.x;\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.loop = false;\n            _audioSource.Stop();\n        }\n        \n        _meditationProgress = 0f;\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _healingColor;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n    }\n    \n    private void OnValidate()\n    {\n        if (_healingAmount < 0f)\n            _healingAmount = 0f;\n            \n        if (_meditationDuration < 0.1f)\n            _meditationDuration = 0.1f;\n            \n        if (_cooldownTime < 0f)\n            _cooldownTime = 0f;\n            \n        if (_detectionRadius < 0.1f)\n            _detectionRadius = 0.1f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RollingFog\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rollSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fogDensity\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"rollDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    },\n    {\n      \"name\": \"maxCoverage\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"currentCoverage\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_fog_roll\",\n      \"trigger\": \"when fog rolling begins\",\n      \"actions\": [\n        {\n          \"action\": \"activate particle system with fog effects\"\n        },\n        {\n          \"action\": \"play ambient fog rolling sound\"\n        },\n        {\n          \"action\": \"begin moving fog forward in roll direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"expand_fog_coverage\",\n      \"trigger\": \"while fog is rolling and coverage is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase fog density and coverage area\"\n        },\n        {\n          \"action\": \"reduce visibility in affected areas\"\n        },\n        {\n          \"action\": \"continue forward movement at roll speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_fog_presence\",\n      \"trigger\": \"when fog reaches maximum coverage\",\n      \"actions\": [\n        {\n          \"action\": \"maintain current fog density\"\n        },\n        {\n          \"action\": \"keep fog particles active and swirling\"\n        },\n        {\n          \"action\": \"continue playing ambient fog sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interact_with_environment\",\n      \"trigger\": \"when fog encounters obstacles or terrain changes\",\n      \"actions\": [\n        {\n          \"action\": \"flow around solid objects naturally\"\n        },\n        {\n          \"action\": \"settle into low areas and valleys\"\n        },\n        {\n          \"action\": \"adjust particle density based on terrain\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\n\npublic class FogRoller : MonoBehaviour\n{\n    [Header(\"Fog Settings\")]\n    [SerializeField] private bool _enableFog = true;\n    [SerializeField] private Color _fogColor = Color.gray;\n    [SerializeField] private FogMode _fogMode = FogMode.ExponentialSquared;\n    \n    [Header(\"Rolling Animation\")]\n    [SerializeField] private float _rollDuration = 30f;\n    [SerializeField] private AnimationCurve _rollCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private bool _rollOnStart = true;\n    [SerializeField] private bool _loop = false;\n    \n    [Header(\"Fog Density\")]\n    [SerializeField] private float _startDensity = 0f;\n    [SerializeField] private float _endDensity = 0.02f;\n    \n    [Header(\"Fog Distance (Linear Mode)\")]\n    [SerializeField] private float _startDistance = 300f;\n    [SerializeField] private float _endDistance = 50f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _fogParticles;\n    [SerializeField] private Light _ambientLight;\n    [SerializeField] private Color _startLightColor = Color.white;\n    [SerializeField] private Color _endLightColor = Color.gray;\n    [SerializeField] private float _startLightIntensity = 1f;\n    [SerializeField] private float _endLightIntensity = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fogRollingSound;\n    [SerializeField] private float _audioFadeInDuration = 5f;\n    \n    private bool _isRolling = false;\n    private float _rollTimer = 0f;\n    private bool _originalFogEnabled;\n    private Color _originalFogColor;\n    private FogMode _originalFogMode;\n    private float _originalFogDensity;\n    private float _originalFogStartDistance;\n    private float _originalFogEndDistance;\n    private Color _originalLightColor;\n    private float _originalLightIntensity;\n    private float _targetAudioVolume;\n    \n    private void Start()\n    {\n        StoreOriginalSettings();\n        \n        if (_audioSource != null)\n        {\n            _targetAudioVolume = _audioSource.volume;\n            _audioSource.volume = 0f;\n        }\n        \n        if (_rollOnStart)\n        {\n            StartFogRoll();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isRolling)\n        {\n            UpdateFogRoll();\n        }\n    }\n    \n    private void StoreOriginalSettings()\n    {\n        _originalFogEnabled = RenderSettings.fog;\n        _originalFogColor = RenderSettings.fogColor;\n        _originalFogMode = RenderSettings.fogMode;\n        _originalFogDensity = RenderSettings.fogDensity;\n        _originalFogStartDistance = RenderSettings.fogStartDistance;\n        _originalFogEndDistance = RenderSettings.fogEndDistance;\n        \n        if (_ambientLight != null)\n        {\n            _originalLightColor = _ambientLight.color;\n            _originalLightIntensity = _ambientLight.intensity;\n        }\n    }\n    \n    public void StartFogRoll()\n    {\n        if (_isRolling) return;\n        \n        _isRolling = true;\n        _rollTimer = 0f;\n        \n        RenderSettings.fog = _enableFog;\n        RenderSettings.fogMode = _fogMode;\n        RenderSettings.fogColor = _fogColor;\n        \n        if (_fogParticles != null && !_fogParticles.isPlaying)\n        {\n            _fogParticles.Play();\n        }\n        \n        if (_audioSource != null && _fogRollingSound != null)\n        {\n            _audioSource.clip = _fogRollingSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    public void StopFogRoll()\n    {\n        if (!_isRolling) return;\n        \n        _isRolling = false;\n        RestoreOriginalSettings();\n        \n        if (_fogParticles != null && _fogParticles.isPlaying)\n        {\n            _fogParticles.Stop();\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void UpdateFogRoll()\n    {\n        _rollTimer += Time.deltaTime;\n        float normalizedTime = Mathf.Clamp01(_rollTimer / _rollDuration);\n        float curveValue = _rollCurve.Evaluate(normalizedTime);\n        \n        // Update fog density\n        if (_fogMode == FogMode.Exponential || _fogMode == FogMode.ExponentialSquared)\n        {\n            RenderSettings.fogDensity = Mathf.Lerp(_startDensity, _endDensity, curveValue);\n        }\n        else if (_fogMode == FogMode.Linear)\n        {\n            RenderSettings.fogStartDistance = Mathf.Lerp(_startDistance, _endDistance, curveValue);\n            RenderSettings.fogEndDistance = RenderSettings.fogStartDistance * 2f;\n        }\n        \n        // Update ambient light\n        if (_ambientLight != null)\n        {\n            _ambientLight.color = Color.Lerp(_startLightColor, _endLightColor, curveValue);\n            _ambientLight.intensity = Mathf.Lerp(_startLightIntensity, _endLightIntensity, curveValue);\n        }\n        \n        // Update audio volume\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float audioFadeProgress = Mathf.Clamp01(_rollTimer / _audioFadeInDuration);\n            _audioSource.volume = Mathf.Lerp(0f, _targetAudioVolume, audioFadeProgress);\n        }\n        \n        // Check if roll is complete\n        if (normalizedTime >= 1f)\n        {\n            if (_loop)\n            {\n                _rollTimer = 0f;\n            }\n            else\n            {\n                _isRolling = false;\n                \n                if (_audioSource != null && _audioSource.isPlaying)\n                {\n                    _audioSource.Stop();\n                }\n            }\n        }\n    }\n    \n    private void RestoreOriginalSettings()\n    {\n        RenderSettings.fog = _originalFogEnabled;\n        RenderSettings.fogColor = _originalFogColor;\n        RenderSettings.fogMode = _originalFogMode;\n        RenderSettings.fogDensity = _originalFogDensity;\n        RenderSettings.fogStartDistance = _originalFogStartDistance;\n        RenderSettings.fogEndDistance = _originalFogEndDistance;\n        \n        if (_ambientLight != null)\n        {\n            _ambientLight.color = _originalLightColor;\n            _ambientLight.intensity = _originalLightIntensity;\n        }\n    }\n    \n    public void ToggleFogRoll()\n    {\n        if (_isRolling)\n        {\n            StopFogRoll();\n        }\n        else\n        {\n            StartFogRoll();\n        }\n    }\n    \n    public bool IsRolling => _isRolling;\n    \n    public float RollProgress => _isRolling ? Mathf.Clamp01(_rollTimer / _rollDuration) : 0f;\n    \n    private void OnDestroy()\n    {\n        if (_isRolling)\n        {\n            RestoreOriginalSettings();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _rollDuration = Mathf.Max(0.1f, _rollDuration);\n        _startDensity = Mathf.Max(0f, _startDensity);\n        _endDensity = Mathf.Max(0f, _endDensity);\n        _startDistance = Mathf.Max(0.1f, _startDistance);\n        _endDistance = Mathf.Max(0.1f, _endDistance);\n        _audioFadeInDuration = Mathf.Max(0.1f, _audioFadeInDuration);\n        _startLightIntensity = Mathf.Max(0f, _startLightIntensity);\n        _endLightIntensity = Mathf.Max(0f, _endLightIntensity);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwingSword\",\n  \"components\": [\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swingCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isSwinging\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"swing_sword\",\n      \"trigger\": \"when left mouse button is pressed and sword is not currently swinging and cooldown period has passed\",\n      \"actions\": [\n        {\n          \"action\": \"set swinging state to true\"\n        },\n        {\n          \"action\": \"play sword swing animation\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_swing\",\n      \"trigger\": \"when sword swing animation completes\",\n      \"actions\": [\n        {\n          \"action\": \"set swinging state to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_cooldown\",\n      \"trigger\": \"every frame while cooldown timer is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease cooldown timer by frame time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SwordController : MonoBehaviour\n{\n    [Header(\"Sword Settings\")]\n    [SerializeField] private float _swingDuration = 0.5f;\n    [SerializeField] private float _swingAngle = 90f;\n    [SerializeField] private AnimationCurve _swingCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private KeyCode _swingKey = KeyCode.Mouse0;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _damage = 10f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private LayerMask _enemyLayers = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swingSound;\n    [SerializeField] private AudioClip _hitSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _slashEffect;\n    [SerializeField] private Transform _effectSpawnPoint;\n    \n    private bool _isSwinging = false;\n    private float _swingTimer = 0f;\n    private Vector3 _initialRotation;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private bool _hasDealtDamage = false;\n    \n    private void Start()\n    {\n        _initialRotation = transform.localEulerAngles;\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_effectSpawnPoint == null)\n        {\n            _effectSpawnPoint = transform;\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateSwingAnimation();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_swingKey) && !_isSwinging)\n        {\n            StartSwing();\n        }\n    }\n    \n    private void StartSwing()\n    {\n        _isSwinging = true;\n        _swingTimer = 0f;\n        _hasDealtDamage = false;\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(\"Swing\");\n        }\n        \n        PlaySwingSound();\n        SpawnSlashEffect();\n    }\n    \n    private void UpdateSwingAnimation()\n    {\n        if (!_isSwinging) return;\n        \n        _swingTimer += Time.deltaTime;\n        float progress = _swingTimer / _swingDuration;\n        \n        if (progress >= 1f)\n        {\n            progress = 1f;\n            _isSwinging = false;\n        }\n        \n        float curveValue = _swingCurve.Evaluate(progress);\n        float currentAngle = curveValue * _swingAngle;\n        \n        Vector3 rotation = _initialRotation;\n        rotation.z += currentAngle;\n        transform.localEulerAngles = rotation;\n        \n        // Check for hits during the middle portion of the swing\n        if (progress >= 0.3f && progress <= 0.7f && !_hasDealtDamage)\n        {\n            CheckForHits();\n        }\n        \n        // Return to initial position when swing is complete\n        if (!_isSwinging)\n        {\n            transform.localEulerAngles = _initialRotation;\n        }\n    }\n    \n    private void CheckForHits()\n    {\n        Vector3 attackPosition = transform.position + transform.forward * (_attackRange * 0.5f);\n        Collider[] hitColliders = Physics.OverlapSphere(attackPosition, _attackRange, _enemyLayers);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            if (hitCollider.gameObject != gameObject && \n                hitCollider.transform.parent != transform.parent)\n            {\n                DealDamage(hitCollider.gameObject);\n                _hasDealtDamage = true;\n                break;\n            }\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        // Try to find common health components\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - target can implement this method\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Apply knockback\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n        \n        PlayHitSound();\n        \n        // Destroy objects tagged as destructible\n        if (target.CompareTag(\"Destructible\"))\n        {\n            Destroy(target);\n        }\n    }\n    \n    private void PlaySwingSound()\n    {\n        if (_audioSource != null && _swingSound != null)\n        {\n            _audioSource.PlayOneShot(_swingSound);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void SpawnSlashEffect()\n    {\n        if (_slashEffect != null && _effectSpawnPoint != null)\n        {\n            GameObject effect = Instantiate(_slashEffect, _effectSpawnPoint.position, _effectSpawnPoint.rotation);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw attack range\n        Gizmos.color = Color.red;\n        Vector3 attackPosition = transform.position + transform.forward * (_attackRange * 0.5f);\n        Gizmos.DrawWireSphere(attackPosition, _attackRange);\n        \n        // Draw swing arc\n        Gizmos.color = Color.yellow;\n        Vector3 startDirection = Quaternion.Euler(0, 0, -_swingAngle * 0.5f) * transform.right;\n        Vector3 endDirection = Quaternion.Euler(0, 0, _swingAngle * 0.5f) * transform.right;\n        \n        Gizmos.DrawRay(transform.position, startDirection * _attackRange);\n        Gizmos.DrawRay(transform.position, endDirection * _attackRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ColorMatchingPuzzleBlock\",\n  \"components\": [\n    \"Renderer\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"blockColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.red\"\n    },\n    {\n      \"name\": \"targetColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.red\"\n    },\n    {\n      \"name\": \"isMatched\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canBeClicked\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"matchSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"clickSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"animationDuration\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_block\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set block color to a random color from available colors\"\n        },\n        {\n          \"action\": \"set target color based on puzzle configuration\"\n        },\n        {\n          \"action\": \"update visual appearance to show current color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_click\",\n      \"trigger\": \"when player clicks on this block\",\n      \"actions\": [\n        {\n          \"action\": \"play click sound effect\"\n        },\n        {\n          \"action\": \"cycle to next available color in sequence\"\n        },\n        {\n          \"action\": \"update visual appearance with new color\"\n        },\n        {\n          \"action\": \"animate color transition smoothly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_color_match\",\n      \"trigger\": \"when block color changes\",\n      \"actions\": [\n        {\n          \"action\": \"compare current color with target color\"\n        },\n        {\n          \"action\": \"set matched status if colors are identical\"\n        },\n        {\n          \"action\": \"notify puzzle manager of match status change\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_match_feedback\",\n      \"trigger\": \"when block becomes matched\",\n      \"actions\": [\n        {\n          \"action\": \"play success sound effect\"\n        },\n        {\n          \"action\": \"add glowing effect around block edges\"\n        },\n        {\n          \"action\": \"disable further clicking on this block\"\n        },\n        {\n          \"action\": \"animate celebration effect briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_hover_effect\",\n      \"trigger\": \"when mouse hovers over clickable block\",\n      \"actions\": [\n        {\n          \"action\": \"slightly increase block scale\"\n        },\n        {\n          \"action\": \"add subtle highlight outline\"\n        },\n        {\n          \"action\": \"show preview of next color in sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_hover_effect\",\n      \"trigger\": \"when mouse stops hovering over block\",\n      \"actions\": [\n        {\n          \"action\": \"return block to normal scale\"\n        },\n        {\n          \"action\": \"remove highlight outline\"\n        },\n        {\n          \"action\": \"hide color preview\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_block\",\n      \"trigger\": \"when puzzle is reset\",\n      \"actions\": [\n        {\n          \"action\": \"set block color back to initial random color\"\n        },\n        {\n          \"action\": \"clear matched status\"\n        },\n        {\n          \"action\": \"enable clicking functionality\"\n        },\n        {\n          \"action\": \"remove any visual effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class ColorMatchingPuzzle : MonoBehaviour\n{\n    [System.Serializable]\n    public class PuzzleBlock\n    {\n        public GameObject blockObject;\n        public Renderer blockRenderer;\n        public Color currentColor;\n        public Vector2Int gridPosition;\n        public bool isMatched;\n        \n        public PuzzleBlock(GameObject obj, Vector2Int pos)\n        {\n            blockObject = obj;\n            blockRenderer = obj.GetComponent<Renderer>();\n            gridPosition = pos;\n            isMatched = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class ColorSet\n    {\n        public Color color;\n        public Material material;\n    }\n    \n    [Header(\"Grid Settings\")]\n    [SerializeField] private int _gridWidth = 5;\n    [SerializeField] private int _gridHeight = 5;\n    [SerializeField] private float _blockSpacing = 1.1f;\n    [SerializeField] private GameObject _blockPrefab;\n    \n    [Header(\"Colors\")]\n    [SerializeField] private ColorSet[] _availableColors;\n    [SerializeField] private int _minMatchCount = 3;\n    \n    [Header(\"Gameplay\")]\n    [SerializeField] private float _swapAnimationDuration = 0.3f;\n    [SerializeField] private float _matchDelay = 0.5f;\n    [SerializeField] private float _fallSpeed = 5f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _matchEffectPrefab;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _swapSound;\n    [SerializeField] private AudioClip _matchSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnBlocksMatched;\n    public UnityEvent OnPuzzleCompleted;\n    public UnityEvent OnNoMovesAvailable;\n    \n    private PuzzleBlock[,] _grid;\n    private PuzzleBlock _selectedBlock;\n    private bool _isProcessing;\n    private Camera _mainCamera;\n    private int _totalMatches;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        InitializeGrid();\n        GenerateInitialBlocks();\n    }\n    \n    private void Update()\n    {\n        if (!_isProcessing)\n        {\n            HandleInput();\n        }\n    }\n    \n    private void InitializeGrid()\n    {\n        _grid = new PuzzleBlock[_gridWidth, _gridHeight];\n        \n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                Vector3 position = new Vector3(\n                    (x - _gridWidth / 2f) * _blockSpacing,\n                    (y - _gridHeight / 2f) * _blockSpacing,\n                    0\n                );\n                \n                GameObject blockObj = Instantiate(_blockPrefab, position, Quaternion.identity, transform);\n                blockObj.name = $\"Block_{x}_{y}\";\n                \n                PuzzleBlock block = new PuzzleBlock(blockObj, new Vector2Int(x, y));\n                _grid[x, y] = block;\n                \n                // Add collider for mouse interaction\n                if (blockObj.GetComponent<Collider>() == null)\n                {\n                    blockObj.AddComponent<BoxCollider>();\n                }\n            }\n        }\n    }\n    \n    private void GenerateInitialBlocks()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                AssignRandomColor(_grid[x, y]);\n            }\n        }\n        \n        // Ensure no initial matches\n        while (HasMatches())\n        {\n            for (int x = 0; x < _gridWidth; x++)\n            {\n                for (int y = 0; y < _gridHeight; y++)\n                {\n                    if (IsPartOfMatch(_grid[x, y]))\n                    {\n                        AssignRandomColor(_grid[x, y]);\n                    }\n                }\n            }\n        }\n    }\n    \n    private void AssignRandomColor(PuzzleBlock block)\n    {\n        if (_availableColors.Length == 0) return;\n        \n        ColorSet colorSet = _availableColors[Random.Range(0, _availableColors.Length)];\n        block.currentColor = colorSet.color;\n        \n        if (block.blockRenderer != null && colorSet.material != null)\n        {\n            block.blockRenderer.material = colorSet.material;\n        }\n        else if (block.blockRenderer != null)\n        {\n            block.blockRenderer.material.color = colorSet.color;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n            \n            if (Physics.Raycast(ray, out hit))\n            {\n                PuzzleBlock clickedBlock = GetBlockFromGameObject(hit.collider.gameObject);\n                \n                if (clickedBlock != null)\n                {\n                    if (_selectedBlock == null)\n                    {\n                        SelectBlock(clickedBlock);\n                    }\n                    else if (_selectedBlock == clickedBlock)\n                    {\n                        DeselectBlock();\n                    }\n                    else if (AreAdjacent(_selectedBlock, clickedBlock))\n                    {\n                        StartCoroutine(SwapBlocks(_selectedBlock, clickedBlock));\n                    }\n                    else\n                    {\n                        SelectBlock(clickedBlock);\n                    }\n                }\n            }\n        }\n    }\n    \n    private PuzzleBlock GetBlockFromGameObject(GameObject obj)\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (_grid[x, y].blockObject == obj)\n                {\n                    return _grid[x, y];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private void SelectBlock(PuzzleBlock block)\n    {\n        DeselectBlock();\n        _selectedBlock = block;\n        \n        // Visual feedback for selection\n        if (block.blockRenderer != null)\n        {\n            block.blockRenderer.material.color = Color.Lerp(block.currentColor, Color.white, 0.3f);\n        }\n    }\n    \n    private void DeselectBlock()\n    {\n        if (_selectedBlock != null && _selectedBlock.blockRenderer != null)\n        {\n            _selectedBlock.blockRenderer.material.color = _selectedBlock.currentColor;\n        }\n        _selectedBlock = null;\n    }\n    \n    private bool AreAdjacent(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        Vector2Int pos1 = block1.gridPosition;\n        Vector2Int pos2 = block2.gridPosition;\n        \n        int deltaX = Mathf.Abs(pos1.x - pos2.x);\n        int deltaY = Mathf.Abs(pos1.y - pos2.y);\n        \n        return (deltaX == 1 && deltaY == 0) || (deltaX == 0 && deltaY == 1);\n    }\n    \n    private IEnumerator SwapBlocks(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        _isProcessing = true;\n        DeselectBlock();\n        \n        // Play swap sound\n        if (_audioSource != null && _swapSound != null)\n        {\n            _audioSource.PlayOneShot(_swapSound);\n        }\n        \n        // Animate swap\n        Vector3 pos1 = block1.blockObject.transform.position;\n        Vector3 pos2 = block2.blockObject.transform.position;\n        \n        float elapsed = 0f;\n        while (elapsed < _swapAnimationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / _swapAnimationDuration;\n            \n            block1.blockObject.transform.position = Vector3.Lerp(pos1, pos2, t);\n            block2.blockObject.transform.position = Vector3.Lerp(pos2, pos1, t);\n            \n            yield return null;\n        }\n        \n        // Complete swap\n        block1.blockObject.transform.position = pos2;\n        block2.blockObject.transform.position = pos1;\n        \n        // Swap colors\n        Color tempColor = block1.currentColor;\n        Material tempMaterial = block1.blockRenderer.material;\n        \n        block1.currentColor = block2.currentColor;\n        block1.blockRenderer.material = block2.blockRenderer.material;\n        \n        block2.currentColor = tempColor;\n        block2.blockRenderer.material = tempMaterial;\n        \n        // Check for matches\n        yield return new WaitForSeconds(_matchDelay);\n        \n        if (HasMatches())\n        {\n            yield return StartCoroutine(ProcessMatches());\n        }\n        else\n        {\n            // Swap back if no matches\n            yield return StartCoroutine(SwapBlocksBack(block1, block2));\n        }\n        \n        _isProcessing = false;\n    }\n    \n    private IEnumerator SwapBlocksBack(PuzzleBlock block1, PuzzleBlock block2)\n    {\n        Vector3 pos1 = block1.blockObject.transform.position;\n        Vector3 pos2 = block2.blockObject.transform.position;\n        \n        float elapsed = 0f;\n        while (elapsed < _swapAnimationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / _swapAnimationDuration;\n            \n            block1.blockObject.transform.position = Vector3.Lerp(pos1, pos2, t);\n            block2.blockObject.transform.position = Vector3.Lerp(pos2, pos1, t);\n            \n            yield return null;\n        }\n        \n        // Swap colors back\n        Color tempColor = block1.currentColor;\n        Material tempMaterial = block1.blockRenderer.material;\n        \n        block1.currentColor = block2.currentColor;\n        block1.blockRenderer.material = block2.blockRenderer.material;\n        \n        block2.currentColor = tempColor;\n        block2.blockRenderer.material = tempMaterial;\n    }\n    \n    private bool HasMatches()\n    {\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (IsPartOfMatch(_grid[x, y]))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private bool IsPartOfMatch(PuzzleBlock block)\n    {\n        return GetHorizontalMatchLength(block) >= _minMatchCount || \n               GetVerticalMatchLength(block) >= _minMatchCount;\n    }\n    \n    private int GetHorizontalMatchLength(PuzzleBlock block)\n    {\n        int count = 1;\n        Color color = block.currentColor;\n        Vector2Int pos = block.gridPosition;\n        \n        // Check left\n        for (int x = pos.x - 1; x >= 0; x--)\n        {\n            if (_grid[x, pos.y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        // Check right\n        for (int x = pos.x + 1; x < _gridWidth; x++)\n        {\n            if (_grid[x, pos.y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        return count;\n    }\n    \n    private int GetVerticalMatchLength(PuzzleBlock block)\n    {\n        int count = 1;\n        Color color = block.currentColor;\n        Vector2Int pos = block.gridPosition;\n        \n        // Check down\n        for (int y = pos.y - 1; y >= 0; y--)\n        {\n            if (_grid[pos.x, y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        // Check up\n        for (int y = pos.y + 1; y < _gridHeight; y++)\n        {\n            if (_grid[pos.x, y].currentColor == color)\n                count++;\n            else\n                break;\n        }\n        \n        return count;\n    }\n    \n    private IEnumerator ProcessMatches()\n    {\n        List<PuzzleBlock> matchedBlocks = new List<PuzzleBlock>();\n        \n        // Find all matched blocks\n        for (int x = 0; x < _gridWidth; x++)\n        {\n            for (int y = 0; y < _gridHeight; y++)\n            {\n                if (IsPartOfMatch(_grid[x, y]))\n                {\n                    matchedBlocks.Add(_grid[x, y]);\n                    _grid[x, y].isMatched = true;\n                }\n            }\n        }\n        \n        // Play match sound and effects\n        if (_audioSource != null && _matchSound != null)\n        {\n            _audioSource.PlayOneShot(_matchSound);\n        }\n        \n        foreach (PuzzleBlock block in matchedBlocks)\n        {\n            if (_matchEffectPrefab != null)\n            {\n                Instantiate(_matchEffectPrefab, block.blockObject.transform.position, Quaternion.identity);\n            }\n        }\n        \n        _totalMatches += matchedBlocks.Count;\n        OnBlocksMatched?.Invoke(matchedBlocks.Count);\n        \n        // Remove matched blocks\n        foreach (PuzzleBlock block in matchedBlocks)\n        {\n            block.blockObject.SetActive(false);\n        }\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        // Drop blocks down\n        yield return StartCoroutine(DropBlocks());\n        \n        // Fill empty spaces\n        FillEmptySpaces();\n        \n        // Check for more matches\n        if (HasMatches())\n        {\n            yield return StartCoroutine(ProcessMatches());\n        }\n        else\n        {\n            CheckGameState();\n        }\n    }\n    \n    private IEnumerator DropBlocks()\n    {\n        bool blocksDropped = true;\n        \n        while (blocksDropped)\n        {\n            blocksDropped = false;\n            \n            for (int x = 0; x < _gridWidth; x++)\n            {\n                for (int y = 0; y < _gridHeight - 1; y++)\n                {\n                    if (!_grid[x, y].blockObject.activeInHierarchy && _grid[x, y + 1].blockObject.activeInHierarchy)\n                    {\n                        // Move block down\n                        _grid[x, y].blockObject.SetActive(true);\n                        _grid[x, y].currentColor = _grid[x, y + 1].currentColor;\n                        _grid[x, y].blockRenderer.material = _grid[x, y + 1].blockRenderer.material;\n                        \n                        _grid[x, y + 1].blockObject.SetActive(false);\n                        blocksDropped = true;\n                    }\n                }\n            }\n            \n            if (blocksDropped)\n            {\n                yield return new"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ComboCounter\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentCombo\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxCombo\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"comboTimeWindow\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"timeSinceLastHit\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"comboMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isComboActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"increment_combo\",\n      \"trigger\": \"when player successfully hits target\",\n      \"actions\": [\n        {\n          \"action\": \"increase current combo count by one\"\n        },\n        {\n          \"action\": \"reset time since last hit to zero\"\n        },\n        {\n          \"action\": \"set combo as active\"\n        },\n        {\n          \"action\": \"update max combo if current combo exceeds it\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_combo_on_timeout\",\n      \"trigger\": \"when time since last hit exceeds combo time window\",\n      \"actions\": [\n        {\n          \"action\": \"reset current combo to zero\"\n        },\n        {\n          \"action\": \"set combo as inactive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_combo_on_miss\",\n      \"trigger\": \"when player misses or takes damage\",\n      \"actions\": [\n        {\n          \"action\": \"reset current combo to zero\"\n        },\n        {\n          \"action\": \"set combo as inactive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_timer\",\n      \"trigger\": \"every frame when combo is active\",\n      \"actions\": [\n        {\n          \"action\": \"increase time since last hit by frame time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_combo_bonus\",\n      \"trigger\": \"when calculating score or damage\",\n      \"actions\": [\n        {\n          \"action\": \"multiply base value by combo multiplier based on current combo count\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ComboCounter : MonoBehaviour\n{\n    [Header(\"Combo Settings\")]\n    [SerializeField] private int _maxCombo = 999;\n    [SerializeField] private float _comboTimeWindow = 2f;\n    [SerializeField] private int _minComboToDisplay = 2;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _comboText;\n    [SerializeField] private GameObject _comboPanel;\n    [SerializeField] private Animator _comboAnimator;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _comboParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _comboSound;\n    [SerializeField] private AudioClip _comboBreakSound;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _highComboColor = Color.yellow;\n    [SerializeField] private Color _maxComboColor = Color.red;\n    [SerializeField] private int _highComboThreshold = 10;\n    [SerializeField] private int _maxComboThreshold = 50;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnComboChanged;\n    public UnityEvent<int> OnComboBreak;\n    public UnityEvent<int> OnHighCombo;\n    \n    private int _currentCombo = 0;\n    private float _lastComboTime;\n    private Coroutine _comboTimerCoroutine;\n    private bool _isComboActive = false;\n    \n    public int CurrentCombo => _currentCombo;\n    public bool IsComboActive => _isComboActive;\n    \n    private void Start()\n    {\n        InitializeCombo();\n    }\n    \n    private void InitializeCombo()\n    {\n        _currentCombo = 0;\n        _isComboActive = false;\n        \n        if (_comboPanel != null)\n            _comboPanel.SetActive(false);\n            \n        UpdateComboDisplay();\n    }\n    \n    public void AddCombo()\n    {\n        AddCombo(1);\n    }\n    \n    public void AddCombo(int amount)\n    {\n        if (amount <= 0) return;\n        \n        _currentCombo = Mathf.Min(_currentCombo + amount, _maxCombo);\n        _lastComboTime = Time.time;\n        \n        if (_currentCombo >= _minComboToDisplay && !_isComboActive)\n        {\n            _isComboActive = true;\n            ShowComboUI();\n        }\n        \n        UpdateComboDisplay();\n        PlayComboEffects();\n        \n        OnComboChanged?.Invoke(_currentCombo);\n        \n        if (_currentCombo >= _highComboThreshold)\n        {\n            OnHighCombo?.Invoke(_currentCombo);\n        }\n        \n        RestartComboTimer();\n    }\n    \n    public void BreakCombo()\n    {\n        if (_currentCombo > 0)\n        {\n            int brokenCombo = _currentCombo;\n            _currentCombo = 0;\n            _isComboActive = false;\n            \n            HideComboUI();\n            PlayComboBreakEffects();\n            \n            OnComboBreak?.Invoke(brokenCombo);\n            OnComboChanged?.Invoke(_currentCombo);\n        }\n        \n        StopComboTimer();\n    }\n    \n    private void RestartComboTimer()\n    {\n        StopComboTimer();\n        _comboTimerCoroutine = StartCoroutine(ComboTimerCoroutine());\n    }\n    \n    private void StopComboTimer()\n    {\n        if (_comboTimerCoroutine != null)\n        {\n            StopCoroutine(_comboTimerCoroutine);\n            _comboTimerCoroutine = null;\n        }\n    }\n    \n    private IEnumerator ComboTimerCoroutine()\n    {\n        while (Time.time - _lastComboTime < _comboTimeWindow)\n        {\n            yield return null;\n        }\n        \n        BreakCombo();\n    }\n    \n    private void UpdateComboDisplay()\n    {\n        if (_comboText != null)\n        {\n            _comboText.text = _currentCombo.ToString();\n            _comboText.color = GetComboColor();\n        }\n    }\n    \n    private Color GetComboColor()\n    {\n        if (_currentCombo >= _maxComboThreshold)\n            return _maxComboColor;\n        else if (_currentCombo >= _highComboThreshold)\n            return _highComboColor;\n        else\n            return _normalColor;\n    }\n    \n    private void ShowComboUI()\n    {\n        if (_comboPanel != null)\n        {\n            _comboPanel.SetActive(true);\n        }\n        \n        if (_comboAnimator != null)\n        {\n            _comboAnimator.SetTrigger(\"Show\");\n        }\n    }\n    \n    private void HideComboUI()\n    {\n        if (_comboAnimator != null)\n        {\n            _comboAnimator.SetTrigger(\"Hide\");\n        }\n        else if (_comboPanel != null)\n        {\n            _comboPanel.SetActive(false);\n        }\n    }\n    \n    private void PlayComboEffects()\n    {\n        if (_comboParticles != null && _currentCombo % 5 == 0)\n        {\n            _comboParticles.Play();\n        }\n        \n        if (_audioSource != null && _comboSound != null)\n        {\n            float pitch = 1f + (_currentCombo * 0.02f);\n            _audioSource.pitch = Mathf.Clamp(pitch, 0.8f, 2f);\n            _audioSource.PlayOneShot(_comboSound);\n        }\n    }\n    \n    private void PlayComboBreakEffects()\n    {\n        if (_audioSource != null && _comboBreakSound != null)\n        {\n            _audioSource.pitch = 1f;\n            _audioSource.PlayOneShot(_comboBreakSound);\n        }\n    }\n    \n    public void ResetCombo()\n    {\n        _currentCombo = 0;\n        _isComboActive = false;\n        StopComboTimer();\n        HideComboUI();\n        UpdateComboDisplay();\n        OnComboChanged?.Invoke(_currentCombo);\n    }\n    \n    public void SetComboTimeWindow(float timeWindow)\n    {\n        _comboTimeWindow = Mathf.Max(0.1f, timeWindow);\n    }\n    \n    public float GetRemainingTime()\n    {\n        if (!_isComboActive) return 0f;\n        return Mathf.Max(0f, _comboTimeWindow - (Time.time - _lastComboTime));\n    }\n    \n    public float GetComboTimeProgress()\n    {\n        if (!_isComboActive) return 0f;\n        return GetRemainingTime() / _comboTimeWindow;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            AddCombo();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        StopComboTimer();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ProximityMine\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"armingDelay\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isArmed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"arm_mine\",\n      \"trigger\": \"when arming delay time has passed after being placed\",\n      \"actions\": [\n        {\n          \"action\": \"set mine to armed state\"\n        },\n        {\n          \"action\": \"play arming sound effect\"\n        },\n        {\n          \"action\": \"activate blinking light indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detonate_on_contact\",\n      \"trigger\": \"when something steps on or touches the mine and mine is armed\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect at mine location\"\n        },\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"deal damage to all objects within explosion radius\"\n        },\n        {\n          \"action\": \"apply explosive force to nearby objects\"\n        },\n        {\n          \"action\": \"destroy the mine object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when mine is armed\",\n      \"actions\": [\n        {\n          \"action\": \"slowly pulse red light to indicate active state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LandMine : MonoBehaviour\n{\n    [Header(\"Mine Settings\")]\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _damage = 100f;\n    [SerializeField] private float _armingDelay = 1f;\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _explosionPrefab;\n    [SerializeField] private GameObject _armedIndicator;\n    [SerializeField] private AudioClip _armingSound;\n    [SerializeField] private AudioClip _explosionSound;\n    [SerializeField] private float _blinkRate = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnMineArmed;\n    public UnityEvent OnMineTriggered;\n    public UnityEvent<float> OnDamageDealt;\n    \n    private bool _isArmed = false;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Collider _triggerCollider;\n    private Renderer _indicatorRenderer;\n    private float _blinkTimer = 0f;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider == null)\n        {\n            _triggerCollider = gameObject.AddComponent<SphereCollider>();\n            ((SphereCollider)_triggerCollider).radius = 0.5f;\n        }\n        _triggerCollider.isTrigger = true;\n        \n        if (_armedIndicator != null)\n        {\n            _indicatorRenderer = _armedIndicator.GetComponent<Renderer>();\n            _armedIndicator.SetActive(false);\n        }\n        \n        StartCoroutine(ArmMineAfterDelay());\n    }\n    \n    private void Update()\n    {\n        if (_isArmed && !_hasExploded && _indicatorRenderer != null)\n        {\n            _blinkTimer += Time.deltaTime;\n            if (_blinkTimer >= 1f / _blinkRate)\n            {\n                _blinkTimer = 0f;\n                _indicatorRenderer.enabled = !_indicatorRenderer.enabled;\n            }\n        }\n    }\n    \n    private System.Collections.IEnumerator ArmMineAfterDelay()\n    {\n        yield return new WaitForSeconds(_armingDelay);\n        ArmMine();\n    }\n    \n    private void ArmMine()\n    {\n        if (_hasExploded) return;\n        \n        _isArmed = true;\n        \n        if (_armedIndicator != null)\n        {\n            _armedIndicator.SetActive(true);\n        }\n        \n        if (_armingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_armingSound);\n        }\n        \n        OnMineArmed?.Invoke();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isArmed || _hasExploded) return;\n        \n        if (IsValidTrigger(other))\n        {\n            TriggerExplosion();\n        }\n    }\n    \n    private bool IsValidTrigger(Collider other)\n    {\n        return (_triggerLayers.value & (1 << other.gameObject.layer)) != 0;\n    }\n    \n    private void TriggerExplosion()\n    {\n        if (_hasExploded) return;\n        \n        _hasExploded = true;\n        OnMineTriggered?.Invoke();\n        \n        if (_explosionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_explosionSound);\n        }\n        \n        if (_explosionPrefab != null)\n        {\n            Instantiate(_explosionPrefab, transform.position, Quaternion.identity);\n        }\n        \n        ApplyExplosionEffects();\n        \n        if (_armedIndicator != null)\n        {\n            _armedIndicator.SetActive(false);\n        }\n        \n        StartCoroutine(DestroyAfterExplosion());\n    }\n    \n    private void ApplyExplosionEffects()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius);\n        \n        foreach (Collider hit in colliders)\n        {\n            if (hit == _triggerCollider) continue;\n            \n            Rigidbody rb = hit.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            if (hit.CompareTag(\"Player\"))\n            {\n                ApplyDamageToPlayer(hit.gameObject);\n            }\n            \n            IDamageable damageable = hit.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                float distance = Vector3.Distance(transform.position, hit.transform.position);\n                float damageMultiplier = 1f - (distance / _explosionRadius);\n                float finalDamage = _damage * damageMultiplier;\n                \n                damageable.TakeDamage(finalDamage);\n                OnDamageDealt?.Invoke(finalDamage);\n            }\n        }\n    }\n    \n    private void ApplyDamageToPlayer(GameObject player)\n    {\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        float damageMultiplier = 1f - (distance / _explosionRadius);\n        float finalDamage = _damage * damageMultiplier;\n        \n        OnDamageDealt?.Invoke(finalDamage);\n        \n        player.SendMessage(\"TakeDamage\", finalDamage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private System.Collections.IEnumerator DestroyAfterExplosion()\n    {\n        GetComponent<Renderer>().enabled = false;\n        _triggerCollider.enabled = false;\n        \n        yield return new WaitForSeconds(2f);\n        \n        Destroy(gameObject);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _isArmed ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        \n        if (!_isArmed)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, Vector3.one * 0.5f);\n        }\n    }\n    \n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ArrowTrap\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"shootForce\",\n      \"type\": \"float\",\n      \"default\": 20.0\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"arrowPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shootPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isOnCooldown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"check if trap is not on cooldown\"\n        },\n        {\n          \"action\": \"if not on cooldown then shoot arrow\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shoot_arrow\",\n      \"trigger\": \"when shooting arrow\",\n      \"actions\": [\n        {\n          \"action\": \"instantiate arrow at shoot point\"\n        },\n        {\n          \"action\": \"launch arrow forward with shoot force\"\n        },\n        {\n          \"action\": \"play shooting sound effect\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooldown_timer\",\n      \"trigger\": \"when cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"set trap ready to shoot again\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class ArrowTrap : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private LayerMask _targetLayerMask = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private Transform _detectionPoint;\n    \n    [Header(\"Arrow Settings\")]\n    [SerializeField] private GameObject _arrowPrefab;\n    [SerializeField] private Transform _shootPoint;\n    [SerializeField] private float _arrowSpeed = 20f;\n    [SerializeField] private float _arrowLifetime = 5f;\n    [SerializeField] private int _arrowDamage = 25;\n    \n    [Header(\"Timing Settings\")]\n    [SerializeField] private float _shootDelay = 0.5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _continuousFiring = false;\n    [SerializeField] private float _continuousFireRate = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _reloadSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private GameObject _warningIndicator;\n    \n    private bool _isOnCooldown = false;\n    private bool _isFiring = false;\n    private Coroutine _firingCoroutine;\n    \n    private void Start()\n    {\n        if (_detectionPoint == null)\n            _detectionPoint = transform;\n            \n        if (_shootPoint == null)\n            _shootPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_isOnCooldown || _isFiring)\n            return;\n            \n        DetectTargets();\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(_detectionPoint.position, _detectionRange, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(_targetTag))\n            {\n                Vector3 directionToTarget = (target.transform.position - _detectionPoint.position).normalized;\n                \n                if (Physics.Raycast(_detectionPoint.position, directionToTarget, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider == target)\n                    {\n                        StartFiring();\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void StartFiring()\n    {\n        if (_isFiring)\n            return;\n            \n        _isFiring = true;\n        \n        if (_continuousFiring)\n        {\n            _firingCoroutine = StartCoroutine(ContinuousFire());\n        }\n        else\n        {\n            StartCoroutine(SingleShot());\n        }\n    }\n    \n    private IEnumerator SingleShot()\n    {\n        ShowWarning();\n        yield return new WaitForSeconds(_shootDelay);\n        \n        ShootArrow();\n        HideWarning();\n        \n        _isFiring = false;\n        StartCoroutine(Cooldown());\n    }\n    \n    private IEnumerator ContinuousFire()\n    {\n        ShowWarning();\n        yield return new WaitForSeconds(_shootDelay);\n        \n        while (_isFiring && HasTargetsInRange())\n        {\n            ShootArrow();\n            yield return new WaitForSeconds(1f / _continuousFireRate);\n        }\n        \n        HideWarning();\n        _isFiring = false;\n        StartCoroutine(Cooldown());\n    }\n    \n    private bool HasTargetsInRange()\n    {\n        Collider[] targets = Physics.OverlapSphere(_detectionPoint.position, _detectionRange, _targetLayerMask);\n        \n        foreach (Collider target in targets)\n        {\n            if (target.CompareTag(_targetTag))\n            {\n                Vector3 directionToTarget = (target.transform.position - _detectionPoint.position).normalized;\n                \n                if (Physics.Raycast(_detectionPoint.position, directionToTarget, out RaycastHit hit, _detectionRange))\n                {\n                    if (hit.collider == target)\n                        return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private void ShootArrow()\n    {\n        if (_arrowPrefab == null || _shootPoint == null)\n            return;\n            \n        GameObject arrow = Instantiate(_arrowPrefab, _shootPoint.position, _shootPoint.rotation);\n        \n        TrapArrow arrowScript = arrow.GetComponent<TrapArrow>();\n        if (arrowScript == null)\n            arrowScript = arrow.AddComponent<TrapArrow>();\n            \n        arrowScript.Initialize(_shootPoint.forward, _arrowSpeed, _arrowDamage, _arrowLifetime);\n        \n        PlayShootEffects();\n    }\n    \n    private void PlayShootEffects()\n    {\n        if (_audioSource != null && _shootSound != null)\n            _audioSource.PlayOneShot(_shootSound);\n            \n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n    }\n    \n    private void ShowWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(true);\n    }\n    \n    private void HideWarning()\n    {\n        if (_warningIndicator != null)\n            _warningIndicator.SetActive(false);\n    }\n    \n    private IEnumerator Cooldown()\n    {\n        _isOnCooldown = true;\n        \n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n            \n        yield return new WaitForSeconds(_cooldownTime);\n        _isOnCooldown = false;\n    }\n    \n    public void StopFiring()\n    {\n        if (_firingCoroutine != null)\n        {\n            StopCoroutine(_firingCoroutine);\n            _firingCoroutine = null;\n        }\n        \n        _isFiring = false;\n        HideWarning();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_detectionPoint == null)\n            _detectionPoint = transform;\n            \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(_detectionPoint.position, _detectionRange);\n        \n        if (_shootPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(_shootPoint.position, _shootPoint.forward * 3f);\n        }\n    }\n}\n\npublic class TrapArrow : MonoBehaviour\n{\n    private Vector3 _direction;\n    private float _speed;\n    private int _damage;\n    private float _lifetime;\n    private Rigidbody _rigidbody;\n    private bool _hasHit = false;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _rigidbody.useGravity = false;\n    }\n    \n    public void Initialize(Vector3 direction, float speed, int damage, float lifetime)\n    {\n        _direction = direction.normalized;\n        _speed = speed;\n        _damage = damage;\n        _lifetime = lifetime;\n        \n        _rigidbody.velocity = _direction * _speed;\n        transform.rotation = Quaternion.LookRotation(_direction);\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit)\n            return;\n            \n        if (other.CompareTag(\"Player\"))\n        {\n            _hasHit = true;\n            \n            // Try to find health component on player\n            var healthComponent = other.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                // Use reflection to try calling common health methods\n                var healthType = healthComponent.GetType();\n                var takeDamageMethod = healthType.GetMethod(\"TakeDamage\");\n                if (takeDamageMethod != null)\n                {\n                    takeDamageMethod.Invoke(healthComponent, new object[] { _damage });\n                }\n            }\n            \n            StickToTarget(other.transform);\n        }\n        else if (!other.isTrigger)\n        {\n            _hasHit = true;\n            StickToSurface();\n        }\n    }\n    \n    private void StickToTarget(Transform target)\n    {\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        transform.SetParent(target);\n        \n        Destroy(gameObject, 2f);\n    }\n    \n    private void StickToSurface()\n    {\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        Destroy(gameObject, 5f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChainLightningRod\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"LineRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"chainRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxChainTargets\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"lightningDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"chainDelay\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"activationCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentCooldown\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_lightning_trigger\",\n      \"trigger\": \"when enemy enters trigger area and cooldown is finished\",\n      \"actions\": [\n        {\n          \"action\": \"activate lightning rod\"\n        },\n        {\n          \"action\": \"find nearest enemy as first target\"\n        },\n        {\n          \"action\": \"start chain lightning sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chain_to_next_target\",\n      \"trigger\": \"when lightning hits current target and chain count is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to current target\"\n        },\n        {\n          \"action\": \"create lightning visual effect to current target\"\n        },\n        {\n          \"action\": \"find nearest unchained enemy within chain range\"\n        },\n        {\n          \"action\": \"wait for chain delay duration\"\n        },\n        {\n          \"action\": \"jump lightning to next target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_chain_sequence\",\n      \"trigger\": \"when no more valid targets found or maximum chains reached\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to final target\"\n        },\n        {\n          \"action\": \"clear all lightning visual effects\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"deactivate lightning rod\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_cooldown\",\n      \"trigger\": \"every frame when cooldown is active\",\n      \"actions\": [\n        {\n          \"action\": \"reduce cooldown timer\"\n        },\n        {\n          \"action\": \"mark as ready when cooldown reaches zero\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class LightningRod : MonoBehaviour\n{\n    [Header(\"Lightning Settings\")]\n    [SerializeField] private float _detectionRadius = 15f;\n    [SerializeField] private float _chainRadius = 8f;\n    [SerializeField] private int _maxChainTargets = 5;\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string[] _targetTags = { \"Enemy\", \"Player\" };\n\n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _lightningPrefab;\n    [SerializeField] private ParticleSystem _strikeEffect;\n    [SerializeField] private ParticleSystem _chainEffect;\n    [SerializeField] private float _lightningDuration = 0.3f;\n    [SerializeField] private Color _lightningColor = Color.cyan;\n    [SerializeField] private AnimationCurve _lightningWidth = AnimationCurve.Linear(0f, 0.2f, 1f, 0.05f);\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _lightningSound;\n    [SerializeField] private AudioClip _chainSound;\n\n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _autoTrigger = true;\n    [SerializeField] private float _autoTriggerInterval = 3f;\n    [SerializeField] private bool _triggerOnPlayerEnter = true;\n\n    private float _lastStrikeTime;\n    private List<GameObject> _activeTargets = new List<GameObject>();\n    private List<LineRenderer> _activeLightning = new List<LineRenderer>();\n    private Coroutine _lightningCoroutine;\n\n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_autoTrigger)\n            InvokeRepeating(nameof(TriggerLightning), _autoTriggerInterval, _autoTriggerInterval);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerOnPlayerEnter) return;\n        \n        if (other.CompareTag(\"Player\") && CanStrike())\n        {\n            TriggerLightning();\n        }\n    }\n\n    public void TriggerLightning()\n    {\n        if (!CanStrike()) return;\n\n        GameObject primaryTarget = FindPrimaryTarget();\n        if (primaryTarget == null) return;\n\n        _lastStrikeTime = Time.time;\n        \n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        _lightningCoroutine = StartCoroutine(ExecuteLightningChain(primaryTarget));\n    }\n\n    private bool CanStrike()\n    {\n        return Time.time >= _lastStrikeTime + _cooldownTime;\n    }\n\n    private GameObject FindPrimaryTarget()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayers);\n        GameObject closestTarget = null;\n        float closestDistance = float.MaxValue;\n\n        foreach (Collider col in colliders)\n        {\n            if (IsValidTarget(col.gameObject))\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = col.gameObject;\n                }\n            }\n        }\n\n        return closestTarget;\n    }\n\n    private bool IsValidTarget(GameObject target)\n    {\n        if (target == gameObject) return false;\n\n        foreach (string tag in _targetTags)\n        {\n            if (target.CompareTag(tag))\n                return true;\n        }\n        return false;\n    }\n\n    private IEnumerator ExecuteLightningChain(GameObject primaryTarget)\n    {\n        ClearActiveLightning();\n        _activeTargets.Clear();\n\n        List<GameObject> chainTargets = new List<GameObject> { primaryTarget };\n        GameObject currentTarget = primaryTarget;\n\n        // Build chain\n        for (int i = 0; i < _maxChainTargets - 1; i++)\n        {\n            GameObject nextTarget = FindNextChainTarget(currentTarget, chainTargets);\n            if (nextTarget == null) break;\n            \n            chainTargets.Add(nextTarget);\n            currentTarget = nextTarget;\n        }\n\n        // Create lightning visuals\n        Vector3 startPos = transform.position;\n        for (int i = 0; i < chainTargets.Count; i++)\n        {\n            Vector3 endPos = chainTargets[i].transform.position;\n            CreateLightningBolt(startPos, endPos, i == 0);\n            \n            if (i < chainTargets.Count - 1)\n            {\n                startPos = endPos;\n            }\n        }\n\n        // Apply damage and effects\n        foreach (GameObject target in chainTargets)\n        {\n            ApplyLightningDamage(target);\n            CreateStrikeEffect(target.transform.position);\n        }\n\n        // Play audio\n        PlayLightningAudio();\n\n        // Wait for lightning duration\n        yield WaitForSeconds(_lightningDuration);\n\n        // Clean up\n        ClearActiveLightning();\n    }\n\n    private GameObject FindNextChainTarget(GameObject currentTarget, List<GameObject> excludeTargets)\n    {\n        Collider[] colliders = Physics.OverlapSphere(currentTarget.transform.position, _chainRadius, _targetLayers);\n        GameObject bestTarget = null;\n        float closestDistance = float.MaxValue;\n\n        foreach (Collider col in colliders)\n        {\n            GameObject target = col.gameObject;\n            \n            if (!IsValidTarget(target) || excludeTargets.Contains(target))\n                continue;\n\n            float distance = Vector3.Distance(currentTarget.transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                bestTarget = target;\n            }\n        }\n\n        return bestTarget;\n    }\n\n    private void CreateLightningBolt(Vector3 startPos, Vector3 endPos, bool isPrimary)\n    {\n        if (_lightningPrefab == null) return;\n\n        LineRenderer lightning = Instantiate(_lightningPrefab);\n        lightning.positionCount = 2;\n        lightning.SetPosition(0, startPos);\n        lightning.SetPosition(1, endPos);\n        lightning.color = _lightningColor;\n        lightning.widthCurve = _lightningWidth;\n        lightning.material.color = _lightningColor;\n\n        _activeLightning.Add(lightning);\n    }\n\n    private void ApplyLightningDamage(GameObject target)\n    {\n        // Try different damage interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Send damage message - common Unity pattern\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"OnLightningStrike\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n\n        // Alternative: Use Rigidbody for physics impact\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * _damage * 10f, ForceMode.Impulse);\n        }\n    }\n\n    private void CreateStrikeEffect(Vector3 position)\n    {\n        if (_strikeEffect != null)\n        {\n            ParticleSystem effect = Instantiate(_strikeEffect);\n            effect.transform.position = position;\n            effect.Play();\n            Destroy(effect.gameObject, effect.main.duration + effect.main.startLifetime.constantMax);\n        }\n\n        if (_chainEffect != null)\n        {\n            ParticleSystem chain = Instantiate(_chainEffect);\n            chain.transform.position = position;\n            chain.Play();\n            Destroy(chain.gameObject, chain.main.duration + chain.main.startLifetime.constantMax);\n        }\n    }\n\n    private void PlayLightningAudio()\n    {\n        if (_audioSource != null && _lightningSound != null)\n        {\n            _audioSource.PlayOneShot(_lightningSound);\n        }\n\n        if (_audioSource != null && _chainSound != null && _activeTargets.Count > 1)\n        {\n            _audioSource.PlayOneShot(_chainSound);\n        }\n    }\n\n    private void ClearActiveLightning()\n    {\n        foreach (LineRenderer lightning in _activeLightning)\n        {\n            if (lightning != null)\n                Destroy(lightning.gameObject);\n        }\n        _activeLightning.Clear();\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _chainRadius);\n    }\n\n    private void OnDestroy()\n    {\n        if (_lightningCoroutine != null)\n            StopCoroutine(_lightningCoroutine);\n        \n        ClearActiveLightning();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AcidPoolHazard\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"bubbleEffectIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"acidSizzleVolume\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_player_on_contact\",\n      \"trigger\": \"when player enters acid pool area\",\n      \"actions\": [\n        {\n          \"action\": \"start continuous damage to player\"\n        },\n        {\n          \"action\": \"play acid sizzling sound effect\"\n        },\n        {\n          \"action\": \"increase bubble particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_damage_while_in_pool\",\n      \"trigger\": \"while player remains in acid pool\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to player at regular intervals\"\n        },\n        {\n          \"action\": \"maintain sizzling audio loop\"\n        },\n        {\n          \"action\": \"keep bubble effects active\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_damage_on_exit\",\n      \"trigger\": \"when player exits acid pool area\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying damage to player\"\n        },\n        {\n          \"action\": \"fade out sizzling sound effect\"\n        },\n        {\n          \"action\": \"reduce bubble particle effects to normal level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ambient_bubbling\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"play subtle bubbling particle effects\"\n        },\n        {\n          \"action\": \"emit low ambient acid pool sounds\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AcidPoolHazard : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private bool _continuousDamage = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private Color _acidColor = Color.green;\n    [SerializeField] private float _dissolveSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _damageSound;\n    [SerializeField] private AudioClip _bubbleSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _waveAmplitude = 0.1f;\n    [SerializeField] private float _waveFrequency = 1f;\n    [SerializeField] private Transform _surfaceTransform;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectEnterAcid;\n    public UnityEvent<GameObject> OnObjectExitAcid;\n    public UnityEvent<GameObject, float> OnDamageDealt;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _acidMaterial;\n    private Vector3 _originalSurfacePosition;\n    private float _waveTimer;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _objectsInAcid = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    [System.Serializable]\n    private class DissolvableObject\n    {\n        public GameObject gameObject;\n        public Renderer renderer;\n        public Material originalMaterial;\n        public float dissolveProgress;\n        public bool isDissolving;\n        \n        public DissolvableObject(GameObject obj)\n        {\n            gameObject = obj;\n            renderer = obj.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                originalMaterial = renderer.material;\n            }\n            dissolveProgress = 0f;\n            isDissolving = false;\n        }\n    }\n    \n    private System.Collections.Generic.List<DissolvableObject> _dissolvingObjects = \n        new System.Collections.Generic.List<DissolvableObject>();\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupAcidMaterial();\n        StartBubbleEffects();\n        \n        if (_surfaceTransform != null)\n        {\n            _originalSurfacePosition = _surfaceTransform.localPosition;\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.spatialBlend = 1f;\n        \n        _renderer = GetComponent<Renderer>();\n        \n        if (_bubbleEffect == null)\n        {\n            _bubbleEffect = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void SetupAcidMaterial()\n    {\n        if (_renderer != null)\n        {\n            _acidMaterial = _renderer.material;\n            _acidMaterial.color = _acidColor;\n            \n            if (_acidMaterial.HasProperty(\"_EmissionColor\"))\n            {\n                _acidMaterial.SetColor(\"_EmissionColor\", _acidColor * 0.3f);\n                _acidMaterial.EnableKeyword(\"_EMISSION\");\n            }\n        }\n    }\n    \n    private void StartBubbleEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            _bubbleEffect.Play();\n        }\n        \n        if (_bubbleSound != null)\n        {\n            _audioSource.clip = _bubbleSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateWaveAnimation();\n        ProcessContinuousDamage();\n        UpdateDissolvingObjects();\n    }\n    \n    private void UpdateWaveAnimation()\n    {\n        if (_surfaceTransform == null) return;\n        \n        _waveTimer += Time.deltaTime * _waveFrequency;\n        float waveOffset = Mathf.Sin(_waveTimer) * _waveAmplitude;\n        \n        _surfaceTransform.localPosition = _originalSurfacePosition + Vector3.up * waveOffset;\n    }\n    \n    private void ProcessContinuousDamage()\n    {\n        if (!_continuousDamage) return;\n        \n        var objectsToRemove = new System.Collections.Generic.List<GameObject>();\n        var objectsToUpdate = new System.Collections.Generic.List<GameObject>(_objectsInAcid.Keys);\n        \n        foreach (var obj in objectsToUpdate)\n        {\n            if (obj == null)\n            {\n                objectsToRemove.Add(obj);\n                continue;\n            }\n            \n            _objectsInAcid[obj] += Time.deltaTime;\n            \n            if (_objectsInAcid[obj] >= _damageInterval)\n            {\n                DealDamage(obj);\n                _objectsInAcid[obj] = 0f;\n            }\n        }\n        \n        foreach (var obj in objectsToRemove)\n        {\n            _objectsInAcid.Remove(obj);\n        }\n    }\n    \n    private void UpdateDissolvingObjects()\n    {\n        for (int i = _dissolvingObjects.Count - 1; i >= 0; i--)\n        {\n            var dissolvable = _dissolvingObjects[i];\n            \n            if (dissolvable.gameObject == null)\n            {\n                _dissolvingObjects.RemoveAt(i);\n                continue;\n            }\n            \n            if (dissolvable.isDissolving)\n            {\n                dissolvable.dissolveProgress += Time.deltaTime * _dissolveSpeed;\n                \n                if (dissolvable.renderer != null && dissolvable.renderer.material.HasProperty(\"_Cutoff\"))\n                {\n                    dissolvable.renderer.material.SetFloat(\"_Cutoff\", dissolvable.dissolveProgress);\n                }\n                else if (dissolvable.renderer != null)\n                {\n                    Color color = dissolvable.renderer.material.color;\n                    color.a = Mathf.Lerp(1f, 0f, dissolvable.dissolveProgress);\n                    dissolvable.renderer.material.color = color;\n                }\n                \n                if (dissolvable.dissolveProgress >= 1f)\n                {\n                    if (dissolvable.gameObject != null)\n                    {\n                        Destroy(dissolvable.gameObject);\n                    }\n                    _dissolvingObjects.RemoveAt(i);\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other == null) return;\n        \n        PlaySplashEffect(other.transform.position);\n        PlayEnterSound();\n        \n        if (!_objectsInAcid.ContainsKey(other.gameObject))\n        {\n            _objectsInAcid.Add(other.gameObject, 0f);\n            OnObjectEnterAcid?.Invoke(other.gameObject);\n            \n            if (!_continuousDamage)\n            {\n                DealDamage(other.gameObject);\n            }\n            \n            StartDissolving(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other == null) return;\n        \n        if (_objectsInAcid.ContainsKey(other.gameObject))\n        {\n            _objectsInAcid.Remove(other.gameObject);\n            OnObjectExitAcid?.Invoke(other.gameObject);\n        }\n    }\n    \n    private void PlaySplashEffect(Vector3 position)\n    {\n        if (_splashEffect != null)\n        {\n            _splashEffect.transform.position = position;\n            _splashEffect.Play();\n        }\n    }\n    \n    private void PlayEnterSound()\n    {\n        if (_enterSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_enterSound, _audioVolume);\n        }\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        if (target == null) return;\n        \n        // Try to find and damage player\n        if (target.CompareTag(\"Player\"))\n        {\n            var characterController = target.GetComponent<CharacterController>();\n            if (characterController != null)\n            {\n                // Apply knockback\n                Vector3 knockback = (target.transform.position - transform.position).normalized * 2f;\n                knockback.y = 1f;\n                characterController.Move(knockback * Time.deltaTime);\n            }\n        }\n        \n        // Try to damage any object with health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use reflection to try to call TakeDamage method if it exists\n            var takeDamageMethod = healthComponent.GetType().GetMethod(\"TakeDamage\");\n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Destroy non-player objects after some time\n        if (!target.CompareTag(\"Player\"))\n        {\n            var rigidbody = target.GetComponent<Rigidbody>();\n            if (rigidbody != null)\n            {\n                rigidbody.AddForce(Vector3.down * 5f, ForceMode.Impulse);\n            }\n        }\n        \n        PlayDamageSound();\n        OnDamageDealt?.Invoke(target, _damageAmount);\n    }\n    \n    private void PlayDamageSound()\n    {\n        if (_damageSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_damageSound, _audioVolume);\n        }\n    }\n    \n    private void StartDissolving(GameObject target)\n    {\n        if (target.CompareTag(\"Player\")) return;\n        \n        var existingDissolvable = _dissolvingObjects.Find(d => d.gameObject == target);\n        if (existingDissolvable == null)\n        {\n            var newDissolvable = new DissolvableObject(target);\n            newDissolvable.isDissolving = true;\n            _dissolvingObjects.Add(newDissolvable);\n        }\n    }\n    \n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = Mathf.Max(0f, damage);\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = Mathf.Max(0.1f, interval);\n    }\n    \n    public void EnableContinuousDamage(bool enable)\n    {\n        _continuousDamage = enable;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_acidMaterial != null)\n        {\n            Destroy(_acidMaterial);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Tank\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90.0\n    },\n    {\n      \"name\": \"turretRotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 45.0\n    },\n    {\n      \"name\": \"turret\",\n      \"type\": \"Transform\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"move_forward\",\n      \"trigger\": \"when forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"move tank forward at move speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"move_backward\",\n      \"trigger\": \"when backward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"move tank backward at move speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_left\",\n      \"trigger\": \"when left input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate tank left at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_right\",\n      \"trigger\": \"when right input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate tank right at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_turret_left\",\n      \"trigger\": \"when turret left input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate turret left at turret rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_turret_right\",\n      \"trigger\": \"when turret right input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate turret right at turret rotation speed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Tank : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    \n    [Header(\"Turret\")]\n    [SerializeField] private Transform _turret;\n    [SerializeField] private float _turretRotationSpeed = 120f;\n    [SerializeField] private Transform _firePoint;\n    \n    [Header(\"Shooting\")]\n    [SerializeField] private GameObject _projectilePrefab;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private float _projectileSpeed = 20f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _fireKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseAiming = true;\n    \n    private Rigidbody _rigidbody;\n    private Camera _mainCamera;\n    private float _lastFireTime;\n    private Vector3 _targetDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _mainCamera = Camera.main;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_turret == null)\n        {\n            Transform turretChild = transform.Find(\"Turret\");\n            if (turretChild != null)\n            {\n                _turret = turretChild;\n            }\n        }\n        \n        if (_firePoint == null && _turret != null)\n        {\n            Transform firePointChild = _turret.Find(\"FirePoint\");\n            if (firePointChild != null)\n            {\n                _firePoint = firePointChild;\n            }\n        }\n        \n        _rigidbody.centerOfMass = Vector3.zero;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleTurretRotation();\n        HandleShooting();\n    }\n    \n    private void FixedUpdate()\n    {\n        HandleMovement();\n    }\n    \n    private void HandleInput()\n    {\n        if (_useMouseAiming && _mainCamera != null)\n        {\n            Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit))\n            {\n                Vector3 targetPosition = hit.point;\n                targetPosition.y = _turret.position.y;\n                _targetDirection = (targetPosition - _turret.position).normalized;\n            }\n        }\n        else\n        {\n            float horizontalAim = Input.GetAxis(\"Mouse X\");\n            if (Mathf.Abs(horizontalAim) > 0.1f)\n            {\n                _turret.Rotate(0, horizontalAim * _turretRotationSpeed * Time.deltaTime, 0);\n            }\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        float vertical = Input.GetAxis(\"Vertical\");\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        \n        Vector3 movement = transform.forward * vertical * _moveSpeed;\n        _rigidbody.MovePosition(_rigidbody.position + movement * Time.fixedDeltaTime);\n        \n        if (Mathf.Abs(horizontal) > 0.1f)\n        {\n            float rotation = horizontal * _rotationSpeed * Time.fixedDeltaTime;\n            Quaternion deltaRotation = Quaternion.Euler(0, rotation, 0);\n            _rigidbody.MoveRotation(_rigidbody.rotation * deltaRotation);\n        }\n    }\n    \n    private void HandleTurretRotation()\n    {\n        if (_turret == null) return;\n        \n        if (_useMouseAiming && _targetDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(_targetDirection);\n            targetRotation = Quaternion.Euler(0, targetRotation.eulerAngles.y, 0);\n            \n            _turret.rotation = Quaternion.RotateTowards(\n                _turret.rotation, \n                targetRotation, \n                _turretRotationSpeed * Time.deltaTime\n            );\n        }\n    }\n    \n    private void HandleShooting()\n    {\n        if (Input.GetKey(_fireKey) && CanFire())\n        {\n            Fire();\n        }\n    }\n    \n    private bool CanFire()\n    {\n        return Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n    \n    private void Fire()\n    {\n        if (_projectilePrefab == null || _firePoint == null) return;\n        \n        GameObject projectile = Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        \n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb == null)\n        {\n            projectileRb = projectile.AddComponent<Rigidbody>();\n        }\n        \n        projectileRb.velocity = _firePoint.forward * _projectileSpeed;\n        \n        ProjectileDestroyer destroyer = projectile.GetComponent<ProjectileDestroyer>();\n        if (destroyer == null)\n        {\n            destroyer = projectile.AddComponent<ProjectileDestroyer>();\n        }\n        destroyer.SetLifetime(5f);\n        \n        _lastFireTime = Time.time;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_turret != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_turret.position, 0.5f);\n            \n            if (_firePoint != null)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawWireSphere(_firePoint.position, 0.2f);\n                Gizmos.DrawRay(_firePoint.position, _firePoint.forward * 3f);\n            }\n        }\n        \n        if (_useMouseAiming && _targetDirection != Vector3.zero)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawRay(transform.position, _targetDirection * 5f);\n        }\n    }\n}\n\npublic class ProjectileDestroyer : MonoBehaviour\n{\n    private float _lifetime = 5f;\n    private float _spawnTime;\n    \n    private void Start()\n    {\n        _spawnTime = Time.time;\n    }\n    \n    private void Update()\n    {\n        if (Time.time >= _spawnTime + _lifetime)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public void SetLifetime(float lifetime)\n    {\n        _lifetime = lifetime;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!other.CompareTag(\"Player\") && !other.isTrigger)\n        {\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ScoreMultiplierIndicator\",\n  \"components\": [\n    \"TextMeshProUGUI\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"baseMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"currentMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"maxMultiplier\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"multiplierDecayRate\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"multiplierIncrement\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"displayFormat\",\n      \"type\": \"string\",\n      \"default\": \"x{0:F1}\"\n    },\n    {\n      \"name\": \"pulseOnChange\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"colorGradient\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_multiplier\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"set current multiplier to base multiplier value\"\n        },\n        {\n          \"action\": \"update display text with current multiplier\"\n        },\n        {\n          \"action\": \"set text color to default multiplier color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"increase_multiplier\",\n      \"trigger\": \"when score multiplier increase event is received\",\n      \"actions\": [\n        {\n          \"action\": \"increase current multiplier by increment amount\"\n        },\n        {\n          \"action\": \"clamp current multiplier to maximum allowed value\"\n        },\n        {\n          \"action\": \"update display text with new multiplier value\"\n        },\n        {\n          \"action\": \"trigger pulse animation if enabled\"\n        },\n        {\n          \"action\": \"update text color based on multiplier level if gradient enabled\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decay_multiplier\",\n      \"trigger\": \"when multiplier decay timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current multiplier by decay rate\"\n        },\n        {\n          \"action\": \"clamp current multiplier to minimum base value\"\n        },\n        {\n          \"action\": \"update display text with decayed multiplier value\"\n        },\n        {\n          \"action\": \"update text color based on new multiplier level if gradient enabled\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_multiplier\",\n      \"trigger\": \"when multiplier reset event is received\",\n      \"actions\": [\n        {\n          \"action\": \"set current multiplier back to base value\"\n        },\n        {\n          \"action\": \"update display text to show base multiplier\"\n        },\n        {\n          \"action\": \"reset text color to default\"\n        },\n        {\n          \"action\": \"stop any active pulse animations\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_display\",\n      \"trigger\": \"when multiplier value changes\",\n      \"actions\": [\n        {\n          \"action\": \"format multiplier value using display format string\"\n        },\n        {\n          \"action\": \"update text component with formatted multiplier text\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_pulse\",\n      \"trigger\": \"when pulse animation should play\",\n      \"actions\": [\n        {\n          \"action\": \"trigger scale up animation on text\"\n        },\n        {\n          \"action\": \"trigger scale down animation after brief delay\"\n        },\n        {\n          \"action\": \"add glow effect during pulse if available\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections;\n\npublic class ScoreMultiplierIndicator : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private TextMeshProUGUI _multiplierText;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    \n    [Header(\"Multiplier Settings\")]\n    [SerializeField] private float _baseMultiplier = 1.0f;\n    [SerializeField] private float _maxMultiplier = 10.0f;\n    [SerializeField] private float _multiplierDecayRate = 0.5f;\n    [SerializeField] private float _multiplierIncrement = 0.5f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _lowMultiplierColor = Color.white;\n    [SerializeField] private Color _highMultiplierColor = Color.red;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0, 1, 1, 1.2f);\n    [SerializeField] private float _pulseDuration = 0.3f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private float _fadeInDuration = 0.5f;\n    [SerializeField] private float _fadeOutDuration = 1.0f;\n    [SerializeField] private float _hideDelay = 2.0f;\n    \n    private float _currentMultiplier;\n    private float _multiplierTimer;\n    private bool _isVisible;\n    private Coroutine _hideCoroutine;\n    private Coroutine _pulseCoroutine;\n    private Vector3 _originalScale;\n    \n    public float CurrentMultiplier => _currentMultiplier;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        _currentMultiplier = _baseMultiplier;\n        _originalScale = transform.localScale;\n        UpdateDisplay();\n        SetVisibility(false, true);\n    }\n    \n    private void Update()\n    {\n        UpdateMultiplierDecay();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_multiplierText == null)\n            _multiplierText = GetComponentInChildren<TextMeshProUGUI>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_canvasGroup == null)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n    }\n    \n    private void UpdateMultiplierDecay()\n    {\n        if (_currentMultiplier > _baseMultiplier)\n        {\n            _multiplierTimer += Time.deltaTime;\n            \n            if (_multiplierTimer >= 1.0f)\n            {\n                _multiplierTimer = 0f;\n                _currentMultiplier = Mathf.Max(_baseMultiplier, _currentMultiplier - _multiplierDecayRate);\n                UpdateDisplay();\n                \n                if (_currentMultiplier <= _baseMultiplier)\n                {\n                    HideIndicator();\n                }\n            }\n        }\n    }\n    \n    public void AddMultiplier()\n    {\n        AddMultiplier(_multiplierIncrement);\n    }\n    \n    public void AddMultiplier(float amount)\n    {\n        _currentMultiplier = Mathf.Min(_maxMultiplier, _currentMultiplier + amount);\n        _multiplierTimer = 0f;\n        \n        UpdateDisplay();\n        ShowIndicator();\n        TriggerPulseEffect();\n    }\n    \n    public void ResetMultiplier()\n    {\n        _currentMultiplier = _baseMultiplier;\n        _multiplierTimer = 0f;\n        UpdateDisplay();\n        HideIndicator();\n    }\n    \n    private void UpdateDisplay()\n    {\n        if (_multiplierText != null)\n        {\n            _multiplierText.text = $\"x{_currentMultiplier:F1}\";\n        }\n        \n        UpdateColors();\n        UpdateFillAmount();\n    }\n    \n    private void UpdateColors()\n    {\n        float normalizedMultiplier = (_currentMultiplier - _baseMultiplier) / (_maxMultiplier - _baseMultiplier);\n        Color currentColor = Color.Lerp(_lowMultiplierColor, _highMultiplierColor, normalizedMultiplier);\n        \n        if (_multiplierText != null)\n            _multiplierText.color = currentColor;\n            \n        if (_backgroundImage != null)\n            _backgroundImage.color = new Color(currentColor.r, currentColor.g, currentColor.b, 0.3f);\n    }\n    \n    private void UpdateFillAmount()\n    {\n        if (_fillImage != null)\n        {\n            float fillAmount = (_currentMultiplier - _baseMultiplier) / (_maxMultiplier - _baseMultiplier);\n            _fillImage.fillAmount = fillAmount;\n        }\n    }\n    \n    private void ShowIndicator()\n    {\n        if (_hideCoroutine != null)\n        {\n            StopCoroutine(_hideCoroutine);\n            _hideCoroutine = null;\n        }\n        \n        if (!_isVisible)\n        {\n            StartCoroutine(FadeIn());\n        }\n        \n        _hideCoroutine = StartCoroutine(HideAfterDelay());\n    }\n    \n    private void HideIndicator()\n    {\n        if (_hideCoroutine != null)\n        {\n            StopCoroutine(_hideCoroutine);\n            _hideCoroutine = null;\n        }\n        \n        if (_isVisible)\n        {\n            StartCoroutine(FadeOut());\n        }\n    }\n    \n    private IEnumerator FadeIn()\n    {\n        _isVisible = true;\n        float elapsedTime = 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        while (elapsedTime < _fadeInDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeInDuration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator FadeOut()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _canvasGroup.alpha;\n        \n        while (elapsedTime < _fadeOutDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _fadeOutDuration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, progress);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = 0f;\n        _isVisible = false;\n    }\n    \n    private IEnumerator HideAfterDelay()\n    {\n        yield return new WaitForSeconds(_hideDelay);\n        \n        if (_currentMultiplier <= _baseMultiplier)\n        {\n            HideIndicator();\n        }\n    }\n    \n    private void SetVisibility(bool visible, bool immediate = false)\n    {\n        _isVisible = visible;\n        \n        if (immediate)\n        {\n            _canvasGroup.alpha = visible ? 1f : 0f;\n        }\n    }\n    \n    private void TriggerPulseEffect()\n    {\n        if (_pulseCoroutine != null)\n        {\n            StopCoroutine(_pulseCoroutine);\n        }\n        \n        _pulseCoroutine = StartCoroutine(PulseAnimation());\n    }\n    \n    private IEnumerator PulseAnimation()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _pulseDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _pulseDuration;\n            float scaleMultiplier = _pulseCurve.Evaluate(progress);\n            transform.localScale = _originalScale * scaleMultiplier;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n        _pulseCoroutine = null;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            AddMultiplier();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_hideCoroutine != null)\n            StopCoroutine(_hideCoroutine);\n            \n        if (_pulseCoroutine != null)\n            StopCoroutine(_pulseCoroutine);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MovingPlatform\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pointA\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"pointB\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3(10, 0, 0)\"\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isMovingToB\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"pauseDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isPaused\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"pauseTimer\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"move_between_points\",\n      \"trigger\": \"every frame when not paused\",\n      \"actions\": [\n        {\n          \"action\": \"move toward current target point at move speed\"\n        },\n        {\n          \"action\": \"when reaching target point start pause timer and set paused to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_pause_at_endpoints\",\n      \"trigger\": \"every frame when paused\",\n      \"actions\": [\n        {\n          \"action\": \"increment pause timer\"\n        },\n        {\n          \"action\": \"when pause timer exceeds pause duration switch target point and resume movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"switch_direction\",\n      \"trigger\": \"when reaching point A or point B\",\n      \"actions\": [\n        {\n          \"action\": \"toggle movement direction between point A and point B\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MovingPlatform : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private Transform _pointA;\n    [SerializeField] private Transform _pointB;\n    [SerializeField] private float _speed = 2f;\n    [SerializeField] private float _waitTime = 1f;\n    [SerializeField] private AnimationCurve _movementCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Platform Settings\")]\n    [SerializeField] private bool _startAtPointA = true;\n    [SerializeField] private bool _moveOnStart = true;\n    [SerializeField] private LayerMask _passengerLayer = -1;\n    \n    private Vector3 _startPoint;\n    private Vector3 _endPoint;\n    private bool _movingToB = true;\n    private float _journeyLength;\n    private float _journeyTime;\n    private float _waitTimer;\n    private bool _isWaiting;\n    private bool _isMoving;\n    private Vector3 _lastPosition;\n    private Vector3 _platformVelocity;\n    \n    private void Start()\n    {\n        InitializePlatform();\n        \n        if (_moveOnStart)\n        {\n            StartMoving();\n        }\n    }\n    \n    private void InitializePlatform()\n    {\n        if (_pointA == null || _pointB == null)\n        {\n            Debug.LogError(\"MovingPlatform: Point A and Point B must be assigned!\");\n            enabled = false;\n            return;\n        }\n        \n        _startPoint = _pointA.position;\n        _endPoint = _pointB.position;\n        _journeyLength = Vector3.Distance(_startPoint, _endPoint);\n        \n        if (_startAtPointA)\n        {\n            transform.position = _startPoint;\n            _movingToB = true;\n        }\n        else\n        {\n            transform.position = _endPoint;\n            _movingToB = false;\n        }\n        \n        _lastPosition = transform.position;\n    }\n    \n    private void Update()\n    {\n        if (!_isMoving) return;\n        \n        if (_isWaiting)\n        {\n            HandleWaiting();\n        }\n        else\n        {\n            HandleMovement();\n        }\n        \n        CalculateVelocity();\n    }\n    \n    private void HandleWaiting()\n    {\n        _waitTimer -= Time.deltaTime;\n        \n        if (_waitTimer <= 0f)\n        {\n            _isWaiting = false;\n            _journeyTime = 0f;\n            SwapPoints();\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        _journeyTime += Time.deltaTime * _speed / _journeyLength;\n        \n        float curveValue = _movementCurve.Evaluate(_journeyTime);\n        Vector3 currentTarget = _movingToB ? _endPoint : _startPoint;\n        Vector3 currentStart = _movingToB ? _startPoint : _endPoint;\n        \n        transform.position = Vector3.Lerp(currentStart, currentTarget, curveValue);\n        \n        if (_journeyTime >= 1f)\n        {\n            transform.position = currentTarget;\n            \n            if (_waitTime > 0f)\n            {\n                _isWaiting = true;\n                _waitTimer = _waitTime;\n            }\n            else\n            {\n                _journeyTime = 0f;\n                SwapPoints();\n            }\n        }\n    }\n    \n    private void SwapPoints()\n    {\n        _movingToB = !_movingToB;\n    }\n    \n    private void CalculateVelocity()\n    {\n        _platformVelocity = (transform.position - _lastPosition) / Time.deltaTime;\n        _lastPosition = transform.position;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidPassenger(other))\n        {\n            AttachPassenger(other.transform);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsValidPassenger(other))\n        {\n            DetachPassenger(other.transform);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (IsValidPassenger(collision.collider))\n        {\n            AttachPassenger(collision.transform);\n        }\n    }\n    \n    private void OnCollisionExit(Collision collision)\n    {\n        if (IsValidPassenger(collision.collider))\n        {\n            DetachPassenger(collision.transform);\n        }\n    }\n    \n    private bool IsValidPassenger(Collider collider)\n    {\n        return (_passengerLayer.value & (1 << collider.gameObject.layer)) != 0;\n    }\n    \n    private void AttachPassenger(Transform passenger)\n    {\n        passenger.SetParent(transform);\n        \n        Rigidbody passengerRb = passenger.GetComponent<Rigidbody>();\n        if (passengerRb != null)\n        {\n            passengerRb.velocity += _platformVelocity;\n        }\n    }\n    \n    private void DetachPassenger(Transform passenger)\n    {\n        passenger.SetParent(null);\n    }\n    \n    public void StartMoving()\n    {\n        _isMoving = true;\n        _journeyTime = 0f;\n        _isWaiting = false;\n    }\n    \n    public void StopMoving()\n    {\n        _isMoving = false;\n        _isWaiting = false;\n    }\n    \n    public void ResetToStart()\n    {\n        StopMoving();\n        transform.position = _startAtPointA ? _startPoint : _endPoint;\n        _movingToB = _startAtPointA;\n        _lastPosition = transform.position;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_pointA != null && _pointB != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(_pointA.position, _pointB.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_pointA.position, 0.3f);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_pointB.position, 0.3f);\n            \n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position, transform.localScale);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldKnight\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"blockDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"blockCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isBlocking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canBlock\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_blocking\",\n      \"trigger\": \"when right mouse button is pressed and can block\",\n      \"actions\": [\n        {\n          \"action\": \"set blocking state to true\"\n        },\n        {\n          \"action\": \"play shield raise animation\"\n        },\n        {\n          \"action\": \"reduce movement speed by half\"\n        },\n        {\n          \"action\": \"set can block to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_block\",\n      \"trigger\": \"while blocking and right mouse button held\",\n      \"actions\": [\n        {\n          \"action\": \"keep shield raised\"\n        },\n        {\n          \"action\": \"face toward nearest threat\"\n        },\n        {\n          \"action\": \"maintain defensive stance animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_blocking\",\n      \"trigger\": \"when right mouse button released or block duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"set blocking state to false\"\n        },\n        {\n          \"action\": \"play shield lower animation\"\n        },\n        {\n          \"action\": \"restore normal movement speed\"\n        },\n        {\n          \"action\": \"start block cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"block_attack\",\n      \"trigger\": \"when enemy attack hits while blocking\",\n      \"actions\": [\n        {\n          \"action\": \"deflect incoming damage\"\n        },\n        {\n          \"action\": \"play shield impact effect\"\n        },\n        {\n          \"action\": \"push back slightly from impact\"\n        },\n        {\n          \"action\": \"play metallic clang sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_block_ability\",\n      \"trigger\": \"when block cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"set can block to true\"\n        },\n        {\n          \"action\": \"show block ready indicator\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class KnightShieldController : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private GameObject _shieldObject;\n    [SerializeField] private Transform _shieldPosition;\n    [SerializeField] private float _blockDuration = 2f;\n    [SerializeField] private float _blockCooldown = 1f;\n    [SerializeField] private float _blockAngle = 90f;\n    [SerializeField] private LayerMask _projectileLayer = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _blockTrigger = \"Block\";\n    [SerializeField] private string _isBlockingBool = \"IsBlocking\";\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _blockSound;\n    [SerializeField] private AudioClip _deflectSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _blockEffect;\n    [SerializeField] private ParticleSystem _deflectEffect;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _blockKey = KeyCode.Mouse1;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBlockStart;\n    public UnityEvent OnBlockEnd;\n    public UnityEvent OnSuccessfulBlock;\n    \n    private bool _isBlocking = false;\n    private bool _canBlock = true;\n    private float _blockTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Collider _shieldCollider;\n    private Rigidbody _rb;\n    \n    private void Start()\n    {\n        if (_shieldObject != null)\n        {\n            _shieldCollider = _shieldObject.GetComponent<Collider>();\n            if (_shieldCollider == null)\n            {\n                _shieldCollider = _shieldObject.AddComponent<BoxCollider>();\n                _shieldCollider.isTrigger = true;\n            }\n        }\n        \n        _rb = GetComponent<Rigidbody>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        if (_shieldObject != null)\n            _shieldObject.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateBlockTimer();\n        UpdateCooldownTimer();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_blockKey) && _canBlock && !_isBlocking)\n        {\n            StartBlocking();\n        }\n        else if (Input.GetKeyUp(_blockKey) && _isBlocking)\n        {\n            StopBlocking();\n        }\n    }\n    \n    private void UpdateBlockTimer()\n    {\n        if (_isBlocking)\n        {\n            _blockTimer += Time.deltaTime;\n            if (_blockTimer >= _blockDuration)\n            {\n                StopBlocking();\n            }\n        }\n    }\n    \n    private void UpdateCooldownTimer()\n    {\n        if (!_canBlock)\n        {\n            _cooldownTimer += Time.deltaTime;\n            if (_cooldownTimer >= _blockCooldown)\n            {\n                _canBlock = true;\n                _cooldownTimer = 0f;\n            }\n        }\n    }\n    \n    private void StartBlocking()\n    {\n        _isBlocking = true;\n        _blockTimer = 0f;\n        \n        if (_shieldObject != null)\n        {\n            _shieldObject.SetActive(true);\n            PositionShield();\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetTrigger(_blockTrigger);\n            _animator.SetBool(_isBlockingBool, true);\n        }\n        \n        if (_audioSource != null && _blockSound != null)\n        {\n            _audioSource.PlayOneShot(_blockSound);\n        }\n        \n        if (_blockEffect != null)\n        {\n            _blockEffect.Play();\n        }\n        \n        OnBlockStart?.Invoke();\n    }\n    \n    private void StopBlocking()\n    {\n        _isBlocking = false;\n        _canBlock = false;\n        _cooldownTimer = 0f;\n        \n        if (_shieldObject != null)\n        {\n            _shieldObject.SetActive(false);\n        }\n        \n        if (_animator != null)\n        {\n            _animator.SetBool(_isBlockingBool, false);\n        }\n        \n        if (_blockEffect != null)\n        {\n            _blockEffect.Stop();\n        }\n        \n        OnBlockEnd?.Invoke();\n    }\n    \n    private void PositionShield()\n    {\n        if (_shieldObject == null) return;\n        \n        if (_shieldPosition != null)\n        {\n            _shieldObject.transform.position = _shieldPosition.position;\n            _shieldObject.transform.rotation = _shieldPosition.rotation;\n        }\n        else\n        {\n            Vector3 forward = transform.forward;\n            Vector3 shieldPos = transform.position + forward * 0.5f + Vector3.up * 1f;\n            _shieldObject.transform.position = shieldPos;\n            _shieldObject.transform.LookAt(transform.position + forward * 2f);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isBlocking) return;\n        \n        if (IsProjectile(other))\n        {\n            HandleProjectileBlock(other);\n        }\n        else if (other.CompareTag(\"Enemy\"))\n        {\n            HandleEnemyBlock(other);\n        }\n    }\n    \n    private bool IsProjectile(Collider other)\n    {\n        return (_projectileLayer.value & (1 << other.gameObject.layer)) > 0 ||\n               other.CompareTag(\"Projectile\") ||\n               other.GetComponent<Rigidbody>() != null;\n    }\n    \n    private void HandleProjectileBlock(Collider other)\n    {\n        Vector3 directionToProjectile = (other.transform.position - transform.position).normalized;\n        Vector3 shieldForward = _shieldObject != null ? _shieldObject.transform.forward : transform.forward;\n        \n        float angle = Vector3.Angle(-shieldForward, directionToProjectile);\n        \n        if (angle <= _blockAngle * 0.5f)\n        {\n            BlockProjectile(other);\n        }\n    }\n    \n    private void HandleEnemyBlock(Collider other)\n    {\n        Vector3 directionToEnemy = (other.transform.position - transform.position).normalized;\n        Vector3 shieldForward = _shieldObject != null ? _shieldObject.transform.forward : transform.forward;\n        \n        float angle = Vector3.Angle(-shieldForward, directionToEnemy);\n        \n        if (angle <= _blockAngle * 0.5f)\n        {\n            BlockEnemyAttack(other);\n        }\n    }\n    \n    private void BlockProjectile(Collider projectile)\n    {\n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb != null)\n        {\n            Vector3 reflectDirection = Vector3.Reflect(projectileRb.velocity.normalized, \n                _shieldObject != null ? _shieldObject.transform.forward : transform.forward);\n            projectileRb.velocity = reflectDirection * projectileRb.velocity.magnitude;\n        }\n        \n        PlayDeflectEffects();\n        OnSuccessfulBlock?.Invoke();\n        \n        Destroy(projectile.gameObject, 0.1f);\n    }\n    \n    private void BlockEnemyAttack(Collider enemy)\n    {\n        Rigidbody enemyRb = enemy.GetComponent<Rigidbody>();\n        if (enemyRb != null)\n        {\n            Vector3 knockbackDirection = (enemy.transform.position - transform.position).normalized;\n            enemyRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n        }\n        \n        PlayDeflectEffects();\n        OnSuccessfulBlock?.Invoke();\n    }\n    \n    private void PlayDeflectEffects()\n    {\n        if (_audioSource != null && _deflectSound != null)\n        {\n            _audioSource.PlayOneShot(_deflectSound);\n        }\n        \n        if (_deflectEffect != null)\n        {\n            _deflectEffect.Play();\n        }\n    }\n    \n    public bool IsBlocking()\n    {\n        return _isBlocking;\n    }\n    \n    public bool CanBlock()\n    {\n        return _canBlock;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        return _canBlock ? 1f : _cooldownTimer / _blockCooldown;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RocketLauncher\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"splashRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"splashDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"projectileSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"rocketPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"launchPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isReloaded\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_rocket\",\n      \"trigger\": \"when fire input is pressed and weapon is reloaded\",\n      \"actions\": [\n        {\n          \"action\": \"spawn rocket projectile at launch point\"\n        },\n        {\n          \"action\": \"launch rocket forward at projectile speed\"\n        },\n        {\n          \"action\": \"play launch sound effect\"\n        },\n        {\n          \"action\": \"set weapon to not reloaded\"\n        },\n        {\n          \"action\": \"start reload timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rocket_impact\",\n      \"trigger\": \"when rocket collides with any surface or object\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect at impact point\"\n        },\n        {\n          \"action\": \"deal direct damage to hit target\"\n        },\n        {\n          \"action\": \"find all objects within splash radius\"\n        },\n        {\n          \"action\": \"deal splash damage to nearby objects based on distance\"\n        },\n        {\n          \"action\": \"apply knockback force to affected objects\"\n        },\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"destroy rocket projectile\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_complete\",\n      \"trigger\": \"when reload time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set weapon to reloaded\"\n        },\n        {\n          \"action\": \"play reload complete sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"calculate_splash_damage\",\n      \"trigger\": \"when applying splash damage to target\",\n      \"actions\": [\n        {\n          \"action\": \"calculate distance from explosion center to target\"\n        },\n        {\n          \"action\": \"reduce damage based on distance from center\"\n        },\n        {\n          \"action\": \"apply calculated damage to target\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class RocketLauncher : MonoBehaviour\n{\n    [Header(\"Rocket Settings\")]\n    [SerializeField] private GameObject _rocketPrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _rocketSpeed = 20f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private int _maxAmmo = 10;\n    [SerializeField] private float _reloadTime = 3f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _fireSound;\n    [SerializeField] private AudioClip _reloadSound;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnAmmoChanged;\n    public UnityEvent OnReloadStarted;\n    public UnityEvent OnReloadCompleted;\n\n    private float _lastFireTime;\n    private int _currentAmmo;\n    private bool _isReloading;\n\n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n\n    private void Update()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && CanFire())\n        {\n            Fire();\n        }\n\n        if (Input.GetKeyDown(KeyCode.R) && !_isReloading && _currentAmmo < _maxAmmo)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n\n    private bool CanFire()\n    {\n        return !_isReloading && \n               _currentAmmo > 0 && \n               Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n\n    private void Fire()\n    {\n        _lastFireTime = Time.time;\n        _currentAmmo--;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n\n        if (_rocketPrefab != null && _firePoint != null)\n        {\n            GameObject rocket = Instantiate(_rocketPrefab, _firePoint.position, _firePoint.rotation);\n            Rocket rocketScript = rocket.GetComponent<Rocket>();\n            if (rocketScript == null)\n            {\n                rocketScript = rocket.AddComponent<Rocket>();\n            }\n            rocketScript.Initialize(_rocketSpeed);\n        }\n\n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n\n        if (_audioSource != null && _fireSound != null)\n            _audioSource.PlayOneShot(_fireSound);\n\n        if (_currentAmmo <= 0)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n\n    private IEnumerator Reload()\n    {\n        _isReloading = true;\n        OnReloadStarted?.Invoke();\n\n        if (_audioSource != null && _reloadSound != null)\n            _audioSource.PlayOneShot(_reloadSound);\n\n        yield return new WaitForSeconds(_reloadTime);\n\n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n        OnAmmoChanged?.Invoke(_currentAmmo);\n        OnReloadCompleted?.Invoke();\n    }\n}\n\npublic class Rocket : MonoBehaviour\n{\n    [Header(\"Rocket Properties\")]\n    [SerializeField] private float _speed = 20f;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private float _explosionDamage = 100f;\n    [SerializeField] private float _explosionForce = 1000f;\n    [SerializeField] private float _lifetime = 10f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _explosionEffect;\n    [SerializeField] private AudioClip _explosionSound;\n\n    [Header(\"Layers\")]\n    [SerializeField] private LayerMask _damageableLayers = -1;\n\n    private Rigidbody _rigidbody;\n    private bool _hasExploded;\n\n    public void Initialize(float speed)\n    {\n        _speed = speed;\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        _rigidbody.velocity = transform.forward * _speed;\n        _rigidbody.useGravity = true;\n\n        Destroy(gameObject, _lifetime);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_hasExploded)\n        {\n            Explode();\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_hasExploded)\n        {\n            Explode();\n        }\n    }\n\n    private void Explode()\n    {\n        _hasExploded = true;\n\n        // Create explosion effect\n        if (_explosionEffect != null)\n        {\n            Instantiate(_explosionEffect, transform.position, Quaternion.identity);\n        }\n\n        // Play explosion sound\n        if (_explosionSound != null)\n        {\n            AudioSource.PlayClipAtPoint(_explosionSound, transform.position);\n        }\n\n        // Apply splash damage\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _damageableLayers);\n        \n        foreach (Collider hit in colliders)\n        {\n            float distance = Vector3.Distance(transform.position, hit.transform.position);\n            float damageMultiplier = 1f - (distance / _explosionRadius);\n            damageMultiplier = Mathf.Clamp01(damageMultiplier);\n            \n            float finalDamage = _explosionDamage * damageMultiplier;\n\n            // Apply damage to player\n            if (hit.CompareTag(\"Player\"))\n            {\n                PlayerDamageReceiver playerDamage = hit.GetComponent<PlayerDamageReceiver>();\n                if (playerDamage != null)\n                {\n                    playerDamage.TakeDamage(finalDamage);\n                }\n            }\n\n            // Apply damage to enemies\n            EnemyDamageReceiver enemyDamage = hit.GetComponent<EnemyDamageReceiver>();\n            if (enemyDamage != null)\n            {\n                enemyDamage.TakeDamage(finalDamage);\n            }\n\n            // Apply explosion force to rigidbodies\n            Rigidbody hitRigidbody = hit.GetComponent<Rigidbody>();\n            if (hitRigidbody != null)\n            {\n                hitRigidbody.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n        }\n\n        Destroy(gameObject);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n    }\n}\n\npublic class PlayerDamageReceiver : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n}\n\npublic class EnemyDamageReceiver : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 50f;\n    [SerializeField] private float _currentHealth;\n\n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n\n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n\n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n            Destroy(gameObject, 0.1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MageEnemy\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 80\n    },\n    {\n      \"name\": \"mana\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"castRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"spellDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"castCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"manaCostPerSpell\",\n      \"type\": \"int\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"manaRegenRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"retreatDistance\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"enter combat state\"\n        },\n        {\n          \"action\": \"face toward player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_distance\",\n      \"trigger\": \"when player is closer than retreat distance\",\n      \"actions\": [\n        {\n          \"action\": \"move away from player at movement speed\"\n        },\n        {\n          \"action\": \"maintain line of sight with player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cast_spell\",\n      \"trigger\": \"when player is within cast range and cooldown is ready and mana is sufficient\",\n      \"actions\": [\n        {\n          \"action\": \"play casting animation\"\n        },\n        {\n          \"action\": \"reduce mana by spell cost\"\n        },\n        {\n          \"action\": \"create spell projectile aimed at player\"\n        },\n        {\n          \"action\": \"start cast cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_mana\",\n      \"trigger\": \"when mana is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increase mana over time at regeneration rate\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by player attack\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt animation\"\n        },\n        {\n          \"action\": \"briefly interrupt current action\"\n        }\n      ]\n    },\n    {\n      \"name\": \"die\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"disable all combat behaviors\"\n        },\n        {\n          \"action\": \"destroy game object after animation completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_target\",\n      \"trigger\": \"when player leaves detection range\",\n      \"actions\": [\n        {\n          \"action\": \"exit combat state\"\n        },\n        {\n          \"action\": \"return to idle patrol behavior\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MageEnemy : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _detectionRange = 10f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _retreatDistance = 3f;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private float _attackCooldown = 2f;\n    [SerializeField] private float _spellCastTime = 1f;\n    \n    [Header(\"Spells\")]\n    [SerializeField] private GameObject _fireballPrefab;\n    [SerializeField] private GameObject _iceBoltPrefab;\n    [SerializeField] private GameObject _lightningPrefab;\n    [SerializeField] private Transform _spellSpawnPoint;\n    [SerializeField] private float _projectileSpeed = 15f;\n    [SerializeField] private int _projectileDamage = 25;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _castingEffect;\n    [SerializeField] private ParticleSystem _deathEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    private Transform _player;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private int _currentHealth;\n    private float _lastAttackTime;\n    private bool _isCasting;\n    private bool _isDead;\n    private EnemyState _currentState;\n    private Vector3 _initialPosition;\n    \n    private enum EnemyState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        Retreating,\n        Dead\n    }\n    \n    private enum SpellType\n    {\n        Fireball,\n        IceBolt,\n        Lightning\n    }\n    \n    void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _currentHealth = _maxHealth;\n        _currentState = EnemyState.Idle;\n        _initialPosition = transform.position;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_spellSpawnPoint == null)\n            _spellSpawnPoint = transform;\n            \n        FindPlayer();\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        HandleStateMachine();\n        UpdateAnimations();\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead || _isCasting) return;\n        \n        HandleMovement();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(\"Player\");\n        if (playerObject != null)\n            _player = playerObject.transform;\n    }\n    \n    private void HandleStateMachine()\n    {\n        if (_player == null)\n        {\n            FindPlayer();\n            return;\n        }\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);\n        \n        switch (_currentState)\n        {\n            case EnemyState.Idle:\n                if (distanceToPlayer <= _detectionRange)\n                    _currentState = EnemyState.Chasing;\n                break;\n                \n            case EnemyState.Chasing:\n                if (distanceToPlayer > _detectionRange)\n                    _currentState = EnemyState.Idle;\n                else if (distanceToPlayer <= _attackRange)\n                    _currentState = EnemyState.Attacking;\n                break;\n                \n            case EnemyState.Attacking:\n                if (distanceToPlayer > _attackRange)\n                    _currentState = EnemyState.Chasing;\n                else if (distanceToPlayer < _retreatDistance)\n                    _currentState = EnemyState.Retreating;\n                else\n                    TryAttack();\n                break;\n                \n            case EnemyState.Retreating:\n                if (distanceToPlayer >= _retreatDistance)\n                    _currentState = EnemyState.Attacking;\n                break;\n        }\n    }\n    \n    private void HandleMovement()\n    {\n        if (_player == null) return;\n        \n        Vector3 direction = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case EnemyState.Chasing:\n                direction = (_player.position - transform.position).normalized;\n                break;\n                \n            case EnemyState.Retreating:\n                direction = (transform.position - _player.position).normalized;\n                break;\n        }\n        \n        if (direction != Vector3.zero)\n        {\n            _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n            transform.LookAt(new Vector3(_player.position.x, transform.position.y, _player.position.z));\n        }\n    }\n    \n    private void TryAttack()\n    {\n        if (Time.time - _lastAttackTime >= _attackCooldown && !_isCasting)\n        {\n            StartCoroutine(CastSpell());\n            _lastAttackTime = Time.time;\n        }\n    }\n    \n    private IEnumerator CastSpell()\n    {\n        _isCasting = true;\n        \n        if (_castingEffect != null)\n            _castingEffect.Play();\n            \n        if (_audioSource != null && _castSound != null)\n            _audioSource.PlayOneShot(_castSound);\n        \n        yield return new WaitForSeconds(_spellCastTime);\n        \n        SpellType spellType = (SpellType)Random.Range(0, 3);\n        LaunchSpell(spellType);\n        \n        _isCasting = false;\n    }\n    \n    private void LaunchSpell(SpellType spellType)\n    {\n        if (_player == null) return;\n        \n        GameObject spellPrefab = GetSpellPrefab(spellType);\n        if (spellPrefab == null) return;\n        \n        Vector3 direction = (_player.position - _spellSpawnPoint.position).normalized;\n        GameObject spell = Instantiate(spellPrefab, _spellSpawnPoint.position, Quaternion.LookRotation(direction));\n        \n        Rigidbody spellRb = spell.GetComponent<Rigidbody>();\n        if (spellRb != null)\n        {\n            spellRb.velocity = direction * _projectileSpeed;\n        }\n        \n        SpellProjectile projectile = spell.GetComponent<SpellProjectile>();\n        if (projectile == null)\n        {\n            projectile = spell.AddComponent<SpellProjectile>();\n        }\n        projectile.Initialize(_projectileDamage, spellType);\n        \n        Destroy(spell, 5f);\n    }\n    \n    private GameObject GetSpellPrefab(SpellType spellType)\n    {\n        switch (spellType)\n        {\n            case SpellType.Fireball:\n                return _fireballPrefab;\n            case SpellType.IceBolt:\n                return _iceBoltPrefab;\n            case SpellType.Lightning:\n                return _lightningPrefab;\n            default:\n                return _fireballPrefab;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == EnemyState.Chasing || _currentState == EnemyState.Retreating);\n        _animator.SetBool(\"IsCasting\", _isCasting);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = EnemyState.Dead;\n        \n        if (_deathEffect != null)\n            _deathEffect.Play();\n            \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n        \n        GetComponent<Collider>().enabled = false;\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isDead)\n        {\n            _currentState = EnemyState.Attacking;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _retreatDistance);\n    }\n}\n\npublic class SpellProjectile : MonoBehaviour\n{\n    private int _damage;\n    private MageEnemy.SpellType _spellType;\n    private bool _hasHit;\n    \n    public void Initialize(int damage, MageEnemy.SpellType spellType)\n    {\n        _damage = damage;\n        _spellType = spellType;\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            ApplySpellEffect(other.gameObject);\n            _hasHit = true;\n            Destroy(gameObject);\n        }\n        else if (!other.CompareTag(\"Enemy\"))\n        {\n            _hasHit = true;\n            Destroy(gameObject);\n        }\n    }\n    \n    private void ApplySpellEffect(GameObject target)\n    {\n        // Apply damage - you would typically have a health component here\n        // For now, we'll just send a message that can be caught by any health system\n        target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        \n        // Apply spell-specific effects\n        switch (_spellType)\n        {\n            case MageEnemy.SpellType.IceBolt:\n                // Slow effect could be applied here\n                break;\n            case MageEnemy.SpellType.Lightning:\n                // Stun effect could be applied here\n                break;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WindGlider\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"glideSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"windSensitivity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"liftForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxAltitude\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"stallSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"glide_forward\",\n      \"trigger\": \"always while airborne\",\n      \"actions\": [\n        {\n          \"action\": \"move forward at glide speed\"\n        },\n        {\n          \"action\": \"gradually lose altitude due to gravity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"catch_updraft\",\n      \"trigger\": \"when entering wind current zone with upward flow\",\n      \"actions\": [\n        {\n          \"action\": \"gain upward lift force\"\n        },\n        {\n          \"action\": \"increase altitude while in updraft\"\n        },\n        {\n          \"action\": \"slightly increase forward speed from wind assistance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_with_crosswind\",\n      \"trigger\": \"when in wind current zone with horizontal flow\",\n      \"actions\": [\n        {\n          \"action\": \"drift sideways in direction of wind flow\"\n        },\n        {\n          \"action\": \"adjust flight path based on wind strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_lift_in_downdraft\",\n      \"trigger\": \"when entering wind current zone with downward flow\",\n      \"actions\": [\n        {\n          \"action\": \"lose lift and descend faster\"\n        },\n        {\n          \"action\": \"reduce forward speed due to air resistance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stall_at_low_speed\",\n      \"trigger\": \"when forward speed drops below stall speed\",\n      \"actions\": [\n        {\n          \"action\": \"lose control and drop rapidly\"\n        },\n        {\n          \"action\": \"tumble slightly while falling\"\n        }\n      ]\n    },\n    {\n      \"name\": \"altitude_limit\",\n      \"trigger\": \"when reaching maximum altitude\",\n      \"actions\": [\n        {\n          \"action\": \"prevent further upward movement\"\n        },\n        {\n          \"action\": \"maintain level flight at altitude ceiling\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Glider : MonoBehaviour\n{\n    [Header(\"Glider Physics\")]\n    [SerializeField] private float _liftForce = 15f;\n    [SerializeField] private float _dragCoefficient = 0.98f;\n    [SerializeField] private float _minGlideSpeed = 5f;\n    [SerializeField] private float _maxGlideSpeed = 25f;\n    [SerializeField] private float _stallSpeed = 3f;\n    \n    [Header(\"Control Settings\")]\n    [SerializeField] private float _pitchSensitivity = 2f;\n    [SerializeField] private float _rollSensitivity = 1.5f;\n    [SerializeField] private float _yawSensitivity = 1f;\n    [SerializeField] private float _maxPitchAngle = 45f;\n    [SerializeField] private float _maxRollAngle = 60f;\n    \n    [Header(\"Wind Response\")]\n    [SerializeField] private float _windInfluenceMultiplier = 1.2f;\n    [SerializeField] private float _turbulenceResistance = 0.8f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _windAudioSource;\n    [SerializeField] private AudioClip _windSoundClip;\n    [SerializeField] private float _minWindVolume = 0.1f;\n    [SerializeField] private float _maxWindVolume = 0.8f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnStall;\n    public UnityEvent OnLanding;\n    public UnityEvent<float> OnSpeedChanged;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded = false;\n    private bool _isStalling = false;\n    private float _currentSpeed;\n    private Vector3 _windVelocity;\n    private WindCurrent _currentWindZone;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = true;\n        _rigidbody.drag = 0.1f;\n        _rigidbody.angularDrag = 5f;\n        \n        if (_windAudioSource == null)\n        {\n            _windAudioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        SetupAudio();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_windAudioSource != null && _windSoundClip != null)\n        {\n            _windAudioSource.clip = _windSoundClip;\n            _windAudioSource.loop = true;\n            _windAudioSource.volume = _minWindVolume;\n            _windAudioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_isGrounded) return;\n        \n        HandleInput();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGrounded) return;\n        \n        CalculateAerodynamics();\n        ApplyWindEffects();\n        CheckStallCondition();\n        \n        _currentSpeed = _rigidbody.velocity.magnitude;\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void HandleInput()\n    {\n        float pitch = Input.GetAxis(\"Vertical\") * _pitchSensitivity;\n        float roll = -Input.GetAxis(\"Horizontal\") * _rollSensitivity;\n        float yaw = 0f;\n        \n        if (Input.GetKey(KeyCode.Q))\n            yaw = -_yawSensitivity;\n        else if (Input.GetKey(KeyCode.E))\n            yaw = _yawSensitivity;\n        \n        ApplyControlInputs(pitch, roll, yaw);\n    }\n    \n    private void ApplyControlInputs(float pitch, float roll, float yaw)\n    {\n        Vector3 torque = new Vector3(pitch, yaw, roll) * Time.fixedDeltaTime;\n        \n        Vector3 currentEuler = transform.eulerAngles;\n        float normalizedPitch = Mathf.DeltaAngle(0, currentEuler.x);\n        float normalizedRoll = Mathf.DeltaAngle(0, currentEuler.z);\n        \n        if (Mathf.Abs(normalizedPitch) > _maxPitchAngle && Mathf.Sign(pitch) == Mathf.Sign(normalizedPitch))\n            torque.x = 0;\n        \n        if (Mathf.Abs(normalizedRoll) > _maxRollAngle && Mathf.Sign(roll) == Mathf.Sign(normalizedRoll))\n            torque.z = 0;\n        \n        _rigidbody.AddTorque(torque, ForceMode.VelocityChange);\n    }\n    \n    private void CalculateAerodynamics()\n    {\n        Vector3 velocity = _rigidbody.velocity;\n        float speed = velocity.magnitude;\n        \n        if (speed < 0.1f) return;\n        \n        Vector3 forward = transform.forward;\n        Vector3 up = transform.up;\n        \n        float angleOfAttack = Vector3.Angle(forward, velocity.normalized);\n        float liftAmount = Mathf.Clamp01(1f - (angleOfAttack / 90f)) * _liftForce;\n        \n        Vector3 lift = up * liftAmount * speed * 0.1f;\n        _rigidbody.AddForce(lift, ForceMode.Force);\n        \n        Vector3 drag = -velocity.normalized * speed * speed * 0.01f * _dragCoefficient;\n        _rigidbody.AddForce(drag, ForceMode.Force);\n        \n        _rigidbody.velocity = Vector3.ClampMagnitude(_rigidbody.velocity, _maxGlideSpeed);\n    }\n    \n    private void ApplyWindEffects()\n    {\n        if (_currentWindZone != null)\n        {\n            _windVelocity = _currentWindZone.GetWindVelocityAtPosition(transform.position);\n            Vector3 windForce = _windVelocity * _windInfluenceMultiplier;\n            \n            if (_currentWindZone.HasTurbulence())\n            {\n                Vector3 turbulence = _currentWindZone.GetTurbulence(transform.position);\n                windForce += turbulence * (1f - _turbulenceResistance);\n            }\n            \n            _rigidbody.AddForce(windForce, ForceMode.Force);\n        }\n    }\n    \n    private void CheckStallCondition()\n    {\n        bool wasStalling = _isStalling;\n        _isStalling = _currentSpeed < _stallSpeed;\n        \n        if (_isStalling && !wasStalling)\n        {\n            OnStall?.Invoke();\n        }\n        \n        if (_isStalling)\n        {\n            _rigidbody.AddForce(Vector3.down * 20f, ForceMode.Force);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_windAudioSource != null && _windSoundClip != null)\n        {\n            float speedRatio = Mathf.Clamp01(_currentSpeed / _maxGlideSpeed);\n            float windStrength = _windVelocity.magnitude * 0.1f;\n            float targetVolume = Mathf.Lerp(_minWindVolume, _maxWindVolume, speedRatio + windStrength);\n            \n            _windAudioSource.volume = Mathf.Lerp(_windAudioSource.volume, targetVolume, Time.deltaTime * 2f);\n            _windAudioSource.pitch = Mathf.Lerp(0.8f, 1.4f, speedRatio);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Ground\"))\n        {\n            _isGrounded = true;\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.angularVelocity = Vector3.zero;\n            OnLanding?.Invoke();\n        }\n        \n        WindCurrent windCurrent = other.GetComponent<WindCurrent>();\n        if (windCurrent != null)\n        {\n            _currentWindZone = windCurrent;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Ground\"))\n        {\n            _isGrounded = false;\n        }\n        \n        WindCurrent windCurrent = other.GetComponent<WindCurrent>();\n        if (windCurrent != null && windCurrent == _currentWindZone)\n        {\n            _currentWindZone = null;\n            _windVelocity = Vector3.zero;\n        }\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsStalling()\n    {\n        return _isStalling;\n    }\n    \n    public Vector3 GetWindVelocity()\n    {\n        return _windVelocity;\n    }\n}\n\npublic class WindCurrent : MonoBehaviour\n{\n    [Header(\"Wind Properties\")]\n    [SerializeField] private Vector3 _windDirection = Vector3.forward;\n    [SerializeField] private float _windStrength = 10f;\n    [SerializeField] private AnimationCurve _strengthOverDistance = AnimationCurve.Linear(0, 1, 1, 0);\n    \n    [Header(\"Turbulence\")]\n    [SerializeField] private bool _hasTurbulence = false;\n    [SerializeField] private float _turbulenceStrength = 2f;\n    [SerializeField] private float _turbulenceFrequency = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _windParticles;\n    [SerializeField] private Color _windColor = Color.white;\n    \n    private Collider _windZone;\n    private Vector3 _center;\n    private Vector3 _size;\n    \n    private void Start()\n    {\n        _windZone = GetComponent<Collider>();\n        if (_windZone == null)\n        {\n            BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();\n            boxCollider.isTrigger = true;\n            boxCollider.size = Vector3.one * 10f;\n            _windZone = boxCollider;\n        }\n        \n        _windZone.isTrigger = true;\n        _center = _windZone.bounds.center;\n        _size = _windZone.bounds.size;\n        \n        SetupParticles();\n    }\n    \n    private void SetupParticles()\n    {\n        if (_windParticles == null)\n        {\n            GameObject particleGO = new GameObject(\"WindParticles\");\n            particleGO.transform.SetParent(transform);\n            particleGO.transform.localPosition = Vector3.zero;\n            _windParticles = particleGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _windParticles.main;\n        main.startColor = _windColor;\n        main.startSpeed = _windStrength * 0.5f;\n        main.maxParticles = 100;\n        \n        var shape = _windParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = _size;\n        \n        var velocityOverLifetime = _windParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.x = _windDirection.x * _windStrength;\n        velocityOverLifetime.y = _windDirection.y * _windStrength;\n        velocityOverLifetime.z = _windDirection.z * _windStrength;\n    }\n    \n    public Vector3 GetWindVelocityAtPosition(Vector3 position)\n    {\n        float distance = Vector3.Distance(position, _center);\n        float maxDistance = Mathf.Max(_size.x, _size.y, _size.z) * 0.5f;\n        float normalizedDistance = Mathf.Clamp01(distance / maxDistance);\n        \n        float strengthMultiplier = _strengthOverDistance.Evaluate(normalizedDistance);\n        return _windDirection.normalized * _windStrength * strengthMultiplier;\n    }\n    \n    public bool HasTurbulence()\n    {\n        return _hasTurbulence;\n    }\n    \n    public Vector3 GetTurbulence(Vector3 position)\n    {\n        if (!_hasTurbulence) return Vector3.zero;\n        \n        float time = Time.time * _turbulenceFrequency;\n        float noiseX = Mathf.PerlinNoise(position.x * 0.1f + time, position.z * 0.1f) - 0.5f;\n        float noiseY = Mathf.PerlinNoise(position.y * 0.1f + time, position.x * 0.1f) - 0.5f;\n        float noiseZ = Mathf.PerlinNoise(position.z * 0.1f + time, position.y * 0.1f) - 0.5f;\n        \n        return new Vector3(noiseX, noiseY, noiseZ) * _turbulenceStrength;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _windColor;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n        \n        Gizmos.color = Color.yellow;\n        Vector3 arrowEnd = _windDirection.normalized * 2f;\n        Gizmos.DrawRay(Vector3.zero, arrowEnd);\n        Gizmos.DrawWireSphere(arrowEnd, 0.2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DragonMount\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"flySpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"ascendSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"descendSpeed\",\n      \"type\": \"float\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"maxAltitude\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"minAltitude\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"wingFlapForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"isFlying\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hasRider\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_flying\",\n      \"trigger\": \"when rider mounts and presses fly button\",\n      \"actions\": [\n        {\n          \"action\": \"set flying state to true\"\n        },\n        {\n          \"action\": \"play wing flap animation\"\n        },\n        {\n          \"action\": \"apply upward force to lift off ground\"\n        },\n        {\n          \"action\": \"enable aerial movement controls\"\n        }\n      ]\n    },\n    {\n      \"name\": \"aerial_movement\",\n      \"trigger\": \"when flying and receiving movement input\",\n      \"actions\": [\n        {\n          \"action\": \"move forward at fly speed based on input direction\"\n        },\n        {\n          \"action\": \"rotate smoothly toward input direction at turn speed\"\n        },\n        {\n          \"action\": \"tilt body to show banking during turns\"\n        },\n        {\n          \"action\": \"adjust wing flap animation speed based on movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"altitude_control\",\n      \"trigger\": \"when flying and receiving vertical input\",\n      \"actions\": [\n        {\n          \"action\": \"ascend at ascend speed when climb input detected\"\n        },\n        {\n          \"action\": \"descend at descend speed when dive input detected\"\n        },\n        {\n          \"action\": \"limit altitude between minimum and maximum values\"\n        },\n        {\n          \"action\": \"play appropriate climbing or diving animations\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_flight\",\n      \"trigger\": \"when flying without input\",\n      \"actions\": [\n        {\n          \"action\": \"maintain current altitude with gentle hovering\"\n        },\n        {\n          \"action\": \"play idle flying animation with wing beats\"\n        },\n        {\n          \"action\": \"apply small random movements for natural flight feel\"\n        },\n        {\n          \"action\": \"gradually reduce speed if no forward input\"\n        }\n      ]\n    },\n    {\n      \"name\": \"landing\",\n      \"trigger\": \"when flying near ground and landing input received\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce altitude toward ground\"\n        },\n        {\n          \"action\": \"slow horizontal movement for controlled descent\"\n        },\n        {\n          \"action\": \"play landing animation when close to surface\"\n        },\n        {\n          \"action\": \"set flying state to false when touching ground\"\n        },\n        {\n          \"action\": \"transition to ground movement mode\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dismount_in_air\",\n      \"trigger\": \"when rider dismounts while flying\",\n      \"actions\": [\n        {\n          \"action\": \"eject rider safely with parachute or gliding ability\"\n        },\n        {\n          \"action\": \"continue flying in autonomous mode\"\n        },\n        {\n          \"action\": \"set has rider state to false\"\n        },\n        {\n          \"action\": \"fly in circles or return to designated perch\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DragonMount : MonoBehaviour\n{\n    [Header(\"Flight Settings\")]\n    [SerializeField] private float _flySpeed = 15f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _maxAltitude = 100f;\n    [SerializeField] private float _minAltitude = 2f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _pitchSpeed = 60f;\n    [SerializeField] private float _yawSpeed = 90f;\n    [SerializeField] private float _rollSpeed = 45f;\n    [SerializeField] private float _maxPitchAngle = 45f;\n    [SerializeField] private float _maxRollAngle = 30f;\n    \n    [Header(\"Wing Animation\")]\n    [SerializeField] private Transform _leftWing;\n    [SerializeField] private Transform _rightWing;\n    [SerializeField] private float _wingFlapSpeed = 3f;\n    [SerializeField] private float _wingFlapAngle = 20f;\n    \n    [Header(\"Rider Settings\")]\n    [SerializeField] private Transform _riderSeat;\n    [SerializeField] private float _mountRange = 3f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    [SerializeField] private KeyCode _dismountKey = KeyCode.Q;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _wingFlapSound;\n    [SerializeField] private AudioClip _roarSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerMounted;\n    public UnityEvent OnPlayerDismounted;\n    public UnityEvent OnTakeOff;\n    public UnityEvent OnLanding;\n    \n    private Rigidbody _rigidbody;\n    private Transform _rider;\n    private Vector3 _currentVelocity;\n    private float _currentSpeed;\n    private float _wingFlapTimer;\n    private bool _isGrounded = true;\n    private bool _hasRider = false;\n    private Vector3 _originalRiderPosition;\n    private Quaternion _originalRiderRotation;\n    private CharacterController _riderController;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.useGravity = false;\n        _rigidbody.drag = 2f;\n        _rigidbody.angularDrag = 5f;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.spatialBlend = 1f;\n        _audioSource.volume = 0.7f;\n    }\n    \n    private void Update()\n    {\n        CheckForRiderInput();\n        \n        if (_hasRider)\n        {\n            HandleFlightInput();\n            AnimateWings();\n            PlayFlightSounds();\n        }\n        else\n        {\n            HandleIdleBehavior();\n        }\n        \n        CheckGroundStatus();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_hasRider)\n        {\n            ApplyFlightPhysics();\n        }\n        else\n        {\n            ApplyIdlePhysics();\n        }\n    }\n    \n    private void CheckForRiderInput()\n    {\n        if (!_hasRider)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null && Vector3.Distance(transform.position, player.transform.position) <= _mountRange)\n            {\n                if (Input.GetKeyDown(_mountKey))\n                {\n                    MountPlayer(player.transform);\n                }\n            }\n        }\n        else\n        {\n            if (Input.GetKeyDown(_dismountKey))\n            {\n                DismountPlayer();\n            }\n        }\n    }\n    \n    private void MountPlayer(Transform player)\n    {\n        _rider = player;\n        _hasRider = true;\n        \n        _originalRiderPosition = player.position;\n        _originalRiderRotation = player.rotation;\n        \n        _riderController = player.GetComponent<CharacterController>();\n        if (_riderController != null)\n        {\n            _riderController.enabled = false;\n        }\n        \n        Rigidbody riderRb = player.GetComponent<Rigidbody>();\n        if (riderRb != null)\n        {\n            riderRb.isKinematic = true;\n        }\n        \n        player.SetParent(_riderSeat);\n        player.localPosition = Vector3.zero;\n        player.localRotation = Quaternion.identity;\n        \n        OnPlayerMounted?.Invoke();\n        \n        if (_roarSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_roarSound);\n        }\n    }\n    \n    private void DismountPlayer()\n    {\n        if (_rider == null) return;\n        \n        _rider.SetParent(null);\n        \n        Vector3 dismountPosition = transform.position + transform.right * 3f;\n        RaycastHit hit;\n        if (Physics.Raycast(dismountPosition + Vector3.up * 10f, Vector3.down, out hit, 20f))\n        {\n            dismountPosition = hit.point + Vector3.up * 0.5f;\n        }\n        \n        _rider.position = dismountPosition;\n        _rider.rotation = _originalRiderRotation;\n        \n        if (_riderController != null)\n        {\n            _riderController.enabled = true;\n        }\n        \n        Rigidbody riderRb = _rider.GetComponent<Rigidbody>();\n        if (riderRb != null)\n        {\n            riderRb.isKinematic = false;\n        }\n        \n        _hasRider = false;\n        _rider = null;\n        \n        OnPlayerDismounted?.Invoke();\n    }\n    \n    private void HandleFlightInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        float ascend = Input.GetKey(KeyCode.Space) ? 1f : 0f;\n        float descend = Input.GetKey(KeyCode.LeftShift) ? 1f : 0f;\n        \n        Vector3 inputDirection = new Vector3(horizontal, ascend - descend, vertical);\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, _flySpeed, _acceleration * Time.deltaTime);\n            \n            if (_isGrounded && (ascend > 0 || vertical > 0))\n            {\n                _isGrounded = false;\n                OnTakeOff?.Invoke();\n            }\n        }\n        else\n        {\n            _currentSpeed = Mathf.MoveTowards(_currentSpeed, 0f, _deceleration * Time.deltaTime);\n        }\n        \n        if (inputDirection.magnitude > 0.1f)\n        {\n            float targetYaw = horizontal * _yawSpeed * Time.deltaTime;\n            float targetPitch = -vertical * _pitchSpeed * Time.deltaTime;\n            float targetRoll = -horizontal * _rollSpeed * Time.deltaTime;\n            \n            targetPitch = Mathf.Clamp(targetPitch, -_maxPitchAngle, _maxPitchAngle);\n            targetRoll = Mathf.Clamp(targetRoll, -_maxRollAngle, _maxRollAngle);\n            \n            transform.Rotate(targetPitch, targetYaw, 0f, Space.Self);\n            \n            Vector3 currentEuler = transform.eulerAngles;\n            currentEuler.z = Mathf.LerpAngle(currentEuler.z, targetRoll, Time.deltaTime * 2f);\n            transform.eulerAngles = currentEuler;\n        }\n        else\n        {\n            Vector3 currentEuler = transform.eulerAngles;\n            currentEuler.z = Mathf.LerpAngle(currentEuler.z, 0f, Time.deltaTime * 2f);\n            transform.eulerAngles = currentEuler;\n        }\n    }\n    \n    private void ApplyFlightPhysics()\n    {\n        Vector3 forwardMovement = transform.forward * _currentSpeed;\n        \n        float currentAltitude = transform.position.y;\n        if (currentAltitude > _maxAltitude)\n        {\n            forwardMovement.y = Mathf.Min(forwardMovement.y, 0f);\n        }\n        else if (currentAltitude < _minAltitude)\n        {\n            forwardMovement.y = Mathf.Max(forwardMovement.y, 2f);\n        }\n        \n        _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, forwardMovement, Time.fixedDeltaTime * 3f);\n    }\n    \n    private void ApplyIdlePhysics()\n    {\n        if (!_isGrounded)\n        {\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, Vector3.down * 2f, Time.fixedDeltaTime);\n        }\n        else\n        {\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, Vector3.zero, Time.fixedDeltaTime * 5f);\n        }\n    }\n    \n    private void HandleIdleBehavior()\n    {\n        transform.rotation = Quaternion.Lerp(transform.rotation, \n            Quaternion.LookRotation(transform.forward, Vector3.up), Time.deltaTime);\n    }\n    \n    private void AnimateWings()\n    {\n        if (_leftWing == null || _rightWing == null) return;\n        \n        _wingFlapTimer += Time.deltaTime * _wingFlapSpeed;\n        float flapAngle = Mathf.Sin(_wingFlapTimer) * _wingFlapAngle;\n        \n        _leftWing.localRotation = Quaternion.Euler(0f, 0f, flapAngle);\n        _rightWing.localRotation = Quaternion.Euler(0f, 0f, -flapAngle);\n    }\n    \n    private void PlayFlightSounds()\n    {\n        if (_wingFlapSound != null && _audioSource != null && _currentSpeed > 0.5f)\n        {\n            if (!_audioSource.isPlaying)\n            {\n                _audioSource.clip = _wingFlapSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            _audioSource.pitch = Mathf.Lerp(0.8f, 1.5f, _currentSpeed / _flySpeed);\n        }\n        else if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _wingFlapSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void CheckGroundStatus()\n    {\n        RaycastHit hit;\n        bool wasGrounded = _isGrounded;\n        _isGrounded = Physics.Raycast(transform.position, Vector3.down, out hit, 2f);\n        \n        if (!wasGrounded && _isGrounded)\n        {\n            OnLanding?.Invoke();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        if (_riderSeat != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_riderSeat.position, Vector3.one * 0.5f);\n        }\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CloneAbility\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"cloneDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"cloneCount\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"spawnDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"cloneHealthPercentage\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"cloneDamagePercentage\",\n      \"type\": \"float\",\n      \"default\": 0.75\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_clone_ability\",\n      \"trigger\": \"when clone ability key is pressed and ability is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"create specified number of clones around the player\"\n        },\n        {\n          \"action\": \"position clones at spawn distance from player\"\n        },\n        {\n          \"action\": \"copy player appearance and equipment to clones\"\n        },\n        {\n          \"action\": \"set clone health to percentage of player health\"\n        },\n        {\n          \"action\": \"set clone damage to percentage of player damage\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"clone_combat_behavior\",\n      \"trigger\": \"when clone is created and enemies are nearby\",\n      \"actions\": [\n        {\n          \"action\": \"target nearest enemy to the clone\"\n        },\n        {\n          \"action\": \"move toward targeted enemy\"\n        },\n        {\n          \"action\": \"attack enemy using copied abilities\"\n        },\n        {\n          \"action\": \"take damage when hit by enemies\"\n        }\n      ]\n    },\n    {\n      \"name\": \"clone_expiration\",\n      \"trigger\": \"when clone duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"play disappearing visual effect\"\n        },\n        {\n          \"action\": \"destroy clone object\"\n        },\n        {\n          \"action\": \"remove clone from active clone list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"clone_death\",\n      \"trigger\": \"when clone health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play clone death animation\"\n        },\n        {\n          \"action\": \"create small explosion effect\"\n        },\n        {\n          \"action\": \"destroy clone object immediately\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooldown_management\",\n      \"trigger\": \"when cooldown timer is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease cooldown timer\"\n        },\n        {\n          \"action\": \"disable clone ability activation\"\n        },\n        {\n          \"action\": \"show cooldown progress on UI\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class CloneAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class CloneData\n    {\n        public GameObject clonePrefab;\n        public float lifetime = 5f;\n        public float health = 100f;\n        public bool canAttack = true;\n        public bool followsPlayer = false;\n        public float followDistance = 3f;\n    }\n\n    [Header(\"Clone Settings\")]\n    [SerializeField] private CloneData _cloneData;\n    [SerializeField] private int _maxClones = 3;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private float _spawnRadius = 2f;\n    [SerializeField] private LayerMask _spawnLayerMask = -1;\n\n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _cloneKey = KeyCode.C;\n\n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _spawnEffect;\n    [SerializeField] private GameObject _despawnEffect;\n    [SerializeField] private AudioClip _spawnSound;\n    [SerializeField] private AudioClip _despawnSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnCloneSpawned;\n    public UnityEvent<GameObject> OnCloneDespawned;\n    public UnityEvent OnCooldownStarted;\n    public UnityEvent OnCooldownEnded;\n\n    private List<GameObject> _activeClones = new List<GameObject>();\n    private float _lastCloneTime;\n    private AudioSource _audioSource;\n    private Transform _playerTransform;\n\n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _playerTransform = transform;\n        \n        if (_cloneData.clonePrefab == null)\n        {\n            Debug.LogWarning(\"Clone prefab not assigned to CloneAbility on \" + gameObject.name);\n        }\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        CleanupDestroyedClones();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_cloneKey))\n        {\n            TrySpawnClone();\n        }\n    }\n\n    public void TrySpawnClone()\n    {\n        if (!CanSpawnClone())\n            return;\n\n        Vector3 spawnPosition = GetValidSpawnPosition();\n        if (spawnPosition != Vector3.zero)\n        {\n            SpawnClone(spawnPosition);\n        }\n    }\n\n    private bool CanSpawnClone()\n    {\n        if (_cloneData.clonePrefab == null)\n            return false;\n\n        if (_activeClones.Count >= _maxClones)\n            return false;\n\n        if (Time.time - _lastCloneTime < _cooldownTime)\n            return false;\n\n        return true;\n    }\n\n    private Vector3 GetValidSpawnPosition()\n    {\n        for (int attempts = 0; attempts < 10; attempts++)\n        {\n            Vector2 randomCircle = Random.insideUnitCircle * _spawnRadius;\n            Vector3 testPosition = _playerTransform.position + new Vector3(randomCircle.x, 0, randomCircle.y);\n            \n            if (Physics.CheckSphere(testPosition, 0.5f, _spawnLayerMask))\n                continue;\n\n            return testPosition;\n        }\n\n        return _playerTransform.position + _playerTransform.forward * 2f;\n    }\n\n    private void SpawnClone(Vector3 position)\n    {\n        GameObject clone = Instantiate(_cloneData.clonePrefab, position, _playerTransform.rotation);\n        \n        CloneController cloneController = clone.GetComponent<CloneController>();\n        if (cloneController == null)\n            cloneController = clone.AddComponent<CloneController>();\n\n        cloneController.Initialize(_cloneData, _playerTransform);\n        \n        _activeClones.Add(clone);\n        _lastCloneTime = Time.time;\n\n        StartCoroutine(DestroyCloneAfterTime(clone, _cloneData.lifetime));\n\n        if (_spawnEffect != null)\n            Instantiate(_spawnEffect, position, Quaternion.identity);\n\n        if (_spawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_spawnSound);\n\n        OnCloneSpawned?.Invoke(clone);\n        OnCooldownStarted?.Invoke();\n        \n        StartCoroutine(CooldownTimer());\n    }\n\n    private IEnumerator DestroyCloneAfterTime(GameObject clone, float time)\n    {\n        yield return new WaitForSeconds(time);\n        \n        if (clone != null)\n        {\n            DestroyClone(clone);\n        }\n    }\n\n    private IEnumerator CooldownTimer()\n    {\n        yield return new WaitForSeconds(_cooldownTime);\n        OnCooldownEnded?.Invoke();\n    }\n\n    public void DestroyClone(GameObject clone)\n    {\n        if (clone == null)\n            return;\n\n        _activeClones.Remove(clone);\n\n        if (_despawnEffect != null)\n            Instantiate(_despawnEffect, clone.transform.position, Quaternion.identity);\n\n        if (_despawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_despawnSound);\n\n        OnCloneDespawned?.Invoke(clone);\n        Destroy(clone);\n    }\n\n    public void DestroyAllClones()\n    {\n        for (int i = _activeClones.Count - 1; i >= 0; i--)\n        {\n            if (_activeClones[i] != null)\n                DestroyClone(_activeClones[i]);\n        }\n        _activeClones.Clear();\n    }\n\n    private void CleanupDestroyedClones()\n    {\n        for (int i = _activeClones.Count - 1; i >= 0; i--)\n        {\n            if (_activeClones[i] == null)\n            {\n                _activeClones.RemoveAt(i);\n            }\n        }\n    }\n\n    public bool IsOnCooldown()\n    {\n        return Time.time - _lastCloneTime < _cooldownTime;\n    }\n\n    public float GetCooldownProgress()\n    {\n        return Mathf.Clamp01((Time.time - _lastCloneTime) / _cooldownTime);\n    }\n\n    public int GetActiveCloneCount()\n    {\n        CleanupDestroyedClones();\n        return _activeClones.Count;\n    }\n\n    public List<GameObject> GetActiveClones()\n    {\n        CleanupDestroyedClones();\n        return new List<GameObject>(_activeClones);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n    }\n}\n\npublic class CloneController : MonoBehaviour\n{\n    private CloneAbility.CloneData _data;\n    private Transform _playerTransform;\n    private float _currentHealth;\n    private bool _isInitialized;\n\n    public void Initialize(CloneAbility.CloneData data, Transform playerTransform)\n    {\n        _data = data;\n        _playerTransform = playerTransform;\n        _currentHealth = data.health;\n        _isInitialized = true;\n    }\n\n    private void Update()\n    {\n        if (!_isInitialized || _playerTransform == null)\n            return;\n\n        if (_data.followsPlayer)\n        {\n            FollowPlayer();\n        }\n    }\n\n    private void FollowPlayer()\n    {\n        float distance = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distance > _data.followDistance)\n        {\n            Vector3 direction = (_playerTransform.position - transform.position).normalized;\n            transform.position += direction * Time.deltaTime * 5f;\n            transform.LookAt(_playerTransform);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        CloneAbility cloneAbility = _playerTransform.GetComponent<CloneAbility>();\n        if (cloneAbility != null)\n        {\n            cloneAbility.DestroyClone(gameObject);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Enemy\") && _data.canAttack)\n        {\n            // Clone can interact with enemies\n            Debug.Log(\"Clone interacting with enemy: \" + other.name);\n        }\n    }\n\n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _data.health;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CollectibleCoin\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"scoreValue\",\n      \"type\": \"int\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"rotate_continuously\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_coin\",\n      \"trigger\": \"when player touches this coin\",\n      \"actions\": [\n        {\n          \"action\": \"add score value to player score\"\n        },\n        {\n          \"action\": \"destroy this coin object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class CollectibleCoin : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private Vector3 _rotationSpeed = new Vector3(0, 180, 0);\n    \n    [Header(\"Collection Settings\")]\n    [SerializeField] private int _scoreValue = 10;\n    [SerializeField] private bool _destroyOnCollect = true;\n    [SerializeField] private float _collectDelay = 0f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _collectSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _collectEffect;\n    [SerializeField] private float _effectDuration = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnCoinCollected;\n    public UnityEvent OnCollectionComplete;\n    \n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private bool _isCollected = false;\n    \n    public static int TotalScore { get; private set; } = 0;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _collectSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_collider != null)\n        {\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isCollected)\n        {\n            transform.Rotate(_rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isCollected) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            CollectCoin();\n        }\n    }\n    \n    private void CollectCoin()\n    {\n        if (_isCollected) return;\n        \n        _isCollected = true;\n        \n        TotalScore += _scoreValue;\n        \n        OnCoinCollected?.Invoke(_scoreValue);\n        \n        PlayCollectSound();\n        SpawnCollectEffect();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_collectDelay > 0)\n        {\n            Invoke(nameof(CompleteCollection), _collectDelay);\n        }\n        else\n        {\n            CompleteCollection();\n        }\n    }\n    \n    private void PlayCollectSound()\n    {\n        if (_collectSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _collectSound;\n            _audioSource.volume = _volume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void SpawnCollectEffect()\n    {\n        if (_collectEffect != null)\n        {\n            GameObject effect = Instantiate(_collectEffect, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n    }\n    \n    private void CompleteCollection()\n    {\n        OnCollectionComplete?.Invoke();\n        \n        if (_destroyOnCollect)\n        {\n            Destroy(gameObject);\n        }\n    }\n    \n    public static void ResetScore()\n    {\n        TotalScore = 0;\n    }\n    \n    public void SetScoreValue(int value)\n    {\n        _scoreValue = Mathf.Max(0, value);\n    }\n    \n    public int GetScoreValue()\n    {\n        return _scoreValue;\n    }\n    \n    public bool IsCollected()\n    {\n        return _isCollected;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StatisticsTracker\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"totalScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"enemiesDefeated\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"itemsCollected\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"distanceTraveled\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"timeAlive\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"levelsCompleted\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"deathCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"highScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"sessionStartTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"lastPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_session\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"record current time as session start\"\n        },\n        {\n          \"action\": \"store current player position as starting position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_score_increase\",\n      \"trigger\": \"when score increases\",\n      \"actions\": [\n        {\n          \"action\": \"add score increase amount to total score\"\n        },\n        {\n          \"action\": \"update high score if total score exceeds previous high score\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_enemy_defeat\",\n      \"trigger\": \"when enemy is defeated\",\n      \"actions\": [\n        {\n          \"action\": \"increment enemies defeated counter by one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_item_collection\",\n      \"trigger\": \"when item is collected\",\n      \"actions\": [\n        {\n          \"action\": \"increment items collected counter by one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_distance_traveled\",\n      \"trigger\": \"every frame while player is moving\",\n      \"actions\": [\n        {\n          \"action\": \"calculate distance between current position and last recorded position\"\n        },\n        {\n          \"action\": \"add calculated distance to total distance traveled\"\n        },\n        {\n          \"action\": \"update last recorded position to current position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_survival_time\",\n      \"trigger\": \"every frame while player is alive\",\n      \"actions\": [\n        {\n          \"action\": \"calculate time elapsed since session start\"\n        },\n        {\n          \"action\": \"update time alive with elapsed time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_level_completion\",\n      \"trigger\": \"when level is completed\",\n      \"actions\": [\n        {\n          \"action\": \"increment levels completed counter by one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_player_death\",\n      \"trigger\": \"when player dies\",\n      \"actions\": [\n        {\n          \"action\": \"increment death count by one\"\n        }\n      ]\n    },\n    {\n      \"name\": \"save_statistics\",\n      \"trigger\": \"when game session ends\",\n      \"actions\": [\n        {\n          \"action\": \"save all tracked statistics to persistent storage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_session_stats\",\n      \"trigger\": \"when new game session begins\",\n      \"actions\": [\n        {\n          \"action\": \"reset all session-specific statistics to zero\"\n        },\n        {\n          \"action\": \"preserve persistent statistics like high score and total statistics\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System;\n\npublic class StatisticsTracker : MonoBehaviour\n{\n    [System.Serializable]\n    public class StatisticEntry\n    {\n        public string name;\n        public float value;\n        public float maxValue;\n        public bool trackMaximum;\n        \n        public StatisticEntry(string statName, float initialValue = 0f, bool trackMax = false)\n        {\n            name = statName;\n            value = initialValue;\n            maxValue = initialValue;\n            trackMaximum = trackMax;\n        }\n    }\n\n    [System.Serializable]\n    public class StatisticEvent : UnityEvent<string, float> { }\n\n    [Header(\"Statistics Configuration\")]\n    [SerializeField] private List<StatisticEntry> _statistics = new List<StatisticEntry>();\n    [SerializeField] private bool _persistBetweenScenes = true;\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    [SerializeField] private string _savePrefix = \"Stats_\";\n\n    [Header(\"Display Settings\")]\n    [SerializeField] private bool _showDebugInfo = false;\n    [SerializeField] private Vector2 _debugPosition = new Vector2(10, 10);\n\n    [Header(\"Events\")]\n    public StatisticEvent OnStatisticChanged;\n    public StatisticEvent OnStatisticMaxReached;\n    public UnityEvent OnStatisticsReset;\n\n    private Dictionary<string, StatisticEntry> _statisticsDict = new Dictionary<string, StatisticEntry>();\n    private Dictionary<string, float> _sessionStartValues = new Dictionary<string, float>();\n\n    public static StatisticsTracker Instance { get; private set; }\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            if (_persistBetweenScenes)\n            {\n                DontDestroyOnLoad(gameObject);\n            }\n            InitializeStatistics();\n        }\n        else if (Instance != this)\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void Start()\n    {\n        LoadStatistics();\n        RecordSessionStartValues();\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (!pauseStatus && _saveToPlayerPrefs)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _saveToPlayerPrefs)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_saveToPlayerPrefs && Instance == this)\n        {\n            SaveStatistics();\n        }\n    }\n\n    private void OnGUI()\n    {\n        if (!_showDebugInfo) return;\n\n        GUILayout.BeginArea(new Rect(_debugPosition.x, _debugPosition.y, 300, 400));\n        GUILayout.Label(\"Statistics Tracker\", GUI.skin.box);\n        \n        foreach (var stat in _statistics)\n        {\n            string displayText = $\"{stat.name}: {stat.value:F2}\";\n            if (stat.trackMaximum)\n            {\n                displayText += $\" (Max: {stat.maxValue:F2})\";\n            }\n            GUILayout.Label(displayText);\n        }\n        \n        GUILayout.EndArea();\n    }\n\n    private void InitializeStatistics()\n    {\n        _statisticsDict.Clear();\n        \n        foreach (var stat in _statistics)\n        {\n            if (!_statisticsDict.ContainsKey(stat.name))\n            {\n                _statisticsDict[stat.name] = stat;\n            }\n        }\n\n        // Add common default statistics if not already present\n        AddDefaultStatistics();\n    }\n\n    private void AddDefaultStatistics()\n    {\n        string[] defaultStats = {\n            \"PlayTime\", \"Score\", \"Deaths\", \"Kills\", \"ItemsCollected\",\n            \"JumpsPerformed\", \"DistanceTraveled\", \"DamageTaken\", \"DamageDealt\"\n        };\n\n        foreach (string statName in defaultStats)\n        {\n            if (!_statisticsDict.ContainsKey(statName))\n            {\n                var newStat = new StatisticEntry(statName, 0f, true);\n                _statistics.Add(newStat);\n                _statisticsDict[statName] = newStat;\n            }\n        }\n    }\n\n    private void RecordSessionStartValues()\n    {\n        _sessionStartValues.Clear();\n        foreach (var kvp in _statisticsDict)\n        {\n            _sessionStartValues[kvp.Key] = kvp.Value.value;\n        }\n    }\n\n    public void AddStatistic(string statName, float initialValue = 0f, bool trackMaximum = false)\n    {\n        if (_statisticsDict.ContainsKey(statName)) return;\n\n        var newStat = new StatisticEntry(statName, initialValue, trackMaximum);\n        _statistics.Add(newStat);\n        _statisticsDict[statName] = newStat;\n    }\n\n    public void SetStatistic(string statName, float value)\n    {\n        if (!_statisticsDict.ContainsKey(statName))\n        {\n            AddStatistic(statName, value);\n            return;\n        }\n\n        var stat = _statisticsDict[statName];\n        float oldValue = stat.value;\n        stat.value = value;\n\n        if (stat.trackMaximum && value > stat.maxValue)\n        {\n            stat.maxValue = value;\n            OnStatisticMaxReached?.Invoke(statName, value);\n        }\n\n        if (Mathf.Abs(oldValue - value) > 0.001f)\n        {\n            OnStatisticChanged?.Invoke(statName, value);\n        }\n    }\n\n    public void IncrementStatistic(string statName, float amount = 1f)\n    {\n        if (!_statisticsDict.ContainsKey(statName))\n        {\n            AddStatistic(statName, amount);\n            return;\n        }\n\n        SetStatistic(statName, _statisticsDict[statName].value + amount);\n    }\n\n    public void DecrementStatistic(string statName, float amount = 1f)\n    {\n        IncrementStatistic(statName, -amount);\n    }\n\n    public float GetStatistic(string statName)\n    {\n        return _statisticsDict.ContainsKey(statName) ? _statisticsDict[statName].value : 0f;\n    }\n\n    public float GetMaxStatistic(string statName)\n    {\n        return _statisticsDict.ContainsKey(statName) ? _statisticsDict[statName].maxValue : 0f;\n    }\n\n    public float GetSessionChange(string statName)\n    {\n        if (!_statisticsDict.ContainsKey(statName) || !_sessionStartValues.ContainsKey(statName))\n            return 0f;\n\n        return _statisticsDict[statName].value - _sessionStartValues[statName];\n    }\n\n    public Dictionary<string, float> GetAllStatistics()\n    {\n        var result = new Dictionary<string, float>();\n        foreach (var kvp in _statisticsDict)\n        {\n            result[kvp.Key] = kvp.Value.value;\n        }\n        return result;\n    }\n\n    public void ResetStatistic(string statName)\n    {\n        if (_statisticsDict.ContainsKey(statName))\n        {\n            _statisticsDict[statName].value = 0f;\n            _statisticsDict[statName].maxValue = 0f;\n            OnStatisticChanged?.Invoke(statName, 0f);\n        }\n    }\n\n    public void ResetAllStatistics()\n    {\n        foreach (var stat in _statistics)\n        {\n            stat.value = 0f;\n            stat.maxValue = 0f;\n        }\n        \n        RecordSessionStartValues();\n        OnStatisticsReset?.Invoke();\n    }\n\n    public void TrackPlayTime()\n    {\n        IncrementStatistic(\"PlayTime\", Time.deltaTime);\n    }\n\n    private void Update()\n    {\n        TrackPlayTime();\n    }\n\n    public void SaveStatistics()\n    {\n        if (!_saveToPlayerPrefs) return;\n\n        foreach (var kvp in _statisticsDict)\n        {\n            PlayerPrefs.SetFloat(_savePrefix + kvp.Key, kvp.Value.value);\n            if (kvp.Value.trackMaximum)\n            {\n                PlayerPrefs.SetFloat(_savePrefix + kvp.Key + \"_Max\", kvp.Value.maxValue);\n            }\n        }\n        PlayerPrefs.Save();\n    }\n\n    public void LoadStatistics()\n    {\n        if (!_saveToPlayerPrefs) return;\n\n        foreach (var kvp in _statisticsDict)\n        {\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key))\n            {\n                kvp.Value.value = PlayerPrefs.GetFloat(_savePrefix + kvp.Key, 0f);\n            }\n            \n            if (kvp.Value.trackMaximum && PlayerPrefs.HasKey(_savePrefix + kvp.Key + \"_Max\"))\n            {\n                kvp.Value.maxValue = PlayerPrefs.GetFloat(_savePrefix + kvp.Key + \"_Max\", 0f);\n            }\n        }\n    }\n\n    public void DeleteSavedStatistics()\n    {\n        foreach (var kvp in _statisticsDict)\n        {\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key))\n            {\n                PlayerPrefs.DeleteKey(_savePrefix + kvp.Key);\n            }\n            if (PlayerPrefs.HasKey(_savePrefix + kvp.Key + \"_Max\"))\n            {\n                PlayerPrefs.DeleteKey(_savePrefix + kvp.Key + \"_Max\");\n            }\n        }\n        PlayerPrefs.Save();\n    }\n\n    // Event handlers for common game events\n    public void OnPlayerDeath()\n    {\n        IncrementStatistic(\"Deaths\");\n    }\n\n    public void OnEnemyKilled()\n    {\n        IncrementStatistic(\"Kills\");\n    }\n\n    public void OnItemCollected()\n    {\n        IncrementStatistic(\"ItemsCollected\");\n    }\n\n    public void OnJumpPerformed()\n    {\n        IncrementStatistic(\"JumpsPerformed\");\n    }\n\n    public void OnDistanceTraveled(float distance)\n    {\n        IncrementStatistic(\"DistanceTraveled\", distance);\n    }\n\n    public void OnDamageTaken(float damage)\n    {\n        IncrementStatistic(\"DamageTaken\", damage);\n    }\n\n    public void OnDamageDealt(float damage)\n    {\n        IncrementStatistic(\"DamageDealt\", damage);\n    }\n\n    public void OnScoreChanged(float newScore)\n    {\n        SetStatistic(\"Score\", newScore);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CountdownTimerDisplay\",\n  \"components\": [\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"countdownDuration\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"currentTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"timeFormat\",\n      \"type\": \"string\",\n      \"default\": \"mm:ss\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_countdown\",\n      \"trigger\": \"when countdown is started\",\n      \"actions\": [\n        {\n          \"action\": \"set current time to countdown duration\"\n        },\n        {\n          \"action\": \"activate the timer\"\n        },\n        {\n          \"action\": \"update display text with formatted time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_timer\",\n      \"trigger\": \"every frame while timer is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current time by frame time\"\n        },\n        {\n          \"action\": \"update display text with formatted current time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"timer_finished\",\n      \"trigger\": \"when current time reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"set current time to zero\"\n        },\n        {\n          \"action\": \"deactivate the timer\"\n        },\n        {\n          \"action\": \"display zero time on text\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pause_timer\",\n      \"trigger\": \"when pause is requested\",\n      \"actions\": [\n        {\n          \"action\": \"deactivate the timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"resume_timer\",\n      \"trigger\": \"when resume is requested\",\n      \"actions\": [\n        {\n          \"action\": \"activate the timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_timer\",\n      \"trigger\": \"when reset is requested\",\n      \"actions\": [\n        {\n          \"action\": \"set current time to countdown duration\"\n        },\n        {\n          \"action\": \"deactivate the timer\"\n        },\n        {\n          \"action\": \"update display text with formatted time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing TMPro;\n\npublic class CountdownTimer : MonoBehaviour\n{\n    [Header(\"Timer Settings\")]\n    [SerializeField] private float _startTime = 60f;\n    [SerializeField] private bool _startOnAwake = true;\n    [SerializeField] private bool _destroyOnComplete = false;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private TextMeshProUGUI _timerText;\n    [SerializeField] private Text _legacyTimerText;\n    [SerializeField] private string _timeFormat = \"mm:ss\";\n    [SerializeField] private string _completedText = \"TIME'S UP!\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private bool _enableWarningEffect = true;\n    [SerializeField] private float _warningThreshold = 10f;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _warningColor = Color.red;\n    [SerializeField] private float _blinkSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _tickSound;\n    [SerializeField] private AudioClip _warningSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private bool _playTickEverySecond = false;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnTimerStart;\n    public UnityEvent OnTimerComplete;\n    public UnityEvent OnWarningThreshold;\n    public UnityEvent<float> OnTimerUpdate;\n    \n    private float _currentTime;\n    private bool _isRunning = false;\n    private bool _isCompleted = false;\n    private bool _warningTriggered = false;\n    private float _lastSecond = -1f;\n    private bool _blinkState = false;\n    private float _blinkTimer = 0f;\n    \n    public float CurrentTime => _currentTime;\n    public float StartTime => _startTime;\n    public bool IsRunning => _isRunning;\n    public bool IsCompleted => _isCompleted;\n    public float Progress => _startTime > 0 ? 1f - (_currentTime / _startTime) : 1f;\n    \n    private void Awake()\n    {\n        _currentTime = _startTime;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_timerText == null)\n            _timerText = GetComponent<TextMeshProUGUI>();\n            \n        if (_legacyTimerText == null)\n            _legacyTimerText = GetComponent<Text>();\n    }\n    \n    private void Start()\n    {\n        UpdateDisplay();\n        \n        if (_startOnAwake)\n            StartTimer();\n    }\n    \n    private void Update()\n    {\n        if (!_isRunning || _isCompleted)\n            return;\n            \n        _currentTime -= Time.deltaTime;\n        \n        if (_currentTime <= 0f)\n        {\n            _currentTime = 0f;\n            CompleteTimer();\n        }\n        else\n        {\n            CheckWarningThreshold();\n            CheckTickSound();\n            UpdateBlinkEffect();\n        }\n        \n        UpdateDisplay();\n        OnTimerUpdate?.Invoke(_currentTime);\n    }\n    \n    public void StartTimer()\n    {\n        if (_isCompleted)\n            return;\n            \n        _isRunning = true;\n        OnTimerStart?.Invoke();\n    }\n    \n    public void PauseTimer()\n    {\n        _isRunning = false;\n    }\n    \n    public void ResumeTimer()\n    {\n        if (!_isCompleted)\n            _isRunning = true;\n    }\n    \n    public void StopTimer()\n    {\n        _isRunning = false;\n        _currentTime = _startTime;\n        _isCompleted = false;\n        _warningTriggered = false;\n        _lastSecond = -1f;\n        UpdateDisplay();\n        ResetVisualEffects();\n    }\n    \n    public void ResetTimer()\n    {\n        StopTimer();\n    }\n    \n    public void SetTime(float newTime)\n    {\n        _startTime = newTime;\n        if (!_isRunning)\n        {\n            _currentTime = _startTime;\n            UpdateDisplay();\n        }\n    }\n    \n    public void AddTime(float additionalTime)\n    {\n        _currentTime += additionalTime;\n        if (_currentTime > _startTime)\n            _currentTime = _startTime;\n    }\n    \n    private void CompleteTimer()\n    {\n        _isRunning = false;\n        _isCompleted = true;\n        \n        PlaySound(_completeSound);\n        OnTimerComplete?.Invoke();\n        \n        if (_destroyOnComplete)\n            Destroy(gameObject);\n    }\n    \n    private void CheckWarningThreshold()\n    {\n        if (!_warningTriggered && _currentTime <= _warningThreshold)\n        {\n            _warningTriggered = true;\n            PlaySound(_warningSound);\n            OnWarningThreshold?.Invoke();\n        }\n    }\n    \n    private void CheckTickSound()\n    {\n        if (!_playTickEverySecond)\n            return;\n            \n        float currentSecond = Mathf.Floor(_currentTime);\n        if (currentSecond != _lastSecond && currentSecond >= 0)\n        {\n            _lastSecond = currentSecond;\n            PlaySound(_tickSound);\n        }\n    }\n    \n    private void UpdateBlinkEffect()\n    {\n        if (!_enableWarningEffect || !_warningTriggered)\n            return;\n            \n        _blinkTimer += Time.deltaTime;\n        if (_blinkTimer >= 1f / _blinkSpeed)\n        {\n            _blinkState = !_blinkState;\n            _blinkTimer = 0f;\n        }\n    }\n    \n    private void UpdateDisplay()\n    {\n        string timeString = FormatTime(_currentTime);\n        \n        if (_isCompleted)\n            timeString = _completedText;\n            \n        if (_timerText != null)\n        {\n            _timerText.text = timeString;\n            _timerText.color = GetCurrentColor();\n        }\n        \n        if (_legacyTimerText != null)\n        {\n            _legacyTimerText.text = timeString;\n            _legacyTimerText.color = GetCurrentColor();\n        }\n    }\n    \n    private Color GetCurrentColor()\n    {\n        if (!_enableWarningEffect || !_warningTriggered)\n            return _normalColor;\n            \n        return _blinkState ? _warningColor : _normalColor;\n    }\n    \n    private void ResetVisualEffects()\n    {\n        _blinkState = false;\n        _blinkTimer = 0f;\n        \n        if (_timerText != null)\n            _timerText.color = _normalColor;\n            \n        if (_legacyTimerText != null)\n            _legacyTimerText.color = _normalColor;\n    }\n    \n    private string FormatTime(float timeInSeconds)\n    {\n        int minutes = Mathf.FloorToInt(timeInSeconds / 60f);\n        int seconds = Mathf.FloorToInt(timeInSeconds % 60f);\n        int milliseconds = Mathf.FloorToInt((timeInSeconds * 100f) % 100f);\n        \n        switch (_timeFormat.ToLower())\n        {\n            case \"mm:ss\":\n                return string.Format(\"{0:00}:{1:00}\", minutes, seconds);\n            case \"mm:ss.ff\":\n                return string.Format(\"{0:00}:{1:00}.{2:00}\", minutes, seconds, milliseconds);\n            case \"ss\":\n                return string.Format(\"{0:00}\", Mathf.FloorToInt(timeInSeconds));\n            case \"ss.ff\":\n                return string.Format(\"{0:00}.{1:00}\", Mathf.FloorToInt(timeInSeconds), milliseconds);\n            case \"m:ss\":\n                return string.Format(\"{0}:{1:00}\", minutes, seconds);\n            default:\n                return string.Format(\"{0:00}:{1:00}\", minutes, seconds);\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n    \n    private void OnValidate()\n    {\n        if (_startTime < 0f)\n            _startTime = 0f;\n            \n        if (_warningThreshold < 0f)\n            _warningThreshold = 0f;\n            \n        if (_blinkSpeed <= 0f)\n            _blinkSpeed = 1f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AudioVisualizer\",\n  \"components\": [\n    \"AudioSource\",\n    \"MeshRenderer\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"baseScale\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"scaleMultiplier\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"particleSpawnRate\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"particleSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"lowFrequencyThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"highFrequencyThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"scale_with_volume\",\n      \"trigger\": \"when audio volume changes\",\n      \"actions\": [\n        {\n          \"action\": \"increase object scale proportionally to current audio volume level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"color_shift_frequency\",\n      \"trigger\": \"when audio frequency data updates\",\n      \"actions\": [\n        {\n          \"action\": \"shift color to red when low frequencies dominate\"\n        },\n        {\n          \"action\": \"shift color to green when mid frequencies dominate\"\n        },\n        {\n          \"action\": \"shift color to blue when high frequencies dominate\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_with_waveform\",\n      \"trigger\": \"when audio waveform data changes\",\n      \"actions\": [\n        {\n          \"action\": \"rotate object based on audio waveform intensity and pattern\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spawn_beat_particles\",\n      \"trigger\": \"when audio beat is detected\",\n      \"actions\": [\n        {\n          \"action\": \"spawn particles from object center\"\n        },\n        {\n          \"action\": \"make particles move outward in all directions\"\n        },\n        {\n          \"action\": \"synchronize particle emission timing with detected beat\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\n[System.Serializable]\npublic class AudioVisualizerSettings\n{\n    [Header(\"Scale Settings\")]\n    public float baseScale = 1f;\n    public float scaleMultiplier = 2f;\n    public float scaleSmoothing = 5f;\n    \n    [Header(\"Color Settings\")]\n    public float colorSensitivity = 1f;\n    public float colorSmoothing = 3f;\n    \n    [Header(\"Rotation Settings\")]\n    public float rotationSpeed = 100f;\n    public Vector3 rotationAxis = Vector3.up;\n    \n    [Header(\"Particle Settings\")]\n    public int maxParticles = 50;\n    public float particleSpeed = 5f;\n    public float particleLifetime = 2f;\n    public float beatThreshold = 0.7f;\n    public float beatCooldown = 0.2f;\n}\n\npublic class AudioVisualizer : MonoBehaviour\n{\n    [Header(\"Audio Source\")]\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Visualization Settings\")]\n    [SerializeField] private AudioVisualizerSettings _settings = new AudioVisualizerSettings();\n    \n    [Header(\"Components\")]\n    [SerializeField] private Renderer _renderer;\n    [SerializeField] private ParticleSystem _particleSystem;\n    \n    [Header(\"Audio Analysis\")]\n    [SerializeField] private int _sampleSize = 1024;\n    [SerializeField] private FFTWindow _fftWindow = FFTWindow.Blackman;\n    \n    private float[] _audioSamples;\n    private float[] _frequencyBands;\n    private float _currentVolume;\n    private Color _targetColor;\n    private Color _currentColor;\n    private float _targetScale;\n    private float _currentScale;\n    private float _lastBeatTime;\n    private Material _material;\n    private Vector3 _baseScale;\n    private float _rotationAccumulator;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        InitializeAudioAnalysis();\n        InitializeVisualization();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_renderer == null)\n            _renderer = GetComponent<Renderer>();\n        \n        if (_particleSystem == null)\n            _particleSystem = GetComponent<ParticleSystem>();\n        \n        if (_audioSource == null)\n        {\n            Debug.LogError(\"AudioSource component required for AudioVisualizer\");\n            enabled = false;\n            return;\n        }\n        \n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _baseScale = transform.localScale;\n        }\n    }\n    \n    private void InitializeAudioAnalysis()\n    {\n        _audioSamples = new float[_sampleSize];\n        _frequencyBands = new float[3]; // Low, Mid, High\n        _currentScale = _settings.baseScale;\n        _targetScale = _settings.baseScale;\n        _currentColor = Color.white;\n        _targetColor = Color.white;\n    }\n    \n    private void InitializeVisualization()\n    {\n        if (_particleSystem != null)\n        {\n            var main = _particleSystem.main;\n            main.maxParticles = _settings.maxParticles;\n            main.startLifetime = _settings.particleLifetime;\n            main.startSpeed = _settings.particleSpeed;\n            \n            var emission = _particleSystem.emission;\n            emission.enabled = false;\n            \n            var shape = _particleSystem.shape;\n            shape.enabled = true;\n            shape.shapeType = ParticleSystemShapeType.Sphere;\n            shape.radius = 0.1f;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_audioSource == null || !_audioSource.isPlaying)\n            return;\n        \n        AnalyzeAudio();\n        UpdateScale();\n        UpdateColor();\n        UpdateRotation();\n        CheckForBeat();\n    }\n    \n    private void AnalyzeAudio()\n    {\n        _audioSource.GetSpectrumData(_audioSamples, 0, _fftWindow);\n        \n        // Calculate volume\n        float sum = 0f;\n        for (int i = 0; i < _audioSamples.Length; i++)\n        {\n            sum += _audioSamples[i] * _audioSamples[i];\n        }\n        _currentVolume = Mathf.Sqrt(sum / _audioSamples.Length);\n        \n        // Calculate frequency bands\n        CalculateFrequencyBands();\n    }\n    \n    private void CalculateFrequencyBands()\n    {\n        int count = 0;\n        \n        // Low frequencies (0-170 Hz approximately)\n        for (int i = 0; i < 8; i++)\n        {\n            _frequencyBands[0] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[0] /= count;\n        \n        count = 0;\n        // Mid frequencies (170-4000 Hz approximately)\n        for (int i = 8; i < 128; i++)\n        {\n            _frequencyBands[1] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[1] /= count;\n        \n        count = 0;\n        // High frequencies (4000+ Hz approximately)\n        for (int i = 128; i < _audioSamples.Length / 4; i++)\n        {\n            _frequencyBands[2] += _audioSamples[i];\n            count++;\n        }\n        if (count > 0) _frequencyBands[2] /= count;\n    }\n    \n    private void UpdateScale()\n    {\n        _targetScale = _settings.baseScale + (_currentVolume * _settings.scaleMultiplier);\n        _currentScale = Mathf.Lerp(_currentScale, _targetScale, Time.deltaTime * _settings.scaleSmoothing);\n        \n        if (_renderer != null)\n        {\n            transform.localScale = _baseScale * _currentScale;\n        }\n    }\n    \n    private void UpdateColor()\n    {\n        float red = _frequencyBands[0] * _settings.colorSensitivity;\n        float green = _frequencyBands[1] * _settings.colorSensitivity;\n        float blue = _frequencyBands[2] * _settings.colorSensitivity;\n        \n        _targetColor = new Color(red, green, blue, 1f);\n        _currentColor = Color.Lerp(_currentColor, _targetColor, Time.deltaTime * _settings.colorSmoothing);\n        \n        if (_material != null)\n        {\n            _material.color = _currentColor;\n        }\n    }\n    \n    private void UpdateRotation()\n    {\n        float waveformIntensity = 0f;\n        for (int i = 0; i < _audioSamples.Length; i += 10)\n        {\n            waveformIntensity += Mathf.Abs(_audioSamples[i]);\n        }\n        waveformIntensity /= (_audioSamples.Length / 10);\n        \n        _rotationAccumulator += waveformIntensity * _settings.rotationSpeed * Time.deltaTime;\n        transform.rotation = Quaternion.AngleAxis(_rotationAccumulator, _settings.rotationAxis);\n    }\n    \n    private void CheckForBeat()\n    {\n        if (_currentVolume > _settings.beatThreshold && \n            Time.time - _lastBeatTime > _settings.beatCooldown)\n        {\n            TriggerBeatEffect();\n            _lastBeatTime = Time.time;\n        }\n    }\n    \n    private void TriggerBeatEffect()\n    {\n        if (_particleSystem != null)\n        {\n            var emission = _particleSystem.emission;\n            emission.Emit(10);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_settings.baseScale <= 0f)\n            _settings.baseScale = 1f;\n        \n        if (_settings.scaleMultiplier < 0f)\n            _settings.scaleMultiplier = 0f;\n        \n        if (_settings.beatThreshold < 0f)\n            _settings.beatThreshold = 0f;\n        \n        if (_settings.beatThreshold > 1f)\n            _settings.beatThreshold = 1f;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_material != null && Application.isPlaying)\n        {\n            Destroy(_material);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MountableHorse\",\n  \"components\": [\n    \"Rigidbody\",\n    \"CapsuleCollider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"runSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"interactionRange\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isMounted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"mountedPlayer\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_mount_prompt\",\n      \"trigger\": \"when player is within interaction range and horse is not mounted\",\n      \"actions\": [\n        {\n          \"action\": \"display mount interaction prompt to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_mount_prompt\",\n      \"trigger\": \"when player moves away from interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"hide mount interaction prompt\"\n        }\n      ]\n    },\n    {\n      \"name\": \"mount_player\",\n      \"trigger\": \"when player presses interact key while near horse and horse is not mounted\",\n      \"actions\": [\n        {\n          \"action\": \"set horse as mounted\"\n        },\n        {\n          \"action\": \"attach player to horse saddle position\"\n        },\n        {\n          \"action\": \"disable player movement controls\"\n        },\n        {\n          \"action\": \"enable horse movement controls for player\"\n        },\n        {\n          \"action\": \"play mount animation\"\n        },\n        {\n          \"action\": \"hide interaction prompt\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dismount_player\",\n      \"trigger\": \"when player presses dismount key while mounted\",\n      \"actions\": [\n        {\n          \"action\": \"set horse as not mounted\"\n        },\n        {\n          \"action\": \"detach player from horse\"\n        },\n        {\n          \"action\": \"place player beside horse\"\n        },\n        {\n          \"action\": \"enable player movement controls\"\n        },\n        {\n          \"action\": \"disable horse movement controls\"\n        },\n        {\n          \"action\": \"play dismount animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"horse_walk\",\n      \"trigger\": \"when horse is mounted and player holds forward movement key\",\n      \"actions\": [\n        {\n          \"action\": \"move horse forward at walking speed\"\n        },\n        {\n          \"action\": \"play walking animation\"\n        },\n        {\n          \"action\": \"play walking sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"horse_run\",\n      \"trigger\": \"when horse is mounted and player holds run key with forward movement\",\n      \"actions\": [\n        {\n          \"action\": \"move horse forward at running speed\"\n        },\n        {\n          \"action\": \"play running animation\"\n        },\n        {\n          \"action\": \"play galloping sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"horse_turn\",\n      \"trigger\": \"when horse is mounted and player uses left or right movement keys\",\n      \"actions\": [\n        {\n          \"action\": \"rotate horse in the direction of input\"\n        },\n        {\n          \"action\": \"lean horse slightly in turn direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"horse_jump\",\n      \"trigger\": \"when horse is mounted and player presses jump key\",\n      \"actions\": [\n        {\n          \"action\": \"make horse jump upward with jump force\"\n        },\n        {\n          \"action\": \"play jumping animation\"\n        },\n        {\n          \"action\": \"play horse neigh sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_behavior\",\n      \"trigger\": \"when horse is not mounted and no player is nearby\",\n      \"actions\": [\n        {\n          \"action\": \"play idle animation\"\n        },\n        {\n          \"action\": \"occasionally look around\"\n        },\n        {\n          \"action\": \"occasionally make horse sounds\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MountableHorse : MonoBehaviour\n{\n    [Header(\"Horse Settings\")]\n    [SerializeField] private float _moveSpeed = 8f;\n    [SerializeField] private float _rotationSpeed = 120f;\n    [SerializeField] private float _jumpForce = 12f;\n    [SerializeField] private float _maxStamina = 100f;\n    [SerializeField] private float _staminaDrainRate = 20f;\n    [SerializeField] private float _staminaRegenRate = 15f;\n    \n    [Header(\"Mount Points\")]\n    [SerializeField] private Transform _mountPoint;\n    [SerializeField] private float _mountRange = 3f;\n    [SerializeField] private KeyCode _mountKey = KeyCode.E;\n    \n    [Header(\"Ground Check\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckRadius = 0.3f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _hoofstepSounds;\n    [SerializeField] private AudioClip _neighSound;\n    [SerializeField] private AudioClip _jumpSound;\n    [SerializeField] private float _hoofstepInterval = 0.5f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerMounted;\n    public UnityEvent OnPlayerDismounted;\n    public UnityEvent OnHorseJump;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Transform _mountedPlayer;\n    private bool _isPlayerMounted;\n    private float _currentStamina;\n    private bool _isGrounded;\n    private float _lastHoofstepTime;\n    private Vector3 _originalPlayerPosition;\n    private Transform _originalPlayerParent;\n    private bool _canMount = true;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_mountPoint == null)\n        {\n            GameObject mountPointObj = new GameObject(\"MountPoint\");\n            mountPointObj.transform.SetParent(transform);\n            mountPointObj.transform.localPosition = new Vector3(0, 1.5f, 0);\n            _mountPoint = mountPointObj.transform;\n        }\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheckObj = new GameObject(\"GroundCheck\");\n            groundCheckObj.transform.SetParent(transform);\n            groundCheckObj.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheckPoint = groundCheckObj.transform;\n        }\n    }\n    \n    private void Start()\n    {\n        _currentStamina = _maxStamina;\n        _rigidbody.freezeRotation = true;\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInput();\n        UpdateStamina();\n        CheckGrounded();\n        UpdateAnimations();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isPlayerMounted)\n        {\n            HandleMovement();\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_isPlayerMounted || !_canMount) return;\n        \n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _mountRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                ShowMountPrompt(true);\n                return;\n            }\n        }\n        \n        ShowMountPrompt(false);\n    }\n    \n    private void ShowMountPrompt(bool show)\n    {\n        // This would typically show UI prompt - for now just a debug message\n        if (show && !_isPlayerMounted)\n        {\n            Debug.Log($\"Press {_mountKey} to mount horse\");\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_mountKey))\n        {\n            if (!_isPlayerMounted)\n            {\n                TryMountPlayer();\n            }\n            else\n            {\n                DismountPlayer();\n            }\n        }\n        \n        if (_isPlayerMounted && Input.GetKeyDown(KeyCode.Space) && _isGrounded && _currentStamina > 20f)\n        {\n            Jump();\n        }\n    }\n    \n    private void TryMountPlayer()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _mountRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                MountPlayer(col.transform);\n                break;\n            }\n        }\n    }\n    \n    private void MountPlayer(Transform player)\n    {\n        _mountedPlayer = player;\n        _isPlayerMounted = true;\n        \n        // Store original player state\n        _originalPlayerPosition = player.position;\n        _originalPlayerParent = player.parent;\n        \n        // Attach player to mount point\n        player.SetParent(_mountPoint);\n        player.localPosition = Vector3.zero;\n        player.localRotation = Quaternion.identity;\n        \n        // Disable player's rigidbody and collider if they exist\n        Rigidbody playerRb = player.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.isKinematic = true;\n        }\n        \n        Collider playerCol = player.GetComponent<Collider>();\n        if (playerCol != null)\n        {\n            playerCol.enabled = false;\n        }\n        \n        PlaySound(_neighSound);\n        OnPlayerMounted?.Invoke();\n    }\n    \n    private void DismountPlayer()\n    {\n        if (!_isPlayerMounted || _mountedPlayer == null) return;\n        \n        // Find safe dismount position\n        Vector3 dismountPosition = FindSafeDismountPosition();\n        \n        // Restore player state\n        _mountedPlayer.SetParent(_originalPlayerParent);\n        _mountedPlayer.position = dismountPosition;\n        \n        // Re-enable player components\n        Rigidbody playerRb = _mountedPlayer.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            playerRb.isKinematic = false;\n        }\n        \n        Collider playerCol = _mountedPlayer.GetComponent<Collider>();\n        if (playerCol != null)\n        {\n            playerCol.enabled = true;\n        }\n        \n        _mountedPlayer = null;\n        _isPlayerMounted = false;\n        \n        OnPlayerDismounted?.Invoke();\n    }\n    \n    private Vector3 FindSafeDismountPosition()\n    {\n        Vector3[] directions = {\n            -transform.right,\n            transform.right,\n            -transform.forward,\n            transform.forward\n        };\n        \n        foreach (Vector3 direction in directions)\n        {\n            Vector3 testPosition = transform.position + direction * 2f;\n            \n            if (!Physics.CheckSphere(testPosition, 0.5f, _groundLayerMask))\n            {\n                return testPosition;\n            }\n        }\n        \n        return transform.position + Vector3.back * 2f;\n    }\n    \n    private void HandleMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        \n        if (Mathf.Abs(horizontal) > 0.1f || Mathf.Abs(vertical) > 0.1f)\n        {\n            // Movement\n            Vector3 movement = transform.forward * vertical * _moveSpeed;\n            _rigidbody.velocity = new Vector3(movement.x, _rigidbody.velocity.y, movement.z);\n            \n            // Rotation\n            transform.Rotate(0, horizontal * _rotationSpeed * Time.fixedDeltaTime, 0);\n            \n            // Drain stamina when running\n            if (Input.GetKey(KeyCode.LeftShift) && _currentStamina > 0)\n            {\n                _rigidbody.velocity = new Vector3(_rigidbody.velocity.x * 1.5f, _rigidbody.velocity.y, _rigidbody.velocity.z * 1.5f);\n                _currentStamina -= _staminaDrainRate * Time.fixedDeltaTime;\n            }\n            \n            PlayHoofstepSounds();\n        }\n    }\n    \n    private void Jump()\n    {\n        _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n        _currentStamina -= 20f;\n        PlaySound(_jumpSound);\n        OnHorseJump?.Invoke();\n    }\n    \n    private void UpdateStamina()\n    {\n        if (_currentStamina < _maxStamina)\n        {\n            _currentStamina += _staminaRegenRate * Time.deltaTime;\n            _currentStamina = Mathf.Clamp(_currentStamina, 0, _maxStamina);\n        }\n    }\n    \n    private void CheckGrounded()\n    {\n        _isGrounded = Physics.CheckSphere(_groundCheckPoint.position, _groundCheckRadius, _groundLayerMask);\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"IsGrounded\", _isGrounded);\n        _animator.SetBool(\"IsMounted\", _isPlayerMounted);\n    }\n    \n    private void PlayHoofstepSounds()\n    {\n        if (_hoofstepSounds.Length == 0 || Time.time - _lastHoofstepTime < _hoofstepInterval) return;\n        \n        AudioClip randomHoofstep = _hoofstepSounds[Random.Range(0, _hoofstepSounds.Length)];\n        PlaySound(randomHoofstep);\n        _lastHoofstepTime = Time.time;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw mount range\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _mountRange);\n        \n        // Draw ground check\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = _isGrounded ? Color.green : Color.red;\n            Gizmos.DrawWireSphere(_groundCheckPoint.position, _groundCheckRadius);\n        }\n    }\n    \n    public float GetStaminaPercentage()\n    {\n        return _currentStamina / _maxStamina;\n    }\n    \n    public bool IsPlayerMounted()\n    {\n        return _isPlayerMounted;\n    }\n    \n    public void SetCanMount(bool canMount)\n    {\n        _canMount = canMount;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CookingPot\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isLit\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"cookingTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"currentCookTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"isCooking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"maxIngredients\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"currentIngredients\",\n      \"type\": \"List<string>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"availableRecipes\",\n      \"type\": \"List<Recipe>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentRecipe\",\n      \"type\": \"Recipe\",\n      \"default\": null\n    },\n    {\n      \"name\": \"cookingSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"completeSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"light_pot\",\n      \"trigger\": \"when player interacts with pot and pot is not lit\",\n      \"actions\": [\n        {\n          \"action\": \"set pot to lit state\"\n        },\n        {\n          \"action\": \"enable fire particle effects\"\n        },\n        {\n          \"action\": \"play lighting sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"add_ingredient\",\n      \"trigger\": \"when player drops ingredient item into pot and pot is lit and not currently cooking\",\n      \"actions\": [\n        {\n          \"action\": \"add ingredient to current ingredients list\"\n        },\n        {\n          \"action\": \"destroy the ingredient item\"\n        },\n        {\n          \"action\": \"play ingredient splash sound\"\n        },\n        {\n          \"action\": \"check if current ingredients match any available recipe\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_cooking\",\n      \"trigger\": \"when ingredients match a valid recipe and pot is lit\",\n      \"actions\": [\n        {\n          \"action\": \"set cooking state to true\"\n        },\n        {\n          \"action\": \"store the matched recipe as current recipe\"\n        },\n        {\n          \"action\": \"reset cooking timer to zero\"\n        },\n        {\n          \"action\": \"play cooking sound on loop\"\n        },\n        {\n          \"action\": \"enable bubbling particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooking_progress\",\n      \"trigger\": \"when pot is cooking and fire is lit\",\n      \"actions\": [\n        {\n          \"action\": \"increase cooking timer\"\n        },\n        {\n          \"action\": \"update cooking progress visual indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_cooking\",\n      \"trigger\": \"when cooking timer reaches required cooking time\",\n      \"actions\": [\n        {\n          \"action\": \"set cooking state to false\"\n        },\n        {\n          \"action\": \"stop cooking sound\"\n        },\n        {\n          \"action\": \"disable bubbling effects\"\n        },\n        {\n          \"action\": \"spawn the completed recipe item\"\n        },\n        {\n          \"action\": \"clear current ingredients list\"\n        },\n        {\n          \"action\": \"clear current recipe\"\n        },\n        {\n          \"action\": \"play cooking complete sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"extinguish_fire\",\n      \"trigger\": \"when player pours water on lit pot\",\n      \"actions\": [\n        {\n          \"action\": \"set pot to unlit state\"\n        },\n        {\n          \"action\": \"disable fire particle effects\"\n        },\n        {\n          \"action\": \"stop all cooking processes\"\n        },\n        {\n          \"action\": \"play extinguishing steam sound\"\n        },\n        {\n          \"action\": \"enable steam particle effects briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_ingredients\",\n      \"trigger\": \"when player interacts with pot while ingredients are added but not cooking\",\n      \"actions\": [\n        {\n          \"action\": \"spawn ingredient items from current ingredients list\"\n        },\n        {\n          \"action\": \"clear current ingredients list\"\n        },\n        {\n          \"action\": \"play pouring out sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class CookingPot : MonoBehaviour\n{\n    [System.Serializable]\n    public class Ingredient\n    {\n        public string name;\n        public GameObject prefab;\n        public int quantity;\n        \n        public Ingredient(string itemName, GameObject itemPrefab, int itemQuantity = 1)\n        {\n            name = itemName;\n            prefab = itemPrefab;\n            quantity = itemQuantity;\n        }\n    }\n    \n    [System.Serializable]\n    public class Recipe\n    {\n        public string recipeName;\n        public List<Ingredient> requiredIngredients = new List<Ingredient>();\n        public GameObject resultPrefab;\n        public float cookingTime = 3f;\n        public string description;\n    }\n    \n    [Header(\"Cooking Configuration\")]\n    [SerializeField] private List<Recipe> _availableRecipes = new List<Recipe>();\n    [SerializeField] private Transform _ingredientDropZone;\n    [SerializeField] private Transform _resultSpawnPoint;\n    [SerializeField] private float _interactionRange = 2f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _cookingParticles;\n    [SerializeField] private ParticleSystem _completeParticles;\n    [SerializeField] private Animator _potAnimator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _cookingSound;\n    [SerializeField] private AudioClip _completeSound;\n    [SerializeField] private AudioClip _failSound;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _uiCanvas;\n    [SerializeField] private GameObject _recipePanel;\n    [SerializeField] private UnityEngine.UI.Text _statusText;\n    [SerializeField] private UnityEngine.UI.Button _cookButton;\n    [SerializeField] private UnityEngine.UI.Text _recipeListText;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnRecipeCompleted;\n    public UnityEvent OnCookingStarted;\n    public UnityEvent OnCookingFailed;\n    \n    private List<Ingredient> _currentIngredients = new List<Ingredient>();\n    private bool _isCooking = false;\n    private float _cookingTimer = 0f;\n    private Recipe _currentRecipe;\n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_cookButton != null)\n            _cookButton.onClick.AddListener(StartCooking);\n            \n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(false);\n            \n        UpdateUI();\n        DisplayAvailableRecipes();\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        HandleCooking();\n        UpdateUI();\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n        \n        if (_playerTransform != null)\n        {\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            bool wasInRange = _playerInRange;\n            _playerInRange = distance <= _interactionRange;\n            \n            if (_playerInRange && !wasInRange)\n            {\n                ShowUI();\n            }\n            else if (!_playerInRange && wasInRange)\n            {\n                HideUI();\n            }\n            \n            if (_playerInRange && Input.GetKeyDown(KeyCode.E) && !_isCooking)\n            {\n                ToggleRecipePanel();\n            }\n        }\n    }\n    \n    private void HandleCooking()\n    {\n        if (_isCooking)\n        {\n            _cookingTimer += Time.deltaTime;\n            \n            if (_cookingTimer >= _currentRecipe.cookingTime)\n            {\n                CompleteCooking();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Ingredient\") || other.CompareTag(\"Item\"))\n        {\n            AddIngredient(other.gameObject);\n        }\n    }\n    \n    private void AddIngredient(GameObject ingredientObject)\n    {\n        if (_isCooking) return;\n        \n        string ingredientName = ingredientObject.name.Replace(\"(Clone)\", \"\").Trim();\n        \n        Ingredient existingIngredient = _currentIngredients.Find(i => i.name == ingredientName);\n        if (existingIngredient != null)\n        {\n            existingIngredient.quantity++;\n        }\n        else\n        {\n            _currentIngredients.Add(new Ingredient(ingredientName, ingredientObject, 1));\n        }\n        \n        Destroy(ingredientObject);\n        UpdateUI();\n    }\n    \n    public void StartCooking()\n    {\n        if (_isCooking) return;\n        \n        Recipe matchedRecipe = FindMatchingRecipe();\n        if (matchedRecipe != null)\n        {\n            _currentRecipe = matchedRecipe;\n            _isCooking = true;\n            _cookingTimer = 0f;\n            \n            OnCookingStarted?.Invoke();\n            \n            if (_cookingParticles != null)\n                _cookingParticles.Play();\n                \n            if (_potAnimator != null)\n                _potAnimator.SetBool(\"IsCooking\", true);\n                \n            if (_audioSource != null && _cookingSound != null)\n                _audioSource.PlayOneShot(_cookingSound);\n        }\n        else\n        {\n            OnCookingFailed?.Invoke();\n            \n            if (_audioSource != null && _failSound != null)\n                _audioSource.PlayOneShot(_failSound);\n                \n            ClearIngredients();\n        }\n    }\n    \n    private Recipe FindMatchingRecipe()\n    {\n        foreach (Recipe recipe in _availableRecipes)\n        {\n            if (IngredientsMatch(recipe.requiredIngredients, _currentIngredients))\n            {\n                return recipe;\n            }\n        }\n        return null;\n    }\n    \n    private bool IngredientsMatch(List<Ingredient> required, List<Ingredient> current)\n    {\n        if (required.Count != current.Count) return false;\n        \n        foreach (Ingredient requiredIngredient in required)\n        {\n            Ingredient currentIngredient = current.Find(i => i.name == requiredIngredient.name);\n            if (currentIngredient == null || currentIngredient.quantity < requiredIngredient.quantity)\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private void CompleteCooking()\n    {\n        _isCooking = false;\n        \n        if (_cookingParticles != null)\n            _cookingParticles.Stop();\n            \n        if (_completeParticles != null)\n            _completeParticles.Play();\n            \n        if (_potAnimator != null)\n            _potAnimator.SetBool(\"IsCooking\", false);\n            \n        if (_audioSource != null && _completeSound != null)\n            _audioSource.PlayOneShot(_completeSound);\n        \n        SpawnResult();\n        OnRecipeCompleted?.Invoke(_currentRecipe.recipeName);\n        \n        ClearIngredients();\n        _currentRecipe = null;\n    }\n    \n    private void SpawnResult()\n    {\n        if (_currentRecipe.resultPrefab != null && _resultSpawnPoint != null)\n        {\n            Instantiate(_currentRecipe.resultPrefab, _resultSpawnPoint.position, _resultSpawnPoint.rotation);\n        }\n    }\n    \n    private void ClearIngredients()\n    {\n        _currentIngredients.Clear();\n        UpdateUI();\n    }\n    \n    private void ShowUI()\n    {\n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(true);\n    }\n    \n    private void HideUI()\n    {\n        if (_uiCanvas != null)\n            _uiCanvas.gameObject.SetActive(false);\n            \n        if (_recipePanel != null)\n            _recipePanel.SetActive(false);\n    }\n    \n    private void ToggleRecipePanel()\n    {\n        if (_recipePanel != null)\n            _recipePanel.SetActive(!_recipePanel.activeSelf);\n    }\n    \n    private void UpdateUI()\n    {\n        if (_statusText != null)\n        {\n            if (_isCooking)\n            {\n                float progress = _cookingTimer / _currentRecipe.cookingTime;\n                _statusText.text = $\"Cooking {_currentRecipe.recipeName}... {progress:P0}\";\n            }\n            else if (_currentIngredients.Count > 0)\n            {\n                _statusText.text = \"Ingredients added. Press Cook to start!\";\n            }\n            else\n            {\n                _statusText.text = \"Drop ingredients here. Press E for recipes.\";\n            }\n        }\n        \n        if (_cookButton != null)\n        {\n            _cookButton.interactable = !_isCooking && _currentIngredients.Count > 0;\n        }\n    }\n    \n    private void DisplayAvailableRecipes()\n    {\n        if (_recipeListText != null)\n        {\n            string recipeText = \"Available Recipes:\\n\\n\";\n            \n            foreach (Recipe recipe in _availableRecipes)\n            {\n                recipeText += $\"<b>{recipe.recipeName}</b>\\n\";\n                recipeText += $\"{recipe.description}\\n\";\n                recipeText += \"Ingredients:\\n\";\n                \n                foreach (Ingredient ingredient in recipe.requiredIngredients)\n                {\n                    recipeText += $\"- {ingredient.name} x{ingredient.quantity}\\n\";\n                }\n                \n                recipeText += $\"Cooking Time: {recipe.cookingTime}s\\n\\n\";\n            }\n            \n            _recipeListText.text = recipeText;\n        }\n    }\n    \n    public void AddRecipe(Recipe newRecipe)\n    {\n        if (!_availableRecipes.Contains(newRecipe))\n        {\n            _availableRecipes.Add(newRecipe);\n            DisplayAvailableRecipes();\n        }\n    }\n    \n    public void RemoveRecipe(string recipeName)\n    {\n        _availableRecipes.RemoveAll(r => r.recipeName == recipeName);\n        DisplayAvailableRecipes();\n    }\n    \n    public bool HasIngredient(string ingredientName)\n    {\n        return _currentIngredients.Exists(i => i.name == ingredientName);\n    }\n    \n    public int GetIngredientCount(string ingredientName)\n    {\n        Ingredient ingredient = _currentIngredients.Find(i => i.name == ingredientName);\n        return ingredient != null ? ingredient.quantity : 0;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_ingredientDropZone != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireCube(_ingredientDropZone.position, Vector3.one);\n        }\n        \n        if (_resultSpawnPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_resultSpawnPoint.position, 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InputPromptIcons\",\n  \"components\": [\n    \"Canvas\",\n    \"CanvasGroup\",\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"pulseSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"iconScale\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_prompt_icon\",\n      \"trigger\": \"when player enters interaction zone\",\n      \"actions\": [\n        {\n          \"action\": \"make icon visible\"\n        },\n        {\n          \"action\": \"fade icon in smoothly\"\n        },\n        {\n          \"action\": \"start pulsing animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_prompt_icon\",\n      \"trigger\": \"when player leaves interaction zone\",\n      \"actions\": [\n        {\n          \"action\": \"fade icon out smoothly\"\n        },\n        {\n          \"action\": \"stop pulsing animation\"\n        },\n        {\n          \"action\": \"make icon invisible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_animation\",\n      \"trigger\": \"continuously while icon is visible\",\n      \"actions\": [\n        {\n          \"action\": \"scale icon up and down rhythmically\"\n        },\n        {\n          \"action\": \"create breathing effect with size changes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_icon_type\",\n      \"trigger\": \"when interaction type changes\",\n      \"actions\": [\n        {\n          \"action\": \"switch to appropriate input icon sprite\"\n        },\n        {\n          \"action\": \"adjust icon size for new type\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.InputSystem;\nusing System.Collections.Generic;\n\npublic class InputPromptIcons : MonoBehaviour\n{\n    [System.Serializable]\n    public class InputPrompt\n    {\n        [Header(\"Input Configuration\")]\n        public string actionName;\n        public InputActionReference inputAction;\n        \n        [Header(\"Visual Elements\")]\n        public Image iconImage;\n        public Text promptText;\n        public GameObject promptContainer;\n        \n        [Header(\"Icon Sprites\")]\n        public Sprite keyboardSprite;\n        public Sprite gamepadSprite;\n        public Sprite mouseSprite;\n        \n        [Header(\"Settings\")]\n        public bool showOnlyWhenRelevant = true;\n        public float fadeSpeed = 2f;\n        \n        [HideInInspector]\n        public CanvasGroup canvasGroup;\n        [HideInInspector]\n        public bool isVisible;\n    }\n    \n    [Header(\"Input Prompts\")]\n    [SerializeField] private List<InputPrompt> _inputPrompts = new List<InputPrompt>();\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _deviceCheckInterval = 0.5f;\n    [SerializeField] private bool _autoDetectInputDevice = true;\n    [SerializeField] private bool _hideInactivePrompts = true;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _enableFadeAnimation = true;\n    [SerializeField] private float _defaultFadeSpeed = 3f;\n    [SerializeField] private AnimationCurve _fadeCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Layout Settings\")]\n    [SerializeField] private bool _autoArrangePrompts = true;\n    [SerializeField] private float _promptSpacing = 10f;\n    [SerializeField] private bool _useHorizontalLayout = true;\n    \n    private enum InputDeviceType\n    {\n        Keyboard,\n        Gamepad,\n        Mouse\n    }\n    \n    private InputDeviceType _currentDeviceType = InputDeviceType.Keyboard;\n    private float _lastDeviceCheckTime;\n    private Dictionary<string, InputPrompt> _promptLookup = new Dictionary<string, InputPrompt>();\n    \n    private void Start()\n    {\n        InitializePrompts();\n        SetupCanvasGroups();\n        \n        if (_autoDetectInputDevice)\n        {\n            DetectInputDevice();\n        }\n        \n        UpdateAllPrompts();\n        \n        if (_autoArrangePrompts)\n        {\n            ArrangePrompts();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_autoDetectInputDevice && Time.time - _lastDeviceCheckTime >= _deviceCheckInterval)\n        {\n            DetectInputDevice();\n            _lastDeviceCheckTime = Time.time;\n        }\n        \n        UpdatePromptVisibility();\n        HandleFadeAnimations();\n    }\n    \n    private void InitializePrompts()\n    {\n        _promptLookup.Clear();\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (!string.IsNullOrEmpty(prompt.actionName))\n            {\n                _promptLookup[prompt.actionName] = prompt;\n            }\n            \n            if (prompt.promptContainer != null && prompt.canvasGroup == null)\n            {\n                prompt.canvasGroup = prompt.promptContainer.GetComponent<CanvasGroup>();\n                if (prompt.canvasGroup == null)\n                {\n                    prompt.canvasGroup = prompt.promptContainer.AddComponent<CanvasGroup>();\n                }\n            }\n        }\n    }\n    \n    private void SetupCanvasGroups()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.canvasGroup != null)\n            {\n                prompt.canvasGroup.alpha = prompt.isVisible ? 1f : 0f;\n                prompt.canvasGroup.interactable = false;\n                prompt.canvasGroup.blocksRaycasts = false;\n            }\n        }\n    }\n    \n    private void DetectInputDevice()\n    {\n        InputDeviceType newDeviceType = _currentDeviceType;\n        \n        if (Gamepad.current != null && Gamepad.current.wasUpdatedThisFrame)\n        {\n            newDeviceType = InputDeviceType.Gamepad;\n        }\n        else if (Keyboard.current != null && Keyboard.current.anyKey.wasPressedThisFrame)\n        {\n            newDeviceType = InputDeviceType.Keyboard;\n        }\n        else if (Mouse.current != null && (Mouse.current.leftButton.wasPressedThisFrame || \n                 Mouse.current.rightButton.wasPressedThisFrame || Mouse.current.middleButton.wasPressedThisFrame))\n        {\n            newDeviceType = InputDeviceType.Mouse;\n        }\n        \n        if (newDeviceType != _currentDeviceType)\n        {\n            _currentDeviceType = newDeviceType;\n            UpdateAllPrompts();\n        }\n    }\n    \n    private void UpdateAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            UpdatePromptIcon(prompt);\n            UpdatePromptText(prompt);\n        }\n    }\n    \n    private void UpdatePromptIcon(InputPrompt prompt)\n    {\n        if (prompt.iconImage == null) return;\n        \n        Sprite targetSprite = null;\n        \n        switch (_currentDeviceType)\n        {\n            case InputDeviceType.Keyboard:\n                targetSprite = prompt.keyboardSprite;\n                break;\n            case InputDeviceType.Gamepad:\n                targetSprite = prompt.gamepadSprite;\n                break;\n            case InputDeviceType.Mouse:\n                targetSprite = prompt.mouseSprite;\n                break;\n        }\n        \n        if (targetSprite != null)\n        {\n            prompt.iconImage.sprite = targetSprite;\n            prompt.iconImage.gameObject.SetActive(true);\n        }\n        else\n        {\n            prompt.iconImage.gameObject.SetActive(false);\n        }\n    }\n    \n    private void UpdatePromptText(InputPrompt prompt)\n    {\n        if (prompt.promptText == null || prompt.inputAction == null) return;\n        \n        string bindingText = GetBindingDisplayString(prompt.inputAction);\n        prompt.promptText.text = bindingText;\n    }\n    \n    private string GetBindingDisplayString(InputActionReference actionRef)\n    {\n        if (actionRef == null || actionRef.action == null) return \"\";\n        \n        var action = actionRef.action;\n        int bindingIndex = GetBindingIndexForCurrentDevice(action);\n        \n        if (bindingIndex >= 0)\n        {\n            return action.GetBindingDisplayString(bindingIndex);\n        }\n        \n        return action.GetBindingDisplayString();\n    }\n    \n    private int GetBindingIndexForCurrentDevice(InputAction action)\n    {\n        for (int i = 0; i < action.bindings.Count; i++)\n        {\n            var binding = action.bindings[i];\n            \n            switch (_currentDeviceType)\n            {\n                case InputDeviceType.Keyboard:\n                    if (binding.path.Contains(\"Keyboard\"))\n                        return i;\n                    break;\n                case InputDeviceType.Gamepad:\n                    if (binding.path.Contains(\"Gamepad\"))\n                        return i;\n                    break;\n                case InputDeviceType.Mouse:\n                    if (binding.path.Contains(\"Mouse\"))\n                        return i;\n                    break;\n            }\n        }\n        \n        return -1;\n    }\n    \n    private void UpdatePromptVisibility()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            bool shouldBeVisible = ShouldPromptBeVisible(prompt);\n            \n            if (prompt.isVisible != shouldBeVisible)\n            {\n                prompt.isVisible = shouldBeVisible;\n            }\n        }\n    }\n    \n    private bool ShouldPromptBeVisible(InputPrompt prompt)\n    {\n        if (!prompt.showOnlyWhenRelevant) return true;\n        if (prompt.inputAction == null) return false;\n        \n        var action = prompt.inputAction.action;\n        if (action == null) return false;\n        \n        return action.enabled && HasValidBindingForCurrentDevice(action);\n    }\n    \n    private bool HasValidBindingForCurrentDevice(InputAction action)\n    {\n        return GetBindingIndexForCurrentDevice(action) >= 0;\n    }\n    \n    private void HandleFadeAnimations()\n    {\n        if (!_enableFadeAnimation) return;\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.canvasGroup == null) continue;\n            \n            float targetAlpha = prompt.isVisible ? 1f : 0f;\n            float fadeSpeed = prompt.fadeSpeed > 0 ? prompt.fadeSpeed : _defaultFadeSpeed;\n            \n            if (Mathf.Abs(prompt.canvasGroup.alpha - targetAlpha) > 0.01f)\n            {\n                float newAlpha = Mathf.MoveTowards(prompt.canvasGroup.alpha, targetAlpha, fadeSpeed * Time.deltaTime);\n                newAlpha = _fadeCurve.Evaluate(newAlpha);\n                prompt.canvasGroup.alpha = newAlpha;\n            }\n            \n            if (_hideInactivePrompts && prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(prompt.canvasGroup.alpha > 0.01f);\n            }\n        }\n    }\n    \n    private void ArrangePrompts()\n    {\n        Vector3 currentPosition = transform.position;\n        \n        foreach (var prompt in _inputPrompts)\n        {\n            if (prompt.promptContainer == null) continue;\n            \n            prompt.promptContainer.transform.position = currentPosition;\n            \n            if (_useHorizontalLayout)\n            {\n                RectTransform rectTransform = prompt.promptContainer.GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    currentPosition.x += rectTransform.rect.width + _promptSpacing;\n                }\n                else\n                {\n                    currentPosition.x += _promptSpacing;\n                }\n            }\n            else\n            {\n                RectTransform rectTransform = prompt.promptContainer.GetComponent<RectTransform>();\n                if (rectTransform != null)\n                {\n                    currentPosition.y -= rectTransform.rect.height + _promptSpacing;\n                }\n                else\n                {\n                    currentPosition.y -= _promptSpacing;\n                }\n            }\n        }\n    }\n    \n    public void ShowPrompt(string actionName)\n    {\n        if (_promptLookup.TryGetValue(actionName, out InputPrompt prompt))\n        {\n            prompt.isVisible = true;\n            if (prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(true);\n            }\n        }\n    }\n    \n    public void HidePrompt(string actionName)\n    {\n        if (_promptLookup.TryGetValue(actionName, out InputPrompt prompt))\n        {\n            prompt.isVisible = false;\n        }\n    }\n    \n    public void ShowAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            prompt.isVisible = true;\n            if (prompt.promptContainer != null)\n            {\n                prompt.promptContainer.SetActive(true);\n            }\n        }\n    }\n    \n    public void HideAllPrompts()\n    {\n        foreach (var prompt in _inputPrompts)\n        {\n            prompt.isVisible = false;\n        }\n    }\n    \n    public void SetDeviceType(int deviceType)\n    {\n        if (deviceType >= 0 && deviceType < System.Enum.GetValues(typeof(InputDeviceType)).Length)\n        {\n            _currentDeviceType = (InputDeviceType)deviceType;\n            UpdateAllPrompts();\n        }\n    }\n    \n    public void RefreshPrompts()\n    {\n        InitializePrompts();\n        UpdateAllPrompts();\n        \n        if (_autoArrangePrompts)\n        {\n            ArrangePrompts();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Fireplace\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"warmthRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"warmthStrength\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"fuelLevel\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"burnRate\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isLit\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"provide_warmth\",\n      \"trigger\": \"when player enters warmth zone\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase player temperature\"\n        },\n        {\n          \"action\": \"display warmth effect on screen\"\n        },\n        {\n          \"action\": \"play crackling fire sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_warmth\",\n      \"trigger\": \"when player exits warmth zone\",\n      \"actions\": [\n        {\n          \"action\": \"stop warming player\"\n        },\n        {\n          \"action\": \"fade out warmth effects\"\n        },\n        {\n          \"action\": \"reduce fire sound volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"consume_fuel\",\n      \"trigger\": \"continuously while fireplace is lit\",\n      \"actions\": [\n        {\n          \"action\": \"decrease fuel level over time\"\n        },\n        {\n          \"action\": \"reduce flame intensity as fuel decreases\"\n        }\n      ]\n    },\n    {\n      \"name\": \"extinguish_fire\",\n      \"trigger\": \"when fuel level reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"stop all flame particles\"\n        },\n        {\n          \"action\": \"stop fire sounds\"\n        },\n        {\n          \"action\": \"disable warmth zone\"\n        },\n        {\n          \"action\": \"set fireplace as unlit\"\n        }\n      ]\n    },\n    {\n      \"name\": \"relight_fireplace\",\n      \"trigger\": \"when player interacts with unlit fireplace and has fuel\",\n      \"actions\": [\n        {\n          \"action\": \"restart flame particles\"\n        },\n        {\n          \"action\": \"resume fire sounds\"\n        },\n        {\n          \"action\": \"reactivate warmth zone\"\n        },\n        {\n          \"action\": \"set fireplace as lit\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class Fireplace : MonoBehaviour\n{\n    [Header(\"Fire Settings\")]\n    [SerializeField] private GameObject fireEffect;\n    [SerializeField] private AudioSource fireAudioSource;\n    [SerializeField] private Light fireLight;\n    [SerializeField] private bool isLit = true;\n    [SerializeField] private float fuelDuration = 300f;\n    [SerializeField] private float currentFuel = 300f;\n    \n    [Header(\"Warmth Zone\")]\n    [SerializeField] private float warmthRadius = 5f;\n    [SerializeField] private float maxWarmthStrength = 100f;\n    [SerializeField] private float warmthFalloffRate = 2f;\n    [SerializeField] private LayerMask playerLayer = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private AnimationCurve flameSizeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private AnimationCurve lightIntensityCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private float baseFireScale = 1f;\n    [SerializeField] private float baseLightIntensity = 2f;\n    [SerializeField] private Color warmLightColor = Color.yellow;\n    [SerializeField] private Color coolLightColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] cracklingSounds;\n    [SerializeField] private float crackleInterval = 3f;\n    [SerializeField] private float baseVolume = 0.5f;\n    \n    [Header(\"Fuel System\")]\n    [SerializeField] private bool requiresFuel = true;\n    [SerializeField] private string fuelTag = \"Wood\";\n    [SerializeField] private float fuelAddAmount = 60f;\n    [SerializeField] private float interactionRange = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFireLit;\n    public UnityEvent OnFireExtinguished;\n    public UnityEvent OnPlayerEnterWarmth;\n    public UnityEvent OnPlayerExitWarmth;\n    \n    private List<GameObject> _playersInWarmth = new List<GameObject>();\n    private float _crackleTimer;\n    private bool _playerNearby;\n    private Vector3 _originalFireScale;\n    private float _originalLightIntensity;\n    \n    [System.Serializable]\n    public class WarmthData\n    {\n        public GameObject player;\n        public float warmthLevel;\n        public float timeInWarmth;\n        \n        public WarmthData(GameObject p)\n        {\n            player = p;\n            warmthLevel = 0f;\n            timeInWarmth = 0f;\n        }\n    }\n    \n    private List<WarmthData> _warmthDataList = new List<WarmthData>();\n    \n    void Start()\n    {\n        InitializeFireplace();\n        SetupComponents();\n    }\n    \n    void Update()\n    {\n        if (requiresFuel && isLit)\n        {\n            ConsumeFuel();\n        }\n        \n        UpdateFireEffects();\n        UpdateWarmthZone();\n        HandleAudio();\n        CheckForPlayerInteraction();\n    }\n    \n    void InitializeFireplace()\n    {\n        if (fireEffect != null)\n        {\n            _originalFireScale = fireEffect.transform.localScale;\n        }\n        \n        if (fireLight != null)\n        {\n            _originalLightIntensity = fireLight.intensity;\n        }\n        \n        currentFuel = Mathf.Clamp(currentFuel, 0f, fuelDuration);\n        \n        if (currentFuel <= 0f)\n        {\n            ExtinguishFire();\n        }\n    }\n    \n    void SetupComponents()\n    {\n        if (fireAudioSource == null)\n        {\n            fireAudioSource = GetComponent<AudioSource>();\n            if (fireAudioSource == null)\n            {\n                fireAudioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (fireAudioSource != null)\n        {\n            fireAudioSource.loop = true;\n            fireAudioSource.volume = baseVolume;\n        }\n    }\n    \n    void ConsumeFuel()\n    {\n        currentFuel -= Time.deltaTime;\n        currentFuel = Mathf.Max(0f, currentFuel);\n        \n        if (currentFuel <= 0f && isLit)\n        {\n            ExtinguishFire();\n        }\n    }\n    \n    void UpdateFireEffects()\n    {\n        float fuelPercentage = requiresFuel ? (currentFuel / fuelDuration) : 1f;\n        \n        if (fireEffect != null)\n        {\n            fireEffect.SetActive(isLit);\n            if (isLit)\n            {\n                float scaleMultiplier = flameSizeCurve.Evaluate(fuelPercentage);\n                fireEffect.transform.localScale = _originalFireScale * scaleMultiplier * baseFireScale;\n            }\n        }\n        \n        if (fireLight != null)\n        {\n            fireLight.enabled = isLit;\n            if (isLit)\n            {\n                float intensityMultiplier = lightIntensityCurve.Evaluate(fuelPercentage);\n                fireLight.intensity = _originalLightIntensity * intensityMultiplier * baseLightIntensity;\n                fireLight.color = Color.Lerp(coolLightColor, warmLightColor, fuelPercentage);\n                \n                // Add flickering effect\n                fireLight.intensity += Mathf.Sin(Time.time * 10f) * 0.1f * intensityMultiplier;\n            }\n        }\n    }\n    \n    void UpdateWarmthZone()\n    {\n        if (!isLit) return;\n        \n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, warmthRadius, playerLayer);\n        \n        // Remove players who left the warmth zone\n        for (int i = _warmthDataList.Count - 1; i >= 0; i--)\n        {\n            bool stillInRange = false;\n            foreach (var collider in playersInRange)\n            {\n                if (collider.gameObject == _warmthDataList[i].player)\n                {\n                    stillInRange = true;\n                    break;\n                }\n            }\n            \n            if (!stillInRange)\n            {\n                OnPlayerExitWarmth.Invoke();\n                _warmthDataList.RemoveAt(i);\n            }\n        }\n        \n        // Add new players and update existing ones\n        foreach (var collider in playersInRange)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                WarmthData existingData = _warmthDataList.Find(w => w.player == collider.gameObject);\n                \n                if (existingData == null)\n                {\n                    _warmthDataList.Add(new WarmthData(collider.gameObject));\n                    OnPlayerEnterWarmth.Invoke();\n                }\n                else\n                {\n                    UpdatePlayerWarmth(existingData, collider.gameObject);\n                }\n            }\n        }\n    }\n    \n    void UpdatePlayerWarmth(WarmthData warmthData, GameObject player)\n    {\n        float distance = Vector3.Distance(transform.position, player.transform.position);\n        float warmthStrength = Mathf.Clamp01(1f - (distance / warmthRadius));\n        warmthStrength = Mathf.Pow(warmthStrength, warmthFalloffRate);\n        \n        warmthData.warmthLevel = warmthStrength * maxWarmthStrength;\n        warmthData.timeInWarmth += Time.deltaTime;\n        \n        // Apply warmth effect to player (you can extend this based on your needs)\n        ApplyWarmthToPlayer(player, warmthData.warmthLevel);\n    }\n    \n    void ApplyWarmthToPlayer(GameObject player, float warmthLevel)\n    {\n        // Send message to player about warmth level\n        player.SendMessage(\"ReceiveWarmth\", warmthLevel, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    void HandleAudio()\n    {\n        if (fireAudioSource == null) return;\n        \n        if (isLit)\n        {\n            float fuelPercentage = requiresFuel ? (currentFuel / fuelDuration) : 1f;\n            fireAudioSource.volume = baseVolume * fuelPercentage;\n            \n            _crackleTimer -= Time.deltaTime;\n            if (_crackleTimer <= 0f && cracklingSounds.Length > 0)\n            {\n                AudioClip randomCrackle = cracklingSounds[Random.Range(0, cracklingSounds.Length)];\n                AudioSource.PlayClipAtPoint(randomCrackle, transform.position, baseVolume * fuelPercentage);\n                _crackleTimer = crackleInterval + Random.Range(-1f, 1f);\n            }\n        }\n        else\n        {\n            fireAudioSource.volume = 0f;\n        }\n    }\n    \n    void CheckForPlayerInteraction()\n    {\n        bool playerWasNearby = _playerNearby;\n        _playerNearby = false;\n        \n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, interactionRange);\n        foreach (var collider in nearbyObjects)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                _playerNearby = true;\n                \n                if (Input.GetKeyDown(KeyCode.E))\n                {\n                    TryAddFuel(collider.gameObject);\n                }\n                break;\n            }\n        }\n    }\n    \n    void TryAddFuel(GameObject player)\n    {\n        if (!requiresFuel) return;\n        \n        // Look for fuel in player's vicinity or inventory\n        Collider[] nearbyItems = Physics.OverlapSphere(player.transform.position, 2f);\n        foreach (var item in nearbyItems)\n        {\n            if (item.CompareTag(fuelTag))\n            {\n                AddFuel();\n                Destroy(item.gameObject);\n                break;\n            }\n        }\n    }\n    \n    public void AddFuel()\n    {\n        currentFuel = Mathf.Min(currentFuel + fuelAddAmount, fuelDuration);\n        \n        if (!isLit && currentFuel > 0f)\n        {\n            LightFire();\n        }\n    }\n    \n    public void LightFire()\n    {\n        if (requiresFuel && currentFuel <= 0f) return;\n        \n        isLit = true;\n        OnFireLit.Invoke();\n    }\n    \n    public void ExtinguishFire()\n    {\n        isLit = false;\n        OnFireExtinguished.Invoke();\n        \n        // Clear warmth data\n        _warmthDataList.Clear();\n    }\n    \n    public float GetWarmthAtPosition(Vector3 position)\n    {\n        if (!isLit) return 0f;\n        \n        float distance = Vector3.Distance(transform.position, position);\n        if (distance > warmthRadius) return 0f;\n        \n        float warmthStrength = Mathf.Clamp01(1f - (distance / warmthRadius));\n        return Mathf.Pow(warmthStrength, warmthFalloffRate) * maxWarmthStrength;\n    }\n    \n    public bool IsPlayerInWarmth(GameObject player)\n    {\n        return _warmthDataList.Exists(w => w.player == player);\n    }\n    \n    public float GetFuelPercentage()\n    {\n        return requiresFuel ? (currentFuel / fuelDuration) : 1f;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        // Draw warmth radius\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, warmthRadius);\n        \n        // Draw interaction range\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, interactionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StealthCrouch\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"crouchSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"standSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"visibilityLevel\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"maxVisibility\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"visibilityDecreaseRate\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"visibilityIncreaseRate\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"isCrouching\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"crouchHeight\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"standHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_crouch\",\n      \"trigger\": \"when crouch input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set crouching state to true\"\n        },\n        {\n          \"action\": \"reduce character height to crouch height\"\n        },\n        {\n          \"action\": \"change movement speed to crouch speed\"\n        },\n        {\n          \"action\": \"play crouch animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_crouch\",\n      \"trigger\": \"when crouch input is released\",\n      \"actions\": [\n        {\n          \"action\": \"set crouching state to false\"\n        },\n        {\n          \"action\": \"restore character height to stand height\"\n        },\n        {\n          \"action\": \"change movement speed to stand speed\"\n        },\n        {\n          \"action\": \"play stand animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decrease_visibility_while_crouching\",\n      \"trigger\": \"when crouching and moving slowly\",\n      \"actions\": [\n        {\n          \"action\": \"decrease visibility level over time\"\n        },\n        {\n          \"action\": \"clamp visibility level to minimum zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"increase_visibility_while_standing\",\n      \"trigger\": \"when standing or moving quickly\",\n      \"actions\": [\n        {\n          \"action\": \"increase visibility level over time\"\n        },\n        {\n          \"action\": \"clamp visibility level to maximum value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_visibility_meter\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"update visibility meter display based on current visibility level\"\n        },\n        {\n          \"action\": \"change meter color based on visibility threshold\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class StealthCrouchSystem : MonoBehaviour\n{\n    [Header(\"Crouch Settings\")]\n    [SerializeField] private KeyCode _crouchKey = KeyCode.LeftControl;\n    [SerializeField] private float _crouchHeight = 1f;\n    [SerializeField] private float _standHeight = 2f;\n    [SerializeField] private float _crouchSpeed = 2f;\n    [SerializeField] private float _standSpeed = 5f;\n    [SerializeField] private float _heightTransitionSpeed = 8f;\n    \n    [Header(\"Visibility Settings\")]\n    [SerializeField] private float _maxVisibility = 100f;\n    [SerializeField] private float _visibilityDecreaseRate = 20f;\n    [SerializeField] private float _visibilityIncreaseRate = 30f;\n    [SerializeField] private float _crouchVisibilityMultiplier = 0.3f;\n    [SerializeField] private float _movementVisibilityMultiplier = 1.5f;\n    [SerializeField] private float _detectionRange = 10f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Slider _visibilityMeter;\n    [SerializeField] private Image _visibilityFill;\n    [SerializeField] private Color _lowVisibilityColor = Color.green;\n    [SerializeField] private Color _highVisibilityColor = Color.red;\n    [SerializeField] private Canvas _stealthUI;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _crouchSound;\n    [SerializeField] private AudioClip _standSound;\n    \n    private CharacterController _characterController;\n    private Camera _playerCamera;\n    private bool _isCrouching;\n    private float _currentVisibility;\n    private float _targetHeight;\n    private Vector3 _lastPosition;\n    private List<Transform> _nearbyEnemies = new List<Transform>();\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _playerCamera = GetComponentInChildren<Camera>();\n        \n        if (_characterController == null)\n        {\n            _characterController = gameObject.AddComponent<CharacterController>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _targetHeight = _standHeight;\n        _characterController.height = _standHeight;\n        _currentVisibility = 0f;\n        _lastPosition = transform.position;\n        \n        SetupUI();\n    }\n    \n    private void Update()\n    {\n        HandleCrouchInput();\n        UpdateHeight();\n        UpdateVisibility();\n        UpdateUI();\n        FindNearbyEnemies();\n    }\n    \n    private void HandleCrouchInput()\n    {\n        bool crouchPressed = Input.GetKey(_crouchKey);\n        \n        if (crouchPressed && !_isCrouching)\n        {\n            StartCrouch();\n        }\n        else if (!crouchPressed && _isCrouching)\n        {\n            StopCrouch();\n        }\n    }\n    \n    private void StartCrouch()\n    {\n        _isCrouching = true;\n        _targetHeight = _crouchHeight;\n        \n        if (_audioSource && _crouchSound)\n        {\n            _audioSource.PlayOneShot(_crouchSound);\n        }\n    }\n    \n    private void StopCrouch()\n    {\n        if (CanStandUp())\n        {\n            _isCrouching = false;\n            _targetHeight = _standHeight;\n            \n            if (_audioSource && _standSound)\n            {\n                _audioSource.PlayOneShot(_standSound);\n            }\n        }\n    }\n    \n    private bool CanStandUp()\n    {\n        float checkHeight = _standHeight - _crouchHeight;\n        Vector3 checkStart = transform.position + Vector3.up * _crouchHeight;\n        \n        return !Physics.SphereCast(checkStart, _characterController.radius, Vector3.up, out RaycastHit hit, checkHeight);\n    }\n    \n    private void UpdateHeight()\n    {\n        float currentHeight = _characterController.height;\n        float newHeight = Mathf.MoveTowards(currentHeight, _targetHeight, _heightTransitionSpeed * Time.deltaTime);\n        \n        if (Mathf.Abs(newHeight - currentHeight) > 0.01f)\n        {\n            Vector3 centerOffset = Vector3.up * (newHeight - currentHeight) * 0.5f;\n            _characterController.height = newHeight;\n            _characterController.center = Vector3.up * newHeight * 0.5f;\n            \n            if (_playerCamera)\n            {\n                Vector3 cameraPos = _playerCamera.transform.localPosition;\n                cameraPos.y += (newHeight - currentHeight) * 0.8f;\n                _playerCamera.transform.localPosition = cameraPos;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        float visibilityChange = 0f;\n        bool isMoving = Vector3.Distance(transform.position, _lastPosition) > 0.01f;\n        bool isInEnemySight = IsInEnemySight();\n        \n        if (isInEnemySight)\n        {\n            visibilityChange = _visibilityIncreaseRate;\n            \n            if (_isCrouching)\n            {\n                visibilityChange *= _crouchVisibilityMultiplier;\n            }\n            \n            if (isMoving)\n            {\n                visibilityChange *= _movementVisibilityMultiplier;\n            }\n        }\n        else\n        {\n            visibilityChange = -_visibilityDecreaseRate;\n        }\n        \n        _currentVisibility = Mathf.Clamp(_currentVisibility + visibilityChange * Time.deltaTime, 0f, _maxVisibility);\n        _lastPosition = transform.position;\n    }\n    \n    private bool IsInEnemySight()\n    {\n        foreach (Transform enemy in _nearbyEnemies)\n        {\n            if (enemy == null) continue;\n            \n            Vector3 directionToPlayer = (transform.position - enemy.position).normalized;\n            float distanceToPlayer = Vector3.Distance(transform.position, enemy.position);\n            \n            if (distanceToPlayer <= _detectionRange)\n            {\n                if (Physics.Raycast(enemy.position, directionToPlayer, out RaycastHit hit, distanceToPlayer))\n                {\n                    if (hit.transform == transform)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private void FindNearbyEnemies()\n    {\n        _nearbyEnemies.Clear();\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _detectionRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Enemy\") && col.transform != transform)\n            {\n                _nearbyEnemies.Add(col.transform);\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_visibilityMeter)\n        {\n            _visibilityMeter.value = _currentVisibility / _maxVisibility;\n        }\n        \n        if (_visibilityFill)\n        {\n            float normalizedVisibility = _currentVisibility / _maxVisibility;\n            _visibilityFill.color = Color.Lerp(_lowVisibilityColor, _highVisibilityColor, normalizedVisibility);\n        }\n        \n        if (_stealthUI)\n        {\n            _stealthUI.gameObject.SetActive(_nearbyEnemies.Count > 0);\n        }\n    }\n    \n    private void SetupUI()\n    {\n        if (_visibilityMeter == null && _stealthUI != null)\n        {\n            _visibilityMeter = _stealthUI.GetComponentInChildren<Slider>();\n        }\n        \n        if (_visibilityFill == null && _visibilityMeter != null)\n        {\n            _visibilityFill = _visibilityMeter.fillRect.GetComponent<Image>();\n        }\n    }\n    \n    public bool IsCrouching()\n    {\n        return _isCrouching;\n    }\n    \n    public float GetVisibilityPercentage()\n    {\n        return _currentVisibility / _maxVisibility;\n    }\n    \n    public bool IsDetected()\n    {\n        return _currentVisibility >= _maxVisibility;\n    }\n    \n    public float GetMovementSpeed()\n    {\n        return _isCrouching ? _crouchSpeed : _standSpeed;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_isCrouching)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireCube(transform.position + Vector3.up * _crouchHeight * 0.5f, \n                new Vector3(1f, _crouchHeight, 1f));\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ScreenShakeOnImpact\",\n  \"components\": [\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"shakeIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"shakeDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"shakeFrequency\",\n      \"type\": \"float\",\n      \"default\": 20.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_screen_shake\",\n      \"trigger\": \"when collision occurs with any object\",\n      \"actions\": [\n        {\n          \"action\": \"start camera shake with specified intensity and duration\"\n        },\n        {\n          \"action\": \"apply random displacement to camera position based on shake frequency\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_shake_effect\",\n      \"trigger\": \"while screen shake is active\",\n      \"actions\": [\n        {\n          \"action\": \"generate random offset values for camera position\"\n        },\n        {\n          \"action\": \"gradually reduce shake intensity over time\"\n        },\n        {\n          \"action\": \"apply shake offset to camera transform\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_screen_shake\",\n      \"trigger\": \"when shake duration has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying shake effects\"\n        },\n        {\n          \"action\": \"return camera to original position\"\n        },\n        {\n          \"action\": \"reset shake parameters\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class ScreenShake : MonoBehaviour\n{\n    [Header(\"Shake Settings\")]\n    [SerializeField] private float _shakeDuration = 0.5f;\n    [SerializeField] private float _shakeIntensity = 1.0f;\n    [SerializeField] private AnimationCurve _shakeCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);\n    \n    [Header(\"Impact Detection\")]\n    [SerializeField] private bool _shakeOnCollision = true;\n    [SerializeField] private bool _shakeOnTrigger = false;\n    [SerializeField] private string[] _impactTags = { \"Player\", \"Enemy\", \"Projectile\" };\n    [SerializeField] private float _minimumImpactForce = 5.0f;\n    \n    [Header(\"Manual Shake\")]\n    [SerializeField] private KeyCode _testShakeKey = KeyCode.Space;\n    \n    private Vector3 _originalPosition;\n    private bool _isShaking = false;\n    private Camera _camera;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n            _camera = Camera.main;\n            \n        _rigidbody = GetComponent<Rigidbody>();\n        \n        if (_camera != null)\n            _originalPosition = _camera.transform.localPosition;\n        else\n            _originalPosition = transform.localPosition;\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_testShakeKey))\n        {\n            TriggerShake(_shakeIntensity, _shakeDuration);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_shakeOnCollision) return;\n        \n        if (ShouldShakeFromImpact(collision.gameObject, collision.relativeVelocity.magnitude))\n        {\n            float intensity = Mathf.Clamp(collision.relativeVelocity.magnitude / 10f, 0.1f, _shakeIntensity);\n            TriggerShake(intensity, _shakeDuration);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_shakeOnTrigger) return;\n        \n        float impactForce = _minimumImpactForce;\n        Rigidbody otherRb = other.GetComponent<Rigidbody>();\n        if (otherRb != null)\n            impactForce = otherRb.velocity.magnitude;\n            \n        if (ShouldShakeFromImpact(other.gameObject, impactForce))\n        {\n            float intensity = Mathf.Clamp(impactForce / 10f, 0.1f, _shakeIntensity);\n            TriggerShake(intensity, _shakeDuration);\n        }\n    }\n    \n    private bool ShouldShakeFromImpact(GameObject impactObject, float force)\n    {\n        if (force < _minimumImpactForce) return false;\n        \n        if (_impactTags.Length == 0) return true;\n        \n        foreach (string tag in _impactTags)\n        {\n            if (impactObject.CompareTag(tag))\n                return true;\n        }\n        \n        return false;\n    }\n    \n    public void TriggerShake(float intensity, float duration)\n    {\n        if (_isShaking) return;\n        \n        StartCoroutine(ShakeCoroutine(intensity, duration));\n    }\n    \n    public void TriggerShake()\n    {\n        TriggerShake(_shakeIntensity, _shakeDuration);\n    }\n    \n    private IEnumerator ShakeCoroutine(float intensity, float duration)\n    {\n        _isShaking = true;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float progress = elapsed / duration;\n            float currentIntensity = intensity * _shakeCurve.Evaluate(progress);\n            \n            Vector3 randomOffset = new Vector3(\n                Random.Range(-1f, 1f),\n                Random.Range(-1f, 1f),\n                0f\n            ) * currentIntensity;\n            \n            if (_camera != null)\n                _camera.transform.localPosition = _originalPosition + randomOffset;\n            else\n                transform.localPosition = _originalPosition + randomOffset;\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        if (_camera != null)\n            _camera.transform.localPosition = _originalPosition;\n        else\n            transform.localPosition = _originalPosition;\n            \n        _isShaking = false;\n    }\n    \n    private void OnDisable()\n    {\n        StopAllCoroutines();\n        \n        if (_camera != null)\n            _camera.transform.localPosition = _originalPosition;\n        else\n            transform.localPosition = _originalPosition;\n            \n        _isShaking = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldBlock\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"shieldHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"maxShieldHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"shieldRegenRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"shieldRegenDelay\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isShieldActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"absorb_damage\",\n      \"trigger\": \"when projectile or attack hits this block\",\n      \"actions\": [\n        {\n          \"action\": \"reduce shield health by damage amount\"\n        },\n        {\n          \"action\": \"create shield impact visual effect at hit point\"\n        },\n        {\n          \"action\": \"play shield hit sound\"\n        },\n        {\n          \"action\": \"prevent damage from passing through to block\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_break\",\n      \"trigger\": \"when shield health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"deactivate shield protection\"\n        },\n        {\n          \"action\": \"change block material to damaged appearance\"\n        },\n        {\n          \"action\": \"play shield break sound and particle effect\"\n        },\n        {\n          \"action\": \"start shield regeneration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_shield\",\n      \"trigger\": \"when shield regeneration delay time has passed and shield is broken\",\n      \"actions\": [\n        {\n          \"action\": \"gradually restore shield health over time\"\n        },\n        {\n          \"action\": \"play shield charging sound\"\n        },\n        {\n          \"action\": \"show shield regeneration visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reactivate_shield\",\n      \"trigger\": \"when shield health is fully restored\",\n      \"actions\": [\n        {\n          \"action\": \"activate shield protection\"\n        },\n        {\n          \"action\": \"restore block material to normal appearance\"\n        },\n        {\n          \"action\": \"play shield activation sound\"\n        },\n        {\n          \"action\": \"show shield reactivation glow effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ShieldBlock : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _shieldHealth = 100f;\n    [SerializeField] private float _maxShieldHealth = 100f;\n    [SerializeField] private float _regenRate = 10f;\n    [SerializeField] private float _regenDelay = 2f;\n    [SerializeField] private bool _canRegenerate = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldEffect;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _damagedMaterial;\n    [SerializeField] private Color _shieldColor = Color.blue;\n    [SerializeField] private AnimationCurve _damageFeedbackCurve = AnimationCurve.EaseInOut(0f, 1f, 0.3f, 0f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _breakSound;\n    [SerializeField] private AudioClip _regenSound;\n    [SerializeField] private float _audioVolume = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnShieldHit;\n    public UnityEvent OnShieldBroken;\n    public UnityEvent OnShieldRestored;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private float _lastDamageTime;\n    private bool _isShieldActive = true;\n    private float _damageEffectTime;\n    private Color _originalColor;\n    private bool _isRegenerating;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        SetupShield();\n    }\n    \n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.volume = _audioVolume;\n        _audioSource.playOnAwake = false;\n        \n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n    }\n    \n    private void SetupShield()\n    {\n        _shieldHealth = _maxShieldHealth;\n        UpdateShieldVisuals();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(_isShieldActive);\n        }\n    }\n    \n    private void Update()\n    {\n        HandleShieldRegeneration();\n        HandleDamageEffect();\n    }\n    \n    private void HandleShieldRegeneration()\n    {\n        if (!_canRegenerate || _isShieldActive) return;\n        \n        if (Time.time - _lastDamageTime >= _regenDelay)\n        {\n            if (!_isRegenerating)\n            {\n                _isRegenerating = true;\n                PlaySound(_regenSound);\n            }\n            \n            _shieldHealth += _regenRate * Time.deltaTime;\n            _shieldHealth = Mathf.Clamp(_shieldHealth, 0f, _maxShieldHealth);\n            \n            if (_shieldHealth >= _maxShieldHealth)\n            {\n                RestoreShield();\n            }\n            \n            UpdateShieldVisuals();\n        }\n    }\n    \n    private void HandleDamageEffect()\n    {\n        if (_damageEffectTime > 0f)\n        {\n            _damageEffectTime -= Time.deltaTime;\n            \n            if (_renderer != null && _damagedMaterial != null)\n            {\n                float effectStrength = _damageFeedbackCurve.Evaluate(1f - (_damageEffectTime / 0.3f));\n                Color currentColor = Color.Lerp(_originalColor, Color.red, effectStrength);\n                _renderer.material.color = currentColor;\n            }\n            \n            if (_damageEffectTime <= 0f)\n            {\n                ResetVisualEffects();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.collider);\n    }\n    \n    private void HandleCollision(Collider other)\n    {\n        if (!_isShieldActive) return;\n        \n        float damage = CalculateDamage(other);\n        if (damage > 0f)\n        {\n            TakeDamage(damage);\n        }\n    }\n    \n    private float CalculateDamage(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            return 0f; // Don't damage shield from player contact\n        }\n        \n        if (other.CompareTag(\"Enemy\"))\n        {\n            return 25f;\n        }\n        \n        // Check for projectiles or other damaging objects\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            float velocity = rb.velocity.magnitude;\n            return Mathf.Clamp(velocity * 2f, 5f, 50f);\n        }\n        \n        return 10f; // Default damage\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (!_isShieldActive) return;\n        \n        _shieldHealth -= damage;\n        _shieldHealth = Mathf.Max(_shieldHealth, 0f);\n        _lastDamageTime = Time.time;\n        _isRegenerating = false;\n        \n        TriggerDamageEffect();\n        PlaySound(_hitSound);\n        OnShieldHit?.Invoke();\n        \n        if (_shieldHealth <= 0f)\n        {\n            BreakShield();\n        }\n        else\n        {\n            UpdateShieldVisuals();\n        }\n    }\n    \n    private void TriggerDamageEffect()\n    {\n        _damageEffectTime = 0.3f;\n    }\n    \n    private void BreakShield()\n    {\n        _isShieldActive = false;\n        _isRegenerating = false;\n        \n        UpdateShieldVisuals();\n        PlaySound(_breakSound);\n        OnShieldBroken?.Invoke();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(false);\n        }\n        \n        // Disable collision while shield is down\n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n    }\n    \n    private void RestoreShield()\n    {\n        _isShieldActive = true;\n        _isRegenerating = false;\n        _shieldHealth = _maxShieldHealth;\n        \n        UpdateShieldVisuals();\n        OnShieldRestored?.Invoke();\n        \n        if (_shieldEffect != null)\n        {\n            _shieldEffect.SetActive(true);\n        }\n        \n        if (_collider != null)\n        {\n            _collider.enabled = true;\n        }\n    }\n    \n    private void UpdateShieldVisuals()\n    {\n        if (_renderer == null) return;\n        \n        if (_isShieldActive)\n        {\n            float healthPercent = _shieldHealth / _maxShieldHealth;\n            Color shieldColor = Color.Lerp(Color.red, _shieldColor, healthPercent);\n            shieldColor.a = Mathf.Lerp(0.3f, 0.8f, healthPercent);\n            \n            if (_normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n                _renderer.material.color = shieldColor;\n            }\n        }\n        else\n        {\n            if (_damagedMaterial != null)\n            {\n                _renderer.material = _damagedMaterial;\n            }\n            else if (_renderer.material != null)\n            {\n                Color brokenColor = _originalColor;\n                brokenColor.a = 0.2f;\n                _renderer.material.color = brokenColor;\n            }\n        }\n    }\n    \n    private void ResetVisualEffects()\n    {\n        if (_renderer != null)\n        {\n            if (_isShieldActive && _normalMaterial != null)\n            {\n                _renderer.material = _normalMaterial;\n                UpdateShieldVisuals();\n            }\n            else\n            {\n                _renderer.material.color = _originalColor;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip, _audioVolume);\n        }\n    }\n    \n    public void SetShieldHealth(float health)\n    {\n        _shieldHealth = Mathf.Clamp(health, 0f, _maxShieldHealth);\n        \n        if (_shieldHealth > 0f && !_isShieldActive)\n        {\n            RestoreShield();\n        }\n        else if (_shieldHealth <= 0f && _isShieldActive)\n        {\n            BreakShield();\n        }\n        else\n        {\n            UpdateShieldVisuals();\n        }\n    }\n    \n    public float GetShieldHealth()\n    {\n        return _shieldHealth;\n    }\n    \n    public float GetShieldHealthPercent()\n    {\n        return _shieldHealth / _maxShieldHealth;\n    }\n    \n    public bool IsShieldActive()\n    {\n        return _isShieldActive;\n    }\n    \n    public void ForceBreakShield()\n    {\n        _shieldHealth = 0f;\n        BreakShield();\n    }\n    \n    public void ForceRestoreShield()\n    {\n        RestoreShield();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RocketShipLaunch\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"launchForce\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"fuelDuration\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"isLaunched\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_launch\",\n      \"trigger\": \"when launch key is pressed and rocket has not launched yet\",\n      \"actions\": [\n        {\n          \"action\": \"mark rocket as launched\"\n        },\n        {\n          \"action\": \"apply upward force to rocket body\"\n        },\n        {\n          \"action\": \"start engine sound effect\"\n        },\n        {\n          \"action\": \"activate thruster particle effects\"\n        },\n        {\n          \"action\": \"begin fuel consumption countdown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_thrust\",\n      \"trigger\": \"while rocket is launched and fuel duration has not expired\",\n      \"actions\": [\n        {\n          \"action\": \"continue applying upward thrust force\"\n        },\n        {\n          \"action\": \"keep thruster particles active\"\n        },\n        {\n          \"action\": \"maintain engine audio loop\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fuel_depletion\",\n      \"trigger\": \"when fuel duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying thrust force\"\n        },\n        {\n          \"action\": \"fade out engine sound\"\n        },\n        {\n          \"action\": \"reduce thruster particle intensity\"\n        },\n        {\n          \"action\": \"allow rocket to fall under gravity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RocketShipLauncher : MonoBehaviour\n{\n    [Header(\"Launch Settings\")]\n    [SerializeField] private float _launchForce = 1000f;\n    [SerializeField] private float _launchDelay = 3f;\n    [SerializeField] private float _fuelBurnDuration = 5f;\n    [SerializeField] private AnimationCurve _thrustCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _countdownSound;\n    [SerializeField] private AudioClip _launchSound;\n    [SerializeField] private AudioClip _thrusterSound;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _thrusterParticles;\n    [SerializeField] private ParticleSystem _smokeParticles;\n    [SerializeField] private Light _thrusterLight;\n    [SerializeField] private Transform _rocketTransform;\n    \n    [Header(\"Launch Trigger\")]\n    [SerializeField] private KeyCode _launchKey = KeyCode.Space;\n    [SerializeField] private bool _autoLaunch = false;\n    [SerializeField] private float _autoLaunchDelay = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCountdownStart;\n    public UnityEvent OnLaunchStart;\n    public UnityEvent OnLaunchComplete;\n    \n    private Rigidbody _rigidbody;\n    private bool _isLaunching = false;\n    private bool _hasLaunched = false;\n    private float _launchTimer = 0f;\n    private float _thrustTimer = 0f;\n    private Vector3 _initialPosition;\n    private Quaternion _initialRotation;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_rocketTransform == null)\n        {\n            _rocketTransform = transform;\n        }\n        \n        _initialPosition = transform.position;\n        _initialRotation = transform.rotation;\n        \n        _rigidbody.isKinematic = true;\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n        \n        if (_autoLaunch)\n        {\n            Invoke(nameof(StartLaunchSequence), _autoLaunchDelay);\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_hasLaunched && !_isLaunching && Input.GetKeyDown(_launchKey))\n        {\n            StartLaunchSequence();\n        }\n        \n        if (_isLaunching)\n        {\n            UpdateLaunchSequence();\n        }\n    }\n    \n    private void StartLaunchSequence()\n    {\n        if (_hasLaunched || _isLaunching) return;\n        \n        _isLaunching = true;\n        _launchTimer = 0f;\n        \n        OnCountdownStart?.Invoke();\n        \n        if (_countdownSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_countdownSound);\n        }\n        \n        if (_smokeParticles != null)\n        {\n            _smokeParticles.Play();\n        }\n    }\n    \n    private void UpdateLaunchSequence()\n    {\n        _launchTimer += Time.deltaTime;\n        \n        if (_launchTimer >= _launchDelay && !_hasLaunched)\n        {\n            Launch();\n        }\n        \n        if (_hasLaunched)\n        {\n            UpdateThrust();\n        }\n    }\n    \n    private void Launch()\n    {\n        _hasLaunched = true;\n        _thrustTimer = 0f;\n        _rigidbody.isKinematic = false;\n        \n        OnLaunchStart?.Invoke();\n        \n        if (_launchSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_launchSound);\n        }\n        \n        if (_thrusterSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _thrusterSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        if (_thrusterParticles != null)\n        {\n            _thrusterParticles.Play();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = true;\n        }\n    }\n    \n    private void UpdateThrust()\n    {\n        _thrustTimer += Time.deltaTime;\n        \n        if (_thrustTimer <= _fuelBurnDuration)\n        {\n            float normalizedTime = _thrustTimer / _fuelBurnDuration;\n            float thrustMultiplier = _thrustCurve.Evaluate(normalizedTime);\n            \n            Vector3 thrustForce = _rocketTransform.up * _launchForce * thrustMultiplier * Time.deltaTime;\n            _rigidbody.AddForce(thrustForce, ForceMode.Force);\n            \n            if (_thrusterLight != null)\n            {\n                _thrusterLight.intensity = thrustMultiplier * 2f;\n            }\n        }\n        else\n        {\n            CompleteLaunch();\n        }\n    }\n    \n    private void CompleteLaunch()\n    {\n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _thrusterSound)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_thrusterParticles != null && _thrusterParticles.isPlaying)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n        \n        OnLaunchComplete?.Invoke();\n    }\n    \n    public void ResetRocket()\n    {\n        _isLaunching = false;\n        _hasLaunched = false;\n        _launchTimer = 0f;\n        _thrustTimer = 0f;\n        \n        transform.position = _initialPosition;\n        transform.rotation = _initialRotation;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_thrusterParticles != null && _thrusterParticles.isPlaying)\n        {\n            _thrusterParticles.Stop();\n        }\n        \n        if (_smokeParticles != null && _smokeParticles.isPlaying)\n        {\n            _smokeParticles.Stop();\n        }\n        \n        if (_thrusterLight != null)\n        {\n            _thrusterLight.enabled = false;\n        }\n    }\n    \n    public void SetLaunchForce(float force)\n    {\n        _launchForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetLaunchDelay(float delay)\n    {\n        _launchDelay = Mathf.Max(0f, delay);\n    }\n    \n    public bool IsLaunching => _isLaunching;\n    public bool HasLaunched => _hasLaunched;\n    public float LaunchProgress => _hasLaunched ? _thrustTimer / _fuelBurnDuration : _launchTimer / _launchDelay;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SizeChanger\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"minScale\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"maxScale\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"scaleSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"currentTargetScale\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"increase_size\",\n      \"trigger\": \"when increase size input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set target scale to maximum scale value\"\n        },\n        {\n          \"action\": \"gradually scale object up to target scale at scale speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decrease_size\",\n      \"trigger\": \"when decrease size input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set target scale to minimum scale value\"\n        },\n        {\n          \"action\": \"gradually scale object down to target scale at scale speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_size\",\n      \"trigger\": \"when reset size input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set target scale to normal size\"\n        },\n        {\n          \"action\": \"gradually scale object to normal size at scale speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"smooth_scaling\",\n      \"trigger\": \"when current scale is different from target scale\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly interpolate current scale toward target scale\"\n        },\n        {\n          \"action\": \"apply the interpolated scale to the transform\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SizeChangeAbility : MonoBehaviour\n{\n    [System.Serializable]\n    public class SizeChangeEvent : UnityEvent<float> { }\n    \n    [Header(\"Size Settings\")]\n    [SerializeField] private float _minSize = 0.5f;\n    [SerializeField] private float _maxSize = 3.0f;\n    [SerializeField] private float _defaultSize = 1.0f;\n    [SerializeField] private float _sizeChangeSpeed = 2.0f;\n    [SerializeField] private AnimationCurve _sizeTransitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _growKey = KeyCode.E;\n    [SerializeField] private KeyCode _shrinkKey = KeyCode.Q;\n    [SerializeField] private KeyCode _resetKey = KeyCode.R;\n    [SerializeField] private bool _useMouseWheel = true;\n    [SerializeField] private float _mouseWheelSensitivity = 0.5f;\n    \n    [Header(\"Energy System\")]\n    [SerializeField] private bool _useEnergySystem = true;\n    [SerializeField] private float _maxEnergy = 100f;\n    [SerializeField] private float _energyDrainRate = 10f;\n    [SerializeField] private float _energyRegenRate = 5f;\n    [SerializeField] private float _minEnergyToActivate = 10f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private bool _adjustMass = true;\n    [SerializeField] private float _baseMass = 1f;\n    [SerializeField] private bool _adjustCollider = true;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _sizeChangeEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _growSound;\n    [SerializeField] private AudioClip _shrinkSound;\n    [SerializeField] private AudioClip _resetSound;\n    \n    [Header(\"Events\")]\n    public SizeChangeEvent OnSizeChanged;\n    public UnityEvent OnGrow;\n    public UnityEvent OnShrink;\n    public UnityEvent OnReset;\n    public UnityEvent OnEnergyDepleted;\n    \n    private float _currentSize;\n    private float _targetSize;\n    private Vector3 _originalScale;\n    private float _currentEnergy;\n    private bool _isChangingSize;\n    private float _sizeChangeTimer;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Vector3 _originalColliderSize;\n    private Vector3 _originalColliderCenter;\n    \n    private void Start()\n    {\n        _originalScale = transform.localScale;\n        _currentSize = _defaultSize;\n        _targetSize = _defaultSize;\n        _currentEnergy = _maxEnergy;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider != null)\n        {\n            if (_collider is BoxCollider boxCollider)\n            {\n                _originalColliderSize = boxCollider.size;\n                _originalColliderCenter = boxCollider.center;\n            }\n            else if (_collider is SphereCollider sphereCollider)\n            {\n                _originalColliderSize = Vector3.one * sphereCollider.radius;\n                _originalColliderCenter = sphereCollider.center;\n            }\n            else if (_collider is CapsuleCollider capsuleCollider)\n            {\n                _originalColliderSize = new Vector3(capsuleCollider.radius, capsuleCollider.height, capsuleCollider.radius);\n                _originalColliderCenter = capsuleCollider.center;\n            }\n        }\n        \n        ApplySize(_currentSize);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateEnergy();\n        UpdateSizeTransition();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_useEnergySystem || _currentEnergy >= _minEnergyToActivate)\n        {\n            if (Input.GetKeyDown(_growKey))\n            {\n                Grow();\n            }\n            else if (Input.GetKeyDown(_shrinkKey))\n            {\n                Shrink();\n            }\n            \n            if (_useMouseWheel)\n            {\n                float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n                if (Mathf.Abs(scroll) > 0.01f)\n                {\n                    ChangeSize(scroll * _mouseWheelSensitivity);\n                }\n            }\n        }\n        \n        if (Input.GetKeyDown(_resetKey))\n        {\n            ResetSize();\n        }\n    }\n    \n    private void UpdateEnergy()\n    {\n        if (!_useEnergySystem) return;\n        \n        if (_isChangingSize && _currentSize != _defaultSize)\n        {\n            _currentEnergy -= _energyDrainRate * Time.deltaTime;\n            _currentEnergy = Mathf.Max(0, _currentEnergy);\n            \n            if (_currentEnergy <= 0)\n            {\n                OnEnergyDepleted?.Invoke();\n                ResetSize();\n            }\n        }\n        else if (!_isChangingSize || _currentSize == _defaultSize)\n        {\n            _currentEnergy += _energyRegenRate * Time.deltaTime;\n            _currentEnergy = Mathf.Min(_maxEnergy, _currentEnergy);\n        }\n    }\n    \n    private void UpdateSizeTransition()\n    {\n        if (_isChangingSize)\n        {\n            _sizeChangeTimer += Time.deltaTime * _sizeChangeSpeed;\n            float progress = _sizeChangeTimer;\n            \n            if (progress >= 1f)\n            {\n                progress = 1f;\n                _isChangingSize = false;\n            }\n            \n            float curveValue = _sizeTransitionCurve.Evaluate(progress);\n            float newSize = Mathf.Lerp(_currentSize, _targetSize, curveValue);\n            \n            ApplySize(newSize);\n            \n            if (!_isChangingSize)\n            {\n                _currentSize = _targetSize;\n            }\n        }\n    }\n    \n    public void Grow()\n    {\n        ChangeSize(0.5f);\n        OnGrow?.Invoke();\n        PlaySound(_growSound);\n    }\n    \n    public void Shrink()\n    {\n        ChangeSize(-0.5f);\n        OnShrink?.Invoke();\n        PlaySound(_shrinkSound);\n    }\n    \n    public void ChangeSize(float amount)\n    {\n        if (_useEnergySystem && _currentEnergy < _minEnergyToActivate && amount != 0) return;\n        \n        float newTargetSize = _targetSize + amount;\n        newTargetSize = Mathf.Clamp(newTargetSize, _minSize, _maxSize);\n        \n        if (Mathf.Abs(newTargetSize - _targetSize) > 0.01f)\n        {\n            _targetSize = newTargetSize;\n            _isChangingSize = true;\n            _sizeChangeTimer = 0f;\n            \n            PlayEffect();\n        }\n    }\n    \n    public void SetSize(float size)\n    {\n        size = Mathf.Clamp(size, _minSize, _maxSize);\n        _targetSize = size;\n        _isChangingSize = true;\n        _sizeChangeTimer = 0f;\n        \n        PlayEffect();\n    }\n    \n    public void ResetSize()\n    {\n        _targetSize = _defaultSize;\n        _isChangingSize = true;\n        _sizeChangeTimer = 0f;\n        \n        OnReset?.Invoke();\n        PlaySound(_resetSound);\n        PlayEffect();\n    }\n    \n    private void ApplySize(float size)\n    {\n        Vector3 newScale = _originalScale * size;\n        transform.localScale = newScale;\n        \n        if (_adjustMass && _rigidbody != null)\n        {\n            _rigidbody.mass = _baseMass * (size * size * size);\n        }\n        \n        if (_adjustCollider && _collider != null)\n        {\n            if (_collider is BoxCollider boxCollider)\n            {\n                boxCollider.size = _originalColliderSize * size;\n                boxCollider.center = _originalColliderCenter * size;\n            }\n            else if (_collider is SphereCollider sphereCollider)\n            {\n                sphereCollider.radius = _originalColliderSize.x * size;\n                sphereCollider.center = _originalColliderCenter * size;\n            }\n            else if (_collider is CapsuleCollider capsuleCollider)\n            {\n                capsuleCollider.radius = _originalColliderSize.x * size;\n                capsuleCollider.height = _originalColliderSize.y * size;\n                capsuleCollider.center = _originalColliderCenter * size;\n            }\n        }\n        \n        OnSizeChanged?.Invoke(size);\n    }\n    \n    private void PlayEffect()\n    {\n        if (_sizeChangeEffect != null)\n        {\n            _sizeChangeEffect.Play();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public float GetCurrentSize()\n    {\n        return _currentSize;\n    }\n    \n    public float GetTargetSize()\n    {\n        return _targetSize;\n    }\n    \n    public float GetCurrentEnergy()\n    {\n        return _currentEnergy;\n    }\n    \n    public float GetEnergyPercentage()\n    {\n        return _useEnergySystem ? _currentEnergy / _maxEnergy : 1f;\n    }\n    \n    public bool IsChangingSize()\n    {\n        return _isChangingSize;\n    }\n    \n    public bool CanChangeSize()\n    {\n        return !_useEnergySystem || _currentEnergy >= _minEnergyToActivate;\n    }\n    \n    public void SetEnergy(float energy)\n    {\n        _currentEnergy = Mathf.Clamp(energy, 0, _maxEnergy);\n    }\n    \n    public void AddEnergy(float amount)\n    {\n        _currentEnergy = Mathf.Clamp(_currentEnergy + amount, 0, _maxEnergy);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LavaFloor\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damagePerSecond\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"burnSoundEffect\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_player_on_contact\",\n      \"trigger\": \"when player enters the lava area\",\n      \"actions\": [\n        {\n          \"action\": \"start applying damage to player over time\"\n        },\n        {\n          \"action\": \"play burning sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_damage\",\n      \"trigger\": \"while player remains in contact with lava\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player at regular intervals\"\n        },\n        {\n          \"action\": \"apply burning visual effect to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_damage\",\n      \"trigger\": \"when player exits the lava area\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying damage to player\"\n        },\n        {\n          \"action\": \"stop burning sound effect\"\n        },\n        {\n          \"action\": \"remove burning visual effect from player\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LavaFloor : MonoBehaviour\n{\n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private bool _continuousDamage = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _lavaParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _sizzleSound;\n    [SerializeField] private AudioClip _damageSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerEnterLava;\n    public UnityEvent<GameObject> OnPlayerExitLava;\n    public UnityEvent<GameObject, float> OnPlayerDamaged;\n    \n    private bool _playerInLava = false;\n    private float _damageTimer = 0f;\n    private GameObject _currentPlayer;\n    \n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_lavaParticles == null)\n            _lavaParticles = GetComponentInChildren<ParticleSystem>();\n    }\n    \n    private void Update()\n    {\n        if (_playerInLava && _continuousDamage)\n        {\n            _damageTimer += Time.deltaTime;\n            \n            if (_damageTimer >= _damageInterval)\n            {\n                DealDamage();\n                _damageTimer = 0f;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerInLava = true;\n            _currentPlayer = other.gameObject;\n            _damageTimer = 0f;\n            \n            OnPlayerEnterLava?.Invoke(_currentPlayer);\n            \n            if (_audioSource && _sizzleSound)\n            {\n                _audioSource.clip = _sizzleSound;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            if (_lavaParticles)\n                _lavaParticles.Play();\n                \n            if (!_continuousDamage)\n                DealDamage();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && other.gameObject == _currentPlayer)\n        {\n            _playerInLava = false;\n            _currentPlayer = null;\n            _damageTimer = 0f;\n            \n            OnPlayerExitLava?.Invoke(other.gameObject);\n            \n            if (_audioSource)\n                _audioSource.Stop();\n                \n            if (_lavaParticles)\n                _lavaParticles.Stop();\n        }\n    }\n    \n    private void DealDamage()\n    {\n        if (_currentPlayer == null) return;\n        \n        var playerHealth = _currentPlayer.GetComponent<CharacterController>();\n        if (playerHealth != null)\n        {\n            OnPlayerDamaged?.Invoke(_currentPlayer, _damageAmount);\n            \n            if (_audioSource && _damageSound)\n            {\n                _audioSource.PlayOneShot(_damageSound);\n            }\n        }\n    }\n    \n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = Mathf.Max(0f, damage);\n    }\n    \n    public void SetDamageInterval(float interval)\n    {\n        _damageInterval = Mathf.Max(0.1f, interval);\n    }\n    \n    public void EnableLava(bool enable)\n    {\n        GetComponent<Collider>().enabled = enable;\n        \n        if (!enable && _playerInLava)\n        {\n            _playerInLava = false;\n            _currentPlayer = null;\n            \n            if (_audioSource)\n                _audioSource.Stop();\n                \n            if (_lavaParticles)\n                _lavaParticles.Stop();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Blowgun\",\n  \"components\": [\n    \"Transform\",\n    \"AudioSource\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dartPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"firePoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"dartSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"ammoCount\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxAmmo\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isLoaded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"canFire\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_dart\",\n      \"trigger\": \"when fire input is pressed and weapon is loaded and can fire\",\n      \"actions\": [\n        {\n          \"action\": \"instantiate dart at fire point position\"\n        },\n        {\n          \"action\": \"launch dart forward at dart speed\"\n        },\n        {\n          \"action\": \"play blowgun firing sound\"\n        },\n        {\n          \"action\": \"trigger firing animation\"\n        },\n        {\n          \"action\": \"decrease ammo count by one\"\n        },\n        {\n          \"action\": \"set is loaded to false\"\n        },\n        {\n          \"action\": \"set can fire to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_dart\",\n      \"trigger\": \"when weapon is not loaded and ammo count is greater than zero and can fire\",\n      \"actions\": [\n        {\n          \"action\": \"play dart loading sound\"\n        },\n        {\n          \"action\": \"trigger reload animation\"\n        },\n        {\n          \"action\": \"wait for reload time duration\"\n        },\n        {\n          \"action\": \"set is loaded to true\"\n        },\n        {\n          \"action\": \"set can fire to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_reload\",\n      \"trigger\": \"when fire input is pressed and weapon is not loaded and ammo count is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"start reload sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"empty_fire_attempt\",\n      \"trigger\": \"when fire input is pressed and ammo count is zero\",\n      \"actions\": [\n        {\n          \"action\": \"play empty click sound\"\n        },\n        {\n          \"action\": \"trigger empty fire animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refill_ammo\",\n      \"trigger\": \"when reload input is held and ammo count is less than maximum\",\n      \"actions\": [\n        {\n          \"action\": \"play ammo refill sound\"\n        },\n        {\n          \"action\": \"set ammo count to maximum\"\n        },\n        {\n          \"action\": \"set is loaded to true if ammo available\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Blowgun : MonoBehaviour\n{\n    [Header(\"Blowgun Settings\")]\n    [SerializeField] private GameObject _dartPrefab;\n    [SerializeField] private Transform _firePoint;\n    [SerializeField] private float _dartSpeed = 20f;\n    [SerializeField] private float _fireRate = 1f;\n    [SerializeField] private int _maxAmmo = 10;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _emptySound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _muzzleFlash;\n    [SerializeField] private Transform _blowgunModel;\n    [SerializeField] private float _recoilForce = 0.1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnShoot;\n    public UnityEvent OnReload;\n    public UnityEvent OnAmmoEmpty;\n    \n    private int _currentAmmo;\n    private float _lastFireTime;\n    private bool _isReloading;\n    private AudioSource _audioSource;\n    private Vector3 _originalPosition;\n    \n    private void Start()\n    {\n        _currentAmmo = _maxAmmo;\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_blowgunModel != null)\n            _originalPosition = _blowgunModel.localPosition;\n            \n        if (_firePoint == null)\n            _firePoint = transform;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleRecoil();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && CanShoot())\n        {\n            Shoot();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R) && !_isReloading && _currentAmmo < _maxAmmo)\n        {\n            StartCoroutine(Reload());\n        }\n    }\n    \n    private bool CanShoot()\n    {\n        return !_isReloading && \n               _currentAmmo > 0 && \n               Time.time >= _lastFireTime + (1f / _fireRate);\n    }\n    \n    private void Shoot()\n    {\n        if (_dartPrefab == null) return;\n        \n        _currentAmmo--;\n        _lastFireTime = Time.time;\n        \n        GameObject dart = Instantiate(_dartPrefab, _firePoint.position, _firePoint.rotation);\n        Dart dartComponent = dart.GetComponent<Dart>();\n        if (dartComponent == null)\n            dartComponent = dart.AddComponent<Dart>();\n            \n        dartComponent.Initialize(_dartSpeed);\n        \n        PlaySound(_shootSound);\n        \n        if (_muzzleFlash != null)\n            _muzzleFlash.Play();\n            \n        ApplyRecoil();\n        OnShoot?.Invoke();\n        \n        if (_currentAmmo <= 0)\n        {\n            OnAmmoEmpty?.Invoke();\n        }\n    }\n    \n    private void ApplyRecoil()\n    {\n        if (_blowgunModel != null)\n        {\n            _blowgunModel.localPosition = _originalPosition - transform.forward * _recoilForce;\n        }\n    }\n    \n    private void HandleRecoil()\n    {\n        if (_blowgunModel != null)\n        {\n            _blowgunModel.localPosition = Vector3.Lerp(_blowgunModel.localPosition, _originalPosition, Time.deltaTime * 10f);\n        }\n    }\n    \n    private IEnumerator Reload()\n    {\n        _isReloading = true;\n        PlaySound(_reloadSound);\n        OnReload?.Invoke();\n        \n        yield return new WaitForSeconds(_reloadTime);\n        \n        _currentAmmo = _maxAmmo;\n        _isReloading = false;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void TryShoot()\n    {\n        if (CanShoot())\n        {\n            Shoot();\n        }\n        else if (_currentAmmo <= 0)\n        {\n            PlaySound(_emptySound);\n        }\n    }\n    \n    public int GetCurrentAmmo()\n    {\n        return _currentAmmo;\n    }\n    \n    public int GetMaxAmmo()\n    {\n        return _maxAmmo;\n    }\n    \n    public bool IsReloading()\n    {\n        return _isReloading;\n    }\n}\n\npublic class Dart : MonoBehaviour\n{\n    [Header(\"Dart Settings\")]\n    [SerializeField] private float _damage = 25f;\n    [SerializeField] private float _lifetime = 5f;\n    [SerializeField] private bool _stickToSurfaces = true;\n    [SerializeField] private LayerMask _hitLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _hitEffect;\n    [SerializeField] private AudioClip _hitSound;\n    \n    private Rigidbody _rigidbody;\n    private bool _hasHit;\n    private AudioSource _audioSource;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        Destroy(gameObject, _lifetime);\n    }\n    \n    public void Initialize(float speed)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = transform.forward * speed;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasHit) return;\n        \n        if (((1 << other.gameObject.layer) & _hitLayers) != 0)\n        {\n            HandleHit(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasHit) return;\n        \n        if (((1 << collision.gameObject.layer) & _hitLayers) != 0)\n        {\n            HandleHit(collision.collider);\n        }\n    }\n    \n    private void HandleHit(Collider hitCollider)\n    {\n        _hasHit = true;\n        \n        if (hitCollider.CompareTag(\"Player\"))\n        {\n            DealDamageToPlayer(hitCollider.gameObject);\n        }\n        else\n        {\n            DealDamageToTarget(hitCollider.gameObject);\n        }\n        \n        if (_stickToSurfaces)\n        {\n            StickToSurface(hitCollider);\n        }\n        \n        SpawnHitEffect();\n        PlayHitSound();\n        \n        if (!_stickToSurfaces)\n        {\n            Destroy(gameObject, 0.1f);\n        }\n    }\n    \n    private void DealDamageToPlayer(GameObject player)\n    {\n        // Send damage message to player\n        player.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    private void DealDamageToTarget(GameObject target)\n    {\n        // Try to find health component or send damage message\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n    }\n    \n    private void StickToSurface(Collider surface)\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n            _rigidbody.isKinematic = true;\n        }\n        \n        transform.SetParent(surface.transform);\n        \n        Destroy(gameObject, _lifetime - 1f);\n    }\n    \n    private void SpawnHitEffect()\n    {\n        if (_hitEffect != null)\n        {\n            Instantiate(_hitEffect, transform.position, transform.rotation);\n        }\n    }\n    \n    private void PlayHitSound()\n    {\n        if (_audioSource != null && _hitSound != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"NotificationPopup\",\n  \"components\": [\n    \"Canvas\",\n    \"CanvasGroup\",\n    \"Image\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"fadeInSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeOutSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"slideDistance\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"notificationText\",\n      \"type\": \"string\",\n      \"default\": \"Notification\"\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_notification\",\n      \"trigger\": \"when show notification is requested with message text\",\n      \"actions\": [\n        {\n          \"action\": \"set notification text to provided message\"\n        },\n        {\n          \"action\": \"make popup visible\"\n        },\n        {\n          \"action\": \"slide popup in from top of screen\"\n        },\n        {\n          \"action\": \"fade popup in smoothly\"\n        },\n        {\n          \"action\": \"mark popup as currently visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_hide_after_duration\",\n      \"trigger\": \"when popup has been visible for display duration time\",\n      \"actions\": [\n        {\n          \"action\": \"start hiding the popup\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_notification\",\n      \"trigger\": \"when hide notification is requested\",\n      \"actions\": [\n        {\n          \"action\": \"fade popup out smoothly\"\n        },\n        {\n          \"action\": \"slide popup up off screen\"\n        },\n        {\n          \"action\": \"make popup invisible when animation completes\"\n        },\n        {\n          \"action\": \"mark popup as no longer visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dismiss_on_click\",\n      \"trigger\": \"when popup is clicked by user\",\n      \"actions\": [\n        {\n          \"action\": \"immediately hide the notification\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\n\npublic class NotificationPopup : MonoBehaviour\n{\n    [System.Serializable]\n    public class NotificationData\n    {\n        public string title;\n        public string message;\n        public Sprite icon;\n        public Color backgroundColor = Color.white;\n        public float duration = 3f;\n        public NotificationType type = NotificationType.Info;\n    }\n\n    [System.Serializable]\n    public enum NotificationType\n    {\n        Info,\n        Warning,\n        Error,\n        Success\n    }\n\n    [System.Serializable]\n    public class NotificationTypeSettings\n    {\n        public NotificationType type;\n        public Color backgroundColor;\n        public Color textColor;\n        public Sprite defaultIcon;\n    }\n\n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _notificationPrefab;\n    [SerializeField] private Transform _notificationContainer;\n    [SerializeField] private Canvas _canvas;\n\n    [Header(\"Animation Settings\")]\n    [SerializeField] private AnimationCurve _slideInCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private AnimationCurve _slideOutCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);\n    [SerializeField] private float _animationDuration = 0.5f;\n    [SerializeField] private Vector2 _slideOffset = new Vector2(300f, 0f);\n\n    [Header(\"Notification Settings\")]\n    [SerializeField] private int _maxNotifications = 5;\n    [SerializeField] private float _defaultDuration = 3f;\n    [SerializeField] private float _notificationSpacing = 10f;\n    [SerializeField] private NotificationTypeSettings[] _typeSettings;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _notificationSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<string> OnNotificationShown;\n    public UnityEvent<string> OnNotificationClosed;\n\n    private Queue<NotificationData> _notificationQueue = new Queue<NotificationData>();\n    private List<GameObject> _activeNotifications = new List<GameObject>();\n    private Dictionary<NotificationType, NotificationTypeSettings> _typeSettingsDict;\n    private bool _isProcessingQueue = false;\n\n    private void Awake()\n    {\n        InitializeTypeSettings();\n        SetupCanvas();\n    }\n\n    private void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n\n    private void InitializeTypeSettings()\n    {\n        _typeSettingsDict = new Dictionary<NotificationType, NotificationTypeSettings>();\n        \n        if (_typeSettings != null)\n        {\n            foreach (var setting in _typeSettings)\n            {\n                _typeSettingsDict[setting.type] = setting;\n            }\n        }\n\n        // Add default settings if not provided\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Info))\n            _typeSettingsDict[NotificationType.Info] = new NotificationTypeSettings \n            { \n                type = NotificationType.Info, \n                backgroundColor = new Color(0.2f, 0.6f, 1f, 0.9f), \n                textColor = Color.white \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Warning))\n            _typeSettingsDict[NotificationType.Warning] = new NotificationTypeSettings \n            { \n                type = NotificationType.Warning, \n                backgroundColor = new Color(1f, 0.8f, 0f, 0.9f), \n                textColor = Color.black \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Error))\n            _typeSettingsDict[NotificationType.Error] = new NotificationTypeSettings \n            { \n                type = NotificationType.Error, \n                backgroundColor = new Color(1f, 0.3f, 0.3f, 0.9f), \n                textColor = Color.white \n            };\n\n        if (!_typeSettingsDict.ContainsKey(NotificationType.Success))\n            _typeSettingsDict[NotificationType.Success] = new NotificationTypeSettings \n            { \n                type = NotificationType.Success, \n                backgroundColor = new Color(0.3f, 0.8f, 0.3f, 0.9f), \n                textColor = Color.white \n            };\n    }\n\n    private void SetupCanvas()\n    {\n        if (_canvas == null)\n            _canvas = GetComponentInParent<Canvas>();\n\n        if (_canvas == null)\n        {\n            GameObject canvasGO = new GameObject(\"NotificationCanvas\");\n            canvasGO.transform.SetParent(transform);\n            _canvas = canvasGO.AddComponent<Canvas>();\n            _canvas.renderMode = RenderMode.ScreenSpaceOverlay;\n            _canvas.sortingOrder = 1000;\n            canvasGO.AddComponent<CanvasScaler>();\n            canvasGO.AddComponent<GraphicRaycaster>();\n        }\n\n        if (_notificationContainer == null)\n        {\n            GameObject containerGO = new GameObject(\"NotificationContainer\");\n            containerGO.transform.SetParent(_canvas.transform);\n            _notificationContainer = containerGO.transform;\n            \n            RectTransform containerRect = containerGO.AddComponent<RectTransform>();\n            containerRect.anchorMin = new Vector2(1f, 1f);\n            containerRect.anchorMax = new Vector2(1f, 1f);\n            containerRect.pivot = new Vector2(1f, 1f);\n            containerRect.anchoredPosition = new Vector2(-20f, -20f);\n            containerRect.sizeDelta = new Vector2(400f, 600f);\n\n            VerticalLayoutGroup layoutGroup = containerGO.AddComponent<VerticalLayoutGroup>();\n            layoutGroup.childAlignment = TextAnchor.UpperRight;\n            layoutGroup.spacing = _notificationSpacing;\n            layoutGroup.childControlHeight = false;\n            layoutGroup.childControlWidth = false;\n            layoutGroup.childForceExpandHeight = false;\n            layoutGroup.childForceExpandWidth = false;\n\n            ContentSizeFitter sizeFitter = containerGO.AddComponent<ContentSizeFitter>();\n            sizeFitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;\n        }\n    }\n\n    public void ShowNotification(string message)\n    {\n        ShowNotification(\"\", message, null, NotificationType.Info, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message)\n    {\n        ShowNotification(title, message, null, NotificationType.Info, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message, NotificationType type)\n    {\n        ShowNotification(title, message, null, type, _defaultDuration);\n    }\n\n    public void ShowNotification(string title, string message, Sprite icon, NotificationType type, float duration = -1f)\n    {\n        if (duration < 0f)\n            duration = _defaultDuration;\n\n        NotificationData data = new NotificationData\n        {\n            title = title,\n            message = message,\n            icon = icon,\n            type = type,\n            duration = duration\n        };\n\n        if (_typeSettingsDict.ContainsKey(type))\n        {\n            data.backgroundColor = _typeSettingsDict[type].backgroundColor;\n            if (icon == null)\n                data.icon = _typeSettingsDict[type].defaultIcon;\n        }\n\n        _notificationQueue.Enqueue(data);\n        \n        if (!_isProcessingQueue)\n            StartCoroutine(ProcessNotificationQueue());\n    }\n\n    private IEnumerator ProcessNotificationQueue()\n    {\n        _isProcessingQueue = true;\n\n        while (_notificationQueue.Count > 0)\n        {\n            if (_activeNotifications.Count >= _maxNotifications)\n            {\n                yield return new WaitForSeconds(0.1f);\n                continue;\n            }\n\n            NotificationData data = _notificationQueue.Dequeue();\n            yield return StartCoroutine(DisplayNotification(data));\n        }\n\n        _isProcessingQueue = false;\n    }\n\n    private IEnumerator DisplayNotification(NotificationData data)\n    {\n        GameObject notification = CreateNotificationObject(data);\n        if (notification == null)\n            yield break;\n\n        _activeNotifications.Add(notification);\n        \n        PlayNotificationSound();\n        OnNotificationShown?.Invoke(data.message);\n\n        // Animate in\n        yield return StartCoroutine(AnimateNotificationIn(notification));\n\n        // Wait for duration\n        yield return new WaitForSeconds(data.duration);\n\n        // Animate out and destroy\n        yield return StartCoroutine(AnimateNotificationOut(notification));\n        \n        _activeNotifications.Remove(notification);\n        OnNotificationClosed?.Invoke(data.message);\n        \n        if (notification != null)\n            Destroy(notification);\n    }\n\n    private GameObject CreateNotificationObject(NotificationData data)\n    {\n        GameObject notification;\n\n        if (_notificationPrefab != null)\n        {\n            notification = Instantiate(_notificationPrefab, _notificationContainer);\n        }\n        else\n        {\n            notification = CreateDefaultNotification();\n        }\n\n        SetupNotificationContent(notification, data);\n        return notification;\n    }\n\n    private GameObject CreateDefaultNotification()\n    {\n        GameObject notification = new GameObject(\"Notification\");\n        notification.transform.SetParent(_notificationContainer);\n\n        RectTransform rect = notification.AddComponent<RectTransform>();\n        rect.sizeDelta = new Vector2(350f, 80f);\n\n        Image background = notification.AddComponent<Image>();\n        background.color = Color.white;\n\n        // Title\n        GameObject titleGO = new GameObject(\"Title\");\n        titleGO.transform.SetParent(notification.transform);\n        RectTransform titleRect = titleGO.AddComponent<RectTransform>();\n        titleRect.anchorMin = new Vector2(0.1f, 0.6f);\n        titleRect.anchorMax = new Vector2(0.9f, 0.9f);\n        titleRect.offsetMin = Vector2.zero;\n        titleRect.offsetMax = Vector2.zero;\n\n        TextMeshProUGUI titleText = titleGO.AddComponent<TextMeshProUGUI>();\n        titleText.text = \"\";\n        titleText.fontSize = 14f;\n        titleText.fontStyle = FontStyles.Bold;\n        titleText.color = Color.black;\n\n        // Message\n        GameObject messageGO = new GameObject(\"Message\");\n        messageGO.transform.SetParent(notification.transform);\n        RectTransform messageRect = messageGO.AddComponent<RectTransform>();\n        messageRect.anchorMin = new Vector2(0.1f, 0.1f);\n        messageRect.anchorMax = new Vector2(0.9f, 0.6f);\n        messageRect.offsetMin = Vector2.zero;\n        messageRect.offsetMax = Vector2.zero;\n\n        TextMeshProUGUI messageText = messageGO.AddComponent<TextMeshProUGUI>();\n        messageText.text = \"\";\n        messageText.fontSize = 12f;\n        messageText.color = Color.black;\n\n        // Icon\n        GameObject iconGO = new GameObject(\"Icon\");\n        iconGO.transform.SetParent(notification.transform);\n        RectTransform iconRect = iconGO.AddComponent<RectTransform>();\n        iconRect.anchorMin = new Vector2(0.02f, 0.2f);\n        iconRect.anchorMax = new Vector2(0.08f, 0.8f);\n        iconRect.offsetMin = Vector2.zero;\n        iconRect.offsetMax = Vector2.zero;\n\n        Image iconImage = iconGO.AddComponent<Image>();\n        iconImage.color = Color.white;\n\n        // Close button\n        GameObject closeGO = new GameObject(\"CloseButton\");\n        closeGO.transform.SetParent(notification.transform);\n        RectTransform closeRect = closeGO.AddComponent<RectTransform>();\n        closeRect.anchorMin = new Vector2(0.92f, 0.7f);\n        closeRect.anchorMax = new Vector2(0.98f, 0.9f);\n        closeRect.offsetMin = Vector2.zero;\n        closeRect.offsetMax = Vector2.zero;\n\n        Button closeButton = closeGO.AddComponent<Button>();\n        Image closeImage = closeGO.AddComponent<Image>();\n        closeImage.color = new Color(0.8f, 0.2f, 0.2f, 0.8f);\n\n        closeButton.onClick.AddListener(() => StartCoroutine(CloseNotification(notification)));\n\n        return notification;\n    }\n\n    private void SetupNotificationContent(GameObject notification, NotificationData data)\n    {\n        // Set background color\n        Image background = notification.GetComponent<Image>();\n        if (background != null)\n            background.color = data.backgroundColor;\n\n        // Set title\n        TextMeshProUGUI titleText = notification.transform.Find(\"Title\")?.GetComponent<TextMeshProUGUI>();\n        if (titleText != null)\n        {\n            titleText.text = data.title;\n            if (_typeSettingsDict.ContainsKey(data.type))\n                titleText.color = _typeSettingsDict[data.type].textColor;\n        }\n\n        // Set message\n        TextMeshProUGUI messageText = notification.transform.Find(\"Message\")?.GetComponent<TextMeshProUGUI>();\n        if (messageText != null)\n        {\n            messageText.text = data.message;\n            if (_typeSettingsDict.ContainsKey(data.type))\n                messageText.color = _typeSettingsDict[data.type].textColor;\n        }\n\n        // Set icon\n        Image iconImage = notification.transform.Find(\"Icon\")?.GetComponent<Image>();\n        if (iconImage != null)\n        {\n            if (data.icon != null)\n            {\n                iconImage.sprite = data.icon;\n                iconImage.gameObject.SetActive(true);\n            }\n            else\n            {\n                iconImage.gameObject.SetActive(false);\n            }\n        }\n    }\n\n    private IEnumerator AnimateNotificationIn(GameObject notification)\n    {\n        RectTransform rect = notification.GetComponent<RectTransform>();\n        Vector2 targetPosition = rect.anchoredPosition;\n        Vector2 startPosition = targetPosition + _slideOffset;\n        \n        rect.anchoredPosition = startPosition;\n        \n        float elapsed = 0f;\n        while (elapsed < _animationDuration)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _animationDuration;\n            float curveValue = _slideInCurve.Evaluate(progress);\n            \n            rect.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, curveValue);\n            \n            yield return null;\n        }\n        \n        rect.anchoredPosition = targetPosition;\n    }\n\n    private IEnumerator AnimateNotificationOut(GameObject notification)\n    {\n        if (notification == null)\n            yield break;\n\n        RectTransform rect = notification.GetComponent<RectTransform>();\n        Vector2 startPosition = rect.anchoredPosition;\n        Vector2 targetPosition = startPosition + _slideOffset;\n        \n        float elapsed = 0f;\n        while (elapsed < _animationDuration && notification != null)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / _animationDuration;\n            float curveValue = _slideOutCurve.Evaluate(progress);"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AmmoBox\",\n  \"components\": [\n    \"BoxCollider\",\n    \"MeshRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"ammoAmount\",\n      \"type\": \"int\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"refillSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isUsed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"respawnTime\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"refill_ammo\",\n      \"trigger\": \"when player touches the ammo box and box is not used\",\n      \"actions\": [\n        {\n          \"action\": \"add ammo amount to player weapon\"\n        },\n        {\n          \"action\": \"play refill sound effect\"\n        },\n        {\n          \"action\": \"mark box as used\"\n        },\n        {\n          \"action\": \"hide the ammo box visually\"\n        },\n        {\n          \"action\": \"disable collision detection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respawn_ammo_box\",\n      \"trigger\": \"when respawn time has elapsed after being used\",\n      \"actions\": [\n        {\n          \"action\": \"mark box as not used\"\n        },\n        {\n          \"action\": \"show the ammo box visually\"\n        },\n        {\n          \"action\": \"enable collision detection\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AmmoBox : MonoBehaviour\n{\n    [System.Serializable]\n    public class AmmoRefillEvent : UnityEvent<int> { }\n    \n    [System.Serializable]\n    public class AmmoType\n    {\n        public string ammoName = \"Bullets\";\n        public int refillAmount = 30;\n        public bool unlimitedRefills = false;\n        public int maxRefills = 1;\n        [HideInInspector] public int currentRefills = 0;\n    }\n    \n    [Header(\"Ammo Configuration\")]\n    [SerializeField] private AmmoType[] _ammoTypes = new AmmoType[] { new AmmoType() };\n    [SerializeField] private bool _refillAllAmmoTypes = true;\n    [SerializeField] private float _refillCooldown = 1f;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool _requireKeyPress = false;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _visualEffect;\n    [SerializeField] private AudioClip _refillSound;\n    [SerializeField] private ParticleSystem _refillParticles;\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _refillAnimationTrigger = \"Refill\";\n    \n    [Header(\"Auto Destruction\")]\n    [SerializeField] private bool _destroyWhenEmpty = true;\n    [SerializeField] private float _destroyDelay = 0.5f;\n    \n    [Header(\"Events\")]\n    public AmmoRefillEvent OnAmmoRefilled;\n    public UnityEvent OnAmmoBoxEmpty;\n    public UnityEvent OnPlayerInRange;\n    public UnityEvent OnPlayerOutOfRange;\n    \n    private AudioSource _audioSource;\n    private bool _playerInRange = false;\n    private GameObject _currentPlayer;\n    private float _lastRefillTime = -1f;\n    private bool _isEmpty = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null && _refillSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        // Initialize refill counters\n        foreach (var ammoType in _ammoTypes)\n        {\n            ammoType.currentRefills = 0;\n        }\n        \n        // Ensure we have a collider for trigger detection\n        Collider col = GetComponent<Collider>();\n        if (col == null)\n        {\n            col = gameObject.AddComponent<BoxCollider>();\n        }\n        col.isTrigger = true;\n    }\n    \n    private void Update()\n    {\n        if (_isEmpty) return;\n        \n        if (_requireKeyPress && _playerInRange && _currentPlayer != null)\n        {\n            if (Input.GetKeyDown(_interactionKey))\n            {\n                TryRefillAmmo(_currentPlayer);\n            }\n        }\n        \n        // Check if player is still in range when using key interaction\n        if (_requireKeyPress && _currentPlayer != null)\n        {\n            float distance = Vector3.Distance(transform.position, _currentPlayer.transform.position);\n            if (distance > _interactionRange)\n            {\n                OnPlayerExitRange();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isEmpty) return;\n        \n        if (IsPlayer(other.gameObject))\n        {\n            if (_requireKeyPress)\n            {\n                OnPlayerEnterRange(other.gameObject);\n            }\n            else\n            {\n                TryRefillAmmo(other.gameObject);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (IsPlayer(other.gameObject) && _requireKeyPress)\n        {\n            OnPlayerExitRange();\n        }\n    }\n    \n    private bool IsPlayer(GameObject obj)\n    {\n        return obj.CompareTag(\"Player\") && ((_playerLayer.value & (1 << obj.layer)) != 0);\n    }\n    \n    private void OnPlayerEnterRange(GameObject player)\n    {\n        _playerInRange = true;\n        _currentPlayer = player;\n        OnPlayerInRange?.Invoke();\n    }\n    \n    private void OnPlayerExitRange()\n    {\n        _playerInRange = false;\n        _currentPlayer = null;\n        OnPlayerOutOfRange?.Invoke();\n    }\n    \n    private void TryRefillAmmo(GameObject player)\n    {\n        if (_isEmpty || Time.time - _lastRefillTime < _refillCooldown)\n            return;\n        \n        // Find weapon components on player\n        WeaponAmmo[] weapons = player.GetComponentsInChildren<WeaponAmmo>();\n        if (weapons.Length == 0)\n        {\n            // Try to find weapon on player directly\n            WeaponAmmo weapon = player.GetComponent<WeaponAmmo>();\n            if (weapon != null)\n            {\n                weapons = new WeaponAmmo[] { weapon };\n            }\n        }\n        \n        if (weapons.Length == 0) return;\n        \n        bool refillSuccessful = false;\n        \n        foreach (var ammoType in _ammoTypes)\n        {\n            if (!ammoType.unlimitedRefills && ammoType.currentRefills >= ammoType.maxRefills)\n                continue;\n            \n            foreach (var weapon in weapons)\n            {\n                if (_refillAllAmmoTypes || weapon.AmmoTypeName == ammoType.ammoName)\n                {\n                    if (weapon.RefillAmmo(ammoType.refillAmount))\n                    {\n                        refillSuccessful = true;\n                        ammoType.currentRefills++;\n                        OnAmmoRefilled?.Invoke(ammoType.refillAmount);\n                        \n                        if (!_refillAllAmmoTypes) break;\n                    }\n                }\n            }\n        }\n        \n        if (refillSuccessful)\n        {\n            _lastRefillTime = Time.time;\n            PlayRefillEffects();\n            \n            if (IsEmpty())\n            {\n                HandleEmptyAmmoBox();\n            }\n        }\n    }\n    \n    private void PlayRefillEffects()\n    {\n        if (_refillSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_refillSound);\n        }\n        \n        if (_refillParticles != null)\n        {\n            _refillParticles.Play();\n        }\n        \n        if (_animator != null && !string.IsNullOrEmpty(_refillAnimationTrigger))\n        {\n            _animator.SetTrigger(_refillAnimationTrigger);\n        }\n        \n        if (_visualEffect != null)\n        {\n            _visualEffect.SetActive(true);\n            Invoke(nameof(DisableVisualEffect), 1f);\n        }\n    }\n    \n    private void DisableVisualEffect()\n    {\n        if (_visualEffect != null)\n        {\n            _visualEffect.SetActive(false);\n        }\n    }\n    \n    private bool IsEmpty()\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            if (ammoType.unlimitedRefills || ammoType.currentRefills < ammoType.maxRefills)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private void HandleEmptyAmmoBox()\n    {\n        _isEmpty = true;\n        OnAmmoBoxEmpty?.Invoke();\n        \n        if (_destroyWhenEmpty)\n        {\n            Destroy(gameObject, _destroyDelay);\n        }\n    }\n    \n    public void RefillAmmoBox()\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            ammoType.currentRefills = 0;\n        }\n        _isEmpty = false;\n    }\n    \n    public int GetRemainingRefills(string ammoTypeName)\n    {\n        foreach (var ammoType in _ammoTypes)\n        {\n            if (ammoType.ammoName == ammoTypeName)\n            {\n                if (ammoType.unlimitedRefills) return -1;\n                return ammoType.maxRefills - ammoType.currentRefills;\n            }\n        }\n        return 0;\n    }\n}\n\n[System.Serializable]\npublic class WeaponAmmo : MonoBehaviour\n{\n    [Header(\"Ammo Settings\")]\n    [SerializeField] private string _ammoTypeName = \"Bullets\";\n    [SerializeField] private int _currentAmmo = 30;\n    [SerializeField] private int _maxAmmo = 120;\n    [SerializeField] private int _clipSize = 30;\n    [SerializeField] private int _currentClip = 30;\n    \n    public string AmmoTypeName => _ammoTypeName;\n    public int CurrentAmmo => _currentAmmo;\n    public int MaxAmmo => _maxAmmo;\n    public int CurrentClip => _currentClip;\n    \n    public bool RefillAmmo(int amount)\n    {\n        if (_currentAmmo >= _maxAmmo) return false;\n        \n        int ammoToAdd = Mathf.Min(amount, _maxAmmo - _currentAmmo);\n        _currentAmmo += ammoToAdd;\n        \n        return ammoToAdd > 0;\n    }\n    \n    public bool UseAmmo(int amount = 1)\n    {\n        if (_currentClip < amount) return false;\n        \n        _currentClip -= amount;\n        return true;\n    }\n    \n    public bool Reload()\n    {\n        if (_currentAmmo <= 0 || _currentClip >= _clipSize) return false;\n        \n        int ammoNeeded = _clipSize - _currentClip;\n        int ammoToReload = Mathf.Min(ammoNeeded, _currentAmmo);\n        \n        _currentClip += ammoToReload;\n        _currentAmmo -= ammoToReload;\n        \n        return ammoToReload > 0;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Snake\",\n  \"components\": [\n    \"Rigidbody2D\",\n    \"Collider2D\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slitherSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"biteRange\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"biteDamage\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"biteForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"patrolDistance\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 4.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"slither_patrol\",\n      \"trigger\": \"when no target is detected\",\n      \"actions\": [\n        {\n          \"action\": \"move in a winding serpentine pattern\"\n        },\n        {\n          \"action\": \"play slithering animation\"\n        },\n        {\n          \"action\": \"change direction randomly within patrol area\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_target\",\n      \"trigger\": \"when player or prey enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop patrol behavior\"\n        },\n        {\n          \"action\": \"face toward detected target\"\n        },\n        {\n          \"action\": \"play alert animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_target\",\n      \"trigger\": \"when target is detected and within range\",\n      \"actions\": [\n        {\n          \"action\": \"slither toward target at increased speed\"\n        },\n        {\n          \"action\": \"play aggressive slithering animation\"\n        },\n        {\n          \"action\": \"follow target movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bite_attack\",\n      \"trigger\": \"when target is within bite range\",\n      \"actions\": [\n        {\n          \"action\": \"lunge forward quickly\"\n        },\n        {\n          \"action\": \"play bite animation\"\n        },\n        {\n          \"action\": \"deal damage to target\"\n        },\n        {\n          \"action\": \"apply knockback force to target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"retreat_after_bite\",\n      \"trigger\": \"when bite attack completes\",\n      \"actions\": [\n        {\n          \"action\": \"move backward briefly\"\n        },\n        {\n          \"action\": \"return to chase behavior after short delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_target\",\n      \"trigger\": \"when target moves beyond detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop chasing\"\n        },\n        {\n          \"action\": \"return to patrol behavior\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Snake : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _turnSpeed = 90f;\n    [SerializeField] private float _slitherAmplitude = 0.5f;\n    [SerializeField] private float _slitherFrequency = 2f;\n    \n    [Header(\"Body\")]\n    [SerializeField] private GameObject _bodySegmentPrefab;\n    [SerializeField] private int _initialBodySegments = 5;\n    [SerializeField] private float _segmentSpacing = 0.8f;\n    \n    [Header(\"Bite\")]\n    [SerializeField] private float _biteRange = 1.5f;\n    [SerializeField] private float _biteCooldown = 2f;\n    [SerializeField] private int _biteDamage = 10;\n    [SerializeField] private LayerMask _biteTargetMask = -1;\n    [SerializeField] private AudioClip _biteSound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 5f;\n    [SerializeField] private float _chaseSpeed = 4f;\n    \n    private List<Transform> _bodySegments = new List<Transform>();\n    private List<Vector3> _positionHistory = new List<Vector3>();\n    private Transform _target;\n    private float _lastBiteTime;\n    private float _slitherTime;\n    private Vector3 _wanderDirection;\n    private float _wanderTimer;\n    private AudioSource _audioSource;\n    private bool _isChasing;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        CreateBodySegments();\n        _wanderDirection = transform.forward;\n        _wanderTimer = Random.Range(2f, 5f);\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        HandleMovement();\n        UpdateSlither();\n        UpdateBodySegments();\n        CheckForBite();\n    }\n    \n    private void CreateBodySegments()\n    {\n        if (_bodySegmentPrefab == null) return;\n        \n        for (int i = 0; i < _initialBodySegments; i++)\n        {\n            Vector3 segmentPosition = transform.position - transform.forward * (i + 1) * _segmentSpacing;\n            GameObject segment = Instantiate(_bodySegmentPrefab, segmentPosition, transform.rotation);\n            _bodySegments.Add(segment.transform);\n            _positionHistory.Add(segmentPosition);\n        }\n    }\n    \n    private void DetectTargets()\n    {\n        Collider[] targets = Physics.OverlapSphere(transform.position, _detectionRange, _biteTargetMask);\n        Transform closestTarget = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Collider target in targets)\n        {\n            if (target.transform == transform) continue;\n            \n            float distance = Vector3.Distance(transform.position, target.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = target.transform;\n            }\n        }\n        \n        _target = closestTarget;\n        _isChasing = _target != null;\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 moveDirection;\n        float currentSpeed;\n        \n        if (_isChasing && _target != null)\n        {\n            moveDirection = (_target.position - transform.position).normalized;\n            currentSpeed = _chaseSpeed;\n        }\n        else\n        {\n            _wanderTimer -= Time.deltaTime;\n            if (_wanderTimer <= 0f)\n            {\n                _wanderDirection = Quaternion.Euler(0, Random.Range(-45f, 45f), 0) * transform.forward;\n                _wanderTimer = Random.Range(2f, 5f);\n            }\n            moveDirection = _wanderDirection;\n            currentSpeed = _moveSpeed;\n        }\n        \n        if (moveDirection != Vector3.zero)\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _turnSpeed * Time.deltaTime);\n        }\n        \n        transform.Translate(Vector3.forward * currentSpeed * Time.deltaTime);\n    }\n    \n    private void UpdateSlither()\n    {\n        _slitherTime += Time.deltaTime * _slitherFrequency;\n        float slitherOffset = Mathf.Sin(_slitherTime) * _slitherAmplitude;\n        \n        Vector3 slitherPosition = transform.position + transform.right * slitherOffset;\n        transform.position = slitherPosition;\n        \n        _positionHistory.Insert(0, transform.position);\n        \n        int maxHistoryLength = _bodySegments.Count * 5;\n        if (_positionHistory.Count > maxHistoryLength)\n        {\n            _positionHistory.RemoveRange(maxHistoryLength, _positionHistory.Count - maxHistoryLength);\n        }\n    }\n    \n    private void UpdateBodySegments()\n    {\n        for (int i = 0; i < _bodySegments.Count; i++)\n        {\n            if (_bodySegments[i] == null) continue;\n            \n            int historyIndex = (i + 1) * 5;\n            if (historyIndex < _positionHistory.Count)\n            {\n                Vector3 targetPosition = _positionHistory[historyIndex];\n                _bodySegments[i].position = Vector3.Lerp(_bodySegments[i].position, targetPosition, Time.deltaTime * 10f);\n                \n                if (historyIndex + 5 < _positionHistory.Count)\n                {\n                    Vector3 direction = (_positionHistory[historyIndex] - _positionHistory[historyIndex + 5]).normalized;\n                    if (direction != Vector3.zero)\n                    {\n                        _bodySegments[i].rotation = Quaternion.LookRotation(direction);\n                    }\n                }\n            }\n        }\n    }\n    \n    private void CheckForBite()\n    {\n        if (Time.time - _lastBiteTime < _biteCooldown) return;\n        if (_target == null) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        if (distanceToTarget <= _biteRange)\n        {\n            Vector3 directionToTarget = (_target.position - transform.position).normalized;\n            float angle = Vector3.Angle(transform.forward, directionToTarget);\n            \n            if (angle < 45f)\n            {\n                PerformBite();\n            }\n        }\n    }\n    \n    private void PerformBite()\n    {\n        _lastBiteTime = Time.time;\n        \n        if (_biteSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_biteSound);\n        }\n        \n        if (_target != null)\n        {\n            if (_target.CompareTag(\"Player\"))\n            {\n                _target.SendMessage(\"TakeDamage\", _biteDamage, SendMessageOptions.DontRequireReceiver);\n            }\n            \n            Rigidbody targetRb = _target.GetComponent<Rigidbody>();\n            if (targetRb != null)\n            {\n                Vector3 knockbackDirection = (_target.position - transform.position).normalized;\n                targetRb.AddForce(knockbackDirection * 5f, ForceMode.Impulse);\n            }\n        }\n        \n        transform.position += transform.forward * 0.3f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _biteRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_target != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(transform.position, _target.position);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _target = other.transform;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HealthBar\",\n  \"components\": [\n    \"Image\",\n    \"Canvas\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fillImage\",\n      \"type\": \"Image\",\n      \"default\": null\n    },\n    {\n      \"name\": \"backgroundColor\",\n      \"type\": \"Image\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"update_health_display\",\n      \"trigger\": \"when current health value changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate health percentage based on current health and maximum health\"\n        },\n        {\n          \"action\": \"adjust fill image width to match health percentage\"\n        },\n        {\n          \"action\": \"change fill color to red when health is low\"\n        },\n        {\n          \"action\": \"change fill color to yellow when health is medium\"\n        },\n        {\n          \"action\": \"change fill color to green when health is high\"\n        }\n      ]\n    },\n    {\n      \"name\": \"smooth_health_transition\",\n      \"trigger\": \"when health bar needs to update visually\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly animate fill bar to new health percentage\"\n        },\n        {\n          \"action\": \"play visual effect when health decreases\"\n        },\n        {\n          \"action\": \"flash red briefly when taking damage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_health_bar\",\n      \"trigger\": \"when health bar starts\",\n      \"actions\": [\n        {\n          \"action\": \"set fill image to full width\"\n        },\n        {\n          \"action\": \"set initial color based on starting health\"\n        },\n        {\n          \"action\": \"position health bar in correct screen location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class HealthBar : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Slider _healthSlider;\n    [SerializeField] private Image _fillImage;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private Color _healthyColor = Color.green;\n    [SerializeField] private Color _warningColor = Color.yellow;\n    [SerializeField] private Color _criticalColor = Color.red;\n    [SerializeField] private float _warningThreshold = 0.6f;\n    [SerializeField] private float _criticalThreshold = 0.3f;\n    \n    [Header(\"Animation Settings\")]\n    [SerializeField] private bool _useSmoothing = true;\n    [SerializeField] private float _smoothSpeed = 5f;\n    [SerializeField] private bool _usePulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private float _pulseIntensity = 0.3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnHealthChanged;\n    public UnityEvent OnHealthDepleted;\n    public UnityEvent OnHealthCritical;\n    \n    private float _targetHealth;\n    private bool _isInitialized = false;\n    private float _originalAlpha;\n    \n    void Start()\n    {\n        InitializeHealthBar();\n    }\n    \n    void Update()\n    {\n        if (!_isInitialized) return;\n        \n        UpdateHealthBarVisual();\n        UpdateColorBasedOnHealth();\n        \n        if (_usePulseEffect && GetHealthPercentage() <= _criticalThreshold)\n        {\n            ApplyPulseEffect();\n        }\n    }\n    \n    private void InitializeHealthBar()\n    {\n        _currentHealth = _maxHealth;\n        _targetHealth = _maxHealth;\n        \n        if (_healthSlider == null)\n            _healthSlider = GetComponent<Slider>();\n            \n        if (_fillImage == null && _healthSlider != null)\n            _fillImage = _healthSlider.fillRect?.GetComponent<Image>();\n            \n        if (_backgroundImage == null && _healthSlider != null)\n            _backgroundImage = _healthSlider.GetComponent<Image>();\n        \n        if (_healthSlider != null)\n        {\n            _healthSlider.maxValue = _maxHealth;\n            _healthSlider.value = _currentHealth;\n        }\n        \n        if (_fillImage != null)\n        {\n            _originalAlpha = _fillImage.color.a;\n        }\n        \n        _isInitialized = true;\n    }\n    \n    private void UpdateHealthBarVisual()\n    {\n        if (_healthSlider == null) return;\n        \n        if (_useSmoothing)\n        {\n            _healthSlider.value = Mathf.Lerp(_healthSlider.value, _targetHealth, Time.deltaTime * _smoothSpeed);\n        }\n        else\n        {\n            _healthSlider.value = _targetHealth;\n        }\n    }\n    \n    private void UpdateColorBasedOnHealth()\n    {\n        if (_fillImage == null) return;\n        \n        float healthPercentage = GetHealthPercentage();\n        Color targetColor;\n        \n        if (healthPercentage > _warningThreshold)\n        {\n            targetColor = _healthyColor;\n        }\n        else if (healthPercentage > _criticalThreshold)\n        {\n            targetColor = _warningColor;\n        }\n        else\n        {\n            targetColor = _criticalColor;\n        }\n        \n        _fillImage.color = targetColor;\n    }\n    \n    private void ApplyPulseEffect()\n    {\n        if (_fillImage == null) return;\n        \n        float pulse = Mathf.Sin(Time.time * _pulseSpeed) * _pulseIntensity;\n        float alpha = _originalAlpha + pulse;\n        alpha = Mathf.Clamp01(alpha);\n        \n        Color currentColor = _fillImage.color;\n        currentColor.a = alpha;\n        _fillImage.color = currentColor;\n    }\n    \n    public void SetMaxHealth(float maxHealth)\n    {\n        _maxHealth = Mathf.Max(1f, maxHealth);\n        _currentHealth = Mathf.Min(_currentHealth, _maxHealth);\n        _targetHealth = _currentHealth;\n        \n        if (_healthSlider != null)\n        {\n            _healthSlider.maxValue = _maxHealth;\n        }\n        \n        OnHealthChanged?.Invoke();\n    }\n    \n    public void SetHealth(float health)\n    {\n        float previousHealth = _currentHealth;\n        _currentHealth = Mathf.Clamp(health, 0f, _maxHealth);\n        _targetHealth = _currentHealth;\n        \n        if (previousHealth != _currentHealth)\n        {\n            OnHealthChanged?.Invoke();\n            \n            if (_currentHealth <= 0f && previousHealth > 0f)\n            {\n                OnHealthDepleted?.Invoke();\n            }\n            else if (_currentHealth <= _maxHealth * _criticalThreshold && previousHealth > _maxHealth * _criticalThreshold)\n            {\n                OnHealthCritical?.Invoke();\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        SetHealth(_currentHealth - damage);\n    }\n    \n    public void Heal(float healAmount)\n    {\n        SetHealth(_currentHealth + healAmount);\n    }\n    \n    public void RestoreToFull()\n    {\n        SetHealth(_maxHealth);\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _maxHealth > 0 ? _currentHealth / _maxHealth : 0f;\n    }\n    \n    public bool IsHealthFull()\n    {\n        return _currentHealth >= _maxHealth;\n    }\n    \n    public bool IsHealthEmpty()\n    {\n        return _currentHealth <= 0f;\n    }\n    \n    public bool IsHealthCritical()\n    {\n        return GetHealthPercentage() <= _criticalThreshold;\n    }\n    \n    void OnValidate()\n    {\n        _maxHealth = Mathf.Max(1f, _maxHealth);\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        _warningThreshold = Mathf.Clamp01(_warningThreshold);\n        _criticalThreshold = Mathf.Clamp01(_criticalThreshold);\n        _smoothSpeed = Mathf.Max(0.1f, _smoothSpeed);\n        _pulseSpeed = Mathf.Max(0.1f, _pulseSpeed);\n        _pulseIntensity = Mathf.Clamp01(_pulseIntensity);\n        \n        if (_criticalThreshold > _warningThreshold)\n        {\n            _criticalThreshold = _warningThreshold;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MimicChest\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"pushForce\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"smallMimicPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lidObject\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"eyesObject\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isRevealed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hasBeenTriggered\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"reveal_mimic\",\n      \"trigger\": \"when player enters detection range and mimic has not been revealed\",\n      \"actions\": [\n        {\n          \"action\": \"slowly open the chest lid\"\n        },\n        {\n          \"action\": \"make glowing eyes visible and start glowing animation\"\n        },\n        {\n          \"action\": \"play ominous reveal sound\"\n        },\n        {\n          \"action\": \"set revealed state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"snap_and_push\",\n      \"trigger\": \"when player touches the mimic chest\",\n      \"actions\": [\n        {\n          \"action\": \"quickly snap the lid shut\"\n        },\n        {\n          \"action\": \"hide the glowing eyes\"\n        },\n        {\n          \"action\": \"apply strong pushing force away from chest toward player\"\n        },\n        {\n          \"action\": \"play loud snapping sound\"\n        },\n        {\n          \"action\": \"set triggered state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spawn_mini_mimics\",\n      \"trigger\": \"when mimic has been triggered and touched\",\n      \"actions\": [\n        {\n          \"action\": \"spawn three smaller mimic objects around the chest\"\n        },\n        {\n          \"action\": \"make each spawned mimic start chasing the player\"\n        },\n        {\n          \"action\": \"play spawning sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MimicChest : MonoBehaviour\n{\n    [Header(\"Detection\")]\n    [SerializeField] private float _detectionRange = 3f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Components\")]\n    [SerializeField] private Transform _lidTransform;\n    [SerializeField] private GameObject _eyesObject;\n    [SerializeField] private Light _eyeGlow;\n    [SerializeField] private float _lidOpenAngle = 45f;\n    [SerializeField] private float _lidAnimationSpeed = 2f;\n    \n    [Header(\"Attack\")]\n    [SerializeField] private float _pushForce = 15f;\n    [SerializeField] private float _pushRadius = 2f;\n    [SerializeField] private float _snapSpeed = 5f;\n    \n    [Header(\"Minion Spawning\")]\n    [SerializeField] private GameObject _miniMimicPrefab;\n    [SerializeField] private int _spawnCount = 3;\n    [SerializeField] private float _spawnRadius = 2f;\n    [SerializeField] private float _spawnHeight = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _revealSound;\n    [SerializeField] private AudioClip _snapSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    private bool _isRevealed = false;\n    private bool _hasAttacked = false;\n    private Transform _playerTransform;\n    private Quaternion _lidClosedRotation;\n    private Quaternion _lidOpenRotation;\n    private Coroutine _lidAnimationCoroutine;\n    private List<GameObject> _spawnedMinions = new List<GameObject>();\n    \n    private void Start()\n    {\n        if (_lidTransform != null)\n        {\n            _lidClosedRotation = _lidTransform.localRotation;\n            _lidOpenRotation = _lidClosedRotation * Quaternion.Euler(-_lidOpenAngle, 0, 0);\n        }\n        \n        if (_eyesObject != null)\n            _eyesObject.SetActive(false);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = false;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        if (_hasAttacked) return;\n        \n        FindPlayer();\n        \n        if (_playerTransform != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n            \n            if (!_isRevealed && distanceToPlayer <= _detectionRange)\n            {\n                RevealMimic();\n            }\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n    }\n    \n    private void RevealMimic()\n    {\n        _isRevealed = true;\n        \n        if (_eyesObject != null)\n            _eyesObject.SetActive(true);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = true;\n            \n        if (_lidAnimationCoroutine != null)\n            StopCoroutine(_lidAnimationCoroutine);\n            \n        _lidAnimationCoroutine = StartCoroutine(AnimateLid(_lidOpenRotation));\n        \n        PlaySound(_revealSound);\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasAttacked) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            Attack(other);\n        }\n    }\n    \n    private void OnMouseDown()\n    {\n        if (_hasAttacked) return;\n        \n        Collider playerCollider = FindObjectOfType<Collider>();\n        if (playerCollider != null && playerCollider.CompareTag(\"Player\"))\n        {\n            Attack(playerCollider);\n        }\n    }\n    \n    private void Attack(Collider playerCollider)\n    {\n        _hasAttacked = true;\n        \n        StartCoroutine(AttackSequence(playerCollider));\n    }\n    \n    private IEnumerator AttackSequence(Collider playerCollider)\n    {\n        // Snap shut\n        if (_lidAnimationCoroutine != null)\n            StopCoroutine(_lidAnimationCoroutine);\n            \n        _lidAnimationCoroutine = StartCoroutine(AnimateLid(_lidClosedRotation, _snapSpeed));\n        \n        PlaySound(_snapSound);\n        \n        // Hide eyes\n        if (_eyesObject != null)\n            _eyesObject.SetActive(false);\n            \n        if (_eyeGlow != null)\n            _eyeGlow.enabled = false;\n        \n        yield return new WaitForSeconds(0.2f);\n        \n        // Push player away\n        PushPlayerAway(playerCollider);\n        \n        yield return new WaitForSeconds(0.3f);\n        \n        // Spawn minions\n        SpawnMinions();\n    }\n    \n    private void PushPlayerAway(Collider playerCollider)\n    {\n        Rigidbody playerRb = playerCollider.GetComponent<Rigidbody>();\n        if (playerRb != null)\n        {\n            Vector3 pushDirection = (playerCollider.transform.position - transform.position).normalized;\n            pushDirection.y = 0.3f; // Add slight upward force\n            \n            playerRb.AddForce(pushDirection * _pushForce, ForceMode.Impulse);\n        }\n        \n        // Also push any other rigidbodies in range\n        Collider[] nearbyObjects = Physics.OverlapSphere(transform.position, _pushRadius);\n        foreach (Collider col in nearbyObjects)\n        {\n            if (col != playerCollider && col.attachedRigidbody != null && !col.CompareTag(\"MiniMimic\"))\n            {\n                Vector3 pushDirection = (col.transform.position - transform.position).normalized;\n                col.attachedRigidbody.AddForce(pushDirection * (_pushForce * 0.5f), ForceMode.Impulse);\n            }\n        }\n    }\n    \n    private void SpawnMinions()\n    {\n        if (_miniMimicPrefab == null) return;\n        \n        PlaySound(_spawnSound);\n        \n        for (int i = 0; i < _spawnCount; i++)\n        {\n            float angle = (360f / _spawnCount) * i;\n            Vector3 spawnOffset = new Vector3(\n                Mathf.Cos(angle * Mathf.Deg2Rad) * _spawnRadius,\n                _spawnHeight,\n                Mathf.Sin(angle * Mathf.Deg2Rad) * _spawnRadius\n            );\n            \n            Vector3 spawnPosition = transform.position + spawnOffset;\n            \n            GameObject minion = Instantiate(_miniMimicPrefab, spawnPosition, Quaternion.identity);\n            _spawnedMinions.Add(minion);\n            \n            // Add chase behavior to minion\n            MiniMimicChaser chaser = minion.GetComponent<MiniMimicChaser>();\n            if (chaser == null)\n                chaser = minion.AddComponent<MiniMimicChaser>();\n        }\n    }\n    \n    private IEnumerator AnimateLid(Quaternion targetRotation, float speed = -1f)\n    {\n        if (_lidTransform == null) yield break;\n        \n        float animSpeed = speed > 0 ? speed : _lidAnimationSpeed;\n        Quaternion startRotation = _lidTransform.localRotation;\n        float elapsed = 0f;\n        float duration = 1f / animSpeed;\n        \n        while (elapsed < duration)\n        {\n            elapsed += Time.deltaTime;\n            float t = elapsed / duration;\n            _lidTransform.localRotation = Quaternion.Slerp(startRotation, targetRotation, t);\n            yield return null;\n        }\n        \n        _lidTransform.localRotation = targetRotation;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _pushRadius);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _spawnRadius);\n    }\n}\n\npublic class MiniMimicChaser : MonoBehaviour\n{\n    [Header(\"Chase Behavior\")]\n    [SerializeField] private float _chaseSpeed = 3f;\n    [SerializeField] private float _jumpForce = 5f;\n    [SerializeField] private float _jumpCooldown = 2f;\n    [SerializeField] private float _attackRange = 1f;\n    [SerializeField] private float _lifetime = 30f;\n    \n    private Transform _playerTransform;\n    private Rigidbody _rigidbody;\n    private float _lastJumpTime;\n    private bool _isGrounded = true;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        gameObject.tag = \"MiniMimic\";\n        \n        FindPlayer();\n        \n        Destroy(gameObject, _lifetime);\n    }\n    \n    private void Update()\n    {\n        FindPlayer();\n        \n        if (_playerTransform != null)\n        {\n            ChasePlayer();\n        }\n    }\n    \n    private void FindPlayer()\n    {\n        if (_playerTransform == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n                _playerTransform = player.transform;\n        }\n    }\n    \n    private void ChasePlayer()\n    {\n        Vector3 directionToPlayer = (_playerTransform.position - transform.position).normalized;\n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        if (distanceToPlayer > _attackRange)\n        {\n            // Move towards player\n            Vector3 moveDirection = new Vector3(directionToPlayer.x, 0, directionToPlayer.z);\n            transform.position += moveDirection * _chaseSpeed * Time.deltaTime;\n            \n            // Look at player\n            transform.LookAt(new Vector3(_playerTransform.position.x, transform.position.y, _playerTransform.position.z));\n            \n            // Jump if grounded and cooldown elapsed\n            if (_isGrounded && Time.time - _lastJumpTime > _jumpCooldown)\n            {\n                Jump();\n            }\n        }\n    }\n    \n    private void Jump()\n    {\n        if (_rigidbody != null)\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n            _lastJumpTime = Time.time;\n            _isGrounded = false;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Ground\") || collision.contacts[0].normal.y > 0.7f)\n        {\n            _isGrounded = true;\n        }\n        \n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            // Mini attack - small push\n            Rigidbody playerRb = collision.rigidbody;\n            if (playerRb != null)\n            {\n                Vector3 pushDirection = (collision.transform.position - transform.position).normalized;\n                playerRb.AddForce(pushDirection * 3f, ForceMode.Impulse);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VictoryCelebration\",\n  \"components\": [\n    \"Transform\",\n    \"Animator\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"celebrationDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"jumpHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"spinSpeed\",\n      \"type\": \"float\",\n      \"default\": 360.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_celebration\",\n      \"trigger\": \"when victory condition is met\",\n      \"actions\": [\n        {\n          \"action\": \"activate celebration mode\"\n        },\n        {\n          \"action\": \"play victory animation\"\n        },\n        {\n          \"action\": \"play celebration sound effect\"\n        },\n        {\n          \"action\": \"start particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"celebration_movement\",\n      \"trigger\": \"while celebration is active\",\n      \"actions\": [\n        {\n          \"action\": \"jump up and down repeatedly\"\n        },\n        {\n          \"action\": \"spin around continuously\"\n        },\n        {\n          \"action\": \"emit sparkle particles\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_celebration\",\n      \"trigger\": \"when celebration duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"stop victory animation\"\n        },\n        {\n          \"action\": \"fade out particle effects\"\n        },\n        {\n          \"action\": \"return to idle state\"\n        },\n        {\n          \"action\": \"deactivate celebration mode\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class VictoryCelebration : MonoBehaviour\n{\n    [Header(\"Victory Trigger\")]\n    [SerializeField] private bool _triggerOnStart = false;\n    [SerializeField] private KeyCode _testKey = KeyCode.V;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem[] _confettiSystems;\n    [SerializeField] private ParticleSystem[] _fireworkSystems;\n    [SerializeField] private Light[] _celebrationLights;\n    [SerializeField] private Color _lightColor = Color.yellow;\n    [SerializeField] private float _lightIntensity = 2f;\n    [SerializeField] private float _lightFlashSpeed = 5f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _victoryMusic;\n    [SerializeField] private AudioClip[] _cheerSounds;\n    [SerializeField] private float _musicVolume = 0.8f;\n    [SerializeField] private float _cheerVolume = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator[] _celebrationAnimators;\n    [SerializeField] private string _victoryTrigger = \"Victory\";\n    [SerializeField] private Transform[] _bouncingObjects;\n    [SerializeField] private float _bounceHeight = 2f;\n    [SerializeField] private float _bounceSpeed = 3f;\n    \n    [Header(\"Camera Effects\")]\n    [SerializeField] private Camera _mainCamera;\n    [SerializeField] private bool _enableCameraShake = true;\n    [SerializeField] private float _shakeIntensity = 0.5f;\n    [SerializeField] private float _shakeDuration = 2f;\n    \n    [Header(\"UI Elements\")]\n    [SerializeField] private GameObject _victoryPanel;\n    [SerializeField] private CanvasGroup _victoryCanvasGroup;\n    [SerializeField] private float _uiFadeSpeed = 2f;\n    \n    [Header(\"Timing\")]\n    [SerializeField] private float _celebrationDuration = 10f;\n    [SerializeField] private float _delayBeforeStart = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnVictoryStart;\n    public UnityEvent OnVictoryEnd;\n    \n    private bool _isActive = false;\n    private Vector3[] _originalPositions;\n    private Color[] _originalLightColors;\n    private float[] _originalLightIntensities;\n    private Vector3 _originalCameraPosition;\n    private Coroutine _celebrationCoroutine;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        \n        if (_triggerOnStart)\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(_testKey))\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        StoreOriginalValues();\n        \n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(false);\n            \n        if (_victoryCanvasGroup != null)\n            _victoryCanvasGroup.alpha = 0f;\n    }\n    \n    private void StoreOriginalValues()\n    {\n        if (_bouncingObjects != null && _bouncingObjects.Length > 0)\n        {\n            _originalPositions = new Vector3[_bouncingObjects.Length];\n            for (int i = 0; i < _bouncingObjects.Length; i++)\n            {\n                if (_bouncingObjects[i] != null)\n                    _originalPositions[i] = _bouncingObjects[i].position;\n            }\n        }\n        \n        if (_celebrationLights != null && _celebrationLights.Length > 0)\n        {\n            _originalLightColors = new Color[_celebrationLights.Length];\n            _originalLightIntensities = new float[_celebrationLights.Length];\n            \n            for (int i = 0; i < _celebrationLights.Length; i++)\n            {\n                if (_celebrationLights[i] != null)\n                {\n                    _originalLightColors[i] = _celebrationLights[i].color;\n                    _originalLightIntensities[i] = _celebrationLights[i].intensity;\n                }\n            }\n        }\n        \n        if (_mainCamera != null)\n            _originalCameraPosition = _mainCamera.transform.position;\n    }\n    \n    public void StartCelebration()\n    {\n        if (_isActive) return;\n        \n        _isActive = true;\n        \n        if (_celebrationCoroutine != null)\n            StopCoroutine(_celebrationCoroutine);\n            \n        _celebrationCoroutine = StartCoroutine(CelebrationSequence());\n    }\n    \n    public void StopCelebration()\n    {\n        if (!_isActive) return;\n        \n        if (_celebrationCoroutine != null)\n        {\n            StopCoroutine(_celebrationCoroutine);\n            _celebrationCoroutine = null;\n        }\n        \n        StartCoroutine(EndCelebration());\n    }\n    \n    private IEnumerator CelebrationSequence()\n    {\n        OnVictoryStart?.Invoke();\n        \n        yield return new WaitForSeconds(_delayBeforeStart);\n        \n        StartParticleEffects();\n        StartAudioEffects();\n        StartAnimations();\n        StartLightEffects();\n        StartUIEffects();\n        \n        if (_enableCameraShake && _mainCamera != null)\n            StartCoroutine(CameraShake());\n            \n        StartCoroutine(BouncingAnimation());\n        \n        yield return new WaitForSeconds(_celebrationDuration);\n        \n        yield return StartCoroutine(EndCelebration());\n    }\n    \n    private void StartParticleEffects()\n    {\n        if (_confettiSystems != null)\n        {\n            foreach (var system in _confettiSystems)\n            {\n                if (system != null)\n                    system.Play();\n            }\n        }\n        \n        if (_fireworkSystems != null)\n        {\n            foreach (var system in _fireworkSystems)\n            {\n                if (system != null)\n                    system.Play();\n            }\n        }\n    }\n    \n    private void StartAudioEffects()\n    {\n        if (_audioSource != null)\n        {\n            if (_victoryMusic != null)\n            {\n                _audioSource.clip = _victoryMusic;\n                _audioSource.volume = _musicVolume;\n                _audioSource.loop = true;\n                _audioSource.Play();\n            }\n            \n            if (_cheerSounds != null && _cheerSounds.Length > 0)\n            {\n                StartCoroutine(PlayRandomCheers());\n            }\n        }\n    }\n    \n    private IEnumerator PlayRandomCheers()\n    {\n        while (_isActive)\n        {\n            yield return new WaitForSeconds(Random.Range(1f, 3f));\n            \n            if (_cheerSounds.Length > 0 && _audioSource != null)\n            {\n                AudioClip randomCheer = _cheerSounds[Random.Range(0, _cheerSounds.Length)];\n                if (randomCheer != null)\n                {\n                    _audioSource.PlayOneShot(randomCheer, _cheerVolume);\n                }\n            }\n        }\n    }\n    \n    private void StartAnimations()\n    {\n        if (_celebrationAnimators != null)\n        {\n            foreach (var animator in _celebrationAnimators)\n            {\n                if (animator != null)\n                    animator.SetTrigger(_victoryTrigger);\n            }\n        }\n    }\n    \n    private void StartLightEffects()\n    {\n        if (_celebrationLights != null)\n        {\n            StartCoroutine(FlashLights());\n        }\n    }\n    \n    private IEnumerator FlashLights()\n    {\n        while (_isActive)\n        {\n            foreach (var light in _celebrationLights)\n            {\n                if (light != null)\n                {\n                    light.color = _lightColor;\n                    light.intensity = _lightIntensity * (0.5f + 0.5f * Mathf.Sin(Time.time * _lightFlashSpeed));\n                }\n            }\n            yield return null;\n        }\n    }\n    \n    private void StartUIEffects()\n    {\n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(true);\n            \n        if (_victoryCanvasGroup != null)\n            StartCoroutine(FadeInUI());\n    }\n    \n    private IEnumerator FadeInUI()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _victoryCanvasGroup.alpha;\n        \n        while (elapsedTime < 1f / _uiFadeSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime * _uiFadeSpeed;\n            _victoryCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, progress);\n            yield return null;\n        }\n        \n        _victoryCanvasGroup.alpha = 1f;\n    }\n    \n    private IEnumerator CameraShake()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _shakeDuration && _isActive)\n        {\n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.z = 0f;\n            \n            _mainCamera.transform.position = _originalCameraPosition + randomOffset;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        _mainCamera.transform.position = _originalCameraPosition;\n    }\n    \n    private IEnumerator BouncingAnimation()\n    {\n        if (_bouncingObjects == null || _originalPositions == null) yield break;\n        \n        while (_isActive)\n        {\n            for (int i = 0; i < _bouncingObjects.Length; i++)\n            {\n                if (_bouncingObjects[i] != null && i < _originalPositions.Length)\n                {\n                    float bounce = Mathf.Sin(Time.time * _bounceSpeed + i * 0.5f) * _bounceHeight;\n                    Vector3 newPosition = _originalPositions[i];\n                    newPosition.y += bounce;\n                    _bouncingObjects[i].position = newPosition;\n                }\n            }\n            yield return null;\n        }\n    }\n    \n    private IEnumerator EndCelebration()\n    {\n        _isActive = false;\n        \n        StopParticleEffects();\n        \n        if (_audioSource != null)\n        {\n            float startVolume = _audioSource.volume;\n            float elapsedTime = 0f;\n            float fadeDuration = 2f;\n            \n            while (elapsedTime < fadeDuration)\n            {\n                elapsedTime += Time.deltaTime;\n                _audioSource.volume = Mathf.Lerp(startVolume, 0f, elapsedTime / fadeDuration);\n                yield return null;\n            }\n            \n            _audioSource.Stop();\n            _audioSource.volume = startVolume;\n        }\n        \n        if (_victoryCanvasGroup != null)\n            yield return StartCoroutine(FadeOutUI());\n            \n        if (_victoryPanel != null)\n            _victoryPanel.SetActive(false);\n        \n        RestoreOriginalValues();\n        \n        OnVictoryEnd?.Invoke();\n    }\n    \n    private void StopParticleEffects()\n    {\n        if (_confettiSystems != null)\n        {\n            foreach (var system in _confettiSystems)\n            {\n                if (system != null)\n                    system.Stop();\n            }\n        }\n        \n        if (_fireworkSystems != null)\n        {\n            foreach (var system in _fireworkSystems)\n            {\n                if (system != null)\n                    system.Stop();\n            }\n        }\n    }\n    \n    private IEnumerator FadeOutUI()\n    {\n        float elapsedTime = 0f;\n        float startAlpha = _victoryCanvasGroup.alpha;\n        \n        while (elapsedTime < 1f / _uiFadeSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime * _uiFadeSpeed;\n            _victoryCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, progress);\n            yield return null;\n        }\n        \n        _victoryCanvasGroup.alpha = 0f;\n    }\n    \n    private void RestoreOriginalValues()\n    {\n        if (_bouncingObjects != null && _originalPositions != null)\n        {\n            for (int i = 0; i < _bouncingObjects.Length && i < _originalPositions.Length; i++)\n            {\n                if (_bouncingObjects[i] != null)\n                    _bouncingObjects[i].position = _originalPositions[i];\n            }\n        }\n        \n        if (_celebrationLights != null && _originalLightColors != null && _originalLightIntensities != null)\n        {\n            for (int i = 0; i < _celebrationLights.Length && i < _originalLightColors.Length; i++)\n            {\n                if (_celebrationLights[i] != null)\n                {\n                    _celebrationLights[i].color = _originalLightColors[i];\n                    _celebrationLights[i].intensity = _originalLightIntensities[i];\n                }\n            }\n        }\n        \n        if (_mainCamera != null)\n            _mainCamera.transform.position = _originalCameraPosition;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCelebration();\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_celebrationCoroutine != null)\n        {\n            StopCoroutine(_celebrationCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ManaBar\",\n  \"components\": [\n    \"UI Image\",\n    \"UI Slider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxMana\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentMana\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"manaRegenRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"manaBarSlider\",\n      \"type\": \"Slider\",\n      \"default\": null\n    },\n    {\n      \"name\": \"manaBarFill\",\n      \"type\": \"Image\",\n      \"default\": null\n    },\n    {\n      \"name\": \"lowManaThreshold\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_mana_bar\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set current mana to maximum mana\"\n        },\n        {\n          \"action\": \"update mana bar visual to full\"\n        }\n      ]\n    },\n    {\n      \"name\": \"regenerate_mana\",\n      \"trigger\": \"every frame when current mana is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increase current mana by regeneration rate over time\"\n        },\n        {\n          \"action\": \"clamp current mana to not exceed maximum mana\"\n        },\n        {\n          \"action\": \"update mana bar visual to match current mana percentage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"consume_mana\",\n      \"trigger\": \"when ability is used\",\n      \"actions\": [\n        {\n          \"action\": \"decrease current mana by ability cost\"\n        },\n        {\n          \"action\": \"prevent current mana from going below zero\"\n        },\n        {\n          \"action\": \"update mana bar visual to match current mana percentage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_bar_color_when_low\",\n      \"trigger\": \"when current mana falls below low mana threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change mana bar fill color to red\"\n        }\n      ]\n    },\n    {\n      \"name\": \"restore_normal_color\",\n      \"trigger\": \"when current mana rises above low mana threshold\",\n      \"actions\": [\n        {\n          \"action\": \"change mana bar fill color back to blue\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_mana_availability\",\n      \"trigger\": \"when player attempts to use ability\",\n      \"actions\": [\n        {\n          \"action\": \"check if current mana is sufficient for ability cost\"\n        },\n        {\n          \"action\": \"allow ability use if mana is sufficient\"\n        },\n        {\n          \"action\": \"prevent ability use if mana is insufficient\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class ManaBar : MonoBehaviour\n{\n    [Header(\"Mana Settings\")]\n    [SerializeField] private float _maxMana = 100f;\n    [SerializeField] private float _currentMana = 100f;\n    [SerializeField] private float _manaRegenRate = 5f;\n    [SerializeField] private float _manaRegenDelay = 2f;\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Slider _manaSlider;\n    [SerializeField] private Image _manaFillImage;\n    [SerializeField] private Text _manaText;\n    [SerializeField] private Image _backgroundImage;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _fullManaColor = Color.blue;\n    [SerializeField] private Color _lowManaColor = Color.red;\n    [SerializeField] private Color _emptyManaColor = Color.gray;\n    [SerializeField] private float _lowManaThreshold = 0.25f;\n    [SerializeField] private bool _showManaText = true;\n    [SerializeField] private bool _hideWhenFull = false;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private bool _smoothTransition = true;\n    [SerializeField] private float _transitionSpeed = 5f;\n    [SerializeField] private bool _pulseOnLowMana = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnManaEmpty;\n    public UnityEvent OnManaFull;\n    public UnityEvent<float> OnManaChanged;\n    \n    private float _targetManaValue;\n    private float _lastManaUseTime;\n    private bool _wasEmpty;\n    private bool _wasFull;\n    private CanvasGroup _canvasGroup;\n    \n    public float CurrentMana => _currentMana;\n    public float MaxMana => _maxMana;\n    public float ManaPercentage => _currentMana / _maxMana;\n    public bool HasMana => _currentMana > 0f;\n    public bool IsFullMana => _currentMana >= _maxMana;\n    \n    private void Awake()\n    {\n        InitializeComponents();\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = -_manaRegenDelay;\n    }\n    \n    private void Start()\n    {\n        UpdateManaDisplay();\n        UpdateVisibility();\n    }\n    \n    private void Update()\n    {\n        HandleManaRegeneration();\n        HandleSmoothTransition();\n        HandleLowManaPulse();\n        UpdateManaDisplay();\n        UpdateVisibility();\n        CheckManaEvents();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_manaSlider == null)\n            _manaSlider = GetComponentInChildren<Slider>();\n            \n        if (_manaFillImage == null && _manaSlider != null)\n            _manaFillImage = _manaSlider.fillRect?.GetComponent<Image>();\n            \n        if (_manaText == null)\n            _manaText = GetComponentInChildren<Text>();\n            \n        if (_backgroundImage == null)\n            _backgroundImage = GetComponent<Image>();\n            \n        _canvasGroup = GetComponent<CanvasGroup>();\n        if (_canvasGroup == null && _hideWhenFull)\n            _canvasGroup = gameObject.AddComponent<CanvasGroup>();\n            \n        if (_manaSlider != null)\n        {\n            _manaSlider.minValue = 0f;\n            _manaSlider.maxValue = _maxMana;\n            _manaSlider.wholeNumbers = false;\n        }\n    }\n    \n    private void HandleManaRegeneration()\n    {\n        if (_currentMana < _maxMana && Time.time >= _lastManaUseTime + _manaRegenDelay)\n        {\n            _currentMana += _manaRegenRate * Time.deltaTime;\n            _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n            _targetManaValue = _currentMana;\n        }\n    }\n    \n    private void HandleSmoothTransition()\n    {\n        if (_smoothTransition && _manaSlider != null)\n        {\n            float currentSliderValue = _manaSlider.value;\n            float targetValue = _smoothTransition ? _targetManaValue : _currentMana;\n            \n            if (Mathf.Abs(currentSliderValue - targetValue) > 0.01f)\n            {\n                _manaSlider.value = Mathf.Lerp(currentSliderValue, targetValue, _transitionSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _manaSlider.value = targetValue;\n            }\n        }\n        else if (_manaSlider != null)\n        {\n            _manaSlider.value = _currentMana;\n        }\n    }\n    \n    private void HandleLowManaPulse()\n    {\n        if (_pulseOnLowMana && ManaPercentage <= _lowManaThreshold && _manaFillImage != null)\n        {\n            float alpha = 0.5f + 0.5f * Mathf.Sin(Time.time * _pulseSpeed);\n            Color currentColor = _manaFillImage.color;\n            currentColor.a = alpha;\n            _manaFillImage.color = currentColor;\n        }\n        else if (_manaFillImage != null)\n        {\n            Color currentColor = _manaFillImage.color;\n            currentColor.a = 1f;\n            _manaFillImage.color = currentColor;\n        }\n    }\n    \n    private void UpdateManaDisplay()\n    {\n        UpdateManaColor();\n        UpdateManaText();\n    }\n    \n    private void UpdateManaColor()\n    {\n        if (_manaFillImage == null) return;\n        \n        Color targetColor;\n        float percentage = ManaPercentage;\n        \n        if (percentage <= 0f)\n        {\n            targetColor = _emptyManaColor;\n        }\n        else if (percentage <= _lowManaThreshold)\n        {\n            targetColor = Color.Lerp(_emptyManaColor, _lowManaColor, percentage / _lowManaThreshold);\n        }\n        else\n        {\n            float normalizedHigh = (percentage - _lowManaThreshold) / (1f - _lowManaThreshold);\n            targetColor = Color.Lerp(_lowManaColor, _fullManaColor, normalizedHigh);\n        }\n        \n        if (!_pulseOnLowMana || percentage > _lowManaThreshold)\n        {\n            _manaFillImage.color = targetColor;\n        }\n        else\n        {\n            Color pulseColor = targetColor;\n            pulseColor.a = _manaFillImage.color.a;\n            _manaFillImage.color = pulseColor;\n        }\n    }\n    \n    private void UpdateManaText()\n    {\n        if (_manaText != null && _showManaText)\n        {\n            _manaText.text = $\"{Mathf.Ceil(_currentMana)}/{_maxMana}\";\n        }\n        else if (_manaText != null)\n        {\n            _manaText.text = \"\";\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_canvasGroup != null && _hideWhenFull)\n        {\n            float targetAlpha = IsFullMana ? 0f : 1f;\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, targetAlpha, Time.deltaTime * 3f);\n        }\n    }\n    \n    private void CheckManaEvents()\n    {\n        bool isEmpty = _currentMana <= 0f;\n        bool isFull = _currentMana >= _maxMana;\n        \n        if (isEmpty && !_wasEmpty)\n        {\n            OnManaEmpty?.Invoke();\n            _wasEmpty = true;\n        }\n        else if (!isEmpty)\n        {\n            _wasEmpty = false;\n        }\n        \n        if (isFull && !_wasFull)\n        {\n            OnManaFull?.Invoke();\n            _wasFull = true;\n        }\n        else if (!isFull)\n        {\n            _wasFull = false;\n        }\n        \n        OnManaChanged?.Invoke(_currentMana);\n    }\n    \n    public bool TryUseMana(float amount)\n    {\n        if (_currentMana >= amount)\n        {\n            UseMana(amount);\n            return true;\n        }\n        return false;\n    }\n    \n    public void UseMana(float amount)\n    {\n        _currentMana -= amount;\n        _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = Time.time;\n    }\n    \n    public void RestoreMana(float amount)\n    {\n        _currentMana += amount;\n        _currentMana = Mathf.Clamp(_currentMana, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n    }\n    \n    public void SetMana(float amount)\n    {\n        _currentMana = Mathf.Clamp(amount, 0f, _maxMana);\n        _targetManaValue = _currentMana;\n    }\n    \n    public void SetMaxMana(float newMaxMana)\n    {\n        float percentage = ManaPercentage;\n        _maxMana = Mathf.Max(1f, newMaxMana);\n        _currentMana = _maxMana * percentage;\n        _targetManaValue = _currentMana;\n        \n        if (_manaSlider != null)\n        {\n            _manaSlider.maxValue = _maxMana;\n        }\n    }\n    \n    public void RefillMana()\n    {\n        _currentMana = _maxMana;\n        _targetManaValue = _currentMana;\n    }\n    \n    public void EmptyMana()\n    {\n        _currentMana = 0f;\n        _targetManaValue = _currentMana;\n        _lastManaUseTime = Time.time;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RotatingPuzzleRing\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"targetRotation\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"currentRotation\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isLocked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"correctPosition\",\n      \"type\": \"float\",\n      \"default\": 180\n    },\n    {\n      \"name\": \"tolerance\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"clickSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"solveSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"rotate_ring\",\n      \"trigger\": \"when player clicks on the ring and ring is not locked\",\n      \"actions\": [\n        {\n          \"action\": \"play click sound\"\n        },\n        {\n          \"action\": \"rotate ring by rotation speed amount\"\n        },\n        {\n          \"action\": \"update current rotation value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_solution\",\n      \"trigger\": \"when ring rotation changes\",\n      \"actions\": [\n        {\n          \"action\": \"check if current rotation is within tolerance of correct position\"\n        },\n        {\n          \"action\": \"if position is correct then lock the ring and play solve sound\"\n        },\n        {\n          \"action\": \"if position is correct then change ring color to indicate solved state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"smooth_rotation\",\n      \"trigger\": \"every frame when ring is rotating\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly rotate ring toward target rotation\"\n        },\n        {\n          \"action\": \"stop rotation when target is reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when mouse hovers over ring and ring is not locked\",\n      \"actions\": [\n        {\n          \"action\": \"highlight ring with glow effect\"\n        },\n        {\n          \"action\": \"show rotation indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_ring\",\n      \"trigger\": \"when puzzle is reset\",\n      \"actions\": [\n        {\n          \"action\": \"unlock the ring\"\n        },\n        {\n          \"action\": \"reset rotation to starting position\"\n        },\n        {\n          \"action\": \"restore original ring color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RotatingPuzzleRing : MonoBehaviour\n{\n    [Header(\"Ring Configuration\")]\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _targetAngle = 0f;\n    [SerializeField] private float _angleThreshold = 5f;\n    [SerializeField] private bool _canRotate = true;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _rotateClockwiseKey = KeyCode.E;\n    [SerializeField] private KeyCode _rotateCounterClockwiseKey = KeyCode.Q;\n    [SerializeField] private bool _useMouseInteraction = true;\n    [SerializeField] private float _interactionDistance = 5f;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _correctColor = Color.green;\n    [SerializeField] private Color _highlightColor = Color.yellow;\n    [SerializeField] private Renderer _ringRenderer;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotateSound;\n    [SerializeField] private AudioClip _correctPositionSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCorrectPosition;\n    public UnityEvent OnRotationStart;\n    public UnityEvent OnRotationComplete;\n    \n    private float _currentAngle;\n    private bool _isRotating;\n    private bool _isInCorrectPosition;\n    private bool _isHighlighted;\n    private Camera _playerCamera;\n    private Material _ringMaterial;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_ringRenderer == null)\n            _ringRenderer = GetComponent<Renderer>();\n            \n        if (_ringRenderer != null)\n        {\n            _ringMaterial = _ringRenderer.material;\n            _originalColor = _ringMaterial.color;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        _currentAngle = transform.eulerAngles.z;\n        CheckCorrectPosition();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateRotation();\n        UpdateVisuals();\n    }\n    \n    private void HandleInput()\n    {\n        if (!_canRotate || _isRotating)\n            return;\n            \n        bool rotateClockwise = false;\n        bool rotateCounterClockwise = false;\n        \n        // Keyboard input\n        if (Input.GetKeyDown(_rotateClockwiseKey))\n            rotateClockwise = true;\n        else if (Input.GetKeyDown(_rotateCounterClockwiseKey))\n            rotateCounterClockwise = true;\n            \n        // Mouse interaction\n        if (_useMouseInteraction && Input.GetMouseButtonDown(0))\n        {\n            Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit, _interactionDistance))\n            {\n                if (hit.collider.gameObject == gameObject)\n                {\n                    Vector3 hitPoint = hit.point;\n                    Vector3 centerToHit = hitPoint - transform.position;\n                    Vector3 mouseWorldPos = _playerCamera.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, hit.distance));\n                    \n                    float angle = Vector3.SignedAngle(Vector3.right, centerToHit, Vector3.forward);\n                    if (angle > 0)\n                        rotateClockwise = true;\n                    else\n                        rotateCounterClockwise = true;\n                }\n            }\n        }\n        \n        if (rotateClockwise)\n            StartRotation(90f);\n        else if (rotateCounterClockwise)\n            StartRotation(-90f);\n    }\n    \n    private void StartRotation(float rotationAmount)\n    {\n        if (_isRotating)\n            return;\n            \n        _isRotating = true;\n        _targetAngle = _currentAngle + rotationAmount;\n        \n        // Normalize angle\n        while (_targetAngle >= 360f)\n            _targetAngle -= 360f;\n        while (_targetAngle < 0f)\n            _targetAngle += 360f;\n            \n        OnRotationStart?.Invoke();\n        PlaySound(_rotateSound);\n    }\n    \n    private void UpdateRotation()\n    {\n        if (!_isRotating)\n            return;\n            \n        float step = _rotationSpeed * Time.deltaTime;\n        _currentAngle = Mathf.MoveTowardsAngle(_currentAngle, _targetAngle, step);\n        \n        transform.rotation = Quaternion.Euler(0, 0, _currentAngle);\n        \n        if (Mathf.Abs(Mathf.DeltaAngle(_currentAngle, _targetAngle)) < 0.1f)\n        {\n            _currentAngle = _targetAngle;\n            transform.rotation = Quaternion.Euler(0, 0, _currentAngle);\n            _isRotating = false;\n            \n            OnRotationComplete?.Invoke();\n            CheckCorrectPosition();\n        }\n    }\n    \n    private void CheckCorrectPosition()\n    {\n        float angleDifference = Mathf.Abs(Mathf.DeltaAngle(_currentAngle, 0f));\n        bool wasInCorrectPosition = _isInCorrectPosition;\n        _isInCorrectPosition = angleDifference <= _angleThreshold;\n        \n        if (_isInCorrectPosition && !wasInCorrectPosition)\n        {\n            OnCorrectPosition?.Invoke();\n            PlaySound(_correctPositionSound);\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_ringMaterial == null)\n            return;\n            \n        Color targetColor = _originalColor;\n        \n        if (_isInCorrectPosition)\n            targetColor = _correctColor;\n        else if (_isHighlighted)\n            targetColor = _highlightColor;\n        else\n            targetColor = _normalColor;\n            \n        _ringMaterial.color = Color.Lerp(_ringMaterial.color, targetColor, Time.deltaTime * 5f);\n    }\n    \n    private void OnMouseEnter()\n    {\n        if (_useMouseInteraction && _canRotate)\n        {\n            _isHighlighted = true;\n        }\n    }\n    \n    private void OnMouseExit()\n    {\n        _isHighlighted = false;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void SetCanRotate(bool canRotate)\n    {\n        _canRotate = canRotate;\n    }\n    \n    public void SetTargetAngle(float angle)\n    {\n        while (angle >= 360f)\n            angle -= 360f;\n        while (angle < 0f)\n            angle += 360f;\n            \n        // Update the correct position check to use the new target\n        float angleDifference = Mathf.Abs(Mathf.DeltaAngle(_currentAngle, angle));\n        _isInCorrectPosition = angleDifference <= _angleThreshold;\n    }\n    \n    public bool IsInCorrectPosition()\n    {\n        return _isInCorrectPosition;\n    }\n    \n    public float GetCurrentAngle()\n    {\n        return _currentAngle;\n    }\n    \n    public void ResetRing()\n    {\n        _isRotating = false;\n        _currentAngle = 0f;\n        transform.rotation = Quaternion.identity;\n        CheckCorrectPosition();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GraphicsQualitySettings\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentQualityLevel\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"maxQualityLevel\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"autoDetectQuality\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"targetFrameRate\",\n      \"type\": \"int\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"vsyncEnabled\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"antiAliasingLevel\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"shadowQuality\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"textureQuality\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"anisotropicFiltering\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"realtimeReflections\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"particleRaycastBudget\",\n      \"type\": \"int\",\n      \"default\": 256\n    },\n    {\n      \"name\": \"lodBias\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"pixelLightCount\",\n      \"type\": \"int\",\n      \"default\": 4\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_quality_settings\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"detect system hardware capabilities\"\n        },\n        {\n          \"action\": \"set appropriate quality level based on hardware\"\n        },\n        {\n          \"action\": \"apply initial graphics settings\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_quality_level\",\n      \"trigger\": \"when quality level is changed by user\",\n      \"actions\": [\n        {\n          \"action\": \"update current quality level\"\n        },\n        {\n          \"action\": \"apply new shadow quality settings\"\n        },\n        {\n          \"action\": \"adjust texture resolution\"\n        },\n        {\n          \"action\": \"modify anti-aliasing settings\"\n        },\n        {\n          \"action\": \"update particle system limits\"\n        },\n        {\n          \"action\": \"change lighting quality\"\n        }\n      ]\n    },\n    {\n      \"name\": \"toggle_vsync\",\n      \"trigger\": \"when vsync setting is toggled\",\n      \"actions\": [\n        {\n          \"action\": \"enable or disable vertical synchronization\"\n        },\n        {\n          \"action\": \"update target frame rate accordingly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_shadow_quality\",\n      \"trigger\": \"when shadow quality is modified\",\n      \"actions\": [\n        {\n          \"action\": \"change shadow resolution\"\n        },\n        {\n          \"action\": \"update shadow distance\"\n        },\n        {\n          \"action\": \"modify shadow cascade settings\"\n        }\n      ]\n    },\n    {\n      \"name\": \"optimize_for_performance\",\n      \"trigger\": \"when frame rate drops below target consistently\",\n      \"actions\": [\n        {\n          \"action\": \"reduce quality level automatically\"\n        },\n        {\n          \"action\": \"disable expensive visual effects\"\n        },\n        {\n          \"action\": \"lower texture quality\"\n        },\n        {\n          \"action\": \"reduce particle density\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_texture_settings\",\n      \"trigger\": \"when texture quality is changed\",\n      \"actions\": [\n        {\n          \"action\": \"set global texture quality level\"\n        },\n        {\n          \"action\": \"update anisotropic filtering\"\n        },\n        {\n          \"action\": \"refresh loaded textures\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_lighting_settings\",\n      \"trigger\": \"when lighting quality is adjusted\",\n      \"actions\": [\n        {\n          \"action\": \"change pixel light count\"\n        },\n        {\n          \"action\": \"update realtime reflection settings\"\n        },\n        {\n          \"action\": \"modify light culling distance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class GraphicsQualitySettings : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Dropdown _qualityDropdown;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Toggle _vsyncToggle;\n    [SerializeField] private Slider _shadowDistanceSlider;\n    [SerializeField] private Text _shadowDistanceText;\n    [SerializeField] private Dropdown _shadowQualityDropdown;\n    [SerializeField] private Dropdown _textureQualityDropdown;\n    [SerializeField] private Dropdown _antiAliasingDropdown;\n    [SerializeField] private Slider _renderScaleSlider;\n    [SerializeField] private Text _renderScaleText;\n    [SerializeField] private Button _applyButton;\n    [SerializeField] private Button _resetButton;\n\n    [Header(\"Settings\")]\n    [SerializeField] private bool _autoApplyChanges = true;\n    [SerializeField] private float _maxShadowDistance = 150f;\n\n    private Resolution[] _availableResolutions;\n    private int _currentResolutionIndex;\n    private bool _isInitialized = false;\n\n    private struct GraphicsSettings\n    {\n        public int qualityLevel;\n        public int resolutionIndex;\n        public bool fullscreen;\n        public bool vsync;\n        public float shadowDistance;\n        public ShadowQuality shadowQuality;\n        public int textureQuality;\n        public int antiAliasing;\n        public float renderScale;\n    }\n\n    private GraphicsSettings _currentSettings;\n    private GraphicsSettings _originalSettings;\n\n    private void Start()\n    {\n        InitializeResolutions();\n        InitializeDropdowns();\n        LoadCurrentSettings();\n        SetupUICallbacks();\n        _isInitialized = true;\n    }\n\n    private void InitializeResolutions()\n    {\n        _availableResolutions = Screen.resolutions;\n        List<string> resolutionOptions = new List<string>();\n\n        for (int i = 0; i < _availableResolutions.Length; i++)\n        {\n            string option = _availableResolutions[i].width + \" x \" + _availableResolutions[i].height + \" @ \" + _availableResolutions[i].refreshRate + \"Hz\";\n            resolutionOptions.Add(option);\n\n            if (_availableResolutions[i].width == Screen.currentResolution.width &&\n                _availableResolutions[i].height == Screen.currentResolution.height)\n            {\n                _currentResolutionIndex = i;\n            }\n        }\n\n        if (_resolutionDropdown != null)\n        {\n            _resolutionDropdown.ClearOptions();\n            _resolutionDropdown.AddOptions(resolutionOptions);\n            _resolutionDropdown.value = _currentResolutionIndex;\n        }\n    }\n\n    private void InitializeDropdowns()\n    {\n        if (_qualityDropdown != null)\n        {\n            _qualityDropdown.ClearOptions();\n            List<string> qualityOptions = new List<string>();\n            string[] qualityNames = QualitySettings.names;\n            for (int i = 0; i < qualityNames.Length; i++)\n            {\n                qualityOptions.Add(qualityNames[i]);\n            }\n            _qualityDropdown.AddOptions(qualityOptions);\n        }\n\n        if (_shadowQualityDropdown != null)\n        {\n            _shadowQualityDropdown.ClearOptions();\n            _shadowQualityDropdown.AddOptions(new List<string> { \"Disabled\", \"Hard Shadows\", \"Soft Shadows\" });\n        }\n\n        if (_textureQualityDropdown != null)\n        {\n            _textureQualityDropdown.ClearOptions();\n            _textureQualityDropdown.AddOptions(new List<string> { \"Full Res\", \"Half Res\", \"Quarter Res\", \"Eighth Res\" });\n        }\n\n        if (_antiAliasingDropdown != null)\n        {\n            _antiAliasingDropdown.ClearOptions();\n            _antiAliasingDropdown.AddOptions(new List<string> { \"Disabled\", \"2x Multi Sampling\", \"4x Multi Sampling\", \"8x Multi Sampling\" });\n        }\n    }\n\n    private void LoadCurrentSettings()\n    {\n        _currentSettings.qualityLevel = QualitySettings.GetQualityLevel();\n        _currentSettings.resolutionIndex = _currentResolutionIndex;\n        _currentSettings.fullscreen = Screen.fullScreen;\n        _currentSettings.vsync = QualitySettings.vSyncCount > 0;\n        _currentSettings.shadowDistance = QualitySettings.shadowDistance;\n        _currentSettings.shadowQuality = QualitySettings.shadows;\n        _currentSettings.textureQuality = QualitySettings.globalTextureMipmapLimit;\n        _currentSettings.antiAliasing = QualitySettings.antiAliasing;\n        _currentSettings.renderScale = QualitySettings.renderPipeline != null ? 1.0f : 1.0f;\n\n        _originalSettings = _currentSettings;\n\n        UpdateUI();\n    }\n\n    private void UpdateUI()\n    {\n        if (_qualityDropdown != null)\n            _qualityDropdown.value = _currentSettings.qualityLevel;\n\n        if (_resolutionDropdown != null)\n            _resolutionDropdown.value = _currentSettings.resolutionIndex;\n\n        if (_fullscreenToggle != null)\n            _fullscreenToggle.isOn = _currentSettings.fullscreen;\n\n        if (_vsyncToggle != null)\n            _vsyncToggle.isOn = _currentSettings.vsync;\n\n        if (_shadowDistanceSlider != null)\n        {\n            _shadowDistanceSlider.value = _currentSettings.shadowDistance / _maxShadowDistance;\n            if (_shadowDistanceText != null)\n                _shadowDistanceText.text = _currentSettings.shadowDistance.ToString(\"F0\") + \"m\";\n        }\n\n        if (_shadowQualityDropdown != null)\n            _shadowQualityDropdown.value = (int)_currentSettings.shadowQuality;\n\n        if (_textureQualityDropdown != null)\n            _textureQualityDropdown.value = _currentSettings.textureQuality;\n\n        if (_antiAliasingDropdown != null)\n        {\n            int aaIndex = 0;\n            switch (_currentSettings.antiAliasing)\n            {\n                case 0: aaIndex = 0; break;\n                case 2: aaIndex = 1; break;\n                case 4: aaIndex = 2; break;\n                case 8: aaIndex = 3; break;\n            }\n            _antiAliasingDropdown.value = aaIndex;\n        }\n\n        if (_renderScaleSlider != null)\n        {\n            _renderScaleSlider.value = _currentSettings.renderScale;\n            if (_renderScaleText != null)\n                _renderScaleText.text = (_currentSettings.renderScale * 100f).ToString(\"F0\") + \"%\";\n        }\n    }\n\n    private void SetupUICallbacks()\n    {\n        if (_qualityDropdown != null)\n            _qualityDropdown.onValueChanged.AddListener(OnQualityChanged);\n\n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(OnResolutionChanged);\n\n        if (_fullscreenToggle != null)\n            _fullscreenToggle.onValueChanged.AddListener(OnFullscreenChanged);\n\n        if (_vsyncToggle != null)\n            _vsyncToggle.onValueChanged.AddListener(OnVSyncChanged);\n\n        if (_shadowDistanceSlider != null)\n            _shadowDistanceSlider.onValueChanged.AddListener(OnShadowDistanceChanged);\n\n        if (_shadowQualityDropdown != null)\n            _shadowQualityDropdown.onValueChanged.AddListener(OnShadowQualityChanged);\n\n        if (_textureQualityDropdown != null)\n            _textureQualityDropdown.onValueChanged.AddListener(OnTextureQualityChanged);\n\n        if (_antiAliasingDropdown != null)\n            _antiAliasingDropdown.onValueChanged.AddListener(OnAntiAliasingChanged);\n\n        if (_renderScaleSlider != null)\n            _renderScaleSlider.onValueChanged.AddListener(OnRenderScaleChanged);\n\n        if (_applyButton != null)\n            _applyButton.onClick.AddListener(ApplySettings);\n\n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetToDefaults);\n    }\n\n    private void OnQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.qualityLevel = value;\n        if (_autoApplyChanges) ApplyQualityLevel();\n    }\n\n    private void OnResolutionChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.resolutionIndex = value;\n        if (_autoApplyChanges) ApplyResolution();\n    }\n\n    private void OnFullscreenChanged(bool value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.fullscreen = value;\n        if (_autoApplyChanges) ApplyFullscreen();\n    }\n\n    private void OnVSyncChanged(bool value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.vsync = value;\n        if (_autoApplyChanges) ApplyVSync();\n    }\n\n    private void OnShadowDistanceChanged(float value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.shadowDistance = value * _maxShadowDistance;\n        if (_shadowDistanceText != null)\n            _shadowDistanceText.text = _currentSettings.shadowDistance.ToString(\"F0\") + \"m\";\n        if (_autoApplyChanges) ApplyShadowDistance();\n    }\n\n    private void OnShadowQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.shadowQuality = (ShadowQuality)value;\n        if (_autoApplyChanges) ApplyShadowQuality();\n    }\n\n    private void OnTextureQualityChanged(int value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.textureQuality = value;\n        if (_autoApplyChanges) ApplyTextureQuality();\n    }\n\n    private void OnAntiAliasingChanged(int value)\n    {\n        if (!_isInitialized) return;\n        int[] aaValues = { 0, 2, 4, 8 };\n        _currentSettings.antiAliasing = aaValues[Mathf.Clamp(value, 0, aaValues.Length - 1)];\n        if (_autoApplyChanges) ApplyAntiAliasing();\n    }\n\n    private void OnRenderScaleChanged(float value)\n    {\n        if (!_isInitialized) return;\n        _currentSettings.renderScale = value;\n        if (_renderScaleText != null)\n            _renderScaleText.text = (value * 100f).ToString(\"F0\") + \"%\";\n        if (_autoApplyChanges) ApplyRenderScale();\n    }\n\n    public void ApplySettings()\n    {\n        ApplyQualityLevel();\n        ApplyResolution();\n        ApplyFullscreen();\n        ApplyVSync();\n        ApplyShadowDistance();\n        ApplyShadowQuality();\n        ApplyTextureQuality();\n        ApplyAntiAliasing();\n        ApplyRenderScale();\n    }\n\n    private void ApplyQualityLevel()\n    {\n        QualitySettings.SetQualityLevel(_currentSettings.qualityLevel, true);\n    }\n\n    private void ApplyResolution()\n    {\n        if (_currentSettings.resolutionIndex >= 0 && _currentSettings.resolutionIndex < _availableResolutions.Length)\n        {\n            Resolution resolution = _availableResolutions[_currentSettings.resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, _currentSettings.fullscreen, resolution.refreshRate);\n        }\n    }\n\n    private void ApplyFullscreen()\n    {\n        Screen.fullScreen = _currentSettings.fullscreen;\n    }\n\n    private void ApplyVSync()\n    {\n        QualitySettings.vSyncCount = _currentSettings.vsync ? 1 : 0;\n    }\n\n    private void ApplyShadowDistance()\n    {\n        QualitySettings.shadowDistance = _currentSettings.shadowDistance;\n    }\n\n    private void ApplyShadowQuality()\n    {\n        QualitySettings.shadows = _currentSettings.shadowQuality;\n    }\n\n    private void ApplyTextureQuality()\n    {\n        QualitySettings.globalTextureMipmapLimit = _currentSettings.textureQuality;\n    }\n\n    private void ApplyAntiAliasing()\n    {\n        QualitySettings.antiAliasing = _currentSettings.antiAliasing;\n    }\n\n    private void ApplyRenderScale()\n    {\n        // Note: Render scale implementation depends on render pipeline\n        // This is a placeholder for custom render scale logic\n    }\n\n    public void ResetToDefaults()\n    {\n        _currentSettings = _originalSettings;\n        UpdateUI();\n        if (_autoApplyChanges) ApplySettings();\n    }\n\n    public void SaveSettings()\n    {\n        PlayerPrefs.SetInt(\"QualityLevel\", _currentSettings.qualityLevel);\n        PlayerPrefs.SetInt(\"ResolutionIndex\", _currentSettings.resolutionIndex);\n        PlayerPrefs.SetInt(\"Fullscreen\", _currentSettings.fullscreen ? 1 : 0);\n        PlayerPrefs.SetInt(\"VSync\", _currentSettings.vsync ? 1 : 0);\n        PlayerPrefs.SetFloat(\"ShadowDistance\", _currentSettings.shadowDistance);\n        PlayerPrefs.SetInt(\"ShadowQuality\", (int)_currentSettings.shadowQuality);\n        PlayerPrefs.SetInt(\"TextureQuality\", _currentSettings.textureQuality);\n        PlayerPrefs.SetInt(\"AntiAliasing\", _currentSettings.antiAliasing);\n        PlayerPrefs.SetFloat(\"RenderScale\", _currentSettings.renderScale);\n        PlayerPrefs.Save();\n    }\n\n    public void LoadSettings()\n    {\n        if (PlayerPrefs.HasKey(\"QualityLevel\"))\n        {\n            _currentSettings.qualityLevel = PlayerPrefs.GetInt(\"QualityLevel\");\n            _currentSettings.resolutionIndex = PlayerPrefs.GetInt(\"ResolutionIndex\", _currentResolutionIndex);\n            _currentSettings.fullscreen = PlayerPrefs.GetInt(\"Fullscreen\", 1) == 1;\n            _currentSettings.vsync = PlayerPrefs.GetInt(\"VSync\", 1) == 1;\n            _currentSettings.shadowDistance = PlayerPrefs.GetFloat(\"ShadowDistance\", 50f);\n            _currentSettings.shadowQuality = (ShadowQuality)PlayerPrefs.GetInt(\"ShadowQuality\", 2);\n            _currentSettings.textureQuality = PlayerPrefs.GetInt(\"TextureQuality\", 0);\n            _currentSettings.antiAliasing = PlayerPrefs.GetInt(\"AntiAliasing\", 0);\n            _currentSettings.renderScale = PlayerPrefs.GetFloat(\"RenderScale\", 1.0f);\n\n            UpdateUI();\n            ApplySettings();\n        }\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus) SaveSettings();\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus) SaveSettings();\n    }"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SecurityCamera\",\n  \"components\": [\n    \"Camera\",\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"sweepAngle\",\n      \"type\": \"float\",\n      \"default\": 90\n    },\n    {\n      \"name\": \"alertDuration\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isAlerted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentRotation\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"sweepDirection\",\n      \"type\": \"int\",\n      \"default\": 1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"sweep_patrol\",\n      \"trigger\": \"when not alerted and during normal operation\",\n      \"actions\": [\n        {\n          \"action\": \"rotate camera left and right within sweep angle range\"\n        },\n        {\n          \"action\": \"reverse rotation direction when reaching sweep limits\"\n        },\n        {\n          \"action\": \"maintain steady rotation speed during sweep\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_intruder\",\n      \"trigger\": \"when player enters detection range and is within camera view cone\",\n      \"actions\": [\n        {\n          \"action\": \"stop sweeping motion immediately\"\n        },\n        {\n          \"action\": \"track and follow the detected player\"\n        },\n        {\n          \"action\": \"change camera light to red color\"\n        },\n        {\n          \"action\": \"set alert state to active\"\n        },\n        {\n          \"action\": \"play alarm sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"when in alert state and player is visible\",\n      \"actions\": [\n        {\n          \"action\": \"rotate camera to keep player centered in view\"\n        },\n        {\n          \"action\": \"maintain red alert lighting\"\n        },\n        {\n          \"action\": \"continue playing alarm sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_target\",\n      \"trigger\": \"when player leaves detection range or breaks line of sight\",\n      \"actions\": [\n        {\n          \"action\": \"continue alert state for alert duration\"\n        },\n        {\n          \"action\": \"search by rotating toward last known player position\"\n        },\n        {\n          \"action\": \"keep red lighting active during search\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_patrol\",\n      \"trigger\": \"when alert duration expires and no player detected\",\n      \"actions\": [\n        {\n          \"action\": \"change camera light back to white color\"\n        },\n        {\n          \"action\": \"stop alarm sound effects\"\n        },\n        {\n          \"action\": \"set alert state to inactive\"\n        },\n        {\n          \"action\": \"resume normal sweeping patrol pattern\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class SecurityCamera : MonoBehaviour\n{\n    [Header(\"Camera Settings\")]\n    [SerializeField] private Camera _securityCamera;\n    [SerializeField] private Transform _cameraHead;\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _fieldOfView = 60f;\n    [SerializeField] private LayerMask _detectionLayers = -1;\n    [SerializeField] private LayerMask _obstacleLayers = -1;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private bool _enableRotation = true;\n    [SerializeField] private float _rotationSpeed = 30f;\n    [SerializeField] private float _minRotationAngle = -45f;\n    [SerializeField] private float _maxRotationAngle = 45f;\n    [SerializeField] private float _pauseDuration = 2f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionTime = 3f;\n    [SerializeField] private float _lostTargetTime = 5f;\n    [SerializeField] private bool _requireLineOfSight = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Light _cameraLight;\n    [SerializeField] private Color _normalColor = Color.green;\n    [SerializeField] private Color _alertColor = Color.red;\n    [SerializeField] private Color _detectedColor = Color.red;\n    [SerializeField] private MeshRenderer _cameraRenderer;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _alertMaterial;\n    [SerializeField] private Material _detectedMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _detectionSound;\n    [SerializeField] private AudioClip _alertSound;\n    [SerializeField] private AudioClip _lostTargetSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<Transform> OnTargetDetected;\n    public UnityEvent<Transform> OnTargetLost;\n    public UnityEvent<Transform> OnTargetFullyDetected;\n    \n    private CameraState _currentState = CameraState.Normal;\n    private Transform _currentTarget;\n    private float _detectionProgress = 0f;\n    private float _lostTargetTimer = 0f;\n    private bool _rotatingRight = true;\n    private float _pauseTimer = 0f;\n    private bool _isPaused = false;\n    private List<Transform> _detectedTargets = new List<Transform>();\n    private Coroutine _rotationCoroutine;\n    \n    private enum CameraState\n    {\n        Normal,\n        Alert,\n        Detected,\n        Tracking\n    }\n    \n    private void Start()\n    {\n        InitializeCamera();\n        if (_enableRotation)\n        {\n            _rotationCoroutine = StartCoroutine(RotationRoutine());\n        }\n    }\n    \n    private void InitializeCamera()\n    {\n        if (_securityCamera == null)\n            _securityCamera = GetComponentInChildren<Camera>();\n        \n        if (_cameraHead == null)\n            _cameraHead = _securityCamera != null ? _securityCamera.transform : transform;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_cameraLight == null)\n            _cameraLight = GetComponentInChildren<Light>();\n        \n        if (_cameraRenderer == null)\n            _cameraRenderer = GetComponent<MeshRenderer>();\n        \n        SetCameraState(CameraState.Normal);\n    }\n    \n    private void Update()\n    {\n        DetectTargets();\n        UpdateDetectionProgress();\n        UpdateVisuals();\n    }\n    \n    private void DetectTargets()\n    {\n        _detectedTargets.Clear();\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _detectionLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.transform == transform) continue;\n            \n            if (IsTargetInFieldOfView(col.transform) && (!_requireLineOfSight || HasLineOfSight(col.transform)))\n            {\n                _detectedTargets.Add(col.transform);\n            }\n        }\n        \n        HandleTargetDetection();\n    }\n    \n    private bool IsTargetInFieldOfView(Transform target)\n    {\n        Vector3 directionToTarget = (target.position - _cameraHead.position).normalized;\n        float angle = Vector3.Angle(_cameraHead.forward, directionToTarget);\n        return angle <= _fieldOfView * 0.5f;\n    }\n    \n    private bool HasLineOfSight(Transform target)\n    {\n        Vector3 directionToTarget = target.position - _cameraHead.position;\n        float distanceToTarget = directionToTarget.magnitude;\n        \n        if (Physics.Raycast(_cameraHead.position, directionToTarget.normalized, out RaycastHit hit, distanceToTarget, _obstacleLayers))\n        {\n            return hit.transform == target;\n        }\n        \n        return true;\n    }\n    \n    private void HandleTargetDetection()\n    {\n        if (_detectedTargets.Count > 0)\n        {\n            Transform closestTarget = GetClosestTarget();\n            \n            if (_currentTarget != closestTarget)\n            {\n                if (_currentTarget != null)\n                {\n                    OnTargetLost?.Invoke(_currentTarget);\n                    PlaySound(_lostTargetSound);\n                }\n                \n                _currentTarget = closestTarget;\n                _detectionProgress = 0f;\n                OnTargetDetected?.Invoke(_currentTarget);\n                SetCameraState(CameraState.Alert);\n            }\n            \n            _lostTargetTimer = 0f;\n        }\n        else\n        {\n            if (_currentTarget != null)\n            {\n                _lostTargetTimer += Time.deltaTime;\n                \n                if (_lostTargetTimer >= _lostTargetTime)\n                {\n                    OnTargetLost?.Invoke(_currentTarget);\n                    PlaySound(_lostTargetSound);\n                    _currentTarget = null;\n                    _detectionProgress = 0f;\n                    SetCameraState(CameraState.Normal);\n                }\n            }\n        }\n    }\n    \n    private Transform GetClosestTarget()\n    {\n        Transform closest = null;\n        float closestDistance = float.MaxValue;\n        \n        foreach (Transform target in _detectedTargets)\n        {\n            float distance = Vector3.Distance(transform.position, target.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closest = target;\n            }\n        }\n        \n        return closest;\n    }\n    \n    private void UpdateDetectionProgress()\n    {\n        if (_currentTarget != null && _detectedTargets.Contains(_currentTarget))\n        {\n            _detectionProgress += Time.deltaTime / _detectionTime;\n            \n            if (_detectionProgress >= 1f && _currentState != CameraState.Detected)\n            {\n                SetCameraState(CameraState.Detected);\n                OnTargetFullyDetected?.Invoke(_currentTarget);\n                PlaySound(_detectionSound);\n            }\n        }\n        else if (_currentTarget != null)\n        {\n            _detectionProgress -= Time.deltaTime / (_detectionTime * 0.5f);\n            _detectionProgress = Mathf.Max(0f, _detectionProgress);\n            \n            if (_detectionProgress <= 0f && _currentState == CameraState.Detected)\n            {\n                SetCameraState(CameraState.Alert);\n            }\n        }\n    }\n    \n    private void SetCameraState(CameraState newState)\n    {\n        _currentState = newState;\n        \n        switch (_currentState)\n        {\n            case CameraState.Normal:\n                if (_enableRotation && _rotationCoroutine == null)\n                    _rotationCoroutine = StartCoroutine(RotationRoutine());\n                break;\n                \n            case CameraState.Alert:\n                if (_rotationCoroutine != null)\n                {\n                    StopCoroutine(_rotationCoroutine);\n                    _rotationCoroutine = null;\n                }\n                TrackTarget();\n                PlaySound(_alertSound);\n                break;\n                \n            case CameraState.Detected:\n                TrackTarget();\n                break;\n        }\n    }\n    \n    private void TrackTarget()\n    {\n        if (_currentTarget != null)\n        {\n            Vector3 directionToTarget = (_currentTarget.position - _cameraHead.position).normalized;\n            Quaternion targetRotation = Quaternion.LookRotation(directionToTarget);\n            _cameraHead.rotation = Quaternion.Slerp(_cameraHead.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private IEnumerator RotationRoutine()\n    {\n        while (_enableRotation && _currentState == CameraState.Normal)\n        {\n            if (!_isPaused)\n            {\n                float currentY = _cameraHead.localEulerAngles.y;\n                if (currentY > 180f) currentY -= 360f;\n                \n                if (_rotatingRight)\n                {\n                    if (currentY >= _maxRotationAngle)\n                    {\n                        _rotatingRight = false;\n                        _isPaused = true;\n                        _pauseTimer = 0f;\n                    }\n                    else\n                    {\n                        _cameraHead.Rotate(0, _rotationSpeed * Time.deltaTime, 0);\n                    }\n                }\n                else\n                {\n                    if (currentY <= _minRotationAngle)\n                    {\n                        _rotatingRight = true;\n                        _isPaused = true;\n                        _pauseTimer = 0f;\n                    }\n                    else\n                    {\n                        _cameraHead.Rotate(0, -_rotationSpeed * Time.deltaTime, 0);\n                    }\n                }\n            }\n            else\n            {\n                _pauseTimer += Time.deltaTime;\n                if (_pauseTimer >= _pauseDuration)\n                {\n                    _isPaused = false;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void UpdateVisuals()\n    {\n        Color targetColor = _normalColor;\n        Material targetMaterial = _normalMaterial;\n        \n        switch (_currentState)\n        {\n            case CameraState.Normal:\n                targetColor = _normalColor;\n                targetMaterial = _normalMaterial;\n                break;\n                \n            case CameraState.Alert:\n                targetColor = Color.Lerp(_normalColor, _alertColor, _detectionProgress);\n                targetMaterial = _detectionProgress > 0.5f ? _alertMaterial : _normalMaterial;\n                break;\n                \n            case CameraState.Detected:\n                targetColor = _detectedColor;\n                targetMaterial = _detectedMaterial;\n                break;\n        }\n        \n        if (_cameraLight != null)\n        {\n            _cameraLight.color = targetColor;\n        }\n        \n        if (_cameraRenderer != null && targetMaterial != null)\n        {\n            _cameraRenderer.material = targetMaterial;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        if (_cameraHead != null)\n        {\n            Gizmos.color = _currentState == CameraState.Detected ? Color.red : \n                          _currentState == CameraState.Alert ? Color.orange : Color.green;\n            \n            Vector3 forward = _cameraHead.forward;\n            Vector3 right = Quaternion.AngleAxis(_fieldOfView * 0.5f, _cameraHead.up) * forward;\n            Vector3 left = Quaternion.AngleAxis(-_fieldOfView * 0.5f, _cameraHead.up) * forward;\n            \n            Gizmos.DrawRay(_cameraHead.position, right * _detectionRange);\n            Gizmos.DrawRay(_cameraHead.position, left * _detectionRange);\n            Gizmos.DrawRay(_cameraHead.position, forward * _detectionRange);\n        }\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(_cameraHead.position, _currentTarget.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DestructibleBarrel\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"fragmentCount\",\n      \"type\": \"int\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"isDestroyed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when hit by projectile or explosion\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current health by damage amount\"\n        },\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"show damage visual effect at hit point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_barrel\",\n      \"trigger\": \"when current health reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"mark barrel as destroyed\"\n        },\n        {\n          \"action\": \"play explosion sound effect\"\n        },\n        {\n          \"action\": \"create explosion visual effect\"\n        },\n        {\n          \"action\": \"apply explosive force to nearby objects within explosion radius\"\n        },\n        {\n          \"action\": \"spawn fragment pieces that scatter outward\"\n        },\n        {\n          \"action\": \"deal damage to nearby destructible objects\"\n        },\n        {\n          \"action\": \"destroy the barrel game object after brief delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chain_reaction\",\n      \"trigger\": \"when explosion force is applied from nearby explosion\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current health by explosion damage amount\"\n        },\n        {\n          \"action\": \"apply physics force in direction away from explosion source\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when current health is below half of maximum health\",\n      \"actions\": [\n        {\n          \"action\": \"show cracks or damage on barrel surface\"\n        },\n        {\n          \"action\": \"emit smoke particles from damaged areas\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DestructibleBarrel : MonoBehaviour\n{\n    [Header(\"Health Settings\")]\n    [SerializeField] private int _maxHealth = 100;\n    [SerializeField] private int _currentHealth;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private string[] _damageableTags = { \"Bullet\", \"Explosion\", \"Weapon\" };\n    [SerializeField] private int _explosionDamage = 50;\n    [SerializeField] private float _explosionRadius = 5f;\n    [SerializeField] private LayerMask _explosionLayerMask = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _destructionParticles;\n    [SerializeField] private GameObject _damageParticles;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _destructionSound;\n    [SerializeField] private Material _damagedMaterial;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private bool _explodeOnDestruction = true;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private GameObject[] _debrisPrefabs;\n    [SerializeField] private int _debrisCount = 5;\n    [SerializeField] private float _debrisLifetime = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDamaged;\n    public UnityEvent OnDestroyed;\n    \n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Material _originalMaterial;\n    private bool _isDestroyed = false;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isDestroyed) return;\n        \n        foreach (string tag in _damageableTags)\n        {\n            if (other.CompareTag(tag))\n            {\n                int damage = GetDamageFromCollider(other);\n                TakeDamage(damage);\n                break;\n            }\n        }\n    }\n    \n    void OnCollisionEnter(Collision collision)\n    {\n        if (_isDestroyed) return;\n        \n        foreach (string tag in _damageableTags)\n        {\n            if (collision.gameObject.CompareTag(tag))\n            {\n                int damage = GetDamageFromCollider(collision.collider);\n                TakeDamage(damage);\n                break;\n            }\n        }\n    }\n    \n    private int GetDamageFromCollider(Collider other)\n    {\n        if (other.CompareTag(\"Bullet\"))\n            return 25;\n        else if (other.CompareTag(\"Explosion\"))\n            return 75;\n        else if (other.CompareTag(\"Weapon\"))\n            return 40;\n        \n        return 10;\n    }\n    \n    public void TakeDamage(int damage)\n    {\n        if (_isDestroyed) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Max(0, _currentHealth);\n        \n        PlayHitEffect();\n        OnDamaged?.Invoke();\n        \n        UpdateVisualDamage();\n        \n        if (_currentHealth <= 0)\n        {\n            DestroyBarrel();\n        }\n    }\n    \n    private void PlayHitEffect()\n    {\n        if (_damageParticles != null)\n        {\n            GameObject particles = Instantiate(_damageParticles, transform.position, transform.rotation);\n            Destroy(particles, 2f);\n        }\n        \n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n    }\n    \n    private void UpdateVisualDamage()\n    {\n        if (_renderer == null || _damagedMaterial == null) return;\n        \n        float healthPercentage = (float)_currentHealth / _maxHealth;\n        \n        if (healthPercentage < 0.5f && _renderer.material != _damagedMaterial)\n        {\n            _renderer.material = _damagedMaterial;\n        }\n    }\n    \n    private void DestroyBarrel()\n    {\n        if (_isDestroyed) return;\n        _isDestroyed = true;\n        \n        OnDestroyed?.Invoke();\n        \n        if (_explodeOnDestruction)\n        {\n            CreateExplosion();\n        }\n        \n        CreateDestructionEffects();\n        SpawnDebris();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        Destroy(gameObject, 1f);\n    }\n    \n    private void CreateExplosion()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _explosionRadius, _explosionLayerMask);\n        \n        foreach (Collider nearbyObject in colliders)\n        {\n            if (nearbyObject == _collider) continue;\n            \n            Rigidbody rb = nearbyObject.GetComponent<Rigidbody>();\n            if (rb != null)\n            {\n                rb.AddExplosionForce(_explosionForce, transform.position, _explosionRadius);\n            }\n            \n            DestructibleBarrel otherBarrel = nearbyObject.GetComponent<DestructibleBarrel>();\n            if (otherBarrel != null && !otherBarrel._isDestroyed)\n            {\n                float distance = Vector3.Distance(transform.position, otherBarrel.transform.position);\n                int damage = Mathf.RoundToInt(_explosionDamage * (1f - distance / _explosionRadius));\n                otherBarrel.TakeDamage(damage);\n            }\n            \n            if (nearbyObject.CompareTag(\"Player\"))\n            {\n                // Apply damage to player if they have a method to receive damage\n                nearbyObject.SendMessage(\"TakeDamage\", _explosionDamage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n    \n    private void CreateDestructionEffects()\n    {\n        if (_destructionParticles != null)\n        {\n            GameObject particles = Instantiate(_destructionParticles, transform.position, transform.rotation);\n            Destroy(particles, 5f);\n        }\n        \n        if (_destructionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_destructionSound);\n        }\n    }\n    \n    private void SpawnDebris()\n    {\n        if (_debrisPrefabs == null || _debrisPrefabs.Length == 0) return;\n        \n        for (int i = 0; i < _debrisCount; i++)\n        {\n            GameObject debrisPrefab = _debrisPrefabs[Random.Range(0, _debrisPrefabs.Length)];\n            if (debrisPrefab == null) continue;\n            \n            Vector3 spawnPosition = transform.position + Random.insideUnitSphere * 0.5f;\n            Quaternion spawnRotation = Random.rotation;\n            \n            GameObject debris = Instantiate(debrisPrefab, spawnPosition, spawnRotation);\n            \n            Rigidbody debrisRb = debris.GetComponent<Rigidbody>();\n            if (debrisRb == null)\n            {\n                debrisRb = debris.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 explosionDirection = Random.insideUnitSphere;\n            explosionDirection.y = Mathf.Abs(explosionDirection.y);\n            debrisRb.AddForce(explosionDirection * _explosionForce * 0.5f);\n            debrisRb.AddTorque(Random.insideUnitSphere * _explosionForce * 0.1f);\n            \n            Destroy(debris, _debrisLifetime);\n        }\n    }\n    \n    public void SetHealth(int health)\n    {\n        _currentHealth = Mathf.Clamp(health, 0, _maxHealth);\n        UpdateVisualDamage();\n    }\n    \n    public int GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return (float)_currentHealth / _maxHealth;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_explodeOnDestruction)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(transform.position, _explosionRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GardenPatch\",\n  \"components\": [\n    \"BoxCollider\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isPlanted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"cropType\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"growthStage\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxGrowthStage\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"growthTime\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    },\n    {\n      \"name\": \"currentGrowthTime\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"soilMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    },\n    {\n      \"name\": \"plantedMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"plant_seed\",\n      \"trigger\": \"when player interacts with empty patch while holding seeds\",\n      \"actions\": [\n        {\n          \"action\": \"mark patch as planted\"\n        },\n        {\n          \"action\": \"set crop type to seed type\"\n        },\n        {\n          \"action\": \"change material to planted appearance\"\n        },\n        {\n          \"action\": \"reset growth timer\"\n        },\n        {\n          \"action\": \"remove seed from player inventory\"\n        }\n      ]\n    },\n    {\n      \"name\": \"grow_crop\",\n      \"trigger\": \"when patch is planted and growth timer reaches growth time\",\n      \"actions\": [\n        {\n          \"action\": \"increase growth stage by one\"\n        },\n        {\n          \"action\": \"reset growth timer\"\n        },\n        {\n          \"action\": \"update visual appearance based on growth stage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"harvest_crop\",\n      \"trigger\": \"when player interacts with fully grown crop\",\n      \"actions\": [\n        {\n          \"action\": \"add harvested crop to player inventory\"\n        },\n        {\n          \"action\": \"mark patch as empty\"\n        },\n        {\n          \"action\": \"reset growth stage to zero\"\n        },\n        {\n          \"action\": \"change material back to soil appearance\"\n        },\n        {\n          \"action\": \"clear crop type\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_growth_progress\",\n      \"trigger\": \"when player looks at planted patch\",\n      \"actions\": [\n        {\n          \"action\": \"display growth stage information\"\n        },\n        {\n          \"action\": \"show crop type being grown\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class GardenPatch : MonoBehaviour\n{\n    [System.Serializable]\n    public class PlantData\n    {\n        public string plantName;\n        public GameObject plantPrefab;\n        public float growthTime;\n        public int harvestAmount;\n        public Sprite plantIcon;\n    }\n\n    [System.Serializable]\n    public class GrowthStage\n    {\n        public GameObject stagePrefab;\n        public float stageTime;\n    }\n\n    [Header(\"Garden Configuration\")]\n    [SerializeField] private List<PlantData> _availablePlants = new List<PlantData>();\n    [SerializeField] private List<GrowthStage> _growthStages = new List<GrowthStage>();\n    [SerializeField] private Transform _plantSpawnPoint;\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n\n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _soilPrefab;\n    [SerializeField] private GameObject _wateredSoilPrefab;\n    [SerializeField] private GameObject _highlightEffect;\n    [SerializeField] private ParticleSystem _plantingEffect;\n    [SerializeField] private ParticleSystem _harvestEffect;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _plantingSound;\n    [SerializeField] private AudioClip _harvestSound;\n    [SerializeField] private AudioClip _wateringSound;\n\n    [Header(\"Events\")]\n    public UnityEvent<string> OnPlantPlanted;\n    public UnityEvent<string, int> OnPlantHarvested;\n    public UnityEvent OnPatchWatered;\n\n    private enum PatchState\n    {\n        Empty,\n        Planted,\n        Growing,\n        ReadyToHarvest,\n        Watered\n    }\n\n    private PatchState _currentState = PatchState.Empty;\n    private PlantData _currentPlant;\n    private GameObject _currentPlantObject;\n    private GameObject _currentSoilObject;\n    private float _plantingTime;\n    private float _wateringTime;\n    private int _currentGrowthStage;\n    private bool _isWatered;\n    private bool _playerInRange;\n\n    private void Start()\n    {\n        InitializePatch();\n        SetupAudioSource();\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleGrowth();\n        HandleWatering();\n        UpdateVisuals();\n        HandleInput();\n    }\n\n    private void InitializePatch()\n    {\n        if (_plantSpawnPoint == null)\n            _plantSpawnPoint = transform;\n\n        if (_soilPrefab != null)\n        {\n            _currentSoilObject = Instantiate(_soilPrefab, _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentSoilObject.transform.SetParent(transform);\n        }\n\n        if (_highlightEffect != null)\n            _highlightEffect.SetActive(false);\n    }\n\n    private void SetupAudioSource()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _audioSource.playOnAwake = false;\n        _audioSource.spatialBlend = 1f;\n    }\n\n    private void CheckPlayerProximity()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _interactionRange, _playerLayer);\n        bool playerNearby = false;\n\n        foreach (Collider col in playersInRange)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                playerNearby = true;\n                break;\n            }\n        }\n\n        if (playerNearby != _playerInRange)\n        {\n            _playerInRange = playerNearby;\n            if (_highlightEffect != null)\n                _highlightEffect.SetActive(_playerInRange);\n        }\n    }\n\n    private void HandleGrowth()\n    {\n        if (_currentState != PatchState.Growing)\n            return;\n\n        float growthProgress = (Time.time - _plantingTime) / _currentPlant.growthTime;\n        \n        if (_isWatered)\n            growthProgress *= 1.5f;\n\n        UpdateGrowthStage(growthProgress);\n\n        if (growthProgress >= 1f)\n        {\n            _currentState = PatchState.ReadyToHarvest;\n            ShowFinalGrowthStage();\n        }\n    }\n\n    private void UpdateGrowthStage(float progress)\n    {\n        if (_growthStages.Count == 0)\n            return;\n\n        int targetStage = Mathf.FloorToInt(progress * _growthStages.Count);\n        targetStage = Mathf.Clamp(targetStage, 0, _growthStages.Count - 1);\n\n        if (targetStage != _currentGrowthStage)\n        {\n            _currentGrowthStage = targetStage;\n            ShowGrowthStage(targetStage);\n        }\n    }\n\n    private void ShowGrowthStage(int stageIndex)\n    {\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        if (stageIndex < _growthStages.Count && _growthStages[stageIndex].stagePrefab != null)\n        {\n            _currentPlantObject = Instantiate(_growthStages[stageIndex].stagePrefab, \n                _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentPlantObject.transform.SetParent(transform);\n        }\n    }\n\n    private void ShowFinalGrowthStage()\n    {\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        if (_currentPlant.plantPrefab != null)\n        {\n            _currentPlantObject = Instantiate(_currentPlant.plantPrefab, \n                _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentPlantObject.transform.SetParent(transform);\n        }\n    }\n\n    private void HandleWatering()\n    {\n        if (_isWatered && Time.time - _wateringTime > 300f) // 5 minutes\n        {\n            _isWatered = false;\n            UpdateSoilVisual();\n        }\n    }\n\n    private void UpdateVisuals()\n    {\n        // Update soil visual based on watering state\n        if (_currentState == PatchState.Empty || _currentState == PatchState.Watered)\n        {\n            UpdateSoilVisual();\n        }\n    }\n\n    private void UpdateSoilVisual()\n    {\n        if (_currentSoilObject != null)\n            DestroyImmediate(_currentSoilObject);\n\n        GameObject soilPrefab = _isWatered ? _wateredSoilPrefab : _soilPrefab;\n        if (soilPrefab != null)\n        {\n            _currentSoilObject = Instantiate(soilPrefab, _plantSpawnPoint.position, _plantSpawnPoint.rotation);\n            _currentSoilObject.transform.SetParent(transform);\n        }\n    }\n\n    private void HandleInput()\n    {\n        if (!_playerInRange)\n            return;\n\n        if (Input.GetKeyDown(KeyCode.E))\n        {\n            InteractWithPatch();\n        }\n        else if (Input.GetKeyDown(KeyCode.R))\n        {\n            WaterPatch();\n        }\n    }\n\n    public void InteractWithPatch()\n    {\n        switch (_currentState)\n        {\n            case PatchState.Empty:\n            case PatchState.Watered:\n                TryPlantSeed();\n                break;\n            case PatchState.ReadyToHarvest:\n                HarvestPlant();\n                break;\n        }\n    }\n\n    public void PlantSeed(int plantIndex)\n    {\n        if (plantIndex < 0 || plantIndex >= _availablePlants.Count)\n            return;\n\n        if (_currentState != PatchState.Empty && _currentState != PatchState.Watered)\n            return;\n\n        _currentPlant = _availablePlants[plantIndex];\n        _currentState = PatchState.Growing;\n        _plantingTime = Time.time;\n        _currentGrowthStage = -1;\n\n        PlaySound(_plantingSound);\n        PlayEffect(_plantingEffect);\n        OnPlantPlanted?.Invoke(_currentPlant.plantName);\n\n        if (_currentSoilObject != null)\n            _currentSoilObject.SetActive(false);\n    }\n\n    private void TryPlantSeed()\n    {\n        if (_availablePlants.Count > 0)\n        {\n            PlantSeed(0); // Plant first available seed\n        }\n    }\n\n    public void HarvestPlant()\n    {\n        if (_currentState != PatchState.ReadyToHarvest || _currentPlant == null)\n            return;\n\n        string harvestedPlant = _currentPlant.plantName;\n        int harvestAmount = _currentPlant.harvestAmount;\n\n        // Clean up current plant\n        if (_currentPlantObject != null)\n            DestroyImmediate(_currentPlantObject);\n\n        // Reset patch state\n        _currentState = PatchState.Empty;\n        _currentPlant = null;\n        _currentGrowthStage = -1;\n        _isWatered = false;\n\n        // Show soil again\n        if (_currentSoilObject != null)\n            _currentSoilObject.SetActive(true);\n        else\n            UpdateSoilVisual();\n\n        PlaySound(_harvestSound);\n        PlayEffect(_harvestEffect);\n        OnPlantHarvested?.Invoke(harvestedPlant, harvestAmount);\n    }\n\n    public void WaterPatch()\n    {\n        if (_isWatered)\n            return;\n\n        _isWatered = true;\n        _wateringTime = Time.time;\n\n        if (_currentState == PatchState.Empty)\n            _currentState = PatchState.Watered;\n\n        UpdateSoilVisual();\n        PlaySound(_wateringSound);\n        OnPatchWatered?.Invoke();\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n            _audioSource.PlayOneShot(clip);\n    }\n\n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n            effect.Play();\n    }\n\n    public bool CanPlant()\n    {\n        return _currentState == PatchState.Empty || _currentState == PatchState.Watered;\n    }\n\n    public bool CanHarvest()\n    {\n        return _currentState == PatchState.ReadyToHarvest;\n    }\n\n    public bool IsWatered()\n    {\n        return _isWatered;\n    }\n\n    public float GetGrowthProgress()\n    {\n        if (_currentState != PatchState.Growing || _currentPlant == null)\n            return 0f;\n\n        float progress = (Time.time - _plantingTime) / _currentPlant.growthTime;\n        if (_isWatered)\n            progress *= 1.5f;\n\n        return Mathf.Clamp01(progress);\n    }\n\n    public string GetCurrentPlantName()\n    {\n        return _currentPlant?.plantName ?? \"\";\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VoteKickSystem\",\n  \"components\": [\n    \"NetworkBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"votesRequired\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"voteTimeLimit\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"currentVotes\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"targetPlayer\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"voteActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"votedPlayers\",\n      \"type\": \"List<string>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"voteStartTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"lastVoteTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_vote_kick\",\n      \"trigger\": \"when player requests to kick another player and no vote is currently active and cooldown period has passed\",\n      \"actions\": [\n        {\n          \"action\": \"set target player to the player being voted against\"\n        },\n        {\n          \"action\": \"mark vote as active\"\n        },\n        {\n          \"action\": \"reset current vote count to zero\"\n        },\n        {\n          \"action\": \"clear the list of players who have voted\"\n        },\n        {\n          \"action\": \"record the current time as vote start time\"\n        },\n        {\n          \"action\": \"notify all players that a vote kick has been initiated\"\n        },\n        {\n          \"action\": \"display vote kick UI to all players\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cast_vote\",\n      \"trigger\": \"when player votes yes on an active vote kick and player has not already voted\",\n      \"actions\": [\n        {\n          \"action\": \"add player to the list of players who have voted\"\n        },\n        {\n          \"action\": \"increase current vote count by one\"\n        },\n        {\n          \"action\": \"update vote display for all players\"\n        },\n        {\n          \"action\": \"notify all players of the new vote count\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_kick\",\n      \"trigger\": \"when current vote count reaches or exceeds required votes\",\n      \"actions\": [\n        {\n          \"action\": \"kick the target player from the game\"\n        },\n        {\n          \"action\": \"notify all players that the vote kick was successful\"\n        },\n        {\n          \"action\": \"mark vote as inactive\"\n        },\n        {\n          \"action\": \"record current time as last vote time for cooldown\"\n        },\n        {\n          \"action\": \"hide vote kick UI\"\n        },\n        {\n          \"action\": \"clear target player and vote data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"timeout_vote\",\n      \"trigger\": \"when vote time limit has been exceeded and vote is still active\",\n      \"actions\": [\n        {\n          \"action\": \"notify all players that the vote kick has failed due to timeout\"\n        },\n        {\n          \"action\": \"mark vote as inactive\"\n        },\n        {\n          \"action\": \"record current time as last vote time for cooldown\"\n        },\n        {\n          \"action\": \"hide vote kick UI\"\n        },\n        {\n          \"action\": \"clear target player and vote data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_vote_target_left\",\n      \"trigger\": \"when target player leaves the game during an active vote\",\n      \"actions\": [\n        {\n          \"action\": \"notify all players that the vote has been cancelled because target left\"\n        },\n        {\n          \"action\": \"mark vote as inactive\"\n        },\n        {\n          \"action\": \"hide vote kick UI\"\n        },\n        {\n          \"action\": \"clear target player and vote data\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_vote_display\",\n      \"trigger\": \"when vote status changes or time remaining changes\",\n      \"actions\": [\n        {\n          \"action\": \"update UI to show current vote count and required votes\"\n        },\n        {\n          \"action\": \"update UI to show time remaining for the vote\"\n        },\n        {\n          \"action\": \"update UI to show which player is being voted against\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class VoteKickSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class Player\n    {\n        public string playerName;\n        public int playerId;\n        public bool isConnected;\n        public bool hasVoted;\n        public bool votedYes;\n        \n        public Player(string name, int id)\n        {\n            playerName = name;\n            playerId = id;\n            isConnected = true;\n            hasVoted = false;\n            votedYes = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class VoteKickEvent : UnityEvent<string, bool> { }\n    \n    [Header(\"Vote Settings\")]\n    [SerializeField] private float _voteDuration = 30f;\n    [SerializeField] private float _votePassThreshold = 0.6f;\n    [SerializeField] private int _minimumPlayersRequired = 3;\n    [SerializeField] private float _cooldownBetweenVotes = 60f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private GameObject _voteKickPanel;\n    [SerializeField] private Text _voteTargetText;\n    [SerializeField] private Text _voteTimerText;\n    [SerializeField] private Text _voteCountText;\n    [SerializeField] private Button _yesButton;\n    [SerializeField] private Button _noButton;\n    [SerializeField] private Button _initiateVoteButton;\n    [SerializeField] private Dropdown _playerDropdown;\n    [SerializeField] private Text _statusText;\n    \n    [Header(\"Events\")]\n    public VoteKickEvent OnVoteKickComplete;\n    public UnityEvent OnVoteKickStarted;\n    public UnityEvent OnVoteKickCancelled;\n    \n    private List<Player> _players = new List<Player>();\n    private bool _voteInProgress = false;\n    private float _voteTimer = 0f;\n    private string _targetPlayerName = \"\";\n    private int _targetPlayerId = -1;\n    private int _yesVotes = 0;\n    private int _noVotes = 0;\n    private bool _isOnCooldown = false;\n    private float _cooldownTimer = 0f;\n    private int _localPlayerId = 0;\n    \n    private void Start()\n    {\n        InitializeUI();\n        InitializePlayers();\n        UpdatePlayerDropdown();\n    }\n    \n    private void Update()\n    {\n        HandleVoteTimer();\n        HandleCooldownTimer();\n        UpdateUI();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(false);\n            \n        if (_yesButton != null)\n            _yesButton.onClick.AddListener(() => CastVote(true));\n            \n        if (_noButton != null)\n            _noButton.onClick.AddListener(() => CastVote(false));\n            \n        if (_initiateVoteButton != null)\n            _initiateVoteButton.onClick.AddListener(InitiateVoteKick);\n    }\n    \n    private void InitializePlayers()\n    {\n        _players.Clear();\n        _players.Add(new Player(\"Player1\", 0));\n        _players.Add(new Player(\"Player2\", 1));\n        _players.Add(new Player(\"Player3\", 2));\n        _players.Add(new Player(\"Player4\", 3));\n        \n        _localPlayerId = 0;\n    }\n    \n    private void UpdatePlayerDropdown()\n    {\n        if (_playerDropdown == null) return;\n        \n        _playerDropdown.ClearOptions();\n        List<string> playerNames = new List<string>();\n        \n        foreach (Player player in _players)\n        {\n            if (player.isConnected && player.playerId != _localPlayerId)\n            {\n                playerNames.Add(player.playerName);\n            }\n        }\n        \n        _playerDropdown.AddOptions(playerNames);\n    }\n    \n    public void InitiateVoteKick()\n    {\n        if (_voteInProgress)\n        {\n            UpdateStatusText(\"Vote already in progress!\");\n            return;\n        }\n        \n        if (_isOnCooldown)\n        {\n            UpdateStatusText($\"Vote cooldown active: {_cooldownTimer:F0}s remaining\");\n            return;\n        }\n        \n        if (GetConnectedPlayerCount() < _minimumPlayersRequired)\n        {\n            UpdateStatusText($\"Need at least {_minimumPlayersRequired} players to vote\");\n            return;\n        }\n        \n        if (_playerDropdown != null && _playerDropdown.options.Count > 0)\n        {\n            string selectedPlayerName = _playerDropdown.options[_playerDropdown.value].text;\n            Player targetPlayer = GetPlayerByName(selectedPlayerName);\n            \n            if (targetPlayer != null)\n            {\n                StartVoteKick(targetPlayer.playerName, targetPlayer.playerId);\n            }\n        }\n    }\n    \n    public void StartVoteKick(string targetName, int targetId)\n    {\n        if (_voteInProgress) return;\n        \n        _voteInProgress = true;\n        _targetPlayerName = targetName;\n        _targetPlayerId = targetId;\n        _voteTimer = _voteDuration;\n        _yesVotes = 0;\n        _noVotes = 0;\n        \n        ResetPlayerVotes();\n        \n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(true);\n            \n        UpdateStatusText($\"Vote to kick {targetName} started!\");\n        OnVoteKickStarted?.Invoke();\n    }\n    \n    public void CastVote(bool voteYes)\n    {\n        if (!_voteInProgress) return;\n        \n        Player localPlayer = GetPlayerById(_localPlayerId);\n        if (localPlayer == null || localPlayer.hasVoted) return;\n        \n        localPlayer.hasVoted = true;\n        localPlayer.votedYes = voteYes;\n        \n        if (voteYes)\n            _yesVotes++;\n        else\n            _noVotes++;\n            \n        UpdateStatusText($\"Vote cast: {(voteYes ? \"Yes\" : \"No\")}\");\n        \n        if (_yesButton != null)\n            _yesButton.interactable = false;\n        if (_noButton != null)\n            _noButton.interactable = false;\n            \n        CheckVoteCompletion();\n    }\n    \n    private void HandleVoteTimer()\n    {\n        if (!_voteInProgress) return;\n        \n        _voteTimer -= Time.deltaTime;\n        \n        if (_voteTimer <= 0f)\n        {\n            CompleteVote();\n        }\n    }\n    \n    private void HandleCooldownTimer()\n    {\n        if (!_isOnCooldown) return;\n        \n        _cooldownTimer -= Time.deltaTime;\n        \n        if (_cooldownTimer <= 0f)\n        {\n            _isOnCooldown = false;\n            UpdateStatusText(\"Vote cooldown expired. You can initiate votes again.\");\n        }\n    }\n    \n    private void CheckVoteCompletion()\n    {\n        int connectedPlayers = GetConnectedPlayerCount();\n        int totalVotes = _yesVotes + _noVotes;\n        \n        if (totalVotes >= connectedPlayers - 1)\n        {\n            CompleteVote();\n        }\n        else\n        {\n            float requiredYesVotes = (connectedPlayers - 1) * _votePassThreshold;\n            if (_yesVotes >= requiredYesVotes)\n            {\n                CompleteVote();\n            }\n        }\n    }\n    \n    private void CompleteVote()\n    {\n        if (!_voteInProgress) return;\n        \n        int connectedPlayers = GetConnectedPlayerCount();\n        float yesPercentage = (float)_yesVotes / (connectedPlayers - 1);\n        bool votesPassed = yesPercentage >= _votePassThreshold;\n        \n        if (votesPassed)\n        {\n            UpdateStatusText($\"{_targetPlayerName} has been kicked!\");\n            KickPlayer(_targetPlayerId);\n        }\n        else\n        {\n            UpdateStatusText($\"Vote to kick {_targetPlayerName} failed.\");\n        }\n        \n        OnVoteKickComplete?.Invoke(_targetPlayerName, votesPassed);\n        EndVote();\n        StartCooldown();\n    }\n    \n    private void KickPlayer(int playerId)\n    {\n        Player playerToKick = GetPlayerById(playerId);\n        if (playerToKick != null)\n        {\n            playerToKick.isConnected = false;\n            UpdatePlayerDropdown();\n        }\n    }\n    \n    private void EndVote()\n    {\n        _voteInProgress = false;\n        _targetPlayerName = \"\";\n        _targetPlayerId = -1;\n        _yesVotes = 0;\n        _noVotes = 0;\n        \n        if (_voteKickPanel != null)\n            _voteKickPanel.SetActive(false);\n            \n        if (_yesButton != null)\n            _yesButton.interactable = true;\n        if (_noButton != null)\n            _noButton.interactable = true;\n            \n        ResetPlayerVotes();\n    }\n    \n    private void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownBetweenVotes;\n    }\n    \n    private void ResetPlayerVotes()\n    {\n        foreach (Player player in _players)\n        {\n            player.hasVoted = false;\n            player.votedYes = false;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_voteTargetText != null && _voteInProgress)\n            _voteTargetText.text = $\"Kick {_targetPlayerName}?\";\n            \n        if (_voteTimerText != null && _voteInProgress)\n            _voteTimerText.text = $\"Time: {_voteTimer:F0}s\";\n            \n        if (_voteCountText != null && _voteInProgress)\n        {\n            int totalEligibleVoters = GetConnectedPlayerCount() - 1;\n            _voteCountText.text = $\"Yes: {_yesVotes} | No: {_noVotes} | Total: {totalEligibleVoters}\";\n        }\n        \n        if (_initiateVoteButton != null)\n        {\n            _initiateVoteButton.interactable = !_voteInProgress && !_isOnCooldown && \n                                             GetConnectedPlayerCount() >= _minimumPlayersRequired;\n        }\n    }\n    \n    private void UpdateStatusText(string message)\n    {\n        if (_statusText != null)\n            _statusText.text = message;\n            \n        StartCoroutine(ClearStatusAfterDelay(3f));\n    }\n    \n    private IEnumerator ClearStatusAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        if (_statusText != null && !_voteInProgress)\n            _statusText.text = \"\";\n    }\n    \n    private Player GetPlayerById(int id)\n    {\n        return _players.Find(p => p.playerId == id);\n    }\n    \n    private Player GetPlayerByName(string name)\n    {\n        return _players.Find(p => p.playerName == name);\n    }\n    \n    private int GetConnectedPlayerCount()\n    {\n        int count = 0;\n        foreach (Player player in _players)\n        {\n            if (player.isConnected)\n                count++;\n        }\n        return count;\n    }\n    \n    public void AddPlayer(string playerName, int playerId)\n    {\n        if (GetPlayerById(playerId) == null)\n        {\n            _players.Add(new Player(playerName, playerId));\n            UpdatePlayerDropdown();\n        }\n    }\n    \n    public void RemovePlayer(int playerId)\n    {\n        Player player = GetPlayerById(playerId);\n        if (player != null)\n        {\n            player.isConnected = false;\n            UpdatePlayerDropdown();\n            \n            if (_voteInProgress && playerId == _targetPlayerId)\n            {\n                UpdateStatusText(\"Target player disconnected. Vote cancelled.\");\n                OnVoteKickCancelled?.Invoke();\n                EndVote();\n            }\n        }\n    }\n    \n    public void CancelCurrentVote()\n    {\n        if (_voteInProgress)\n        {\n            UpdateStatusText(\"Vote cancelled by administrator.\");\n            OnVoteKickCancelled?.Invoke();\n            EndVote();\n        }\n    }\n    \n    public bool IsVoteInProgress()\n    {\n        return _voteInProgress;\n    }\n    \n    public float GetRemainingVoteTime()\n    {\n        return _voteInProgress ? _voteTimer : 0f;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetRemainingCooldownTime()\n    {\n        return _isOnCooldown ? _cooldownTimer : 0f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwimmingDive\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"diveSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"surfaceSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"maxDiveDepth\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"oxygenCapacity\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"oxygenDrainRate\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isUnderwater\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentOxygen\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_dive\",\n      \"trigger\": \"when dive input is pressed and character is at water surface\",\n      \"actions\": [\n        {\n          \"action\": \"play diving animation\"\n        },\n        {\n          \"action\": \"set underwater state to true\"\n        },\n        {\n          \"action\": \"apply downward diving force\"\n        },\n        {\n          \"action\": \"start oxygen consumption\"\n        }\n      ]\n    },\n    {\n      \"name\": \"underwater_movement\",\n      \"trigger\": \"when character is underwater and movement input is detected\",\n      \"actions\": [\n        {\n          \"action\": \"move in input direction at dive speed\"\n        },\n        {\n          \"action\": \"apply water resistance to movement\"\n        },\n        {\n          \"action\": \"play swimming animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"surface_ascent\",\n      \"trigger\": \"when surface input is pressed or oxygen is low\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward buoyancy force\"\n        },\n        {\n          \"action\": \"move toward water surface at surface speed\"\n        },\n        {\n          \"action\": \"play ascending animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reach_surface\",\n      \"trigger\": \"when character reaches water surface level\",\n      \"actions\": [\n        {\n          \"action\": \"set underwater state to false\"\n        },\n        {\n          \"action\": \"stop oxygen consumption\"\n        },\n        {\n          \"action\": \"restore oxygen to full capacity\"\n        },\n        {\n          \"action\": \"play surface breach animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"oxygen_depletion\",\n      \"trigger\": \"when underwater and oxygen reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"force immediate surface ascent\"\n        },\n        {\n          \"action\": \"apply health damage over time\"\n        },\n        {\n          \"action\": \"play drowning effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"depth_limit_check\",\n      \"trigger\": \"when diving depth exceeds maximum dive depth\",\n      \"actions\": [\n        {\n          \"action\": \"prevent further downward movement\"\n        },\n        {\n          \"action\": \"apply pressure damage\"\n        },\n        {\n          \"action\": \"increase oxygen drain rate\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SwimmingDive : MonoBehaviour\n{\n    [Header(\"Dive Settings\")]\n    [SerializeField] private float _diveForce = 15f;\n    [SerializeField] private float _diveAngle = 45f;\n    [SerializeField] private float _underwaterDrag = 5f;\n    [SerializeField] private float _surfaceDrag = 1f;\n    [SerializeField] private float _buoyancyForce = 10f;\n    [SerializeField] private float _maxDiveDepth = 20f;\n    \n    [Header(\"Water Detection\")]\n    [SerializeField] private LayerMask _waterLayer = 1;\n    [SerializeField] private Transform _waterCheckPoint;\n    [SerializeField] private float _waterCheckRadius = 0.5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _diveKey = KeyCode.Space;\n    [SerializeField] private KeyCode _surfaceKey = KeyCode.LeftShift;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    [SerializeField] private string _diveAnimationTrigger = \"Dive\";\n    [SerializeField] private string _swimAnimationBool = \"IsSwimming\";\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _splashEffect;\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _splashSound;\n    [SerializeField] private AudioClip _underwaterSound;\n    \n    private Rigidbody _rigidbody;\n    private bool _isUnderwater;\n    private bool _canDive = true;\n    private float _originalDrag;\n    private float _waterSurfaceY;\n    private Vector3 _diveStartPosition;\n    private float _currentDepth;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            Debug.LogError(\"SwimmingDive requires a Rigidbody component!\");\n            enabled = false;\n            return;\n        }\n        \n        _originalDrag = _rigidbody.drag;\n        \n        if (_waterCheckPoint == null)\n            _waterCheckPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        CheckWaterStatus();\n        HandleInput();\n        UpdateAnimations();\n        ApplyBuoyancy();\n        UpdateDepth();\n    }\n    \n    private void CheckWaterStatus()\n    {\n        bool wasUnderwater = _isUnderwater;\n        _isUnderwater = Physics.CheckSphere(_waterCheckPoint.position, _waterCheckRadius, _waterLayer);\n        \n        if (_isUnderwater != wasUnderwater)\n        {\n            OnWaterStatusChanged(_isUnderwater);\n        }\n        \n        if (_isUnderwater)\n        {\n            _rigidbody.drag = _underwaterDrag;\n            \n            Collider waterCollider = Physics.OverlapSphere(_waterCheckPoint.position, _waterCheckRadius, _waterLayer)[0];\n            if (waterCollider != null)\n            {\n                _waterSurfaceY = waterCollider.bounds.max.y;\n            }\n        }\n        else\n        {\n            _rigidbody.drag = _originalDrag;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_diveKey) && _canDive)\n        {\n            if (_isUnderwater)\n            {\n                PerformUnderwaterDive();\n            }\n            else\n            {\n                PerformSurfaceDive();\n            }\n        }\n        \n        if (Input.GetKey(_surfaceKey) && _isUnderwater)\n        {\n            SwimToSurface();\n        }\n    }\n    \n    private void PerformSurfaceDive()\n    {\n        Vector3 diveDirection = Quaternion.AngleAxis(-_diveAngle, transform.right) * transform.forward;\n        _rigidbody.AddForce(diveDirection * _diveForce, ForceMode.Impulse);\n        \n        _diveStartPosition = transform.position;\n        _canDive = false;\n        \n        if (_animator != null)\n            _animator.SetTrigger(_diveAnimationTrigger);\n            \n        if (_splashEffect != null && !_isUnderwater)\n            _splashEffect.Play();\n            \n        PlaySound(_splashSound);\n        \n        Invoke(nameof(ResetDiveAbility), 1f);\n    }\n    \n    private void PerformUnderwaterDive()\n    {\n        Vector3 diveDirection = -transform.up;\n        _rigidbody.AddForce(diveDirection * _diveForce * 0.7f, ForceMode.Impulse);\n        \n        _canDive = false;\n        Invoke(nameof(ResetDiveAbility), 0.5f);\n    }\n    \n    private void SwimToSurface()\n    {\n        Vector3 surfaceDirection = Vector3.up;\n        _rigidbody.AddForce(surfaceDirection * _buoyancyForce * 1.5f, ForceMode.Force);\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isUnderwater)\n        {\n            float buoyancyMultiplier = Mathf.Clamp01(_currentDepth / _maxDiveDepth);\n            Vector3 buoyancyForceVector = Vector3.up * _buoyancyForce * buoyancyMultiplier;\n            _rigidbody.AddForce(buoyancyForceVector, ForceMode.Force);\n            \n            if (_bubbleEffect != null && !_bubbleEffect.isPlaying)\n                _bubbleEffect.Play();\n        }\n        else\n        {\n            if (_bubbleEffect != null && _bubbleEffect.isPlaying)\n                _bubbleEffect.Stop();\n        }\n    }\n    \n    private void UpdateDepth()\n    {\n        if (_isUnderwater)\n        {\n            _currentDepth = Mathf.Max(0, _waterSurfaceY - transform.position.y);\n            \n            if (_currentDepth > _maxDiveDepth)\n            {\n                Vector3 position = transform.position;\n                position.y = _waterSurfaceY - _maxDiveDepth;\n                transform.position = position;\n                _currentDepth = _maxDiveDepth;\n            }\n        }\n        else\n        {\n            _currentDepth = 0f;\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator != null)\n        {\n            _animator.SetBool(_swimAnimationBool, _isUnderwater);\n        }\n    }\n    \n    private void OnWaterStatusChanged(bool enteredWater)\n    {\n        if (enteredWater)\n        {\n            PlaySound(_underwaterSound);\n            if (_splashEffect != null)\n                _splashEffect.Play();\n        }\n        else\n        {\n            if (_audioSource != null && _audioSource.clip == _underwaterSound)\n                _audioSource.Stop();\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.clip = clip;\n            _audioSource.Play();\n        }\n    }\n    \n    private void ResetDiveAbility()\n    {\n        _canDive = true;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_waterCheckPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(_waterCheckPoint.position, _waterCheckRadius);\n        }\n        \n        Gizmos.color = Color.red;\n        Vector3 diveDirection = Quaternion.AngleAxis(-_diveAngle, transform.right) * transform.forward;\n        Gizmos.DrawRay(transform.position, diveDirection * 3f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BouncyBall\",\n  \"components\": [\n    \"Rigidbody\",\n    \"SphereCollider\",\n    \"AudioSource\",\n    \"TrailRenderer\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"bounceCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"baseBounceForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"bounceMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"basePitch\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"pitchIncrement\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"maxBounces\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"trailDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"bounceColors\",\n      \"type\": \"Color[]\",\n      \"default\": \"rainbow array\"\n    },\n    {\n      \"name\": \"bounceSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"confettiPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"bounce_on_collision\",\n      \"trigger\": \"when ball collides with any surface\",\n      \"actions\": [\n        {\n          \"action\": \"increase bounce count by one\"\n        },\n        {\n          \"action\": \"apply upward bounce force multiplied by bounce count and bounce multiplier\"\n        },\n        {\n          \"action\": \"play bounce sound with pitch increased by bounce count times pitch increment\"\n        },\n        {\n          \"action\": \"change ball color based on current bounce count using color array\"\n        },\n        {\n          \"action\": \"activate trail renderer for trail duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_after_max_bounces\",\n      \"trigger\": \"when bounce count reaches maximum bounces\",\n      \"actions\": [\n        {\n          \"action\": \"spawn confetti particle explosion at ball position\"\n        },\n        {\n          \"action\": \"play explosion sound effect\"\n        },\n        {\n          \"action\": \"destroy the ball object\"\n        },\n        {\n          \"action\": \"stop trail renderer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_trail\",\n      \"trigger\": \"continuously while trail is active\",\n      \"actions\": [\n        {\n          \"action\": \"gradually fade trail opacity over trail duration\"\n        },\n        {\n          \"action\": \"disable trail renderer when fully faded\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class BouncyBall : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _initialBounceForce = 10f;\n    [SerializeField] private float _bounceMultiplier = 1.2f;\n    [SerializeField] private int _maxBounces = 10;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _bounceSound;\n    [SerializeField] private float _basePitch = 0.5f;\n    [SerializeField] private float _pitchIncrement = 0.15f;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color[] _bounceColors = new Color[]\n    {\n        Color.white, Color.yellow, Color.orange, Color.red, \n        Color.magenta, Color.blue, Color.cyan, Color.green,\n        Color.gray, Color.black\n    };\n    \n    [Header(\"Trail Settings\")]\n    [SerializeField] private float _trailTime = 0.5f;\n    [SerializeField] private float _trailWidth = 0.1f;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private int _confettiCount = 50;\n    [SerializeField] private float _explosionForce = 15f;\n    [SerializeField] private float _confettiLifetime = 3f;\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private TrailRenderer _trailRenderer;\n    private int _bounceCount = 0;\n    private float _currentBounceForce;\n    private bool _hasExploded = false;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupTrail();\n        _currentBounceForce = _initialBounceForce;\n    }\n    \n    void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n        {\n            gameObject.AddComponent<MeshRenderer>();\n            _renderer = GetComponent<Renderer>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (GetComponent<Collider>() == null)\n            gameObject.AddComponent<SphereCollider>();\n    }\n    \n    void SetupTrail()\n    {\n        _trailRenderer = GetComponent<TrailRenderer>();\n        if (_trailRenderer == null)\n            _trailRenderer = gameObject.AddComponent<TrailRenderer>();\n            \n        _trailRenderer.time = _trailTime;\n        _trailRenderer.startWidth = _trailWidth;\n        _trailRenderer.endWidth = 0f;\n        _trailRenderer.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _trailRenderer.color = Color.white;\n    }\n    \n    void OnCollisionEnter(Collision collision)\n    {\n        if (_hasExploded) return;\n        \n        _bounceCount++;\n        \n        if (_bounceCount >= _maxBounces)\n        {\n            ExplodeIntoConfetti();\n            return;\n        }\n        \n        PerformBounce(collision);\n        PlayBounceSound();\n        UpdateVisuals();\n    }\n    \n    void PerformBounce(Collision collision)\n    {\n        Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n        _currentBounceForce *= _bounceMultiplier;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.AddForce(bounceDirection * _currentBounceForce, ForceMode.Impulse);\n    }\n    \n    void PlayBounceSound()\n    {\n        if (_bounceSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _bounceSound;\n            _audioSource.pitch = _basePitch + (_pitchIncrement * _bounceCount);\n            _audioSource.Play();\n        }\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_renderer != null && _bounceColors.Length > 0)\n        {\n            int colorIndex = Mathf.Clamp(_bounceCount - 1, 0, _bounceColors.Length - 1);\n            _renderer.material.color = _bounceColors[colorIndex];\n            \n            if (_trailRenderer != null)\n                _trailRenderer.color = _bounceColors[colorIndex];\n        }\n    }\n    \n    void ExplodeIntoConfetti()\n    {\n        _hasExploded = true;\n        \n        for (int i = 0; i < _confettiCount; i++)\n        {\n            CreateConfettiPiece();\n        }\n        \n        if (_audioSource != null && _bounceSound != null)\n        {\n            _audioSource.pitch = _basePitch + (_pitchIncrement * _maxBounces);\n            _audioSource.Play();\n        }\n        \n        StartCoroutine(DestroyAfterExplosion());\n    }\n    \n    void CreateConfettiPiece()\n    {\n        GameObject confetti = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        confetti.transform.position = transform.position + Random.insideUnitSphere * 0.5f;\n        confetti.transform.localScale = Vector3.one * Random.Range(0.05f, 0.15f);\n        \n        Renderer confettiRenderer = confetti.GetComponent<Renderer>();\n        if (confettiRenderer != null && _bounceColors.Length > 0)\n        {\n            confettiRenderer.material.color = _bounceColors[Random.Range(0, _bounceColors.Length)];\n        }\n        \n        Rigidbody confettiRb = confetti.AddComponent<Rigidbody>();\n        Vector3 explosionDirection = Random.insideUnitSphere;\n        confettiRb.AddForce(explosionDirection * _explosionForce, ForceMode.Impulse);\n        confettiRb.AddTorque(Random.insideUnitSphere * 10f, ForceMode.Impulse);\n        \n        StartCoroutine(DestroyConfetti(confetti));\n    }\n    \n    IEnumerator DestroyConfetti(GameObject confetti)\n    {\n        yield return new WaitForSeconds(_confettiLifetime);\n        if (confetti != null)\n            Destroy(confetti);\n    }\n    \n    IEnumerator DestroyAfterExplosion()\n    {\n        if (_renderer != null)\n            _renderer.enabled = false;\n            \n        if (_trailRenderer != null)\n            _trailRenderer.enabled = false;\n            \n        yield return new WaitForSeconds(1f);\n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CollapsingBridge\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"collapseDelay\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"shakeIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"hasCollapsed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isShaking\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_collapse\",\n      \"trigger\": \"when player steps onto the bridge\",\n      \"actions\": [\n        {\n          \"action\": \"start shaking the bridge\"\n        },\n        {\n          \"action\": \"play creaking sound effect\"\n        },\n        {\n          \"action\": \"wait for collapse delay duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shake_bridge\",\n      \"trigger\": \"when bridge is shaking\",\n      \"actions\": [\n        {\n          \"action\": \"randomly move bridge position slightly up and down\"\n        },\n        {\n          \"action\": \"randomly rotate bridge slightly left and right\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collapse_bridge\",\n      \"trigger\": \"when collapse delay time has passed\",\n      \"actions\": [\n        {\n          \"action\": \"stop shaking\"\n        },\n        {\n          \"action\": \"enable physics on bridge\"\n        },\n        {\n          \"action\": \"apply downward force to make bridge fall\"\n        },\n        {\n          \"action\": \"play collapse sound effect\"\n        },\n        {\n          \"action\": \"mark bridge as collapsed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_reuse\",\n      \"trigger\": \"when bridge has already collapsed\",\n      \"actions\": [\n        {\n          \"action\": \"ignore any further player interactions\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class CollapsingBridge : MonoBehaviour\n{\n    [Header(\"Bridge Settings\")]\n    [SerializeField] private float _collapseDelay = 2f;\n    [SerializeField] private float _collapseSpeed = 5f;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 1.5f;\n    [SerializeField] private bool _resetAfterCollapse = true;\n    [SerializeField] private float _resetDelay = 5f;\n    \n    [Header(\"Bridge Segments\")]\n    [SerializeField] private Transform[] _bridgeSegments;\n    [SerializeField] private float _segmentCollapseInterval = 0.2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _crackingSound;\n    [SerializeField] private AudioClip _collapseSound;\n    \n    [Header(\"Particles\")]\n    [SerializeField] private ParticleSystem _dustParticles;\n    [SerializeField] private ParticleSystem _debrisParticles;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBridgeTriggered;\n    public UnityEvent OnBridgeCollapsed;\n    public UnityEvent OnBridgeReset;\n    \n    private bool _isCollapsing = false;\n    private bool _hasCollapsed = false;\n    private Vector3[] _originalPositions;\n    private Quaternion[] _originalRotations;\n    private Rigidbody[] _segmentRigidbodies;\n    private Collider _triggerCollider;\n    private List<GameObject> _playersOnBridge = new List<GameObject>();\n    \n    private void Start()\n    {\n        InitializeBridge();\n    }\n    \n    private void InitializeBridge()\n    {\n        _triggerCollider = GetComponent<Collider>();\n        if (_triggerCollider != null)\n        {\n            _triggerCollider.isTrigger = true;\n        }\n        \n        if (_bridgeSegments == null || _bridgeSegments.Length == 0)\n        {\n            _bridgeSegments = new Transform[transform.childCount];\n            for (int i = 0; i < transform.childCount; i++)\n            {\n                _bridgeSegments[i] = transform.GetChild(i);\n            }\n        }\n        \n        _originalPositions = new Vector3[_bridgeSegments.Length];\n        _originalRotations = new Quaternion[_bridgeSegments.Length];\n        _segmentRigidbodies = new Rigidbody[_bridgeSegments.Length];\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null)\n            {\n                _originalPositions[i] = _bridgeSegments[i].position;\n                _originalRotations[i] = _bridgeSegments[i].rotation;\n                \n                _segmentRigidbodies[i] = _bridgeSegments[i].GetComponent<Rigidbody>();\n                if (_segmentRigidbodies[i] == null)\n                {\n                    _segmentRigidbodies[i] = _bridgeSegments[i].gameObject.AddComponent<Rigidbody>();\n                }\n                _segmentRigidbodies[i].isKinematic = true;\n            }\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\") && !_isCollapsing && !_hasCollapsed)\n        {\n            if (!_playersOnBridge.Contains(other.gameObject))\n            {\n                _playersOnBridge.Add(other.gameObject);\n                \n                if (_playersOnBridge.Count == 1)\n                {\n                    StartCoroutine(TriggerCollapse());\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playersOnBridge.Remove(other.gameObject);\n        }\n    }\n    \n    private IEnumerator TriggerCollapse()\n    {\n        _isCollapsing = true;\n        OnBridgeTriggered.Invoke();\n        \n        if (_crackingSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_crackingSound);\n        }\n        \n        StartCoroutine(ShakeBridge());\n        \n        yield return new WaitForSeconds(_collapseDelay);\n        \n        StartCoroutine(CollapseBridge());\n    }\n    \n    private IEnumerator ShakeBridge()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _shakeDuration)\n        {\n            for (int i = 0; i < _bridgeSegments.Length; i++)\n            {\n                if (_bridgeSegments[i] != null)\n                {\n                    Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n                    randomOffset.y = Mathf.Abs(randomOffset.y);\n                    _bridgeSegments[i].position = _originalPositions[i] + randomOffset;\n                }\n            }\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null)\n            {\n                _bridgeSegments[i].position = _originalPositions[i];\n            }\n        }\n    }\n    \n    private IEnumerator CollapseBridge()\n    {\n        if (_collapseSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_collapseSound);\n        }\n        \n        if (_dustParticles != null)\n        {\n            _dustParticles.Play();\n        }\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = false;\n                _segmentRigidbodies[i].AddForce(Vector3.down * _collapseSpeed, ForceMode.VelocityChange);\n                _segmentRigidbodies[i].AddTorque(Random.insideUnitSphere * _collapseSpeed * 0.5f, ForceMode.VelocityChange);\n                \n                if (_debrisParticles != null)\n                {\n                    ParticleSystem debris = Instantiate(_debrisParticles, _bridgeSegments[i].position, Quaternion.identity);\n                    debris.Play();\n                    Destroy(debris.gameObject, 3f);\n                }\n                \n                yield return new WaitForSeconds(_segmentCollapseInterval);\n            }\n        }\n        \n        _hasCollapsed = true;\n        OnBridgeCollapsed.Invoke();\n        \n        if (_resetAfterCollapse)\n        {\n            StartCoroutine(ResetBridge());\n        }\n    }\n    \n    private IEnumerator ResetBridge()\n    {\n        yield return new WaitForSeconds(_resetDelay);\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = true;\n                _segmentRigidbodies[i].velocity = Vector3.zero;\n                _segmentRigidbodies[i].angularVelocity = Vector3.zero;\n                \n                _bridgeSegments[i].position = _originalPositions[i];\n                _bridgeSegments[i].rotation = _originalRotations[i];\n            }\n        }\n        \n        _isCollapsing = false;\n        _hasCollapsed = false;\n        _playersOnBridge.Clear();\n        \n        OnBridgeReset.Invoke();\n    }\n    \n    public void ForceCollapse()\n    {\n        if (!_isCollapsing && !_hasCollapsed)\n        {\n            StartCoroutine(TriggerCollapse());\n        }\n    }\n    \n    public void ResetBridgeImmediate()\n    {\n        StopAllCoroutines();\n        \n        for (int i = 0; i < _bridgeSegments.Length; i++)\n        {\n            if (_bridgeSegments[i] != null && _segmentRigidbodies[i] != null)\n            {\n                _segmentRigidbodies[i].isKinematic = true;\n                _segmentRigidbodies[i].velocity = Vector3.zero;\n                _segmentRigidbodies[i].angularVelocity = Vector3.zero;\n                \n                _bridgeSegments[i].position = _originalPositions[i];\n                _bridgeSegments[i].rotation = _originalRotations[i];\n            }\n        }\n        \n        _isCollapsing = false;\n        _hasCollapsed = false;\n        _playersOnBridge.Clear();\n        \n        OnBridgeReset.Invoke();\n    }\n    \n    public bool IsCollapsed => _hasCollapsed;\n    public bool IsCollapsing => _isCollapsing;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CrumblingPlatform\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"crumbleDelay\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"hasBeenStepped\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isCrumbling\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_step\",\n      \"trigger\": \"when player steps on platform\",\n      \"actions\": [\n        {\n          \"action\": \"mark platform as stepped on\"\n        },\n        {\n          \"action\": \"start crumble countdown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"begin_crumbling\",\n      \"trigger\": \"when crumble delay time has elapsed after being stepped on\",\n      \"actions\": [\n        {\n          \"action\": \"mark platform as crumbling\"\n        },\n        {\n          \"action\": \"enable physics gravity\"\n        },\n        {\n          \"action\": \"play crumbling sound effect\"\n        },\n        {\n          \"action\": \"start particle effects for debris\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fall_down\",\n      \"trigger\": \"when platform is crumbling\",\n      \"actions\": [\n        {\n          \"action\": \"fall downward at fall speed\"\n        },\n        {\n          \"action\": \"continue playing debris particles\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_platform\",\n      \"trigger\": \"when platform has fallen far below original position\",\n      \"actions\": [\n        {\n          \"action\": \"destroy platform object\"\n        },\n        {\n          \"action\": \"stop all particle effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class CrumblingPlatform : MonoBehaviour\n{\n    [Header(\"Crumbling Settings\")]\n    [SerializeField] private float _crumbleDelay = 1.0f;\n    [SerializeField] private float _fallSpeed = 5.0f;\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeDuration = 0.8f;\n    [SerializeField] private float _respawnDelay = 5.0f;\n    [SerializeField] private bool _respawnAfterFall = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _crumbleSound;\n    [SerializeField] private AudioClip _fallSound;\n    \n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private bool _isTriggered = false;\n    private bool _isFalling = false;\n    private Rigidbody _rigidbody;\n    private Collider _platformCollider;\n    private AudioSource _audioSource;\n    private Coroutine _crumbleCoroutine;\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        _rigidbody.isKinematic = true;\n        \n        _platformCollider = GetComponent<Collider>();\n        if (_platformCollider == null)\n        {\n            _platformCollider = gameObject.AddComponent<BoxCollider>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isTriggered && !_isFalling && other.CompareTag(\"Player\"))\n        {\n            TriggerCrumble();\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!_isTriggered && !_isFalling && collision.gameObject.CompareTag(\"Player\"))\n        {\n            TriggerCrumble();\n        }\n    }\n    \n    private void TriggerCrumble()\n    {\n        _isTriggered = true;\n        \n        if (_crumbleCoroutine != null)\n        {\n            StopCoroutine(_crumbleCoroutine);\n        }\n        \n        _crumbleCoroutine = StartCoroutine(CrumbleSequence());\n    }\n    \n    private IEnumerator CrumbleSequence()\n    {\n        // Play crumble sound\n        if (_crumbleSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_crumbleSound);\n        }\n        \n        // Shake effect\n        float shakeTimer = 0f;\n        Vector3 shakePosition = _originalPosition;\n        \n        while (shakeTimer < _shakeDuration)\n        {\n            Vector3 randomOffset = Random.insideUnitSphere * _shakeIntensity;\n            randomOffset.y = Mathf.Abs(randomOffset.y) * 0.5f; // Reduce vertical shake\n            transform.position = shakePosition + randomOffset;\n            \n            shakeTimer += Time.deltaTime;\n            yield return null;\n        }\n        \n        // Wait for crumble delay\n        yield return new WaitForSeconds(_crumbleDelay - _shakeDuration);\n        \n        // Start falling\n        StartFalling();\n    }\n    \n    private void StartFalling()\n    {\n        _isFalling = true;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        \n        // Add downward force\n        _rigidbody.AddForce(Vector3.down * _fallSpeed, ForceMode.VelocityChange);\n        \n        // Play fall sound\n        if (_fallSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_fallSound);\n        }\n        \n        // Start respawn timer if enabled\n        if (_respawnAfterFall)\n        {\n            StartCoroutine(RespawnAfterDelay());\n        }\n    }\n    \n    private IEnumerator RespawnAfterDelay()\n    {\n        yield return new WaitForSeconds(_respawnDelay);\n        RespawnPlatform();\n    }\n    \n    private void RespawnPlatform()\n    {\n        // Reset position and rotation\n        transform.position = _originalPosition;\n        transform.rotation = _originalRotation;\n        \n        // Reset rigidbody\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        \n        // Reset flags\n        _isTriggered = false;\n        _isFalling = false;\n        \n        // Re-enable collider if it was disabled\n        if (_platformCollider != null)\n        {\n            _platformCollider.enabled = true;\n        }\n    }\n    \n    public void ResetPlatform()\n    {\n        if (_crumbleCoroutine != null)\n        {\n            StopCoroutine(_crumbleCoroutine);\n            _crumbleCoroutine = null;\n        }\n        \n        StopAllCoroutines();\n        RespawnPlatform();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(transform.position, transform.localScale);\n        \n        if (Application.isPlaying && _isTriggered)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCube(transform.position, transform.localScale * 1.1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DayNightCycle\",\n  \"components\": [\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dayDuration\",\n      \"type\": \"float\",\n      \"default\": 120\n    },\n    {\n      \"name\": \"nightDuration\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"dayIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"nightIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"dayColor\",\n      \"type\": \"Color\",\n      \"default\": \"white\"\n    },\n    {\n      \"name\": \"nightColor\",\n      \"type\": \"Color\",\n      \"default\": \"blue\"\n    },\n    {\n      \"name\": \"transitionSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"currentTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isDay\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"cycle_time\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"increase current time by elapsed time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_night\",\n      \"trigger\": \"when current time exceeds day duration and it is currently day\",\n      \"actions\": [\n        {\n          \"action\": \"set is day to false\"\n        },\n        {\n          \"action\": \"reset current time to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_day\",\n      \"trigger\": \"when current time exceeds night duration and it is currently night\",\n      \"actions\": [\n        {\n          \"action\": \"set is day to true\"\n        },\n        {\n          \"action\": \"reset current time to zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_day_lighting\",\n      \"trigger\": \"when it is day\",\n      \"actions\": [\n        {\n          \"action\": \"gradually change light intensity toward day intensity\"\n        },\n        {\n          \"action\": \"gradually change light color toward day color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_night_lighting\",\n      \"trigger\": \"when it is night\",\n      \"actions\": [\n        {\n          \"action\": \"gradually change light intensity toward night intensity\"\n        },\n        {\n          \"action\": \"gradually change light color toward night color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class DayNightCycle : MonoBehaviour\n{\n    [Header(\"Time Settings\")]\n    [SerializeField] private float _dayDurationInMinutes = 10f;\n    [SerializeField] private float _currentTimeOfDay = 0.5f;\n    [SerializeField] private bool _pauseTime = false;\n    \n    [Header(\"Sun Settings\")]\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Transform _sunTransform;\n    [SerializeField] private Gradient _sunColorGradient;\n    [SerializeField] private AnimationCurve _sunIntensityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private float _maxSunIntensity = 1.5f;\n    \n    [Header(\"Moon Settings\")]\n    [SerializeField] private Light _moonLight;\n    [SerializeField] private Transform _moonTransform;\n    [SerializeField] private Color _moonColor = Color.blue;\n    [SerializeField] private float _maxMoonIntensity = 0.3f;\n    \n    [Header(\"Sky Settings\")]\n    [SerializeField] private Material _skyboxMaterial;\n    [SerializeField] private Gradient _fogColorGradient;\n    [SerializeField] private AnimationCurve _fogDensityCurve = AnimationCurve.EaseInOut(0f, 0.01f, 1f, 0.01f);\n    [SerializeField] private float _maxFogDensity = 0.05f;\n    \n    [Header(\"Ambient Settings\")]\n    [SerializeField] private Gradient _ambientColorGradient;\n    [SerializeField] private AnimationCurve _ambientIntensityCurve = AnimationCurve.EaseInOut(0f, 0.3f, 1f, 1f);\n    [SerializeField] private float _maxAmbientIntensity = 1f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnSunrise;\n    public UnityEvent OnNoon;\n    public UnityEvent OnSunset;\n    public UnityEvent OnMidnight;\n    \n    private float _timeSpeed;\n    private bool _hasSunriseTriggered = false;\n    private bool _hasNoonTriggered = false;\n    private bool _hasSunsetTriggered = false;\n    private bool _hasMidnightTriggered = false;\n    \n    private void Start()\n    {\n        _timeSpeed = 1f / (_dayDurationInMinutes * 60f);\n        \n        if (_sunLight == null)\n            _sunLight = FindObjectOfType<Light>();\n            \n        if (_sunTransform == null && _sunLight != null)\n            _sunTransform = _sunLight.transform;\n            \n        if (_skyboxMaterial == null)\n            _skyboxMaterial = RenderSettings.skybox;\n            \n        InitializeGradients();\n        UpdateCycle();\n    }\n    \n    private void Update()\n    {\n        if (!_pauseTime)\n        {\n            _currentTimeOfDay += Time.deltaTime * _timeSpeed;\n            \n            if (_currentTimeOfDay >= 1f)\n            {\n                _currentTimeOfDay = 0f;\n                ResetEventTriggers();\n            }\n            \n            UpdateCycle();\n            CheckTimeEvents();\n        }\n    }\n    \n    private void UpdateCycle()\n    {\n        UpdateSun();\n        UpdateMoon();\n        UpdateSkybox();\n        UpdateFog();\n        UpdateAmbientLighting();\n    }\n    \n    private void UpdateSun()\n    {\n        if (_sunLight == null) return;\n        \n        float sunAngle = _currentTimeOfDay * 360f - 90f;\n        \n        if (_sunTransform != null)\n        {\n            _sunTransform.rotation = Quaternion.Euler(sunAngle, 30f, 0f);\n        }\n        \n        float sunIntensity = _sunIntensityCurve.Evaluate(_currentTimeOfDay) * _maxSunIntensity;\n        _sunLight.intensity = sunIntensity;\n        \n        _sunLight.color = _sunColorGradient.Evaluate(_currentTimeOfDay);\n        \n        _sunLight.enabled = sunIntensity > 0.01f;\n    }\n    \n    private void UpdateMoon()\n    {\n        if (_moonLight == null) return;\n        \n        float moonAngle = (_currentTimeOfDay + 0.5f) % 1f * 360f - 90f;\n        \n        if (_moonTransform != null)\n        {\n            _moonTransform.rotation = Quaternion.Euler(moonAngle, 30f, 0f);\n        }\n        \n        float nightTime = Mathf.Abs(_currentTimeOfDay - 0.5f) * 2f;\n        nightTime = 1f - nightTime;\n        nightTime = Mathf.Clamp01(nightTime);\n        \n        float moonIntensity = nightTime * _maxMoonIntensity;\n        _moonLight.intensity = moonIntensity;\n        _moonLight.color = _moonColor;\n        \n        _moonLight.enabled = moonIntensity > 0.01f;\n    }\n    \n    private void UpdateSkybox()\n    {\n        if (_skyboxMaterial == null) return;\n        \n        if (_skyboxMaterial.HasProperty(\"_Exposure\"))\n        {\n            float exposure = _sunIntensityCurve.Evaluate(_currentTimeOfDay);\n            _skyboxMaterial.SetFloat(\"_Exposure\", exposure);\n        }\n        \n        if (_skyboxMaterial.HasProperty(\"_Tint\"))\n        {\n            Color tint = _sunColorGradient.Evaluate(_currentTimeOfDay);\n            _skyboxMaterial.SetColor(\"_Tint\", tint);\n        }\n    }\n    \n    private void UpdateFog()\n    {\n        RenderSettings.fog = true;\n        RenderSettings.fogColor = _fogColorGradient.Evaluate(_currentTimeOfDay);\n        RenderSettings.fogDensity = _fogDensityCurve.Evaluate(_currentTimeOfDay) * _maxFogDensity;\n    }\n    \n    private void UpdateAmbientLighting()\n    {\n        RenderSettings.ambientLight = _ambientColorGradient.Evaluate(_currentTimeOfDay);\n        RenderSettings.ambientIntensity = _ambientIntensityCurve.Evaluate(_currentTimeOfDay) * _maxAmbientIntensity;\n    }\n    \n    private void CheckTimeEvents()\n    {\n        if (_currentTimeOfDay >= 0.25f && _currentTimeOfDay < 0.26f && !_hasSunriseTriggered)\n        {\n            OnSunrise?.Invoke();\n            _hasSunriseTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.5f && _currentTimeOfDay < 0.51f && !_hasNoonTriggered)\n        {\n            OnNoon?.Invoke();\n            _hasNoonTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.75f && _currentTimeOfDay < 0.76f && !_hasSunsetTriggered)\n        {\n            OnSunset?.Invoke();\n            _hasSunsetTriggered = true;\n        }\n        else if (_currentTimeOfDay >= 0.99f && !_hasMidnightTriggered)\n        {\n            OnMidnight?.Invoke();\n            _hasMidnightTriggered = true;\n        }\n    }\n    \n    private void ResetEventTriggers()\n    {\n        _hasSunriseTriggered = false;\n        _hasNoonTriggered = false;\n        _hasSunsetTriggered = false;\n        _hasMidnightTriggered = false;\n    }\n    \n    private void InitializeGradients()\n    {\n        if (_sunColorGradient.colorKeys.Length == 0)\n        {\n            GradientColorKey[] colorKeys = new GradientColorKey[5];\n            colorKeys[0] = new GradientColorKey(new Color(0.2f, 0.2f, 0.4f), 0f);\n            colorKeys[1] = new GradientColorKey(new Color(1f, 0.6f, 0.3f), 0.25f);\n            colorKeys[2] = new GradientColorKey(Color.white, 0.5f);\n            colorKeys[3] = new GradientColorKey(new Color(1f, 0.4f, 0.2f), 0.75f);\n            colorKeys[4] = new GradientColorKey(new Color(0.2f, 0.2f, 0.4f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(1f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(1f, 1f);\n            \n            _sunColorGradient.SetKeys(colorKeys, alphaKeys);\n        }\n        \n        if (_fogColorGradient.colorKeys.Length == 0)\n        {\n            _fogColorGradient = _sunColorGradient;\n        }\n        \n        if (_ambientColorGradient.colorKeys.Length == 0)\n        {\n            _ambientColorGradient = _sunColorGradient;\n        }\n    }\n    \n    public void SetTimeOfDay(float time)\n    {\n        _currentTimeOfDay = Mathf.Clamp01(time);\n        ResetEventTriggers();\n        UpdateCycle();\n    }\n    \n    public void PauseTime(bool pause)\n    {\n        _pauseTime = pause;\n    }\n    \n    public void SetDayDuration(float minutes)\n    {\n        _dayDurationInMinutes = Mathf.Max(0.1f, minutes);\n        _timeSpeed = 1f / (_dayDurationInMinutes * 60f);\n    }\n    \n    public float GetTimeOfDay()\n    {\n        return _currentTimeOfDay;\n    }\n    \n    public bool IsDay()\n    {\n        return _currentTimeOfDay > 0.25f && _currentTimeOfDay < 0.75f;\n    }\n    \n    public bool IsNight()\n    {\n        return !IsDay();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExperienceBar\",\n  \"components\": [\n    \"UI.Slider\",\n    \"UI.Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentExperience\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"experienceToNextLevel\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentLevel\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"experienceMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"levelText\",\n      \"type\": \"UI.Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"experienceBar\",\n      \"type\": \"UI.Slider\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"gain_experience\",\n      \"trigger\": \"when experience points are awarded\",\n      \"actions\": [\n        {\n          \"action\": \"add experience points to current experience\"\n        },\n        {\n          \"action\": \"update experience bar fill amount based on progress to next level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_level_up\",\n      \"trigger\": \"when current experience reaches or exceeds experience needed for next level\",\n      \"actions\": [\n        {\n          \"action\": \"increase current level by one\"\n        },\n        {\n          \"action\": \"subtract experience needed for level up from current experience\"\n        },\n        {\n          \"action\": \"calculate new experience requirement using multiplier\"\n        },\n        {\n          \"action\": \"update level text display\"\n        },\n        {\n          \"action\": \"reset experience bar to show remaining experience\"\n        },\n        {\n          \"action\": \"trigger level up visual effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_display\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"set experience bar maximum value to experience needed for next level\"\n        },\n        {\n          \"action\": \"set experience bar current value to current experience\"\n        },\n        {\n          \"action\": \"update level text to show current level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_bar_display\",\n      \"trigger\": \"when experience values change\",\n      \"actions\": [\n        {\n          \"action\": \"calculate experience progress as percentage of requirement\"\n        },\n        {\n          \"action\": \"set slider value to match experience progress\"\n        },\n        {\n          \"action\": \"update any experience text displays\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class ExperienceBar : MonoBehaviour\n{\n    [Header(\"UI References\")]\n    [SerializeField] private Slider _experienceSlider;\n    [SerializeField] private Text _levelText;\n    [SerializeField] private Text _experienceText;\n    [SerializeField] private GameObject _levelUpEffect;\n    \n    [Header(\"Experience Settings\")]\n    [SerializeField] private int _currentLevel = 1;\n    [SerializeField] private float _currentExperience = 0f;\n    [SerializeField] private float _baseExperienceRequired = 100f;\n    [SerializeField] private float _experienceMultiplier = 1.5f;\n    [SerializeField] private int _maxLevel = 99;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _normalBarColor = Color.blue;\n    [SerializeField] private Color _levelUpBarColor = Color.gold;\n    [SerializeField] private float _levelUpEffectDuration = 2f;\n    [SerializeField] private AnimationCurve _levelUpAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _levelUpSound;\n    [SerializeField] private AudioClip _experienceGainSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnLevelUp;\n    public UnityEvent<float> OnExperienceGained;\n    \n    private float _experienceRequiredForNextLevel;\n    private bool _isLevelingUp = false;\n    private float _levelUpTimer = 0f;\n    private Image _sliderFillImage;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        CalculateExperienceRequired();\n        UpdateUI();\n    }\n    \n    private void Update()\n    {\n        if (_isLevelingUp)\n        {\n            HandleLevelUpAnimation();\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_experienceSlider == null)\n            _experienceSlider = GetComponentInChildren<Slider>();\n            \n        if (_experienceSlider != null)\n        {\n            _sliderFillImage = _experienceSlider.fillRect.GetComponent<Image>();\n            if (_sliderFillImage != null)\n                _sliderFillImage.color = _normalBarColor;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_levelUpEffect != null)\n            _levelUpEffect.SetActive(false);\n    }\n    \n    private void CalculateExperienceRequired()\n    {\n        _experienceRequiredForNextLevel = _baseExperienceRequired * Mathf.Pow(_experienceMultiplier, _currentLevel - 1);\n    }\n    \n    public void AddExperience(float amount)\n    {\n        if (_currentLevel >= _maxLevel) return;\n        \n        _currentExperience += amount;\n        \n        PlayExperienceGainSound();\n        OnExperienceGained?.Invoke(amount);\n        \n        CheckForLevelUp();\n        UpdateUI();\n    }\n    \n    private void CheckForLevelUp()\n    {\n        while (_currentExperience >= _experienceRequiredForNextLevel && _currentLevel < _maxLevel)\n        {\n            LevelUp();\n        }\n    }\n    \n    private void LevelUp()\n    {\n        _currentExperience -= _experienceRequiredForNextLevel;\n        _currentLevel++;\n        \n        CalculateExperienceRequired();\n        StartLevelUpEffect();\n        \n        PlayLevelUpSound();\n        OnLevelUp?.Invoke(_currentLevel);\n    }\n    \n    private void StartLevelUpEffect()\n    {\n        _isLevelingUp = true;\n        _levelUpTimer = 0f;\n        \n        if (_levelUpEffect != null)\n            _levelUpEffect.SetActive(true);\n            \n        if (_sliderFillImage != null)\n            _sliderFillImage.color = _levelUpBarColor;\n    }\n    \n    private void HandleLevelUpAnimation()\n    {\n        _levelUpTimer += Time.deltaTime;\n        float progress = _levelUpTimer / _levelUpEffectDuration;\n        \n        if (_sliderFillImage != null)\n        {\n            float animationValue = _levelUpAnimationCurve.Evaluate(progress);\n            _sliderFillImage.color = Color.Lerp(_levelUpBarColor, _normalBarColor, animationValue);\n        }\n        \n        if (progress >= 1f)\n        {\n            _isLevelingUp = false;\n            \n            if (_levelUpEffect != null)\n                _levelUpEffect.SetActive(false);\n                \n            if (_sliderFillImage != null)\n                _sliderFillImage.color = _normalBarColor;\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_experienceSlider != null)\n        {\n            if (_currentLevel >= _maxLevel)\n            {\n                _experienceSlider.value = 1f;\n            }\n            else\n            {\n                _experienceSlider.value = _currentExperience / _experienceRequiredForNextLevel;\n            }\n        }\n        \n        if (_levelText != null)\n        {\n            _levelText.text = \"Level \" + _currentLevel.ToString();\n        }\n        \n        if (_experienceText != null)\n        {\n            if (_currentLevel >= _maxLevel)\n            {\n                _experienceText.text = \"MAX LEVEL\";\n            }\n            else\n            {\n                _experienceText.text = $\"{_currentExperience:F0} / {_experienceRequiredForNextLevel:F0}\";\n            }\n        }\n    }\n    \n    private void PlayLevelUpSound()\n    {\n        if (_audioSource != null && _levelUpSound != null)\n        {\n            _audioSource.PlayOneShot(_levelUpSound);\n        }\n    }\n    \n    private void PlayExperienceGainSound()\n    {\n        if (_audioSource != null && _experienceGainSound != null)\n        {\n            _audioSource.PlayOneShot(_experienceGainSound, 0.5f);\n        }\n    }\n    \n    public void SetLevel(int level)\n    {\n        _currentLevel = Mathf.Clamp(level, 1, _maxLevel);\n        _currentExperience = 0f;\n        CalculateExperienceRequired();\n        UpdateUI();\n    }\n    \n    public void SetExperience(float experience)\n    {\n        _currentExperience = Mathf.Max(0f, experience);\n        CheckForLevelUp();\n        UpdateUI();\n    }\n    \n    public int GetCurrentLevel()\n    {\n        return _currentLevel;\n    }\n    \n    public float GetCurrentExperience()\n    {\n        return _currentExperience;\n    }\n    \n    public float GetExperienceRequiredForNextLevel()\n    {\n        return _experienceRequiredForNextLevel;\n    }\n    \n    public float GetExperienceProgress()\n    {\n        if (_currentLevel >= _maxLevel) return 1f;\n        return _currentExperience / _experienceRequiredForNextLevel;\n    }\n    \n    public bool IsMaxLevel()\n    {\n        return _currentLevel >= _maxLevel;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChainReactionSystem\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"objectBPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"objectCPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"objectDPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"objectEPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"victorySound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"reactionType\",\n      \"type\": \"string\",\n      \"default\": \"A\"\n    },\n    {\n      \"name\": \"spawnRadius\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"hasExploded\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"explode_object_a\",\n      \"trigger\": \"when this object is touched and reaction type is A and has not exploded\",\n      \"actions\": [\n        {\n          \"action\": \"mark as exploded\"\n        },\n        {\n          \"action\": \"play explosion effect at current position\"\n        },\n        {\n          \"action\": \"spawn 5 objects of type B in circular pattern around current position\"\n        },\n        {\n          \"action\": \"destroy this object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_object_b\",\n      \"trigger\": \"when this object is touched and reaction type is B and has not exploded\",\n      \"actions\": [\n        {\n          \"action\": \"mark as exploded\"\n        },\n        {\n          \"action\": \"play explosion effect at current position\"\n        },\n        {\n          \"action\": \"spawn 3 objects of type C in circular pattern around current position\"\n        },\n        {\n          \"action\": \"destroy this object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_object_c\",\n      \"trigger\": \"when this object is touched and reaction type is C and has not exploded\",\n      \"actions\": [\n        {\n          \"action\": \"mark as exploded\"\n        },\n        {\n          \"action\": \"play explosion effect at current position\"\n        },\n        {\n          \"action\": \"spawn 2 objects of type D in circular pattern around current position\"\n        },\n        {\n          \"action\": \"destroy this object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_object_d\",\n      \"trigger\": \"when this object is touched and reaction type is D and has not exploded\",\n      \"actions\": [\n        {\n          \"action\": \"mark as exploded\"\n        },\n        {\n          \"action\": \"play explosion effect at current position\"\n        },\n        {\n          \"action\": \"spawn 1 object of type E at current position\"\n        },\n        {\n          \"action\": \"destroy this object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"victory_object_e\",\n      \"trigger\": \"when this object is touched and reaction type is E and has not exploded\",\n      \"actions\": [\n        {\n          \"action\": \"mark as exploded\"\n        },\n        {\n          \"action\": \"play victory sound\"\n        },\n        {\n          \"action\": \"play explosion effect at current position\"\n        },\n        {\n          \"action\": \"destroy this object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ChainReactionSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class ReactionLevel\n    {\n        [Header(\"Spawn Settings\")]\n        public GameObject prefab;\n        public int spawnCount;\n        public float spawnRadius = 2f;\n        public float spawnForce = 5f;\n        \n        [Header(\"Visual Effects\")]\n        public GameObject explosionEffect;\n        public AudioClip explosionSound;\n        \n        [Header(\"Timing\")]\n        public float destructionDelay = 0.1f;\n    }\n    \n    [Header(\"Chain Reaction Configuration\")]\n    [SerializeField] private ReactionLevel[] _reactionLevels = new ReactionLevel[5];\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _victorySound;\n    \n    [Header(\"Detection\")]\n    [SerializeField] private LayerMask _triggerLayers = -1;\n    [SerializeField] private string _triggerTag = \"Player\";\n    \n    [Header(\"Current Level\")]\n    [SerializeField] private int _currentLevel = 0;\n    \n    private bool _hasTriggered = false;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    \n    public UnityEvent OnChainReactionTriggered;\n    public UnityEvent OnVictoryReached;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        SetupCollider();\n        InitializeReactionLevels();\n    }\n    \n    private void SetupCollider()\n    {\n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        if (!_collider.isTrigger)\n            _collider.isTrigger = true;\n    }\n    \n    private void InitializeReactionLevels()\n    {\n        if (_reactionLevels == null || _reactionLevels.Length == 0)\n        {\n            _reactionLevels = new ReactionLevel[5];\n            for (int i = 0; i < _reactionLevels.Length; i++)\n            {\n                _reactionLevels[i] = new ReactionLevel();\n            }\n        }\n        \n        // Set default spawn counts if not configured\n        if (_reactionLevels.Length >= 1 && _reactionLevels[0].spawnCount == 0)\n            _reactionLevels[0].spawnCount = 5; // A spawns 5 B\n            \n        if (_reactionLevels.Length >= 2 && _reactionLevels[1].spawnCount == 0)\n            _reactionLevels[1].spawnCount = 3; // B spawns 3 C\n            \n        if (_reactionLevels.Length >= 3 && _reactionLevels[2].spawnCount == 0)\n            _reactionLevels[2].spawnCount = 2; // C spawns 2 D\n            \n        if (_reactionLevels.Length >= 4 && _reactionLevels[3].spawnCount == 0)\n            _reactionLevels[3].spawnCount = 1; // D spawns 1 E\n            \n        if (_reactionLevels.Length >= 5 && _reactionLevels[4].spawnCount == 0)\n            _reactionLevels[4].spawnCount = 0; // E is final level\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_hasTriggered)\n            return;\n            \n        if (!IsValidTrigger(other))\n            return;\n            \n        TriggerChainReaction();\n    }\n    \n    private bool IsValidTrigger(Collider other)\n    {\n        // Check layer mask\n        int otherLayer = 1 << other.gameObject.layer;\n        if ((_triggerLayers.value & otherLayer) == 0)\n            return false;\n            \n        // Check tag if specified\n        if (!string.IsNullOrEmpty(_triggerTag) && !other.CompareTag(_triggerTag))\n            return false;\n            \n        return true;\n    }\n    \n    private void TriggerChainReaction()\n    {\n        if (_hasTriggered)\n            return;\n            \n        _hasTriggered = true;\n        \n        OnChainReactionTriggered?.Invoke();\n        \n        // Check if this is the final level (E)\n        if (_currentLevel >= _reactionLevels.Length - 1 || _reactionLevels[_currentLevel].spawnCount == 0)\n        {\n            PlayVictorySound();\n            OnVictoryReached?.Invoke();\n        }\n        else\n        {\n            StartCoroutine(ExecuteReaction());\n        }\n    }\n    \n    private IEnumerator ExecuteReaction()\n    {\n        ReactionLevel currentReaction = _reactionLevels[_currentLevel];\n        \n        // Play explosion sound\n        if (currentReaction.explosionSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(currentReaction.explosionSound);\n        }\n        \n        // Spawn explosion effect\n        if (currentReaction.explosionEffect != null)\n        {\n            Instantiate(currentReaction.explosionEffect, transform.position, transform.rotation);\n        }\n        \n        // Spawn next level objects\n        if (currentReaction.prefab != null && currentReaction.spawnCount > 0)\n        {\n            SpawnNextLevelObjects(currentReaction);\n        }\n        \n        // Wait before destroying this object\n        yield return new WaitForSeconds(currentReaction.destructionDelay);\n        \n        Destroy(gameObject);\n    }\n    \n    private void SpawnNextLevelObjects(ReactionLevel reaction)\n    {\n        float angleStep = 360f / reaction.spawnCount;\n        \n        for (int i = 0; i < reaction.spawnCount; i++)\n        {\n            float angle = i * angleStep * Mathf.Deg2Rad;\n            Vector3 spawnDirection = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\n            Vector3 spawnPosition = transform.position + spawnDirection * reaction.spawnRadius;\n            \n            GameObject spawnedObject = Instantiate(reaction.prefab, spawnPosition, Quaternion.identity);\n            \n            // Set up the spawned object's chain reaction component\n            ChainReactionSystem chainReaction = spawnedObject.GetComponent<ChainReactionSystem>();\n            if (chainReaction == null)\n            {\n                chainReaction = spawnedObject.AddComponent<ChainReactionSystem>();\n            }\n            \n            // Configure the next level\n            chainReaction.SetupAsNextLevel(_currentLevel + 1, _reactionLevels, _victorySound);\n            \n            // Apply spawn force\n            Rigidbody spawnedRb = spawnedObject.GetComponent<Rigidbody>();\n            if (spawnedRb != null && reaction.spawnForce > 0)\n            {\n                Vector3 forceDirection = spawnDirection + Vector3.up * 0.3f;\n                spawnedRb.AddForce(forceDirection.normalized * reaction.spawnForce, ForceMode.Impulse);\n            }\n        }\n    }\n    \n    public void SetupAsNextLevel(int level, ReactionLevel[] reactionLevels, AudioClip victorySound)\n    {\n        _currentLevel = level;\n        _reactionLevels = reactionLevels;\n        _victorySound = victorySound;\n        _hasTriggered = false;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n    }\n    \n    private void PlayVictorySound()\n    {\n        if (_victorySound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_victorySound);\n        }\n    }\n    \n    public void ResetChainReaction()\n    {\n        _hasTriggered = false;\n    }\n    \n    public void SetCurrentLevel(int level)\n    {\n        _currentLevel = Mathf.Clamp(level, 0, _reactionLevels.Length - 1);\n    }\n    \n    public int GetCurrentLevel()\n    {\n        return _currentLevel;\n    }\n    \n    public bool HasTriggered()\n    {\n        return _hasTriggered;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_currentLevel < _reactionLevels.Length)\n        {\n            ReactionLevel currentReaction = _reactionLevels[_currentLevel];\n            \n            // Draw spawn radius\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireCircle(transform.position, currentReaction.spawnRadius);\n            \n            // Draw spawn positions\n            if (currentReaction.spawnCount > 0)\n            {\n                Gizmos.color = Color.green;\n                float angleStep = 360f / currentReaction.spawnCount;\n                \n                for (int i = 0; i < currentReaction.spawnCount; i++)\n                {\n                    float angle = i * angleStep * Mathf.Deg2Rad;\n                    Vector3 spawnDirection = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\n                    Vector3 spawnPosition = transform.position + spawnDirection * currentReaction.spawnRadius;\n                    \n                    Gizmos.DrawWireSphere(spawnPosition, 0.2f);\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LoadingScreen\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\",\n    \"Slider\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"progressBar\",\n      \"type\": \"Slider\",\n      \"default\": null\n    },\n    {\n      \"name\": \"progressText\",\n      \"type\": \"Text\",\n      \"default\": null\n    },\n    {\n      \"name\": \"backgroundImage\",\n      \"type\": \"Image\",\n      \"default\": null\n    },\n    {\n      \"name\": \"loadingSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"currentProgress\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"targetProgress\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_loading_screen\",\n      \"trigger\": \"when loading screen starts\",\n      \"actions\": [\n        {\n          \"action\": \"set progress bar value to zero\"\n        },\n        {\n          \"action\": \"set progress text to show zero percent\"\n        },\n        {\n          \"action\": \"make loading screen visible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_progress\",\n      \"trigger\": \"when target progress value changes\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly animate progress bar toward target value\"\n        },\n        {\n          \"action\": \"update progress text to show current percentage\"\n        },\n        {\n          \"action\": \"display loading status message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_loading\",\n      \"trigger\": \"when progress reaches one hundred percent\",\n      \"actions\": [\n        {\n          \"action\": \"show completion message\"\n        },\n        {\n          \"action\": \"wait for brief moment\"\n        },\n        {\n          \"action\": \"fade out loading screen\"\n        },\n        {\n          \"action\": \"hide loading screen completely\"\n        }\n      ]\n    },\n    {\n      \"name\": \"animate_progress_bar\",\n      \"trigger\": \"every frame while loading is active\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase current progress toward target progress\"\n        },\n        {\n          \"action\": \"update progress bar fill amount\"\n        },\n        {\n          \"action\": \"ensure smooth visual transition\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class LoadingScreen : MonoBehaviour\n{\n    [Header(\"UI Elements\")]\n    [SerializeField] private Slider _progressBar;\n    [SerializeField] private Text _progressText;\n    [SerializeField] private Text _loadingStatusText;\n    [SerializeField] private Image _backgroundImage;\n    [SerializeField] private GameObject _loadingPanel;\n    \n    [Header(\"Loading Settings\")]\n    [SerializeField] private string _sceneToLoad = \"MainScene\";\n    [SerializeField] private float _minimumLoadTime = 2f;\n    [SerializeField] private float _progressUpdateSpeed = 2f;\n    [SerializeField] private bool _allowSceneActivation = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private AnimationCurve _progressCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    [SerializeField] private Color _progressBarColor = Color.green;\n    [SerializeField] private Color _backgroundColor = Color.black;\n    \n    [Header(\"Loading Messages\")]\n    [SerializeField] private string[] _loadingMessages = {\n        \"Loading assets...\",\n        \"Preparing scene...\",\n        \"Initializing systems...\",\n        \"Almost ready...\"\n    };\n    \n    private AsyncOperation _loadOperation;\n    private float _targetProgress;\n    private float _currentProgress;\n    private float _loadStartTime;\n    private bool _isLoading;\n    private int _currentMessageIndex;\n    private Coroutine _messageUpdateCoroutine;\n    \n    private void Start()\n    {\n        InitializeLoadingScreen();\n        StartLoading();\n    }\n    \n    private void Update()\n    {\n        if (_isLoading)\n        {\n            UpdateProgress();\n            UpdateLoadingStatus();\n        }\n    }\n    \n    private void InitializeLoadingScreen()\n    {\n        if (_loadingPanel != null)\n            _loadingPanel.SetActive(true);\n            \n        if (_backgroundImage != null)\n            _backgroundImage.color = _backgroundColor;\n            \n        if (_progressBar != null)\n        {\n            _progressBar.value = 0f;\n            if (_progressBar.fillRect != null)\n                _progressBar.fillRect.GetComponent<Image>().color = _progressBarColor;\n        }\n        \n        if (_progressText != null)\n            _progressText.text = \"0%\";\n            \n        if (_loadingStatusText != null && _loadingMessages.Length > 0)\n            _loadingStatusText.text = _loadingMessages[0];\n            \n        _currentProgress = 0f;\n        _targetProgress = 0f;\n        _loadStartTime = Time.time;\n        _currentMessageIndex = 0;\n    }\n    \n    public void StartLoading()\n    {\n        if (_isLoading) return;\n        \n        _isLoading = true;\n        _loadStartTime = Time.time;\n        \n        StartCoroutine(LoadSceneAsync());\n        \n        if (_loadingMessages.Length > 1)\n            _messageUpdateCoroutine = StartCoroutine(UpdateLoadingMessages());\n    }\n    \n    public void LoadScene(string sceneName)\n    {\n        _sceneToLoad = sceneName;\n        StartLoading();\n    }\n    \n    private IEnumerator LoadSceneAsync()\n    {\n        yield return new WaitForEndOfFrame();\n        \n        _loadOperation = SceneManager.LoadSceneAsync(_sceneToLoad);\n        _loadOperation.allowSceneActivation = false;\n        \n        while (!_loadOperation.isDone)\n        {\n            float progress = Mathf.Clamp01(_loadOperation.progress / 0.9f);\n            _targetProgress = progress;\n            \n            if (_loadOperation.progress >= 0.9f)\n            {\n                _targetProgress = 1f;\n                \n                float elapsedTime = Time.time - _loadStartTime;\n                if (elapsedTime >= _minimumLoadTime && _allowSceneActivation)\n                {\n                    yield return new WaitForSeconds(0.5f);\n                    _loadOperation.allowSceneActivation = true;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void UpdateProgress()\n    {\n        if (_currentProgress < _targetProgress)\n        {\n            _currentProgress = Mathf.MoveTowards(_currentProgress, _targetProgress, \n                Time.deltaTime * _progressUpdateSpeed);\n        }\n        \n        float curvedProgress = _progressCurve.Evaluate(_currentProgress);\n        \n        if (_progressBar != null)\n            _progressBar.value = curvedProgress;\n            \n        if (_progressText != null)\n        {\n            int percentage = Mathf.RoundToInt(curvedProgress * 100f);\n            _progressText.text = percentage + \"%\";\n        }\n    }\n    \n    private void UpdateLoadingStatus()\n    {\n        if (_loadingStatusText == null || _loadingMessages.Length == 0) return;\n        \n        int expectedMessageIndex = Mathf.FloorToInt(_currentProgress * (_loadingMessages.Length - 1));\n        expectedMessageIndex = Mathf.Clamp(expectedMessageIndex, 0, _loadingMessages.Length - 1);\n        \n        if (expectedMessageIndex != _currentMessageIndex)\n        {\n            _currentMessageIndex = expectedMessageIndex;\n            _loadingStatusText.text = _loadingMessages[_currentMessageIndex];\n        }\n    }\n    \n    private IEnumerator UpdateLoadingMessages()\n    {\n        while (_isLoading && _currentProgress < 1f)\n        {\n            yield return new WaitForSeconds(Random.Range(1f, 3f));\n            \n            if (_loadingStatusText != null && _loadingMessages.Length > 0)\n            {\n                int nextIndex = (_currentMessageIndex + 1) % _loadingMessages.Length;\n                if (_currentProgress >= (float)nextIndex / _loadingMessages.Length)\n                {\n                    _currentMessageIndex = nextIndex;\n                    _loadingStatusText.text = _loadingMessages[_currentMessageIndex];\n                }\n            }\n        }\n    }\n    \n    public void SetMinimumLoadTime(float time)\n    {\n        _minimumLoadTime = Mathf.Max(0f, time);\n    }\n    \n    public void SetProgressUpdateSpeed(float speed)\n    {\n        _progressUpdateSpeed = Mathf.Max(0.1f, speed);\n    }\n    \n    public void SetAllowSceneActivation(bool allow)\n    {\n        _allowSceneActivation = allow;\n        if (_loadOperation != null && allow && _loadOperation.progress >= 0.9f)\n        {\n            _loadOperation.allowSceneActivation = true;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_messageUpdateCoroutine != null)\n        {\n            StopCoroutine(_messageUpdateCoroutine);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _minimumLoadTime = Mathf.Max(0f, _minimumLoadTime);\n        _progressUpdateSpeed = Mathf.Max(0.1f, _progressUpdateSpeed);\n        \n        if (_loadingMessages == null || _loadingMessages.Length == 0)\n        {\n            _loadingMessages = new string[] { \"Loading...\" };\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SettingsPreferences\",\n  \"components\": [],\n  \"fields\": [\n    {\n      \"name\": \"masterVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"musicVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"sfxVolume\",\n      \"type\": \"float\",\n      \"default\": 0.9\n    },\n    {\n      \"name\": \"graphicsQuality\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"fullscreen\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"resolution\",\n      \"type\": \"string\",\n      \"default\": \"1920x1080\"\n    },\n    {\n      \"name\": \"difficulty\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"autoSave\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"subtitles\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"save_settings\",\n      \"trigger\": \"when save settings is requested\",\n      \"actions\": [\n        {\n          \"action\": \"store all current setting values to persistent storage\"\n        },\n        {\n          \"action\": \"confirm settings have been saved successfully\"\n        }\n      ]\n    },\n    {\n      \"name\": \"load_settings\",\n      \"trigger\": \"when game starts or settings need to be loaded\",\n      \"actions\": [\n        {\n          \"action\": \"retrieve saved setting values from persistent storage\"\n        },\n        {\n          \"action\": \"apply loaded values to current settings\"\n        },\n        {\n          \"action\": \"use default values for any missing settings\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_to_defaults\",\n      \"trigger\": \"when reset to default settings is requested\",\n      \"actions\": [\n        {\n          \"action\": \"restore all settings to their default values\"\n        },\n        {\n          \"action\": \"save the reset settings to persistent storage\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_settings\",\n      \"trigger\": \"when settings values are changed\",\n      \"actions\": [\n        {\n          \"action\": \"update game systems with new setting values\"\n        },\n        {\n          \"action\": \"validate setting values are within acceptable ranges\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Audio;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class SettingsManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class SettingsData\n    {\n        public float masterVolume = 1f;\n        public float musicVolume = 1f;\n        public float sfxVolume = 1f;\n        public int qualityLevel = 3;\n        public bool fullscreen = true;\n        public int resolutionIndex = 0;\n        public float mouseSensitivity = 1f;\n        public bool invertMouseY = false;\n        public int vsyncCount = 1;\n        public float brightness = 1f;\n        public bool showFPS = false;\n        public string language = \"English\";\n        public KeyCode jumpKey = KeyCode.Space;\n        public KeyCode interactKey = KeyCode.E;\n        public KeyCode runKey = KeyCode.LeftShift;\n    }\n\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private string _masterVolumeParameter = \"MasterVolume\";\n    [SerializeField] private string _musicVolumeParameter = \"MusicVolume\";\n    [SerializeField] private string _sfxVolumeParameter = \"SFXVolume\";\n\n    [Header(\"Graphics Settings\")]\n    [SerializeField] private Camera _mainCamera;\n    [SerializeField] private Light _mainLight;\n\n    [Header(\"Events\")]\n    public UnityEvent<SettingsData> OnSettingsLoaded;\n    public UnityEvent<SettingsData> OnSettingsSaved;\n    public UnityEvent<float> OnVolumeChanged;\n    public UnityEvent<int> OnQualityChanged;\n    public UnityEvent<bool> OnFullscreenChanged;\n\n    private SettingsData _currentSettings;\n    private Resolution[] _availableResolutions;\n    private const string SETTINGS_KEY = \"GameSettings\";\n\n    public SettingsData CurrentSettings => _currentSettings;\n\n    private void Awake()\n    {\n        _currentSettings = new SettingsData();\n        _availableResolutions = Screen.resolutions;\n    }\n\n    private void Start()\n    {\n        LoadSettings();\n        ApplyAllSettings();\n    }\n\n    public void SaveSettings()\n    {\n        string jsonData = JsonUtility.ToJson(_currentSettings, true);\n        PlayerPrefs.SetString(SETTINGS_KEY, jsonData);\n        PlayerPrefs.Save();\n        \n        OnSettingsSaved?.Invoke(_currentSettings);\n        Debug.Log(\"Settings saved successfully\");\n    }\n\n    public void LoadSettings()\n    {\n        if (PlayerPrefs.HasKey(SETTINGS_KEY))\n        {\n            string jsonData = PlayerPrefs.GetString(SETTINGS_KEY);\n            try\n            {\n                _currentSettings = JsonUtility.FromJson<SettingsData>(jsonData);\n                OnSettingsLoaded?.Invoke(_currentSettings);\n                Debug.Log(\"Settings loaded successfully\");\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning($\"Failed to load settings: {e.Message}. Using defaults.\");\n                ResetToDefaults();\n            }\n        }\n        else\n        {\n            Debug.Log(\"No saved settings found. Using defaults.\");\n            ResetToDefaults();\n        }\n    }\n\n    public void ResetToDefaults()\n    {\n        _currentSettings = new SettingsData();\n        ApplyAllSettings();\n        SaveSettings();\n    }\n\n    private void ApplyAllSettings()\n    {\n        SetMasterVolume(_currentSettings.masterVolume);\n        SetMusicVolume(_currentSettings.musicVolume);\n        SetSFXVolume(_currentSettings.sfxVolume);\n        SetQualityLevel(_currentSettings.qualityLevel);\n        SetFullscreen(_currentSettings.fullscreen);\n        SetResolution(_currentSettings.resolutionIndex);\n        SetVSyncCount(_currentSettings.vsyncCount);\n        SetBrightness(_currentSettings.brightness);\n    }\n\n    public void SetMasterVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.masterVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_masterVolumeParameter, dbValue);\n        }\n        \n        OnVolumeChanged?.Invoke(volume);\n    }\n\n    public void SetMusicVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.musicVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_musicVolumeParameter, dbValue);\n        }\n    }\n\n    public void SetSFXVolume(float volume)\n    {\n        volume = Mathf.Clamp01(volume);\n        _currentSettings.sfxVolume = volume;\n        \n        if (_audioMixer != null)\n        {\n            float dbValue = volume > 0 ? Mathf.Log10(volume) * 20 : -80f;\n            _audioMixer.SetFloat(_sfxVolumeParameter, dbValue);\n        }\n    }\n\n    public void SetQualityLevel(int qualityIndex)\n    {\n        qualityIndex = Mathf.Clamp(qualityIndex, 0, QualitySettings.names.Length - 1);\n        _currentSettings.qualityLevel = qualityIndex;\n        QualitySettings.SetQualityLevel(qualityIndex);\n        OnQualityChanged?.Invoke(qualityIndex);\n    }\n\n    public void SetFullscreen(bool isFullscreen)\n    {\n        _currentSettings.fullscreen = isFullscreen;\n        Screen.fullScreen = isFullscreen;\n        OnFullscreenChanged?.Invoke(isFullscreen);\n    }\n\n    public void SetResolution(int resolutionIndex)\n    {\n        if (_availableResolutions != null && resolutionIndex >= 0 && resolutionIndex < _availableResolutions.Length)\n        {\n            _currentSettings.resolutionIndex = resolutionIndex;\n            Resolution resolution = _availableResolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, _currentSettings.fullscreen);\n        }\n    }\n\n    public void SetMouseSensitivity(float sensitivity)\n    {\n        _currentSettings.mouseSensitivity = Mathf.Clamp(sensitivity, 0.1f, 5f);\n    }\n\n    public void SetInvertMouseY(bool invert)\n    {\n        _currentSettings.invertMouseY = invert;\n    }\n\n    public void SetVSyncCount(int vSyncCount)\n    {\n        vSyncCount = Mathf.Clamp(vSyncCount, 0, 4);\n        _currentSettings.vsyncCount = vSyncCount;\n        QualitySettings.vSyncCount = vSyncCount;\n    }\n\n    public void SetBrightness(float brightness)\n    {\n        brightness = Mathf.Clamp(brightness, 0.1f, 2f);\n        _currentSettings.brightness = brightness;\n        \n        if (_mainLight != null)\n        {\n            _mainLight.intensity = brightness;\n        }\n        \n        if (_mainCamera != null)\n        {\n            _mainCamera.backgroundColor = Color.black * brightness;\n        }\n    }\n\n    public void SetShowFPS(bool showFPS)\n    {\n        _currentSettings.showFPS = showFPS;\n    }\n\n    public void SetLanguage(string language)\n    {\n        _currentSettings.language = language;\n    }\n\n    public void SetJumpKey(KeyCode keyCode)\n    {\n        _currentSettings.jumpKey = keyCode;\n    }\n\n    public void SetInteractKey(KeyCode keyCode)\n    {\n        _currentSettings.interactKey = keyCode;\n    }\n\n    public void SetRunKey(KeyCode keyCode)\n    {\n        _currentSettings.runKey = keyCode;\n    }\n\n    public Resolution[] GetAvailableResolutions()\n    {\n        return _availableResolutions;\n    }\n\n    public string[] GetQualityLevels()\n    {\n        return QualitySettings.names;\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus)\n        {\n            SaveSettings();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus)\n        {\n            SaveSettings();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        SaveSettings();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PackWolf\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"packRadius\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"attackRange\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"int\",\n      \"default\": 40\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"howlCooldown\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"isAlpha\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"alert nearby pack members\"\n        },\n        {\n          \"action\": \"play growl sound\"\n        },\n        {\n          \"action\": \"enter aggressive state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"coordinate_pack_attack\",\n      \"trigger\": \"when alpha wolf detects threat\",\n      \"actions\": [\n        {\n          \"action\": \"howl to summon pack\"\n        },\n        {\n          \"action\": \"broadcast attack target to nearby wolves\"\n        },\n        {\n          \"action\": \"coordinate flanking positions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respond_to_pack_call\",\n      \"trigger\": \"when hearing alpha howl\",\n      \"actions\": [\n        {\n          \"action\": \"move toward alpha wolf\"\n        },\n        {\n          \"action\": \"adopt aggressive stance\"\n        },\n        {\n          \"action\": \"focus on shared target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"circle_target\",\n      \"trigger\": \"when in pack attack mode\",\n      \"actions\": [\n        {\n          \"action\": \"move in circular pattern around target\"\n        },\n        {\n          \"action\": \"maintain distance from other pack members\"\n        },\n        {\n          \"action\": \"look for opening to attack\"\n        }\n      ]\n    },\n    {\n      \"name\": \"coordinated_strike\",\n      \"trigger\": \"when target is distracted by other wolves\",\n      \"actions\": [\n        {\n          \"action\": \"lunge at target from behind or side\"\n        },\n        {\n          \"action\": \"deal bite damage\"\n        },\n        {\n          \"action\": \"retreat to safe distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pack_retreat\",\n      \"trigger\": \"when pack leader is defeated or heavily damaged\",\n      \"actions\": [\n        {\n          \"action\": \"whimper and back away\"\n        },\n        {\n          \"action\": \"flee in different directions\"\n        },\n        {\n          \"action\": \"regroup at distant location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\nusing System.Collections;\n\npublic class PackWolf : MonoBehaviour\n{\n    [Header(\"Wolf Stats\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _moveSpeed = 5f;\n    [SerializeField] private float _attackDamage = 20f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    \n    [Header(\"Pack Behavior\")]\n    [SerializeField] private float _packDetectionRadius = 15f;\n    [SerializeField] private float _packFormationDistance = 3f;\n    [SerializeField] private float _packAttackBonus = 1.2f;\n    [SerializeField] private int _maxPackSize = 5;\n    \n    [Header(\"AI Behavior\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private float _loseTargetDistance = 20f;\n    [SerializeField] private float _circleDistance = 4f;\n    [SerializeField] private float _circleSpeed = 2f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _howlSound;\n    [SerializeField] private AudioClip _attackSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    public UnityEvent OnPackFormed;\n    \n    private float _currentHealth;\n    private Transform _target;\n    private List<PackWolf> _packMembers = new List<PackWolf>();\n    private bool _isPackLeader = false;\n    private float _lastAttackTime;\n    private Vector3 _circlePosition;\n    private float _circleAngle;\n    private bool _isDead = false;\n    \n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private Animator _animator;\n    private Collider _collider;\n    \n    private enum WolfState\n    {\n        Idle,\n        Hunting,\n        Circling,\n        Attacking,\n        Dead\n    }\n    \n    private WolfState _currentState = WolfState.Idle;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        _animator = GetComponent<Animator>();\n        _collider = GetComponent<Collider>();\n        \n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _circleAngle = Random.Range(0f, 360f);\n        \n        StartCoroutine(PackDetectionCoroutine());\n        StartCoroutine(TargetDetectionCoroutine());\n    }\n    \n    void Update()\n    {\n        if (_isDead) return;\n        \n        UpdateStateMachine();\n        UpdateAnimations();\n    }\n    \n    void FixedUpdate()\n    {\n        if (_isDead) return;\n        \n        switch (_currentState)\n        {\n            case WolfState.Hunting:\n                MoveTowardsTarget();\n                break;\n            case WolfState.Circling:\n                CircleTarget();\n                break;\n            case WolfState.Attacking:\n                AttackTarget();\n                break;\n        }\n    }\n    \n    private void UpdateStateMachine()\n    {\n        if (_target == null)\n        {\n            _currentState = WolfState.Idle;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget > _loseTargetDistance)\n        {\n            _target = null;\n            _currentState = WolfState.Idle;\n            return;\n        }\n        \n        switch (_currentState)\n        {\n            case WolfState.Idle:\n                if (_target != null)\n                    _currentState = WolfState.Hunting;\n                break;\n                \n            case WolfState.Hunting:\n                if (distanceToTarget <= _circleDistance)\n                    _currentState = WolfState.Circling;\n                break;\n                \n            case WolfState.Circling:\n                if (distanceToTarget <= _attackRange && Time.time >= _lastAttackTime + _attackCooldown)\n                    _currentState = WolfState.Attacking;\n                else if (distanceToTarget > _circleDistance + 2f)\n                    _currentState = WolfState.Hunting;\n                break;\n                \n            case WolfState.Attacking:\n                if (Time.time >= _lastAttackTime + _attackCooldown)\n                    _currentState = WolfState.Circling;\n                break;\n        }\n    }\n    \n    private void MoveTowardsTarget()\n    {\n        if (_target == null) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        transform.LookAt(new Vector3(_target.position.x, transform.position.y, _target.position.z));\n    }\n    \n    private void CircleTarget()\n    {\n        if (_target == null) return;\n        \n        _circleAngle += _circleSpeed * Time.fixedDeltaTime;\n        \n        Vector3 offset = new Vector3(\n            Mathf.Cos(_circleAngle) * _circleDistance,\n            0f,\n            Mathf.Sin(_circleAngle) * _circleDistance\n        );\n        \n        Vector3 targetPosition = _target.position + offset;\n        Vector3 direction = (targetPosition - transform.position).normalized;\n        \n        _rigidbody.MovePosition(transform.position + direction * _moveSpeed * Time.fixedDeltaTime);\n        \n        transform.LookAt(new Vector3(_target.position.x, transform.position.y, _target.position.z));\n    }\n    \n    private void AttackTarget()\n    {\n        if (_target == null || Time.time < _lastAttackTime + _attackCooldown) return;\n        \n        float distance = Vector3.Distance(transform.position, _target.position);\n        if (distance <= _attackRange)\n        {\n            PerformAttack();\n            _lastAttackTime = Time.time;\n        }\n    }\n    \n    private void PerformAttack()\n    {\n        float damage = _attackDamage;\n        \n        if (_packMembers.Count > 1)\n            damage *= _packAttackBonus;\n        \n        if (_audioSource && _attackSound)\n            _audioSource.PlayOneShot(_attackSound);\n        \n        if (_target.CompareTag(\"Player\"))\n        {\n            var playerHealth = _target.GetComponent<PlayerHealthComponent>();\n            if (playerHealth != null)\n                playerHealth.TakeDamage(damage);\n        }\n        \n        NotifyPackOfAttack();\n    }\n    \n    private void NotifyPackOfAttack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this && wolf._target == null)\n            {\n                wolf.SetTarget(_target);\n            }\n        }\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        OnHealthChanged?.Invoke(_currentHealth / _maxHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n        else\n        {\n            AlertPack();\n        }\n    }\n    \n    private void AlertPack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this && wolf._target == null)\n            {\n                wolf.SetTarget(_target);\n            }\n        }\n        \n        if (_audioSource && _howlSound)\n            _audioSource.PlayOneShot(_howlSound);\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = WolfState.Dead;\n        \n        if (_audioSource && _deathSound)\n            _audioSource.PlayOneShot(_deathSound);\n        \n        if (_collider)\n            _collider.enabled = false;\n        \n        if (_rigidbody)\n            _rigidbody.isKinematic = true;\n        \n        RemoveFromPack();\n        OnDeath?.Invoke();\n        \n        StartCoroutine(DestroyAfterDelay(5f));\n    }\n    \n    private void RemoveFromPack()\n    {\n        foreach (var wolf in _packMembers)\n        {\n            if (wolf != this)\n                wolf._packMembers.Remove(this);\n        }\n        _packMembers.Clear();\n    }\n    \n    public void SetTarget(Transform target)\n    {\n        _target = target;\n        if (_currentState == WolfState.Idle)\n            _currentState = WolfState.Hunting;\n    }\n    \n    private IEnumerator PackDetectionCoroutine()\n    {\n        while (!_isDead)\n        {\n            DetectNearbyWolves();\n            yield return new WaitForSeconds(2f);\n        }\n    }\n    \n    private void DetectNearbyWolves()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _packDetectionRadius);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            var wolf = collider.GetComponent<PackWolf>();\n            if (wolf != null && wolf != this && !wolf._isDead)\n            {\n                if (!_packMembers.Contains(wolf) && _packMembers.Count < _maxPackSize)\n                {\n                    JoinPack(wolf);\n                }\n            }\n        }\n        \n        _packMembers.RemoveAll(wolf => wolf == null || wolf._isDead || \n                              Vector3.Distance(transform.position, wolf.transform.position) > _packDetectionRadius * 1.5f);\n    }\n    \n    private void JoinPack(PackWolf otherWolf)\n    {\n        if (!_packMembers.Contains(otherWolf))\n            _packMembers.Add(otherWolf);\n            \n        if (!otherWolf._packMembers.Contains(this))\n            otherWolf._packMembers.Add(this);\n        \n        if (_packMembers.Count >= 2 && !_isPackLeader)\n        {\n            _isPackLeader = _packMembers.Count > otherWolf._packMembers.Count;\n            OnPackFormed?.Invoke();\n        }\n    }\n    \n    private IEnumerator TargetDetectionCoroutine()\n    {\n        while (!_isDead)\n        {\n            if (_target == null)\n                DetectTarget();\n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n    \n    private void DetectTarget()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _detectionRadius);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            if (collider.CompareTag(\"Player\"))\n            {\n                SetTarget(collider.transform);\n                break;\n            }\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        float speed = _rigidbody.velocity.magnitude;\n        _animator.SetFloat(\"Speed\", speed);\n        _animator.SetBool(\"IsAttacking\", _currentState == WolfState.Attacking);\n        _animator.SetBool(\"IsDead\", _isDead);\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _packDetectionRadius);\n        \n        if (_packMembers != null)\n        {\n            Gizmos.color = Color.green;\n            foreach (var wolf in _packMembers)\n            {\n                if (wolf != null && wolf != this)\n                    Gizmos.DrawLine(transform.position, wolf.transform.position);\n            }\n        }\n    }\n}\n\n[System.Serializable]\npublic class PlayerHealthComponent : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    private float _currentHealth;\n    \n    void Start()\n    {\n        _currentHealth = _maxHealth;\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        if (_currentHealth <= 0f)\n        {\n            Debug.Log(\"Player died!\");\n        }\n    }\n    \n    public float GetHealthPercentage()\n    {\n        return _currentHealth / _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FireBreathingDragon\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fireBreathRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"fireBreathCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"fireBreathDuration\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"flyingSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"fireBreathDamage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isBreathingFire\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lastFireBreathTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_targets\",\n      \"trigger\": \"continuously scan for enemies within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"identify nearest enemy target within range\"\n        },\n        {\n          \"action\": \"face toward detected target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"breathe_fire\",\n      \"trigger\": \"when target is within fire breath range and cooldown period has passed\",\n      \"actions\": [\n        {\n          \"action\": \"play fire breathing animation\"\n        },\n        {\n          \"action\": \"emit fire particle effects from mouth\"\n        },\n        {\n          \"action\": \"play fire breathing sound effect\"\n        },\n        {\n          \"action\": \"create fire damage area in front of dragon\"\n        },\n        {\n          \"action\": \"apply fire damage to all objects in breath area\"\n        },\n        {\n          \"action\": \"start cooldown timer for next fire breath\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fly_around\",\n      \"trigger\": \"when no targets are in fire breath range\",\n      \"actions\": [\n        {\n          \"action\": \"fly in circular patterns around the area\"\n        },\n        {\n          \"action\": \"maintain altitude above ground\"\n        },\n        {\n          \"action\": \"occasionally roar to intimidate nearby creatures\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_target\",\n      \"trigger\": \"when target is detected but outside fire breath range\",\n      \"actions\": [\n        {\n          \"action\": \"fly toward target at flying speed\"\n        },\n        {\n          \"action\": \"maintain optimal distance for fire breathing\"\n        },\n        {\n          \"action\": \"play wing flapping sound effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class Dragon : MonoBehaviour\n{\n    [Header(\"Dragon Settings\")]\n    [SerializeField] private float _detectionRange = 15f;\n    [SerializeField] private float _attackRange = 8f;\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 2f;\n    \n    [Header(\"Fire Breath\")]\n    [SerializeField] private Transform _fireBreathPoint;\n    [SerializeField] private GameObject _fireBreathPrefab;\n    [SerializeField] private ParticleSystem _fireParticles;\n    [SerializeField] private float _fireBreathDuration = 3f;\n    [SerializeField] private float _fireBreathCooldown = 5f;\n    [SerializeField] private float _fireDamage = 25f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _roarSound;\n    [SerializeField] private AudioClip _fireBreathSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    private Transform _target;\n    private bool _isBreathingFire = false;\n    private float _lastFireBreathTime = 0f;\n    private Rigidbody _rigidbody;\n    private DragonState _currentState = DragonState.Idle;\n    \n    private enum DragonState\n    {\n        Idle,\n        Chasing,\n        Attacking,\n        BreathingFire\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_fireBreathPoint == null)\n        {\n            GameObject firePoint = new GameObject(\"FireBreathPoint\");\n            firePoint.transform.SetParent(transform);\n            firePoint.transform.localPosition = Vector3.forward * 2f;\n            _fireBreathPoint = firePoint.transform;\n        }\n        \n        _lastFireBreathTime = -_fireBreathCooldown;\n    }\n    \n    private void Update()\n    {\n        FindTarget();\n        UpdateState();\n        HandleState();\n        UpdateAnimations();\n    }\n    \n    private void FindTarget()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRange, _targetLayers);\n        float closestDistance = Mathf.Infinity;\n        Transform closestTarget = null;\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                float distance = Vector3.Distance(transform.position, col.transform.position);\n                if (distance < closestDistance)\n                {\n                    closestDistance = distance;\n                    closestTarget = col.transform;\n                }\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void UpdateState()\n    {\n        if (_target == null)\n        {\n            _currentState = DragonState.Idle;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (_isBreathingFire)\n        {\n            _currentState = DragonState.BreathingFire;\n        }\n        else if (distanceToTarget <= _attackRange && Time.time >= _lastFireBreathTime + _fireBreathCooldown)\n        {\n            _currentState = DragonState.Attacking;\n        }\n        else if (distanceToTarget <= _detectionRange)\n        {\n            _currentState = DragonState.Chasing;\n        }\n        else\n        {\n            _currentState = DragonState.Idle;\n        }\n    }\n    \n    private void HandleState()\n    {\n        switch (_currentState)\n        {\n            case DragonState.Idle:\n                HandleIdle();\n                break;\n            case DragonState.Chasing:\n                HandleChasing();\n                break;\n            case DragonState.Attacking:\n                HandleAttacking();\n                break;\n            case DragonState.BreathingFire:\n                HandleFireBreathing();\n                break;\n        }\n    }\n    \n    private void HandleIdle()\n    {\n        _rigidbody.velocity = Vector3.zero;\n    }\n    \n    private void HandleChasing()\n    {\n        if (_target == null) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * Time.deltaTime);\n        \n        _rigidbody.velocity = transform.forward * _moveSpeed;\n    }\n    \n    private void HandleAttacking()\n    {\n        if (_target == null) return;\n        \n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * 2f * Time.deltaTime);\n        \n        if (!_isBreathingFire)\n        {\n            StartCoroutine(BreatheFire());\n        }\n    }\n    \n    private void HandleFireBreathing()\n    {\n        if (_target == null) return;\n        \n        _rigidbody.velocity = Vector3.zero;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        Vector3 targetRotation = Quaternion.LookRotation(direction).eulerAngles;\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, targetRotation.y, 0), _rotationSpeed * Time.deltaTime);\n    }\n    \n    private IEnumerator BreatheFire()\n    {\n        _isBreathingFire = true;\n        _lastFireBreathTime = Time.time;\n        \n        PlayRoar();\n        \n        yield return new WaitForSeconds(0.5f);\n        \n        if (_fireParticles != null)\n            _fireParticles.Play();\n            \n        if (_fireBreathPrefab != null)\n        {\n            GameObject fireBreath = Instantiate(_fireBreathPrefab, _fireBreathPoint.position, _fireBreathPoint.rotation);\n            Destroy(fireBreath, _fireBreathDuration);\n        }\n        \n        PlayFireBreathSound();\n        \n        float fireTimer = 0f;\n        while (fireTimer < _fireBreathDuration)\n        {\n            DealFireDamage();\n            fireTimer += Time.deltaTime;\n            yield return null;\n        }\n        \n        if (_fireParticles != null)\n            _fireParticles.Stop();\n            \n        _isBreathingFire = false;\n    }\n    \n    private void DealFireDamage()\n    {\n        Vector3 fireDirection = _fireBreathPoint.forward;\n        RaycastHit[] hits = Physics.RaycastAll(_fireBreathPoint.position, fireDirection, _attackRange, _targetLayers);\n        \n        foreach (RaycastHit hit in hits)\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n                if (targetRb != null)\n                {\n                    Vector3 knockback = (hit.collider.transform.position - transform.position).normalized * 5f;\n                    targetRb.AddForce(knockback, ForceMode.Impulse);\n                }\n            }\n        }\n    }\n    \n    private void PlayRoar()\n    {\n        if (_audioSource != null && _roarSound != null)\n        {\n            _audioSource.PlayOneShot(_roarSound);\n        }\n    }\n    \n    private void PlayFireBreathSound()\n    {\n        if (_audioSource != null && _fireBreathSound != null)\n        {\n            _audioSource.PlayOneShot(_fireBreathSound);\n        }\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (_animator == null) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == DragonState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _currentState == DragonState.Attacking);\n        _animator.SetBool(\"IsBreathingFire\", _isBreathingFire);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        if (_fireBreathPoint != null)\n        {\n            Gizmos.color = Color.orange;\n            Gizmos.DrawRay(_fireBreathPoint.position, _fireBreathPoint.forward * _attackRange);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Radio\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isPlaying\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"volume\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"musicClips\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentClipIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"toggle_music\",\n      \"trigger\": \"when player interacts with radio\",\n      \"actions\": [\n        {\n          \"action\": \"if radio is currently playing then stop the music\"\n        },\n        {\n          \"action\": \"if radio is not playing then start playing current music clip\"\n        },\n        {\n          \"action\": \"toggle the playing state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_station\",\n      \"trigger\": \"when player presses next station button\",\n      \"actions\": [\n        {\n          \"action\": \"stop current music\"\n        },\n        {\n          \"action\": \"move to next music clip in the list\"\n        },\n        {\n          \"action\": \"if at end of list then go back to first clip\"\n        },\n        {\n          \"action\": \"start playing the new music clip\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_volume\",\n      \"trigger\": \"when player adjusts volume control\",\n      \"actions\": [\n        {\n          \"action\": \"change the audio volume based on player input\"\n        },\n        {\n          \"action\": \"clamp volume between zero and maximum\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_next_song\",\n      \"trigger\": \"when current music clip finishes playing\",\n      \"actions\": [\n        {\n          \"action\": \"move to next music clip in the list\"\n        },\n        {\n          \"action\": \"if at end of list then go back to first clip\"\n        },\n        {\n          \"action\": \"start playing the new music clip automatically\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Radio : MonoBehaviour\n{\n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip[] _musicTracks;\n    [SerializeField] private float _volume = 0.7f;\n    [SerializeField] private bool _playOnStart = false;\n    [SerializeField] private bool _shuffleMode = false;\n    [SerializeField] private bool _loopPlaylist = true;\n    \n    [Header(\"Interaction\")]\n    [SerializeField] private bool _canPlayerInteract = true;\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _powerIndicator;\n    [SerializeField] private Light _radioLight;\n    [SerializeField] private Color _onColor = Color.green;\n    [SerializeField] private Color _offColor = Color.red;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRadioTurnedOn;\n    public UnityEvent OnRadioTurnedOff;\n    public UnityEvent OnTrackChanged;\n    \n    private bool _isPlaying = false;\n    private int _currentTrackIndex = 0;\n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    \n    private void Start()\n    {\n        InitializeRadio();\n        \n        if (_playOnStart && _musicTracks.Length > 0)\n        {\n            TurnOn();\n        }\n        \n        FindPlayer();\n    }\n    \n    private void Update()\n    {\n        HandlePlayerInteraction();\n        CheckTrackCompletion();\n    }\n    \n    private void InitializeRadio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.volume = _volume;\n        _audioSource.loop = false;\n        _audioSource.playOnAwake = false;\n        \n        UpdateVisualFeedback();\n    }\n    \n    private void FindPlayer()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n        }\n    }\n    \n    private void HandlePlayerInteraction()\n    {\n        if (!_canPlayerInteract || _playerTransform == null) return;\n        \n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        _playerInRange = distanceToPlayer <= _interactionRange;\n        \n        if (_playerInRange && Input.GetKeyDown(_interactionKey))\n        {\n            ToggleRadio();\n        }\n    }\n    \n    private void CheckTrackCompletion()\n    {\n        if (_isPlaying && !_audioSource.isPlaying && _musicTracks.Length > 0)\n        {\n            PlayNextTrack();\n        }\n    }\n    \n    public void ToggleRadio()\n    {\n        if (_isPlaying)\n        {\n            TurnOff();\n        }\n        else\n        {\n            TurnOn();\n        }\n    }\n    \n    public void TurnOn()\n    {\n        if (_musicTracks.Length == 0) return;\n        \n        _isPlaying = true;\n        PlayCurrentTrack();\n        UpdateVisualFeedback();\n        OnRadioTurnedOn?.Invoke();\n    }\n    \n    public void TurnOff()\n    {\n        _isPlaying = false;\n        _audioSource.Stop();\n        UpdateVisualFeedback();\n        OnRadioTurnedOff?.Invoke();\n    }\n    \n    private void PlayCurrentTrack()\n    {\n        if (_musicTracks.Length == 0 || _currentTrackIndex >= _musicTracks.Length) return;\n        \n        _audioSource.clip = _musicTracks[_currentTrackIndex];\n        _audioSource.Play();\n        OnTrackChanged?.Invoke();\n    }\n    \n    private void PlayNextTrack()\n    {\n        if (_shuffleMode)\n        {\n            _currentTrackIndex = Random.Range(0, _musicTracks.Length);\n        }\n        else\n        {\n            _currentTrackIndex++;\n            if (_currentTrackIndex >= _musicTracks.Length)\n            {\n                if (_loopPlaylist)\n                {\n                    _currentTrackIndex = 0;\n                }\n                else\n                {\n                    TurnOff();\n                    return;\n                }\n            }\n        }\n        \n        PlayCurrentTrack();\n    }\n    \n    public void NextTrack()\n    {\n        if (!_isPlaying || _musicTracks.Length <= 1) return;\n        \n        _audioSource.Stop();\n        PlayNextTrack();\n    }\n    \n    public void PreviousTrack()\n    {\n        if (!_isPlaying || _musicTracks.Length <= 1) return;\n        \n        _currentTrackIndex--;\n        if (_currentTrackIndex < 0)\n        {\n            _currentTrackIndex = _musicTracks.Length - 1;\n        }\n        \n        _audioSource.Stop();\n        PlayCurrentTrack();\n    }\n    \n    public void SetVolume(float volume)\n    {\n        _volume = Mathf.Clamp01(volume);\n        _audioSource.volume = _volume;\n    }\n    \n    public void SetShuffleMode(bool shuffle)\n    {\n        _shuffleMode = shuffle;\n    }\n    \n    public void SetLoopMode(bool loop)\n    {\n        _loopPlaylist = loop;\n    }\n    \n    private void UpdateVisualFeedback()\n    {\n        if (_powerIndicator != null)\n        {\n            _powerIndicator.SetActive(_isPlaying);\n        }\n        \n        if (_radioLight != null)\n        {\n            _radioLight.color = _isPlaying ? _onColor : _offColor;\n            _radioLight.enabled = _isPlaying;\n        }\n    }\n    \n    public bool IsPlaying => _isPlaying;\n    public string CurrentTrackName => _musicTracks.Length > 0 && _currentTrackIndex < _musicTracks.Length ? _musicTracks[_currentTrackIndex].name : \"None\";\n    public int CurrentTrackIndex => _currentTrackIndex;\n    public int TotalTracks => _musicTracks.Length;\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_canPlayerInteract)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GrapplingHook\",\n  \"components\": [\n    \"Rigidbody\",\n    \"LineRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hookRange\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"hookSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"swingForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"hookPoint\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"isHooked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isSwinging\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"ropeLength\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_hook\",\n      \"trigger\": \"when fire input is pressed and not currently hooked\",\n      \"actions\": [\n        {\n          \"action\": \"cast ray from player position toward aim direction\"\n        },\n        {\n          \"action\": \"check if ray hits hookable surface within hook range\"\n        },\n        {\n          \"action\": \"if surface is hookable set hook point to hit location\"\n        },\n        {\n          \"action\": \"set hooked state to true\"\n        },\n        {\n          \"action\": \"calculate rope length as distance to hook point\"\n        },\n        {\n          \"action\": \"play hook firing sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"draw_rope\",\n      \"trigger\": \"when hooked state is true\",\n      \"actions\": [\n        {\n          \"action\": \"draw line from player position to hook point\"\n        },\n        {\n          \"action\": \"set line width based on rope thickness\"\n        },\n        {\n          \"action\": \"update line positions every frame\"\n        }\n      ]\n    },\n    {\n      \"name\": \"swing_movement\",\n      \"trigger\": \"when hooked and player is in air\",\n      \"actions\": [\n        {\n          \"action\": \"calculate direction from player to hook point\"\n        },\n        {\n          \"action\": \"maintain rope length constraint\"\n        },\n        {\n          \"action\": \"apply swing physics based on player input\"\n        },\n        {\n          \"action\": \"add momentum in swing direction\"\n        },\n        {\n          \"action\": \"set swinging state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_hook\",\n      \"trigger\": \"when fire input is released or hook key is pressed again\",\n      \"actions\": [\n        {\n          \"action\": \"set hooked state to false\"\n        },\n        {\n          \"action\": \"set swinging state to false\"\n        },\n        {\n          \"action\": \"hide rope line renderer\"\n        },\n        {\n          \"action\": \"preserve current momentum for continued movement\"\n        },\n        {\n          \"action\": \"play hook release sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rope_physics\",\n      \"trigger\": \"when swinging and rope is at maximum length\",\n      \"actions\": [\n        {\n          \"action\": \"prevent player from moving further away from hook point\"\n        },\n        {\n          \"action\": \"apply pendulum physics to player movement\"\n        },\n        {\n          \"action\": \"calculate swing arc based on rope length and gravity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hook_break\",\n      \"trigger\": \"when hook point object is destroyed or moves\",\n      \"actions\": [\n        {\n          \"action\": \"automatically release hook\"\n        },\n        {\n          \"action\": \"set hooked state to false\"\n        },\n        {\n          \"action\": \"hide rope line renderer\"\n        },\n        {\n          \"action\": \"play hook break sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GrapplingHook : MonoBehaviour\n{\n    [Header(\"Grappling Settings\")]\n    [SerializeField] private float _maxGrappleDistance = 20f;\n    [SerializeField] private float _grappleSpeed = 30f;\n    [SerializeField] private float _swingForce = 15f;\n    [SerializeField] private float _climbSpeed = 8f;\n    [SerializeField] private LayerMask _grappleableLayers = -1;\n    [SerializeField] private float _jointSpring = 4.5f;\n    [SerializeField] private float _jointDamper = 7f;\n    [SerializeField] private float _jointMassScale = 4.5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _grappleKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Mouse1;\n    [SerializeField] private KeyCode _climbUpKey = KeyCode.W;\n    [SerializeField] private KeyCode _climbDownKey = KeyCode.S;\n    \n    [Header(\"Visual\")]\n    [SerializeField] private LineRenderer _grappleLine;\n    [SerializeField] private Transform _grapplePoint;\n    [SerializeField] private GameObject _hookPrefab;\n    [SerializeField] private float _lineWidth = 0.1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _shootSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnGrappleStart;\n    public UnityEvent OnGrappleHit;\n    public UnityEvent OnGrappleRelease;\n    \n    private Camera _playerCamera;\n    private Rigidbody _rigidbody;\n    private SpringJoint _springJoint;\n    private Vector3 _grappleTarget;\n    private bool _isGrappling;\n    private bool _isHooked;\n    private GameObject _hookInstance;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    \n    private enum GrappleState\n    {\n        Idle,\n        Shooting,\n        Hooked,\n        Retracting\n    }\n    \n    private GrappleState _currentState = GrappleState.Idle;\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupLineRenderer();\n        \n        _originalDrag = _rigidbody.drag;\n        _originalAngularDrag = _rigidbody.angularDrag;\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateVisuals();\n        HandleClimbing();\n    }\n    \n    void FixedUpdate()\n    {\n        switch (_currentState)\n        {\n            case GrappleState.Shooting:\n                UpdateShooting();\n                break;\n            case GrappleState.Hooked:\n                UpdateSwinging();\n                break;\n        }\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_grappleKey) && !_isGrappling)\n        {\n            StartGrapple();\n        }\n        \n        if (Input.GetKeyDown(_releaseKey) && _isGrappling)\n        {\n            ReleaseGrapple();\n        }\n    }\n    \n    void StartGrapple()\n    {\n        Vector3 rayOrigin = _playerCamera.transform.position;\n        Vector3 rayDirection = _playerCamera.transform.forward;\n        \n        RaycastHit hit;\n        if (Physics.Raycast(rayOrigin, rayDirection, out hit, _maxGrappleDistance, _grappleableLayers))\n        {\n            _grappleTarget = hit.point;\n            _isGrappling = true;\n            _currentState = GrappleState.Shooting;\n            \n            PlaySound(_shootSound);\n            OnGrappleStart?.Invoke();\n            \n            if (_hookPrefab != null)\n            {\n                _hookInstance = Instantiate(_hookPrefab, _grapplePoint.position, Quaternion.identity);\n            }\n        }\n    }\n    \n    void UpdateShooting()\n    {\n        if (_hookInstance != null)\n        {\n            Vector3 direction = (_grappleTarget - _hookInstance.transform.position).normalized;\n            _hookInstance.transform.position += direction * _grappleSpeed * Time.fixedDeltaTime;\n            \n            float distanceToTarget = Vector3.Distance(_hookInstance.transform.position, _grappleTarget);\n            \n            if (distanceToTarget < 0.5f)\n            {\n                _hookInstance.transform.position = _grappleTarget;\n                CreateSpringJoint();\n                _currentState = GrappleState.Hooked;\n                _isHooked = true;\n                \n                PlaySound(_hitSound);\n                OnGrappleHit?.Invoke();\n            }\n        }\n        else\n        {\n            CreateSpringJoint();\n            _currentState = GrappleState.Hooked;\n            _isHooked = true;\n            \n            PlaySound(_hitSound);\n            OnGrappleHit?.Invoke();\n        }\n    }\n    \n    void CreateSpringJoint()\n    {\n        _springJoint = gameObject.AddComponent<SpringJoint>();\n        _springJoint.autoConfigureConnectedAnchor = false;\n        _springJoint.connectedAnchor = _grappleTarget;\n        \n        float distanceFromPoint = Vector3.Distance(transform.position, _grappleTarget);\n        _springJoint.maxDistance = distanceFromPoint * 0.8f;\n        _springJoint.minDistance = distanceFromPoint * 0.25f;\n        \n        _springJoint.spring = _jointSpring;\n        _springJoint.damper = _jointDamper;\n        _springJoint.massScale = _jointMassScale;\n        \n        _rigidbody.drag = 0f;\n        _rigidbody.angularDrag = 0f;\n    }\n    \n    void UpdateSwinging()\n    {\n        Vector3 swingDirection = Vector3.zero;\n        \n        if (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow))\n            swingDirection += -_playerCamera.transform.right;\n        if (Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow))\n            swingDirection += _playerCamera.transform.right;\n        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))\n            swingDirection += _playerCamera.transform.forward;\n        if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow))\n            swingDirection += -_playerCamera.transform.forward;\n        \n        swingDirection.y = 0;\n        swingDirection = swingDirection.normalized;\n        \n        if (swingDirection != Vector3.zero)\n        {\n            _rigidbody.AddForce(swingDirection * _swingForce, ForceMode.Force);\n        }\n    }\n    \n    void HandleClimbing()\n    {\n        if (!_isHooked || _springJoint == null) return;\n        \n        if (Input.GetKey(_climbUpKey))\n        {\n            if (_springJoint.maxDistance > 2f)\n            {\n                _springJoint.maxDistance -= _climbSpeed * Time.deltaTime;\n                _springJoint.minDistance -= _climbSpeed * Time.deltaTime;\n            }\n        }\n        else if (Input.GetKey(_climbDownKey))\n        {\n            _springJoint.maxDistance += _climbSpeed * Time.deltaTime;\n            _springJoint.minDistance += _climbSpeed * Time.deltaTime;\n        }\n    }\n    \n    void ReleaseGrapple()\n    {\n        _isGrappling = false;\n        _isHooked = false;\n        _currentState = GrappleState.Idle;\n        \n        if (_springJoint != null)\n        {\n            Destroy(_springJoint);\n            _springJoint = null;\n        }\n        \n        if (_hookInstance != null)\n        {\n            Destroy(_hookInstance);\n            _hookInstance = null;\n        }\n        \n        _rigidbody.drag = _originalDrag;\n        _rigidbody.angularDrag = _originalAngularDrag;\n        \n        PlaySound(_releaseSound);\n        OnGrappleRelease?.Invoke();\n    }\n    \n    void UpdateVisuals()\n    {\n        if (_grappleLine == null) return;\n        \n        if (_isGrappling)\n        {\n            _grappleLine.enabled = true;\n            _grappleLine.positionCount = 2;\n            \n            Vector3 startPoint = _grapplePoint != null ? _grapplePoint.position : transform.position;\n            Vector3 endPoint = _isHooked ? _grappleTarget : \n                              (_hookInstance != null ? _hookInstance.transform.position : _grappleTarget);\n            \n            _grappleLine.SetPosition(0, startPoint);\n            _grappleLine.SetPosition(1, endPoint);\n        }\n        else\n        {\n            _grappleLine.enabled = false;\n        }\n    }\n    \n    void SetupLineRenderer()\n    {\n        if (_grappleLine == null)\n        {\n            _grappleLine = gameObject.AddComponent<LineRenderer>();\n        }\n        \n        _grappleLine.material = new Material(Shader.Find(\"Sprites/Default\"));\n        _grappleLine.color = Color.white;\n        _grappleLine.startWidth = _lineWidth;\n        _grappleLine.endWidth = _lineWidth;\n        _grappleLine.enabled = false;\n        _grappleLine.useWorldSpace = true;\n    }\n    \n    void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        if (_playerCamera != null)\n        {\n            Vector3 rayOrigin = _playerCamera.transform.position;\n            Vector3 rayDirection = _playerCamera.transform.forward;\n            Gizmos.DrawRay(rayOrigin, rayDirection * _maxGrappleDistance);\n        }\n        \n        if (_isGrappling)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_grappleTarget, 0.5f);\n        }\n    }\n    \n    void OnDestroy()\n    {\n        if (_springJoint != null)\n        {\n            Destroy(_springJoint);\n        }\n        \n        if (_hookInstance != null)\n        {\n            Destroy(_hookInstance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AreaMusicController\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentArea\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_area_change\",\n      \"trigger\": \"when player enters a new area with different music\",\n      \"actions\": [\n        {\n          \"action\": \"identify the new area type\"\n        },\n        {\n          \"action\": \"store the new area name\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out_current_music\",\n      \"trigger\": \"when area change is detected and music is currently playing\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce current music volume to zero\"\n        },\n        {\n          \"action\": \"stop the current audio track when volume reaches zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_in_new_music\",\n      \"trigger\": \"when current music has finished fading out and new area is detected\",\n      \"actions\": [\n        {\n          \"action\": \"load the appropriate music track for the new area\"\n        },\n        {\n          \"action\": \"start playing the new music track at zero volume\"\n        },\n        {\n          \"action\": \"gradually increase volume to full level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_same_area\",\n      \"trigger\": \"when player moves within the same area type\",\n      \"actions\": [\n        {\n          \"action\": \"continue playing current music without changes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AreaMusicManager : MonoBehaviour\n{\n    [System.Serializable]\n    public class MusicArea\n    {\n        [Header(\"Area Settings\")]\n        public string areaName;\n        public AudioClip musicClip;\n        public float volume = 1f;\n        public bool loop = true;\n        public float fadeInDuration = 2f;\n        public float fadeOutDuration = 2f;\n        \n        [Header(\"Area Detection\")]\n        public Transform areaCenter;\n        public float areaRadius = 10f;\n        public LayerMask playerLayer = 1;\n        \n        [Header(\"Trigger Alternative\")]\n        public Collider areaTrigger;\n    }\n\n    [Header(\"Music Areas\")]\n    [SerializeField] private List<MusicArea> _musicAreas = new List<MusicArea>();\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _musicSource;\n    [SerializeField] private float _globalVolume = 1f;\n    [SerializeField] private bool _playOnStart = true;\n    \n    [Header(\"Default Music\")]\n    [SerializeField] private AudioClip _defaultMusicClip;\n    [SerializeField] private float _defaultVolume = 0.5f;\n    \n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _checkInterval = 0.5f;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    private Transform _player;\n    private MusicArea _currentArea;\n    private Coroutine _fadeCoroutine;\n    private bool _isTransitioning = false;\n    private Dictionary<Collider, MusicArea> _triggerToAreaMap = new Dictionary<Collider, MusicArea>();\n\n    private void Start()\n    {\n        InitializeAudioSource();\n        FindPlayer();\n        SetupTriggerMappings();\n        \n        if (_playOnStart)\n        {\n            PlayDefaultMusic();\n        }\n        \n        StartCoroutine(CheckPlayerAreaRoutine());\n    }\n\n    private void InitializeAudioSource()\n    {\n        if (_musicSource == null)\n        {\n            _musicSource = GetComponent<AudioSource>();\n            if (_musicSource == null)\n            {\n                _musicSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _musicSource.playOnAwake = false;\n        _musicSource.volume = 0f;\n    }\n\n    private void FindPlayer()\n    {\n        GameObject playerObject = GameObject.FindGameObjectWithTag(_playerTag);\n        if (playerObject != null)\n        {\n            _player = playerObject.transform;\n        }\n    }\n\n    private void SetupTriggerMappings()\n    {\n        _triggerToAreaMap.Clear();\n        \n        foreach (var area in _musicAreas)\n        {\n            if (area.areaTrigger != null)\n            {\n                _triggerToAreaMap[area.areaTrigger] = area;\n                \n                if (area.areaTrigger.isTrigger == false)\n                {\n                    Debug.LogWarning($\"Area trigger for {area.areaName} is not set as trigger!\");\n                }\n            }\n        }\n    }\n\n    private void PlayDefaultMusic()\n    {\n        if (_defaultMusicClip != null)\n        {\n            PlayMusic(_defaultMusicClip, _defaultVolume, true, 1f);\n        }\n    }\n\n    private IEnumerator CheckPlayerAreaRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(_checkInterval);\n            \n            if (_player != null && !_isTransitioning)\n            {\n                CheckPlayerArea();\n            }\n        }\n    }\n\n    private void CheckPlayerArea()\n    {\n        MusicArea newArea = GetPlayerCurrentArea();\n        \n        if (newArea != _currentArea)\n        {\n            ChangeToArea(newArea);\n        }\n    }\n\n    private MusicArea GetPlayerCurrentArea()\n    {\n        Vector3 playerPosition = _player.position;\n        \n        foreach (var area in _musicAreas)\n        {\n            if (IsPlayerInArea(area, playerPosition))\n            {\n                return area;\n            }\n        }\n        \n        return null;\n    }\n\n    private bool IsPlayerInArea(MusicArea area, Vector3 playerPosition)\n    {\n        if (area.areaTrigger != null)\n        {\n            return area.areaTrigger.bounds.Contains(playerPosition);\n        }\n        \n        if (area.areaCenter != null)\n        {\n            float distance = Vector3.Distance(playerPosition, area.areaCenter.position);\n            return distance <= area.areaRadius;\n        }\n        \n        return false;\n    }\n\n    private void ChangeToArea(MusicArea newArea)\n    {\n        _currentArea = newArea;\n        \n        if (newArea != null && newArea.musicClip != null)\n        {\n            PlayAreaMusic(newArea);\n        }\n        else\n        {\n            PlayDefaultMusic();\n        }\n    }\n\n    private void PlayAreaMusic(MusicArea area)\n    {\n        float fadeIn = area.fadeInDuration;\n        float fadeOut = _currentArea != null ? _currentArea.fadeOutDuration : 1f;\n        \n        PlayMusic(area.musicClip, area.volume, area.loop, fadeIn, fadeOut);\n    }\n\n    private void PlayMusic(AudioClip clip, float volume, bool loop, float fadeInDuration, float fadeOutDuration = 1f)\n    {\n        if (clip == null) return;\n        \n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n        }\n        \n        _fadeCoroutine = StartCoroutine(FadeToNewMusic(clip, volume, loop, fadeInDuration, fadeOutDuration));\n    }\n\n    private IEnumerator FadeToNewMusic(AudioClip newClip, float targetVolume, bool loop, float fadeInDuration, float fadeOutDuration)\n    {\n        _isTransitioning = true;\n        \n        // Fade out current music\n        if (_musicSource.isPlaying)\n        {\n            float startVolume = _musicSource.volume;\n            float fadeOutTime = 0f;\n            \n            while (fadeOutTime < fadeOutDuration)\n            {\n                fadeOutTime += Time.deltaTime;\n                float t = fadeOutTime / fadeOutDuration;\n                _musicSource.volume = Mathf.Lerp(startVolume, 0f, t);\n                yield return null;\n            }\n        }\n        \n        // Change to new music\n        _musicSource.clip = newClip;\n        _musicSource.loop = loop;\n        _musicSource.volume = 0f;\n        _musicSource.Play();\n        \n        // Fade in new music\n        float fadeInTime = 0f;\n        float finalVolume = targetVolume * _globalVolume;\n        \n        while (fadeInTime < fadeInDuration)\n        {\n            fadeInTime += Time.deltaTime;\n            float t = fadeInTime / fadeInDuration;\n            _musicSource.volume = Mathf.Lerp(0f, finalVolume, t);\n            yield return null;\n        }\n        \n        _musicSource.volume = finalVolume;\n        _isTransitioning = false;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(_playerTag) && _triggerToAreaMap.ContainsKey(other))\n        {\n            MusicArea area = _triggerToAreaMap[other];\n            if (area != _currentArea)\n            {\n                ChangeToArea(area);\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(_playerTag) && _triggerToAreaMap.ContainsKey(other))\n        {\n            MusicArea area = _triggerToAreaMap[other];\n            if (area == _currentArea)\n            {\n                ChangeToArea(null);\n            }\n        }\n    }\n\n    public void SetGlobalVolume(float volume)\n    {\n        _globalVolume = Mathf.Clamp01(volume);\n        if (_musicSource.isPlaying && _currentArea != null)\n        {\n            _musicSource.volume = _currentArea.volume * _globalVolume;\n        }\n    }\n\n    public void StopMusic(float fadeOutDuration = 1f)\n    {\n        if (_fadeCoroutine != null)\n        {\n            StopCoroutine(_fadeCoroutine);\n        }\n        \n        _fadeCoroutine = StartCoroutine(FadeOutMusic(fadeOutDuration));\n    }\n\n    private IEnumerator FadeOutMusic(float fadeOutDuration)\n    {\n        _isTransitioning = true;\n        float startVolume = _musicSource.volume;\n        float fadeTime = 0f;\n        \n        while (fadeTime < fadeOutDuration)\n        {\n            fadeTime += Time.deltaTime;\n            float t = fadeTime / fadeOutDuration;\n            _musicSource.volume = Mathf.Lerp(startVolume, 0f, t);\n            yield return null;\n        }\n        \n        _musicSource.Stop();\n        _musicSource.volume = 0f;\n        _currentArea = null;\n        _isTransitioning = false;\n    }\n\n    public void ForceAreaChange(string areaName)\n    {\n        MusicArea area = _musicAreas.Find(a => a.areaName == areaName);\n        if (area != null)\n        {\n            ChangeToArea(area);\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        foreach (var area in _musicAreas)\n        {\n            if (area.areaCenter != null)\n            {\n                Gizmos.color = Color.cyan;\n                Gizmos.DrawWireSphere(area.areaCenter.position, area.areaRadius);\n                \n                Gizmos.color = Color.blue;\n                Gizmos.DrawWireCube(area.areaCenter.position, Vector3.one * 0.5f);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PotionBottle\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swirl_speed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"particle_count\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"glow_intensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"bubble_sound_volume\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_swirl\",\n      \"trigger\": \"always active\",\n      \"actions\": [\n        {\n          \"action\": \"emit particles in circular swirling motion\"\n        },\n        {\n          \"action\": \"rotate particles around bottle center at swirl speed\"\n        },\n        {\n          \"action\": \"vary particle colors between magical hues\"\n        }\n      ]\n    },\n    {\n      \"name\": \"glow_pulse\",\n      \"trigger\": \"always active\",\n      \"actions\": [\n        {\n          \"action\": \"pulse glow intensity up and down smoothly\"\n        },\n        {\n          \"action\": \"illuminate surrounding area with magical light\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bubble_effects\",\n      \"trigger\": \"randomly every few seconds\",\n      \"actions\": [\n        {\n          \"action\": \"spawn larger bubble particles that rise upward\"\n        },\n        {\n          \"action\": \"play soft bubbling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"interaction_response\",\n      \"trigger\": \"when player approaches closely\",\n      \"actions\": [\n        {\n          \"action\": \"increase particle emission rate\"\n        },\n        {\n          \"action\": \"brighten glow intensity\"\n        },\n        {\n          \"action\": \"speed up swirling motion\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class PotionBottle : MonoBehaviour\n{\n    [Header(\"Potion Settings\")]\n    [SerializeField] private Color _potionColor = Color.red;\n    [SerializeField] private float _swirlingSpeed = 2f;\n    [SerializeField] private float _swirlingRadius = 0.5f;\n    [SerializeField] private int _particleCount = 20;\n    \n    [Header(\"Bottle Components\")]\n    [SerializeField] private Transform _liquidTransform;\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private Light _potionLight;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private float _glowIntensity = 1f;\n    [SerializeField] private float _bobHeight = 0.1f;\n    [SerializeField] private float _bobSpeed = 1f;\n    [SerializeField] private AudioClip _bubbleSound;\n    [SerializeField] private bool _playAmbientSound = true;\n    \n    private Vector3 _initialPosition;\n    private float _timeOffset;\n    private ParticleSystem.Particle[] _particles;\n    private float[] _particleAngles;\n    private float[] _particleHeights;\n    private Renderer _liquidRenderer;\n    \n    private void Start()\n    {\n        _initialPosition = transform.position;\n        _timeOffset = Random.Range(0f, 2f * Mathf.PI);\n        \n        InitializeParticleSystem();\n        InitializeLiquid();\n        InitializeLight();\n        InitializeAudio();\n    }\n    \n    private void InitializeParticleSystem()\n    {\n        if (_particleSystem == null)\n        {\n            GameObject particleObj = new GameObject(\"PotionParticles\");\n            particleObj.transform.SetParent(transform);\n            particleObj.transform.localPosition = Vector3.zero;\n            _particleSystem = particleObj.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _particleSystem.main;\n        main.startLifetime = float.MaxValue;\n        main.startSpeed = 0f;\n        main.startSize = 0.05f;\n        main.startColor = _potionColor;\n        main.maxParticles = _particleCount;\n        main.simulationSpace = ParticleSystemSimulationSpace.Local;\n        \n        var emission = _particleSystem.emission;\n        emission.enabled = false;\n        \n        var shape = _particleSystem.shape;\n        shape.enabled = false;\n        \n        _particles = new ParticleSystem.Particle[_particleCount];\n        _particleAngles = new float[_particleCount];\n        _particleHeights = new float[_particleCount];\n        \n        for (int i = 0; i < _particleCount; i++)\n        {\n            _particleAngles[i] = (float)i / _particleCount * 2f * Mathf.PI;\n            _particleHeights[i] = Random.Range(-0.8f, 0.8f);\n            \n            _particles[i].position = CalculateParticlePosition(i, 0f);\n            _particles[i].startColor = Color.Lerp(_potionColor, Color.white, Random.Range(0f, 0.3f));\n            _particles[i].startSize = Random.Range(0.03f, 0.08f);\n        }\n        \n        _particleSystem.SetParticles(_particles, _particleCount);\n    }\n    \n    private void InitializeLiquid()\n    {\n        if (_liquidTransform != null)\n        {\n            _liquidRenderer = _liquidTransform.GetComponent<Renderer>();\n            if (_liquidRenderer != null)\n            {\n                _liquidRenderer.material.color = _potionColor;\n                if (_liquidRenderer.material.HasProperty(\"_EmissionColor\"))\n                {\n                    _liquidRenderer.material.SetColor(\"_EmissionColor\", _potionColor * _glowIntensity);\n                }\n            }\n        }\n    }\n    \n    private void InitializeLight()\n    {\n        if (_potionLight == null)\n        {\n            GameObject lightObj = new GameObject(\"PotionLight\");\n            lightObj.transform.SetParent(transform);\n            lightObj.transform.localPosition = Vector3.zero;\n            _potionLight = lightObj.AddComponent<Light>();\n        }\n        \n        _potionLight.type = LightType.Point;\n        _potionLight.color = _potionColor;\n        _potionLight.intensity = _glowIntensity;\n        _potionLight.range = 3f;\n    }\n    \n    private void InitializeAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.clip = _bubbleSound;\n        _audioSource.loop = true;\n        _audioSource.volume = 0.3f;\n        _audioSource.pitch = Random.Range(0.8f, 1.2f);\n        \n        if (_playAmbientSound && _bubbleSound != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateBottlePosition();\n        UpdateParticles();\n        UpdateLightEffect();\n    }\n    \n    private void UpdateBottlePosition()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed + _timeOffset) * _bobHeight;\n        transform.position = _initialPosition + Vector3.up * bobOffset;\n    }\n    \n    private void UpdateParticles()\n    {\n        if (_particleSystem == null || _particles == null) return;\n        \n        float time = Time.time * _swirlingSpeed;\n        \n        for (int i = 0; i < _particleCount; i++)\n        {\n            _particles[i].position = CalculateParticlePosition(i, time);\n            \n            // Add some random movement\n            Vector3 randomOffset = new Vector3(\n                Mathf.Sin(time * 2f + i) * 0.02f,\n                Mathf.Cos(time * 1.5f + i) * 0.01f,\n                Mathf.Sin(time * 1.8f + i) * 0.02f\n            );\n            \n            _particles[i].position += randomOffset;\n        }\n        \n        _particleSystem.SetParticles(_particles, _particleCount);\n    }\n    \n    private Vector3 CalculateParticlePosition(int index, float time)\n    {\n        float angle = _particleAngles[index] + time;\n        float radius = _swirlingRadius * (0.5f + 0.5f * Mathf.Sin(time * 0.5f + index));\n        \n        float x = Mathf.Cos(angle) * radius;\n        float z = Mathf.Sin(angle) * radius;\n        float y = _particleHeights[index] + Mathf.Sin(time + index) * 0.1f;\n        \n        return new Vector3(x, y, z);\n    }\n    \n    private void UpdateLightEffect()\n    {\n        if (_potionLight != null)\n        {\n            float flicker = 1f + Mathf.Sin(Time.time * 3f + _timeOffset) * 0.1f;\n            _potionLight.intensity = _glowIntensity * flicker;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            StartCoroutine(ConsumePotion());\n        }\n    }\n    \n    private IEnumerator ConsumePotion()\n    {\n        // Increase swirling speed\n        float originalSpeed = _swirlingSpeed;\n        _swirlingSpeed *= 3f;\n        \n        // Play consumption sound\n        if (_audioSource != null && _bubbleSound != null)\n        {\n            _audioSource.pitch = 1.5f;\n            _audioSource.volume = 0.6f;\n        }\n        \n        // Shrink effect\n        Vector3 originalScale = transform.localScale;\n        float shrinkTime = 1f;\n        float elapsed = 0f;\n        \n        while (elapsed < shrinkTime)\n        {\n            elapsed += Time.deltaTime;\n            float progress = elapsed / shrinkTime;\n            \n            transform.localScale = Vector3.Lerp(originalScale, Vector3.zero, progress);\n            \n            if (_potionLight != null)\n            {\n                _potionLight.intensity = Mathf.Lerp(_glowIntensity, 0f, progress);\n            }\n            \n            yield return null;\n        }\n        \n        gameObject.SetActive(false);\n    }\n    \n    public void SetPotionColor(Color newColor)\n    {\n        _potionColor = newColor;\n        \n        if (_liquidRenderer != null)\n        {\n            _liquidRenderer.material.color = _potionColor;\n            if (_liquidRenderer.material.HasProperty(\"_EmissionColor\"))\n            {\n                _liquidRenderer.material.SetColor(\"_EmissionColor\", _potionColor * _glowIntensity);\n            }\n        }\n        \n        if (_potionLight != null)\n        {\n            _potionLight.color = _potionColor;\n        }\n        \n        if (_particles != null)\n        {\n            for (int i = 0; i < _particles.Length; i++)\n            {\n                _particles[i].startColor = Color.Lerp(_potionColor, Color.white, Random.Range(0f, 0.3f));\n            }\n            _particleSystem.SetParticles(_particles, _particleCount);\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            SetPotionColor(_potionColor);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MineCart\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"speed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"brakingForce\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isOnTrack\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"currentTrackPoint\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"trackPoints\",\n      \"type\": \"Transform[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"wheelSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"brakeSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_track\",\n      \"trigger\": \"when cart is on track and has track points to follow\",\n      \"actions\": [\n        {\n          \"action\": \"move toward next track point at current speed\"\n        },\n        {\n          \"action\": \"rotate to face direction of movement\"\n        },\n        {\n          \"action\": \"play wheel rolling sound while moving\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reach_track_point\",\n      \"trigger\": \"when cart reaches current target track point\",\n      \"actions\": [\n        {\n          \"action\": \"advance to next track point in sequence\"\n        },\n        {\n          \"action\": \"if at end of track then stop movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"accelerate_downhill\",\n      \"trigger\": \"when cart is moving downhill on track\",\n      \"actions\": [\n        {\n          \"action\": \"increase speed gradually up to maximum speed\"\n        },\n        {\n          \"action\": \"increase wheel sound pitch and volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake_uphill\",\n      \"trigger\": \"when cart is moving uphill on track\",\n      \"actions\": [\n        {\n          \"action\": \"decrease speed gradually due to gravity\"\n        },\n        {\n          \"action\": \"decrease wheel sound pitch and volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emergency_brake\",\n      \"trigger\": \"when cart derails or leaves track\",\n      \"actions\": [\n        {\n          \"action\": \"apply strong braking force to slow down\"\n        },\n        {\n          \"action\": \"play brake screeching sound\"\n        },\n        {\n          \"action\": \"mark cart as off track\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_interaction\",\n      \"trigger\": \"when player enters cart trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"allow player to control cart speed\"\n        },\n        {\n          \"action\": \"enable manual braking input\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MineCart : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 10f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 8f;\n    [SerializeField] private float _gravity = 9.81f;\n    [SerializeField] private float _slopeSpeedMultiplier = 1.5f;\n    \n    [Header(\"Track Detection\")]\n    [SerializeField] private LayerMask _trackLayerMask = 1;\n    [SerializeField] private float _trackDetectionDistance = 2f;\n    [SerializeField] private Transform _frontWheelPoint;\n    [SerializeField] private Transform _rearWheelPoint;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _mass = 100f;\n    [SerializeField] private float _friction = 0.1f;\n    [SerializeField] private float _airResistance = 0.05f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rollingSound;\n    [SerializeField] private AudioClip _brakeSound;\n    [SerializeField] private float _minPitchSpeed = 0f;\n    [SerializeField] private float _maxPitchSpeed = 10f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCartStart;\n    public UnityEvent OnCartStop;\n    public UnityEvent<float> OnSpeedChanged;\n    public UnityEvent OnDerailed;\n    \n    private Rigidbody _rigidbody;\n    private Vector3 _currentDirection;\n    private float _currentSpeed;\n    private bool _isOnTrack;\n    private bool _isMoving;\n    private bool _playerOnBoard;\n    private RaycastHit _frontHit;\n    private RaycastHit _rearHit;\n    private Vector3 _lastValidDirection;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.mass = _mass;\n        _rigidbody.useGravity = false;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _audioSource.clip = _rollingSound;\n        _audioSource.loop = true;\n        _audioSource.playOnAwake = false;\n        \n        if (_frontWheelPoint == null)\n        {\n            GameObject frontWheel = new GameObject(\"FrontWheelPoint\");\n            frontWheel.transform.SetParent(transform);\n            frontWheel.transform.localPosition = Vector3.forward * 1f;\n            _frontWheelPoint = frontWheel.transform;\n        }\n        \n        if (_rearWheelPoint == null)\n        {\n            GameObject rearWheel = new GameObject(\"RearWheelPoint\");\n            rearWheel.transform.SetParent(transform);\n            rearWheel.transform.localPosition = Vector3.back * 1f;\n            _rearWheelPoint = rearWheel.transform;\n        }\n        \n        _currentDirection = transform.forward;\n        _lastValidDirection = _currentDirection;\n    }\n    \n    private void FixedUpdate()\n    {\n        DetectTrack();\n        \n        if (_isOnTrack)\n        {\n            CalculateTrackDirection();\n            ApplyMovement();\n        }\n        else\n        {\n            ApplyGravity();\n            HandleDerailment();\n        }\n        \n        UpdateAudio();\n        OnSpeedChanged?.Invoke(_currentSpeed);\n    }\n    \n    private void DetectTrack()\n    {\n        bool frontOnTrack = Physics.Raycast(_frontWheelPoint.position, Vector3.down, out _frontHit, _trackDetectionDistance, _trackLayerMask);\n        bool rearOnTrack = Physics.Raycast(_rearWheelPoint.position, Vector3.down, out _rearHit, _trackDetectionDistance, _trackLayerMask);\n        \n        _isOnTrack = frontOnTrack && rearOnTrack;\n        \n        if (!_isOnTrack && _isMoving)\n        {\n            OnDerailed?.Invoke();\n        }\n    }\n    \n    private void CalculateTrackDirection()\n    {\n        if (_isOnTrack)\n        {\n            Vector3 frontPoint = _frontHit.point;\n            Vector3 rearPoint = _rearHit.point;\n            \n            Vector3 trackDirection = (frontPoint - rearPoint).normalized;\n            \n            if (Vector3.Dot(trackDirection, _lastValidDirection) < 0)\n            {\n                trackDirection = -trackDirection;\n            }\n            \n            _currentDirection = trackDirection;\n            _lastValidDirection = trackDirection;\n            \n            Vector3 averageNormal = (_frontHit.normal + _rearHit.normal) * 0.5f;\n            Vector3 rightDirection = Vector3.Cross(trackDirection, averageNormal).normalized;\n            Vector3 upDirection = Vector3.Cross(rightDirection, trackDirection).normalized;\n            \n            transform.rotation = Quaternion.LookRotation(trackDirection, upDirection);\n        }\n    }\n    \n    private void ApplyMovement()\n    {\n        float slopeAngle = Vector3.Angle(Vector3.up, (_frontHit.normal + _rearHit.normal) * 0.5f) - 90f;\n        float slopeForce = Mathf.Sin(slopeAngle * Mathf.Deg2Rad) * _gravity;\n        \n        if (_playerOnBoard)\n        {\n            _currentSpeed += _acceleration * Time.fixedDeltaTime;\n        }\n        \n        _currentSpeed += slopeForce * _slopeSpeedMultiplier * Time.fixedDeltaTime;\n        \n        float resistanceForce = _friction + (_airResistance * _currentSpeed * _currentSpeed);\n        _currentSpeed -= resistanceForce * Time.fixedDeltaTime;\n        \n        _currentSpeed = Mathf.Clamp(_currentSpeed, -_maxSpeed, _maxSpeed);\n        \n        if (Mathf.Abs(_currentSpeed) < 0.1f)\n        {\n            _currentSpeed = 0f;\n            if (_isMoving)\n            {\n                _isMoving = false;\n                OnCartStop?.Invoke();\n            }\n        }\n        else\n        {\n            if (!_isMoving)\n            {\n                _isMoving = true;\n                OnCartStart?.Invoke();\n            }\n        }\n        \n        Vector3 velocity = _currentDirection * _currentSpeed;\n        _rigidbody.velocity = velocity;\n        \n        Vector3 averageTrackPoint = (_frontHit.point + _rearHit.point) * 0.5f;\n        Vector3 targetPosition = averageTrackPoint + Vector3.up * 0.5f;\n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.fixedDeltaTime * 10f);\n    }\n    \n    private void ApplyGravity()\n    {\n        _rigidbody.useGravity = true;\n        _currentSpeed = _rigidbody.velocity.magnitude;\n    }\n    \n    private void HandleDerailment()\n    {\n        _rigidbody.useGravity = true;\n        \n        if (_currentSpeed > 1f)\n        {\n            _currentSpeed -= _deceleration * Time.fixedDeltaTime;\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_isMoving && _currentSpeed > 0.1f)\n        {\n            if (!_audioSource.isPlaying)\n            {\n                _audioSource.Play();\n            }\n            \n            float normalizedSpeed = Mathf.InverseLerp(_minPitchSpeed, _maxPitchSpeed, _currentSpeed);\n            _audioSource.pitch = Mathf.Lerp(0.5f, 2f, normalizedSpeed);\n            _audioSource.volume = Mathf.Lerp(0.3f, 1f, normalizedSpeed);\n        }\n        else\n        {\n            if (_audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerOnBoard = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _playerOnBoard = false;\n        }\n    }\n    \n    public void ApplyBrake()\n    {\n        _currentSpeed *= 0.5f;\n        \n        if (_brakeSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_brakeSound);\n        }\n    }\n    \n    public void AddForce(float force)\n    {\n        _currentSpeed += force;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsOnTrack()\n    {\n        return _isOnTrack;\n    }\n    \n    public bool IsMoving()\n    {\n        return _isMoving;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_frontWheelPoint != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawRay(_frontWheelPoint.position, Vector3.down * _trackDetectionDistance);\n        }\n        \n        if (_rearWheelPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawRay(_rearWheelPoint.position, Vector3.down * _trackDetectionDistance);\n        }\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawRay(transform.position, _currentDirection * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpinningExploder\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"spinAcceleration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"maxSpinSpeed\",\n      \"type\": \"float\",\n      \"default\": 20.0\n    },\n    {\n      \"name\": \"currentSpinSpeed\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"explosionForce\",\n      \"type\": \"float\",\n      \"default\": 500.0\n    },\n    {\n      \"name\": \"pieceCount\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"piecePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionSounds\",\n      \"type\": \"AudioClip[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"baseVolume\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"maxVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"startColor\",\n      \"type\": \"Color\",\n      \"default\": \"blue\"\n    },\n    {\n      \"name\": \"endColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_spin_acceleration\",\n      \"trigger\": \"every frame while spinning speed is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"increase spinning speed by acceleration amount\"\n        },\n        {\n          \"action\": \"rotate object around vertical axis at current spinning speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"volume_increase_with_speed\",\n      \"trigger\": \"every frame while spinning speed changes\",\n      \"actions\": [\n        {\n          \"action\": \"calculate volume based on current speed relative to maximum speed\"\n        },\n        {\n          \"action\": \"set audio source volume to calculated volume between base and maximum\"\n        }\n      ]\n    },\n    {\n      \"name\": \"color_transition_during_spinup\",\n      \"trigger\": \"every frame while spinning speed is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"calculate color blend ratio based on current speed relative to maximum speed\"\n        },\n        {\n          \"action\": \"blend material color from start color to end color using calculated ratio\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explode_at_maximum_speed\",\n      \"trigger\": \"when spinning speed reaches or exceeds maximum speed\",\n      \"actions\": [\n        {\n          \"action\": \"stop spinning and audio\"\n        },\n        {\n          \"action\": \"create ten smaller piece objects at current position\"\n        },\n        {\n          \"action\": \"apply random explosive force to each piece in different directions\"\n        },\n        {\n          \"action\": \"assign unique random sound effect to each piece\"\n        },\n        {\n          \"action\": \"destroy original object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"piece_bouncing_behavior\",\n      \"trigger\": \"when piece object collides with any surface\",\n      \"actions\": [\n        {\n          \"action\": \"bounce off surface with physics\"\n        },\n        {\n          \"action\": \"play assigned unique sound effect\"\n        },\n        {\n          \"action\": \"apply small random force for continued random movement\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class SpinningExploder : MonoBehaviour\n{\n    [Header(\"Spin Settings\")]\n    [SerializeField] private float _maxSpinSpeed = 1000f;\n    [SerializeField] private float _spinAcceleration = 50f;\n    [SerializeField] private float _timeToMaxSpeed = 5f;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioClip _spinSound;\n    [SerializeField] private float _maxVolume = 1f;\n    [SerializeField] private AudioClip[] _explosionSounds;\n    \n    [Header(\"Explosion Settings\")]\n    [SerializeField] private int _fragmentCount = 10;\n    [SerializeField] private float _explosionForce = 500f;\n    [SerializeField] private float _fragmentLifetime = 5f;\n    [SerializeField] private GameObject _fragmentPrefab;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Color _startColor = Color.blue;\n    [SerializeField] private Color _endColor = Color.red;\n    \n    private float _currentSpinSpeed = 0f;\n    private float _spinTimer = 0f;\n    private bool _hasExploded = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Material _material;\n    private Color _originalColor;\n    \n    private void Start()\n    {\n        SetupComponents();\n        StartSpinning();\n    }\n    \n    private void SetupComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null)\n        {\n            _material = _renderer.material;\n            _originalColor = _material.color;\n        }\n        \n        if (_fragmentPrefab == null)\n        {\n            _fragmentPrefab = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            _fragmentPrefab.transform.localScale = Vector3.one * 0.3f;\n        }\n    }\n    \n    private void StartSpinning()\n    {\n        if (_spinSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _spinSound;\n            _audioSource.loop = true;\n            _audioSource.volume = 0f;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasExploded) return;\n        \n        UpdateSpin();\n        UpdateAudio();\n        UpdateColor();\n        \n        if (_spinTimer >= _timeToMaxSpeed)\n        {\n            Explode();\n        }\n    }\n    \n    private void UpdateSpin()\n    {\n        _spinTimer += Time.deltaTime;\n        float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n        _currentSpinSpeed = Mathf.Lerp(0f, _maxSpinSpeed, progress * progress);\n        \n        transform.Rotate(0f, _currentSpinSpeed * Time.deltaTime, 0f);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _spinSound != null)\n        {\n            float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n            _audioSource.volume = Mathf.Lerp(0f, _maxVolume, progress);\n            _audioSource.pitch = Mathf.Lerp(0.5f, 2f, progress);\n        }\n    }\n    \n    private void UpdateColor()\n    {\n        if (_material != null)\n        {\n            float progress = Mathf.Clamp01(_spinTimer / _timeToMaxSpeed);\n            Color currentColor = Color.Lerp(_startColor, _endColor, progress);\n            _material.color = currentColor;\n        }\n    }\n    \n    private void Explode()\n    {\n        _hasExploded = true;\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        CreateFragments();\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.enabled = false;\n        }\n        \n        StartCoroutine(DestroyAfterDelay(1f));\n    }\n    \n    private void CreateFragments()\n    {\n        for (int i = 0; i < _fragmentCount; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere.normalized;\n            Vector3 spawnPosition = transform.position + randomDirection * 0.5f;\n            \n            GameObject fragment = Instantiate(_fragmentPrefab, spawnPosition, Random.rotation);\n            \n            SetupFragment(fragment, randomDirection, i);\n        }\n    }\n    \n    private void SetupFragment(GameObject fragment, Vector3 direction, int index)\n    {\n        Rigidbody rb = fragment.GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            rb = fragment.AddComponent<Rigidbody>();\n        }\n        \n        rb.AddForce(direction * _explosionForce);\n        rb.AddTorque(Random.insideUnitSphere * _explosionForce * 0.1f);\n        \n        AudioSource fragmentAudio = fragment.GetComponent<AudioSource>();\n        if (fragmentAudio == null)\n        {\n            fragmentAudio = fragment.AddComponent<AudioSource>();\n        }\n        \n        if (_explosionSounds != null && _explosionSounds.Length > 0)\n        {\n            int soundIndex = index % _explosionSounds.Length;\n            if (_explosionSounds[soundIndex] != null)\n            {\n                fragmentAudio.clip = _explosionSounds[soundIndex];\n                fragmentAudio.volume = Random.Range(0.3f, 0.8f);\n                fragmentAudio.pitch = Random.Range(0.8f, 1.5f);\n                fragmentAudio.Play();\n            }\n        }\n        \n        FragmentBehavior fragmentBehavior = fragment.AddComponent<FragmentBehavior>();\n        fragmentBehavior.Initialize(_fragmentLifetime);\n        \n        Renderer fragmentRenderer = fragment.GetComponent<Renderer>();\n        if (fragmentRenderer != null)\n        {\n            fragmentRenderer.material.color = Random.ColorHSV();\n        }\n    }\n    \n    private IEnumerator DestroyAfterDelay(float delay)\n    {\n        yield return new WaitForSeconds(delay);\n        Destroy(gameObject);\n    }\n    \n    private void OnDestroy()\n    {\n        if (_material != null)\n        {\n            Destroy(_material);\n        }\n    }\n}\n\npublic class FragmentBehavior : MonoBehaviour\n{\n    private float _lifetime;\n    private float _timer;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    \n    public void Initialize(float lifetime)\n    {\n        _lifetime = lifetime;\n        _rigidbody = GetComponent<Rigidbody>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.drag = 0.5f;\n            _rigidbody.angularDrag = 0.5f;\n        }\n    }\n    \n    private void Update()\n    {\n        _timer += Time.deltaTime;\n        \n        if (_timer >= _lifetime)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        \n        float fadeProgress = _timer / _lifetime;\n        if (fadeProgress > 0.7f)\n        {\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Color color = renderer.material.color;\n                color.a = Mathf.Lerp(1f, 0f, (fadeProgress - 0.7f) / 0.3f);\n                renderer.material.color = color;\n            }\n            \n            if (_audioSource != null)\n            {\n                _audioSource.volume = Mathf.Lerp(_audioSource.volume, 0f, Time.deltaTime * 2f);\n            }\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 bounceDirection = Vector3.Reflect(_rigidbody.velocity.normalized, collision.contacts[0].normal);\n            _rigidbody.velocity = bounceDirection * _rigidbody.velocity.magnitude * 0.8f;\n        }\n        \n        if (_audioSource != null && _audioSource.clip != null)\n        {\n            _audioSource.pitch = Random.Range(0.8f, 1.5f);\n            _audioSource.PlayOneShot(_audioSource.clip, 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RareDropItem\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dropChance\",\n      \"type\": \"float\",\n      \"default\": 0.05\n    },\n    {\n      \"name\": \"sparkleIntensity\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"bobHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"bobSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 45.0\n    },\n    {\n      \"name\": \"magnetRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"magnetSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"despawnTime\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_with_sparkles\",\n      \"trigger\": \"when item spawns\",\n      \"actions\": [\n        {\n          \"action\": \"start sparkle particle effects\"\n        },\n        {\n          \"action\": \"play rare item spawn sound\"\n        },\n        {\n          \"action\": \"emit bright golden glow\"\n        },\n        {\n          \"action\": \"begin floating animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"floating_animation\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"bob up and down smoothly\"\n        },\n        {\n          \"action\": \"rotate slowly around vertical axis\"\n        },\n        {\n          \"action\": \"pulse sparkle effects rhythmically\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attract_to_player\",\n      \"trigger\": \"when player enters magnet range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player with increasing speed\"\n        },\n        {\n          \"action\": \"intensify sparkle effects\"\n        },\n        {\n          \"action\": \"play attraction sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_item\",\n      \"trigger\": \"when player touches item\",\n      \"actions\": [\n        {\n          \"action\": \"add item to player inventory\"\n        },\n        {\n          \"action\": \"burst sparkle explosion\"\n        },\n        {\n          \"action\": \"play collection sound\"\n        },\n        {\n          \"action\": \"show rare item notification\"\n        },\n        {\n          \"action\": \"destroy item object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"despawn_timer\",\n      \"trigger\": \"after despawn time elapses without collection\",\n      \"actions\": [\n        {\n          \"action\": \"fade out sparkle effects\"\n        },\n        {\n          \"action\": \"gradually reduce glow intensity\"\n        },\n        {\n          \"action\": \"destroy item object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class RareDrop : MonoBehaviour\n{\n    [Header(\"Drop Settings\")]\n    [SerializeField] private float _magnetRange = 5f;\n    [SerializeField] private float _magnetSpeed = 8f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _rotationSpeed = 90f;\n    [SerializeField] private float _despawnTime = 30f;\n    \n    [Header(\"Sparkle Effects\")]\n    [SerializeField] private GameObject _sparklePrefab;\n    [SerializeField] private int _sparkleCount = 8;\n    [SerializeField] private float _sparkleRadius = 1.5f;\n    [SerializeField] private float _sparkleSpeed = 2f;\n    [SerializeField] private float _sparkleLifetime = 1f;\n    [SerializeField] private Color _sparkleColor = Color.yellow;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private AudioClip _spawnSound;\n    \n    private Vector3 _startPosition;\n    private bool _isBeingMagneted = false;\n    private Transform _playerTransform;\n    private AudioSource _audioSource;\n    private float _bobTimer;\n    private Coroutine _sparkleCoroutine;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_spawnSound != null)\n        {\n            _audioSource.PlayOneShot(_spawnSound);\n        }\n        \n        _sparkleCoroutine = StartCoroutine(SparkleEffect());\n        \n        Destroy(gameObject, _despawnTime);\n    }\n    \n    private void Update()\n    {\n        HandleBobbing();\n        HandleRotation();\n        CheckForPlayer();\n        \n        if (_isBeingMagneted && _playerTransform != null)\n        {\n            MoveTowardsPlayer();\n        }\n    }\n    \n    private void HandleBobbing()\n    {\n        if (!_isBeingMagneted)\n        {\n            _bobTimer += Time.deltaTime * _bobSpeed;\n            Vector3 newPosition = _startPosition;\n            newPosition.y += Mathf.Sin(_bobTimer) * _bobHeight;\n            transform.position = newPosition;\n        }\n    }\n    \n    private void HandleRotation()\n    {\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_isBeingMagneted) return;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _magnetRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _playerTransform = col.transform;\n                _isBeingMagneted = true;\n                break;\n            }\n        }\n    }\n    \n    private void MoveTowardsPlayer()\n    {\n        if (_playerTransform == null) return;\n        \n        Vector3 direction = (_playerTransform.position - transform.position).normalized;\n        transform.position += direction * _magnetSpeed * Time.deltaTime;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            CollectDrop();\n        }\n    }\n    \n    private void CollectDrop()\n    {\n        if (_pickupSound != null)\n        {\n            _audioSource.PlayOneShot(_pickupSound);\n        }\n        \n        CreatePickupEffect();\n        \n        if (_sparkleCoroutine != null)\n        {\n            StopCoroutine(_sparkleCoroutine);\n        }\n        \n        GetComponent<Renderer>().enabled = false;\n        GetComponent<Collider>().enabled = false;\n        \n        Destroy(gameObject, _pickupSound != null ? _pickupSound.length : 0.1f);\n    }\n    \n    private void CreatePickupEffect()\n    {\n        for (int i = 0; i < _sparkleCount * 2; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere;\n            Vector3 spawnPosition = transform.position + randomDirection * 0.5f;\n            \n            GameObject sparkle = CreateSparkle(spawnPosition);\n            if (sparkle != null)\n            {\n                Rigidbody rb = sparkle.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    rb.velocity = randomDirection * _sparkleSpeed * 2f;\n                }\n                \n                Destroy(sparkle, _sparkleLifetime);\n            }\n        }\n    }\n    \n    private IEnumerator SparkleEffect()\n    {\n        while (true)\n        {\n            for (int i = 0; i < _sparkleCount; i++)\n            {\n                float angle = (360f / _sparkleCount) * i;\n                float radian = angle * Mathf.Deg2Rad;\n                \n                Vector3 offset = new Vector3(\n                    Mathf.Cos(radian) * _sparkleRadius,\n                    Random.Range(-0.5f, 0.5f),\n                    Mathf.Sin(radian) * _sparkleRadius\n                );\n                \n                Vector3 sparklePosition = transform.position + offset;\n                GameObject sparkle = CreateSparkle(sparklePosition);\n                \n                if (sparkle != null)\n                {\n                    StartCoroutine(AnimateSparkle(sparkle));\n                }\n            }\n            \n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n    \n    private GameObject CreateSparkle(Vector3 position)\n    {\n        GameObject sparkle;\n        \n        if (_sparklePrefab != null)\n        {\n            sparkle = Instantiate(_sparklePrefab, position, Quaternion.identity);\n        }\n        else\n        {\n            sparkle = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            sparkle.transform.position = position;\n            sparkle.transform.localScale = Vector3.one * 0.1f;\n            \n            Renderer renderer = sparkle.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Material material = new Material(Shader.Find(\"Standard\"));\n                material.color = _sparkleColor;\n                material.SetFloat(\"_Metallic\", 1f);\n                material.SetFloat(\"_Smoothness\", 1f);\n                renderer.material = material;\n            }\n            \n            Destroy(sparkle.GetComponent<Collider>());\n            \n            Rigidbody rb = sparkle.AddComponent<Rigidbody>();\n            rb.useGravity = false;\n            rb.drag = 2f;\n        }\n        \n        return sparkle;\n    }\n    \n    private IEnumerator AnimateSparkle(GameObject sparkle)\n    {\n        if (sparkle == null) yield break;\n        \n        Vector3 startScale = sparkle.transform.localScale;\n        float timer = 0f;\n        \n        while (timer < _sparkleLifetime && sparkle != null)\n        {\n            timer += Time.deltaTime;\n            float progress = timer / _sparkleLifetime;\n            \n            float scale = Mathf.Lerp(1f, 0f, progress);\n            sparkle.transform.localScale = startScale * scale;\n            \n            sparkle.transform.Rotate(Vector3.up, 360f * Time.deltaTime);\n            \n            Renderer renderer = sparkle.GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                Color color = renderer.material.color;\n                color.a = Mathf.Lerp(1f, 0f, progress);\n                renderer.material.color = color;\n            }\n            \n            yield return null;\n        }\n        \n        if (sparkle != null)\n        {\n            Destroy(sparkle);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _magnetRange);\n        \n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _sparkleRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Zipline\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"startPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"endPoint\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"travelSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"ziplineSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"arrivalSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_zipline\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"draw line between start point and end point\"\n        },\n        {\n          \"action\": \"position zipline cable visually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_zipline\",\n      \"trigger\": \"when player interacts with zipline and zipline is active\",\n      \"actions\": [\n        {\n          \"action\": \"attach player to zipline\"\n        },\n        {\n          \"action\": \"disable player movement controls\"\n        },\n        {\n          \"action\": \"play zipline sound effect\"\n        },\n        {\n          \"action\": \"start moving player toward end point at travel speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"travel_along_zipline\",\n      \"trigger\": \"while player is attached to zipline\",\n      \"actions\": [\n        {\n          \"action\": \"move player smoothly along zipline path\"\n        },\n        {\n          \"action\": \"maintain player orientation facing forward\"\n        },\n        {\n          \"action\": \"continue playing zipline sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_zipline_travel\",\n      \"trigger\": \"when player reaches end point of zipline\",\n      \"actions\": [\n        {\n          \"action\": \"detach player from zipline\"\n        },\n        {\n          \"action\": \"restore player movement controls\"\n        },\n        {\n          \"action\": \"stop zipline sound effect\"\n        },\n        {\n          \"action\": \"play arrival sound effect\"\n        },\n        {\n          \"action\": \"position player at end point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_interaction_prompt\",\n      \"trigger\": \"when player is near start point and zipline is active\",\n      \"actions\": [\n        {\n          \"action\": \"display use zipline prompt to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_interaction_prompt\",\n      \"trigger\": \"when player moves away from start point\",\n      \"actions\": [\n        {\n          \"action\": \"hide use zipline prompt\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Zipline : MonoBehaviour\n{\n    [System.Serializable]\n    public class ZiplineEvents\n    {\n        public UnityEvent OnPlayerAttach;\n        public UnityEvent OnPlayerDetach;\n        public UnityEvent OnZiplineComplete;\n    }\n\n    [Header(\"Zipline Configuration\")]\n    [SerializeField] private Transform _startPoint;\n    [SerializeField] private Transform _endPoint;\n    [SerializeField] private float _travelSpeed = 10f;\n    [SerializeField] private float _attachDistance = 2f;\n    [SerializeField] private bool _autoDetach = true;\n    [SerializeField] private float _detachDistance = 1f;\n\n    [Header(\"Player Control\")]\n    [SerializeField] private KeyCode _attachKey = KeyCode.E;\n    [SerializeField] private KeyCode _detachKey = KeyCode.Space;\n    [SerializeField] private bool _requireKeyToAttach = true;\n    [SerializeField] private bool _allowEarlyDetach = true;\n\n    [Header(\"Physics\")]\n    [SerializeField] private bool _disablePlayerGravity = true;\n    [SerializeField] private bool _disablePlayerMovement = true;\n    [SerializeField] private Vector3 _playerOffset = Vector3.zero;\n\n    [Header(\"Visual\")]\n    [SerializeField] private LineRenderer _ziplineRenderer;\n    [SerializeField] private GameObject _handlePrefab;\n    [SerializeField] private bool _createVisualHandle = true;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _attachSound;\n    [SerializeField] private AudioClip _travelSound;\n    [SerializeField] private AudioClip _detachSound;\n\n    [Header(\"Events\")]\n    [SerializeField] private ZiplineEvents _events;\n\n    private Transform _attachedPlayer;\n    private Rigidbody _playerRigidbody;\n    private CharacterController _playerController;\n    private bool _isPlayerAttached;\n    private float _travelProgress;\n    private Vector3 _originalGravity;\n    private bool _wasKinematic;\n    private GameObject _visualHandle;\n    private Transform _nearbyPlayer;\n\n    private void Start()\n    {\n        InitializeZipline();\n    }\n\n    private void InitializeZipline()\n    {\n        if (_startPoint == null)\n        {\n            GameObject startObj = new GameObject(\"ZiplineStart\");\n            startObj.transform.SetParent(transform);\n            startObj.transform.localPosition = Vector3.zero;\n            _startPoint = startObj.transform;\n        }\n\n        if (_endPoint == null)\n        {\n            GameObject endObj = new GameObject(\"ZiplineEnd\");\n            endObj.transform.SetParent(transform);\n            endObj.transform.localPosition = new Vector3(10f, -5f, 0f);\n            _endPoint = endObj.transform;\n        }\n\n        SetupVisuals();\n        SetupAudio();\n    }\n\n    private void SetupVisuals()\n    {\n        if (_ziplineRenderer == null)\n        {\n            _ziplineRenderer = GetComponent<LineRenderer>();\n            if (_ziplineRenderer == null)\n            {\n                _ziplineRenderer = gameObject.AddComponent<LineRenderer>();\n            }\n        }\n\n        if (_ziplineRenderer != null)\n        {\n            _ziplineRenderer.positionCount = 2;\n            _ziplineRenderer.startWidth = 0.05f;\n            _ziplineRenderer.endWidth = 0.05f;\n            _ziplineRenderer.material = Resources.Load<Material>(\"Default-Material\");\n            UpdateZiplineVisual();\n        }\n\n        if (_createVisualHandle && _handlePrefab != null && _visualHandle == null)\n        {\n            _visualHandle = Instantiate(_handlePrefab, _startPoint.position, Quaternion.identity);\n            _visualHandle.transform.SetParent(transform);\n        }\n    }\n\n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n\n        if (_audioSource != null)\n        {\n            _audioSource.playOnAwake = false;\n            _audioSource.spatialBlend = 1f;\n        }\n    }\n\n    private void Update()\n    {\n        UpdateZiplineVisual();\n        CheckForNearbyPlayer();\n        HandlePlayerInput();\n        \n        if (_isPlayerAttached)\n        {\n            UpdatePlayerMovement();\n        }\n    }\n\n    private void UpdateZiplineVisual()\n    {\n        if (_ziplineRenderer != null && _startPoint != null && _endPoint != null)\n        {\n            _ziplineRenderer.SetPosition(0, _startPoint.position);\n            _ziplineRenderer.SetPosition(1, _endPoint.position);\n        }\n    }\n\n    private void CheckForNearbyPlayer()\n    {\n        if (_isPlayerAttached) return;\n\n        Collider[] nearbyColliders = Physics.OverlapSphere(_startPoint.position, _attachDistance);\n        _nearbyPlayer = null;\n\n        foreach (Collider col in nearbyColliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                _nearbyPlayer = col.transform;\n                break;\n            }\n        }\n    }\n\n    private void HandlePlayerInput()\n    {\n        if (_nearbyPlayer != null && !_isPlayerAttached)\n        {\n            if (!_requireKeyToAttach || Input.GetKeyDown(_attachKey))\n            {\n                AttachPlayer(_nearbyPlayer);\n            }\n        }\n        else if (_isPlayerAttached && _allowEarlyDetach && Input.GetKeyDown(_detachKey))\n        {\n            DetachPlayer();\n        }\n    }\n\n    private void AttachPlayer(Transform player)\n    {\n        _attachedPlayer = player;\n        _playerRigidbody = player.GetComponent<Rigidbody>();\n        _playerController = player.GetComponent<CharacterController>();\n        _isPlayerAttached = true;\n        _travelProgress = 0f;\n\n        if (_playerRigidbody != null)\n        {\n            _wasKinematic = _playerRigidbody.isKinematic;\n            if (_disablePlayerGravity)\n            {\n                _playerRigidbody.useGravity = false;\n            }\n            if (_disablePlayerMovement)\n            {\n                _playerRigidbody.isKinematic = true;\n            }\n        }\n\n        if (_playerController != null && _disablePlayerMovement)\n        {\n            _playerController.enabled = false;\n        }\n\n        PlaySound(_attachSound);\n        _events?.OnPlayerAttach?.Invoke();\n\n        if (_travelSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _travelSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void UpdatePlayerMovement()\n    {\n        if (_attachedPlayer == null) return;\n\n        _travelProgress += _travelSpeed * Time.deltaTime / Vector3.Distance(_startPoint.position, _endPoint.position);\n        _travelProgress = Mathf.Clamp01(_travelProgress);\n\n        Vector3 targetPosition = Vector3.Lerp(_startPoint.position, _endPoint.position, _travelProgress) + _playerOffset;\n        \n        if (_playerController != null && !_playerController.enabled)\n        {\n            _attachedPlayer.position = targetPosition;\n        }\n        else if (_playerRigidbody != null)\n        {\n            _playerRigidbody.MovePosition(targetPosition);\n        }\n        else\n        {\n            _attachedPlayer.position = targetPosition;\n        }\n\n        Vector3 direction = (_endPoint.position - _startPoint.position).normalized;\n        if (direction != Vector3.zero)\n        {\n            _attachedPlayer.rotation = Quaternion.LookRotation(direction);\n        }\n\n        if (_visualHandle != null)\n        {\n            _visualHandle.transform.position = targetPosition;\n        }\n\n        if (_autoDetach && Vector3.Distance(_attachedPlayer.position, _endPoint.position) <= _detachDistance)\n        {\n            DetachPlayer();\n            _events?.OnZiplineComplete?.Invoke();\n        }\n    }\n\n    private void DetachPlayer()\n    {\n        if (!_isPlayerAttached || _attachedPlayer == null) return;\n\n        if (_playerRigidbody != null)\n        {\n            _playerRigidbody.isKinematic = _wasKinematic;\n            if (_disablePlayerGravity)\n            {\n                _playerRigidbody.useGravity = true;\n            }\n        }\n\n        if (_playerController != null && !_playerController.enabled)\n        {\n            _playerController.enabled = true;\n        }\n\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n\n        PlaySound(_detachSound);\n        _events?.OnPlayerDetach?.Invoke();\n\n        _attachedPlayer = null;\n        _playerRigidbody = null;\n        _playerController = null;\n        _isPlayerAttached = false;\n        _travelProgress = 0f;\n\n        if (_visualHandle != null)\n        {\n            _visualHandle.transform.position = _startPoint.position;\n        }\n    }\n\n    private void PlaySound(AudioClip clip)\n    {\n        if (clip != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_requireKeyToAttach && other.CompareTag(\"Player\") && !_isPlayerAttached)\n        {\n            AttachPlayer(other.transform);\n        }\n    }\n\n    private void OnDrawGizmos()\n    {\n        if (_startPoint != null && _endPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawLine(_startPoint.position, _endPoint.position);\n            \n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_startPoint.position, _attachDistance);\n            \n            Gizmos.color = Color.red;\n            Gizmos.DrawWireSphere(_endPoint.position, _detachDistance);\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        if (_startPoint != null)\n        {\n            Gizmos.color = Color.cyan;\n            Gizmos.DrawWireCube(_startPoint.position, Vector3.one * 0.5f);\n        }\n        \n        if (_endPoint != null)\n        {\n            Gizmos.color = Color.magenta;\n            Gizmos.DrawWireCube(_endPoint.position, Vector3.one * 0.5f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParryReflector\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"parryWindow\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"reflectionForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"parryActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_parry\",\n      \"trigger\": \"when parry input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"set parry state to active\"\n        },\n        {\n          \"action\": \"start parry window timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_parry\",\n      \"trigger\": \"when parry window timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"set parry state to inactive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reflect_attack\",\n      \"trigger\": \"when attack collides during active parry window\",\n      \"actions\": [\n        {\n          \"action\": \"reverse attack direction\"\n        },\n        {\n          \"action\": \"apply reflection force to attacking object\"\n        },\n        {\n          \"action\": \"redirect attack back toward attacker\"\n        },\n        {\n          \"action\": \"deactivate parry state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"parry_feedback\",\n      \"trigger\": \"when attack is successfully reflected\",\n      \"actions\": [\n        {\n          \"action\": \"play parry sound effect\"\n        },\n        {\n          \"action\": \"show visual parry effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ParrySystem : MonoBehaviour\n{\n    [Header(\"Parry Settings\")]\n    [SerializeField] private float _parryWindow = 0.5f;\n    [SerializeField] private float _parryCooldown = 1f;\n    [SerializeField] private KeyCode _parryKey = KeyCode.Q;\n    [SerializeField] private float _reflectionForce = 20f;\n    [SerializeField] private LayerMask _projectileLayer = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _parryEffectPrefab;\n    [SerializeField] private float _effectDuration = 0.3f;\n    [SerializeField] private Color _parryColor = Color.cyan;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _parrySound;\n    [SerializeField] private AudioClip _reflectSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnParryActivated;\n    public UnityEvent OnSuccessfulParry;\n    public UnityEvent OnParryFailed;\n    \n    private bool _isParrying = false;\n    private bool _canParry = true;\n    private float _parryTimer = 0f;\n    private AudioSource _audioSource;\n    private SpriteRenderer _spriteRenderer;\n    private Color _originalColor;\n    private Collider2D _collider;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        if (_spriteRenderer != null)\n            _originalColor = _spriteRenderer.color;\n            \n        _collider = GetComponent<Collider2D>();\n        if (_collider == null)\n            _collider = gameObject.AddComponent<CircleCollider2D>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateParryState();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_parryKey) && _canParry)\n        {\n            StartParry();\n        }\n    }\n    \n    private void UpdateParryState()\n    {\n        if (_isParrying)\n        {\n            _parryTimer -= Time.deltaTime;\n            if (_parryTimer <= 0f)\n            {\n                EndParry();\n            }\n        }\n    }\n    \n    private void StartParry()\n    {\n        _isParrying = true;\n        _parryTimer = _parryWindow;\n        \n        if (_spriteRenderer != null)\n            _spriteRenderer.color = _parryColor;\n            \n        if (_parryEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_parryEffectPrefab, transform.position, transform.rotation);\n            Destroy(effect, _effectDuration);\n        }\n        \n        if (_parrySound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_parrySound);\n            \n        OnParryActivated?.Invoke();\n        \n        StartCoroutine(ParryCooldownCoroutine());\n    }\n    \n    private void EndParry()\n    {\n        _isParrying = false;\n        \n        if (_spriteRenderer != null)\n            _spriteRenderer.color = _originalColor;\n    }\n    \n    private IEnumerator ParryCooldownCoroutine()\n    {\n        _canParry = false;\n        yield return new WaitForSeconds(_parryCooldown);\n        _canParry = true;\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (_isParrying && IsProjectile(other))\n        {\n            ReflectProjectile(other);\n        }\n    }\n    \n    private bool IsProjectile(Collider2D other)\n    {\n        return (_projectileLayer.value & (1 << other.gameObject.layer)) > 0 ||\n               other.CompareTag(\"Projectile\") ||\n               other.GetComponent<Rigidbody2D>() != null;\n    }\n    \n    private void ReflectProjectile(Collider2D projectile)\n    {\n        Rigidbody2D projectileRb = projectile.GetComponent<Rigidbody2D>();\n        if (projectileRb == null)\n            projectileRb = projectile.gameObject.AddComponent<Rigidbody2D>();\n            \n        Vector2 reflectionDirection = CalculateReflectionDirection(projectile.transform.position);\n        projectileRb.velocity = reflectionDirection * _reflectionForce;\n        \n        // Change projectile ownership/layer to avoid hitting player\n        if (projectile.gameObject.layer != LayerMask.NameToLayer(\"PlayerProjectile\"))\n        {\n            projectile.gameObject.layer = LayerMask.NameToLayer(\"PlayerProjectile\");\n        }\n        \n        // Flip projectile tag if it exists\n        if (projectile.CompareTag(\"EnemyProjectile\"))\n            projectile.tag = \"PlayerProjectile\";\n            \n        if (_reflectSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_reflectSound);\n            \n        OnSuccessfulParry?.Invoke();\n        \n        // Add visual effect at reflection point\n        if (_parryEffectPrefab != null)\n        {\n            GameObject reflectEffect = Instantiate(_parryEffectPrefab, projectile.transform.position, Quaternion.identity);\n            Destroy(reflectEffect, _effectDuration);\n        }\n    }\n    \n    private Vector2 CalculateReflectionDirection(Vector3 projectilePosition)\n    {\n        Vector2 incomingDirection = (projectilePosition - transform.position).normalized;\n        Vector2 normal = -incomingDirection;\n        Vector2 reflectedDirection = Vector2.Reflect(incomingDirection, normal);\n        \n        return reflectedDirection;\n    }\n    \n    public bool IsCurrentlyParrying()\n    {\n        return _isParrying;\n    }\n    \n    public bool CanParry()\n    {\n        return _canParry;\n    }\n    \n    public float GetParryTimeRemaining()\n    {\n        return _isParrying ? _parryTimer : 0f;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_isParrying)\n        {\n            Gizmos.color = _parryColor;\n            Gizmos.DrawWireSphere(transform.position, 1f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Mirror\",\n  \"components\": [\n    \"MeshRenderer\",\n    \"MeshCollider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"reflectionIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"reflectionQuality\",\n      \"type\": \"int\",\n      \"default\": 512\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"create_reflection\",\n      \"trigger\": \"when camera approaches mirror\",\n      \"actions\": [\n        {\n          \"action\": \"create reflection camera that mirrors main camera position and rotation\"\n        },\n        {\n          \"action\": \"render scene from reflection camera perspective\"\n        },\n        {\n          \"action\": \"apply rendered image to mirror surface as texture\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_reflection\",\n      \"trigger\": \"every frame while camera is near\",\n      \"actions\": [\n        {\n          \"action\": \"update reflection camera to match main camera movement\"\n        },\n        {\n          \"action\": \"flip reflection camera orientation across mirror plane\"\n        },\n        {\n          \"action\": \"refresh reflection texture on mirror surface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"optimize_reflection\",\n      \"trigger\": \"when camera moves far from mirror\",\n      \"actions\": [\n        {\n          \"action\": \"disable reflection rendering to save performance\"\n        },\n        {\n          \"action\": \"show static reflection texture or disable reflection entirely\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Rendering;\n\npublic class Mirror : MonoBehaviour\n{\n    [Header(\"Mirror Settings\")]\n    [SerializeField] private Camera _mirrorCamera;\n    [SerializeField] private RenderTexture _mirrorTexture;\n    [SerializeField] private Material _mirrorMaterial;\n    [SerializeField] private int _textureSize = 512;\n    [SerializeField] private LayerMask _reflectionLayers = -1;\n    [SerializeField] private bool _disablePixelLights = true;\n    [SerializeField] private float _clipPlaneOffset = 0.07f;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private bool _useOcclusionCulling = true;\n    [SerializeField] private float _maxRenderDistance = 100f;\n    [SerializeField] private int _maxReflectionFPS = 30;\n    \n    private Camera _mainCamera;\n    private float _lastRenderTime;\n    private Vector4 _reflectionPlane;\n    private Matrix4x4 _reflectionMatrix;\n    private bool _isRendering;\n\n    void Start()\n    {\n        SetupMirror();\n    }\n\n    void Update()\n    {\n        if (_mainCamera == null)\n            _mainCamera = Camera.main;\n            \n        if (_mainCamera != null && ShouldRender())\n        {\n            RenderMirror();\n        }\n    }\n\n    void SetupMirror()\n    {\n        if (_mirrorTexture == null)\n        {\n            _mirrorTexture = new RenderTexture(_textureSize, _textureSize, 16, RenderTextureFormat.ARGB32);\n            _mirrorTexture.name = \"MirrorTexture_\" + GetInstanceID();\n            _mirrorTexture.isPowerOfTwo = true;\n            _mirrorTexture.hideFlags = HideFlags.DontSave;\n        }\n\n        if (_mirrorCamera == null)\n        {\n            GameObject cameraObject = new GameObject(\"MirrorCamera_\" + GetInstanceID());\n            cameraObject.transform.SetParent(transform);\n            _mirrorCamera = cameraObject.AddComponent<Camera>();\n            _mirrorCamera.enabled = false;\n            _mirrorCamera.targetTexture = _mirrorTexture;\n        }\n\n        if (_mirrorMaterial == null)\n        {\n            Renderer renderer = GetComponent<Renderer>();\n            if (renderer != null)\n            {\n                _mirrorMaterial = renderer.material;\n            }\n        }\n\n        if (_mirrorMaterial != null)\n        {\n            _mirrorMaterial.mainTexture = _mirrorTexture;\n        }\n\n        CalculateReflectionPlane();\n    }\n\n    bool ShouldRender()\n    {\n        if (_isRendering || _mainCamera == null || _mirrorCamera == null)\n            return false;\n\n        float distance = Vector3.Distance(_mainCamera.transform.position, transform.position);\n        if (distance > _maxRenderDistance)\n            return false;\n\n        float timeSinceLastRender = Time.time - _lastRenderTime;\n        float minInterval = 1f / _maxReflectionFPS;\n        \n        return timeSinceLastRender >= minInterval;\n    }\n\n    void RenderMirror()\n    {\n        _isRendering = true;\n        _lastRenderTime = Time.time;\n\n        Vector3 cameraPosition = _mainCamera.transform.position;\n        Vector3 cameraDirection = _mainCamera.transform.forward;\n\n        Vector3 reflectedPosition = ReflectPosition(cameraPosition);\n        Vector3 reflectedDirection = ReflectDirection(cameraDirection);\n\n        _mirrorCamera.transform.position = reflectedPosition;\n        _mirrorCamera.transform.LookAt(reflectedPosition + reflectedDirection, Vector3.up);\n\n        _mirrorCamera.fieldOfView = _mainCamera.fieldOfView;\n        _mirrorCamera.aspect = _mainCamera.aspect;\n        _mirrorCamera.nearClipPlane = _mainCamera.nearClipPlane;\n        _mirrorCamera.farClipPlane = _mainCamera.farClipPlane;\n        _mirrorCamera.cullingMask = _reflectionLayers;\n        _mirrorCamera.useOcclusionCulling = _useOcclusionCulling;\n\n        if (_disablePixelLights)\n            _mirrorCamera.renderingPath = RenderingPath.VertexLit;\n\n        SetupClipPlane();\n\n        GL.invertCulling = true;\n        _mirrorCamera.Render();\n        GL.invertCulling = false;\n\n        _isRendering = false;\n    }\n\n    void CalculateReflectionPlane()\n    {\n        Vector3 normal = transform.up;\n        Vector3 position = transform.position;\n        float distance = -Vector3.Dot(normal, position);\n        _reflectionPlane = new Vector4(normal.x, normal.y, normal.z, distance);\n    }\n\n    Vector3 ReflectPosition(Vector3 position)\n    {\n        Vector3 normal = new Vector3(_reflectionPlane.x, _reflectionPlane.y, _reflectionPlane.z);\n        float distance = Vector3.Dot(normal, position) + _reflectionPlane.w;\n        return position - 2f * distance * normal;\n    }\n\n    Vector3 ReflectDirection(Vector3 direction)\n    {\n        Vector3 normal = new Vector3(_reflectionPlane.x, _reflectionPlane.y, _reflectionPlane.z);\n        return Vector3.Reflect(direction, normal);\n    }\n\n    void SetupClipPlane()\n    {\n        Vector3 normal = transform.up;\n        Vector3 position = transform.position + normal * _clipPlaneOffset;\n        \n        Vector4 clipPlane = new Vector4(normal.x, normal.y, normal.z, -Vector3.Dot(position, normal));\n        \n        Matrix4x4 projection = _mirrorCamera.CalculateObliqueMatrix(clipPlane);\n        _mirrorCamera.projectionMatrix = projection;\n    }\n\n    void OnValidate()\n    {\n        if (_textureSize < 64) _textureSize = 64;\n        if (_textureSize > 2048) _textureSize = 2048;\n        if (_maxReflectionFPS < 1) _maxReflectionFPS = 1;\n        if (_maxReflectionFPS > 60) _maxReflectionFPS = 60;\n    }\n\n    void OnDestroy()\n    {\n        if (_mirrorTexture != null)\n        {\n            DestroyImmediate(_mirrorTexture);\n        }\n        \n        if (_mirrorCamera != null)\n        {\n            DestroyImmediate(_mirrorCamera.gameObject);\n        }\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawRay(Vector3.zero, Vector3.up * 2f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExtendingBridge\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"extensionSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"maxLength\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"isExtending\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentLength\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_extending\",\n      \"trigger\": \"when player approaches bridge activation area\",\n      \"actions\": [\n        {\n          \"action\": \"begin extending the bridge forward\"\n        },\n        {\n          \"action\": \"play bridge extension sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"extend_bridge\",\n      \"trigger\": \"while bridge is extending and has not reached maximum length\",\n      \"actions\": [\n        {\n          \"action\": \"increase bridge length gradually\"\n        },\n        {\n          \"action\": \"update bridge visual appearance to show extension\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_extending\",\n      \"trigger\": \"when bridge reaches maximum length\",\n      \"actions\": [\n        {\n          \"action\": \"stop bridge extension\"\n        },\n        {\n          \"action\": \"play bridge completion sound\"\n        },\n        {\n          \"action\": \"make bridge solid and walkable\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ExtendingBridge : MonoBehaviour\n{\n    [Header(\"Bridge Settings\")]\n    [SerializeField] private Transform _bridgeSegment;\n    [SerializeField] private float _extendDistance = 10f;\n    [SerializeField] private float _extendSpeed = 2f;\n    [SerializeField] private bool _autoExtend = false;\n    [SerializeField] private float _autoExtendDelay = 1f;\n    \n    [Header(\"Trigger Settings\")]\n    [SerializeField] private bool _usePlayerTrigger = true;\n    [SerializeField] private string _playerTag = \"Player\";\n    [SerializeField] private KeyCode _manualExtendKey = KeyCode.E;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _extendSound;\n    [SerializeField] private AudioClip _retractSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnBridgeExtended;\n    public UnityEvent OnBridgeRetracted;\n    public UnityEvent OnExtensionComplete;\n    \n    private Vector3 _originalPosition;\n    private Vector3 _extendedPosition;\n    private bool _isExtended = false;\n    private bool _isExtending = false;\n    private bool _isRetracting = false;\n    private bool _playerInRange = false;\n    private Coroutine _autoExtendCoroutine;\n    \n    private void Start()\n    {\n        if (_bridgeSegment == null)\n            _bridgeSegment = transform;\n            \n        _originalPosition = _bridgeSegment.position;\n        _extendedPosition = _originalPosition + _bridgeSegment.forward * _extendDistance;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_autoExtend)\n        {\n            _autoExtendCoroutine = StartCoroutine(AutoExtendCoroutine());\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_autoExtend)\n        {\n            HandleManualInput();\n        }\n        \n        HandleBridgeMovement();\n    }\n    \n    private void HandleManualInput()\n    {\n        bool shouldExtend = false;\n        \n        if (_usePlayerTrigger && _playerInRange && Input.GetKeyDown(_manualExtendKey))\n        {\n            shouldExtend = true;\n        }\n        else if (!_usePlayerTrigger && Input.GetKeyDown(_manualExtendKey))\n        {\n            shouldExtend = true;\n        }\n        \n        if (shouldExtend)\n        {\n            if (!_isExtended && !_isExtending)\n            {\n                ExtendBridge();\n            }\n            else if (_isExtended && !_isRetracting)\n            {\n                RetractBridge();\n            }\n        }\n    }\n    \n    private void HandleBridgeMovement()\n    {\n        if (_isExtending)\n        {\n            _bridgeSegment.position = Vector3.MoveTowards(_bridgeSegment.position, _extendedPosition, _extendSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(_bridgeSegment.position, _extendedPosition) < 0.01f)\n            {\n                _bridgeSegment.position = _extendedPosition;\n                _isExtending = false;\n                _isExtended = true;\n                OnExtensionComplete?.Invoke();\n            }\n        }\n        else if (_isRetracting)\n        {\n            _bridgeSegment.position = Vector3.MoveTowards(_bridgeSegment.position, _originalPosition, _extendSpeed * Time.deltaTime);\n            \n            if (Vector3.Distance(_bridgeSegment.position, _originalPosition) < 0.01f)\n            {\n                _bridgeSegment.position = _originalPosition;\n                _isRetracting = false;\n                _isExtended = false;\n                OnExtensionComplete?.Invoke();\n            }\n        }\n    }\n    \n    public void ExtendBridge()\n    {\n        if (_isExtended || _isExtending) return;\n        \n        _isExtending = true;\n        OnBridgeExtended?.Invoke();\n        \n        if (_audioSource != null && _extendSound != null)\n        {\n            _audioSource.PlayOneShot(_extendSound);\n        }\n    }\n    \n    public void RetractBridge()\n    {\n        if (!_isExtended || _isRetracting) return;\n        \n        _isRetracting = true;\n        OnBridgeRetracted?.Invoke();\n        \n        if (_audioSource != null && _retractSound != null)\n        {\n            _audioSource.PlayOneShot(_retractSound);\n        }\n    }\n    \n    public void ToggleBridge()\n    {\n        if (_isExtended || _isRetracting)\n        {\n            RetractBridge();\n        }\n        else if (!_isExtended || _isExtending)\n        {\n            ExtendBridge();\n        }\n    }\n    \n    private System.Collections.IEnumerator AutoExtendCoroutine()\n    {\n        yield return new WaitForSeconds(_autoExtendDelay);\n        ExtendBridge();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_usePlayerTrigger && other.CompareTag(_playerTag))\n        {\n            _playerInRange = true;\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_usePlayerTrigger && other.CompareTag(_playerTag))\n        {\n            _playerInRange = false;\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_bridgeSegment == null) return;\n        \n        Vector3 startPos = Application.isPlaying ? _originalPosition : _bridgeSegment.position;\n        Vector3 endPos = startPos + _bridgeSegment.forward * _extendDistance;\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawLine(startPos, endPos);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireCube(endPos, Vector3.one * 0.5f);\n    }\n    \n    public bool IsExtended => _isExtended;\n    public bool IsMoving => _isExtending || _isRetracting;\n    public float ExtensionProgress\n    {\n        get\n        {\n            if (_bridgeSegment == null) return 0f;\n            float totalDistance = Vector3.Distance(_originalPosition, _extendedPosition);\n            float currentDistance = Vector3.Distance(_originalPosition, _bridgeSegment.position);\n            return Mathf.Clamp01(currentDistance / totalDistance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SidewaysCrab\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody2D\",\n    \"Collider2D\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"changeDirectionTime\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"movingRight\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"sideways_movement\",\n      \"trigger\": \"continuously during gameplay\",\n      \"actions\": [\n        {\n          \"action\": \"move horizontally in current direction at move speed\"\n        },\n        {\n          \"action\": \"face the direction of movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_direction\",\n      \"trigger\": \"when change direction timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"reverse horizontal movement direction\"\n        },\n        {\n          \"action\": \"reset change direction timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wall_collision\",\n      \"trigger\": \"when colliding with wall or obstacle\",\n      \"actions\": [\n        {\n          \"action\": \"immediately reverse horizontal movement direction\"\n        },\n        {\n          \"action\": \"reset change direction timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SidewaysCrab : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _changeDirectionTime = 3f;\n    [SerializeField] private bool _startMovingRight = true;\n    \n    [Header(\"Ground Detection\")]\n    [SerializeField] private Transform _groundCheckPoint;\n    [SerializeField] private float _groundCheckDistance = 0.5f;\n    [SerializeField] private LayerMask _groundLayerMask = 1;\n    \n    [Header(\"Wall Detection\")]\n    [SerializeField] private Transform _wallCheckPoint;\n    [SerializeField] private float _wallCheckDistance = 0.5f;\n    [SerializeField] private LayerMask _wallLayerMask = 1;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private Animator _animator;\n    \n    private Rigidbody2D _rigidbody2D;\n    private SpriteRenderer _spriteRenderer;\n    private bool _movingRight;\n    private float _directionTimer;\n    private bool _isGrounded;\n    private bool _wallDetected;\n    \n    private void Start()\n    {\n        _rigidbody2D = GetComponent<Rigidbody2D>();\n        _spriteRenderer = GetComponent<SpriteRenderer>();\n        \n        if (_animator == null)\n            _animator = GetComponent<Animator>();\n            \n        _movingRight = _startMovingRight;\n        _directionTimer = _changeDirectionTime;\n        \n        if (_groundCheckPoint == null)\n        {\n            GameObject groundCheck = new GameObject(\"GroundCheck\");\n            groundCheck.transform.SetParent(transform);\n            groundCheck.transform.localPosition = new Vector3(0, -0.5f, 0);\n            _groundCheckPoint = groundCheck.transform;\n        }\n        \n        if (_wallCheckPoint == null)\n        {\n            GameObject wallCheck = new GameObject(\"WallCheck\");\n            wallCheck.transform.SetParent(transform);\n            wallCheck.transform.localPosition = new Vector3(0.5f, 0, 0);\n            _wallCheckPoint = wallCheck.transform;\n        }\n    }\n    \n    private void Update()\n    {\n        _directionTimer -= Time.deltaTime;\n        \n        if (_directionTimer <= 0f)\n        {\n            ChangeDirection();\n            _directionTimer = _changeDirectionTime;\n        }\n        \n        CheckGround();\n        CheckWall();\n        \n        if (!_isGrounded || _wallDetected)\n        {\n            ChangeDirection();\n        }\n        \n        UpdateAnimation();\n    }\n    \n    private void FixedUpdate()\n    {\n        MoveCrab();\n    }\n    \n    private void MoveCrab()\n    {\n        if (_rigidbody2D == null) return;\n        \n        float horizontalMovement = _movingRight ? _moveSpeed : -_moveSpeed;\n        _rigidbody2D.velocity = new Vector2(horizontalMovement, _rigidbody2D.velocity.y);\n        \n        UpdateSpriteDirection();\n    }\n    \n    private void CheckGround()\n    {\n        if (_groundCheckPoint == null) return;\n        \n        Vector3 checkPosition = _groundCheckPoint.position;\n        if (_movingRight)\n            checkPosition += Vector3.right * 0.3f;\n        else\n            checkPosition += Vector3.left * 0.3f;\n            \n        _isGrounded = Physics2D.Raycast(checkPosition, Vector2.down, _groundCheckDistance, _groundLayerMask);\n        \n        Debug.DrawRay(checkPosition, Vector2.down * _groundCheckDistance, _isGrounded ? Color.green : Color.red);\n    }\n    \n    private void CheckWall()\n    {\n        if (_wallCheckPoint == null) return;\n        \n        Vector2 direction = _movingRight ? Vector2.right : Vector2.left;\n        _wallDetected = Physics2D.Raycast(_wallCheckPoint.position, direction, _wallCheckDistance, _wallLayerMask);\n        \n        Debug.DrawRay(_wallCheckPoint.position, direction * _wallCheckDistance, _wallDetected ? Color.red : Color.green);\n    }\n    \n    private void ChangeDirection()\n    {\n        _movingRight = !_movingRight;\n        _directionTimer = _changeDirectionTime;\n        \n        if (_wallCheckPoint != null)\n        {\n            Vector3 wallCheckPos = _wallCheckPoint.localPosition;\n            wallCheckPos.x = Mathf.Abs(wallCheckPos.x) * (_movingRight ? 1 : -1);\n            _wallCheckPoint.localPosition = wallCheckPos;\n        }\n    }\n    \n    private void UpdateSpriteDirection()\n    {\n        if (_spriteRenderer != null)\n        {\n            _spriteRenderer.flipX = !_movingRight;\n        }\n    }\n    \n    private void UpdateAnimation()\n    {\n        if (_animator != null)\n        {\n            bool isMoving = Mathf.Abs(_rigidbody2D.velocity.x) > 0.1f;\n            _animator.SetBool(\"IsMoving\", isMoving);\n            _animator.SetBool(\"MovingRight\", _movingRight);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ChangeDirection();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_groundCheckPoint != null)\n        {\n            Gizmos.color = Color.yellow;\n            Vector3 groundPos = _groundCheckPoint.position;\n            if (_movingRight)\n                groundPos += Vector3.right * 0.3f;\n            else\n                groundPos += Vector3.left * 0.3f;\n            Gizmos.DrawLine(groundPos, groundPos + Vector3.down * _groundCheckDistance);\n        }\n        \n        if (_wallCheckPoint != null)\n        {\n            Gizmos.color = Color.blue;\n            Vector3 direction = _movingRight ? Vector3.right : Vector3.left;\n            Gizmos.DrawLine(_wallCheckPoint.position, _wallCheckPoint.position + direction * _wallCheckDistance);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RollDodge\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rollSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"rollDuration\",\n      \"type\": \"float\",\n      \"default\": 0.6\n    },\n    {\n      \"name\": \"invincibilityDuration\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"rollCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isRolling\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isInvincible\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"canRoll\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_roll\",\n      \"trigger\": \"when dodge input is pressed and can roll and not currently rolling\",\n      \"actions\": [\n        {\n          \"action\": \"set rolling state to true\"\n        },\n        {\n          \"action\": \"set can roll to false\"\n        },\n        {\n          \"action\": \"get movement input direction\"\n        },\n        {\n          \"action\": \"if no input direction use forward direction\"\n        },\n        {\n          \"action\": \"play roll animation\"\n        },\n        {\n          \"action\": \"start roll movement in chosen direction at roll speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"roll_movement\",\n      \"trigger\": \"while rolling state is active\",\n      \"actions\": [\n        {\n          \"action\": \"continue moving in roll direction at roll speed\"\n        },\n        {\n          \"action\": \"ignore normal movement input\"\n        },\n        {\n          \"action\": \"maintain roll animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_invincibility\",\n      \"trigger\": \"when roll begins\",\n      \"actions\": [\n        {\n          \"action\": \"set invincible state to true\"\n        },\n        {\n          \"action\": \"make character visually flash or transparent\"\n        },\n        {\n          \"action\": \"ignore all damage and collision effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_invincibility\",\n      \"trigger\": \"while invincible state is active\",\n      \"actions\": [\n        {\n          \"action\": \"block all incoming damage\"\n        },\n        {\n          \"action\": \"continue visual invincibility effect\"\n        },\n        {\n          \"action\": \"pass through enemy attacks\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_roll\",\n      \"trigger\": \"when roll duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set rolling state to false\"\n        },\n        {\n          \"action\": \"stop roll movement\"\n        },\n        {\n          \"action\": \"return to idle or movement animation\"\n        },\n        {\n          \"action\": \"restore normal movement control\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_invincibility\",\n      \"trigger\": \"when invincibility duration time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set invincible state to false\"\n        },\n        {\n          \"action\": \"stop visual invincibility effect\"\n        },\n        {\n          \"action\": \"restore normal damage reception\"\n        },\n        {\n          \"action\": \"restore normal collision behavior\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_cooldown\",\n      \"trigger\": \"when roll cooldown time has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set can roll to true\"\n        },\n        {\n          \"action\": \"allow dodge input to trigger new roll\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RollDodge : MonoBehaviour\n{\n    [Header(\"Roll Settings\")]\n    [SerializeField] private float _rollDistance = 5f;\n    [SerializeField] private float _rollDuration = 0.5f;\n    [SerializeField] private float _rollCooldown = 1f;\n    [SerializeField] private KeyCode _rollKey = KeyCode.Space;\n    [SerializeField] private bool _useMouseDirection = false;\n    \n    [Header(\"Invincibility Settings\")]\n    [SerializeField] private float _invincibilityDuration = 0.6f;\n    [SerializeField] private int _flashCount = 6;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private LayerMask _obstacleLayer = -1;\n    [SerializeField] private float _capsuleRadius = 0.5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnRollStart;\n    public UnityEvent OnRollEnd;\n    public UnityEvent OnInvincibilityStart;\n    public UnityEvent OnInvincibilityEnd;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Renderer _renderer;\n    private Camera _camera;\n    \n    private bool _isRolling = false;\n    private bool _isInvincible = false;\n    private bool _canRoll = true;\n    private float _rollTimer = 0f;\n    private float _invincibilityTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Vector3 _rollDirection;\n    private Vector3 _startPosition;\n    private Vector3 _targetPosition;\n    private Color _originalColor;\n    private bool _flashVisible = true;\n    private float _flashTimer = 0f;\n    private float _flashInterval;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        _camera = Camera.main;\n        \n        if (_renderer != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        _flashInterval = _invincibilityDuration / (_flashCount * 2);\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateRoll();\n        UpdateInvincibility();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_rollKey) && _canRoll && !_isRolling)\n        {\n            StartRoll();\n        }\n    }\n    \n    private void UpdateCooldown()\n    {\n        if (!_canRoll)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _canRoll = true;\n            }\n        }\n    }\n    \n    private void UpdateRoll()\n    {\n        if (!_isRolling) return;\n        \n        _rollTimer += Time.deltaTime;\n        float progress = _rollTimer / _rollDuration;\n        \n        if (progress >= 1f)\n        {\n            EndRoll();\n            return;\n        }\n        \n        Vector3 currentPosition = Vector3.Lerp(_startPosition, _targetPosition, progress);\n        transform.position = currentPosition;\n    }\n    \n    private void UpdateInvincibility()\n    {\n        if (!_isInvincible) return;\n        \n        _invincibilityTimer -= Time.deltaTime;\n        if (_invincibilityTimer <= 0f)\n        {\n            EndInvincibility();\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (!_isInvincible || _renderer == null) return;\n        \n        _flashTimer += Time.deltaTime;\n        if (_flashTimer >= _flashInterval)\n        {\n            _flashTimer = 0f;\n            _flashVisible = !_flashVisible;\n            \n            Color targetColor = _flashVisible ? _originalColor : new Color(_originalColor.r, _originalColor.g, _originalColor.b, 0.3f);\n            _renderer.material.color = targetColor;\n        }\n    }\n    \n    private void StartRoll()\n    {\n        _rollDirection = GetRollDirection();\n        if (_rollDirection == Vector3.zero) return;\n        \n        Vector3 targetPos = transform.position + _rollDirection * _rollDistance;\n        \n        if (IsPathBlocked(transform.position, targetPos))\n        {\n            targetPos = GetSafeRollPosition(transform.position, _rollDirection);\n        }\n        \n        _startPosition = transform.position;\n        _targetPosition = targetPos;\n        _rollTimer = 0f;\n        _isRolling = true;\n        _canRoll = false;\n        _cooldownTimer = _rollCooldown;\n        \n        StartInvincibility();\n        OnRollStart?.Invoke();\n        \n        if (_rigidbody != null)\n        {\n            _rigidbody.velocity = Vector3.zero;\n        }\n    }\n    \n    private void EndRoll()\n    {\n        _isRolling = false;\n        transform.position = _targetPosition;\n        OnRollEnd?.Invoke();\n    }\n    \n    private void StartInvincibility()\n    {\n        _isInvincible = true;\n        _invincibilityTimer = _invincibilityDuration;\n        _flashTimer = 0f;\n        _flashVisible = true;\n        OnInvincibilityStart?.Invoke();\n        \n        if (_collider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), true);\n        }\n    }\n    \n    private void EndInvincibility()\n    {\n        _isInvincible = false;\n        OnInvincibilityEnd?.Invoke();\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = _originalColor;\n        }\n        \n        if (_collider != null)\n        {\n            Physics.IgnoreLayerCollision(gameObject.layer, LayerMask.NameToLayer(\"Enemy\"), false);\n        }\n    }\n    \n    private Vector3 GetRollDirection()\n    {\n        Vector3 direction = Vector3.zero;\n        \n        if (_useMouseDirection && _camera != null)\n        {\n            Vector3 mousePos = Input.mousePosition;\n            mousePos.z = _camera.WorldToScreenPoint(transform.position).z;\n            Vector3 worldMousePos = _camera.ScreenToWorldPoint(mousePos);\n            direction = (worldMousePos - transform.position).normalized;\n            direction.y = 0f;\n        }\n        else\n        {\n            float horizontal = Input.GetAxisRaw(\"Horizontal\");\n            float vertical = Input.GetAxisRaw(\"Vertical\");\n            direction = new Vector3(horizontal, 0f, vertical).normalized;\n            \n            if (direction == Vector3.zero)\n            {\n                direction = transform.forward;\n            }\n        }\n        \n        return direction;\n    }\n    \n    private bool IsPathBlocked(Vector3 start, Vector3 end)\n    {\n        Vector3 direction = (end - start).normalized;\n        float distance = Vector3.Distance(start, end);\n        \n        return Physics.CapsuleCast(\n            start + Vector3.up * _capsuleRadius,\n            start + Vector3.up * (GetComponent<Collider>().bounds.size.y - _capsuleRadius),\n            _capsuleRadius,\n            direction,\n            distance,\n            _obstacleLayer\n        );\n    }\n    \n    private Vector3 GetSafeRollPosition(Vector3 start, Vector3 direction)\n    {\n        float maxDistance = _rollDistance;\n        float stepSize = 0.5f;\n        \n        for (float distance = maxDistance; distance > stepSize; distance -= stepSize)\n        {\n            Vector3 testPosition = start + direction * distance;\n            \n            if (!IsPathBlocked(start, testPosition))\n            {\n                return testPosition;\n            }\n        }\n        \n        return start;\n    }\n    \n    public bool IsInvincible()\n    {\n        return _isInvincible;\n    }\n    \n    public bool IsRolling()\n    {\n        return _isRolling;\n    }\n    \n    public bool CanRoll()\n    {\n        return _canRoll && !_isRolling;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isInvincible && other.CompareTag(\"Enemy\"))\n        {\n            return;\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isInvincible && collision.gameObject.CompareTag(\"Enemy\"))\n        {\n            Physics.IgnoreCollision(_collider, collision.collider, true);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SplashScreenDisplay\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\",\n    \"CanvasGroup\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"splashDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"fadeInDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"fadeOutDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"nextSceneName\",\n      \"type\": \"string\",\n      \"default\": \"MainMenu\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_splash\",\n      \"trigger\": \"when the game starts\",\n      \"actions\": [\n        {\n          \"action\": \"set the splash screen image to fully transparent\"\n        },\n        {\n          \"action\": \"display the splash screen canvas\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_in_splash\",\n      \"trigger\": \"immediately after initialization\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase the transparency of the splash screen over the fade in duration\"\n        },\n        {\n          \"action\": \"make the splash screen fully visible when fade in completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hold_splash_display\",\n      \"trigger\": \"when fade in animation completes\",\n      \"actions\": [\n        {\n          \"action\": \"keep the splash screen visible for the specified splash duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out_splash\",\n      \"trigger\": \"when the splash display duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease the transparency of the splash screen over the fade out duration\"\n        },\n        {\n          \"action\": \"make the splash screen fully transparent when fade out completes\"\n        }\n      ]\n    },\n    {\n      \"name\": \"transition_to_next_scene\",\n      \"trigger\": \"when fade out animation completes\",\n      \"actions\": [\n        {\n          \"action\": \"load the next scene specified by the scene name\"\n        },\n        {\n          \"action\": \"destroy the splash screen canvas\"\n        }\n      ]\n    },\n    {\n      \"name\": \"skip_splash_on_input\",\n      \"trigger\": \"when player presses any key or clicks during splash display\",\n      \"actions\": [\n        {\n          \"action\": \"immediately start the fade out animation\"\n        },\n        {\n          \"action\": \"skip any remaining splash display time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.Collections;\n\npublic class SplashScreen : MonoBehaviour\n{\n    [Header(\"Splash Screen Settings\")]\n    [SerializeField] private float _displayDuration = 3f;\n    [SerializeField] private float _fadeInDuration = 1f;\n    [SerializeField] private float _fadeOutDuration = 1f;\n    [SerializeField] private bool _skipOnInput = true;\n    [SerializeField] private string _nextSceneName = \"MainMenu\";\n    \n    [Header(\"UI Components\")]\n    [SerializeField] private Image _splashImage;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    [SerializeField] private Text _skipText;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Multiple Splash Screens\")]\n    [SerializeField] private Sprite[] _splashSprites;\n    [SerializeField] private float _timeBetweenSplashes = 0.5f;\n    \n    private bool _isTransitioning = false;\n    private int _currentSplashIndex = 0;\n    private Coroutine _splashCoroutine;\n    \n    private void Start()\n    {\n        InitializeSplashScreen();\n        _splashCoroutine = StartCoroutine(SplashSequence());\n    }\n    \n    private void Update()\n    {\n        if (_skipOnInput && !_isTransitioning && Input.anyKeyDown)\n        {\n            SkipSplashScreen();\n        }\n    }\n    \n    private void InitializeSplashScreen()\n    {\n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n        \n        if (_canvasGroup != null)\n            _canvasGroup.alpha = 0f;\n        \n        if (_skipText != null)\n            _skipText.gameObject.SetActive(_skipOnInput);\n        \n        if (_splashImage != null && _splashSprites != null && _splashSprites.Length > 0)\n            _splashImage.sprite = _splashSprites[0];\n    }\n    \n    private IEnumerator SplashSequence()\n    {\n        if (_splashSprites != null && _splashSprites.Length > 1)\n        {\n            yield return StartCoroutine(MultipleSplashSequence());\n        }\n        else\n        {\n            yield return StartCoroutine(SingleSplashSequence());\n        }\n        \n        LoadNextScene();\n    }\n    \n    private IEnumerator SingleSplashSequence()\n    {\n        // Fade in\n        yield return StartCoroutine(FadeCanvasGroup(0f, 1f, _fadeInDuration));\n        \n        // Display\n        yield return new WaitForSeconds(_displayDuration);\n        \n        // Fade out\n        yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n    }\n    \n    private IEnumerator MultipleSplashSequence()\n    {\n        for (_currentSplashIndex = 0; _currentSplashIndex < _splashSprites.Length; _currentSplashIndex++)\n        {\n            if (_splashImage != null)\n                _splashImage.sprite = _splashSprites[_currentSplashIndex];\n            \n            // Fade in\n            yield return StartCoroutine(FadeCanvasGroup(0f, 1f, _fadeInDuration));\n            \n            // Display\n            yield return new WaitForSeconds(_displayDuration);\n            \n            // Fade out (except for last splash)\n            if (_currentSplashIndex < _splashSprites.Length - 1)\n            {\n                yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n                yield return new WaitForSeconds(_timeBetweenSplashes);\n            }\n        }\n        \n        // Final fade out\n        yield return StartCoroutine(FadeCanvasGroup(1f, 0f, _fadeOutDuration));\n    }\n    \n    private IEnumerator FadeCanvasGroup(float startAlpha, float endAlpha, float duration)\n    {\n        if (_canvasGroup == null)\n            yield break;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < duration)\n        {\n            elapsedTime += Time.deltaTime;\n            float normalizedTime = elapsedTime / duration;\n            _canvasGroup.alpha = Mathf.Lerp(startAlpha, endAlpha, normalizedTime);\n            yield return null;\n        }\n        \n        _canvasGroup.alpha = endAlpha;\n    }\n    \n    private void SkipSplashScreen()\n    {\n        if (_splashCoroutine != null)\n        {\n            StopCoroutine(_splashCoroutine);\n            _splashCoroutine = null;\n        }\n        \n        _isTransitioning = true;\n        StartCoroutine(QuickFadeOut());\n    }\n    \n    private IEnumerator QuickFadeOut()\n    {\n        yield return StartCoroutine(FadeCanvasGroup(_canvasGroup != null ? _canvasGroup.alpha : 1f, 0f, 0.3f));\n        LoadNextScene();\n    }\n    \n    private void LoadNextScene()\n    {\n        if (_isTransitioning)\n            return;\n        \n        _isTransitioning = true;\n        \n        if (string.IsNullOrEmpty(_nextSceneName))\n        {\n            int currentSceneIndex = SceneManager.GetActiveScene().buildIndex;\n            int nextSceneIndex = currentSceneIndex + 1;\n            \n            if (nextSceneIndex < SceneManager.sceneCountInBuildSettings)\n            {\n                SceneManager.LoadScene(nextSceneIndex);\n            }\n            else\n            {\n                Debug.LogWarning(\"No next scene available. Staying on current scene.\");\n            }\n        }\n        else\n        {\n            SceneManager.LoadScene(_nextSceneName);\n        }\n    }\n    \n    private void PlayAudio()\n    {\n        if (_audioSource != null && _audioSource.clip != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _displayDuration = Mathf.Max(0f, _displayDuration);\n        _fadeInDuration = Mathf.Max(0f, _fadeInDuration);\n        _fadeOutDuration = Mathf.Max(0f, _fadeOutDuration);\n        _timeBetweenSplashes = Mathf.Max(0f, _timeBetweenSplashes);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AudioVolumeController\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"masterVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"musicVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"sfxVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"minVolume\",\n      \"type\": \"float\",\n      \"default\": 0.0\n    },\n    {\n      \"name\": \"maxVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"volumeStep\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"isMuted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"previousVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"increase_master_volume\",\n      \"trigger\": \"when volume up input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase master volume by volume step amount\"\n        },\n        {\n          \"action\": \"clamp master volume between minimum and maximum values\"\n        },\n        {\n          \"action\": \"update audio source volume to match master volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"decrease_master_volume\",\n      \"trigger\": \"when volume down input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"decrease master volume by volume step amount\"\n        },\n        {\n          \"action\": \"clamp master volume between minimum and maximum values\"\n        },\n        {\n          \"action\": \"update audio source volume to match master volume\"\n        }\n      ]\n    },\n    {\n      \"name\": \"toggle_mute\",\n      \"trigger\": \"when mute input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"toggle muted state\"\n        },\n        {\n          \"action\": \"if now muted then store current volume and set audio volume to zero\"\n        },\n        {\n          \"action\": \"if now unmuted then restore audio volume to previously stored value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"set_music_volume\",\n      \"trigger\": \"when music volume slider value changes\",\n      \"actions\": [\n        {\n          \"action\": \"update music volume to slider value\"\n        },\n        {\n          \"action\": \"apply music volume to all music audio sources\"\n        }\n      ]\n    },\n    {\n      \"name\": \"set_sfx_volume\",\n      \"trigger\": \"when sound effects volume slider value changes\",\n      \"actions\": [\n        {\n          \"action\": \"update sound effects volume to slider value\"\n        },\n        {\n          \"action\": \"apply sound effects volume to all sound effect audio sources\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_volume_settings\",\n      \"trigger\": \"when component starts\",\n      \"actions\": [\n        {\n          \"action\": \"set audio source volume to master volume\"\n        },\n        {\n          \"action\": \"apply current volume settings to all audio sources\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Audio;\n\npublic class AudioVolumeControls : MonoBehaviour\n{\n    [Header(\"Audio Mixer\")]\n    [SerializeField] private AudioMixerGroup _masterMixerGroup;\n    [SerializeField] private AudioMixerGroup _musicMixerGroup;\n    [SerializeField] private AudioMixerGroup _sfxMixerGroup;\n    \n    [Header(\"Volume Sliders\")]\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    \n    [Header(\"Volume Labels\")]\n    [SerializeField] private Text _masterVolumeLabel;\n    [SerializeField] private Text _musicVolumeLabel;\n    [SerializeField] private Text _sfxVolumeLabel;\n    \n    [Header(\"Mute Toggles\")]\n    [SerializeField] private Toggle _masterMuteToggle;\n    [SerializeField] private Toggle _musicMuteToggle;\n    [SerializeField] private Toggle _sfxMuteToggle;\n    \n    [Header(\"Settings\")]\n    [SerializeField] private float _minVolume = -80f;\n    [SerializeField] private float _maxVolume = 0f;\n    [SerializeField] private bool _saveToPlayerPrefs = true;\n    \n    private const string MASTER_VOLUME_KEY = \"MasterVolume\";\n    private const string MUSIC_VOLUME_KEY = \"MusicVolume\";\n    private const string SFX_VOLUME_KEY = \"SFXVolume\";\n    private const string MASTER_MUTE_KEY = \"MasterMute\";\n    private const string MUSIC_MUTE_KEY = \"MusicMute\";\n    private const string SFX_MUTE_KEY = \"SFXMute\";\n    \n    private const string MASTER_MIXER_PARAM = \"MasterVolume\";\n    private const string MUSIC_MIXER_PARAM = \"MusicVolume\";\n    private const string SFX_MIXER_PARAM = \"SFXVolume\";\n    \n    private float _masterVolume = 1f;\n    private float _musicVolume = 1f;\n    private float _sfxVolume = 1f;\n    \n    private bool _masterMuted = false;\n    private bool _musicMuted = false;\n    private bool _sfxMuted = false;\n    \n    private void Start()\n    {\n        LoadVolumeSettings();\n        InitializeSliders();\n        InitializeToggles();\n        ApplyVolumeSettings();\n    }\n    \n    private void LoadVolumeSettings()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            _masterVolume = PlayerPrefs.GetFloat(MASTER_VOLUME_KEY, 1f);\n            _musicVolume = PlayerPrefs.GetFloat(MUSIC_VOLUME_KEY, 1f);\n            _sfxVolume = PlayerPrefs.GetFloat(SFX_VOLUME_KEY, 1f);\n            \n            _masterMuted = PlayerPrefs.GetInt(MASTER_MUTE_KEY, 0) == 1;\n            _musicMuted = PlayerPrefs.GetInt(MUSIC_MUTE_KEY, 0) == 1;\n            _sfxMuted = PlayerPrefs.GetInt(SFX_MUTE_KEY, 0) == 1;\n        }\n    }\n    \n    private void InitializeSliders()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            _masterVolumeSlider.minValue = 0f;\n            _masterVolumeSlider.maxValue = 1f;\n            _masterVolumeSlider.value = _masterVolume;\n            _masterVolumeSlider.onValueChanged.AddListener(OnMasterVolumeChanged);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            _musicVolumeSlider.minValue = 0f;\n            _musicVolumeSlider.maxValue = 1f;\n            _musicVolumeSlider.value = _musicVolume;\n            _musicVolumeSlider.onValueChanged.AddListener(OnMusicVolumeChanged);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            _sfxVolumeSlider.minValue = 0f;\n            _sfxVolumeSlider.maxValue = 1f;\n            _sfxVolumeSlider.value = _sfxVolume;\n            _sfxVolumeSlider.onValueChanged.AddListener(OnSFXVolumeChanged);\n        }\n    }\n    \n    private void InitializeToggles()\n    {\n        if (_masterMuteToggle != null)\n        {\n            _masterMuteToggle.isOn = _masterMuted;\n            _masterMuteToggle.onValueChanged.AddListener(OnMasterMuteToggled);\n        }\n        \n        if (_musicMuteToggle != null)\n        {\n            _musicMuteToggle.isOn = _musicMuted;\n            _musicMuteToggle.onValueChanged.AddListener(OnMusicMuteToggled);\n        }\n        \n        if (_sfxMuteToggle != null)\n        {\n            _sfxMuteToggle.isOn = _sfxMuted;\n            _sfxMuteToggle.onValueChanged.AddListener(OnSFXMuteToggled);\n        }\n    }\n    \n    public void OnMasterVolumeChanged(float value)\n    {\n        _masterVolume = value;\n        SetMasterVolume(value);\n        UpdateVolumeLabel(_masterVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnMusicVolumeChanged(float value)\n    {\n        _musicVolume = value;\n        SetMusicVolume(value);\n        UpdateVolumeLabel(_musicVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnSFXVolumeChanged(float value)\n    {\n        _sfxVolume = value;\n        SetSFXVolume(value);\n        UpdateVolumeLabel(_sfxVolumeLabel, value);\n        SaveVolumeSettings();\n    }\n    \n    public void OnMasterMuteToggled(bool muted)\n    {\n        _masterMuted = muted;\n        SetMasterVolume(muted ? 0f : _masterVolume);\n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    public void OnMusicMuteToggled(bool muted)\n    {\n        _musicMuted = muted;\n        SetMusicVolume(muted ? 0f : _musicVolume);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    public void OnSFXMuteToggled(bool muted)\n    {\n        _sfxMuted = muted;\n        SetSFXVolume(muted ? 0f : _sfxVolume);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.interactable = !muted;\n        SaveVolumeSettings();\n    }\n    \n    private void SetMasterVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_masterMixerGroup != null && _masterMixerGroup.audioMixer != null)\n        {\n            _masterMixerGroup.audioMixer.SetFloat(MASTER_MIXER_PARAM, dbVolume);\n        }\n        else\n        {\n            AudioListener.volume = volume;\n        }\n    }\n    \n    private void SetMusicVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_musicMixerGroup != null && _musicMixerGroup.audioMixer != null)\n        {\n            _musicMixerGroup.audioMixer.SetFloat(MUSIC_MIXER_PARAM, dbVolume);\n        }\n    }\n    \n    private void SetSFXVolume(float volume)\n    {\n        float dbVolume = ConvertToDecibels(volume);\n        if (_sfxMixerGroup != null && _sfxMixerGroup.audioMixer != null)\n        {\n            _sfxMixerGroup.audioMixer.SetFloat(SFX_MIXER_PARAM, dbVolume);\n        }\n    }\n    \n    private float ConvertToDecibels(float volume)\n    {\n        if (volume <= 0f)\n            return _minVolume;\n        \n        return Mathf.Lerp(_minVolume, _maxVolume, volume);\n    }\n    \n    private void UpdateVolumeLabel(Text label, float volume)\n    {\n        if (label != null)\n        {\n            label.text = Mathf.RoundToInt(volume * 100f) + \"%\";\n        }\n    }\n    \n    private void ApplyVolumeSettings()\n    {\n        SetMasterVolume(_masterMuted ? 0f : _masterVolume);\n        SetMusicVolume(_musicMuted ? 0f : _musicVolume);\n        SetSFXVolume(_sfxMuted ? 0f : _sfxVolume);\n        \n        UpdateVolumeLabel(_masterVolumeLabel, _masterVolume);\n        UpdateVolumeLabel(_musicVolumeLabel, _musicVolume);\n        UpdateVolumeLabel(_sfxVolumeLabel, _sfxVolume);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.interactable = !_masterMuted;\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.interactable = !_musicMuted;\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.interactable = !_sfxMuted;\n    }\n    \n    private void SaveVolumeSettings()\n    {\n        if (_saveToPlayerPrefs)\n        {\n            PlayerPrefs.SetFloat(MASTER_VOLUME_KEY, _masterVolume);\n            PlayerPrefs.SetFloat(MUSIC_VOLUME_KEY, _musicVolume);\n            PlayerPrefs.SetFloat(SFX_VOLUME_KEY, _sfxVolume);\n            \n            PlayerPrefs.SetInt(MASTER_MUTE_KEY, _masterMuted ? 1 : 0);\n            PlayerPrefs.SetInt(MUSIC_MUTE_KEY, _musicMuted ? 1 : 0);\n            PlayerPrefs.SetInt(SFX_MUTE_KEY, _sfxMuted ? 1 : 0);\n            \n            PlayerPrefs.Save();\n        }\n    }\n    \n    public void ResetToDefaults()\n    {\n        _masterVolume = 1f;\n        _musicVolume = 1f;\n        _sfxVolume = 1f;\n        \n        _masterMuted = false;\n        _musicMuted = false;\n        _sfxMuted = false;\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.value = _masterVolume;\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.value = _musicVolume;\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.value = _sfxVolume;\n        \n        if (_masterMuteToggle != null)\n            _masterMuteToggle.isOn = _masterMuted;\n        if (_musicMuteToggle != null)\n            _musicMuteToggle.isOn = _musicMuted;\n        if (_sfxMuteToggle != null)\n            _sfxMuteToggle.isOn = _sfxMuted;\n        \n        ApplyVolumeSettings();\n        SaveVolumeSettings();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.RemoveListener(OnMasterVolumeChanged);\n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.RemoveListener(OnMusicVolumeChanged);\n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.RemoveListener(OnSFXVolumeChanged);\n        \n        if (_masterMuteToggle != null)\n            _masterMuteToggle.onValueChanged.RemoveListener(OnMasterMuteToggled);\n        if (_musicMuteToggle != null)\n            _musicMuteToggle.onValueChanged.RemoveListener(OnMusicMuteToggled);\n        if (_sfxMuteToggle != null)\n            _sfxMuteToggle.onValueChanged.RemoveListener(OnSFXMuteToggled);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CompassPointer\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"target\",\n      \"type\": \"Transform\",\n      \"default\": null\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"point_to_target\",\n      \"trigger\": \"every frame when target exists\",\n      \"actions\": [\n        {\n          \"action\": \"calculate direction from compass to target\"\n        },\n        {\n          \"action\": \"smoothly rotate compass to face target direction\"\n        },\n        {\n          \"action\": \"maintain upright orientation while pointing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_pointing\",\n      \"trigger\": \"when target becomes null or destroyed\",\n      \"actions\": [\n        {\n          \"action\": \"stop rotation movement\"\n        },\n        {\n          \"action\": \"maintain current orientation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class Compass : MonoBehaviour\n{\n    [Header(\"Compass Settings\")]\n    [SerializeField] private Transform _compassNeedle;\n    [SerializeField] private Transform _target;\n    [SerializeField] private bool _useClosestPlayerAsTarget = true;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 5f;\n    [SerializeField] private bool _smoothRotation = true;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private float _rotationOffset = 0f;\n    \n    [Header(\"Distance Settings\")]\n    [SerializeField] private bool _hideWhenClose = false;\n    [SerializeField] private float _hideDistance = 5f;\n    [SerializeField] private CanvasGroup _canvasGroup;\n    [SerializeField] private GameObject _compassObject;\n    \n    [Header(\"Debug\")]\n    [SerializeField] private bool _showDebugLine = false;\n    [SerializeField] private Color _debugLineColor = Color.red;\n    \n    private Camera _playerCamera;\n    private Vector3 _lastKnownTargetPosition;\n    private bool _hasTarget;\n    \n    private void Start()\n    {\n        InitializeCompass();\n        FindTarget();\n    }\n    \n    private void Update()\n    {\n        if (_useClosestPlayerAsTarget && (_target == null || !_target.gameObject.activeInHierarchy))\n        {\n            FindTarget();\n        }\n        \n        if (_target != null && _target.gameObject.activeInHierarchy)\n        {\n            _lastKnownTargetPosition = _target.position;\n            _hasTarget = true;\n        }\n        \n        if (_hasTarget)\n        {\n            UpdateCompassRotation();\n            UpdateVisibility();\n        }\n        else\n        {\n            HideCompass();\n        }\n    }\n    \n    private void InitializeCompass()\n    {\n        if (_compassNeedle == null)\n            _compassNeedle = transform;\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_canvasGroup == null)\n            _canvasGroup = GetComponent<CanvasGroup>();\n            \n        if (_compassObject == null)\n            _compassObject = gameObject;\n    }\n    \n    private void FindTarget()\n    {\n        if (_useClosestPlayerAsTarget)\n        {\n            GameObject[] targets = GameObject.FindGameObjectsWithTag(_targetTag);\n            float closestDistance = Mathf.Infinity;\n            Transform closestTarget = null;\n            \n            foreach (GameObject targetObj in targets)\n            {\n                if (targetObj.activeInHierarchy)\n                {\n                    float distance = Vector3.Distance(transform.position, targetObj.transform.position);\n                    if (distance < closestDistance)\n                    {\n                        closestDistance = distance;\n                        closestTarget = targetObj.transform;\n                    }\n                }\n            }\n            \n            _target = closestTarget;\n        }\n    }\n    \n    private void UpdateCompassRotation()\n    {\n        Vector3 directionToTarget = (_lastKnownTargetPosition - transform.position).normalized;\n        \n        if (_playerCamera != null)\n        {\n            Vector3 cameraForward = _playerCamera.transform.forward;\n            cameraForward.y = 0;\n            cameraForward.Normalize();\n            \n            directionToTarget.y = 0;\n            directionToTarget.Normalize();\n            \n            float angle = Vector3.SignedAngle(cameraForward, directionToTarget, Vector3.up);\n            angle += _rotationOffset;\n            \n            Quaternion targetRotation = Quaternion.AngleAxis(angle, _rotationAxis);\n            \n            if (_smoothRotation)\n            {\n                _compassNeedle.rotation = Quaternion.Lerp(_compassNeedle.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _compassNeedle.rotation = targetRotation;\n            }\n        }\n        else\n        {\n            float angle = Mathf.Atan2(directionToTarget.x, directionToTarget.z) * Mathf.Rad2Deg;\n            angle += _rotationOffset;\n            \n            Quaternion targetRotation = Quaternion.AngleAxis(angle, _rotationAxis);\n            \n            if (_smoothRotation)\n            {\n                _compassNeedle.rotation = Quaternion.Lerp(_compassNeedle.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n            }\n            else\n            {\n                _compassNeedle.rotation = targetRotation;\n            }\n        }\n    }\n    \n    private void UpdateVisibility()\n    {\n        if (_hideWhenClose)\n        {\n            float distance = Vector3.Distance(transform.position, _lastKnownTargetPosition);\n            bool shouldShow = distance > _hideDistance;\n            \n            if (_canvasGroup != null)\n            {\n                float targetAlpha = shouldShow ? 1f : 0f;\n                _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, targetAlpha, _rotationSpeed * Time.deltaTime);\n            }\n            else if (_compassObject != null)\n            {\n                _compassObject.SetActive(shouldShow);\n            }\n        }\n        else\n        {\n            ShowCompass();\n        }\n    }\n    \n    private void ShowCompass()\n    {\n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, 1f, _rotationSpeed * Time.deltaTime);\n        }\n        else if (_compassObject != null)\n        {\n            _compassObject.SetActive(true);\n        }\n    }\n    \n    private void HideCompass()\n    {\n        if (_canvasGroup != null)\n        {\n            _canvasGroup.alpha = Mathf.Lerp(_canvasGroup.alpha, 0f, _rotationSpeed * Time.deltaTime);\n        }\n        else if (_compassObject != null)\n        {\n            _compassObject.SetActive(false);\n        }\n    }\n    \n    public void SetTarget(Transform newTarget)\n    {\n        _target = newTarget;\n        _useClosestPlayerAsTarget = false;\n        _hasTarget = _target != null;\n    }\n    \n    public void SetTargetPosition(Vector3 position)\n    {\n        _lastKnownTargetPosition = position;\n        _target = null;\n        _useClosestPlayerAsTarget = false;\n        _hasTarget = true;\n    }\n    \n    public void ClearTarget()\n    {\n        _target = null;\n        _hasTarget = false;\n        _useClosestPlayerAsTarget = false;\n    }\n    \n    public float GetDistanceToTarget()\n    {\n        if (_hasTarget)\n        {\n            return Vector3.Distance(transform.position, _lastKnownTargetPosition);\n        }\n        return -1f;\n    }\n    \n    public Vector3 GetDirectionToTarget()\n    {\n        if (_hasTarget)\n        {\n            return (_lastKnownTargetPosition - transform.position).normalized;\n        }\n        return Vector3.zero;\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (_showDebugLine && _hasTarget)\n        {\n            Gizmos.color = _debugLineColor;\n            Gizmos.DrawLine(transform.position, _lastKnownTargetPosition);\n            Gizmos.DrawWireSphere(_lastKnownTargetPosition, 1f);\n            \n            if (_hideWhenClose)\n            {\n                Gizmos.color = Color.yellow;\n                Gizmos.DrawWireSphere(transform.position, _hideDistance);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SunLensFlare\",\n  \"components\": [\n    \"LensFlare\",\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"intensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"fadeSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"maxDistance\",\n      \"type\": \"float\",\n      \"default\": 1000.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"adjust_flare_visibility\",\n      \"trigger\": \"when camera looks toward sun position\",\n      \"actions\": [\n        {\n          \"action\": \"increase lens flare brightness based on viewing angle\"\n        },\n        {\n          \"action\": \"make flare more visible when directly facing sun\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_with_distance\",\n      \"trigger\": \"when camera distance from sun changes\",\n      \"actions\": [\n        {\n          \"action\": \"reduce flare intensity as distance increases\"\n        },\n        {\n          \"action\": \"completely hide flare when beyond maximum distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_occlusion\",\n      \"trigger\": \"when objects block line of sight to sun\",\n      \"actions\": [\n        {\n          \"action\": \"fade out lens flare when sun is occluded\"\n        },\n        {\n          \"action\": \"fade in lens flare when sun becomes visible again\"\n        }\n      ]\n    },\n    {\n      \"name\": \"atmospheric_effects\",\n      \"trigger\": \"when sun position changes throughout day\",\n      \"actions\": [\n        {\n          \"action\": \"adjust flare color based on sun height\"\n        },\n        {\n          \"action\": \"increase flare warmth when sun is low on horizon\"\n        },\n        {\n          \"action\": \"reduce flare intensity during overcast conditions\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SunLensFlare : MonoBehaviour\n{\n    [Header(\"Lens Flare Settings\")]\n    [SerializeField] private LensFlare _lensFlare;\n    [SerializeField] private Light _sunLight;\n    [SerializeField] private Camera _playerCamera;\n    \n    [Header(\"Visibility Control\")]\n    [SerializeField] private bool _checkVisibility = true;\n    [SerializeField] private LayerMask _occlusionLayers = -1;\n    [SerializeField] private float _maxDistance = 1000f;\n    [SerializeField] private float _fadeSpeed = 5f;\n    \n    [Header(\"Dynamic Brightness\")]\n    [SerializeField] private bool _adjustBrightness = true;\n    [SerializeField] private float _maxBrightness = 1f;\n    [SerializeField] private float _minBrightness = 0.1f;\n    [SerializeField] private AnimationCurve _brightnessCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Color Settings\")]\n    [SerializeField] private bool _matchSunColor = true;\n    [SerializeField] private Color _customColor = Color.white;\n    [SerializeField] private Gradient _timeOfDayGradient;\n    [SerializeField] private bool _useTimeOfDay = false;\n    [SerializeField] private float _timeOfDaySpeed = 0.1f;\n    \n    private float _targetBrightness;\n    private float _currentBrightness;\n    private bool _isVisible;\n    private Vector3 _sunDirection;\n    private float _timeOfDay;\n    \n    void Start()\n    {\n        InitializeComponents();\n        SetupLensFlare();\n    }\n    \n    void Update()\n    {\n        if (_lensFlare == null) return;\n        \n        UpdateSunDirection();\n        CheckVisibility();\n        UpdateBrightness();\n        UpdateColor();\n        ApplyLensFlareSettings();\n    }\n    \n    void InitializeComponents()\n    {\n        if (_lensFlare == null)\n            _lensFlare = GetComponent<LensFlare>();\n        \n        if (_lensFlare == null)\n            _lensFlare = gameObject.AddComponent<LensFlare>();\n        \n        if (_sunLight == null)\n            _sunLight = GetComponent<Light>();\n        \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n        \n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n    }\n    \n    void SetupLensFlare()\n    {\n        if (_lensFlare == null) return;\n        \n        _lensFlare.brightness = 0f;\n        _currentBrightness = 0f;\n        _targetBrightness = 0f;\n        \n        if (_timeOfDayGradient == null)\n        {\n            _timeOfDayGradient = new Gradient();\n            GradientColorKey[] colorKeys = new GradientColorKey[3];\n            colorKeys[0] = new GradientColorKey(new Color(1f, 0.5f, 0.2f), 0f);\n            colorKeys[1] = new GradientColorKey(Color.white, 0.5f);\n            colorKeys[2] = new GradientColorKey(new Color(1f, 0.7f, 0.4f), 1f);\n            \n            GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];\n            alphaKeys[0] = new GradientAlphaKey(1f, 0f);\n            alphaKeys[1] = new GradientAlphaKey(1f, 1f);\n            \n            _timeOfDayGradient.SetKeys(colorKeys, alphaKeys);\n        }\n    }\n    \n    void UpdateSunDirection()\n    {\n        if (_playerCamera == null) return;\n        \n        _sunDirection = (transform.position - _playerCamera.transform.position).normalized;\n    }\n    \n    void CheckVisibility()\n    {\n        if (!_checkVisibility || _playerCamera == null)\n        {\n            _isVisible = true;\n            _targetBrightness = _maxBrightness;\n            return;\n        }\n        \n        Vector3 cameraPosition = _playerCamera.transform.position;\n        Vector3 sunPosition = transform.position;\n        Vector3 direction = (sunPosition - cameraPosition).normalized;\n        float distance = Vector3.Distance(cameraPosition, sunPosition);\n        \n        if (distance > _maxDistance)\n        {\n            _isVisible = false;\n            _targetBrightness = 0f;\n            return;\n        }\n        \n        Vector3 cameraForward = _playerCamera.transform.forward;\n        float dotProduct = Vector3.Dot(cameraForward, direction);\n        \n        if (dotProduct <= 0f)\n        {\n            _isVisible = false;\n            _targetBrightness = 0f;\n            return;\n        }\n        \n        RaycastHit hit;\n        if (Physics.Raycast(cameraPosition, direction, out hit, distance, _occlusionLayers))\n        {\n            if (hit.collider.transform != transform)\n            {\n                _isVisible = false;\n                _targetBrightness = 0f;\n                return;\n            }\n        }\n        \n        _isVisible = true;\n        \n        if (_adjustBrightness)\n        {\n            float normalizedDot = Mathf.Clamp01(dotProduct);\n            float curveValue = _brightnessCurve.Evaluate(normalizedDot);\n            _targetBrightness = Mathf.Lerp(_minBrightness, _maxBrightness, curveValue);\n        }\n        else\n        {\n            _targetBrightness = _maxBrightness;\n        }\n    }\n    \n    void UpdateBrightness()\n    {\n        _currentBrightness = Mathf.Lerp(_currentBrightness, _targetBrightness, Time.deltaTime * _fadeSpeed);\n    }\n    \n    void UpdateColor()\n    {\n        if (_lensFlare == null) return;\n        \n        Color targetColor = Color.white;\n        \n        if (_useTimeOfDay)\n        {\n            _timeOfDay += Time.deltaTime * _timeOfDaySpeed;\n            if (_timeOfDay > 1f) _timeOfDay = 0f;\n            targetColor = _timeOfDayGradient.Evaluate(_timeOfDay);\n        }\n        else if (_matchSunColor && _sunLight != null)\n        {\n            targetColor = _sunLight.color;\n        }\n        else\n        {\n            targetColor = _customColor;\n        }\n        \n        _lensFlare.color = targetColor;\n    }\n    \n    void ApplyLensFlareSettings()\n    {\n        if (_lensFlare == null) return;\n        \n        _lensFlare.brightness = _currentBrightness;\n        \n        if (_sunLight != null)\n        {\n            _lensFlare.enabled = _sunLight.enabled && _currentBrightness > 0.01f;\n        }\n        else\n        {\n            _lensFlare.enabled = _currentBrightness > 0.01f;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera == null) return;\n        \n        Gizmos.color = _isVisible ? Color.green : Color.red;\n        Gizmos.DrawLine(_playerCamera.transform.position, transform.position);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 5f);\n    }\n    \n    public void SetBrightness(float brightness)\n    {\n        _maxBrightness = Mathf.Clamp01(brightness);\n    }\n    \n    public void SetColor(Color color)\n    {\n        _customColor = color;\n        _matchSunColor = false;\n    }\n    \n    public void SetTimeOfDay(float normalizedTime)\n    {\n        _timeOfDay = Mathf.Clamp01(normalizedTime);\n    }\n    \n    public bool IsVisible()\n    {\n        return _isVisible;\n    }\n    \n    public float GetCurrentBrightness()\n    {\n        return _currentBrightness;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TurntableDJMixer\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"crossfaderPosition\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"leftTurntableSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"rightTurntableSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"leftVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"rightVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"bassLevel\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"midLevel\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"trebleLevel\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isPlaying\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"leftTrackLoaded\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"rightTrackLoaded\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"adjust_crossfader\",\n      \"trigger\": \"when crossfader slider is moved\",\n      \"actions\": [\n        {\n          \"action\": \"blend audio between left and right turntables based on crossfader position\"\n        },\n        {\n          \"action\": \"adjust volume levels of both tracks proportionally\"\n        }\n      ]\n    },\n    {\n      \"name\": \"control_left_turntable\",\n      \"trigger\": \"when left turntable is touched or scratched\",\n      \"actions\": [\n        {\n          \"action\": \"modify left turntable playback speed based on touch direction\"\n        },\n        {\n          \"action\": \"create scratch sound effects when moved rapidly\"\n        },\n        {\n          \"action\": \"pause left track when turntable is held still\"\n        }\n      ]\n    },\n    {\n      \"name\": \"control_right_turntable\",\n      \"trigger\": \"when right turntable is touched or scratched\",\n      \"actions\": [\n        {\n          \"action\": \"modify right turntable playback speed based on touch direction\"\n        },\n        {\n          \"action\": \"create scratch sound effects when moved rapidly\"\n        },\n        {\n          \"action\": \"pause right track when turntable is held still\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_equalizer\",\n      \"trigger\": \"when bass, mid, or treble knobs are rotated\",\n      \"actions\": [\n        {\n          \"action\": \"modify corresponding frequency range of the mixed audio output\"\n        },\n        {\n          \"action\": \"update visual feedback on equalizer display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"load_track\",\n      \"trigger\": \"when track is dropped onto turntable deck\",\n      \"actions\": [\n        {\n          \"action\": \"load audio file into corresponding turntable\"\n        },\n        {\n          \"action\": \"display track information on deck screen\"\n        },\n        {\n          \"action\": \"enable playback controls for that deck\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_playback\",\n      \"trigger\": \"when play button is pressed on either deck\",\n      \"actions\": [\n        {\n          \"action\": \"begin audio playback on selected turntable\"\n        },\n        {\n          \"action\": \"illuminate play button indicator\"\n        },\n        {\n          \"action\": \"start turntable rotation animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cue_track\",\n      \"trigger\": \"when cue button is pressed and held\",\n      \"actions\": [\n        {\n          \"action\": \"play audio preview through headphones only\"\n        },\n        {\n          \"action\": \"allow track positioning without affecting main output\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Audio;\nusing System.Collections;\n\npublic class TurntableDJMixer : MonoBehaviour\n{\n    [System.Serializable]\n    public class TurntableSettings\n    {\n        [Header(\"Turntable Properties\")]\n        public Transform turntablePlatter;\n        public AudioSource audioSource;\n        public AudioClip[] trackClips;\n        [Range(0f, 2f)] public float pitchRange = 0.5f;\n        [Range(0f, 1f)] public float volume = 1f;\n        public bool isPlaying = false;\n        public float currentRPM = 33.33f;\n        public int currentTrackIndex = 0;\n    }\n\n    [System.Serializable]\n    public class CrossfaderSettings\n    {\n        [Range(-1f, 1f)] public float position = 0f;\n        public AnimationCurve crossfadeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);\n    }\n\n    [System.Serializable]\n    public class EffectSettings\n    {\n        [Range(0f, 1f)] public float reverbAmount = 0f;\n        [Range(0f, 1f)] public float distortionAmount = 0f;\n        [Range(0f, 1f)] public float echoAmount = 0f;\n        [Range(20f, 20000f)] public float lowPassFreq = 20000f;\n        [Range(20f, 20000f)] public float highPassFreq = 20f;\n    }\n\n    [Header(\"Turntables\")]\n    [SerializeField] private TurntableSettings _leftTurntable;\n    [SerializeField] private TurntableSettings _rightTurntable;\n\n    [Header(\"Mixer Controls\")]\n    [SerializeField] private CrossfaderSettings _crossfader;\n    [SerializeField] private Transform _crossfaderKnob;\n    [Range(0f, 1f)] [SerializeField] private float _masterVolume = 1f;\n    [Range(0f, 1f)] [SerializeField] private float _leftChannelGain = 1f;\n    [Range(0f, 1f)] [SerializeField] private float _rightChannelGain = 1f;\n\n    [Header(\"Effects\")]\n    [SerializeField] private EffectSettings _leftEffects;\n    [SerializeField] private EffectSettings _rightEffects;\n\n    [Header(\"Visual Elements\")]\n    [SerializeField] private Transform _leftPitchSlider;\n    [SerializeField] private Transform _rightPitchSlider;\n    [SerializeField] private Light[] _vuMeterLights;\n    [SerializeField] private Material _activeLightMaterial;\n    [SerializeField] private Material _inactiveLightMaterial;\n\n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _leftPlayKey = KeyCode.Q;\n    [SerializeField] private KeyCode _rightPlayKey = KeyCode.P;\n    [SerializeField] private KeyCode _leftNextTrackKey = KeyCode.W;\n    [SerializeField] private KeyCode _rightNextTrackKey = KeyCode.O;\n\n    [Header(\"Events\")]\n    public UnityEvent<int> OnLeftTrackChanged;\n    public UnityEvent<int> OnRightTrackChanged;\n    public UnityEvent<bool> OnLeftPlayStateChanged;\n    public UnityEvent<bool> OnRightPlayStateChanged;\n    public UnityEvent<float> OnCrossfaderChanged;\n\n    private AudioLowPassFilter _leftLowPass;\n    private AudioHighPassFilter _leftHighPass;\n    private AudioReverbFilter _leftReverb;\n    private AudioDistortionFilter _leftDistortion;\n    private AudioEchoFilter _leftEcho;\n\n    private AudioLowPassFilter _rightLowPass;\n    private AudioHighPassFilter _rightHighPass;\n    private AudioReverbFilter _rightReverb;\n    private AudioDistortionFilter _rightDistortion;\n    private AudioEchoFilter _rightEcho;\n\n    private bool _isDraggingCrossfader = false;\n    private bool _isDraggingLeftPitch = false;\n    private bool _isDraggingRightPitch = false;\n\n    private float _leftVuLevel = 0f;\n    private float _rightVuLevel = 0f;\n\n    private void Start()\n    {\n        InitializeTurntables();\n        InitializeAudioEffects();\n        InitializeVisuals();\n    }\n\n    private void InitializeTurntables()\n    {\n        if (_leftTurntable.audioSource == null)\n            _leftTurntable.audioSource = gameObject.AddComponent<AudioSource>();\n        if (_rightTurntable.audioSource == null)\n            _rightTurntable.audioSource = gameObject.AddComponent<AudioSource>();\n\n        _leftTurntable.audioSource.loop = true;\n        _rightTurntable.audioSource.loop = true;\n        _leftTurntable.audioSource.playOnAwake = false;\n        _rightTurntable.audioSource.playOnAwake = false;\n\n        if (_leftTurntable.trackClips != null && _leftTurntable.trackClips.Length > 0)\n            _leftTurntable.audioSource.clip = _leftTurntable.trackClips[0];\n        if (_rightTurntable.trackClips != null && _rightTurntable.trackClips.Length > 0)\n            _rightTurntable.audioSource.clip = _rightTurntable.trackClips[0];\n    }\n\n    private void InitializeAudioEffects()\n    {\n        _leftLowPass = _leftTurntable.audioSource.gameObject.AddComponent<AudioLowPassFilter>();\n        _leftHighPass = _leftTurntable.audioSource.gameObject.AddComponent<AudioHighPassFilter>();\n        _leftReverb = _leftTurntable.audioSource.gameObject.AddComponent<AudioReverbFilter>();\n        _leftDistortion = _leftTurntable.audioSource.gameObject.AddComponent<AudioDistortionFilter>();\n        _leftEcho = _leftTurntable.audioSource.gameObject.AddComponent<AudioEchoFilter>();\n\n        _rightLowPass = _rightTurntable.audioSource.gameObject.AddComponent<AudioLowPassFilter>();\n        _rightHighPass = _rightTurntable.audioSource.gameObject.AddComponent<AudioHighPassFilter>();\n        _rightReverb = _rightTurntable.audioSource.gameObject.AddComponent<AudioReverbFilter>();\n        _rightDistortion = _rightTurntable.audioSource.gameObject.AddComponent<AudioDistortionFilter>();\n        _rightEcho = _rightTurntable.audioSource.gameObject.AddComponent<AudioEchoFilter>();\n\n        _leftReverb.enabled = false;\n        _leftDistortion.enabled = false;\n        _leftEcho.enabled = false;\n        _rightReverb.enabled = false;\n        _rightDistortion.enabled = false;\n        _rightEcho.enabled = false;\n    }\n\n    private void InitializeVisuals()\n    {\n        if (_crossfaderKnob != null)\n            _crossfaderKnob.localPosition = new Vector3(_crossfader.position, 0f, 0f);\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        UpdateTurntableRotation();\n        UpdateAudioEffects();\n        UpdateCrossfader();\n        UpdateVUMeters();\n        UpdateVisuals();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_leftPlayKey))\n            ToggleLeftTurntable();\n        if (Input.GetKeyDown(_rightPlayKey))\n            ToggleRightTurntable();\n        if (Input.GetKeyDown(_leftNextTrackKey))\n            NextLeftTrack();\n        if (Input.GetKeyDown(_rightNextTrackKey))\n            NextRightTrack();\n\n        HandleMouseInput();\n    }\n\n    private void HandleMouseInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            if (Physics.Raycast(ray, out RaycastHit hit))\n            {\n                if (hit.collider.CompareTag(\"Crossfader\"))\n                    _isDraggingCrossfader = true;\n                else if (hit.collider.CompareTag(\"LeftPitch\"))\n                    _isDraggingLeftPitch = true;\n                else if (hit.collider.CompareTag(\"RightPitch\"))\n                    _isDraggingRightPitch = true;\n            }\n        }\n\n        if (Input.GetMouseButtonUp(0))\n        {\n            _isDraggingCrossfader = false;\n            _isDraggingLeftPitch = false;\n            _isDraggingRightPitch = false;\n        }\n\n        if (_isDraggingCrossfader)\n            UpdateCrossfaderFromMouse();\n        if (_isDraggingLeftPitch)\n            UpdateLeftPitchFromMouse();\n        if (_isDraggingRightPitch)\n            UpdateRightPitchFromMouse();\n    }\n\n    private void UpdateCrossfaderFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float newPosition = Mathf.Clamp((mousePos.x - transform.position.x) / 2f, -1f, 1f);\n        SetCrossfaderPosition(newPosition);\n    }\n\n    private void UpdateLeftPitchFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float pitchValue = Mathf.Clamp((mousePos.y - transform.position.y) / 2f, -_leftTurntable.pitchRange, _leftTurntable.pitchRange);\n        SetLeftTurntablePitch(1f + pitchValue);\n    }\n\n    private void UpdateRightPitchFromMouse()\n    {\n        Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n        float pitchValue = Mathf.Clamp((mousePos.y - transform.position.y) / 2f, -_rightTurntable.pitchRange, _rightTurntable.pitchRange);\n        SetRightTurntablePitch(1f + pitchValue);\n    }\n\n    private void UpdateTurntableRotation()\n    {\n        if (_leftTurntable.turntablePlatter != null && _leftTurntable.isPlaying)\n        {\n            float rotationSpeed = (_leftTurntable.currentRPM / 60f) * 360f * _leftTurntable.audioSource.pitch;\n            _leftTurntable.turntablePlatter.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);\n        }\n\n        if (_rightTurntable.turntablePlatter != null && _rightTurntable.isPlaying)\n        {\n            float rotationSpeed = (_rightTurntable.currentRPM / 60f) * 360f * _rightTurntable.audioSource.pitch;\n            _rightTurntable.turntablePlatter.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);\n        }\n    }\n\n    private void UpdateAudioEffects()\n    {\n        UpdateEffectsForTurntable(_leftEffects, _leftLowPass, _leftHighPass, _leftReverb, _leftDistortion, _leftEcho);\n        UpdateEffectsForTurntable(_rightEffects, _rightLowPass, _rightHighPass, _rightReverb, _rightDistortion, _rightEcho);\n    }\n\n    private void UpdateEffectsForTurntable(EffectSettings effects, AudioLowPassFilter lowPass, AudioHighPassFilter highPass,\n        AudioReverbFilter reverb, AudioDistortionFilter distortion, AudioEchoFilter echo)\n    {\n        lowPass.cutoffFrequency = effects.lowPassFreq;\n        highPass.cutoffFrequency = effects.highPassFreq;\n\n        reverb.enabled = effects.reverbAmount > 0.01f;\n        if (reverb.enabled)\n            reverb.reverbLevel = Mathf.Lerp(-10000f, 0f, effects.reverbAmount);\n\n        distortion.enabled = effects.distortionAmount > 0.01f;\n        if (distortion.enabled)\n            distortion.distortionLevel = effects.distortionAmount;\n\n        echo.enabled = effects.echoAmount > 0.01f;\n        if (echo.enabled)\n        {\n            echo.wetMix = effects.echoAmount;\n            echo.delay = 500f;\n            echo.decayRatio = 0.5f;\n        }\n    }\n\n    private void UpdateCrossfader()\n    {\n        float leftVolume = _crossfader.crossfadeCurve.Evaluate(Mathf.Clamp01(1f + _crossfader.position));\n        float rightVolume = _crossfader.crossfadeCurve.Evaluate(Mathf.Clamp01(1f - _crossfader.position));\n\n        _leftTurntable.audioSource.volume = _leftTurntable.volume * _leftChannelGain * leftVolume * _masterVolume;\n        _rightTurntable.audioSource.volume = _rightTurntable.volume * _rightChannelGain * rightVolume * _masterVolume;\n    }\n\n    private void UpdateVUMeters()\n    {\n        _leftVuLevel = GetAudioLevel(_leftTurntable.audioSource);\n        _rightVuLevel = GetAudioLevel(_rightTurntable.audioSource);\n\n        if (_vuMeterLights != null)\n        {\n            int leftLights = Mathf.RoundToInt(_leftVuLevel * (_vuMeterLights.Length / 2f));\n            int rightLights = Mathf.RoundToInt(_rightVuLevel * (_vuMeterLights.Length / 2f));\n\n            for (int i = 0; i < _vuMeterLights.Length / 2; i++)\n            {\n                if (_vuMeterLights[i] != null)\n                {\n                    _vuMeterLights[i].enabled = i < leftLights;\n                    _vuMeterLights[i].color = i < leftLights ? Color.green : Color.black;\n                }\n            }\n\n            for (int i = _vuMeterLights.Length / 2; i < _vuMeterLights.Length; i++)\n            {\n                if (_vuMeterLights[i] != null)\n                {\n                    int rightIndex = i - (_vuMeterLights.Length / 2);\n                    _vuMeterLights[i].enabled = rightIndex < rightLights;\n                    _vuMeterLights[i].color = rightIndex < rightLights ? Color.green : Color.black;\n                }\n            }\n        }\n    }\n\n    private float GetAudioLevel(AudioSource audioSource)\n    {\n        if (audioSource == null || !audioSource.isPlaying)\n            return 0f;\n\n        float[] samples = new float[256];\n        audioSource.GetOutputData(samples, 0);\n        \n        float sum = 0f;\n        for (int i = 0; i < samples.Length; i++)\n            sum += Mathf.Abs(samples[i]);\n        \n        return Mathf.Clamp01(sum / samples.Length * 10f);\n    }\n\n    private void UpdateVisuals()\n    {\n        if (_crossfaderKnob != null)\n            _crossf"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MagneticFieldZone\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fieldStrength\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"attractionRadius\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"affectMetalObjects\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"affectElectronicDevices\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"pulseEffect\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"pulseFrequency\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attract_metal_objects\",\n      \"trigger\": \"when metal objects are within attraction radius\",\n      \"actions\": [\n        {\n          \"action\": \"pull metal objects toward the center of the magnetic field\"\n        },\n        {\n          \"action\": \"apply force proportional to field strength and object mass\"\n        }\n      ]\n    },\n    {\n      \"name\": \"disrupt_electronics\",\n      \"trigger\": \"when electronic devices enter the magnetic field and affect electronics is enabled\",\n      \"actions\": [\n        {\n          \"action\": \"cause electronic devices to malfunction temporarily\"\n        },\n        {\n          \"action\": \"create visual static or interference effects on screens\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pulse_magnetic_field\",\n      \"trigger\": \"when pulse effect is enabled and pulse timer reaches frequency interval\",\n      \"actions\": [\n        {\n          \"action\": \"temporarily increase field strength\"\n        },\n        {\n          \"action\": \"create expanding visual pulse effect\"\n        },\n        {\n          \"action\": \"reset pulse timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"repel_objects\",\n      \"trigger\": \"when field strength is set to negative value\",\n      \"actions\": [\n        {\n          \"action\": \"push metal objects away from the center\"\n        },\n        {\n          \"action\": \"apply repulsive force based on absolute field strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_field_indicator\",\n      \"trigger\": \"continuously while magnetic field is active\",\n      \"actions\": [\n        {\n          \"action\": \"display particle effects showing magnetic field lines\"\n        },\n        {\n          \"action\": \"animate field visualization based on current strength\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MagneticFieldZone : MonoBehaviour\n{\n    [Header(\"Magnetic Field Settings\")]\n    [SerializeField] private float _magneticStrength = 10f;\n    [SerializeField] private float _maxRange = 15f;\n    [SerializeField] private AnimationCurve _strengthFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Magnetic Behavior\")]\n    [SerializeField] private bool _attractMetalObjects = true;\n    [SerializeField] private bool _repelMetalObjects = false;\n    [SerializeField] private bool _affectRigidbodies = true;\n    [SerializeField] private bool _affectCharacterControllers = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _magneticParticles;\n    [SerializeField] private LineRenderer _fieldLines;\n    [SerializeField] private Material _fieldLineMaterial;\n    [SerializeField] private int _fieldLineCount = 8;\n    [SerializeField] private float _fieldLineLength = 10f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _magneticHumSound;\n    [SerializeField] private float _baseVolume = 0.5f;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.02f;\n    [SerializeField] private int _maxAffectedObjects = 50;\n    \n    private List<MagneticObject> _affectedObjects = new List<MagneticObject>();\n    private SphereCollider _detectionCollider;\n    private float _lastUpdateTime;\n    private bool _isActive = true;\n    \n    [System.Serializable]\n    private class MagneticObject\n    {\n        public Transform transform;\n        public Rigidbody rigidbody;\n        public CharacterController characterController;\n        public float metallic = 1f;\n        public Vector3 originalVelocity;\n        \n        public MagneticObject(Transform t, Rigidbody rb, CharacterController cc, float metalValue)\n        {\n            transform = t;\n            rigidbody = rb;\n            characterController = cc;\n            metallic = metalValue;\n        }\n    }\n    \n    private void Start()\n    {\n        SetupDetectionCollider();\n        SetupVisualEffects();\n        SetupAudio();\n    }\n    \n    private void SetupDetectionCollider()\n    {\n        _detectionCollider = GetComponent<SphereCollider>();\n        if (_detectionCollider == null)\n        {\n            _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _maxRange;\n    }\n    \n    private void SetupVisualEffects()\n    {\n        if (_fieldLines == null)\n        {\n            GameObject fieldLinesObj = new GameObject(\"FieldLines\");\n            fieldLinesObj.transform.SetParent(transform);\n            fieldLinesObj.transform.localPosition = Vector3.zero;\n            _fieldLines = fieldLinesObj.AddComponent<LineRenderer>();\n        }\n        \n        if (_fieldLines != null && _fieldLineMaterial != null)\n        {\n            _fieldLines.material = _fieldLineMaterial;\n            _fieldLines.startWidth = 0.1f;\n            _fieldLines.endWidth = 0.05f;\n            _fieldLines.positionCount = _fieldLineCount * 2;\n            _fieldLines.useWorldSpace = true;\n        }\n        \n        UpdateFieldLines();\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_audioSource != null && _magneticHumSound != null)\n        {\n            _audioSource.clip = _magneticHumSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _baseVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isActive) return;\n        \n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            ApplyMagneticForces();\n            UpdateVisualEffects();\n            UpdateAudio();\n            _lastUpdateTime = Time.time;\n        }\n    }\n    \n    private void ApplyMagneticForces()\n    {\n        for (int i = _affectedObjects.Count - 1; i >= 0; i--)\n        {\n            if (_affectedObjects[i].transform == null)\n            {\n                _affectedObjects.RemoveAt(i);\n                continue;\n            }\n            \n            ApplyForceToObject(_affectedObjects[i]);\n        }\n    }\n    \n    private void ApplyForceToObject(MagneticObject magneticObj)\n    {\n        Vector3 direction = transform.position - magneticObj.transform.position;\n        float distance = direction.magnitude;\n        \n        if (distance > _maxRange)\n        {\n            _affectedObjects.Remove(magneticObj);\n            return;\n        }\n        \n        if (distance < 0.1f) return;\n        \n        direction.Normalize();\n        \n        float normalizedDistance = distance / _maxRange;\n        float strengthMultiplier = _strengthFalloff.Evaluate(1f - normalizedDistance);\n        float force = _magneticStrength * strengthMultiplier * magneticObj.metallic;\n        \n        if (_repelMetalObjects)\n        {\n            direction = -direction;\n        }\n        \n        Vector3 magneticForce = direction * force;\n        \n        if (_affectRigidbodies && magneticObj.rigidbody != null)\n        {\n            magneticObj.rigidbody.AddForce(magneticForce, ForceMode.Force);\n        }\n        else if (_affectCharacterControllers && magneticObj.characterController != null)\n        {\n            Vector3 movement = magneticForce * Time.deltaTime / magneticObj.characterController.mass;\n            magneticObj.characterController.Move(movement);\n        }\n        else\n        {\n            magneticObj.transform.position += magneticForce * Time.deltaTime * 0.1f;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_magneticParticles != null)\n        {\n            var emission = _magneticParticles.emission;\n            emission.rateOverTime = _affectedObjects.Count * 10f;\n        }\n        \n        UpdateFieldLines();\n    }\n    \n    private void UpdateFieldLines()\n    {\n        if (_fieldLines == null) return;\n        \n        Vector3[] positions = new Vector3[_fieldLineCount * 2];\n        \n        for (int i = 0; i < _fieldLineCount; i++)\n        {\n            float angle = (360f / _fieldLineCount) * i;\n            Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.forward;\n            \n            positions[i * 2] = transform.position;\n            positions[i * 2 + 1] = transform.position + direction * _fieldLineLength;\n        }\n        \n        _fieldLines.positionCount = positions.Length;\n        _fieldLines.SetPositions(positions);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            float volumeMultiplier = Mathf.Clamp01(_affectedObjects.Count / 10f);\n            _audioSource.volume = _baseVolume * volumeMultiplier;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive) return;\n        if (_affectedObjects.Count >= _maxAffectedObjects) return;\n        if (((1 << other.gameObject.layer) & _affectedLayers) == 0) return;\n        \n        float metallicValue = GetMetallicValue(other);\n        if (metallicValue <= 0f) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        CharacterController cc = other.GetComponent<CharacterController>();\n        \n        if (rb != null || cc != null || other.CompareTag(\"Player\"))\n        {\n            MagneticObject magneticObj = new MagneticObject(other.transform, rb, cc, metallicValue);\n            _affectedObjects.Add(magneticObj);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        for (int i = _affectedObjects.Count - 1; i >= 0; i--)\n        {\n            if (_affectedObjects[i].transform == other.transform)\n            {\n                _affectedObjects.RemoveAt(i);\n                break;\n            }\n        }\n    }\n    \n    private float GetMetallicValue(Collider other)\n    {\n        if (other.CompareTag(\"Metal\")) return 1f;\n        if (other.CompareTag(\"Player\")) return 0.3f;\n        if (other.name.ToLower().Contains(\"metal\")) return 0.8f;\n        if (other.name.ToLower().Contains(\"iron\")) return 1f;\n        if (other.name.ToLower().Contains(\"steel\")) return 0.9f;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && rb.mass > 1f) return 0.5f;\n        \n        return 0.2f;\n    }\n    \n    public void SetMagneticStrength(float strength)\n    {\n        _magneticStrength = Mathf.Max(0f, strength);\n    }\n    \n    public void SetMaxRange(float range)\n    {\n        _maxRange = Mathf.Max(0.1f, range);\n        if (_detectionCollider != null)\n        {\n            _detectionCollider.radius = _maxRange;\n        }\n    }\n    \n    public void ToggleAttraction()\n    {\n        _attractMetalObjects = !_attractMetalObjects;\n        _repelMetalObjects = !_attractMetalObjects;\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (!active)\n        {\n            _affectedObjects.Clear();\n        }\n        \n        if (_magneticParticles != null)\n        {\n            if (active)\n                _magneticParticles.Play();\n            else\n                _magneticParticles.Stop();\n        }\n        \n        if (_audioSource != null)\n        {\n            if (active && !_audioSource.isPlaying)\n                _audioSource.Play();\n            else if (!active && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n    }\n    \n    public int GetAffectedObjectCount()\n    {\n        return _affectedObjects.Count;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _maxRange);\n        \n        Gizmos.color = Color.cyan;\n        for (int i = 0; i < _affectedObjects.Count; i++)\n        {\n            if (_affectedObjects[i].transform != null)\n            {\n                Gizmos.DrawLine(transform.position, _affectedObjects[i].transform.position);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GoKartController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"brakeForce\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"driftThreshold\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"enginePitch\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"currentLap\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"checkpointsPassed\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate_forward\",\n      \"trigger\": \"when forward input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase forward velocity up to maximum speed\"\n        },\n        {\n          \"action\": \"increase engine sound pitch based on current speed\"\n        },\n        {\n          \"action\": \"create dust particles behind rear wheels\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake_or_reverse\",\n      \"trigger\": \"when brake input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"apply braking force to reduce speed\"\n        },\n        {\n          \"action\": \"if speed is very low then move backward slowly\"\n        },\n        {\n          \"action\": \"create brake light effects\"\n        },\n        {\n          \"action\": \"play tire screech sound if braking hard\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_left_right\",\n      \"trigger\": \"when steering input is detected\",\n      \"actions\": [\n        {\n          \"action\": \"rotate the kart in the steering direction\"\n        },\n        {\n          \"action\": \"tilt the kart body slightly toward the turn\"\n        },\n        {\n          \"action\": \"adjust wheel rotation to match steering angle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_mechanics\",\n      \"trigger\": \"when turning at high speed\",\n      \"actions\": [\n        {\n          \"action\": \"reduce grip on rear wheels\"\n        },\n        {\n          \"action\": \"create tire smoke effects\"\n        },\n        {\n          \"action\": \"play drifting sound effects\"\n        },\n        {\n          \"action\": \"slightly reduce speed during drift\"\n        }\n      ]\n    },\n    {\n      \"name\": \"checkpoint_detection\",\n      \"trigger\": \"when passing through a checkpoint\",\n      \"actions\": [\n        {\n          \"action\": \"increment checkpoints passed counter\"\n        },\n        {\n          \"action\": \"play checkpoint sound effect\"\n        },\n        {\n          \"action\": \"display checkpoint notification\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lap_completion\",\n      \"trigger\": \"when all checkpoints are passed and crossing finish line\",\n      \"actions\": [\n        {\n          \"action\": \"increment current lap number\"\n        },\n        {\n          \"action\": \"reset checkpoints passed to zero\"\n        },\n        {\n          \"action\": \"record lap time\"\n        },\n        {\n          \"action\": \"play lap completion sound\"\n        },\n        {\n          \"action\": \"display lap time on screen\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collision_response\",\n      \"trigger\": \"when colliding with walls or other karts\",\n      \"actions\": [\n        {\n          \"action\": \"reduce speed based on collision force\"\n        },\n        {\n          \"action\": \"bounce away from collision point\"\n        },\n        {\n          \"action\": \"play collision sound effect\"\n        },\n        {\n          \"action\": \"create impact particle effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"airborne_handling\",\n      \"trigger\": \"when kart leaves the ground\",\n      \"actions\": [\n        {\n          \"action\": \"reduce steering effectiveness\"\n        },\n        {\n          \"action\": \"maintain forward momentum\"\n        },\n        {\n          \"action\": \"prepare for landing impact\"\n        }\n      ]\n    },\n    {\n      \"name\": \"landing_impact\",\n      \"trigger\": \"when kart touches ground after being airborne\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal steering control\"\n        },\n        {\n          \"action\": \"create dust cloud on landing\"\n        },\n        {\n          \"action\": \"play landing thud sound\"\n        },\n        {\n          \"action\": \"briefly compress suspension visually\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n\npublic class GoKartController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _motorForce = 1500f;\n    [SerializeField] private float _brakeForce = 3000f;\n    [SerializeField] private float _maxSteerAngle = 30f;\n    [SerializeField] private float _downForce = 100f;\n    \n    [Header(\"Wheel Colliders\")]\n    [SerializeField] private WheelCollider _frontLeftWheelCollider;\n    [SerializeField] private WheelCollider _frontRightWheelCollider;\n    [SerializeField] private WheelCollider _rearLeftWheelCollider;\n    [SerializeField] private WheelCollider _rearRightWheelCollider;\n    \n    [Header(\"Wheel Transforms\")]\n    [SerializeField] private Transform _frontLeftWheelTransform;\n    [SerializeField] private Transform _frontRightWheelTransform;\n    [SerializeField] private Transform _rearLeftWheelTransform;\n    [SerializeField] private Transform _rearRightWheelTransform;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _engineAudioSource;\n    [SerializeField] private AudioClip _engineIdleClip;\n    [SerializeField] private AudioClip _engineRevClip;\n    [SerializeField] private float _minPitch = 0.8f;\n    [SerializeField] private float _maxPitch = 2.0f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _leftWheelSmoke;\n    [SerializeField] private ParticleSystem _rightWheelSmoke;\n    [SerializeField] private TrailRenderer _leftSkidTrail;\n    [SerializeField] private TrailRenderer _rightSkidTrail;\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _currentSteerAngle;\n    private float _currentBreakForce;\n    private bool _isBraking;\n    private Rigidbody _rigidbody;\n    private float _currentSpeed;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.centerOfMass = new Vector3(0, -0.5f, 0);\n        \n        if (_engineAudioSource != null && _engineIdleClip != null)\n        {\n            _engineAudioSource.clip = _engineIdleClip;\n            _engineAudioSource.loop = true;\n            _engineAudioSource.Play();\n        }\n    }\n    \n    private void Update()\n    {\n        GetInput();\n        HandleMotor();\n        HandleSteering();\n        UpdateWheelPoses();\n        UpdateAudio();\n        UpdateEffects();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyDownForce();\n        _currentSpeed = _rigidbody.velocity.magnitude * 3.6f;\n    }\n    \n    private void GetInput()\n    {\n        _horizontalInput = Input.GetAxis(\"Horizontal\");\n        _verticalInput = Input.GetAxis(\"Vertical\");\n        _isBraking = Input.GetKey(KeyCode.Space);\n    }\n    \n    private void HandleMotor()\n    {\n        _frontLeftWheelCollider.motorTorque = _verticalInput * _motorForce;\n        _frontRightWheelCollider.motorTorque = _verticalInput * _motorForce;\n        \n        _currentBreakForce = _isBraking ? _brakeForce : 0f;\n        ApplyBraking();\n    }\n    \n    private void ApplyBraking()\n    {\n        _frontRightWheelCollider.brakeTorque = _currentBreakForce;\n        _frontLeftWheelCollider.brakeTorque = _currentBreakForce;\n        _rearLeftWheelCollider.brakeTorque = _currentBreakForce;\n        _rearRightWheelCollider.brakeTorque = _currentBreakForce;\n    }\n    \n    private void HandleSteering()\n    {\n        _currentSteerAngle = _maxSteerAngle * _horizontalInput;\n        _frontLeftWheelCollider.steerAngle = _currentSteerAngle;\n        _frontRightWheelCollider.steerAngle = _currentSteerAngle;\n    }\n    \n    private void UpdateWheelPoses()\n    {\n        UpdateWheelPose(_frontLeftWheelCollider, _frontLeftWheelTransform);\n        UpdateWheelPose(_frontRightWheelCollider, _frontRightWheelTransform);\n        UpdateWheelPose(_rearRightWheelCollider, _rearRightWheelTransform);\n        UpdateWheelPose(_rearLeftWheelCollider, _rearLeftWheelTransform);\n    }\n    \n    private void UpdateWheelPose(WheelCollider collider, Transform wheelTransform)\n    {\n        if (collider == null || wheelTransform == null) return;\n        \n        Vector3 pos;\n        Quaternion rot;\n        collider.GetWorldPose(out pos, out rot);\n        wheelTransform.position = pos;\n        wheelTransform.rotation = rot;\n    }\n    \n    private void ApplyDownForce()\n    {\n        _rigidbody.AddForce(-transform.up * _downForce * _rigidbody.velocity.magnitude);\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_engineAudioSource == null) return;\n        \n        float speedRatio = Mathf.Clamp01(_currentSpeed / 100f);\n        _engineAudioSource.pitch = Mathf.Lerp(_minPitch, _maxPitch, speedRatio);\n        \n        if (Mathf.Abs(_verticalInput) > 0.1f && _engineRevClip != null)\n        {\n            if (_engineAudioSource.clip != _engineRevClip)\n            {\n                _engineAudioSource.clip = _engineRevClip;\n                _engineAudioSource.Play();\n            }\n        }\n        else if (_engineIdleClip != null)\n        {\n            if (_engineAudioSource.clip != _engineIdleClip)\n            {\n                _engineAudioSource.clip = _engineIdleClip;\n                _engineAudioSource.Play();\n            }\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        bool isSkidding = _isBraking && _currentSpeed > 10f;\n        \n        if (_leftWheelSmoke != null)\n        {\n            if (isSkidding && !_leftWheelSmoke.isPlaying)\n                _leftWheelSmoke.Play();\n            else if (!isSkidding && _leftWheelSmoke.isPlaying)\n                _leftWheelSmoke.Stop();\n        }\n        \n        if (_rightWheelSmoke != null)\n        {\n            if (isSkidding && !_rightWheelSmoke.isPlaying)\n                _rightWheelSmoke.Play();\n            else if (!isSkidding && _rightWheelSmoke.isPlaying)\n                _rightWheelSmoke.Stop();\n        }\n        \n        if (_leftSkidTrail != null)\n            _leftSkidTrail.emitting = isSkidding;\n            \n        if (_rightSkidTrail != null)\n            _rightSkidTrail.emitting = isSkidding;\n    }\n    \n    public float GetCurrentSpeed()\n    {\n        return _currentSpeed;\n    }\n    \n    public bool IsGrounded()\n    {\n        return _frontLeftWheelCollider.isGrounded || _frontRightWheelCollider.isGrounded ||\n               _rearLeftWheelCollider.isGrounded || _rearRightWheelCollider.isGrounded;\n    }\n}\n\npublic class RaceCheckpoint : MonoBehaviour\n{\n    [Header(\"Checkpoint Settings\")]\n    [SerializeField] private int _checkpointIndex;\n    [SerializeField] private bool _isFinishLine;\n    [SerializeField] private Material _activeMaterial;\n    [SerializeField] private Material _inactiveMaterial;\n    \n    private Renderer _renderer;\n    private bool _isActive = true;\n    \n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        UpdateVisual();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isActive) return;\n        \n        GoKartController kart = other.GetComponent<GoKartController>();\n        if (kart != null)\n        {\n            RaceManager raceManager = FindObjectOfType<RaceManager>();\n            if (raceManager != null)\n            {\n                raceManager.CheckpointReached(_checkpointIndex, _isFinishLine, kart);\n            }\n            \n            _isActive = false;\n            UpdateVisual();\n        }\n    }\n    \n    public void ResetCheckpoint()\n    {\n        _isActive = true;\n        UpdateVisual();\n    }\n    \n    private void UpdateVisual()\n    {\n        if (_renderer != null)\n        {\n            _renderer.material = _isActive ? _activeMaterial : _inactiveMaterial;\n        }\n    }\n}\n\npublic class RaceManager : MonoBehaviour\n{\n    [Header(\"Race Settings\")]\n    [SerializeField] private int _totalLaps = 3;\n    [SerializeField] private int _totalCheckpoints = 5;\n    [SerializeField] private Text _lapText;\n    [SerializeField] private Text _timeText;\n    [SerializeField] private Text _speedText;\n    [SerializeField] private GameObject _raceCompletePanel;\n    \n    private int _currentLap = 1;\n    private int _currentCheckpoint = 0;\n    private float _raceTime = 0f;\n    private bool _raceActive = true;\n    private GoKartController _playerKart;\n    private RaceCheckpoint[] _checkpoints;\n    \n    private void Start()\n    {\n        _playerKart = FindObjectOfType<GoKartController>();\n        _checkpoints = FindObjectsOfType<RaceCheckpoint>();\n        \n        if (_raceCompletePanel != null)\n            _raceCompletePanel.SetActive(false);\n    }\n    \n    private void Update()\n    {\n        if (_raceActive)\n        {\n            _raceTime += Time.deltaTime;\n            UpdateUI();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            RestartRace();\n        }\n    }\n    \n    public void CheckpointReached(int checkpointIndex, bool isFinishLine, GoKartController kart)\n    {\n        if (!_raceActive || kart != _playerKart) return;\n        \n        if (checkpointIndex == _currentCheckpoint)\n        {\n            _currentCheckpoint++;\n            \n            if (isFinishLine)\n            {\n                if (_currentLap >= _totalLaps)\n                {\n                    CompleteRace();\n                }\n                else\n                {\n                    _currentLap++;\n                    _currentCheckpoint = 0;\n                    ResetCheckpoints();\n                }\n            }\n        }\n    }\n    \n    private void CompleteRace()\n    {\n        _raceActive = false;\n        if (_raceCompletePanel != null)\n        {\n            _raceCompletePanel.SetActive(true);\n        }\n        \n        Debug.Log($\"Race Complete! Time: {FormatTime(_raceTime)}\");\n    }\n    \n    private void RestartRace()\n    {\n        _currentLap = 1;\n        _currentCheckpoint = 0;\n        _raceTime = 0f;\n        _raceActive = true;\n        \n        if (_raceCompletePanel != null)\n            _raceCompletePanel.SetActive(false);\n            \n        ResetCheckpoints();\n    }\n    \n    private void ResetCheckpoints()\n    {\n        foreach (RaceCheckpoint checkpoint in _checkpoints)\n        {\n            if (checkpoint != null)\n                checkpoint.ResetCheckpoint();\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_lapText != null)\n            _lapText.text = $\"Lap: {_currentLap}/{_totalLaps}\";\n            \n        if (_timeText != null)\n            _timeText.text = $\"Time: {FormatTime(_raceTime)}\";\n            \n        if (_speedText != null && _playerKart != null)\n            _speedText.text = $\"Speed: {_playerKart.GetCurrentSpeed():F0} km/h\";\n    }\n    \n    private string FormatTime(float time)\n    {\n        int minutes = Mathf.FloorToInt(time / 60f);\n        int seconds = Mathf.FloorToInt(time % 60f);\n        int milliseconds = Mathf.FloorToInt((time * 100f) % 100f);\n        return $\"{minutes:00}:{seconds:00}:{milliseconds:00}\";\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DirectionalDamageIndicator\",\n  \"components\": [\n    \"Canvas\",\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"indicatorPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"fadeOutTime\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"indicatorDistance\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"damageColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    },\n    {\n      \"name\": \"activeIndicators\",\n      \"type\": \"List<GameObject>\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_damage_indicator\",\n      \"trigger\": \"when damage is received from a source\",\n      \"actions\": [\n        {\n          \"action\": \"calculate direction from player to damage source\"\n        },\n        {\n          \"action\": \"create damage indicator UI element\"\n        },\n        {\n          \"action\": \"position indicator on screen edge pointing toward damage source\"\n        },\n        {\n          \"action\": \"set indicator color to damage color\"\n        },\n        {\n          \"action\": \"add indicator to active indicators list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_indicator_positions\",\n      \"trigger\": \"every frame while indicators are active\",\n      \"actions\": [\n        {\n          \"action\": \"update each indicator position based on damage source location\"\n        },\n        {\n          \"action\": \"keep indicators positioned on screen edge\"\n        },\n        {\n          \"action\": \"rotate indicators to point toward damage sources\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fade_out_indicator\",\n      \"trigger\": \"when indicator has been displayed for full duration\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce indicator opacity over fade out time\"\n        },\n        {\n          \"action\": \"remove indicator when completely faded\"\n        },\n        {\n          \"action\": \"remove indicator from active indicators list\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cleanup_expired_indicators\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"check each active indicator for expiration\"\n        },\n        {\n          \"action\": \"remove indicators that have exceeded display duration\"\n        },\n        {\n          \"action\": \"destroy expired indicator game objects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class DirectionalDamageIndicator : MonoBehaviour\n{\n    [Header(\"Damage Indicator Settings\")]\n    [SerializeField] private GameObject _damageIndicatorPrefab;\n    [SerializeField] private Transform _indicatorParent;\n    [SerializeField] private float _indicatorDistance = 100f;\n    [SerializeField] private float _indicatorDuration = 2f;\n    [SerializeField] private float _fadeOutDuration = 0.5f;\n    [SerializeField] private Color _damageColor = Color.red;\n    [SerializeField] private Vector2 _indicatorSize = new Vector2(50f, 50f);\n    \n    [Header(\"Player Reference\")]\n    [SerializeField] private Transform _playerTransform;\n    [SerializeField] private Camera _playerCamera;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _damageSound;\n    \n    private List<DamageIndicatorInstance> _activeIndicators = new List<DamageIndicatorInstance>();\n    private Canvas _canvas;\n    \n    [System.Serializable]\n    private class DamageIndicatorInstance\n    {\n        public GameObject indicatorObject;\n        public Image indicatorImage;\n        public Vector3 damageSourcePosition;\n        public float creationTime;\n        public Coroutine fadeCoroutine;\n    }\n    \n    private void Start()\n    {\n        InitializeComponents();\n        CreateIndicatorPrefabIfNeeded();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_playerTransform == null)\n            _playerTransform = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n            \n        if (_playerCamera == null)\n            _playerCamera = Camera.main;\n            \n        if (_indicatorParent == null)\n        {\n            _canvas = FindObjectOfType<Canvas>();\n            if (_canvas == null)\n            {\n                GameObject canvasGO = new GameObject(\"DamageIndicatorCanvas\");\n                _canvas = canvasGO.AddComponent<Canvas>();\n                _canvas.renderMode = RenderMode.ScreenSpaceOverlay;\n                canvasGO.AddComponent<CanvasScaler>();\n                canvasGO.AddComponent<GraphicRaycaster>();\n            }\n            _indicatorParent = _canvas.transform;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void CreateIndicatorPrefabIfNeeded()\n    {\n        if (_damageIndicatorPrefab == null)\n        {\n            _damageIndicatorPrefab = new GameObject(\"DamageIndicator\");\n            Image image = _damageIndicatorPrefab.AddComponent<Image>();\n            \n            Texture2D texture = new Texture2D(32, 32);\n            Color[] pixels = new Color[32 * 32];\n            for (int i = 0; i < pixels.Length; i++)\n            {\n                int x = i % 32;\n                int y = i / 32;\n                float distance = Vector2.Distance(new Vector2(x, y), new Vector2(16, 16));\n                if (distance < 12f)\n                    pixels[i] = _damageColor;\n                else\n                    pixels[i] = Color.clear;\n            }\n            texture.SetPixels(pixels);\n            texture.Apply();\n            \n            Sprite sprite = Sprite.Create(texture, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f));\n            image.sprite = sprite;\n            image.color = _damageColor;\n            \n            RectTransform rectTransform = _damageIndicatorPrefab.GetComponent<RectTransform>();\n            rectTransform.sizeDelta = _indicatorSize;\n        }\n    }\n    \n    private void Update()\n    {\n        UpdateIndicatorPositions();\n        CleanupExpiredIndicators();\n    }\n    \n    private void UpdateIndicatorPositions()\n    {\n        if (_playerTransform == null || _playerCamera == null) return;\n        \n        for (int i = _activeIndicators.Count - 1; i >= 0; i--)\n        {\n            var indicator = _activeIndicators[i];\n            if (indicator.indicatorObject == null) continue;\n            \n            Vector3 directionToDamage = (indicator.damageSourcePosition - _playerTransform.position).normalized;\n            Vector3 screenCenter = new Vector3(Screen.width * 0.5f, Screen.height * 0.5f, 0f);\n            \n            Vector3 forward = _playerCamera.transform.forward;\n            Vector3 right = _playerCamera.transform.right;\n            \n            float angle = Mathf.Atan2(Vector3.Dot(directionToDamage, right), Vector3.Dot(directionToDamage, forward)) * Mathf.Rad2Deg;\n            \n            Vector3 indicatorPosition = screenCenter + new Vector3(\n                Mathf.Sin(angle * Mathf.Deg2Rad) * _indicatorDistance,\n                Mathf.Cos(angle * Mathf.Deg2Rad) * _indicatorDistance,\n                0f\n            );\n            \n            RectTransform rectTransform = indicator.indicatorObject.GetComponent<RectTransform>();\n            rectTransform.position = indicatorPosition;\n            rectTransform.rotation = Quaternion.Euler(0f, 0f, -angle);\n        }\n    }\n    \n    private void CleanupExpiredIndicators()\n    {\n        for (int i = _activeIndicators.Count - 1; i >= 0; i--)\n        {\n            var indicator = _activeIndicators[i];\n            if (Time.time - indicator.creationTime > _indicatorDuration)\n            {\n                if (indicator.indicatorObject != null)\n                    Destroy(indicator.indicatorObject);\n                _activeIndicators.RemoveAt(i);\n            }\n        }\n    }\n    \n    public void ShowDamageIndicator(Vector3 damageSourcePosition)\n    {\n        if (_indicatorParent == null || _damageIndicatorPrefab == null) return;\n        \n        GameObject indicatorInstance = Instantiate(_damageIndicatorPrefab, _indicatorParent);\n        Image indicatorImage = indicatorInstance.GetComponent<Image>();\n        \n        DamageIndicatorInstance newIndicator = new DamageIndicatorInstance\n        {\n            indicatorObject = indicatorInstance,\n            indicatorImage = indicatorImage,\n            damageSourcePosition = damageSourcePosition,\n            creationTime = Time.time\n        };\n        \n        _activeIndicators.Add(newIndicator);\n        \n        newIndicator.fadeCoroutine = StartCoroutine(FadeOutIndicator(newIndicator));\n        \n        PlayDamageSound();\n    }\n    \n    private IEnumerator FadeOutIndicator(DamageIndicatorInstance indicator)\n    {\n        float fadeStartTime = _indicatorDuration - _fadeOutDuration;\n        \n        yield return new WaitForSeconds(fadeStartTime);\n        \n        if (indicator.indicatorImage != null)\n        {\n            Color originalColor = indicator.indicatorImage.color;\n            float fadeTimer = 0f;\n            \n            while (fadeTimer < _fadeOutDuration && indicator.indicatorImage != null)\n            {\n                fadeTimer += Time.deltaTime;\n                float alpha = Mathf.Lerp(originalColor.a, 0f, fadeTimer / _fadeOutDuration);\n                indicator.indicatorImage.color = new Color(originalColor.r, originalColor.g, originalColor.b, alpha);\n                yield return null;\n            }\n        }\n    }\n    \n    private void PlayDamageSound()\n    {\n        if (_audioSource != null && _damageSound != null)\n        {\n            _audioSource.PlayOneShot(_damageSound);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Projectile\") || other.CompareTag(\"Enemy\"))\n        {\n            ShowDamageIndicator(other.transform.position);\n        }\n    }\n    \n    public void OnPlayerDamaged(Vector3 damageSourcePosition)\n    {\n        ShowDamageIndicator(damageSourcePosition);\n    }\n    \n    private void OnDestroy()\n    {\n        foreach (var indicator in _activeIndicators)\n        {\n            if (indicator.indicatorObject != null)\n                Destroy(indicator.indicatorObject);\n        }\n        _activeIndicators.Clear();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StatefulDoor\",\n  \"components\": [\n    \"Renderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isLocked\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"isUnlocking\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isClosing\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"shakeIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"unlockDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"openDuration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"unlockTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"openTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"lockedColor\",\n      \"type\": \"Color\",\n      \"default\": \"red\"\n    },\n    {\n      \"name\": \"unlockingColor\",\n      \"type\": \"Color\",\n      \"default\": \"yellow\"\n    },\n    {\n      \"name\": \"openColor\",\n      \"type\": \"Color\",\n      \"default\": \"green\"\n    },\n    {\n      \"name\": \"closingColor\",\n      \"type\": \"Color\",\n      \"default\": \"blue\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"shake_when_locked\",\n      \"trigger\": \"when door is in locked state\",\n      \"actions\": [\n        {\n          \"action\": \"shake door slightly with random small movements\"\n        },\n        {\n          \"action\": \"set material emission color to red\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_unlocking\",\n      \"trigger\": \"when unlock key is used on locked door\",\n      \"actions\": [\n        {\n          \"action\": \"set door state to unlocking\"\n        },\n        {\n          \"action\": \"play key turning sound\"\n        },\n        {\n          \"action\": \"set material emission color to yellow\"\n        },\n        {\n          \"action\": \"start unlock timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_unlocking\",\n      \"trigger\": \"when unlock timer reaches three seconds\",\n      \"actions\": [\n        {\n          \"action\": \"set door state to open\"\n        },\n        {\n          \"action\": \"stop key turning sound\"\n        },\n        {\n          \"action\": \"rotate door to open position\"\n        },\n        {\n          \"action\": \"set material emission color to green\"\n        },\n        {\n          \"action\": \"start open timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_close_door\",\n      \"trigger\": \"when open timer reaches ten seconds\",\n      \"actions\": [\n        {\n          \"action\": \"set door state to closing\"\n        },\n        {\n          \"action\": \"set material emission color to blue\"\n        },\n        {\n          \"action\": \"rotate door back to closed position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_closing\",\n      \"trigger\": \"when door rotation reaches closed position\",\n      \"actions\": [\n        {\n          \"action\": \"set door state to locked\"\n        },\n        {\n          \"action\": \"reset all timers\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Door : MonoBehaviour\n{\n    public enum DoorState\n    {\n        Locked,\n        Unlocking,\n        Open,\n        Closing\n    }\n\n    [Header(\"Door Settings\")]\n    [SerializeField] private DoorState _currentState = DoorState.Locked;\n    [SerializeField] private float _unlockDuration = 3f;\n    [SerializeField] private float _openDuration = 10f;\n    [SerializeField] private float _openAngle = 90f;\n    [SerializeField] private float _openSpeed = 2f;\n\n    [Header(\"Shake Settings\")]\n    [SerializeField] private float _shakeIntensity = 0.1f;\n    [SerializeField] private float _shakeSpeed = 10f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _unlockingSound;\n    [SerializeField] private AudioClip _openSound;\n    [SerializeField] private AudioClip _closeSound;\n\n    [Header(\"Visual Settings\")]\n    [SerializeField] private Renderer _doorRenderer;\n    [SerializeField] private string _emissionProperty = \"_EmissionColor\";\n    [SerializeField] private Color _lockedColor = Color.red;\n    [SerializeField] private Color _unlockingColor = Color.yellow;\n    [SerializeField] private Color _openColor = Color.green;\n    [SerializeField] private Color _closingColor = Color.blue;\n\n    [Header(\"Events\")]\n    public UnityEvent OnDoorUnlocked;\n    public UnityEvent OnDoorOpened;\n    public UnityEvent OnDoorClosed;\n\n    private Vector3 _originalPosition;\n    private Quaternion _originalRotation;\n    private Quaternion _openRotation;\n    private Material _doorMaterial;\n    private Coroutine _currentStateCoroutine;\n    private bool _isPlayerNear = false;\n\n    private void Start()\n    {\n        _originalPosition = transform.position;\n        _originalRotation = transform.rotation;\n        _openRotation = _originalRotation * Quaternion.Euler(0, _openAngle, 0);\n\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n\n        if (_doorRenderer == null)\n            _doorRenderer = GetComponent<Renderer>();\n\n        if (_doorRenderer != null)\n        {\n            _doorMaterial = _doorRenderer.material;\n            UpdateEmissionColor();\n        }\n\n        SetState(_currentState);\n    }\n\n    private void Update()\n    {\n        if (_currentState == DoorState.Locked)\n        {\n            ApplyShake();\n        }\n\n        if (_isPlayerNear && Input.GetKeyDown(KeyCode.E))\n        {\n            TryInteract();\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerNear = true;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            _isPlayerNear = false;\n        }\n    }\n\n    public void TryInteract()\n    {\n        if (_currentState == DoorState.Locked)\n        {\n            SetState(DoorState.Unlocking);\n        }\n    }\n\n    public void SetState(DoorState newState)\n    {\n        if (_currentState == newState) return;\n\n        if (_currentStateCoroutine != null)\n        {\n            StopCoroutine(_currentStateCoroutine);\n        }\n\n        _currentState = newState;\n        UpdateEmissionColor();\n\n        switch (_currentState)\n        {\n            case DoorState.Locked:\n                break;\n            case DoorState.Unlocking:\n                _currentStateCoroutine = StartCoroutine(UnlockingSequence());\n                break;\n            case DoorState.Open:\n                _currentStateCoroutine = StartCoroutine(OpenSequence());\n                break;\n            case DoorState.Closing:\n                _currentStateCoroutine = StartCoroutine(ClosingSequence());\n                break;\n        }\n    }\n\n    private void ApplyShake()\n    {\n        if (_shakeIntensity <= 0) return;\n\n        float shakeX = Mathf.Sin(Time.time * _shakeSpeed) * _shakeIntensity;\n        float shakeZ = Mathf.Cos(Time.time * _shakeSpeed * 1.1f) * _shakeIntensity;\n        \n        transform.position = _originalPosition + new Vector3(shakeX, 0, shakeZ);\n    }\n\n    private IEnumerator UnlockingSequence()\n    {\n        if (_unlockingSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _unlockingSound;\n            _audioSource.Play();\n        }\n\n        yield return new WaitForSeconds(_unlockDuration);\n\n        OnDoorUnlocked?.Invoke();\n        SetState(DoorState.Open);\n    }\n\n    private IEnumerator OpenSequence()\n    {\n        if (_openSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _openSound;\n            _audioSource.Play();\n        }\n\n        // Reset position from shake\n        transform.position = _originalPosition;\n\n        // Rotate door to open position\n        float elapsedTime = 0f;\n        while (elapsedTime < 1f / _openSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime * _openSpeed;\n            transform.rotation = Quaternion.Lerp(_originalRotation, _openRotation, t);\n            yield return null;\n        }\n\n        transform.rotation = _openRotation;\n        OnDoorOpened?.Invoke();\n\n        // Wait for open duration\n        yield return new WaitForSeconds(_openDuration);\n\n        SetState(DoorState.Closing);\n    }\n\n    private IEnumerator ClosingSequence()\n    {\n        if (_closeSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _closeSound;\n            _audioSource.Play();\n        }\n\n        // Rotate door back to closed position\n        float elapsedTime = 0f;\n        while (elapsedTime < 1f / _openSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float t = elapsedTime * _openSpeed;\n            transform.rotation = Quaternion.Lerp(_openRotation, _originalRotation, t);\n            yield return null;\n        }\n\n        transform.rotation = _originalRotation;\n        OnDoorClosed?.Invoke();\n        SetState(DoorState.Locked);\n    }\n\n    private void UpdateEmissionColor()\n    {\n        if (_doorMaterial == null) return;\n\n        Color targetColor = _currentState switch\n        {\n            DoorState.Locked => _lockedColor,\n            DoorState.Unlocking => _unlockingColor,\n            DoorState.Open => _openColor,\n            DoorState.Closing => _closingColor,\n            _ => _lockedColor\n        };\n\n        _doorMaterial.SetColor(_emissionProperty, targetColor);\n    }\n\n    public DoorState GetCurrentState()\n    {\n        return _currentState;\n    }\n\n    public bool IsLocked()\n    {\n        return _currentState == DoorState.Locked;\n    }\n\n    public bool IsOpen()\n    {\n        return _currentState == DoorState.Open;\n    }\n\n    private void OnDestroy()\n    {\n        if (_currentStateCoroutine != null)\n        {\n            StopCoroutine(_currentStateCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FishingSpot\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fishingRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"catchChance\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"fishTypes\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"Bass\",\n        \"Trout\",\n        \"Salmon\"\n      ]\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"rippleEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"splashSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_approach\",\n      \"trigger\": \"when player enters fishing range\",\n      \"actions\": [\n        {\n          \"action\": \"show fishing interaction prompt\"\n        },\n        {\n          \"action\": \"spawn ripple effects on water surface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_fishing_attempt\",\n      \"trigger\": \"when player uses fishing rod at this spot\",\n      \"actions\": [\n        {\n          \"action\": \"play water splash sound\"\n        },\n        {\n          \"action\": \"start fishing minigame\"\n        },\n        {\n          \"action\": \"determine catch success based on catch chance\"\n        },\n        {\n          \"action\": \"spawn random fish type if successful\"\n        },\n        {\n          \"action\": \"deactivate spot temporarily\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reactivate_spot\",\n      \"trigger\": \"when cooldown timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"reactivate fishing spot\"\n        },\n        {\n          \"action\": \"restore ripple effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_interaction\",\n      \"trigger\": \"when player leaves fishing range\",\n      \"actions\": [\n        {\n          \"action\": \"hide fishing interaction prompt\"\n        },\n        {\n          \"action\": \"stop ripple effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class FishingSpot : MonoBehaviour\n{\n    [Header(\"Fishing Configuration\")]\n    [SerializeField] private float _interactionRange = 3f;\n    [SerializeField] private float _fishingDuration = 5f;\n    [SerializeField] private float _catchChance = 0.7f;\n    [SerializeField] private int _maxFishCount = 10;\n    [SerializeField] private float _respawnTime = 30f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _rippleEffect;\n    [SerializeField] private ParticleSystem _bubbleParticles;\n    [SerializeField] private Animator _waterAnimator;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _castSound;\n    [SerializeField] private AudioClip _catchSound;\n    [SerializeField] private AudioClip _splashSound;\n    \n    [Header(\"Fish Types\")]\n    [SerializeField] private FishData[] _availableFish;\n    \n    [Header(\"Events\")]\n    public UnityEvent<FishData> OnFishCaught;\n    public UnityEvent OnFishingStarted;\n    public UnityEvent OnFishingFailed;\n    public UnityEvent OnSpotDepleted;\n    \n    private Transform _playerTransform;\n    private bool _isPlayerNearby;\n    private bool _isFishing;\n    private bool _isDepleted;\n    private int _currentFishCount;\n    private Coroutine _fishingCoroutine;\n    private Coroutine _respawnCoroutine;\n    \n    [System.Serializable]\n    public class FishData\n    {\n        public string fishName;\n        public Sprite fishIcon;\n        public float rarity; // 0-1, lower is rarer\n        public int value;\n        public float size;\n    }\n    \n    private void Start()\n    {\n        _currentFishCount = _maxFishCount;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_bubbleParticles != null && !_isDepleted)\n            _bubbleParticles.Play();\n    }\n    \n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleInput();\n    }\n    \n    private void CheckPlayerProximity()\n    {\n        GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n        if (player != null)\n        {\n            _playerTransform = player.transform;\n            float distance = Vector3.Distance(transform.position, _playerTransform.position);\n            _isPlayerNearby = distance <= _interactionRange && !_isDepleted;\n        }\n        else\n        {\n            _isPlayerNearby = false;\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (_isPlayerNearby && !_isFishing && Input.GetKeyDown(KeyCode.E))\n        {\n            StartFishing();\n        }\n        else if (_isFishing && Input.GetKeyDown(KeyCode.E))\n        {\n            StopFishing();\n        }\n    }\n    \n    private void StartFishing()\n    {\n        if (_isDepleted || _currentFishCount <= 0)\n        {\n            Debug.Log(\"Fishing spot is depleted!\");\n            return;\n        }\n        \n        _isFishing = true;\n        OnFishingStarted.Invoke();\n        \n        PlaySound(_castSound);\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", true);\n            \n        _fishingCoroutine = StartCoroutine(FishingProcess());\n    }\n    \n    private void StopFishing()\n    {\n        if (_fishingCoroutine != null)\n        {\n            StopCoroutine(_fishingCoroutine);\n            _fishingCoroutine = null;\n        }\n        \n        _isFishing = false;\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", false);\n    }\n    \n    private IEnumerator FishingProcess()\n    {\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _fishingDuration)\n        {\n            elapsedTime += Time.deltaTime;\n            \n            // Random chance for early bite\n            if (Random.value < 0.1f)\n            {\n                yield return new WaitForSeconds(Random.Range(0.5f, 2f));\n                break;\n            }\n            \n            yield return null;\n        }\n        \n        // Determine if catch is successful\n        bool catchSuccessful = Random.value < _catchChance;\n        \n        if (catchSuccessful)\n        {\n            CatchFish();\n        }\n        else\n        {\n            FailedCatch();\n        }\n        \n        _isFishing = false;\n        \n        if (_waterAnimator != null)\n            _waterAnimator.SetBool(\"IsFishing\", false);\n    }\n    \n    private void CatchFish()\n    {\n        if (_availableFish.Length == 0) return;\n        \n        FishData caughtFish = SelectRandomFish();\n        _currentFishCount--;\n        \n        PlaySound(_catchSound);\n        CreateRippleEffect();\n        \n        OnFishCaught.Invoke(caughtFish);\n        \n        Debug.Log($\"Caught: {caughtFish.fishName}!\");\n        \n        if (_currentFishCount <= 0)\n        {\n            DepleteFishingSpot();\n        }\n    }\n    \n    private void FailedCatch()\n    {\n        PlaySound(_splashSound);\n        OnFishingFailed.Invoke();\n        Debug.Log(\"The fish got away!\");\n    }\n    \n    private FishData SelectRandomFish()\n    {\n        float totalWeight = 0f;\n        foreach (var fish in _availableFish)\n        {\n            totalWeight += fish.rarity;\n        }\n        \n        float randomValue = Random.value * totalWeight;\n        float currentWeight = 0f;\n        \n        foreach (var fish in _availableFish)\n        {\n            currentWeight += fish.rarity;\n            if (randomValue <= currentWeight)\n            {\n                return fish;\n            }\n        }\n        \n        return _availableFish[0];\n    }\n    \n    private void CreateRippleEffect()\n    {\n        if (_rippleEffect != null)\n        {\n            GameObject ripple = Instantiate(_rippleEffect, transform.position, Quaternion.identity);\n            Destroy(ripple, 3f);\n        }\n    }\n    \n    private void DepleteFishingSpot()\n    {\n        _isDepleted = true;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Stop();\n            \n        OnSpotDepleted.Invoke();\n        \n        if (_respawnTime > 0)\n        {\n            _respawnCoroutine = StartCoroutine(RespawnFish());\n        }\n    }\n    \n    private IEnumerator RespawnFish()\n    {\n        yield return new WaitForSeconds(_respawnTime);\n        \n        _currentFishCount = _maxFishCount;\n        _isDepleted = false;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Play();\n            \n        Debug.Log(\"Fishing spot has been replenished!\");\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n        \n        if (_isDepleted)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawWireCube(transform.position + Vector3.up, Vector3.one * 0.5f);\n        }\n    }\n    \n    public bool IsAvailable()\n    {\n        return !_isDepleted && _currentFishCount > 0;\n    }\n    \n    public int GetRemainingFish()\n    {\n        return _currentFishCount;\n    }\n    \n    public void RefillSpot()\n    {\n        _currentFishCount = _maxFishCount;\n        _isDepleted = false;\n        \n        if (_bubbleParticles != null)\n            _bubbleParticles.Play();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ChaosEngine\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"behaviorTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"behaviorInterval\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"totalChaosTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"chaosDuration\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"lastBehaviorIndex\",\n      \"type\": \"int\",\n      \"default\": -1\n    },\n    {\n      \"name\": \"isInCalmState\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"spinSpeed\",\n      \"type\": \"float\",\n      \"default\": 180\n    },\n    {\n      \"name\": \"bounceForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"scaleMultiplier\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"teleportRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"forceStrength\",\n      \"type\": \"float\",\n      \"default\": 15\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"chaos_behavior_timer\",\n      \"trigger\": \"every frame during chaos mode\",\n      \"actions\": [\n        {\n          \"action\": \"increment behavior timer by frame time\"\n        },\n        {\n          \"action\": \"increment total chaos time by frame time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_random_behavior\",\n      \"trigger\": \"when behavior timer exceeds interval and not in calm state\",\n      \"actions\": [\n        {\n          \"action\": \"generate random number from zero to nineteen excluding last behavior index\"\n        },\n        {\n          \"action\": \"store new behavior index as last behavior index\"\n        },\n        {\n          \"action\": \"reset behavior timer to zero\"\n        },\n        {\n          \"action\": \"execute behavior based on random index\"\n        }\n      ]\n    },\n    {\n      \"name\": \"spin_behavior\",\n      \"trigger\": \"when behavior index is zero\",\n      \"actions\": [\n        {\n          \"action\": \"rotate object around random axis at spin speed for duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bounce_behavior\",\n      \"trigger\": \"when behavior index is one\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward force with bounce force strength\"\n        },\n        {\n          \"action\": \"add random horizontal force component\"\n        }\n      ]\n    },\n    {\n      \"name\": \"scale_pulse_behavior\",\n      \"trigger\": \"when behavior index is two\",\n      \"actions\": [\n        {\n          \"action\": \"animate scale from current size to scale multiplier and back over duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"color_shift_behavior\",\n      \"trigger\": \"when behavior index is three\",\n      \"actions\": [\n        {\n          \"action\": \"change material color to random bright color\"\n        },\n        {\n          \"action\": \"animate color transition over half the duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"audio_play_behavior\",\n      \"trigger\": \"when behavior index is four\",\n      \"actions\": [\n        {\n          \"action\": \"play random audio clip from collection\"\n        },\n        {\n          \"action\": \"set random pitch between half and double speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"particle_burst_behavior\",\n      \"trigger\": \"when behavior index is five\",\n      \"actions\": [\n        {\n          \"action\": \"emit burst of particles with random colors\"\n        },\n        {\n          \"action\": \"set particle velocity in random directions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"force_application_behavior\",\n      \"trigger\": \"when behavior index is six\",\n      \"actions\": [\n        {\n          \"action\": \"apply force in random direction with force strength\"\n        },\n        {\n          \"action\": \"add random torque for spinning effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"teleport_behavior\",\n      \"trigger\": \"when behavior index is seven\",\n      \"actions\": [\n        {\n          \"action\": \"move object to random position within teleport range\"\n        },\n        {\n          \"action\": \"create visual effect at old and new positions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rapid_rotation_behavior\",\n      \"trigger\": \"when behavior index is eight\",\n      \"actions\": [\n        {\n          \"action\": \"rotate rapidly around all three axes simultaneously\"\n        }\n      ]\n    },\n    {\n      \"name\": \"gravity_flip_behavior\",\n      \"trigger\": \"when behavior index is nine\",\n      \"actions\": [\n        {\n          \"action\": \"reverse gravity direction for the object temporarily\"\n        }\n      ]\n    },\n    {\n      \"name\": \"size_randomize_behavior\",\n      \"trigger\": \"when behavior index is ten\",\n      \"actions\": [\n        {\n          \"action\": \"set scale to random value between half and triple size\"\n        }\n      ]\n    },\n    {\n      \"name\": \"material_swap_behavior\",\n      \"trigger\": \"when behavior index is eleven\",\n      \"actions\": [\n        {\n          \"action\": \"change to random material from predefined collection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"vibration_behavior\",\n      \"trigger\": \"when behavior index is twelve\",\n      \"actions\": [\n        {\n          \"action\": \"shake position rapidly in small random movements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"trail_behavior\",\n      \"trigger\": \"when behavior index is thirteen\",\n      \"actions\": [\n        {\n          \"action\": \"enable trail renderer with random color\"\n        },\n        {\n          \"action\": \"move in curved path to create visible trail\"\n        }\n      ]\n    },\n    {\n      \"name\": \"phase_behavior\",\n      \"trigger\": \"when behavior index is fourteen\",\n      \"actions\": [\n        {\n          \"action\": \"make object semi-transparent and disable collisions temporarily\"\n        }\n      ]\n    },\n    {\n      \"name\": \"magnetic_behavior\",\n      \"trigger\": \"when behavior index is fifteen\",\n      \"actions\": [\n        {\n          \"action\": \"attract or repel nearby objects with invisible force\"\n        }\n      ]\n    },\n    {\n      \"name\": \"clone_behavior\",\n      \"trigger\": \"when behavior index is sixteen\",\n      \"actions\": [\n        {\n          \"action\": \"create temporary duplicate at random nearby position\"\n        },\n        {\n          \"action\": \"destroy duplicate after short delay\"\n        }\n      ]\n    },\n    {\n      \"name\": \"orbit_behavior\",\n      \"trigger\": \"when behavior index is seventeen\",\n      \"actions\": [\n        {\n          \"action\": \"move in circular orbit around original position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"strobe_behavior\",\n      \"trigger\": \"when behavior index is eighteen\",\n      \"actions\": [\n        {\n          \"action\": \"rapidly toggle visibility on and off\"\n        }\n      ]\n    },\n    {\n      \"name\": \"explosion_behavior\",\n      \"trigger\": \"when behavior index is nineteen\",\n      \"actions\": [\n        {\n          \"action\": \"create expanding sphere effect around object\"\n        },\n        {\n          \"action\": \"push away nearby objects with force\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enter_calm_state\",\n      \"trigger\": \"when total chaos time exceeds chaos duration\",\n      \"actions\": [\n        {\n          \"action\": \"set calm state flag to true\"\n        },\n        {\n          \"action\": \"stop all chaotic movements\"\n        },\n        {\n          \"action\": \"gradually return to original scale and rotation\"\n        },\n        {\n          \"action\": \"fade to peaceful blue color\"\n        },\n        {\n          \"action\": \"play soft ambient sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_calm_state\",\n      \"trigger\": \"when in calm state\",\n      \"actions\": [\n        {\n          \"action\": \"gently float up and down with slow breathing motion\"\n        },\n        {\n          \"action\": \"emit soft particle effects occasionally\"\n        },\n        {\n          \"action\": \"maintain peaceful blue color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class ChaosEngine : MonoBehaviour\n{\n    [Header(\"Chaos Settings\")]\n    [SerializeField] private float _behaviorInterval = 3f;\n    [SerializeField] private float _chaosModeDuration = 60f;\n    [SerializeField] private bool _startInChaosMode = true;\n    \n    [Header(\"Movement Behaviors\")]\n    [SerializeField] private float _spinSpeed = 360f;\n    [SerializeField] private float _bounceForce = 10f;\n    [SerializeField] private float _teleportRadius = 20f;\n    [SerializeField] private float _forceStrength = 500f;\n    \n    [Header(\"Visual Behaviors\")]\n    [SerializeField] private AnimationCurve _scalePulseCurve = AnimationCurve.EaseInOut(0, 1, 1, 2);\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private Color[] _colorShiftColors = { Color.red, Color.blue, Color.green, Color.yellow, Color.magenta };\n    [SerializeField] private float _colorShiftDuration = 1f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip[] _chaosAudioClips;\n    [SerializeField] private AudioClip _meditativeAudioClip;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    [Header(\"Particles\")]\n    [SerializeField] private ParticleSystem _particleSystem;\n    [SerializeField] private int _burstParticleCount = 50;\n    \n    [Header(\"Meditative State\")]\n    [SerializeField] private float _meditativeRotationSpeed = 30f;\n    [SerializeField] private Color _meditativeColor = Color.white;\n    [SerializeField] private float _meditativeTransitionDuration = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnChaosStart;\n    public UnityEvent OnMeditativeStateEnter;\n    \n    private enum ChaoseBehavior\n    {\n        Spin, Bounce, ScalePulse, ColorShift, AudioPlay, ParticleBurst,\n        ForceApplication, Teleport, RotationFlip, Shake, Orbit, Wobble,\n        FlashScale, RandomJump, ColorCycle, SpeedBurst, GravityFlip,\n        Vibrate, SizeOscillate, DirectionalSpin\n    }\n    \n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Vector3 _originalScale;\n    private Vector3 _originalPosition;\n    private Color _originalColor;\n    \n    private bool _isInChaosMode = true;\n    private bool _isInMeditativeState = false;\n    private float _chaosTimer = 0f;\n    private ChaoseBehavior _lastBehavior = ChaoseBehavior.Spin;\n    private Coroutine _currentBehaviorCoroutine;\n    private Coroutine _meditativeTransitionCoroutine;\n    \n    private List<ChaoseBehavior> _availableBehaviors;\n    \n    void Start()\n    {\n        InitializeComponents();\n        InitializeBehaviors();\n        \n        if (_startInChaosMode)\n        {\n            StartChaosMode();\n        }\n    }\n    \n    void Update()\n    {\n        if (_isInChaosMode && !_isInMeditativeState)\n        {\n            _chaosTimer += Time.deltaTime;\n            \n            if (_chaosTimer >= _chaosModeDuration)\n            {\n                EnterMeditativeState();\n            }\n        }\n    }\n    \n    private void InitializeComponents()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n            _renderer = GetComponentInChildren<Renderer>();\n            \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_particleSystem == null)\n            _particleSystem = GetComponentInChildren<ParticleSystem>();\n        \n        _originalScale = transform.localScale;\n        _originalPosition = transform.position;\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n            _originalColor = _renderer.material.color;\n        }\n    }\n    \n    private void InitializeBehaviors()\n    {\n        _availableBehaviors = new List<ChaoseBehavior>();\n        for (int i = 0; i < System.Enum.GetValues(typeof(ChaoseBehavior)).Length; i++)\n        {\n            _availableBehaviors.Add((ChaoseBehavior)i);\n        }\n    }\n    \n    private void StartChaosMode()\n    {\n        _isInChaosMode = true;\n        _chaosTimer = 0f;\n        OnChaosStart?.Invoke();\n        StartCoroutine(ChaosLoop());\n    }\n    \n    private IEnumerator ChaosLoop()\n    {\n        while (_isInChaosMode && !_isInMeditativeState)\n        {\n            ChaoseBehavior nextBehavior = GetRandomBehavior();\n            ExecuteBehavior(nextBehavior);\n            _lastBehavior = nextBehavior;\n            \n            yield return new WaitForSeconds(_behaviorInterval);\n        }\n    }\n    \n    private ChaoseBehavior GetRandomBehavior()\n    {\n        List<ChaoseBehavior> availableChoices = new List<ChaoseBehavior>(_availableBehaviors);\n        availableChoices.Remove(_lastBehavior);\n        \n        return availableChoices[Random.Range(0, availableChoices.Count)];\n    }\n    \n    private void ExecuteBehavior(ChaoseBehavior behavior)\n    {\n        if (_currentBehaviorCoroutine != null)\n            StopCoroutine(_currentBehaviorCoroutine);\n            \n        switch (behavior)\n        {\n            case ChaoseBehavior.Spin:\n                _currentBehaviorCoroutine = StartCoroutine(SpinBehavior());\n                break;\n            case ChaoseBehavior.Bounce:\n                _currentBehaviorCoroutine = StartCoroutine(BounceBehavior());\n                break;\n            case ChaoseBehavior.ScalePulse:\n                _currentBehaviorCoroutine = StartCoroutine(ScalePulseBehavior());\n                break;\n            case ChaoseBehavior.ColorShift:\n                _currentBehaviorCoroutine = StartCoroutine(ColorShiftBehavior());\n                break;\n            case ChaoseBehavior.AudioPlay:\n                _currentBehaviorCoroutine = StartCoroutine(AudioPlayBehavior());\n                break;\n            case ChaoseBehavior.ParticleBurst:\n                _currentBehaviorCoroutine = StartCoroutine(ParticleBurstBehavior());\n                break;\n            case ChaoseBehavior.ForceApplication:\n                _currentBehaviorCoroutine = StartCoroutine(ForceApplicationBehavior());\n                break;\n            case ChaoseBehavior.Teleport:\n                _currentBehaviorCoroutine = StartCoroutine(TeleportBehavior());\n                break;\n            case ChaoseBehavior.RotationFlip:\n                _currentBehaviorCoroutine = StartCoroutine(RotationFlipBehavior());\n                break;\n            case ChaoseBehavior.Shake:\n                _currentBehaviorCoroutine = StartCoroutine(ShakeBehavior());\n                break;\n            case ChaoseBehavior.Orbit:\n                _currentBehaviorCoroutine = StartCoroutine(OrbitBehavior());\n                break;\n            case ChaoseBehavior.Wobble:\n                _currentBehaviorCoroutine = StartCoroutine(WobbleBehavior());\n                break;\n            case ChaoseBehavior.FlashScale:\n                _currentBehaviorCoroutine = StartCoroutine(FlashScaleBehavior());\n                break;\n            case ChaoseBehavior.RandomJump:\n                _currentBehaviorCoroutine = StartCoroutine(RandomJumpBehavior());\n                break;\n            case ChaoseBehavior.ColorCycle:\n                _currentBehaviorCoroutine = StartCoroutine(ColorCycleBehavior());\n                break;\n            case ChaoseBehavior.SpeedBurst:\n                _currentBehaviorCoroutine = StartCoroutine(SpeedBurstBehavior());\n                break;\n            case ChaoseBehavior.GravityFlip:\n                _currentBehaviorCoroutine = StartCoroutine(GravityFlipBehavior());\n                break;\n            case ChaoseBehavior.Vibrate:\n                _currentBehaviorCoroutine = StartCoroutine(VibrateBehavior());\n                break;\n            case ChaoseBehavior.SizeOscillate:\n                _currentBehaviorCoroutine = StartCoroutine(SizeOscillateBehavior());\n                break;\n            case ChaoseBehavior.DirectionalSpin:\n                _currentBehaviorCoroutine = StartCoroutine(DirectionalSpinBehavior());\n                break;\n        }\n    }\n    \n    private IEnumerator SpinBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        Vector3 spinAxis = Random.insideUnitSphere.normalized;\n        \n        while (elapsed < duration)\n        {\n            transform.Rotate(spinAxis * _spinSpeed * Time.deltaTime);\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n    }\n    \n    private IEnumerator BounceBehavior()\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 bounceDirection = Vector3.up + Random.insideUnitSphere * 0.5f;\n            _rigidbody.AddForce(bounceDirection.normalized * _bounceForce, ForceMode.Impulse);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ScalePulseBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float normalizedTime = elapsed / duration;\n            float scaleMultiplier = _scalePulseCurve.Evaluate(normalizedTime * _pulseSpeed % 1f);\n            transform.localScale = _originalScale * scaleMultiplier;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n    }\n    \n    private IEnumerator ColorShiftBehavior()\n    {\n        if (_renderer != null && _colorShiftColors.Length > 0)\n        {\n            Color targetColor = _colorShiftColors[Random.Range(0, _colorShiftColors.Length)];\n            Color startColor = _renderer.material.color;\n            float elapsed = 0f;\n            \n            while (elapsed < _colorShiftDuration)\n            {\n                _renderer.material.color = Color.Lerp(startColor, targetColor, elapsed / _colorShiftDuration);\n                elapsed += Time.deltaTime;\n                yield return null;\n            }\n        }\n        yield return null;\n    }\n    \n    private IEnumerator AudioPlayBehavior()\n    {\n        if (_audioSource != null && _chaosAudioClips.Length > 0)\n        {\n            AudioClip clip = _chaosAudioClips[Random.Range(0, _chaosAudioClips.Length)];\n            _audioSource.clip = clip;\n            _audioSource.volume = _audioVolume;\n            _audioSource.Play();\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ParticleBurstBehavior()\n    {\n        if (_particleSystem != null)\n        {\n            _particleSystem.Emit(_burstParticleCount);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator ForceApplicationBehavior()\n    {\n        if (_rigidbody != null)\n        {\n            Vector3 randomForce = Random.insideUnitSphere * _forceStrength;\n            _rigidbody.AddForce(randomForce, ForceMode.Impulse);\n        }\n        yield return null;\n    }\n    \n    private IEnumerator TeleportBehavior()\n    {\n        Vector3 randomOffset = Random.insideUnitSphere * _teleportRadius;\n        randomOffset.y = Mathf.Abs(randomOffset.y);\n        transform.position = _originalPosition + randomOffset;\n        yield return null;\n    }\n    \n    private IEnumerator RotationFlipBehavior()\n    {\n        Vector3 randomRotation = new Vector3(\n            Random.Range(0, 360),\n            Random.Range(0, 360),\n            Random.Range(0, 360)\n        );\n        transform.rotation = Quaternion.Euler(randomRotation);\n        yield return null;\n    }\n    \n    private IEnumerator ShakeBehavior()\n    {\n        float duration = _behaviorInterval * 0.6f;\n        float elapsed = 0f;\n        Vector3 originalPos = transform.position;\n        \n        while (elapsed < duration)\n        {\n            Vector3 shakeOffset = Random.insideUnitSphere * 0.5f;\n            transform.position = originalPos + shakeOffset;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.position = originalPos;\n    }\n    \n    private IEnumerator OrbitBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        Vector3 center = _originalPosition;\n        float radius = 5f;\n        \n        while (elapsed < duration)\n        {\n            float angle = (elapsed / duration) * 360f * 2f;\n            Vector3 offset = new Vector3(\n                Mathf.Cos(angle * Mathf.Deg2Rad) * radius,\n                Mathf.Sin(angle * Mathf.Deg2Rad) * radius * 0.5f,\n                Mathf.Sin(angle * Mathf.Deg2Rad * 0.5f) * radius\n            );\n            transform.position = center + offset;\n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n    }\n    \n    private IEnumerator WobbleBehavior()\n    {\n        float duration = _behaviorInterval * 0.8f;\n        float elapsed = 0f;\n        \n        while (elapsed < duration)\n        {\n            float wobbleX = Mathf.Sin(elapsed * 10f) * 0.3f;\n            float wobbleZ = Mathf.Cos(elapsed * 8f) * 0.3f;\n            transform.localScale = _originalScale + new Vector3(wobbleX, 0, wobbleZ);\n            elapsed += Time.deltaTime;\n            yield return null;"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AlarmSystem\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"isTriggered\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"alarmDuration\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"playerTag\",\n      \"type\": \"string\",\n      \"default\": \"Player\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection radius\",\n      \"actions\": [\n        {\n          \"action\": \"set alarm as triggered\"\n        },\n        {\n          \"action\": \"play alarm sound\"\n        },\n        {\n          \"action\": \"start alarm duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_alarm\",\n      \"trigger\": \"when alarm duration timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"stop alarm sound\"\n        },\n        {\n          \"action\": \"set alarm as not triggered\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_on_player_exit\",\n      \"trigger\": \"when player exits detection radius and alarm is not triggered\",\n      \"actions\": [\n        {\n          \"action\": \"ensure alarm remains inactive\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class AlarmSystem : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 10f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    [SerializeField] private string _targetTag = \"Player\";\n    [SerializeField] private bool _requireLineOfSight = true;\n    [SerializeField] private LayerMask _obstacleLayers = 1;\n    \n    [Header(\"Alarm Settings\")]\n    [SerializeField] private float _alarmDuration = 5f;\n    [SerializeField] private float _cooldownTime = 2f;\n    [SerializeField] private bool _resetOnLostTarget = true;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _alarmSound;\n    [SerializeField] private bool _loopAlarmSound = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _alarmLight;\n    [SerializeField] private Color _normalLightColor = Color.white;\n    [SerializeField] private Color _alarmLightColor = Color.red;\n    [SerializeField] private float _flashSpeed = 2f;\n    [SerializeField] private Renderer _indicatorRenderer;\n    [SerializeField] private Material _normalMaterial;\n    [SerializeField] private Material _alarmMaterial;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onAlarmTriggered;\n    [SerializeField] private UnityEvent _onAlarmStopped;\n    [SerializeField] private UnityEvent _onTargetDetected;\n    [SerializeField] private UnityEvent _onTargetLost;\n    \n    private bool _isAlarmActive = false;\n    private bool _targetDetected = false;\n    private bool _isOnCooldown = false;\n    private float _alarmTimer = 0f;\n    private float _cooldownTimer = 0f;\n    private Transform _currentTarget;\n    private Coroutine _flashCoroutine;\n    \n    private enum AlarmState\n    {\n        Idle,\n        Detecting,\n        Alarming,\n        Cooldown\n    }\n    \n    private AlarmState _currentState = AlarmState.Idle;\n    \n    void Start()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_alarmLight == null)\n            _alarmLight = GetComponentInChildren<Light>();\n            \n        if (_indicatorRenderer == null)\n            _indicatorRenderer = GetComponent<Renderer>();\n            \n        SetNormalState();\n    }\n    \n    void Update()\n    {\n        switch (_currentState)\n        {\n            case AlarmState.Idle:\n                CheckForTargets();\n                break;\n                \n            case AlarmState.Detecting:\n                if (_targetDetected && _currentTarget != null)\n                {\n                    if (!_isOnCooldown)\n                    {\n                        TriggerAlarm();\n                    }\n                }\n                else\n                {\n                    _currentState = AlarmState.Idle;\n                }\n                break;\n                \n            case AlarmState.Alarming:\n                _alarmTimer -= Time.deltaTime;\n                \n                if (_resetOnLostTarget && !_targetDetected)\n                {\n                    StopAlarm();\n                }\n                else if (_alarmTimer <= 0f)\n                {\n                    StopAlarm();\n                }\n                break;\n                \n            case AlarmState.Cooldown:\n                _cooldownTimer -= Time.deltaTime;\n                if (_cooldownTimer <= 0f)\n                {\n                    _isOnCooldown = false;\n                    _currentState = AlarmState.Idle;\n                }\n                break;\n        }\n        \n        CheckForTargets();\n    }\n    \n    void CheckForTargets()\n    {\n        bool previousDetection = _targetDetected;\n        _targetDetected = false;\n        _currentTarget = null;\n        \n        Collider[] colliders = Physics.OverlapSphere(transform.position, _detectionRadius, _targetLayers);\n        \n        foreach (Collider col in colliders)\n        {\n            if (!string.IsNullOrEmpty(_targetTag) && !col.CompareTag(_targetTag))\n                continue;\n                \n            if (_requireLineOfSight)\n            {\n                Vector3 directionToTarget = (col.transform.position - transform.position).normalized;\n                float distanceToTarget = Vector3.Distance(transform.position, col.transform.position);\n                \n                if (Physics.Raycast(transform.position, directionToTarget, distanceToTarget, _obstacleLayers))\n                    continue;\n            }\n            \n            _targetDetected = true;\n            _currentTarget = col.transform;\n            \n            if (_currentState == AlarmState.Idle)\n            {\n                _currentState = AlarmState.Detecting;\n            }\n            \n            break;\n        }\n        \n        if (previousDetection && !_targetDetected)\n        {\n            _onTargetLost?.Invoke();\n        }\n        else if (!previousDetection && _targetDetected)\n        {\n            _onTargetDetected?.Invoke();\n        }\n    }\n    \n    void TriggerAlarm()\n    {\n        if (_isAlarmActive || _isOnCooldown)\n            return;\n            \n        _isAlarmActive = true;\n        _currentState = AlarmState.Alarming;\n        _alarmTimer = _alarmDuration;\n        \n        if (_audioSource != null && _alarmSound != null)\n        {\n            _audioSource.clip = _alarmSound;\n            _audioSource.loop = _loopAlarmSound;\n            _audioSource.Play();\n        }\n        \n        if (_alarmLight != null)\n        {\n            _alarmLight.color = _alarmLightColor;\n            if (_flashCoroutine != null)\n                StopCoroutine(_flashCoroutine);\n            _flashCoroutine = StartCoroutine(FlashLight());\n        }\n        \n        if (_indicatorRenderer != null && _alarmMaterial != null)\n        {\n            _indicatorRenderer.material = _alarmMaterial;\n        }\n        \n        _onAlarmTriggered?.Invoke();\n    }\n    \n    void StopAlarm()\n    {\n        if (!_isAlarmActive)\n            return;\n            \n        _isAlarmActive = false;\n        _currentState = AlarmState.Cooldown;\n        _cooldownTimer = _cooldownTime;\n        _isOnCooldown = true;\n        \n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n        }\n        \n        if (_flashCoroutine != null)\n        {\n            StopCoroutine(_flashCoroutine);\n            _flashCoroutine = null;\n        }\n        \n        SetNormalState();\n        _onAlarmStopped?.Invoke();\n    }\n    \n    void SetNormalState()\n    {\n        if (_alarmLight != null)\n        {\n            _alarmLight.color = _normalLightColor;\n        }\n        \n        if (_indicatorRenderer != null && _normalMaterial != null)\n        {\n            _indicatorRenderer.material = _normalMaterial;\n        }\n    }\n    \n    IEnumerator FlashLight()\n    {\n        while (_isAlarmActive)\n        {\n            if (_alarmLight != null)\n            {\n                _alarmLight.enabled = !_alarmLight.enabled;\n            }\n            yield return new WaitForSeconds(1f / _flashSpeed);\n        }\n        \n        if (_alarmLight != null)\n        {\n            _alarmLight.enabled = true;\n        }\n    }\n    \n    public void ForceStopAlarm()\n    {\n        StopAlarm();\n    }\n    \n    public void ResetAlarm()\n    {\n        StopAlarm();\n        _isOnCooldown = false;\n        _currentState = AlarmState.Idle;\n    }\n    \n    public bool IsAlarmActive()\n    {\n        return _isAlarmActive;\n    }\n    \n    public bool IsTargetDetected()\n    {\n        return _targetDetected;\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = _targetDetected ? Color.red : Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        if (_currentTarget != null)\n        {\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(transform.position, _currentTarget.position);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AbilityScroll\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"abilityName\",\n      \"type\": \"string\",\n      \"default\": \"Fireball\"\n    },\n    {\n      \"name\": \"abilityDescription\",\n      \"type\": \"string\",\n      \"default\": \"Launches a fiery projectile\"\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"bobHeight\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"bobSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"isConsumed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_and_glow\",\n      \"trigger\": \"always while not consumed\",\n      \"actions\": [\n        {\n          \"action\": \"rotate slowly around vertical axis\"\n        },\n        {\n          \"action\": \"bob up and down gently\"\n        },\n        {\n          \"action\": \"emit magical glow effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"teach_ability\",\n      \"trigger\": \"when player touches scroll\",\n      \"actions\": [\n        {\n          \"action\": \"display ability learning notification with name and description\"\n        },\n        {\n          \"action\": \"add new ability to player ability list\"\n        },\n        {\n          \"action\": \"play magical learning sound effect\"\n        },\n        {\n          \"action\": \"create sparkle particle effect\"\n        },\n        {\n          \"action\": \"mark scroll as consumed\"\n        },\n        {\n          \"action\": \"fade out and destroy scroll object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"highlight_on_approach\",\n      \"trigger\": \"when player is nearby\",\n      \"actions\": [\n        {\n          \"action\": \"increase glow intensity\"\n        },\n        {\n          \"action\": \"display ability name above scroll\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_highlight\",\n      \"trigger\": \"when player moves away\",\n      \"actions\": [\n        {\n          \"action\": \"return glow to normal intensity\"\n        },\n        {\n          \"action\": \"hide ability name display\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class AbilityScroll : MonoBehaviour\n{\n    [Header(\"Scroll Settings\")]\n    [SerializeField] private string _abilityName = \"New Ability\";\n    [SerializeField] private string _abilityDescription = \"You have learned a new ability!\";\n    [SerializeField] private Sprite _abilityIcon;\n    [SerializeField] private KeyCode _abilityKey = KeyCode.Q;\n    [SerializeField] private float _abilityCooldown = 5f;\n    [SerializeField] private float _abilityDuration = 3f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _glowEffect;\n    [SerializeField] private ParticleSystem _learnEffect;\n    [SerializeField] private AudioClip _learnSound;\n    [SerializeField] private float _floatSpeed = 1f;\n    [SerializeField] private float _floatHeight = 0.5f;\n    \n    [Header(\"UI\")]\n    [SerializeField] private Canvas _abilityUI;\n    [SerializeField] private UnityEngine.UI.Text _abilityNameText;\n    [SerializeField] private UnityEngine.UI.Text _abilityDescriptionText;\n    [SerializeField] private UnityEngine.UI.Image _abilityIconImage;\n    [SerializeField] private UnityEngine.UI.Text _keyBindText;\n    [SerializeField] private float _uiDisplayTime = 3f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<string> OnAbilityLearned;\n    public UnityEvent OnScrollCollected;\n    \n    private Vector3 _startPosition;\n    private bool _isLearned = false;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    private Renderer _renderer;\n    private GameObject _currentPlayer;\n    \n    [System.Serializable]\n    public class LearnedAbility\n    {\n        public string name;\n        public string description;\n        public KeyCode keyCode;\n        public float cooldown;\n        public float duration;\n        public bool isActive;\n        public float lastUsedTime;\n        \n        public bool CanUse()\n        {\n            return Time.time >= lastUsedTime + cooldown;\n        }\n        \n        public void Use()\n        {\n            lastUsedTime = Time.time;\n        }\n    }\n    \n    private static System.Collections.Generic.List<LearnedAbility> _learnedAbilities = new System.Collections.Generic.List<LearnedAbility>();\n    \n    void Start()\n    {\n        _startPosition = transform.position;\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        _renderer = GetComponent<Renderer>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n            _collider.isTrigger = true;\n        }\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.SetActive(true);\n        }\n        \n        if (_abilityUI != null)\n        {\n            _abilityUI.gameObject.SetActive(false);\n        }\n    }\n    \n    void Update()\n    {\n        if (!_isLearned)\n        {\n            FloatAnimation();\n        }\n        \n        HandleAbilityInput();\n    }\n    \n    void FloatAnimation()\n    {\n        float newY = _startPosition.y + Mathf.Sin(Time.time * _floatSpeed) * _floatHeight;\n        transform.position = new Vector3(_startPosition.x, newY, _startPosition.z);\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.transform.Rotate(0, 50f * Time.deltaTime, 0);\n        }\n    }\n    \n    void HandleAbilityInput()\n    {\n        if (_currentPlayer == null) return;\n        \n        foreach (var ability in _learnedAbilities)\n        {\n            if (Input.GetKeyDown(ability.keyCode) && ability.CanUse())\n            {\n                ActivateAbility(ability);\n            }\n        }\n    }\n    \n    void ActivateAbility(LearnedAbility ability)\n    {\n        ability.Use();\n        ability.isActive = true;\n        \n        StartCoroutine(DeactivateAbilityAfterDuration(ability));\n        \n        Debug.Log($\"Activated ability: {ability.name}\");\n    }\n    \n    System.Collections.IEnumerator DeactivateAbilityAfterDuration(LearnedAbility ability)\n    {\n        yield return new WaitForSeconds(ability.duration);\n        ability.isActive = false;\n        Debug.Log($\"Deactivated ability: {ability.name}\");\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (_isLearned) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            LearnAbility(other.gameObject);\n        }\n    }\n    \n    void LearnAbility(GameObject player)\n    {\n        _isLearned = true;\n        _currentPlayer = player;\n        \n        LearnedAbility newAbility = new LearnedAbility\n        {\n            name = _abilityName,\n            description = _abilityDescription,\n            keyCode = _abilityKey,\n            cooldown = _abilityCooldown,\n            duration = _abilityDuration,\n            isActive = false,\n            lastUsedTime = -_abilityCooldown\n        };\n        \n        _learnedAbilities.Add(newAbility);\n        \n        PlayLearnEffects();\n        ShowAbilityUI();\n        \n        OnAbilityLearned?.Invoke(_abilityName);\n        OnScrollCollected?.Invoke();\n        \n        if (_collider != null)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_renderer != null)\n        {\n            _renderer.enabled = false;\n        }\n        \n        if (_glowEffect != null)\n        {\n            _glowEffect.SetActive(false);\n        }\n        \n        Destroy(gameObject, 2f);\n    }\n    \n    void PlayLearnEffects()\n    {\n        if (_learnEffect != null)\n        {\n            _learnEffect.Play();\n        }\n        \n        if (_learnSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_learnSound);\n        }\n    }\n    \n    void ShowAbilityUI()\n    {\n        if (_abilityUI == null) return;\n        \n        _abilityUI.gameObject.SetActive(true);\n        \n        if (_abilityNameText != null)\n        {\n            _abilityNameText.text = _abilityName;\n        }\n        \n        if (_abilityDescriptionText != null)\n        {\n            _abilityDescriptionText.text = _abilityDescription;\n        }\n        \n        if (_abilityIconImage != null && _abilityIcon != null)\n        {\n            _abilityIconImage.sprite = _abilityIcon;\n        }\n        \n        if (_keyBindText != null)\n        {\n            _keyBindText.text = $\"Press {_abilityKey} to use\";\n        }\n        \n        StartCoroutine(HideUIAfterDelay());\n    }\n    \n    System.Collections.IEnumerator HideUIAfterDelay()\n    {\n        yield return new WaitForSeconds(_uiDisplayTime);\n        \n        if (_abilityUI != null)\n        {\n            _abilityUI.gameObject.SetActive(false);\n        }\n    }\n    \n    public static bool HasAbility(string abilityName)\n    {\n        return _learnedAbilities.Exists(a => a.name == abilityName);\n    }\n    \n    public static bool IsAbilityActive(string abilityName)\n    {\n        var ability = _learnedAbilities.Find(a => a.name == abilityName);\n        return ability != null && ability.isActive;\n    }\n    \n    public static float GetAbilityCooldownRemaining(string abilityName)\n    {\n        var ability = _learnedAbilities.Find(a => a.name == abilityName);\n        if (ability == null) return 0f;\n        \n        float timeRemaining = (ability.lastUsedTime + ability.cooldown) - Time.time;\n        return Mathf.Max(0f, timeRemaining);\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, 1f);\n        \n        Gizmos.color = Color.blue;\n        Vector3 floatPos = transform.position + Vector3.up * _floatHeight;\n        Gizmos.DrawWireSphere(floatPos, 0.1f);\n        \n        Vector3 floatPosDown = transform.position - Vector3.up * _floatHeight;\n        Gizmos.DrawWireSphere(floatPosDown, 0.1f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FallingBoulder\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"hasTriggered\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_fall\",\n      \"trigger\": \"when player enters detection radius and boulder has not been triggered yet\",\n      \"actions\": [\n        {\n          \"action\": \"set hasTriggered to true\"\n        },\n        {\n          \"action\": \"enable physics on the boulder\"\n        },\n        {\n          \"action\": \"apply downward force to make boulder fall\"\n        },\n        {\n          \"action\": \"play falling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"impact_ground\",\n      \"trigger\": \"when boulder collides with ground or solid surface\",\n      \"actions\": [\n        {\n          \"action\": \"play impact sound effect\"\n        },\n        {\n          \"action\": \"create dust particle effect at impact point\"\n        },\n        {\n          \"action\": \"apply screen shake effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FallingBoulder : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float _detectionRadius = 5f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    [SerializeField] private string _playerTag = \"Player\";\n    \n    [Header(\"Boulder Settings\")]\n    [SerializeField] private float _fallSpeed = 10f;\n    [SerializeField] private float _fallAcceleration = 9.81f;\n    [SerializeField] private float _maxFallSpeed = 20f;\n    [SerializeField] private float _destroyDelay = 3f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _dustEffect;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _triggerSound;\n    [SerializeField] private AudioClip _impactSound;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private float _damageAmount = 50f;\n    [SerializeField] private float _damageRadius = 2f;\n    \n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private bool _isTriggered = false;\n    private bool _hasFallen = false;\n    private Vector3 _initialPosition;\n    private float _currentFallSpeed = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _collider = GetComponent<Collider>();\n        _initialPosition = transform.position;\n        \n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n    }\n    \n    private void Update()\n    {\n        if (!_isTriggered && !_hasFallen)\n        {\n            CheckForPlayer();\n        }\n        \n        if (_isTriggered && !_hasFallen)\n        {\n            HandleFalling();\n        }\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] playersInRange = Physics.OverlapSphere(transform.position, _detectionRadius, _playerLayer);\n        \n        foreach (Collider player in playersInRange)\n        {\n            if (player.CompareTag(_playerTag))\n            {\n                TriggerFall();\n                break;\n            }\n        }\n    }\n    \n    private void TriggerFall()\n    {\n        if (_isTriggered) return;\n        \n        _isTriggered = true;\n        _rigidbody.isKinematic = false;\n        _rigidbody.useGravity = true;\n        \n        if (_triggerSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_triggerSound);\n        }\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Play();\n        }\n    }\n    \n    private void HandleFalling()\n    {\n        _currentFallSpeed += _fallAcceleration * Time.deltaTime;\n        _currentFallSpeed = Mathf.Min(_currentFallSpeed, _maxFallSpeed);\n        \n        Vector3 velocity = _rigidbody.velocity;\n        velocity.y = -_currentFallSpeed;\n        _rigidbody.velocity = velocity;\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_hasFallen) return;\n        \n        if (collision.gameObject.CompareTag(\"Ground\") || collision.gameObject.layer == LayerMask.NameToLayer(\"Ground\"))\n        {\n            HandleImpact();\n        }\n        else if (collision.gameObject.CompareTag(_playerTag))\n        {\n            DealDamageToPlayer(collision.gameObject);\n            HandleImpact();\n        }\n    }\n    \n    private void HandleImpact()\n    {\n        _hasFallen = true;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.isKinematic = true;\n        \n        if (_impactSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_impactSound);\n        }\n        \n        DealAreaDamage();\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n            _dustEffect.Play();\n        }\n        \n        Invoke(nameof(DestroyBoulder), _destroyDelay);\n    }\n    \n    private void DealDamageToPlayer(GameObject player)\n    {\n        var playerHealth = player.GetComponent<Health>();\n        if (playerHealth != null)\n        {\n            playerHealth.TakeDamage(_damageAmount);\n        }\n    }\n    \n    private void DealAreaDamage()\n    {\n        Collider[] objectsInDamageRadius = Physics.OverlapSphere(transform.position, _damageRadius);\n        \n        foreach (Collider obj in objectsInDamageRadius)\n        {\n            if (obj.CompareTag(_playerTag))\n            {\n                var health = obj.GetComponent<Health>();\n                if (health != null)\n                {\n                    float distance = Vector3.Distance(transform.position, obj.transform.position);\n                    float damageMultiplier = 1f - (distance / _damageRadius);\n                    float finalDamage = _damageAmount * damageMultiplier;\n                    health.TakeDamage(finalDamage);\n                }\n            }\n        }\n    }\n    \n    private void DestroyBoulder()\n    {\n        Destroy(gameObject);\n    }\n    \n    public void ResetBoulder()\n    {\n        transform.position = _initialPosition;\n        _isTriggered = false;\n        _hasFallen = false;\n        _currentFallSpeed = 0f;\n        _rigidbody.isKinematic = true;\n        _rigidbody.useGravity = false;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_dustEffect != null)\n        {\n            _dustEffect.Stop();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRadius);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _damageRadius);\n    }\n    \n    [System.Serializable]\n    public class Health : MonoBehaviour\n    {\n        [SerializeField] private float _maxHealth = 100f;\n        [SerializeField] private float _currentHealth;\n        \n        private void Start()\n        {\n            _currentHealth = _maxHealth;\n        }\n        \n        public void TakeDamage(float damage)\n        {\n            _currentHealth -= damage;\n            _currentHealth = Mathf.Max(0, _currentHealth);\n            \n            if (_currentHealth <= 0)\n            {\n                Die();\n            }\n        }\n        \n        public void Heal(float amount)\n        {\n            _currentHealth += amount;\n            _currentHealth = Mathf.Min(_maxHealth, _currentHealth);\n        }\n        \n        private void Die()\n        {\n            gameObject.SetActive(false);\n        }\n        \n        public float GetCurrentHealth()\n        {\n            return _currentHealth;\n        }\n        \n        public float GetMaxHealth()\n        {\n            return _maxHealth;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Werewolf\",\n  \"components\": [\n    \"Transform\",\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isTransformed\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"transformationTime\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"humanSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"werewolfSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"night_transformation\",\n      \"trigger\": \"when night time begins\",\n      \"actions\": [\n        {\n          \"action\": \"play transformation animation\"\n        },\n        {\n          \"action\": \"play howling sound effect\"\n        },\n        {\n          \"action\": \"increase movement speed to werewolf speed\"\n        },\n        {\n          \"action\": \"set transformed state to true\"\n        },\n        {\n          \"action\": \"change appearance to werewolf form\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dawn_reversion\",\n      \"trigger\": \"when day time begins\",\n      \"actions\": [\n        {\n          \"action\": \"play reverse transformation animation\"\n        },\n        {\n          \"action\": \"decrease movement speed to human speed\"\n        },\n        {\n          \"action\": \"set transformed state to false\"\n        },\n        {\n          \"action\": \"change appearance to human form\"\n        }\n      ]\n    },\n    {\n      \"name\": \"werewolf_hunt\",\n      \"trigger\": \"when transformed and player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"growl menacingly\"\n        },\n        {\n          \"action\": \"chase player aggressively\"\n        },\n        {\n          \"action\": \"play aggressive werewolf animations\"\n        }\n      ]\n    },\n    {\n      \"name\": \"human_behavior\",\n      \"trigger\": \"when not transformed and player approaches\",\n      \"actions\": [\n        {\n          \"action\": \"act normally like a human NPC\"\n        },\n        {\n          \"action\": \"walk at normal human pace\"\n        },\n        {\n          \"action\": \"show no signs of being a werewolf\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class Werewolf : MonoBehaviour\n{\n    [System.Serializable]\n    public class WerewolfEvents\n    {\n        public UnityEvent OnTransformToWerewolf;\n        public UnityEvent OnTransformToHuman;\n    }\n\n    [Header(\"Transformation Settings\")]\n    [SerializeField] private float _nightStartHour = 20f;\n    [SerializeField] private float _nightEndHour = 6f;\n    [SerializeField] private float _transformationDuration = 2f;\n    [SerializeField] private bool _useRealTime = false;\n    [SerializeField] private float _gameTimeSpeed = 1f;\n\n    [Header(\"Werewolf Form\")]\n    [SerializeField] private GameObject _humanModel;\n    [SerializeField] private GameObject _werewolfModel;\n    [SerializeField] private float _werewolfSpeed = 8f;\n    [SerializeField] private float _werewolfJumpForce = 15f;\n    [SerializeField] private float _werewolfDamage = 50f;\n\n    [Header(\"Human Form\")]\n    [SerializeField] private float _humanSpeed = 4f;\n    [SerializeField] private float _humanJumpForce = 8f;\n    [SerializeField] private float _humanDamage = 10f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _transformationSound;\n    [SerializeField] private AudioClip _werewolfHowl;\n    [SerializeField] private AudioClip _werewolfGrowl;\n\n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _transformationEffect;\n    [SerializeField] private Light _moonlight;\n\n    [Header(\"Events\")]\n    [SerializeField] private WerewolfEvents _events;\n\n    private bool _isWerewolf = false;\n    private bool _isTransforming = false;\n    private float _currentGameTime = 12f; // Start at noon\n    private AudioSource _audioSource;\n    private Rigidbody _rigidbody;\n    private Collider _collider;\n    private Animator _humanAnimator;\n    private Animator _werewolfAnimator;\n    private float _transformTimer = 0f;\n\n    // Movement variables\n    private float _currentSpeed;\n    private float _currentJumpForce;\n    private float _currentDamage;\n    private bool _isGrounded = true;\n\n    private void Start()\n    {\n        InitializeComponents();\n        SetupInitialState();\n    }\n\n    private void InitializeComponents()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n\n        _collider = GetComponent<Collider>();\n\n        if (_humanModel != null)\n            _humanAnimator = _humanModel.GetComponent<Animator>();\n        \n        if (_werewolfModel != null)\n            _werewolfAnimator = _werewolfModel.GetComponent<Animator>();\n    }\n\n    private void SetupInitialState()\n    {\n        SetHumanForm();\n        \n        if (_moonlight != null)\n            _moonlight.enabled = false;\n    }\n\n    private void Update()\n    {\n        UpdateGameTime();\n        CheckTransformationConditions();\n        HandleTransformation();\n        HandleMovement();\n        UpdateAnimations();\n    }\n\n    private void UpdateGameTime()\n    {\n        if (_useRealTime)\n        {\n            System.DateTime currentTime = System.DateTime.Now;\n            _currentGameTime = currentTime.Hour + (currentTime.Minute / 60f);\n        }\n        else\n        {\n            _currentGameTime += Time.deltaTime * _gameTimeSpeed;\n            if (_currentGameTime >= 24f)\n                _currentGameTime -= 24f;\n        }\n    }\n\n    private void CheckTransformationConditions()\n    {\n        if (_isTransforming) return;\n\n        bool shouldBeWerewolf = IsNightTime();\n\n        if (shouldBeWerewolf && !_isWerewolf)\n        {\n            StartTransformation(true);\n        }\n        else if (!shouldBeWerewolf && _isWerewolf)\n        {\n            StartTransformation(false);\n        }\n    }\n\n    private bool IsNightTime()\n    {\n        if (_nightStartHour > _nightEndHour) // Night crosses midnight\n        {\n            return _currentGameTime >= _nightStartHour || _currentGameTime <= _nightEndHour;\n        }\n        else\n        {\n            return _currentGameTime >= _nightStartHour && _currentGameTime <= _nightEndHour;\n        }\n    }\n\n    private void StartTransformation(bool toWerewolf)\n    {\n        _isTransforming = true;\n        _transformTimer = 0f;\n\n        if (_transformationEffect != null)\n            _transformationEffect.Play();\n\n        if (_transformationSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_transformationSound);\n\n        if (toWerewolf)\n        {\n            _events?.OnTransformToWerewolf?.Invoke();\n            if (_werewolfHowl != null && _audioSource != null)\n                _audioSource.PlayOneShot(_werewolfHowl);\n        }\n        else\n        {\n            _events?.OnTransformToHuman?.Invoke();\n        }\n    }\n\n    private void HandleTransformation()\n    {\n        if (!_isTransforming) return;\n\n        _transformTimer += Time.deltaTime;\n\n        if (_transformTimer >= _transformationDuration)\n        {\n            CompleteTransformation();\n        }\n    }\n\n    private void CompleteTransformation()\n    {\n        _isTransforming = false;\n        \n        if (IsNightTime())\n        {\n            SetWerewolfForm();\n        }\n        else\n        {\n            SetHumanForm();\n        }\n    }\n\n    private void SetWerewolfForm()\n    {\n        _isWerewolf = true;\n        \n        if (_humanModel != null)\n            _humanModel.SetActive(false);\n        \n        if (_werewolfModel != null)\n            _werewolfModel.SetActive(true);\n\n        _currentSpeed = _werewolfSpeed;\n        _currentJumpForce = _werewolfJumpForce;\n        _currentDamage = _werewolfDamage;\n\n        if (_moonlight != null)\n            _moonlight.enabled = true;\n    }\n\n    private void SetHumanForm()\n    {\n        _isWerewolf = false;\n        \n        if (_werewolfModel != null)\n            _werewolfModel.SetActive(false);\n        \n        if (_humanModel != null)\n            _humanModel.SetActive(true);\n\n        _currentSpeed = _humanSpeed;\n        _currentJumpForce = _humanJumpForce;\n        _currentDamage = _humanDamage;\n\n        if (_moonlight != null)\n            _moonlight.enabled = false;\n    }\n\n    private void HandleMovement()\n    {\n        if (_isTransforming || _rigidbody == null) return;\n\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Vector3 movement = new Vector3(horizontal, 0f, vertical).normalized;\n        \n        if (movement.magnitude > 0.1f)\n        {\n            transform.rotation = Quaternion.LookRotation(movement);\n            _rigidbody.MovePosition(transform.position + movement * _currentSpeed * Time.deltaTime);\n        }\n\n        if (Input.GetButtonDown(\"Jump\") && _isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.up * _currentJumpForce, ForceMode.Impulse);\n            _isGrounded = false;\n        }\n    }\n\n    private void UpdateAnimations()\n    {\n        float speed = _rigidbody != null ? _rigidbody.velocity.magnitude : 0f;\n        \n        if (_isWerewolf && _werewolfAnimator != null)\n        {\n            _werewolfAnimator.SetFloat(\"Speed\", speed);\n            _werewolfAnimator.SetBool(\"IsGrounded\", _isGrounded);\n        }\n        else if (!_isWerewolf && _humanAnimator != null)\n        {\n            _humanAnimator.SetFloat(\"Speed\", speed);\n            _humanAnimator.SetBool(\"IsGrounded\", _isGrounded);\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Ground\"))\n        {\n            _isGrounded = true;\n        }\n\n        if (_isWerewolf && collision.gameObject.CompareTag(\"Player\"))\n        {\n            AttackTarget(collision.gameObject);\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isWerewolf && other.CompareTag(\"Player\"))\n        {\n            if (_werewolfGrowl != null && _audioSource != null)\n                _audioSource.PlayOneShot(_werewolfGrowl);\n        }\n    }\n\n    private void AttackTarget(GameObject target)\n    {\n        // Apply damage logic here\n        Debug.Log($\"Werewolf attacks {target.name} for {_currentDamage} damage!\");\n        \n        // Push the target away\n        Rigidbody targetRb = target.GetComponent<Rigidbody>();\n        if (targetRb != null)\n        {\n            Vector3 pushDirection = (target.transform.position - transform.position).normalized;\n            targetRb.AddForce(pushDirection * 10f, ForceMode.Impulse);\n        }\n    }\n\n    public bool IsWerewolfForm()\n    {\n        return _isWerewolf;\n    }\n\n    public float GetCurrentGameTime()\n    {\n        return _currentGameTime;\n    }\n\n    public void ForceTransformation(bool toWerewolf)\n    {\n        if (_isTransforming) return;\n        \n        StartTransformation(toWerewolf);\n    }\n\n    public void SetGameTime(float hour)\n    {\n        _currentGameTime = Mathf.Clamp(hour, 0f, 24f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WingGlide\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"glideSpeed\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"liftForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"dragCoefficient\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"minGlideHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"wingSpread\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_gliding\",\n      \"trigger\": \"when jump input is held while in air\",\n      \"actions\": [\n        {\n          \"action\": \"spread wings and enter glide mode\"\n        },\n        {\n          \"action\": \"reduce falling speed significantly\"\n        },\n        {\n          \"action\": \"apply forward momentum in facing direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_glide\",\n      \"trigger\": \"while gliding and above minimum height\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward lift force to counteract gravity\"\n        },\n        {\n          \"action\": \"maintain forward gliding motion\"\n        },\n        {\n          \"action\": \"apply air resistance to control speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_while_gliding\",\n      \"trigger\": \"when horizontal input is received during glide\",\n      \"actions\": [\n        {\n          \"action\": \"tilt wings in input direction\"\n        },\n        {\n          \"action\": \"gradually turn glide direction\"\n        },\n        {\n          \"action\": \"adjust lift distribution between wings\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_glide\",\n      \"trigger\": \"when jump input is released or ground is reached\",\n      \"actions\": [\n        {\n          \"action\": \"fold wings back to normal position\"\n        },\n        {\n          \"action\": \"restore normal falling physics\"\n        },\n        {\n          \"action\": \"exit glide mode\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class WingGlide : MonoBehaviour\n{\n    [Header(\"Glide Settings\")]\n    [SerializeField] private float _glideSpeed = 8f;\n    [SerializeField] private float _glideGravity = 2f;\n    [SerializeField] private float _normalGravity = 9.81f;\n    [SerializeField] private float _maxGlideTime = 10f;\n    [SerializeField] private KeyCode _glideKey = KeyCode.Space;\n    \n    [Header(\"Wing Animation\")]\n    [SerializeField] private Transform _leftWing;\n    [SerializeField] private Transform _rightWing;\n    [SerializeField] private float _wingFlapSpeed = 2f;\n    [SerializeField] private float _wingFlapAmount = 15f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _glideStartSound;\n    [SerializeField] private AudioClip _glideLoopSound;\n    [SerializeField] private AudioClip _glideEndSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _windTrailEffect;\n    [SerializeField] private Transform _cameraTransform;\n    [SerializeField] private float _cameraShakeAmount = 0.1f;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGliding = false;\n    private float _currentGlideTime = 0f;\n    private Vector3 _originalCameraPosition;\n    private float _wingFlapTimer = 0f;\n    private bool _canGlide = true;\n    private float _glideStamina = 100f;\n    private float _maxGlideStamina = 100f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        if (_cameraTransform == null)\n        {\n            Camera mainCamera = Camera.main;\n            if (mainCamera != null)\n            {\n                _cameraTransform = mainCamera.transform;\n            }\n        }\n        \n        if (_cameraTransform != null)\n        {\n            _originalCameraPosition = _cameraTransform.localPosition;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        _glideStamina = _maxGlideStamina;\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateWingAnimation();\n        UpdateStamina();\n        \n        if (_isGliding)\n        {\n            _currentGlideTime += Time.deltaTime;\n            \n            if (_currentGlideTime >= _maxGlideTime || _glideStamina <= 0f || !Input.GetKey(_glideKey))\n            {\n                StopGliding();\n            }\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        if (_isGliding)\n        {\n            ApplyGlidePhysics();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_glideKey) && _canGlide && _glideStamina > 10f && !_isGliding)\n        {\n            StartGliding();\n        }\n        \n        if (Input.GetKeyUp(_glideKey) && _isGliding)\n        {\n            StopGliding();\n        }\n    }\n    \n    private void StartGliding()\n    {\n        _isGliding = true;\n        _currentGlideTime = 0f;\n        _canGlide = true;\n        \n        // Reduce gravity for gliding effect\n        _rigidbody.drag = 1f;\n        \n        // Play start sound\n        if (_audioSource != null && _glideStartSound != null)\n        {\n            _audioSource.PlayOneShot(_glideStartSound);\n        }\n        \n        // Start loop sound\n        if (_audioSource != null && _glideLoopSound != null)\n        {\n            _audioSource.clip = _glideLoopSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n        \n        // Start particle effect\n        if (_windTrailEffect != null)\n        {\n            _windTrailEffect.Play();\n        }\n        \n        // Extend wings\n        AnimateWingsOpen();\n    }\n    \n    private void StopGliding()\n    {\n        _isGliding = false;\n        _currentGlideTime = 0f;\n        \n        // Restore normal physics\n        _rigidbody.drag = 0f;\n        \n        // Stop loop sound and play end sound\n        if (_audioSource != null)\n        {\n            _audioSource.Stop();\n            if (_glideEndSound != null)\n            {\n                _audioSource.PlayOneShot(_glideEndSound);\n            }\n        }\n        \n        // Stop particle effect\n        if (_windTrailEffect != null)\n        {\n            _windTrailEffect.Stop();\n        }\n        \n        // Fold wings\n        AnimateWingsClose();\n        \n        // Reset camera\n        if (_cameraTransform != null)\n        {\n            _cameraTransform.localPosition = _originalCameraPosition;\n        }\n    }\n    \n    private void ApplyGlidePhysics()\n    {\n        Vector3 velocity = _rigidbody.velocity;\n        \n        // Apply reduced gravity\n        Vector3 gravityForce = Vector3.up * (-_glideGravity * _rigidbody.mass);\n        _rigidbody.AddForce(gravityForce, ForceMode.Force);\n        \n        // Apply forward glide force\n        Vector3 forwardDirection = transform.forward;\n        Vector3 glideForce = forwardDirection * _glideSpeed;\n        _rigidbody.AddForce(glideForce, ForceMode.Force);\n        \n        // Limit vertical fall speed\n        if (velocity.y < -5f)\n        {\n            velocity.y = -5f;\n            _rigidbody.velocity = velocity;\n        }\n        \n        // Add slight camera shake for immersion\n        if (_cameraTransform != null)\n        {\n            Vector3 shakeOffset = new Vector3(\n                Random.Range(-_cameraShakeAmount, _cameraShakeAmount),\n                Random.Range(-_cameraShakeAmount, _cameraShakeAmount),\n                0f\n            );\n            _cameraTransform.localPosition = _originalCameraPosition + shakeOffset;\n        }\n    }\n    \n    private void UpdateWingAnimation()\n    {\n        if (_isGliding)\n        {\n            _wingFlapTimer += Time.deltaTime * _wingFlapSpeed;\n            float flapOffset = Mathf.Sin(_wingFlapTimer) * _wingFlapAmount;\n            \n            if (_leftWing != null)\n            {\n                _leftWing.localRotation = Quaternion.Euler(0f, 0f, flapOffset);\n            }\n            \n            if (_rightWing != null)\n            {\n                _rightWing.localRotation = Quaternion.Euler(0f, 0f, -flapOffset);\n            }\n        }\n    }\n    \n    private void AnimateWingsOpen()\n    {\n        if (_leftWing != null)\n        {\n            _leftWing.localRotation = Quaternion.Euler(0f, 0f, 45f);\n        }\n        \n        if (_rightWing != null)\n        {\n            _rightWing.localRotation = Quaternion.Euler(0f, 0f, -45f);\n        }\n    }\n    \n    private void AnimateWingsClose()\n    {\n        if (_leftWing != null)\n        {\n            _leftWing.localRotation = Quaternion.Euler(0f, 0f, 0f);\n        }\n        \n        if (_rightWing != null)\n        {\n            _rightWing.localRotation = Quaternion.Euler(0f, 0f, 0f);\n        }\n    }\n    \n    private void UpdateStamina()\n    {\n        if (_isGliding)\n        {\n            _glideStamina -= 20f * Time.deltaTime;\n            _glideStamina = Mathf.Max(0f, _glideStamina);\n        }\n        else\n        {\n            _glideStamina += 10f * Time.deltaTime;\n            _glideStamina = Mathf.Min(_maxGlideStamina, _glideStamina);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isGliding)\n        {\n            StopGliding();\n        }\n    }\n    \n    public bool IsGliding()\n    {\n        return _isGliding;\n    }\n    \n    public float GetGlideStamina()\n    {\n        return _glideStamina;\n    }\n    \n    public float GetGlideStaminaPercentage()\n    {\n        return _glideStamina / _maxGlideStamina;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RotatingBlade\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 180\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"rotationAxis\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_rotation\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around specified axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_player\",\n      \"trigger\": \"when player collides with blade\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage to player\"\n        },\n        {\n          \"action\": \"play metal clang sound effect\"\n        },\n        {\n          \"action\": \"create spark particle effect at collision point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_objects\",\n      \"trigger\": \"when destructible object touches blade\",\n      \"actions\": [\n        {\n          \"action\": \"destroy the object\"\n        },\n        {\n          \"action\": \"create debris particle effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class RotatingBlade : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 360f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 1;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotationSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private bool _playRotationSound = true;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private float _hitFlashDuration = 0.1f;\n    [SerializeField] private Color _hitFlashColor = Color.red;\n    \n    private Renderer _renderer;\n    private Color _originalColor;\n    private bool _isFlashing = false;\n    private float _flashTimer = 0f;\n    \n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = \n        new System.Collections.Generic.Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        _renderer = GetComponent<Renderer>();\n        if (_renderer != null && _renderer.material != null)\n        {\n            _originalColor = _renderer.material.color;\n        }\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _rotationSound != null && _playRotationSound)\n        {\n            _audioSource.clip = _rotationSound;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void Update()\n    {\n        RotateBlade();\n        HandleFlashEffect();\n    }\n\n    private void RotateBlade()\n    {\n        float rotationDirection = _clockwise ? 1f : -1f;\n        Vector3 rotation = _rotationAxis * _rotationSpeed * rotationDirection * Time.deltaTime;\n        transform.Rotate(rotation, Space.Self);\n    }\n\n    private void HandleFlashEffect()\n    {\n        if (_isFlashing)\n        {\n            _flashTimer -= Time.deltaTime;\n            if (_flashTimer <= 0f)\n            {\n                _isFlashing = false;\n                if (_renderer != null && _renderer.material != null)\n                {\n                    _renderer.material.color = _originalColor;\n                }\n            }\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other.gameObject);\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        HandleCollision(other.gameObject);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.gameObject);\n    }\n\n    private void OnCollisionStay(Collision collision)\n    {\n        HandleCollision(collision.gameObject);\n    }\n\n    private void HandleCollision(GameObject target)\n    {\n        if (target == null) return;\n        \n        if (!IsInDamageableLayer(target)) return;\n        \n        if (!CanDamageTarget(target)) return;\n        \n        DealDamage(target);\n        PlayHitEffects(target);\n        UpdateLastDamageTime(target);\n    }\n\n    private bool IsInDamageableLayer(GameObject target)\n    {\n        return (_damageableLayers.value & (1 << target.layer)) != 0;\n    }\n\n    private bool CanDamageTarget(GameObject target)\n    {\n        if (!_lastDamageTime.ContainsKey(target))\n        {\n            return true;\n        }\n        \n        return Time.time - _lastDamageTime[target] >= _damageInterval;\n    }\n\n    private void DealDamage(GameObject target)\n    {\n        if (target.CompareTag(\"Player\"))\n        {\n            var playerScript = target.GetComponent<MonoBehaviour>();\n            if (playerScript != null)\n            {\n                playerScript.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n        else\n        {\n            var healthComponent = target.GetComponent<MonoBehaviour>();\n            if (healthComponent != null)\n            {\n                healthComponent.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            }\n        }\n    }\n\n    private void PlayHitEffects(GameObject target)\n    {\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound);\n        }\n        \n        if (_sparkParticles != null)\n        {\n            _sparkParticles.transform.position = GetClosestPoint(target.transform.position);\n            _sparkParticles.Play();\n        }\n        \n        TriggerFlashEffect();\n    }\n\n    private void TriggerFlashEffect()\n    {\n        if (_renderer != null && _renderer.material != null)\n        {\n            _renderer.material.color = _hitFlashColor;\n            _isFlashing = true;\n            _flashTimer = _hitFlashDuration;\n        }\n    }\n\n    private Vector3 GetClosestPoint(Vector3 targetPosition)\n    {\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            return col.ClosestPoint(targetPosition);\n        }\n        return transform.position;\n    }\n\n    private void UpdateLastDamageTime(GameObject target)\n    {\n        _lastDamageTime[target] = Time.time;\n    }\n\n    private void OnDisable()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        _lastDamageTime.Clear();\n    }\n\n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = speed;\n    }\n\n    public void SetClockwise(bool clockwise)\n    {\n        _clockwise = clockwise;\n    }\n\n    public void SetDamage(int damage)\n    {\n        _damage = Mathf.Max(0, damage);\n    }\n\n    public void ToggleRotation()\n    {\n        enabled = !enabled;\n        \n        if (_audioSource != null)\n        {\n            if (enabled && _playRotationSound)\n            {\n                _audioSource.Play();\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ComboSystem\",\n  \"components\": [\n    \"Renderer\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"comboCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"comboTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"comboWindow\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"lowNote\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"higherNote\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionEffect\",\n      \"type\": \"ParticleSystem\",\n      \"default\": null\n    },\n    {\n      \"name\": \"bonusObjectPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"yellowColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.yellow\"\n    },\n    {\n      \"name\": \"orangeColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.orange\"\n    },\n    {\n      \"name\": \"redColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.red\"\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"Color\",\n      \"default\": \"Color.white\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"first_hit\",\n      \"trigger\": \"when object is hit and combo count is zero\",\n      \"actions\": [\n        {\n          \"action\": \"set combo count to one\"\n        },\n        {\n          \"action\": \"change object color to yellow\"\n        },\n        {\n          \"action\": \"play low note sound\"\n        },\n        {\n          \"action\": \"start combo timer at two seconds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"second_hit\",\n      \"trigger\": \"when object is hit and combo count is one and within combo window\",\n      \"actions\": [\n        {\n          \"action\": \"set combo count to two\"\n        },\n        {\n          \"action\": \"change object color to orange\"\n        },\n        {\n          \"action\": \"play higher note sound\"\n        },\n        {\n          \"action\": \"reset combo timer to two seconds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"third_hit\",\n      \"trigger\": \"when object is hit and combo count is two and within combo window\",\n      \"actions\": [\n        {\n          \"action\": \"set combo count to three\"\n        },\n        {\n          \"action\": \"change object color to red\"\n        },\n        {\n          \"action\": \"reset combo timer to two seconds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fourth_hit_explosion\",\n      \"trigger\": \"when object is hit and combo count is three and within combo window\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion particle effect\"\n        },\n        {\n          \"action\": \"spawn five bonus objects around this position\"\n        },\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"restore original object color\"\n        },\n        {\n          \"action\": \"stop combo timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"combo_timeout\",\n      \"trigger\": \"when combo timer reaches zero and combo count is greater than zero\",\n      \"actions\": [\n        {\n          \"action\": \"reset combo count to zero\"\n        },\n        {\n          \"action\": \"restore original object color\"\n        },\n        {\n          \"action\": \"stop combo timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_timer\",\n      \"trigger\": \"every frame when combo timer is active\",\n      \"actions\": [\n        {\n          \"action\": \"decrease combo timer by frame time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class ComboSystem : MonoBehaviour\n{\n    [Header(\"Combo Settings\")]\n    [SerializeField] private float _comboWindow = 2f;\n    [SerializeField] private int _maxComboLevel = 4;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Renderer _targetRenderer;\n    [SerializeField] private Color _normalColor = Color.white;\n    [SerializeField] private Color _combo1Color = Color.yellow;\n    [SerializeField] private Color _combo2Color = new Color(1f, 0.5f, 0f);\n    [SerializeField] private Color _combo3Color = Color.red;\n    [SerializeField] private ParticleSystem _explosionEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _lowNote;\n    [SerializeField] private AudioClip _midNote;\n    [SerializeField] private AudioClip _highNote;\n    [SerializeField] private AudioClip _explosionSound;\n    \n    [Header(\"Bonus Objects\")]\n    [SerializeField] private GameObject _bonusObjectPrefab;\n    [SerializeField] private int _bonusObjectCount = 5;\n    [SerializeField] private float _spawnRadius = 3f;\n    [SerializeField] private float _spawnForce = 5f;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnComboReset;\n    public UnityEvent OnComboComplete;\n    \n    private int _currentComboLevel = 0;\n    private Coroutine _comboResetCoroutine;\n    private Material _originalMaterial;\n    \n    private void Start()\n    {\n        InitializeComponents();\n        ResetCombo();\n    }\n    \n    private void InitializeComponents()\n    {\n        if (_targetRenderer == null)\n            _targetRenderer = GetComponent<Renderer>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_targetRenderer != null)\n        {\n            _originalMaterial = _targetRenderer.material;\n        }\n    }\n    \n    private void OnMouseDown()\n    {\n        ProcessHit();\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            ProcessHit();\n        }\n    }\n    \n    private void ProcessHit()\n    {\n        _currentComboLevel++;\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n        \n        switch (_currentComboLevel)\n        {\n            case 1:\n                HandleCombo1();\n                break;\n            case 2:\n                HandleCombo2();\n                break;\n            case 3:\n                HandleCombo3();\n                break;\n            case 4:\n                HandleCombo4();\n                return;\n        }\n        \n        _comboResetCoroutine = StartCoroutine(ComboResetTimer());\n    }\n    \n    private void HandleCombo1()\n    {\n        SetObjectColor(_combo1Color);\n        PlaySound(_lowNote, 0.8f);\n    }\n    \n    private void HandleCombo2()\n    {\n        SetObjectColor(_combo2Color);\n        PlaySound(_midNote, 1.0f);\n    }\n    \n    private void HandleCombo3()\n    {\n        SetObjectColor(_combo3Color);\n        PlaySound(_highNote, 1.2f);\n    }\n    \n    private void HandleCombo4()\n    {\n        CreateExplosionEffect();\n        PlaySound(_explosionSound, 1.0f);\n        SpawnBonusObjects();\n        OnComboComplete?.Invoke();\n        ResetCombo();\n    }\n    \n    private void SetObjectColor(Color color)\n    {\n        if (_targetRenderer != null && _originalMaterial != null)\n        {\n            _targetRenderer.material.color = color;\n        }\n    }\n    \n    private void PlaySound(AudioClip clip, float pitch)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.pitch = pitch;\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void CreateExplosionEffect()\n    {\n        if (_explosionEffect != null)\n        {\n            _explosionEffect.Play();\n        }\n    }\n    \n    private void SpawnBonusObjects()\n    {\n        if (_bonusObjectPrefab == null) return;\n        \n        for (int i = 0; i < _bonusObjectCount; i++)\n        {\n            Vector3 randomDirection = Random.insideUnitSphere.normalized;\n            Vector3 spawnPosition = transform.position + randomDirection * _spawnRadius;\n            \n            GameObject bonusObject = Instantiate(_bonusObjectPrefab, spawnPosition, Random.rotation);\n            \n            Rigidbody rb = bonusObject.GetComponent<Rigidbody>();\n            if (rb == null)\n            {\n                rb = bonusObject.AddComponent<Rigidbody>();\n            }\n            \n            Vector3 forceDirection = (spawnPosition - transform.position).normalized;\n            rb.AddForce(forceDirection * _spawnForce, ForceMode.Impulse);\n            \n            StartCoroutine(DestroyBonusObjectAfterTime(bonusObject, 10f));\n        }\n    }\n    \n    private IEnumerator DestroyBonusObjectAfterTime(GameObject obj, float time)\n    {\n        yield return new WaitForSeconds(time);\n        if (obj != null)\n        {\n            Destroy(obj);\n        }\n    }\n    \n    private IEnumerator ComboResetTimer()\n    {\n        yield return new WaitForSeconds(_comboWindow);\n        ResetCombo();\n    }\n    \n    private void ResetCombo()\n    {\n        _currentComboLevel = 0;\n        SetObjectColor(_normalColor);\n        \n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n            _comboResetCoroutine = null;\n        }\n        \n        OnComboReset?.Invoke();\n    }\n    \n    private void OnDestroy()\n    {\n        if (_comboResetCoroutine != null)\n        {\n            StopCoroutine(_comboResetCoroutine);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingFeather\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"bobAmount\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"bobSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isFloating\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_floating\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"disable gravity on rigidbody\"\n        },\n        {\n          \"action\": \"set floating state to true\"\n        },\n        {\n          \"action\": \"begin gentle upward movement to float height\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_float_height\",\n      \"trigger\": \"when floating and below target height\",\n      \"actions\": [\n        {\n          \"action\": \"apply gentle upward force to reach float height\"\n        }\n      ]\n    },\n    {\n      \"name\": \"gentle_bobbing\",\n      \"trigger\": \"when floating at target height\",\n      \"actions\": [\n        {\n          \"action\": \"create subtle up and down bobbing motion\"\n        },\n        {\n          \"action\": \"vary vertical position smoothly around float height\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_movement\",\n      \"trigger\": \"when floating\",\n      \"actions\": [\n        {\n          \"action\": \"apply very light random horizontal drift\"\n        },\n        {\n          \"action\": \"create natural swaying motion like floating on air\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_feather\",\n      \"trigger\": \"when player touches feather\",\n      \"actions\": [\n        {\n          \"action\": \"play collection sound effect\"\n        },\n        {\n          \"action\": \"create sparkle particle effect\"\n        },\n        {\n          \"action\": \"destroy feather object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class FloatingFeather : MonoBehaviour\n{\n    [Header(\"Feather Settings\")]\n    [SerializeField] private float _floatDuration = 5f;\n    [SerializeField] private float _floatForce = 10f;\n    [SerializeField] private float _pickupRange = 2f;\n    [SerializeField] private bool _consumeOnUse = true;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private float _bobSpeed = 2f;\n    [SerializeField] private float _bobHeight = 0.5f;\n    [SerializeField] private float _rotationSpeed = 45f;\n    [SerializeField] private ParticleSystem _pickupEffect;\n    [SerializeField] private ParticleSystem _floatEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _pickupSound;\n    [SerializeField] private AudioClip _activateSound;\n    [SerializeField] private AudioSource _audioSource;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnFeatherPickedUp;\n    public UnityEvent OnFloatActivated;\n    public UnityEvent OnFloatDeactivated;\n    \n    private Vector3 _startPosition;\n    private bool _isPickedUp = false;\n    private GameObject _currentPlayer;\n    private FloatingController _floatingController;\n    \n    [System.Serializable]\n    private class FloatingController\n    {\n        public GameObject player;\n        public Rigidbody playerRigidbody;\n        public float originalDrag;\n        public float floatTimeRemaining;\n        public bool isFloating;\n        \n        public FloatingController(GameObject playerObj, float duration)\n        {\n            player = playerObj;\n            playerRigidbody = playerObj.GetComponent<Rigidbody>();\n            floatTimeRemaining = duration;\n            isFloating = false;\n            \n            if (playerRigidbody != null)\n            {\n                originalDrag = playerRigidbody.drag;\n            }\n        }\n    }\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        Collider collider = GetComponent<Collider>();\n        if (collider != null)\n        {\n            collider.isTrigger = true;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isPickedUp)\n        {\n            HandleFeatherAnimation();\n            CheckForPlayerInRange();\n        }\n        else if (_floatingController != null && _floatingController.isFloating)\n        {\n            UpdateFloating();\n        }\n    }\n    \n    private void HandleFeatherAnimation()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _startPosition + Vector3.up * bobOffset;\n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayerInRange()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _pickupRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                PickupFeather(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isPickedUp && other.CompareTag(\"Player\"))\n        {\n            PickupFeather(other.gameObject);\n        }\n    }\n    \n    private void PickupFeather(GameObject player)\n    {\n        _isPickedUp = true;\n        _currentPlayer = player;\n        \n        PlaySound(_pickupSound);\n        PlayEffect(_pickupEffect);\n        \n        GetComponent<Renderer>().enabled = false;\n        GetComponent<Collider>().enabled = false;\n        \n        OnFeatherPickedUp?.Invoke();\n        \n        ActivateFloating();\n    }\n    \n    private void ActivateFloating()\n    {\n        if (_currentPlayer == null) return;\n        \n        _floatingController = new FloatingController(_currentPlayer, _floatDuration);\n        \n        if (_floatingController.playerRigidbody != null)\n        {\n            _floatingController.playerRigidbody.drag = 5f;\n            _floatingController.isFloating = true;\n            \n            PlaySound(_activateSound);\n            PlayEffect(_floatEffect);\n            \n            OnFloatActivated?.Invoke();\n        }\n    }\n    \n    private void UpdateFloating()\n    {\n        _floatingController.floatTimeRemaining -= Time.deltaTime;\n        \n        if (_floatingController.playerRigidbody != null)\n        {\n            Vector3 floatForceVector = Vector3.up * _floatForce;\n            _floatingController.playerRigidbody.AddForce(floatForceVector, ForceMode.Force);\n            \n            if (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.LeftShift))\n            {\n                _floatingController.playerRigidbody.AddForce(floatForceVector * 0.5f, ForceMode.Force);\n            }\n        }\n        \n        if (_floatingController.floatTimeRemaining <= 0f)\n        {\n            DeactivateFloating();\n        }\n    }\n    \n    private void DeactivateFloating()\n    {\n        if (_floatingController?.playerRigidbody != null)\n        {\n            _floatingController.playerRigidbody.drag = _floatingController.originalDrag;\n            _floatingController.isFloating = false;\n        }\n        \n        if (_floatEffect != null && _floatEffect.isPlaying)\n        {\n            _floatEffect.Stop();\n        }\n        \n        OnFloatDeactivated?.Invoke();\n        \n        if (_consumeOnUse)\n        {\n            Destroy(gameObject);\n        }\n        else\n        {\n            ResetFeather();\n        }\n    }\n    \n    private void ResetFeather()\n    {\n        _isPickedUp = false;\n        _currentPlayer = null;\n        _floatingController = null;\n        \n        GetComponent<Renderer>().enabled = true;\n        GetComponent<Collider>().enabled = true;\n        \n        transform.position = _startPosition;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void PlayEffect(ParticleSystem effect)\n    {\n        if (effect != null)\n        {\n            effect.Play();\n        }\n    }\n    \n    public float GetRemainingFloatTime()\n    {\n        return _floatingController?.floatTimeRemaining ?? 0f;\n    }\n    \n    public bool IsFloating()\n    {\n        return _floatingController?.isFloating ?? false;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _pickupRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RotatingSawBlade\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 360\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"int\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"sawSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_rotation\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around forward axis at rotation speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_saw_sound\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"play saw sound continuously in loop\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_player\",\n      \"trigger\": \"when player touches saw blade\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage amount to player\"\n        },\n        {\n          \"action\": \"push player away from saw blade\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class RotatingSawBlade : MonoBehaviour\n{\n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _rotationSpeed = 360f;\n    [SerializeField] private Vector3 _rotationAxis = Vector3.forward;\n    [SerializeField] private bool _clockwise = true;\n    \n    [Header(\"Movement Settings\")]\n    [SerializeField] private bool _enableMovement = false;\n    [SerializeField] private Transform[] _waypoints;\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private bool _loopMovement = true;\n    [SerializeField] private bool _pingPongMovement = false;\n    \n    [Header(\"Damage Settings\")]\n    [SerializeField] private int _damage = 1;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private LayerMask _damageableLayers = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rotationSound;\n    [SerializeField] private AudioClip _hitSound;\n    [SerializeField] private float _rotationVolume = 0.5f;\n    [SerializeField] private float _hitVolume = 1f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private GameObject _hitEffect;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnPlayerHit;\n    public UnityEvent<Collision> OnHitObject;\n    \n    private int _currentWaypointIndex = 0;\n    private bool _movingForward = true;\n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = new System.Collections.Generic.Dictionary<GameObject, float>();\n    \n    private void Start()\n    {\n        InitializeAudio();\n        InitializeParticles();\n        ValidateWaypoints();\n    }\n    \n    private void Update()\n    {\n        RotateBlade();\n        \n        if (_enableMovement && _waypoints != null && _waypoints.Length > 1)\n        {\n            MoveBlade();\n        }\n    }\n    \n    private void InitializeAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n            if (_audioSource == null)\n            {\n                _audioSource = gameObject.AddComponent<AudioSource>();\n            }\n        }\n        \n        if (_rotationSound != null && _audioSource != null)\n        {\n            _audioSource.clip = _rotationSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _rotationVolume;\n            _audioSource.Play();\n        }\n    }\n    \n    private void InitializeParticles()\n    {\n        if (_sparkParticles == null)\n        {\n            _sparkParticles = GetComponentInChildren<ParticleSystem>();\n        }\n    }\n    \n    private void ValidateWaypoints()\n    {\n        if (_enableMovement && (_waypoints == null || _waypoints.Length < 2))\n        {\n            Debug.LogWarning($\"RotatingSawBlade '{gameObject.name}' has movement enabled but insufficient waypoints!\");\n            _enableMovement = false;\n        }\n    }\n    \n    private void RotateBlade()\n    {\n        float rotationDirection = _clockwise ? -1f : 1f;\n        Vector3 rotation = _rotationAxis * _rotationSpeed * rotationDirection * Time.deltaTime;\n        transform.Rotate(rotation, Space.Self);\n    }\n    \n    private void MoveBlade()\n    {\n        Transform targetWaypoint = _waypoints[_currentWaypointIndex];\n        if (targetWaypoint == null) return;\n        \n        Vector3 direction = (targetWaypoint.position - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, targetWaypoint.position);\n        \n        if (distance < 0.1f)\n        {\n            UpdateWaypointIndex();\n        }\n        else\n        {\n            transform.position += direction * _moveSpeed * Time.deltaTime;\n        }\n    }\n    \n    private void UpdateWaypointIndex()\n    {\n        if (_pingPongMovement)\n        {\n            if (_movingForward)\n            {\n                _currentWaypointIndex++;\n                if (_currentWaypointIndex >= _waypoints.Length)\n                {\n                    _currentWaypointIndex = _waypoints.Length - 2;\n                    _movingForward = false;\n                }\n            }\n            else\n            {\n                _currentWaypointIndex--;\n                if (_currentWaypointIndex < 0)\n                {\n                    _currentWaypointIndex = 1;\n                    _movingForward = true;\n                }\n            }\n        }\n        else\n        {\n            _currentWaypointIndex++;\n            if (_currentWaypointIndex >= _waypoints.Length)\n            {\n                if (_loopMovement)\n                {\n                    _currentWaypointIndex = 0;\n                }\n                else\n                {\n                    _currentWaypointIndex = _waypoints.Length - 1;\n                    _enableMovement = false;\n                }\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        HandleCollision(other.gameObject, other.transform.position);\n    }\n    \n    private void OnTriggerStay(Collider other)\n    {\n        HandleCollision(other.gameObject, other.transform.position);\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        HandleCollision(collision.gameObject, collision.contacts[0].point);\n        OnHitObject?.Invoke(collision);\n    }\n    \n    private void OnCollisionStay(Collision collision)\n    {\n        HandleCollision(collision.gameObject, collision.contacts[0].point);\n    }\n    \n    private void HandleCollision(GameObject hitObject, Vector3 hitPoint)\n    {\n        if (!IsInDamageableLayer(hitObject)) return;\n        \n        if (CanDamageObject(hitObject))\n        {\n            DealDamage(hitObject);\n            PlayHitEffects(hitPoint);\n            \n            if (hitObject.CompareTag(\"Player\"))\n            {\n                OnPlayerHit?.Invoke(hitObject);\n            }\n            \n            _lastDamageTime[hitObject] = Time.time;\n        }\n    }\n    \n    private bool IsInDamageableLayer(GameObject obj)\n    {\n        return (_damageableLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    private bool CanDamageObject(GameObject obj)\n    {\n        if (!_lastDamageTime.ContainsKey(obj))\n        {\n            return true;\n        }\n        \n        return Time.time - _lastDamageTime[obj] >= _damageInterval;\n    }\n    \n    private void DealDamage(GameObject target)\n    {\n        // Try different common health interfaces\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Use SendMessage as a fallback for common health methods\n            target.SendMessage(\"TakeDamage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"Damage\", _damage, SendMessageOptions.DontRequireReceiver);\n            target.SendMessage(\"Hit\", _damage, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // If it's a rigidbody, add some force\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 forceDirection = (target.transform.position - transform.position).normalized;\n            rb.AddForce(forceDirection * 10f, ForceMode.Impulse);\n        }\n    }\n    \n    private void PlayHitEffects(Vector3 hitPoint)\n    {\n        // Play hit sound\n        if (_hitSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_hitSound, _hitVolume);\n        }\n        \n        // Play spark particles\n        if (_sparkParticles != null)\n        {\n            _sparkParticles.transform.position = hitPoint;\n            _sparkParticles.Play();\n        }\n        \n        // Instantiate hit effect\n        if (_hitEffect != null)\n        {\n            GameObject effect = Instantiate(_hitEffect, hitPoint, Quaternion.identity);\n            Destroy(effect, 2f);\n        }\n    }\n    \n    public void SetRotationSpeed(float speed)\n    {\n        _rotationSpeed = speed;\n    }\n    \n    public void SetMoveSpeed(float speed)\n    {\n        _moveSpeed = speed;\n    }\n    \n    public void ToggleMovement()\n    {\n        _enableMovement = !_enableMovement;\n    }\n    \n    public void StopBlade()\n    {\n        _rotationSpeed = 0f;\n        _enableMovement = false;\n        \n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    public void StartBlade()\n    {\n        _rotationSpeed = Mathf.Abs(_rotationSpeed) == 0 ? 360f : Mathf.Abs(_rotationSpeed);\n        \n        if (_rotationSound != null && _audioSource != null)\n        {\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_enableMovement && _waypoints != null && _waypoints.Length > 1)\n        {\n            Gizmos.color = Color.yellow;\n            \n            for (int i = 0; i < _waypoints.Length; i++)\n            {\n                if (_waypoints[i] == null) continue;\n                \n                Gizmos.DrawWireSphere(_waypoints[i].position, 0.3f);\n                \n                if (i < _waypoints.Length - 1 && _waypoints[i + 1] != null)\n                {\n                    Gizmos.DrawLine(_waypoints[i].position, _waypoints[i + 1].position);\n                }\n                else if (_loopMovement && !_pingPongMovement && _waypoints[0] != null)\n                {\n                    Gizmos.DrawLine(_waypoints[i].position, _waypoints[0].position);\n                }\n            }\n        }\n        \n        // Draw rotation axis\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, _rotationAxis.normalized);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TimeSlowZone\",\n  \"components\": [\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"slowFactor\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"affectPlayer\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"affectEnemies\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"affectProjectiles\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_time_slow_on_enter\",\n      \"trigger\": \"when object enters the zone trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"check if object should be affected by time slow\"\n        },\n        {\n          \"action\": \"apply slow time effect to the object using slow factor\"\n        },\n        {\n          \"action\": \"add object to list of affected objects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"remove_time_slow_on_exit\",\n      \"trigger\": \"when object exits the zone trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal time scale to the object\"\n        },\n        {\n          \"action\": \"remove object from list of affected objects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_slow_effect\",\n      \"trigger\": \"every frame while zone is active\",\n      \"actions\": [\n        {\n          \"action\": \"ensure all objects in affected list maintain slow time effect\"\n        },\n        {\n          \"action\": \"remove any destroyed objects from affected list\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class TimeSlowZone : MonoBehaviour\n{\n    [Header(\"Time Control\")]\n    [SerializeField] private float _slowTimeScale = 0.3f;\n    [SerializeField] private float _transitionDuration = 0.5f;\n    [SerializeField] private bool _affectFixedTimeScale = true;\n    \n    [Header(\"Zone Settings\")]\n    [SerializeField] private bool _triggerOnEnter = true;\n    [SerializeField] private bool _resetOnExit = true;\n    [SerializeField] private string _targetTag = \"Player\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _slowEffectParticles;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _enterSound;\n    [SerializeField] private AudioClip _exitSound;\n    \n    [Header(\"Zone Indicator\")]\n    [SerializeField] private GameObject _zoneVisual;\n    [SerializeField] private Color _zoneColor = Color.cyan;\n    [SerializeField] private bool _pulseEffect = true;\n    [SerializeField] private float _pulseSpeed = 2f;\n    \n    private float _originalTimeScale;\n    private float _originalFixedTimeScale;\n    private bool _isSlowActive = false;\n    private Coroutine _transitionCoroutine;\n    private Renderer _zoneRenderer;\n    private Material _zoneMaterial;\n    private Color _originalZoneColor;\n    \n    private void Start()\n    {\n        _originalTimeScale = Time.timeScale;\n        _originalFixedTimeScale = Time.fixedDeltaTime;\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        SetupZoneVisual();\n        \n        if (_slowEffectParticles != null)\n        {\n            _slowEffectParticles.Stop();\n        }\n    }\n    \n    private void SetupZoneVisual()\n    {\n        if (_zoneVisual != null)\n        {\n            _zoneRenderer = _zoneVisual.GetComponent<Renderer>();\n            if (_zoneRenderer != null)\n            {\n                _zoneMaterial = _zoneRenderer.material;\n                _originalZoneColor = _zoneMaterial.color;\n                _zoneMaterial.color = _zoneColor;\n            }\n        }\n        else\n        {\n            _zoneRenderer = GetComponent<Renderer>();\n            if (_zoneRenderer != null)\n            {\n                _zoneMaterial = _zoneRenderer.material;\n                _originalZoneColor = _zoneMaterial.color;\n                _zoneMaterial.color = _zoneColor;\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (_pulseEffect && _zoneMaterial != null)\n        {\n            float alpha = Mathf.Lerp(0.3f, 0.8f, (Mathf.Sin(Time.unscaledTime * _pulseSpeed) + 1f) * 0.5f);\n            Color currentColor = _zoneMaterial.color;\n            currentColor.a = alpha;\n            _zoneMaterial.color = currentColor;\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_triggerOnEnter) return;\n        \n        if (string.IsNullOrEmpty(_targetTag) || other.CompareTag(_targetTag))\n        {\n            ActivateSlowTime();\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!_resetOnExit) return;\n        \n        if (string.IsNullOrEmpty(_targetTag) || other.CompareTag(_targetTag))\n        {\n            DeactivateSlowTime();\n        }\n    }\n    \n    public void ActivateSlowTime()\n    {\n        if (_isSlowActive) return;\n        \n        _isSlowActive = true;\n        \n        if (_transitionCoroutine != null)\n            StopCoroutine(_transitionCoroutine);\n            \n        _transitionCoroutine = StartCoroutine(TransitionTimeScale(_slowTimeScale));\n        \n        if (_slowEffectParticles != null)\n            _slowEffectParticles.Play();\n            \n        PlaySound(_enterSound);\n    }\n    \n    public void DeactivateSlowTime()\n    {\n        if (!_isSlowActive) return;\n        \n        _isSlowActive = false;\n        \n        if (_transitionCoroutine != null)\n            StopCoroutine(_transitionCoroutine);\n            \n        _transitionCoroutine = StartCoroutine(TransitionTimeScale(_originalTimeScale));\n        \n        if (_slowEffectParticles != null)\n            _slowEffectParticles.Stop();\n            \n        PlaySound(_exitSound);\n    }\n    \n    private IEnumerator TransitionTimeScale(float targetScale)\n    {\n        float startTimeScale = Time.timeScale;\n        float startFixedTimeScale = Time.fixedDeltaTime;\n        float targetFixedTimeScale = _originalFixedTimeScale * targetScale;\n        \n        float elapsed = 0f;\n        \n        while (elapsed < _transitionDuration)\n        {\n            elapsed += Time.unscaledDeltaTime;\n            float t = elapsed / _transitionDuration;\n            t = Mathf.SmoothStep(0f, 1f, t);\n            \n            Time.timeScale = Mathf.Lerp(startTimeScale, targetScale, t);\n            \n            if (_affectFixedTimeScale)\n            {\n                Time.fixedDeltaTime = Mathf.Lerp(startFixedTimeScale, targetFixedTimeScale, t);\n            }\n            \n            yield return null;\n        }\n        \n        Time.timeScale = targetScale;\n        if (_affectFixedTimeScale)\n        {\n            Time.fixedDeltaTime = targetFixedTimeScale;\n        }\n        \n        _transitionCoroutine = null;\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.pitch = Time.timeScale;\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    public void ToggleSlowTime()\n    {\n        if (_isSlowActive)\n            DeactivateSlowTime();\n        else\n            ActivateSlowTime();\n    }\n    \n    public void SetSlowTimeScale(float newScale)\n    {\n        _slowTimeScale = Mathf.Clamp(newScale, 0.01f, 1f);\n        \n        if (_isSlowActive)\n        {\n            if (_transitionCoroutine != null)\n                StopCoroutine(_transitionCoroutine);\n            _transitionCoroutine = StartCoroutine(TransitionTimeScale(_slowTimeScale));\n        }\n    }\n    \n    private void OnDisable()\n    {\n        if (_isSlowActive)\n        {\n            Time.timeScale = _originalTimeScale;\n            if (_affectFixedTimeScale)\n            {\n                Time.fixedDeltaTime = _originalFixedTimeScale;\n            }\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_zoneMaterial != null && _originalZoneColor != Color.clear)\n        {\n            _zoneMaterial.color = _originalZoneColor;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GravityWell\",\n  \"components\": [\n    \"Rigidbody\",\n    \"SphereCollider\",\n    \"AudioSource\",\n    \"Light\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pullForce\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"baseRumbleVolume\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"maxRumbleVolume\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"baseLightIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"lightIntensityMultiplier\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"collisionParticleCount\",\n      \"type\": \"int\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"pull_nearby_rigidbodies\",\n      \"trigger\": \"when rigidbody objects are within detection radius\",\n      \"actions\": [\n        {\n          \"action\": \"apply force toward gravity well center with strength inversely proportional to distance\"\n        },\n        {\n          \"action\": \"increase force strength as objects get closer to center\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_rumble_volume\",\n      \"trigger\": \"when objects are being pulled by gravity well\",\n      \"actions\": [\n        {\n          \"action\": \"calculate average distance of all pulled objects\"\n        },\n        {\n          \"action\": \"increase rumble volume as average distance decreases\"\n        },\n        {\n          \"action\": \"play low frequency rumble sound at calculated volume level\"\n        }\n      ]\n    },\n    {\n      \"name\": \"modify_light_intensity\",\n      \"trigger\": \"when number of objects being pulled changes\",\n      \"actions\": [\n        {\n          \"action\": \"count total number of objects currently being affected\"\n        },\n        {\n          \"action\": \"increase light intensity based on object count using multiplier\"\n        },\n        {\n          \"action\": \"set light intensity to base value plus calculated bonus\"\n        }\n      ]\n    },\n    {\n      \"name\": \"create_collision_particles\",\n      \"trigger\": \"when rigidbody object collides with gravity well center\",\n      \"actions\": [\n        {\n          \"action\": \"spawn particle effect at collision point\"\n        },\n        {\n          \"action\": \"emit specified number of particles in burst pattern\"\n        },\n        {\n          \"action\": \"orient particles to spread outward from collision location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class GravityWell : MonoBehaviour\n{\n    [Header(\"Gravity Settings\")]\n    [SerializeField] private float _gravitationalForce = 100f;\n    [SerializeField] private float _maxRange = 20f;\n    [SerializeField] private AnimationCurve _forceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio Settings\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _rumbleClip;\n    [SerializeField] private float _baseVolume = 0.1f;\n    [SerializeField] private float _maxVolume = 0.8f;\n    [SerializeField] private float _basePitch = 0.5f;\n    [SerializeField] private float _maxPitch = 1.2f;\n    \n    [Header(\"Light Settings\")]\n    [SerializeField] private Light _wellLight;\n    [SerializeField] private float _baseLightIntensity = 1f;\n    [SerializeField] private float _intensityPerObject = 0.5f;\n    [SerializeField] private float _maxLightIntensity = 10f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _collisionParticles;\n    [SerializeField] private float _collisionThreshold = 2f;\n    [SerializeField] private float _particleEmissionRate = 50f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Transform _centerPoint;\n    [SerializeField] private bool _showGizmos = true;\n    \n    private List<Rigidbody> _affectedBodies = new List<Rigidbody>();\n    private Dictionary<Rigidbody, float> _lastDistances = new Dictionary<Rigidbody, float>();\n    private Collider[] _nearbyColliders = new Collider[50];\n    private float _currentAverageDistance = 0f;\n    \n    private void Start()\n    {\n        if (_centerPoint == null)\n            _centerPoint = transform;\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        SetupAudioSource();\n        \n        if (_wellLight == null)\n            _wellLight = GetComponent<Light>();\n            \n        if (_collisionParticles == null)\n            _collisionParticles = GetComponentInChildren<ParticleSystem>();\n            \n        SetupParticleSystem();\n    }\n    \n    private void SetupAudioSource()\n    {\n        _audioSource.clip = _rumbleClip;\n        _audioSource.loop = true;\n        _audioSource.volume = 0f;\n        _audioSource.pitch = _basePitch;\n        _audioSource.spatialBlend = 1f;\n        _audioSource.rolloffMode = AudioRolloffMode.Logarithmic;\n        _audioSource.maxDistance = _maxRange * 2f;\n        \n        if (_rumbleClip != null)\n            _audioSource.Play();\n    }\n    \n    private void SetupParticleSystem()\n    {\n        if (_collisionParticles != null)\n        {\n            var emission = _collisionParticles.emission;\n            emission.enabled = false;\n            \n            var shape = _collisionParticles.shape;\n            shape.shapeType = ParticleSystemShapeType.Sphere;\n            shape.radius = 0.5f;\n        }\n    }\n    \n    private void FixedUpdate()\n    {\n        UpdateAffectedBodies();\n        ApplyGravitationalForces();\n        UpdateAudioEffects();\n        UpdateLightIntensity();\n        CheckForCollisions();\n    }\n    \n    private void UpdateAffectedBodies()\n    {\n        _affectedBodies.Clear();\n        \n        int numColliders = Physics.OverlapSphereNonAlloc(\n            _centerPoint.position, \n            _maxRange, \n            _nearbyColliders, \n            _affectedLayers\n        );\n        \n        for (int i = 0; i < numColliders; i++)\n        {\n            Rigidbody rb = _nearbyColliders[i].GetComponent<Rigidbody>();\n            if (rb != null && rb.gameObject != gameObject)\n            {\n                _affectedBodies.Add(rb);\n            }\n        }\n    }\n    \n    private void ApplyGravitationalForces()\n    {\n        float totalDistance = 0f;\n        int validBodies = 0;\n        \n        foreach (Rigidbody rb in _affectedBodies)\n        {\n            if (rb == null) continue;\n            \n            Vector3 direction = _centerPoint.position - rb.position;\n            float distance = direction.magnitude;\n            \n            if (distance > _maxRange) continue;\n            \n            float normalizedDistance = distance / _maxRange;\n            float forceMultiplier = _forceCurve.Evaluate(1f - normalizedDistance);\n            \n            Vector3 force = direction.normalized * (_gravitationalForce * forceMultiplier * rb.mass);\n            rb.AddForce(force, ForceMode.Force);\n            \n            _lastDistances[rb] = distance;\n            totalDistance += distance;\n            validBodies++;\n        }\n        \n        _currentAverageDistance = validBodies > 0 ? totalDistance / validBodies : _maxRange;\n    }\n    \n    private void UpdateAudioEffects()\n    {\n        if (_audioSource == null || _rumbleClip == null) return;\n        \n        int objectCount = _affectedBodies.Count;\n        \n        if (objectCount > 0)\n        {\n            float normalizedDistance = Mathf.Clamp01(_currentAverageDistance / _maxRange);\n            float volumeMultiplier = 1f - normalizedDistance;\n            \n            float targetVolume = Mathf.Lerp(_baseVolume, _maxVolume, volumeMultiplier);\n            targetVolume *= Mathf.Clamp01(objectCount / 5f);\n            \n            float targetPitch = Mathf.Lerp(_basePitch, _maxPitch, volumeMultiplier);\n            \n            _audioSource.volume = Mathf.Lerp(_audioSource.volume, targetVolume, Time.fixedDeltaTime * 2f);\n            _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, targetPitch, Time.fixedDeltaTime * 2f);\n        }\n        else\n        {\n            _audioSource.volume = Mathf.Lerp(_audioSource.volume, 0f, Time.fixedDeltaTime * 3f);\n            _audioSource.pitch = Mathf.Lerp(_audioSource.pitch, _basePitch, Time.fixedDeltaTime * 2f);\n        }\n    }\n    \n    private void UpdateLightIntensity()\n    {\n        if (_wellLight == null) return;\n        \n        float targetIntensity = _baseLightIntensity + (_affectedBodies.Count * _intensityPerObject);\n        targetIntensity = Mathf.Clamp(targetIntensity, _baseLightIntensity, _maxLightIntensity);\n        \n        _wellLight.intensity = Mathf.Lerp(_wellLight.intensity, targetIntensity, Time.fixedDeltaTime * 2f);\n    }\n    \n    private void CheckForCollisions()\n    {\n        foreach (Rigidbody rb in _affectedBodies)\n        {\n            if (rb == null) continue;\n            \n            float distance = Vector3.Distance(rb.position, _centerPoint.position);\n            \n            if (distance <= _collisionThreshold)\n            {\n                TriggerCollisionEffect(rb.position);\n            }\n        }\n    }\n    \n    private void TriggerCollisionEffect(Vector3 collisionPoint)\n    {\n        if (_collisionParticles == null) return;\n        \n        _collisionParticles.transform.position = collisionPoint;\n        \n        var emission = _collisionParticles.emission;\n        emission.enabled = true;\n        \n        var emissionRate = _collisionParticles.emission;\n        emissionRate.rateOverTime = _particleEmissionRate;\n        \n        _collisionParticles.Emit((int)(_particleEmissionRate * Time.fixedDeltaTime));\n        \n        Invoke(nameof(StopParticleEmission), 0.1f);\n    }\n    \n    private void StopParticleEmission()\n    {\n        if (_collisionParticles != null)\n        {\n            var emission = _collisionParticles.emission;\n            emission.enabled = false;\n        }\n    }\n    \n    private void OnDrawGizmos()\n    {\n        if (!_showGizmos) return;\n        \n        Vector3 center = _centerPoint != null ? _centerPoint.position : transform.position;\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(center, _maxRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(center, _collisionThreshold);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(center, 0.2f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (!_showGizmos) return;\n        \n        Vector3 center = _centerPoint != null ? _centerPoint.position : transform.position;\n        \n        Gizmos.color = new Color(1f, 1f, 0f, 0.1f);\n        Gizmos.DrawSphere(center, _maxRange);\n        \n        Gizmos.color = new Color(1f, 0f, 0f, 0.2f);\n        Gizmos.DrawSphere(center, _collisionThreshold);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PirateFighter\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"runSpeed\",\n      \"type\": \"float\",\n      \"default\": 6\n    },\n    {\n      \"name\": \"swordDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"pistolDamage\",\n      \"type\": \"float\",\n      \"default\": 40\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"swordRange\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"pistolRange\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"pistolCooldown\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isAlive\",\n      \"type\": \"bool\",\n      \"default\": true\n    },\n    {\n      \"name\": \"hasAmmo\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"patrol_idle\",\n      \"trigger\": \"when no enemy is detected within range\",\n      \"actions\": [\n        {\n          \"action\": \"walk slowly in random directions\"\n        },\n        {\n          \"action\": \"occasionally stop and look around\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_enemy\",\n      \"trigger\": \"when enemy enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"shout pirate battle cry\"\n        },\n        {\n          \"action\": \"draw sword and pistol\"\n        },\n        {\n          \"action\": \"run toward enemy aggressively\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sword_combat\",\n      \"trigger\": \"when enemy is within sword range\",\n      \"actions\": [\n        {\n          \"action\": \"swing sword at enemy\"\n        },\n        {\n          \"action\": \"deal sword damage on hit\"\n        },\n        {\n          \"action\": \"play sword clash sound effects\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pistol_combat\",\n      \"trigger\": \"when enemy is within pistol range but outside sword range and pistol is ready\",\n      \"actions\": [\n        {\n          \"action\": \"aim pistol at enemy\"\n        },\n        {\n          \"action\": \"fire pistol shot\"\n        },\n        {\n          \"action\": \"deal pistol damage on hit\"\n        },\n        {\n          \"action\": \"start pistol reload cooldown\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage from enemy attack\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt animation and sound\"\n        },\n        {\n          \"action\": \"stagger briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"drop sword and pistol\"\n        },\n        {\n          \"action\": \"fall to ground\"\n        },\n        {\n          \"action\": \"become inactive\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PirateController : MonoBehaviour\n{\n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 3f;\n    [SerializeField] private float _rotationSpeed = 180f;\n    [SerializeField] private float _detectionRange = 8f;\n    [SerializeField] private float _attackRange = 2f;\n    [SerializeField] private float _shootRange = 6f;\n    \n    [Header(\"Combat\")]\n    [SerializeField] private float _swordDamage = 25f;\n    [SerializeField] private float _pistolDamage = 40f;\n    [SerializeField] private float _swordCooldown = 1.5f;\n    [SerializeField] private float _pistolCooldown = 3f;\n    [SerializeField] private int _maxAmmo = 6;\n    [SerializeField] private float _reloadTime = 2f;\n    \n    [Header(\"Health\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _swordSwingSound;\n    [SerializeField] private AudioClip _pistolFireSound;\n    [SerializeField] private AudioClip _reloadSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private GameObject _muzzleFlashPrefab;\n    [SerializeField] private Transform _pistolMuzzle;\n    [SerializeField] private GameObject _bloodEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnDeath;\n    public UnityEvent OnAttack;\n    public UnityEvent OnReload;\n    \n    private Transform _target;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private AudioSource _audioSource;\n    private Collider _collider;\n    \n    private float _lastSwordAttack;\n    private float _lastPistolShot;\n    private int _currentAmmo;\n    private bool _isReloading;\n    private bool _isDead;\n    private float _reloadStartTime;\n    \n    private PirateState _currentState = PirateState.Patrolling;\n    private Vector3 _patrolDirection;\n    private float _patrolTimer;\n    private float _patrolChangeInterval = 3f;\n    \n    private enum PirateState\n    {\n        Patrolling,\n        Chasing,\n        Attacking,\n        Reloading,\n        Dead\n    }\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        _audioSource = GetComponent<AudioSource>();\n        _collider = GetComponent<Collider>();\n        \n        _currentHealth = _maxHealth;\n        _currentAmmo = _maxAmmo;\n        _patrolDirection = Random.insideUnitSphere;\n        _patrolDirection.y = 0;\n        _patrolDirection.Normalize();\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        HandleReloading();\n        UpdateState();\n        HandleMovement();\n        HandleCombat();\n        UpdateAnimations();\n    }\n    \n    private void HandleReloading()\n    {\n        if (_isReloading)\n        {\n            if (Time.time - _reloadStartTime >= _reloadTime)\n            {\n                _currentAmmo = _maxAmmo;\n                _isReloading = false;\n                _currentState = PirateState.Chasing;\n                OnReload?.Invoke();\n            }\n        }\n    }\n    \n    private void UpdateState()\n    {\n        if (_isReloading)\n        {\n            _currentState = PirateState.Reloading;\n            return;\n        }\n        \n        FindNearestPlayer();\n        \n        if (_target == null)\n        {\n            _currentState = PirateState.Patrolling;\n            return;\n        }\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget <= _attackRange)\n        {\n            _currentState = PirateState.Attacking;\n        }\n        else if (distanceToTarget <= _detectionRange)\n        {\n            _currentState = PirateState.Chasing;\n        }\n        else\n        {\n            _currentState = PirateState.Patrolling;\n            _target = null;\n        }\n    }\n    \n    private void FindNearestPlayer()\n    {\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        float nearestDistance = _detectionRange;\n        Transform nearestPlayer = null;\n        \n        foreach (GameObject player in players)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance < nearestDistance)\n            {\n                nearestDistance = distance;\n                nearestPlayer = player.transform;\n            }\n        }\n        \n        _target = nearestPlayer;\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 moveDirection = Vector3.zero;\n        \n        switch (_currentState)\n        {\n            case PirateState.Patrolling:\n                HandlePatrolling();\n                moveDirection = _patrolDirection;\n                break;\n                \n            case PirateState.Chasing:\n                if (_target != null)\n                {\n                    moveDirection = (_target.position - transform.position).normalized;\n                }\n                break;\n                \n            case PirateState.Attacking:\n                if (_target != null)\n                {\n                    Vector3 lookDirection = (_target.position - transform.position).normalized;\n                    lookDirection.y = 0;\n                    if (lookDirection != Vector3.zero)\n                    {\n                        Quaternion targetRotation = Quaternion.LookRotation(lookDirection);\n                        transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n                    }\n                }\n                return;\n                \n            case PirateState.Reloading:\n                return;\n        }\n        \n        if (moveDirection != Vector3.zero)\n        {\n            _rigidbody.MovePosition(transform.position + moveDirection * _moveSpeed * Time.deltaTime);\n            \n            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.deltaTime);\n        }\n    }\n    \n    private void HandlePatrolling()\n    {\n        _patrolTimer += Time.deltaTime;\n        if (_patrolTimer >= _patrolChangeInterval)\n        {\n            _patrolDirection = Random.insideUnitSphere;\n            _patrolDirection.y = 0;\n            _patrolDirection.Normalize();\n            _patrolTimer = 0f;\n        }\n    }\n    \n    private void HandleCombat()\n    {\n        if (_currentState != PirateState.Attacking || _target == null) return;\n        \n        float distanceToTarget = Vector3.Distance(transform.position, _target.position);\n        \n        if (distanceToTarget <= _attackRange && Time.time - _lastSwordAttack >= _swordCooldown)\n        {\n            SwordAttack();\n        }\n        else if (distanceToTarget <= _shootRange && _currentAmmo > 0 && Time.time - _lastPistolShot >= _pistolCooldown)\n        {\n            PistolShoot();\n        }\n        else if (_currentAmmo == 0 && !_isReloading)\n        {\n            StartReload();\n        }\n    }\n    \n    private void SwordAttack()\n    {\n        _lastSwordAttack = Time.time;\n        OnAttack?.Invoke();\n        \n        if (_audioSource && _swordSwingSound)\n        {\n            _audioSource.PlayOneShot(_swordSwingSound);\n        }\n        \n        Collider[] hitColliders = Physics.OverlapSphere(transform.position + transform.forward * 1.5f, 1f);\n        foreach (Collider hit in hitColliders)\n        {\n            if (hit.CompareTag(\"Player\"))\n            {\n                DealDamageToPlayer(hit.gameObject, _swordDamage);\n            }\n        }\n    }\n    \n    private void PistolShoot()\n    {\n        _lastPistolShot = Time.time;\n        _currentAmmo--;\n        OnAttack?.Invoke();\n        \n        if (_audioSource && _pistolFireSound)\n        {\n            _audioSource.PlayOneShot(_pistolFireSound);\n        }\n        \n        if (_muzzleFlashPrefab && _pistolMuzzle)\n        {\n            GameObject flash = Instantiate(_muzzleFlashPrefab, _pistolMuzzle.position, _pistolMuzzle.rotation);\n            Destroy(flash, 0.1f);\n        }\n        \n        RaycastHit hit;\n        if (Physics.Raycast(transform.position + Vector3.up, transform.forward, out hit, _shootRange))\n        {\n            if (hit.collider.CompareTag(\"Player\"))\n            {\n                DealDamageToPlayer(hit.collider.gameObject, _pistolDamage);\n            }\n        }\n    }\n    \n    private void StartReload()\n    {\n        _isReloading = true;\n        _reloadStartTime = Time.time;\n        \n        if (_audioSource && _reloadSound)\n        {\n            _audioSource.PlayOneShot(_reloadSound);\n        }\n    }\n    \n    private void DealDamageToPlayer(GameObject player, float damage)\n    {\n        if (_bloodEffectPrefab)\n        {\n            GameObject blood = Instantiate(_bloodEffectPrefab, player.transform.position, Quaternion.identity);\n            Destroy(blood, 2f);\n        }\n        \n        player.SendMessage(\"TakeDamage\", damage, SendMessageOptions.DontRequireReceiver);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        \n        if (_bloodEffectPrefab)\n        {\n            GameObject blood = Instantiate(_bloodEffectPrefab, transform.position + Vector3.up, Quaternion.identity);\n            Destroy(blood, 2f);\n        }\n        \n        if (_currentHealth <= 0)\n        {\n            Die();\n        }\n    }\n    \n    private void Die()\n    {\n        _isDead = true;\n        _currentState = PirateState.Dead;\n        \n        if (_audioSource && _deathSound)\n        {\n            _audioSource.PlayOneShot(_deathSound);\n        }\n        \n        if (_collider)\n        {\n            _collider.enabled = false;\n        }\n        \n        if (_rigidbody)\n        {\n            _rigidbody.isKinematic = true;\n        }\n        \n        OnDeath?.Invoke();\n        \n        Destroy(gameObject, 3f);\n    }\n    \n    private void UpdateAnimations()\n    {\n        if (!_animator) return;\n        \n        _animator.SetBool(\"IsMoving\", _currentState == PirateState.Patrolling || _currentState == PirateState.Chasing);\n        _animator.SetBool(\"IsAttacking\", _currentState == PirateState.Attacking);\n        _animator.SetBool(\"IsReloading\", _isReloading);\n        _animator.SetBool(\"IsDead\", _isDead);\n        _animator.SetFloat(\"Health\", _currentHealth / _maxHealth);\n        _animator.SetInt(\"Ammo\", _currentAmmo);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _attackRange);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(transform.position, _shootRange);\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position + transform.forward * 1.5f, 1f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CheckpointRespawn\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"respawnHeight\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"activationEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"respawnEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_checkpoint\",\n      \"trigger\": \"when player touches this checkpoint\",\n      \"actions\": [\n        {\n          \"action\": \"mark this checkpoint as activated\"\n        },\n        {\n          \"action\": \"set this as the current respawn point for the player\"\n        },\n        {\n          \"action\": \"change visual appearance to show activation\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"spawn activation particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respawn_player\",\n      \"trigger\": \"when player dies and this is the active checkpoint\",\n      \"actions\": [\n        {\n          \"action\": \"move player to this checkpoint position\"\n        },\n        {\n          \"action\": \"place player slightly above ground at respawn height\"\n        },\n        {\n          \"action\": \"reset player health to full\"\n        },\n        {\n          \"action\": \"reset player state to normal\"\n        },\n        {\n          \"action\": \"spawn respawn particle effect\"\n        },\n        {\n          \"action\": \"play respawn sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when checkpoint becomes the active respawn point\",\n      \"actions\": [\n        {\n          \"action\": \"emit glowing light\"\n        },\n        {\n          \"action\": \"change material color to indicate active state\"\n        },\n        {\n          \"action\": \"start gentle floating animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections.Generic;\n\npublic class CheckpointRespawn : MonoBehaviour\n{\n    [Header(\"Checkpoint Settings\")]\n    [SerializeField] private Transform _respawnPoint;\n    [SerializeField] private bool _isActiveCheckpoint = false;\n    [SerializeField] private float _respawnDelay = 2f;\n    [SerializeField] private LayerMask _playerLayer = -1;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private GameObject _activeIndicator;\n    [SerializeField] private GameObject _inactiveIndicator;\n    [SerializeField] private ParticleSystem _activationEffect;\n    [SerializeField] private AudioClip _activationSound;\n    [SerializeField] private AudioClip _respawnSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnCheckpointActivated;\n    public UnityEvent OnPlayerRespawned;\n    \n    private static CheckpointRespawn _currentActiveCheckpoint;\n    private static Dictionary<GameObject, Vector3> _playerLastPositions = new Dictionary<GameObject, Vector3>();\n    private AudioSource _audioSource;\n    private bool _hasBeenActivated = false;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        if (_respawnPoint == null)\n            _respawnPoint = transform;\n            \n        UpdateVisuals();\n        \n        if (_isActiveCheckpoint && _currentActiveCheckpoint == null)\n        {\n            SetAsActiveCheckpoint();\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsPlayer(other.gameObject) && !_hasBeenActivated)\n        {\n            ActivateCheckpoint(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (IsPlayer(other.gameObject) && !_hasBeenActivated)\n        {\n            ActivateCheckpoint(other.gameObject);\n        }\n    }\n    \n    private bool IsPlayer(GameObject obj)\n    {\n        return obj.CompareTag(\"Player\") && ((1 << obj.layer) & _playerLayer) != 0;\n    }\n    \n    private void ActivateCheckpoint(GameObject player)\n    {\n        if (_currentActiveCheckpoint != null && _currentActiveCheckpoint != this)\n        {\n            _currentActiveCheckpoint.DeactivateCheckpoint();\n        }\n        \n        SetAsActiveCheckpoint();\n        _playerLastPositions[player] = _respawnPoint.position;\n        \n        PlayActivationEffects();\n        OnCheckpointActivated?.Invoke();\n        \n        _hasBeenActivated = true;\n    }\n    \n    private void SetAsActiveCheckpoint()\n    {\n        _currentActiveCheckpoint = this;\n        _isActiveCheckpoint = true;\n        UpdateVisuals();\n    }\n    \n    private void DeactivateCheckpoint()\n    {\n        _isActiveCheckpoint = false;\n        UpdateVisuals();\n    }\n    \n    private void UpdateVisuals()\n    {\n        if (_activeIndicator != null)\n            _activeIndicator.SetActive(_isActiveCheckpoint);\n            \n        if (_inactiveIndicator != null)\n            _inactiveIndicator.SetActive(!_isActiveCheckpoint);\n    }\n    \n    private void PlayActivationEffects()\n    {\n        if (_activationEffect != null)\n            _activationEffect.Play();\n            \n        if (_activationSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_activationSound);\n    }\n    \n    public static void RespawnPlayer(GameObject player)\n    {\n        if (_currentActiveCheckpoint == null)\n        {\n            Debug.LogWarning(\"No active checkpoint found for respawn!\");\n            return;\n        }\n        \n        _currentActiveCheckpoint.StartCoroutine(_currentActiveCheckpoint.RespawnPlayerCoroutine(player));\n    }\n    \n    private System.Collections.IEnumerator RespawnPlayerCoroutine(GameObject player)\n    {\n        yield return new WaitForSeconds(_respawnDelay);\n        \n        Vector3 respawnPosition = _playerLastPositions.ContainsKey(player) \n            ? _playerLastPositions[player] \n            : _respawnPoint.position;\n        \n        // Reset player position\n        if (player.GetComponent<Rigidbody>() != null)\n        {\n            Rigidbody rb = player.GetComponent<Rigidbody>();\n            rb.velocity = Vector3.zero;\n            rb.angularVelocity = Vector3.zero;\n        }\n        \n        if (player.GetComponent<Rigidbody2D>() != null)\n        {\n            Rigidbody2D rb2d = player.GetComponent<Rigidbody2D>();\n            rb2d.velocity = Vector2.zero;\n            rb2d.angularVelocity = 0f;\n        }\n        \n        player.transform.position = respawnPosition;\n        player.transform.rotation = _respawnPoint.rotation;\n        \n        // Re-enable player if disabled\n        if (!player.activeInHierarchy)\n            player.SetActive(true);\n            \n        // Reset player components\n        Collider playerCollider = player.GetComponent<Collider>();\n        if (playerCollider != null)\n            playerCollider.enabled = true;\n            \n        Collider2D playerCollider2D = player.GetComponent<Collider2D>();\n        if (playerCollider2D != null)\n            playerCollider2D.enabled = true;\n        \n        PlayRespawnEffects();\n        OnPlayerRespawned?.Invoke();\n    }\n    \n    private void PlayRespawnEffects()\n    {\n        if (_respawnSound != null && _audioSource != null)\n            _audioSource.PlayOneShot(_respawnSound);\n    }\n    \n    public static Vector3 GetCurrentRespawnPosition()\n    {\n        return _currentActiveCheckpoint != null ? _currentActiveCheckpoint._respawnPoint.position : Vector3.zero;\n    }\n    \n    public static CheckpointRespawn GetCurrentActiveCheckpoint()\n    {\n        return _currentActiveCheckpoint;\n    }\n    \n    public void ForceActivateCheckpoint()\n    {\n        if (_currentActiveCheckpoint != null && _currentActiveCheckpoint != this)\n        {\n            _currentActiveCheckpoint.DeactivateCheckpoint();\n        }\n        \n        SetAsActiveCheckpoint();\n        PlayActivationEffects();\n        OnCheckpointActivated?.Invoke();\n        _hasBeenActivated = true;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        if (_respawnPoint != null)\n        {\n            Gizmos.color = _isActiveCheckpoint ? Color.green : Color.yellow;\n            Gizmos.DrawWireSphere(_respawnPoint.position, 1f);\n            Gizmos.DrawLine(_respawnPoint.position, _respawnPoint.position + _respawnPoint.forward * 2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Submarine\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"maxDepth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"buoyancyForce\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"enginePower\",\n      \"type\": \"float\",\n      \"default\": 1000\n    },\n    {\n      \"name\": \"isEngineRunning\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"currentDepth\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"oxygenLevel\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"engine_control\",\n      \"trigger\": \"when engine start input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"toggle engine running state\"\n        },\n        {\n          \"action\": \"play engine startup sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"forward_movement\",\n      \"trigger\": \"when forward input is held and engine is running\",\n      \"actions\": [\n        {\n          \"action\": \"apply forward thrust based on engine power\"\n        },\n        {\n          \"action\": \"increase speed up to maximum speed limit\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steering\",\n      \"trigger\": \"when horizontal input is detected\",\n      \"actions\": [\n        {\n          \"action\": \"rotate submarine left or right based on input direction\"\n        },\n        {\n          \"action\": \"apply turning force at specified turn speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dive_control\",\n      \"trigger\": \"when dive input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"reduce buoyancy to sink deeper\"\n        },\n        {\n          \"action\": \"limit descent to maximum depth\"\n        }\n      ]\n    },\n    {\n      \"name\": \"surface_control\",\n      \"trigger\": \"when surface input is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"increase buoyancy to rise upward\"\n        },\n        {\n          \"action\": \"prevent rising above water surface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"depth_tracking\",\n      \"trigger\": \"continuously while underwater\",\n      \"actions\": [\n        {\n          \"action\": \"update current depth based on position\"\n        },\n        {\n          \"action\": \"apply water pressure effects at greater depths\"\n        }\n      ]\n    },\n    {\n      \"name\": \"oxygen_consumption\",\n      \"trigger\": \"continuously while submerged\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease oxygen level over time\"\n        },\n        {\n          \"action\": \"increase consumption rate when engine is running\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emergency_surface\",\n      \"trigger\": \"when oxygen level drops below critical threshold\",\n      \"actions\": [\n        {\n          \"action\": \"automatically increase buoyancy to emergency surface\"\n        },\n        {\n          \"action\": \"play warning alarm sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SubmarineController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _forwardSpeed = 10f;\n    [SerializeField] private float _rotationSpeed = 50f;\n    [SerializeField] private float _verticalSpeed = 5f;\n    [SerializeField] private float _maxDepth = -50f;\n    [SerializeField] private float _minDepth = -2f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _buoyancyForce = 100f;\n    [SerializeField] private float _waterDrag = 2f;\n    [SerializeField] private float _waterAngularDrag = 5f;\n    \n    [Header(\"Ballast System\")]\n    [SerializeField] private float _ballastFillRate = 2f;\n    [SerializeField] private float _ballastEmptyRate = 3f;\n    [SerializeField] private float _maxBallastWeight = 500f;\n    \n    [Header(\"Sonar\")]\n    [SerializeField] private float _sonarRange = 100f;\n    [SerializeField] private LayerMask _sonarLayerMask = -1;\n    [SerializeField] private AudioSource _sonarAudioSource;\n    [SerializeField] private AudioClip _sonarPingSound;\n    \n    [Header(\"Lights\")]\n    [SerializeField] private Light[] _submarineLights;\n    [SerializeField] private float _lightIntensityAtSurface = 0.5f;\n    [SerializeField] private float _lightIntensityAtDepth = 2f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bubbleEffect;\n    [SerializeField] private ParticleSystem _propellerEffect;\n    [SerializeField] private Transform _propellerTransform;\n    [SerializeField] private float _propellerRotationSpeed = 360f;\n    \n    private Rigidbody _rigidbody;\n    private float _currentBallastWeight = 0f;\n    private float _waterSurfaceY = 0f;\n    private bool _isSubmerged = false;\n    private float _currentDepth = 0f;\n    private float _sonarCooldown = 0f;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        SetupUnderwaterPhysics();\n        InitializeLights();\n        InitializeEffects();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateDepth();\n        UpdateLighting();\n        UpdateEffects();\n        UpdateSonar();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyBuoyancy();\n        ApplyMovement();\n        ApplyBallastSystem();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        float dive = 0f;\n        \n        if (Input.GetKey(KeyCode.Q)) dive = 1f;\n        if (Input.GetKey(KeyCode.E)) dive = -1f;\n        \n        // Store input for FixedUpdate\n        _horizontalInput = horizontal;\n        _verticalInput = vertical;\n        _diveInput = dive;\n        \n        // Ballast controls\n        if (Input.GetKey(KeyCode.F))\n        {\n            FillBallast();\n        }\n        else if (Input.GetKey(KeyCode.R))\n        {\n            EmptyBallast();\n        }\n        \n        // Sonar\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            TriggerSonar();\n        }\n        \n        // Lights toggle\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            ToggleLights();\n        }\n    }\n    \n    private float _horizontalInput;\n    private float _verticalInput;\n    private float _diveInput;\n    \n    private void ApplyMovement()\n    {\n        // Forward/backward movement\n        Vector3 forwardForce = transform.forward * _verticalInput * _forwardSpeed;\n        _rigidbody.AddForce(forwardForce);\n        \n        // Rotation\n        float torque = _horizontalInput * _rotationSpeed;\n        _rigidbody.AddTorque(0, torque, 0);\n        \n        // Vertical movement (diving/surfacing)\n        Vector3 verticalForce = Vector3.up * _diveInput * _verticalSpeed;\n        _rigidbody.AddForce(verticalForce);\n        \n        // Clamp depth\n        Vector3 position = transform.position;\n        position.y = Mathf.Clamp(position.y, _maxDepth, _minDepth);\n        transform.position = position;\n    }\n    \n    private void ApplyBuoyancy()\n    {\n        if (_isSubmerged)\n        {\n            float buoyancyAdjustment = _buoyancyForce - _currentBallastWeight;\n            _rigidbody.AddForce(Vector3.up * buoyancyAdjustment);\n        }\n    }\n    \n    private void ApplyBallastSystem()\n    {\n        // Natural ballast adjustment based on depth\n        float depthRatio = Mathf.Abs(_currentDepth) / Mathf.Abs(_maxDepth);\n        float targetBallast = depthRatio * _maxBallastWeight * 0.3f;\n        \n        if (_currentBallastWeight < targetBallast)\n        {\n            _currentBallastWeight += _ballastFillRate * Time.fixedDeltaTime;\n        }\n        else if (_currentBallastWeight > targetBallast)\n        {\n            _currentBallastWeight -= _ballastEmptyRate * Time.fixedDeltaTime;\n        }\n        \n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void FillBallast()\n    {\n        _currentBallastWeight += _ballastFillRate * Time.deltaTime;\n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void EmptyBallast()\n    {\n        _currentBallastWeight -= _ballastEmptyRate * Time.deltaTime;\n        _currentBallastWeight = Mathf.Clamp(_currentBallastWeight, 0f, _maxBallastWeight);\n    }\n    \n    private void SetupUnderwaterPhysics()\n    {\n        _rigidbody.drag = _waterDrag;\n        _rigidbody.angularDrag = _waterAngularDrag;\n        _rigidbody.useGravity = true;\n    }\n    \n    private void UpdateDepth()\n    {\n        _currentDepth = transform.position.y - _waterSurfaceY;\n        _isSubmerged = _currentDepth < 0f;\n    }\n    \n    private void InitializeLights()\n    {\n        if (_submarineLights == null || _submarineLights.Length == 0)\n        {\n            _submarineLights = GetComponentsInChildren<Light>();\n        }\n    }\n    \n    private void UpdateLighting()\n    {\n        if (_submarineLights == null) return;\n        \n        float depthRatio = Mathf.Abs(_currentDepth) / Mathf.Abs(_maxDepth);\n        float targetIntensity = Mathf.Lerp(_lightIntensityAtSurface, _lightIntensityAtDepth, depthRatio);\n        \n        foreach (Light light in _submarineLights)\n        {\n            if (light != null)\n            {\n                light.intensity = targetIntensity;\n            }\n        }\n    }\n    \n    private void ToggleLights()\n    {\n        if (_submarineLights == null) return;\n        \n        foreach (Light light in _submarineLights)\n        {\n            if (light != null)\n            {\n                light.enabled = !light.enabled;\n            }\n        }\n    }\n    \n    private void InitializeEffects()\n    {\n        if (_bubbleEffect != null)\n        {\n            var emission = _bubbleEffect.emission;\n            emission.enabled = false;\n        }\n        \n        if (_propellerEffect != null)\n        {\n            var emission = _propellerEffect.emission;\n            emission.enabled = false;\n        }\n    }\n    \n    private void UpdateEffects()\n    {\n        UpdateBubbleEffect();\n        UpdatePropellerEffect();\n        UpdatePropellerRotation();\n    }\n    \n    private void UpdateBubbleEffect()\n    {\n        if (_bubbleEffect == null) return;\n        \n        var emission = _bubbleEffect.emission;\n        bool shouldEmit = _isSubmerged && (_diveInput != 0f || _rigidbody.velocity.magnitude > 1f);\n        emission.enabled = shouldEmit;\n        \n        if (shouldEmit)\n        {\n            emission.rateOverTime = Mathf.Abs(_currentDepth) * 2f;\n        }\n    }\n    \n    private void UpdatePropellerEffect()\n    {\n        if (_propellerEffect == null) return;\n        \n        var emission = _propellerEffect.emission;\n        bool shouldEmit = Mathf.Abs(_verticalInput) > 0.1f;\n        emission.enabled = shouldEmit;\n        \n        if (shouldEmit)\n        {\n            emission.rateOverTime = Mathf.Abs(_verticalInput) * 50f;\n        }\n    }\n    \n    private void UpdatePropellerRotation()\n    {\n        if (_propellerTransform == null) return;\n        \n        float rotationAmount = _verticalInput * _propellerRotationSpeed * Time.deltaTime;\n        _propellerTransform.Rotate(0, 0, rotationAmount);\n    }\n    \n    private void UpdateSonar()\n    {\n        if (_sonarCooldown > 0f)\n        {\n            _sonarCooldown -= Time.deltaTime;\n        }\n    }\n    \n    private void TriggerSonar()\n    {\n        if (_sonarCooldown > 0f) return;\n        \n        _sonarCooldown = 2f;\n        \n        if (_sonarAudioSource != null && _sonarPingSound != null)\n        {\n            _sonarAudioSource.PlayOneShot(_sonarPingSound);\n        }\n        \n        // Detect objects in range\n        Collider[] detectedObjects = Physics.OverlapSphere(transform.position, _sonarRange, _sonarLayerMask);\n        \n        foreach (Collider col in detectedObjects)\n        {\n            if (col.gameObject != gameObject)\n            {\n                Debug.Log($\"Sonar detected: {col.name} at distance {Vector3.Distance(transform.position, col.transform.position):F1}m\");\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            Debug.Log(\"Player entered submarine trigger zone\");\n        }\n        \n        if (other.name.Contains(\"Fish\") || other.CompareTag(\"Fish\"))\n        {\n            Debug.Log(\"Fish detected near submarine\");\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw sonar range\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _sonarRange);\n        \n        // Draw depth limits\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(new Vector3(transform.position.x - 5f, _maxDepth, transform.position.z),\n                       new Vector3(transform.position.x + 5f, _maxDepth, transform.position.z));\n        \n        Gizmos.color = Color.green;\n        Gizmos.DrawLine(new Vector3(transform.position.x - 5f, _minDepth, transform.position.z),\n                       new Vector3(transform.position.x + 5f, _minDepth, transform.position.z));\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SaveLoadSystem\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"saveFileName\",\n      \"type\": \"string\",\n      \"default\": \"savegame.json\"\n    },\n    {\n      \"name\": \"autoSaveInterval\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"lastSaveTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"saveData\",\n      \"type\": \"Dictionary<string, object>\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_save_system\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"create empty save data dictionary\"\n        },\n        {\n          \"action\": \"check if save file exists on disk\"\n        },\n        {\n          \"action\": \"load existing save file if found\"\n        }\n      ]\n    },\n    {\n      \"name\": \"auto_save_check\",\n      \"trigger\": \"every frame update\",\n      \"actions\": [\n        {\n          \"action\": \"check if enough time has passed since last save\"\n        },\n        {\n          \"action\": \"perform auto save if interval exceeded\"\n        }\n      ]\n    },\n    {\n      \"name\": \"save_game_data\",\n      \"trigger\": \"when save game is requested\",\n      \"actions\": [\n        {\n          \"action\": \"collect player position and rotation\"\n        },\n        {\n          \"action\": \"collect player health and stats\"\n        },\n        {\n          \"action\": \"collect inventory items and quantities\"\n        },\n        {\n          \"action\": \"collect level progress and unlocked areas\"\n        },\n        {\n          \"action\": \"collect game settings and preferences\"\n        },\n        {\n          \"action\": \"convert all data to JSON format\"\n        },\n        {\n          \"action\": \"write JSON data to save file\"\n        },\n        {\n          \"action\": \"update last save timestamp\"\n        },\n        {\n          \"action\": \"display save confirmation message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"load_game_data\",\n      \"trigger\": \"when load game is requested\",\n      \"actions\": [\n        {\n          \"action\": \"check if save file exists\"\n        },\n        {\n          \"action\": \"read JSON data from save file\"\n        },\n        {\n          \"action\": \"parse JSON into game data objects\"\n        },\n        {\n          \"action\": \"restore player position and rotation\"\n        },\n        {\n          \"action\": \"restore player health and stats\"\n        },\n        {\n          \"action\": \"restore inventory items and quantities\"\n        },\n        {\n          \"action\": \"restore level progress and unlocked areas\"\n        },\n        {\n          \"action\": \"restore game settings and preferences\"\n        },\n        {\n          \"action\": \"display load confirmation message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"delete_save_data\",\n      \"trigger\": \"when delete save is requested\",\n      \"actions\": [\n        {\n          \"action\": \"show confirmation dialog to player\"\n        },\n        {\n          \"action\": \"delete save file from disk if confirmed\"\n        },\n        {\n          \"action\": \"clear save data dictionary\"\n        },\n        {\n          \"action\": \"reset last save timestamp\"\n        },\n        {\n          \"action\": \"display deletion confirmation message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_save_error\",\n      \"trigger\": \"when save operation fails\",\n      \"actions\": [\n        {\n          \"action\": \"log error details to console\"\n        },\n        {\n          \"action\": \"display error message to player\"\n        },\n        {\n          \"action\": \"attempt to create backup save file\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_load_error\",\n      \"trigger\": \"when load operation fails\",\n      \"actions\": [\n        {\n          \"action\": \"log error details to console\"\n        },\n        {\n          \"action\": \"display error message to player\"\n        },\n        {\n          \"action\": \"start new game with default values\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class SaveLoadSystem : MonoBehaviour\n{\n    [System.Serializable]\n    public class GameData\n    {\n        public Vector3 playerPosition;\n        public Quaternion playerRotation;\n        public float playerHealth = 100f;\n        public int playerScore = 0;\n        public int playerLevel = 1;\n        public float playerExperience = 0f;\n        public List<string> unlockedAchievements = new List<string>();\n        public List<string> collectedItems = new List<string>();\n        public Dictionary<string, bool> gameFlags = new Dictionary<string, bool>();\n        public Dictionary<string, float> gameValues = new Dictionary<string, float>();\n        public string currentScene = \"\";\n        public float totalPlayTime = 0f;\n        public DateTime lastSaveTime;\n        \n        public GameData()\n        {\n            lastSaveTime = DateTime.Now;\n        }\n    }\n\n    [System.Serializable]\n    public class SaveSlot\n    {\n        public string slotName;\n        public GameData gameData;\n        public DateTime saveTime;\n        public string sceneName;\n        public float playTime;\n        public Texture2D screenshot;\n    }\n\n    [Header(\"Save Settings\")]\n    [SerializeField] private string _saveFileName = \"GameSave\";\n    [SerializeField] private string _saveFileExtension = \".json\";\n    [SerializeField] private int _maxSaveSlots = 5;\n    [SerializeField] private bool _autoSaveEnabled = true;\n    [SerializeField] private float _autoSaveInterval = 300f;\n\n    [Header(\"Player References\")]\n    [SerializeField] private Transform _playerTransform;\n    [SerializeField] private GameObject _playerGameObject;\n\n    [Header(\"Events\")]\n    public UnityEvent OnSaveStarted;\n    public UnityEvent OnSaveCompleted;\n    public UnityEvent OnLoadStarted;\n    public UnityEvent OnLoadCompleted;\n    public UnityEvent<string> OnSaveError;\n    public UnityEvent<string> OnLoadError;\n\n    private GameData _currentGameData;\n    private List<SaveSlot> _saveSlots;\n    private float _autoSaveTimer;\n    private float _sessionStartTime;\n    private string _saveFolderPath;\n\n    public GameData CurrentGameData => _currentGameData;\n    public List<SaveSlot> SaveSlots => _saveSlots;\n\n    private void Awake()\n    {\n        _currentGameData = new GameData();\n        _saveSlots = new List<SaveSlot>();\n        _sessionStartTime = Time.time;\n        \n        _saveFolderPath = Path.Combine(Application.persistentDataPath, \"Saves\");\n        \n        if (!Directory.Exists(_saveFolderPath))\n        {\n            Directory.CreateDirectory(_saveFolderPath);\n        }\n\n        if (_playerTransform == null && _playerGameObject == null)\n        {\n            GameObject player = GameObject.FindGameObjectWithTag(\"Player\");\n            if (player != null)\n            {\n                _playerTransform = player.transform;\n                _playerGameObject = player;\n            }\n        }\n    }\n\n    private void Start()\n    {\n        LoadSaveSlots();\n        InitializeGameData();\n    }\n\n    private void Update()\n    {\n        if (_autoSaveEnabled)\n        {\n            _autoSaveTimer += Time.deltaTime;\n            if (_autoSaveTimer >= _autoSaveInterval)\n            {\n                AutoSave();\n                _autoSaveTimer = 0f;\n            }\n        }\n\n        UpdatePlayTime();\n    }\n\n    private void InitializeGameData()\n    {\n        _currentGameData.currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;\n        \n        if (_playerTransform != null)\n        {\n            _currentGameData.playerPosition = _playerTransform.position;\n            _currentGameData.playerRotation = _playerTransform.rotation;\n        }\n    }\n\n    private void UpdatePlayTime()\n    {\n        _currentGameData.totalPlayTime = Time.time - _sessionStartTime;\n    }\n\n    public void SaveGame(int slotIndex = 0)\n    {\n        try\n        {\n            OnSaveStarted?.Invoke();\n            \n            UpdateCurrentGameData();\n            \n            SaveSlot saveSlot = new SaveSlot\n            {\n                slotName = $\"Save Slot {slotIndex + 1}\",\n                gameData = _currentGameData,\n                saveTime = DateTime.Now,\n                sceneName = _currentGameData.currentScene,\n                playTime = _currentGameData.totalPlayTime\n            };\n\n            string json = JsonUtility.ToJson(saveSlot, true);\n            string filePath = GetSaveFilePath(slotIndex);\n            \n            File.WriteAllText(filePath, json);\n            \n            UpdateSaveSlot(slotIndex, saveSlot);\n            \n            OnSaveCompleted?.Invoke();\n            Debug.Log($\"Game saved to slot {slotIndex}\");\n        }\n        catch (Exception e)\n        {\n            OnSaveError?.Invoke($\"Save failed: {e.Message}\");\n            Debug.LogError($\"Save failed: {e.Message}\");\n        }\n    }\n\n    public void LoadGame(int slotIndex = 0)\n    {\n        try\n        {\n            OnLoadStarted?.Invoke();\n            \n            string filePath = GetSaveFilePath(slotIndex);\n            \n            if (!File.Exists(filePath))\n            {\n                OnLoadError?.Invoke(\"Save file not found\");\n                return;\n            }\n\n            string json = File.ReadAllText(filePath);\n            SaveSlot saveSlot = JsonUtility.FromJson<SaveSlot>(json);\n            \n            if (saveSlot?.gameData != null)\n            {\n                _currentGameData = saveSlot.gameData;\n                ApplyGameData();\n                OnLoadCompleted?.Invoke();\n                Debug.Log($\"Game loaded from slot {slotIndex}\");\n            }\n            else\n            {\n                OnLoadError?.Invoke(\"Invalid save data\");\n            }\n        }\n        catch (Exception e)\n        {\n            OnLoadError?.Invoke($\"Load failed: {e.Message}\");\n            Debug.LogError($\"Load failed: {e.Message}\");\n        }\n    }\n\n    private void UpdateCurrentGameData()\n    {\n        _currentGameData.lastSaveTime = DateTime.Now;\n        _currentGameData.currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;\n        \n        if (_playerTransform != null)\n        {\n            _currentGameData.playerPosition = _playerTransform.position;\n            _currentGameData.playerRotation = _playerTransform.rotation;\n        }\n    }\n\n    private void ApplyGameData()\n    {\n        if (_playerTransform != null)\n        {\n            _playerTransform.position = _currentGameData.playerPosition;\n            _playerTransform.rotation = _currentGameData.playerRotation;\n        }\n\n        if (_currentGameData.currentScene != UnityEngine.SceneManagement.SceneManager.GetActiveScene().name)\n        {\n            UnityEngine.SceneManagement.SceneManager.LoadScene(_currentGameData.currentScene);\n        }\n    }\n\n    public void AutoSave()\n    {\n        SaveGame(0);\n        Debug.Log(\"Auto-save completed\");\n    }\n\n    public void DeleteSave(int slotIndex)\n    {\n        try\n        {\n            string filePath = GetSaveFilePath(slotIndex);\n            \n            if (File.Exists(filePath))\n            {\n                File.Delete(filePath);\n                \n                if (slotIndex < _saveSlots.Count)\n                {\n                    _saveSlots[slotIndex] = null;\n                }\n                \n                Debug.Log($\"Save slot {slotIndex} deleted\");\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Failed to delete save: {e.Message}\");\n        }\n    }\n\n    public bool HasSave(int slotIndex)\n    {\n        string filePath = GetSaveFilePath(slotIndex);\n        return File.Exists(filePath);\n    }\n\n    public SaveSlot GetSaveSlot(int slotIndex)\n    {\n        if (slotIndex >= 0 && slotIndex < _saveSlots.Count)\n        {\n            return _saveSlots[slotIndex];\n        }\n        return null;\n    }\n\n    private void LoadSaveSlots()\n    {\n        _saveSlots.Clear();\n        \n        for (int i = 0; i < _maxSaveSlots; i++)\n        {\n            string filePath = GetSaveFilePath(i);\n            \n            if (File.Exists(filePath))\n            {\n                try\n                {\n                    string json = File.ReadAllText(filePath);\n                    SaveSlot saveSlot = JsonUtility.FromJson<SaveSlot>(json);\n                    _saveSlots.Add(saveSlot);\n                }\n                catch (Exception e)\n                {\n                    Debug.LogError($\"Failed to load save slot {i}: {e.Message}\");\n                    _saveSlots.Add(null);\n                }\n            }\n            else\n            {\n                _saveSlots.Add(null);\n            }\n        }\n    }\n\n    private void UpdateSaveSlot(int slotIndex, SaveSlot saveSlot)\n    {\n        while (_saveSlots.Count <= slotIndex)\n        {\n            _saveSlots.Add(null);\n        }\n        \n        _saveSlots[slotIndex] = saveSlot;\n    }\n\n    private string GetSaveFilePath(int slotIndex)\n    {\n        return Path.Combine(_saveFolderPath, $\"{_saveFileName}_{slotIndex}{_saveFileExtension}\");\n    }\n\n    public void SetGameFlag(string flagName, bool value)\n    {\n        _currentGameData.gameFlags[flagName] = value;\n    }\n\n    public bool GetGameFlag(string flagName, bool defaultValue = false)\n    {\n        return _currentGameData.gameFlags.ContainsKey(flagName) ? _currentGameData.gameFlags[flagName] : defaultValue;\n    }\n\n    public void SetGameValue(string valueName, float value)\n    {\n        _currentGameData.gameValues[valueName] = value;\n    }\n\n    public float GetGameValue(string valueName, float defaultValue = 0f)\n    {\n        return _currentGameData.gameValues.ContainsKey(valueName) ? _currentGameData.gameValues[valueName] : defaultValue;\n    }\n\n    public void AddCollectedItem(string itemId)\n    {\n        if (!_currentGameData.collectedItems.Contains(itemId))\n        {\n            _currentGameData.collectedItems.Add(itemId);\n        }\n    }\n\n    public bool HasCollectedItem(string itemId)\n    {\n        return _currentGameData.collectedItems.Contains(itemId);\n    }\n\n    public void UnlockAchievement(string achievementId)\n    {\n        if (!_currentGameData.unlockedAchievements.Contains(achievementId))\n        {\n            _currentGameData.unlockedAchievements.Add(achievementId);\n        }\n    }\n\n    public bool IsAchievementUnlocked(string achievementId)\n    {\n        return _currentGameData.unlockedAchievements.Contains(achievementId);\n    }\n\n    private void OnApplicationPause(bool pauseStatus)\n    {\n        if (pauseStatus && _autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n\n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (!hasFocus && _autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (_autoSaveEnabled)\n        {\n            AutoSave();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"QuantumObject\",\n  \"components\": [\n    \"MeshRenderer\",\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"flickerSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"superpositionPositions\",\n      \"type\": \"Vector3[]\",\n      \"default\": []\n    },\n    {\n      \"name\": \"observationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"quantumHumSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"normalMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    },\n    {\n      \"name\": \"translucentMaterial\",\n      \"type\": \"Material\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isObserved\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_observation\",\n      \"trigger\": \"player is looking at this object with raycast hit within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"set observed state to true\"\n        },\n        {\n          \"action\": \"collapse to single visible state\"\n        },\n        {\n          \"action\": \"apply normal material to make fully opaque\"\n        },\n        {\n          \"action\": \"stop quantum hum sound\"\n        },\n        {\n          \"action\": \"play observation sound once\"\n        },\n        {\n          \"action\": \"stop flickering between positions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enter_superposition\",\n      \"trigger\": \"player is not looking at this object or raycast does not hit\",\n      \"actions\": [\n        {\n          \"action\": \"set observed state to false\"\n        },\n        {\n          \"action\": \"apply translucent material\"\n        },\n        {\n          \"action\": \"start flickering between multiple positions from superposition array\"\n        },\n        {\n          \"action\": \"play quantum hum sound continuously\"\n        },\n        {\n          \"action\": \"stop observation sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"flicker_positions\",\n      \"trigger\": \"object is in superposition state and flicker timer expires\",\n      \"actions\": [\n        {\n          \"action\": \"move to next position in superposition positions array\"\n        },\n        {\n          \"action\": \"reset flicker timer based on flicker speed\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class QuantumObject : MonoBehaviour\n{\n    [Header(\"Quantum States\")]\n    [SerializeField] private float _observationDistance = 10f;\n    [SerializeField] private LayerMask _obstacleLayerMask = -1;\n    \n    [Header(\"Superposition Settings\")]\n    [SerializeField] private float _flickerSpeed = 2f;\n    [SerializeField] private float _positionVariance = 0.5f;\n    [SerializeField] private int _superpositionCount = 3;\n    [SerializeField] private float _transparencyInSuperposition = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _observationSound;\n    [SerializeField] private AudioClip _quantumHumSound;\n    [SerializeField] private float _humVolume = 0.5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _collapseEffect;\n    [SerializeField] private float _materialTransitionSpeed = 2f;\n    \n    private Camera _playerCamera;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private Material _originalMaterial;\n    private Material _quantumMaterial;\n    \n    private bool _isObserved = false;\n    private bool _wasObservedLastFrame = false;\n    private Vector3 _originalPosition;\n    private Vector3[] _superpositionPositions;\n    private int _currentSuperpositionIndex = 0;\n    private float _flickerTimer = 0f;\n    private float _currentTransparency = 1f;\n    private Coroutine _humCoroutine;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        _renderer = GetComponent<Renderer>();\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n            _audioSource.spatialBlend = 1f;\n        }\n        \n        _originalPosition = transform.position;\n        _originalMaterial = _renderer.material;\n        _quantumMaterial = new Material(_originalMaterial);\n        \n        GenerateSuperpositionPositions();\n        StartQuantumHum();\n    }\n    \n    private void Update()\n    {\n        CheckObservationState();\n        UpdateQuantumBehavior();\n    }\n    \n    private void CheckObservationState()\n    {\n        _wasObservedLastFrame = _isObserved;\n        _isObserved = false;\n        \n        if (_playerCamera == null) return;\n        \n        Vector3 directionToObject = (transform.position - _playerCamera.transform.position).normalized;\n        float distanceToObject = Vector3.Distance(_playerCamera.transform.position, transform.position);\n        \n        if (distanceToObject <= _observationDistance)\n        {\n            float dotProduct = Vector3.Dot(_playerCamera.transform.forward, directionToObject);\n            \n            if (dotProduct > 0.5f)\n            {\n                Ray observationRay = new Ray(_playerCamera.transform.position, directionToObject);\n                \n                if (Physics.Raycast(observationRay, out RaycastHit hit, distanceToObject, _obstacleLayerMask))\n                {\n                    if (hit.collider.gameObject == gameObject)\n                    {\n                        _isObserved = true;\n                    }\n                }\n            }\n        }\n        \n        if (_isObserved != _wasObservedLastFrame)\n        {\n            OnObservationStateChanged();\n        }\n    }\n    \n    private void UpdateQuantumBehavior()\n    {\n        if (_isObserved)\n        {\n            UpdateObservedState();\n        }\n        else\n        {\n            UpdateSuperpositionState();\n        }\n        \n        UpdateMaterialTransparency();\n    }\n    \n    private void UpdateObservedState()\n    {\n        transform.position = Vector3.Lerp(transform.position, _originalPosition, Time.deltaTime * 5f);\n        _currentTransparency = Mathf.Lerp(_currentTransparency, 1f, Time.deltaTime * _materialTransitionSpeed);\n    }\n    \n    private void UpdateSuperpositionState()\n    {\n        _flickerTimer += Time.deltaTime * _flickerSpeed;\n        \n        if (_flickerTimer >= 1f)\n        {\n            _flickerTimer = 0f;\n            _currentSuperpositionIndex = (_currentSuperpositionIndex + 1) % _superpositionCount;\n        }\n        \n        Vector3 targetPosition = Vector3.Lerp(\n            _superpositionPositions[_currentSuperpositionIndex],\n            _superpositionPositions[(_currentSuperpositionIndex + 1) % _superpositionCount],\n            _flickerTimer\n        );\n        \n        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 3f);\n        _currentTransparency = Mathf.Lerp(_currentTransparency, _transparencyInSuperposition, Time.deltaTime * _materialTransitionSpeed);\n    }\n    \n    private void UpdateMaterialTransparency()\n    {\n        Color materialColor = _quantumMaterial.color;\n        materialColor.a = _currentTransparency;\n        _quantumMaterial.color = materialColor;\n        _renderer.material = _quantumMaterial;\n    }\n    \n    private void OnObservationStateChanged()\n    {\n        if (_isObserved)\n        {\n            OnCollapse();\n        }\n        else\n        {\n            OnEnterSuperposition();\n        }\n    }\n    \n    private void OnCollapse()\n    {\n        if (_observationSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_observationSound);\n        }\n        \n        if (_collapseEffect != null)\n        {\n            _collapseEffect.Play();\n        }\n        \n        StopQuantumHum();\n    }\n    \n    private void OnEnterSuperposition()\n    {\n        GenerateSuperpositionPositions();\n        StartQuantumHum();\n    }\n    \n    private void GenerateSuperpositionPositions()\n    {\n        _superpositionPositions = new Vector3[_superpositionCount];\n        \n        for (int i = 0; i < _superpositionCount; i++)\n        {\n            Vector3 randomOffset = new Vector3(\n                Random.Range(-_positionVariance, _positionVariance),\n                Random.Range(-_positionVariance * 0.5f, _positionVariance * 0.5f),\n                Random.Range(-_positionVariance, _positionVariance)\n            );\n            \n            _superpositionPositions[i] = _originalPosition + randomOffset;\n        }\n    }\n    \n    private void StartQuantumHum()\n    {\n        if (_quantumHumSound != null && _audioSource != null && _humCoroutine == null)\n        {\n            _humCoroutine = StartCoroutine(PlayQuantumHum());\n        }\n    }\n    \n    private void StopQuantumHum()\n    {\n        if (_humCoroutine != null)\n        {\n            StopCoroutine(_humCoroutine);\n            _humCoroutine = null;\n        }\n        \n        if (_audioSource != null && _audioSource.isPlaying && _audioSource.clip == _quantumHumSound)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private IEnumerator PlayQuantumHum()\n    {\n        while (!_isObserved)\n        {\n            if (_audioSource != null && _quantumHumSound != null)\n            {\n                _audioSource.clip = _quantumHumSound;\n                _audioSource.volume = _humVolume;\n                _audioSource.loop = true;\n                _audioSource.Play();\n                \n                yield return new WaitWhile(() => !_isObserved && _audioSource.isPlaying);\n            }\n            else\n            {\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_quantumMaterial != null)\n        {\n            DestroyImmediate(_quantumMaterial);\n        }\n        \n        StopQuantumHum();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.cyan;\n        Gizmos.DrawWireSphere(transform.position, _observationDistance);\n        \n        if (_superpositionPositions != null)\n        {\n            Gizmos.color = Color.red;\n            foreach (Vector3 pos in _superpositionPositions)\n            {\n                Gizmos.DrawWireCube(pos, Vector3.one * 0.1f);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Waterfall\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"mistIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"waterFlowRate\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"mistSpreadRadius\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"soundVolume\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"generate_water_particles\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"emit water particles downward at flow rate\"\n        },\n        {\n          \"action\": \"apply gravity to water particles\"\n        },\n        {\n          \"action\": \"fade out particles as they fall\"\n        }\n      ]\n    },\n    {\n      \"name\": \"create_mist_effect\",\n      \"trigger\": \"when water particles hit bottom\",\n      \"actions\": [\n        {\n          \"action\": \"spawn mist particles at impact point\"\n        },\n        {\n          \"action\": \"spread mist particles outward in radius\"\n        },\n        {\n          \"action\": \"make mist particles rise slowly\"\n        },\n        {\n          \"action\": \"fade mist particles over time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"play_waterfall_sound\",\n      \"trigger\": \"continuously while active\",\n      \"actions\": [\n        {\n          \"action\": \"play rushing water sound at specified volume\"\n        },\n        {\n          \"action\": \"adjust sound intensity based on flow rate\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_mist_density\",\n      \"trigger\": \"when mist intensity changes\",\n      \"actions\": [\n        {\n          \"action\": \"increase or decrease mist particle count\"\n        },\n        {\n          \"action\": \"modify mist particle size based on intensity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class Waterfall : MonoBehaviour\n{\n    [Header(\"Water Settings\")]\n    [SerializeField] private ParticleSystem _waterParticles;\n    [SerializeField] private float _waterFlowRate = 100f;\n    [SerializeField] private float _waterSpeed = 5f;\n    [SerializeField] private Color _waterColor = Color.cyan;\n    \n    [Header(\"Mist Settings\")]\n    [SerializeField] private ParticleSystem _mistParticles;\n    [SerializeField] private float _mistDensity = 50f;\n    [SerializeField] private float _mistSpread = 2f;\n    [SerializeField] private Color _mistColor = Color.white;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _waterfallSound;\n    [SerializeField] private float _audioVolume = 0.7f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private BoxCollider _splashZone;\n    [SerializeField] private float _splashForce = 10f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Light _mistLight;\n    [SerializeField] private float _lightIntensity = 0.5f;\n    [SerializeField] private Color _lightColor = Color.white;\n    [SerializeField] private AnimationCurve _intensityCurve = AnimationCurve.EaseInOut(0f, 0.3f, 1f, 1f);\n    \n    private float _timeOffset;\n    private Vector3 _originalLightPosition;\n    private List<Rigidbody> _objectsInSplashZone = new List<Rigidbody>();\n    \n    void Start()\n    {\n        _timeOffset = Random.Range(0f, 100f);\n        SetupWaterParticles();\n        SetupMistParticles();\n        SetupAudio();\n        SetupSplashZone();\n        SetupLighting();\n    }\n    \n    void SetupWaterParticles()\n    {\n        if (_waterParticles == null)\n        {\n            GameObject waterGO = new GameObject(\"WaterParticles\");\n            waterGO.transform.SetParent(transform);\n            waterGO.transform.localPosition = Vector3.zero;\n            _waterParticles = waterGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _waterParticles.main;\n        main.startLifetime = 3f;\n        main.startSpeed = _waterSpeed;\n        main.startSize = 0.1f;\n        main.startColor = _waterColor;\n        main.maxParticles = (int)_waterFlowRate;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _waterParticles.emission;\n        emission.rateOverTime = _waterFlowRate;\n        \n        var shape = _waterParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(1f, 0.1f, 0.5f);\n        \n        var velocityOverLifetime = _waterParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(-_waterSpeed);\n        \n        var collision = _waterParticles.collision;\n        collision.enabled = true;\n        collision.type = ParticleSystemCollisionType.World;\n        collision.mode = ParticleSystemCollisionMode.Collision3D;\n        collision.dampen = 0.3f;\n        collision.bounce = 0.1f;\n    }\n    \n    void SetupMistParticles()\n    {\n        if (_mistParticles == null)\n        {\n            GameObject mistGO = new GameObject(\"MistParticles\");\n            mistGO.transform.SetParent(transform);\n            mistGO.transform.localPosition = new Vector3(0f, -2f, 0f);\n            _mistParticles = mistGO.AddComponent<ParticleSystem>();\n        }\n        \n        var main = _mistParticles.main;\n        main.startLifetime = 5f;\n        main.startSpeed = 0.5f;\n        main.startSize = new ParticleSystem.MinMaxCurve(0.5f, 2f);\n        main.startColor = _mistColor;\n        main.maxParticles = (int)_mistDensity;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = _mistParticles.emission;\n        emission.rateOverTime = _mistDensity;\n        \n        var shape = _mistParticles.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Box;\n        shape.scale = new Vector3(_mistSpread, 0.5f, _mistSpread);\n        \n        var velocityOverLifetime = _mistParticles.velocityOverLifetime;\n        velocityOverLifetime.enabled = true;\n        velocityOverLifetime.space = ParticleSystemSimulationSpace.World;\n        velocityOverLifetime.y = new ParticleSystem.MinMaxCurve(0.2f, 1f);\n        \n        var sizeOverLifetime = _mistParticles.sizeOverLifetime;\n        sizeOverLifetime.enabled = true;\n        sizeOverLifetime.size = new ParticleSystem.MinMaxCurve(1f, AnimationCurve.Linear(0f, 0.2f, 1f, 1f));\n        \n        var colorOverLifetime = _mistParticles.colorOverLifetime;\n        colorOverLifetime.enabled = true;\n        Gradient gradient = new Gradient();\n        gradient.SetKeys(\n            new GradientColorKey[] { new GradientColorKey(_mistColor, 0f), new GradientColorKey(_mistColor, 1f) },\n            new GradientAlphaKey[] { new GradientAlphaKey(0f, 0f), new GradientAlphaKey(0.8f, 0.3f), new GradientAlphaKey(0f, 1f) }\n        );\n        colorOverLifetime.color = gradient;\n    }\n    \n    void SetupAudio()\n    {\n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        \n        if (_waterfallSound != null)\n        {\n            _audioSource.clip = _waterfallSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            _audioSource.spatialBlend = 1f;\n            _audioSource.rolloffMode = AudioRolloffMode.Logarithmic;\n            _audioSource.maxDistance = 20f;\n            _audioSource.Play();\n        }\n    }\n    \n    void SetupSplashZone()\n    {\n        if (_splashZone == null)\n        {\n            _splashZone = gameObject.AddComponent<BoxCollider>();\n            _splashZone.isTrigger = true;\n            _splashZone.size = new Vector3(2f, 1f, 2f);\n            _splashZone.center = new Vector3(0f, -2.5f, 0f);\n        }\n    }\n    \n    void SetupLighting()\n    {\n        if (_mistLight == null)\n        {\n            GameObject lightGO = new GameObject(\"MistLight\");\n            lightGO.transform.SetParent(transform);\n            lightGO.transform.localPosition = new Vector3(0f, -1f, 1f);\n            _mistLight = lightGO.AddComponent<Light>();\n        }\n        \n        _mistLight.type = LightType.Point;\n        _mistLight.color = _lightColor;\n        _mistLight.intensity = _lightIntensity;\n        _mistLight.range = 5f;\n        _mistLight.shadows = LightShadows.Soft;\n        \n        _originalLightPosition = _mistLight.transform.localPosition;\n    }\n    \n    void Update()\n    {\n        UpdateLighting();\n        UpdateParticleEffects();\n        ApplySplashForces();\n    }\n    \n    void UpdateLighting()\n    {\n        if (_mistLight != null)\n        {\n            float time = Time.time + _timeOffset;\n            float intensity = _intensityCurve.Evaluate((Mathf.Sin(time * 0.5f) + 1f) * 0.5f);\n            _mistLight.intensity = _lightIntensity * intensity;\n            \n            Vector3 offset = new Vector3(\n                Mathf.Sin(time * 0.3f) * 0.2f,\n                Mathf.Sin(time * 0.7f) * 0.1f,\n                Mathf.Cos(time * 0.4f) * 0.15f\n            );\n            _mistLight.transform.localPosition = _originalLightPosition + offset;\n        }\n    }\n    \n    void UpdateParticleEffects()\n    {\n        if (_waterParticles != null)\n        {\n            var emission = _waterParticles.emission;\n            emission.rateOverTime = _waterFlowRate;\n            \n            var main = _waterParticles.main;\n            main.startSpeed = _waterSpeed;\n            main.startColor = _waterColor;\n        }\n        \n        if (_mistParticles != null)\n        {\n            var emission = _mistParticles.emission;\n            emission.rateOverTime = _mistDensity;\n            \n            var main = _mistParticles.main;\n            main.startColor = _mistColor;\n            \n            var shape = _mistParticles.shape;\n            shape.scale = new Vector3(_mistSpread, 0.5f, _mistSpread);\n        }\n    }\n    \n    void ApplySplashForces()\n    {\n        for (int i = _objectsInSplashZone.Count - 1; i >= 0; i--)\n        {\n            if (_objectsInSplashZone[i] == null)\n            {\n                _objectsInSplashZone.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody rb = _objectsInSplashZone[i];\n            Vector3 splashDirection = Vector3.up + Random.insideUnitSphere * 0.3f;\n            rb.AddForce(splashDirection * _splashForce * Time.deltaTime, ForceMode.Force);\n        }\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (((1 << other.gameObject.layer) & _affectedLayers) != 0)\n        {\n            Rigidbody rb = other.GetComponent<Rigidbody>();\n            if (rb != null && !_objectsInSplashZone.Contains(rb))\n            {\n                _objectsInSplashZone.Add(rb);\n                \n                // Create splash effect\n                CreateSplashEffect(other.transform.position);\n            }\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null && _objectsInSplashZone.Contains(rb))\n        {\n            _objectsInSplashZone.Remove(rb);\n        }\n    }\n    \n    void CreateSplashEffect(Vector3 position)\n    {\n        GameObject splashGO = new GameObject(\"SplashEffect\");\n        splashGO.transform.position = position;\n        \n        ParticleSystem splash = splashGO.AddComponent<ParticleSystem>();\n        \n        var main = splash.main;\n        main.startLifetime = 1f;\n        main.startSpeed = 3f;\n        main.startSize = 0.2f;\n        main.startColor = _waterColor;\n        main.maxParticles = 20;\n        main.simulationSpace = ParticleSystemSimulationSpace.World;\n        \n        var emission = splash.emission;\n        emission.SetBursts(new ParticleSystem.Burst[] {\n            new ParticleSystem.Burst(0f, 20)\n        });\n        \n        var shape = splash.shape;\n        shape.enabled = true;\n        shape.shapeType = ParticleSystemShapeType.Hemisphere;\n        shape.radius = 0.5f;\n        \n        Destroy(splashGO, 2f);\n    }\n    \n    void OnValidate()\n    {\n        if (Application.isPlaying)\n        {\n            UpdateParticleEffects();\n            \n            if (_audioSource != null)\n                _audioSource.volume = _audioVolume;\n            \n            if (_mistLight != null)\n            {\n                _mistLight.color = _lightColor;\n                _mistLight.intensity = _lightIntensity;\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MessageSign\",\n  \"components\": [\n    \"Canvas\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"message\",\n      \"type\": \"string\",\n      \"default\": \"Welcome!\"\n    },\n    {\n      \"name\": \"displayDistance\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isVisible\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_message\",\n      \"trigger\": \"when player comes within display distance\",\n      \"actions\": [\n        {\n          \"action\": \"make text visible\"\n        },\n        {\n          \"action\": \"display the message text\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_message\",\n      \"trigger\": \"when player moves away from display distance\",\n      \"actions\": [\n        {\n          \"action\": \"make text invisible\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_sign\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"hide text initially\"\n        },\n        {\n          \"action\": \"set up message display\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\npublic class MessageSign : MonoBehaviour\n{\n    [Header(\"Sign Configuration\")]\n    [SerializeField] private string _signMessage = \"Welcome to the game!\";\n    [SerializeField] private float _displayDistance = 3f;\n    [SerializeField] private bool _requireInteraction = false;\n    [SerializeField] private KeyCode _interactionKey = KeyCode.E;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Canvas _messageCanvas;\n    [SerializeField] private TextMeshProUGUI _messageText;\n    [SerializeField] private Text _legacyMessageText;\n    [SerializeField] private GameObject _interactionPrompt;\n    \n    [Header(\"Display Settings\")]\n    [SerializeField] private float _fadeSpeed = 2f;\n    [SerializeField] private bool _lookAtPlayer = true;\n    [SerializeField] private Vector3 _canvasOffset = Vector3.up;\n    \n    private Transform _playerTransform;\n    private bool _playerInRange = false;\n    private bool _messageVisible = false;\n    private CanvasGroup _canvasGroup;\n    private Camera _mainCamera;\n    \n    private void Start()\n    {\n        _mainCamera = Camera.main;\n        if (_mainCamera == null)\n            _mainCamera = FindObjectOfType<Camera>();\n            \n        SetupCanvas();\n        SetupMessageText();\n        \n        if (_messageCanvas != null)\n            _messageCanvas.gameObject.SetActive(false);\n            \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void SetupCanvas()\n    {\n        if (_messageCanvas == null)\n        {\n            GameObject canvasObj = new GameObject(\"MessageCanvas\");\n            canvasObj.transform.SetParent(transform);\n            canvasObj.transform.localPosition = _canvasOffset;\n            \n            _messageCanvas = canvasObj.AddComponent<Canvas>();\n            _messageCanvas.renderMode = RenderMode.WorldSpace;\n            _messageCanvas.worldCamera = _mainCamera;\n            \n            canvasObj.AddComponent<CanvasScaler>();\n            canvasObj.AddComponent<GraphicRaycaster>();\n            \n            RectTransform rectTransform = canvasObj.GetComponent<RectTransform>();\n            rectTransform.sizeDelta = new Vector2(200, 100);\n            rectTransform.localScale = Vector3.one * 0.01f;\n        }\n        \n        _canvasGroup = _messageCanvas.GetComponent<CanvasGroup>();\n        if (_canvasGroup == null)\n            _canvasGroup = _messageCanvas.gameObject.AddComponent<CanvasGroup>();\n            \n        _canvasGroup.alpha = 0f;\n    }\n    \n    private void SetupMessageText()\n    {\n        if (_messageText == null && _legacyMessageText == null)\n        {\n            GameObject textObj = new GameObject(\"MessageText\");\n            textObj.transform.SetParent(_messageCanvas.transform);\n            \n            RectTransform textRect = textObj.AddComponent<RectTransform>();\n            textRect.anchorMin = Vector2.zero;\n            textRect.anchorMax = Vector2.one;\n            textRect.offsetMin = Vector2.zero;\n            textRect.offsetMax = Vector2.zero;\n            \n            _messageText = textObj.AddComponent<TextMeshProUGUI>();\n            if (_messageText != null)\n            {\n                _messageText.text = _signMessage;\n                _messageText.fontSize = 24;\n                _messageText.color = Color.white;\n                _messageText.alignment = TextAlignmentOptions.Center;\n            }\n            else\n            {\n                _legacyMessageText = textObj.AddComponent<Text>();\n                _legacyMessageText.text = _signMessage;\n                _legacyMessageText.fontSize = 24;\n                _legacyMessageText.color = Color.white;\n                _legacyMessageText.alignment = TextAnchor.MiddleCenter;\n                _legacyMessageText.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\n            }\n        }\n        \n        UpdateMessageText();\n    }\n    \n    private void Update()\n    {\n        CheckForPlayer();\n        HandleInteraction();\n        UpdateCanvasRotation();\n        UpdateCanvasAlpha();\n    }\n    \n    private void CheckForPlayer()\n    {\n        if (_mainCamera == null) return;\n        \n        _playerTransform = _mainCamera.transform;\n        float distanceToPlayer = Vector3.Distance(transform.position, _playerTransform.position);\n        \n        bool wasInRange = _playerInRange;\n        _playerInRange = distanceToPlayer <= _displayDistance;\n        \n        if (_playerInRange && !wasInRange)\n        {\n            OnPlayerEnterRange();\n        }\n        else if (!_playerInRange && wasInRange)\n        {\n            OnPlayerExitRange();\n        }\n    }\n    \n    private void HandleInteraction()\n    {\n        if (!_playerInRange) return;\n        \n        if (_requireInteraction)\n        {\n            if (_interactionPrompt != null)\n                _interactionPrompt.SetActive(true);\n                \n            if (Input.GetKeyDown(_interactionKey))\n            {\n                ToggleMessage();\n            }\n        }\n        else\n        {\n            if (!_messageVisible)\n                ShowMessage();\n        }\n    }\n    \n    private void UpdateCanvasRotation()\n    {\n        if (_messageCanvas == null || _playerTransform == null || !_lookAtPlayer) return;\n        \n        Vector3 directionToPlayer = _playerTransform.position - _messageCanvas.transform.position;\n        directionToPlayer.y = 0;\n        \n        if (directionToPlayer != Vector3.zero)\n        {\n            _messageCanvas.transform.rotation = Quaternion.LookRotation(directionToPlayer);\n        }\n    }\n    \n    private void UpdateCanvasAlpha()\n    {\n        if (_canvasGroup == null) return;\n        \n        float targetAlpha = _messageVisible ? 1f : 0f;\n        _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha, targetAlpha, _fadeSpeed * Time.deltaTime);\n        \n        if (_canvasGroup.alpha <= 0f && _messageCanvas.gameObject.activeSelf)\n        {\n            _messageCanvas.gameObject.SetActive(false);\n        }\n    }\n    \n    private void OnPlayerEnterRange()\n    {\n        if (!_requireInteraction)\n        {\n            ShowMessage();\n        }\n    }\n    \n    private void OnPlayerExitRange()\n    {\n        HideMessage();\n        \n        if (_interactionPrompt != null)\n            _interactionPrompt.SetActive(false);\n    }\n    \n    private void ShowMessage()\n    {\n        if (_messageCanvas != null)\n        {\n            _messageCanvas.gameObject.SetActive(true);\n            _messageVisible = true;\n        }\n    }\n    \n    private void HideMessage()\n    {\n        _messageVisible = false;\n    }\n    \n    private void ToggleMessage()\n    {\n        if (_messageVisible)\n            HideMessage();\n        else\n            ShowMessage();\n    }\n    \n    private void UpdateMessageText()\n    {\n        if (_messageText != null)\n            _messageText.text = _signMessage;\n        else if (_legacyMessageText != null)\n            _legacyMessageText.text = _signMessage;\n    }\n    \n    public void SetMessage(string newMessage)\n    {\n        _signMessage = newMessage;\n        UpdateMessageText();\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _displayDistance);\n        \n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireCube(transform.position + _canvasOffset, Vector3.one * 0.5f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ElectrifiedFloor\",\n  \"components\": [\n    \"Renderer\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pulseInterval\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"pulseDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxBrightness\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"minBrightness\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"pulse_electricity\",\n      \"trigger\": \"every pulse interval seconds\",\n      \"actions\": [\n        {\n          \"action\": \"play electrical crackling sound\"\n        },\n        {\n          \"action\": \"increase material emission brightness to maximum over pulse duration\"\n        },\n        {\n          \"action\": \"decrease material emission brightness to minimum after pulse duration\"\n        },\n        {\n          \"action\": \"create electrical particle effects during pulse\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_on_contact\",\n      \"trigger\": \"when player or enemy touches the floor during electrical pulse\",\n      \"actions\": [\n        {\n          \"action\": \"deal damage amount to touching entity\"\n        },\n        {\n          \"action\": \"play electrical shock sound\"\n        },\n        {\n          \"action\": \"create spark particle effects at contact point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"warning_flicker\",\n      \"trigger\": \"half a second before each electrical pulse\",\n      \"actions\": [\n        {\n          \"action\": \"briefly flicker material emission\"\n        },\n        {\n          \"action\": \"play subtle electrical humming sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class ElectrifiedFloor : MonoBehaviour\n{\n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _electricMaterial;\n    [SerializeField] private Color _baseColor = Color.blue;\n    [SerializeField] private Color _pulseColor = Color.white;\n    [SerializeField] private float _pulseSpeed = 2f;\n    [SerializeField] private AnimationCurve _pulseCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Electrical Effects\")]\n    [SerializeField] private float _damageAmount = 10f;\n    [SerializeField] private float _damageInterval = 0.5f;\n    [SerializeField] private float _knockbackForce = 500f;\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _electricHumSound;\n    [SerializeField] private AudioClip _zapSound;\n    [SerializeField] private float _humVolume = 0.3f;\n    [SerializeField] private float _zapVolume = 0.7f;\n    \n    [Header(\"Particle Effects\")]\n    [SerializeField] private ParticleSystem _sparkParticles;\n    [SerializeField] private Light _electricLight;\n    \n    private Renderer _renderer;\n    private Collider _floorCollider;\n    private float _pulseTimer;\n    private bool _isActive = true;\n    private System.Collections.Generic.HashSet<GameObject> _objectsOnFloor = new System.Collections.Generic.HashSet<GameObject>();\n    private System.Collections.Generic.Dictionary<GameObject, float> _lastDamageTime = new System.Collections.Generic.Dictionary<GameObject, float>();\n\n    private void Start()\n    {\n        InitializeComponents();\n        StartCoroutine(PulseEffect());\n        \n        if (_audioSource && _electricHumSound)\n        {\n            _audioSource.clip = _electricHumSound;\n            _audioSource.volume = _humVolume;\n            _audioSource.loop = true;\n            _audioSource.Play();\n        }\n    }\n\n    private void InitializeComponents()\n    {\n        _renderer = GetComponent<Renderer>();\n        _floorCollider = GetComponent<Collider>();\n        \n        if (!_floorCollider)\n        {\n            _floorCollider = gameObject.AddComponent<BoxCollider>();\n            _floorCollider.isTrigger = true;\n        }\n        \n        if (!_audioSource)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        if (_renderer && _electricMaterial)\n        {\n            _renderer.material = _electricMaterial;\n        }\n        \n        if (_sparkParticles)\n        {\n            _sparkParticles.Play();\n        }\n    }\n\n    private void Update()\n    {\n        if (_isActive)\n        {\n            DamageObjectsOnFloor();\n            UpdateLightIntensity();\n        }\n    }\n\n    private IEnumerator PulseEffect()\n    {\n        while (true)\n        {\n            _pulseTimer += Time.deltaTime * _pulseSpeed;\n            \n            if (_renderer && _renderer.material)\n            {\n                float pulseValue = _pulseCurve.Evaluate(Mathf.PingPong(_pulseTimer, 1f));\n                Color currentColor = Color.Lerp(_baseColor, _pulseColor, pulseValue);\n                \n                if (_renderer.material.HasProperty(\"_Color\"))\n                {\n                    _renderer.material.color = currentColor;\n                }\n                else if (_renderer.material.HasProperty(\"_BaseColor\"))\n                {\n                    _renderer.material.SetColor(\"_BaseColor\", currentColor);\n                }\n                \n                if (_renderer.material.HasProperty(\"_EmissionColor\"))\n                {\n                    _renderer.material.SetColor(\"_EmissionColor\", currentColor * 0.5f);\n                }\n            }\n            \n            yield return null;\n        }\n    }\n\n    private void UpdateLightIntensity()\n    {\n        if (_electricLight)\n        {\n            float pulseValue = _pulseCurve.Evaluate(Mathf.PingPong(_pulseTimer, 1f));\n            _electricLight.intensity = Mathf.Lerp(0.5f, 2f, pulseValue);\n            _electricLight.color = Color.Lerp(_baseColor, _pulseColor, pulseValue);\n        }\n    }\n\n    private void DamageObjectsOnFloor()\n    {\n        foreach (GameObject obj in _objectsOnFloor)\n        {\n            if (obj == null) continue;\n            \n            if (!_lastDamageTime.ContainsKey(obj))\n            {\n                _lastDamageTime[obj] = 0f;\n            }\n            \n            if (Time.time - _lastDamageTime[obj] >= _damageInterval)\n            {\n                ApplyElectricalDamage(obj);\n                _lastDamageTime[obj] = Time.time;\n            }\n        }\n    }\n\n    private void ApplyElectricalDamage(GameObject target)\n    {\n        // Apply damage if target has health component\n        var healthComponent = target.GetComponent<MonoBehaviour>();\n        if (healthComponent != null)\n        {\n            // Try to find common health method names\n            var healthType = healthComponent.GetType();\n            var takeDamageMethod = healthType.GetMethod(\"TakeDamage\");\n            var damageMethod = healthType.GetMethod(\"Damage\");\n            \n            if (takeDamageMethod != null)\n            {\n                takeDamageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n            else if (damageMethod != null)\n            {\n                damageMethod.Invoke(healthComponent, new object[] { _damageAmount });\n            }\n        }\n        \n        // Apply knockback\n        Rigidbody rb = target.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            Vector3 knockbackDirection = (target.transform.position - transform.position).normalized;\n            knockbackDirection.y = 0.5f; // Add upward force\n            rb.AddForce(knockbackDirection * _knockbackForce, ForceMode.Impulse);\n        }\n        \n        // Play zap sound\n        if (_audioSource && _zapSound)\n        {\n            _audioSource.PlayOneShot(_zapSound, _zapVolume);\n        }\n        \n        // Spawn spark effect at target position\n        if (_sparkParticles)\n        {\n            _sparkParticles.transform.position = target.transform.position;\n            _sparkParticles.Emit(10);\n        }\n        \n        // Screen shake effect for player\n        if (target.CompareTag(\"Player\"))\n        {\n            StartCoroutine(ScreenShake());\n        }\n    }\n\n    private IEnumerator ScreenShake()\n    {\n        Camera mainCamera = Camera.main;\n        if (mainCamera == null) yield break;\n        \n        Vector3 originalPosition = mainCamera.transform.position;\n        float shakeDuration = 0.2f;\n        float shakeIntensity = 0.1f;\n        \n        float elapsed = 0f;\n        while (elapsed < shakeDuration)\n        {\n            float x = Random.Range(-1f, 1f) * shakeIntensity;\n            float y = Random.Range(-1f, 1f) * shakeIntensity;\n            \n            mainCamera.transform.position = originalPosition + new Vector3(x, y, 0);\n            \n            elapsed += Time.deltaTime;\n            yield return null;\n        }\n        \n        mainCamera.transform.position = originalPosition;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (IsValidTarget(other.gameObject))\n        {\n            _objectsOnFloor.Add(other.gameObject);\n            \n            // Immediate damage on entry\n            if (_isActive)\n            {\n                ApplyElectricalDamage(other.gameObject);\n                _lastDamageTime[other.gameObject] = Time.time;\n            }\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        if (_objectsOnFloor.Contains(other.gameObject))\n        {\n            _objectsOnFloor.Remove(other.gameObject);\n            _lastDamageTime.Remove(other.gameObject);\n        }\n    }\n\n    private bool IsValidTarget(GameObject target)\n    {\n        return (_affectedLayers.value & (1 << target.layer)) != 0;\n    }\n\n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_sparkParticles)\n        {\n            if (active)\n                _sparkParticles.Play();\n            else\n                _sparkParticles.Stop();\n        }\n        \n        if (_electricLight)\n        {\n            _electricLight.enabled = active;\n        }\n        \n        if (_audioSource)\n        {\n            if (active && !_audioSource.isPlaying)\n                _audioSource.Play();\n            else if (!active && _audioSource.isPlaying)\n                _audioSource.Stop();\n        }\n    }\n\n    public void SetDamageAmount(float damage)\n    {\n        _damageAmount = damage;\n    }\n\n    public void SetPulseSpeed(float speed)\n    {\n        _pulseSpeed = speed;\n    }\n\n    private void OnDestroy()\n    {\n        StopAllCoroutines();\n        _objectsOnFloor.Clear();\n        _lastDamageTime.Clear();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Vampire\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"drainAmount\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"drainRange\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"drainCooldown\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"isDraining\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lastDrainTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"start moving toward player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_player\",\n      \"trigger\": \"when player is within detection range and vampire is not draining\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player at move speed\"\n        },\n        {\n          \"action\": \"face direction of player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_drain\",\n      \"trigger\": \"when player is within drain range and drain cooldown has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"set is draining to true\"\n        },\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"play drain sound effect\"\n        },\n        {\n          \"action\": \"start drain visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drain_health\",\n      \"trigger\": \"when is draining is true\",\n      \"actions\": [\n        {\n          \"action\": \"reduce player health by drain amount\"\n        },\n        {\n          \"action\": \"increase vampire current health by drain amount\"\n        },\n        {\n          \"action\": \"clamp vampire health to maximum health\"\n        },\n        {\n          \"action\": \"record current time as last drain time\"\n        },\n        {\n          \"action\": \"set is draining to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_chase\",\n      \"trigger\": \"when player exits detection range\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"set is draining to false\"\n        },\n        {\n          \"action\": \"stop drain visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when vampire receives damage\",\n      \"actions\": [\n        {\n          \"action\": \"reduce current health by damage amount\"\n        },\n        {\n          \"action\": \"play hurt sound effect\"\n        },\n        {\n          \"action\": \"flash red briefly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"die\",\n      \"trigger\": \"when current health reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"play death sound effect\"\n        },\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"destroy vampire after animation completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\n\npublic class Vampire : MonoBehaviour\n{\n    [Header(\"Vampire Settings\")]\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    [SerializeField] private float _drainAmount = 10f;\n    [SerializeField] private float _drainInterval = 1f;\n    [SerializeField] private float _drainRange = 3f;\n    [SerializeField] private float _healPercentage = 0.5f;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _moveSpeed = 2f;\n    [SerializeField] private float _chaseSpeed = 4f;\n    [SerializeField] private float _detectionRange = 5f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _drainEffect;\n    [SerializeField] private LineRenderer _drainBeam;\n    [SerializeField] private Color _drainColor = Color.red;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _drainSound;\n    [SerializeField] private AudioClip _deathSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    public UnityEvent<GameObject> OnStartDraining;\n    public UnityEvent<GameObject> OnStopDraining;\n    \n    private Transform _target;\n    private bool _isDraining;\n    private Coroutine _drainCoroutine;\n    private Rigidbody _rigidbody;\n    private Animator _animator;\n    private bool _isDead;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        _rigidbody = GetComponent<Rigidbody>();\n        _animator = GetComponent<Animator>();\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_drainBeam != null)\n        {\n            _drainBeam.enabled = false;\n            _drainBeam.startColor = _drainColor;\n            _drainBeam.endColor = _drainColor;\n            _drainBeam.startWidth = 0.1f;\n            _drainBeam.endWidth = 0.05f;\n        }\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Update()\n    {\n        if (_isDead) return;\n        \n        FindTarget();\n        HandleMovement();\n        HandleDraining();\n    }\n    \n    private void FindTarget()\n    {\n        GameObject[] players = GameObject.FindGameObjectsWithTag(\"Player\");\n        Transform closestTarget = null;\n        float closestDistance = _detectionRange;\n        \n        foreach (GameObject player in players)\n        {\n            float distance = Vector3.Distance(transform.position, player.transform.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestTarget = player.transform;\n            }\n        }\n        \n        _target = closestTarget;\n    }\n    \n    private void HandleMovement()\n    {\n        if (_target == null || _isDraining) return;\n        \n        Vector3 direction = (_target.position - transform.position).normalized;\n        float distance = Vector3.Distance(transform.position, _target.position);\n        \n        if (distance > _drainRange)\n        {\n            Vector3 movement = direction * _chaseSpeed * Time.deltaTime;\n            transform.position += movement;\n            transform.LookAt(_target);\n            \n            if (_animator != null)\n                _animator.SetBool(\"IsMoving\", true);\n        }\n        else\n        {\n            if (_animator != null)\n                _animator.SetBool(\"IsMoving\", false);\n        }\n    }\n    \n    private void HandleDraining()\n    {\n        if (_target == null) return;\n        \n        float distance = Vector3.Distance(transform.position, _target.position);\n        \n        if (distance <= _drainRange && !_isDraining)\n        {\n            StartDraining();\n        }\n        else if (distance > _drainRange && _isDraining)\n        {\n            StopDraining();\n        }\n    }\n    \n    private void StartDraining()\n    {\n        if (_isDraining || _target == null) return;\n        \n        _isDraining = true;\n        _drainCoroutine = StartCoroutine(DrainHealthCoroutine());\n        \n        if (_drainEffect != null)\n            _drainEffect.Play();\n            \n        if (_drainBeam != null)\n        {\n            _drainBeam.enabled = true;\n            _drainBeam.SetPosition(0, transform.position + Vector3.up);\n            _drainBeam.SetPosition(1, _target.position + Vector3.up);\n        }\n        \n        if (_animator != null)\n            _animator.SetBool(\"IsDraining\", true);\n            \n        OnStartDraining?.Invoke(_target.gameObject);\n    }\n    \n    private void StopDraining()\n    {\n        if (!_isDraining) return;\n        \n        _isDraining = false;\n        \n        if (_drainCoroutine != null)\n        {\n            StopCoroutine(_drainCoroutine);\n            _drainCoroutine = null;\n        }\n        \n        if (_drainEffect != null)\n            _drainEffect.Stop();\n            \n        if (_drainBeam != null)\n            _drainBeam.enabled = false;\n            \n        if (_animator != null)\n            _animator.SetBool(\"IsDraining\", false);\n            \n        OnStopDraining?.Invoke(_target?.gameObject);\n    }\n    \n    private IEnumerator DrainHealthCoroutine()\n    {\n        while (_isDraining && _target != null)\n        {\n            DrainTargetHealth();\n            \n            if (_drainBeam != null)\n            {\n                _drainBeam.SetPosition(0, transform.position + Vector3.up);\n                _drainBeam.SetPosition(1, _target.position + Vector3.up);\n            }\n            \n            yield return new WaitForSeconds(_drainInterval);\n        }\n    }\n    \n    private void DrainTargetHealth()\n    {\n        if (_target == null) return;\n        \n        // Try to find a health component or use a simple health system\n        PlayerHealthComponent targetHealth = _target.GetComponent<PlayerHealthComponent>();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(_drainAmount);\n        }\n        else\n        {\n            // Send damage message to target\n            _target.SendMessage(\"TakeDamage\", _drainAmount, SendMessageOptions.DontRequireReceiver);\n        }\n        \n        // Heal vampire\n        float healAmount = _drainAmount * _healPercentage;\n        Heal(healAmount);\n        \n        // Play drain sound\n        if (_audioSource != null && _drainSound != null)\n            _audioSource.PlayOneShot(_drainSound);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        if (_isDead) return;\n        \n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            Die();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        if (_isDead) return;\n        \n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    private void Die()\n    {\n        if (_isDead) return;\n        \n        _isDead = true;\n        StopDraining();\n        \n        if (_audioSource != null && _deathSound != null)\n            _audioSource.PlayOneShot(_deathSound);\n            \n        if (_animator != null)\n            _animator.SetTrigger(\"Die\");\n            \n        OnDeath?.Invoke();\n        \n        // Disable components\n        if (_rigidbody != null)\n            _rigidbody.isKinematic = true;\n            \n        GetComponent<Collider>().enabled = false;\n        \n        // Destroy after delay\n        Destroy(gameObject, 3f);\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw detection range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _detectionRange);\n        \n        // Draw drain range\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, _drainRange);\n    }\n}\n\n[System.Serializable]\npublic class PlayerHealthComponent : MonoBehaviour\n{\n    [SerializeField] private float _maxHealth = 100f;\n    [SerializeField] private float _currentHealth;\n    \n    public UnityEvent<float> OnHealthChanged;\n    public UnityEvent OnDeath;\n    \n    private void Start()\n    {\n        _currentHealth = _maxHealth;\n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public void TakeDamage(float damage)\n    {\n        _currentHealth -= damage;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n        \n        if (_currentHealth <= 0f)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n    \n    public void Heal(float amount)\n    {\n        _currentHealth += amount;\n        _currentHealth = Mathf.Clamp(_currentHealth, 0f, _maxHealth);\n        \n        OnHealthChanged?.Invoke(_currentHealth);\n    }\n    \n    public float GetCurrentHealth()\n    {\n        return _currentHealth;\n    }\n    \n    public float GetMaxHealth()\n    {\n        return _maxHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ArmorPiece\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"defenseBonus\",\n      \"type\": \"int\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"armorType\",\n      \"type\": \"string\",\n      \"default\": \"Light\"\n    },\n    {\n      \"name\": \"durability\",\n      \"type\": \"int\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isEquipped\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"equip_armor\",\n      \"trigger\": \"when player interacts with this armor piece\",\n      \"actions\": [\n        {\n          \"action\": \"add defense bonus to player stats\"\n        },\n        {\n          \"action\": \"mark armor as equipped\"\n        },\n        {\n          \"action\": \"attach armor to player character model\"\n        },\n        {\n          \"action\": \"play equip sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"unequip_armor\",\n      \"trigger\": \"when player chooses to remove this armor\",\n      \"actions\": [\n        {\n          \"action\": \"remove defense bonus from player stats\"\n        },\n        {\n          \"action\": \"mark armor as not equipped\"\n        },\n        {\n          \"action\": \"detach armor from player character model\"\n        },\n        {\n          \"action\": \"return armor to inventory\"\n        }\n      ]\n    },\n    {\n      \"name\": \"durability_loss\",\n      \"trigger\": \"when player takes damage while wearing this armor\",\n      \"actions\": [\n        {\n          \"action\": \"reduce armor durability by small amount\"\n        },\n        {\n          \"action\": \"check if durability reaches zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"armor_breaks\",\n      \"trigger\": \"when armor durability reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"remove all defense bonuses\"\n        },\n        {\n          \"action\": \"display broken armor visual effect\"\n        },\n        {\n          \"action\": \"mark armor as broken and unusable\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class ArmorPiece : MonoBehaviour\n{\n    [Header(\"Armor Properties\")]\n    [SerializeField] private string _armorName = \"Basic Armor\";\n    [SerializeField] private int _defenseBonus = 10;\n    [SerializeField] private ArmorType _armorType = ArmorType.Chest;\n    [SerializeField] private bool _isEquipped = false;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private GameObject _visualModel;\n    [SerializeField] private Material _equippedMaterial;\n    [SerializeField] private Material _unequippedMaterial;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _equipSound;\n    [SerializeField] private AudioClip _unequipSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<int> OnDefenseChanged;\n    public UnityEvent<string> OnArmorEquipped;\n    public UnityEvent<string> OnArmorUnequipped;\n    \n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Collider _collider;\n    private GameObject _currentWearer;\n    \n    public enum ArmorType\n    {\n        Helmet,\n        Chest,\n        Legs,\n        Boots,\n        Gloves,\n        Shield\n    }\n    \n    public int DefenseBonus => _defenseBonus;\n    public ArmorType Type => _armorType;\n    public bool IsEquipped => _isEquipped;\n    public string ArmorName => _armorName;\n    public GameObject CurrentWearer => _currentWearer;\n    \n    private void Awake()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        _collider = GetComponent<Collider>();\n        \n        if (_collider == null)\n        {\n            _collider = gameObject.AddComponent<BoxCollider>();\n            _collider.isTrigger = true;\n        }\n    }\n    \n    private void Start()\n    {\n        UpdateVisualState();\n        \n        if (!_isEquipped && _collider != null)\n            _collider.enabled = true;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isEquipped && other.CompareTag(\"Player\"))\n        {\n            TryEquipArmor(other.gameObject);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (_isEquipped && other.CompareTag(\"Player\") && other.gameObject == _currentWearer)\n        {\n            // Optional: Auto-unequip when player moves away\n            // UnequipArmor();\n        }\n    }\n    \n    public bool TryEquipArmor(GameObject wearer)\n    {\n        if (_isEquipped || wearer == null)\n            return false;\n            \n        // Check if wearer already has this armor type equipped\n        ArmorPiece[] existingArmor = wearer.GetComponentsInChildren<ArmorPiece>();\n        foreach (ArmorPiece armor in existingArmor)\n        {\n            if (armor != this && armor.IsEquipped && armor.Type == _armorType)\n            {\n                armor.UnequipArmor();\n                break;\n            }\n        }\n        \n        EquipArmor(wearer);\n        return true;\n    }\n    \n    public void EquipArmor(GameObject wearer)\n    {\n        if (_isEquipped || wearer == null)\n            return;\n            \n        _isEquipped = true;\n        _currentWearer = wearer;\n        \n        // Attach to wearer\n        transform.SetParent(wearer.transform);\n        transform.localPosition = GetArmorPosition();\n        transform.localRotation = Quaternion.identity;\n        \n        // Disable collider when equipped\n        if (_collider != null)\n            _collider.enabled = false;\n            \n        // Apply defense bonus\n        ApplyDefenseBonus(wearer, _defenseBonus);\n        \n        // Update visuals and audio\n        UpdateVisualState();\n        PlayEquipSound();\n        \n        // Trigger events\n        OnDefenseChanged?.Invoke(_defenseBonus);\n        OnArmorEquipped?.Invoke(_armorName);\n        \n        Debug.Log($\"{_armorName} equipped! Defense bonus: +{_defenseBonus}\");\n    }\n    \n    public void UnequipArmor()\n    {\n        if (!_isEquipped)\n            return;\n            \n        GameObject previousWearer = _currentWearer;\n        \n        // Remove defense bonus\n        if (previousWearer != null)\n            ApplyDefenseBonus(previousWearer, -_defenseBonus);\n            \n        _isEquipped = false;\n        _currentWearer = null;\n        \n        // Detach from wearer\n        transform.SetParent(null);\n        \n        // Re-enable collider\n        if (_collider != null)\n            _collider.enabled = true;\n            \n        // Update visuals and audio\n        UpdateVisualState();\n        PlayUnequipSound();\n        \n        // Trigger events\n        OnDefenseChanged?.Invoke(-_defenseBonus);\n        OnArmorUnequipped?.Invoke(_armorName);\n        \n        Debug.Log($\"{_armorName} unequipped! Defense bonus removed: -{_defenseBonus}\");\n    }\n    \n    private void ApplyDefenseBonus(GameObject target, int bonus)\n    {\n        // Store defense bonus in a component on the target\n        DefenseTracker tracker = target.GetComponent<DefenseTracker>();\n        if (tracker == null)\n            tracker = target.AddComponent<DefenseTracker>();\n            \n        tracker.ModifyDefense(bonus);\n    }\n    \n    private Vector3 GetArmorPosition()\n    {\n        switch (_armorType)\n        {\n            case ArmorType.Helmet:\n                return new Vector3(0, 1.8f, 0);\n            case ArmorType.Chest:\n                return new Vector3(0, 1.2f, 0);\n            case ArmorType.Legs:\n                return new Vector3(0, 0.6f, 0);\n            case ArmorType.Boots:\n                return new Vector3(0, 0.1f, 0);\n            case ArmorType.Gloves:\n                return new Vector3(0.3f, 1.0f, 0);\n            case ArmorType.Shield:\n                return new Vector3(-0.5f, 1.0f, 0);\n            default:\n                return Vector3.zero;\n        }\n    }\n    \n    private void UpdateVisualState()\n    {\n        if (_renderer != null)\n        {\n            if (_isEquipped && _equippedMaterial != null)\n                _renderer.material = _equippedMaterial;\n            else if (!_isEquipped && _unequippedMaterial != null)\n                _renderer.material = _unequippedMaterial;\n        }\n        \n        if (_visualModel != null)\n            _visualModel.SetActive(_isEquipped);\n    }\n    \n    private void PlayEquipSound()\n    {\n        if (_audioSource != null && _equipSound != null)\n        {\n            _audioSource.clip = _equipSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void PlayUnequipSound()\n    {\n        if (_audioSource != null && _unequipSound != null)\n        {\n            _audioSource.clip = _unequipSound;\n            _audioSource.Play();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        _defenseBonus = Mathf.Max(0, _defenseBonus);\n    }\n    \n    [System.Serializable]\n    public class DefenseTracker : MonoBehaviour\n    {\n        [SerializeField] private int _totalDefense = 0;\n        \n        public int TotalDefense => _totalDefense;\n        \n        public void ModifyDefense(int amount)\n        {\n            _totalDefense += amount;\n            _totalDefense = Mathf.Max(0, _totalDefense);\n        }\n        \n        public void SetDefense(int value)\n        {\n            _totalDefense = Mathf.Max(0, value);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WaterTrident\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"waterDamage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 800\n    },\n    {\n      \"name\": \"returnSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"waterBurstRadius\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isThrown\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"owner\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"throw_trident\",\n      \"trigger\": \"when player performs throw input while holding trident\",\n      \"actions\": [\n        {\n          \"action\": \"launch trident forward with throw force\"\n        },\n        {\n          \"action\": \"set is thrown to true\"\n        },\n        {\n          \"action\": \"play water splash sound effect\"\n        },\n        {\n          \"action\": \"create water trail particles behind trident\"\n        }\n      ]\n    },\n    {\n      \"name\": \"water_impact\",\n      \"trigger\": \"when trident collides with enemy or surface\",\n      \"actions\": [\n        {\n          \"action\": \"deal water damage to target\"\n        },\n        {\n          \"action\": \"create water burst explosion at impact point\"\n        },\n        {\n          \"action\": \"apply knockback effect in burst radius\"\n        },\n        {\n          \"action\": \"play water impact sound\"\n        },\n        {\n          \"action\": \"stop forward movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_owner\",\n      \"trigger\": \"when trident has been thrown and impact occurred\",\n      \"actions\": [\n        {\n          \"action\": \"fly back toward owner at return speed\"\n        },\n        {\n          \"action\": \"create water stream particles during return\"\n        },\n        {\n          \"action\": \"ignore collision with enemies during return\"\n        }\n      ]\n    },\n    {\n      \"name\": \"catch_trident\",\n      \"trigger\": \"when returning trident reaches close proximity to owner\",\n      \"actions\": [\n        {\n          \"action\": \"attach trident back to owner hand\"\n        },\n        {\n          \"action\": \"set is thrown to false\"\n        },\n        {\n          \"action\": \"stop all particle effects\"\n        },\n        {\n          \"action\": \"play catch sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"water_enhancement\",\n      \"trigger\": \"when trident is near water source\",\n      \"actions\": [\n        {\n          \"action\": \"increase water damage by fifty percent\"\n        },\n        {\n          \"action\": \"enhance water particle effects\"\n        },\n        {\n          \"action\": \"create ripple effects on nearby water surface\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class WaterTrident : MonoBehaviour\n{\n    [Header(\"Trident Settings\")]\n    [SerializeField] private float _damage = 50f;\n    [SerializeField] private float _range = 10f;\n    [SerializeField] private float _attackCooldown = 1.5f;\n    [SerializeField] private LayerMask _targetLayers = -1;\n    \n    [Header(\"Water Affinity\")]\n    [SerializeField] private float _waterDamageMultiplier = 2f;\n    [SerializeField] private float _underwaterSpeedBonus = 1.5f;\n    [SerializeField] private float _waterHealingRate = 5f;\n    [SerializeField] private ParticleSystem _waterEffectPrefab;\n    [SerializeField] private AudioClip _waterAttackSound;\n    [SerializeField] private AudioClip _waterSplashSound;\n    \n    [Header(\"Special Abilities\")]\n    [SerializeField] private float _waterBoltSpeed = 20f;\n    [SerializeField] private GameObject _waterBoltPrefab;\n    [SerializeField] private float _tidalWaveForce = 1000f;\n    [SerializeField] private float _tidalWaveRadius = 15f;\n    [SerializeField] private float _specialAbilityCooldown = 10f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private Material _waterMaterial;\n    [SerializeField] private Light _tridentGlow;\n    [SerializeField] private Transform _projectileSpawnPoint;\n    \n    [Header(\"Events\")]\n    public UnityEvent<float> OnDamageDealt;\n    public UnityEvent OnWaterAbilityUsed;\n    public UnityEvent OnTridentEquipped;\n    \n    private bool _isEquipped = false;\n    private float _lastAttackTime;\n    private float _lastSpecialAbilityTime;\n    private bool _isInWater = false;\n    private AudioSource _audioSource;\n    private Renderer _renderer;\n    private Transform _wielder;\n    private Rigidbody _wielderRigidbody;\n    private ParticleSystem _currentWaterEffect;\n    \n    private void Start()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            \n        _renderer = GetComponent<Renderer>();\n        \n        if (_tridentGlow != null)\n            _tridentGlow.enabled = false;\n            \n        SetupWaterDetection();\n    }\n    \n    private void Update()\n    {\n        if (_isEquipped && _wielder != null)\n        {\n            HandleInput();\n            UpdateWaterEffects();\n            HandleWaterHealing();\n        }\n        \n        UpdateVisualEffects();\n    }\n    \n    private void SetupWaterDetection()\n    {\n        SphereCollider waterDetector = gameObject.AddComponent<SphereCollider>();\n        waterDetector.isTrigger = true;\n        waterDetector.radius = 2f;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Water\") || other.name.ToLower().Contains(\"water\"))\n        {\n            _isInWater = true;\n            OnWaterAbilityUsed?.Invoke();\n            PlayWaterEffect();\n        }\n        \n        if (other.CompareTag(\"Player\") && !_isEquipped)\n        {\n            EquipTrident(other.transform);\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (other.CompareTag(\"Water\") || other.name.ToLower().Contains(\"water\"))\n        {\n            _isInWater = false;\n            StopWaterEffect();\n        }\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0) && CanAttack())\n        {\n            PerformAttack();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.Q) && CanUseSpecialAbility())\n        {\n            UseWaterBolt();\n        }\n        \n        if (Input.GetKeyDown(KeyCode.E) && CanUseSpecialAbility())\n        {\n            UseTidalWave();\n        }\n    }\n    \n    private void EquipTrident(Transform player)\n    {\n        _wielder = player;\n        _wielderRigidbody = player.GetComponent<Rigidbody>();\n        _isEquipped = true;\n        \n        transform.SetParent(player);\n        transform.localPosition = new Vector3(0.5f, 0f, 1f);\n        transform.localRotation = Quaternion.identity;\n        \n        if (_tridentGlow != null)\n            _tridentGlow.enabled = true;\n            \n        OnTridentEquipped?.Invoke();\n    }\n    \n    private bool CanAttack()\n    {\n        return Time.time >= _lastAttackTime + _attackCooldown;\n    }\n    \n    private bool CanUseSpecialAbility()\n    {\n        return Time.time >= _lastSpecialAbilityTime + _specialAbilityCooldown;\n    }\n    \n    private void PerformAttack()\n    {\n        _lastAttackTime = Time.time;\n        \n        RaycastHit hit;\n        Vector3 attackDirection = _wielder.forward;\n        \n        if (Physics.Raycast(_wielder.position, attackDirection, out hit, _range, _targetLayers))\n        {\n            float finalDamage = _damage;\n            \n            if (_isInWater)\n                finalDamage *= _waterDamageMultiplier;\n                \n            DealDamage(hit.collider.gameObject, finalDamage);\n            CreateWaterImpactEffect(hit.point);\n        }\n        \n        PlayAttackSound();\n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void UseWaterBolt()\n    {\n        _lastSpecialAbilityTime = Time.time;\n        \n        if (_waterBoltPrefab != null && _projectileSpawnPoint != null)\n        {\n            GameObject waterBolt = Instantiate(_waterBoltPrefab, _projectileSpawnPoint.position, _projectileSpawnPoint.rotation);\n            \n            WaterBolt boltScript = waterBolt.GetComponent<WaterBolt>();\n            if (boltScript == null)\n                boltScript = waterBolt.AddComponent<WaterBolt>();\n                \n            boltScript.Initialize(_damage * 1.5f, _waterBoltSpeed, _wielder);\n        }\n        \n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void UseTidalWave()\n    {\n        _lastSpecialAbilityTime = Time.time;\n        \n        Collider[] affectedObjects = Physics.OverlapSphere(_wielder.position, _tidalWaveRadius);\n        \n        foreach (Collider obj in affectedObjects)\n        {\n            if (obj.gameObject != _wielder.gameObject)\n            {\n                Rigidbody rb = obj.GetComponent<Rigidbody>();\n                if (rb != null)\n                {\n                    Vector3 forceDirection = (obj.transform.position - _wielder.position).normalized;\n                    rb.AddForce(forceDirection * _tidalWaveForce, ForceMode.Impulse);\n                }\n                \n                if (!obj.CompareTag(\"Player\"))\n                {\n                    DealDamage(obj.gameObject, _damage * 0.8f);\n                }\n            }\n        }\n        \n        CreateTidalWaveEffect();\n        OnWaterAbilityUsed?.Invoke();\n    }\n    \n    private void DealDamage(GameObject target, float damage)\n    {\n        if (target.CompareTag(\"Enemy\") || target.name.ToLower().Contains(\"enemy\"))\n        {\n            Destroy(target);\n        }\n        \n        OnDamageDealt?.Invoke(damage);\n    }\n    \n    private void HandleWaterHealing()\n    {\n        if (_isInWater && _wielder != null)\n        {\n            // Simulate healing by triggering event\n            OnDamageDealt?.Invoke(-_waterHealingRate * Time.deltaTime);\n        }\n    }\n    \n    private void UpdateWaterEffects()\n    {\n        if (_isInWater && _wielderRigidbody != null)\n        {\n            // Apply underwater speed bonus\n            Vector3 velocity = _wielderRigidbody.velocity;\n            velocity *= _underwaterSpeedBonus;\n            _wielderRigidbody.velocity = velocity;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_renderer != null && _waterMaterial != null && _isInWater)\n        {\n            _renderer.material = _waterMaterial;\n        }\n        \n        if (_tridentGlow != null)\n        {\n            _tridentGlow.intensity = _isInWater ? 2f : 1f;\n            _tridentGlow.color = _isInWater ? Color.cyan : Color.blue;\n        }\n    }\n    \n    private void PlayWaterEffect()\n    {\n        if (_waterEffectPrefab != null)\n        {\n            _currentWaterEffect = Instantiate(_waterEffectPrefab, transform.position, Quaternion.identity);\n            _currentWaterEffect.transform.SetParent(transform);\n        }\n        \n        if (_audioSource != null && _waterSplashSound != null)\n        {\n            _audioSource.PlayOneShot(_waterSplashSound);\n        }\n    }\n    \n    private void StopWaterEffect()\n    {\n        if (_currentWaterEffect != null)\n        {\n            _currentWaterEffect.Stop();\n            Destroy(_currentWaterEffect.gameObject, 2f);\n        }\n    }\n    \n    private void CreateWaterImpactEffect(Vector3 position)\n    {\n        if (_waterEffectPrefab != null)\n        {\n            ParticleSystem impact = Instantiate(_waterEffectPrefab, position, Quaternion.identity);\n            Destroy(impact.gameObject, 3f);\n        }\n    }\n    \n    private void CreateTidalWaveEffect()\n    {\n        if (_waterEffectPrefab != null)\n        {\n            ParticleSystem tidalWave = Instantiate(_waterEffectPrefab, _wielder.position, Quaternion.identity);\n            var main = tidalWave.main;\n            main.startSize = _tidalWaveRadius;\n            Destroy(tidalWave.gameObject, 5f);\n        }\n    }\n    \n    private void PlayAttackSound()\n    {\n        if (_audioSource != null && _waterAttackSound != null)\n        {\n            _audioSource.PlayOneShot(_waterAttackSound);\n        }\n    }\n}\n\npublic class WaterBolt : MonoBehaviour\n{\n    private float _damage;\n    private float _speed;\n    private Transform _owner;\n    private Rigidbody _rigidbody;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n            \n        _rigidbody.useGravity = false;\n        \n        Destroy(gameObject, 5f);\n    }\n    \n    public void Initialize(float damage, float speed, Transform owner)\n    {\n        _damage = damage;\n        _speed = speed;\n        _owner = owner;\n        \n        if (_rigidbody != null)\n            _rigidbody.velocity = transform.forward * _speed;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.transform != _owner && !other.CompareTag(\"Player\"))\n        {\n            if (other.CompareTag(\"Enemy\") || other.name.ToLower().Contains(\"enemy\"))\n            {\n                Destroy(other.gameObject);\n            }\n            \n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GravityGun\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"pullForce\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"maxRange\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"holdDistance\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"targetObject\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isHolding\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"grab_object\",\n      \"trigger\": \"when fire button is pressed and no object is being held\",\n      \"actions\": [\n        {\n          \"action\": \"cast ray forward from gun position\"\n        },\n        {\n          \"action\": \"find nearest grabbable object within max range\"\n        },\n        {\n          \"action\": \"set that object as target object\"\n        },\n        {\n          \"action\": \"mark as holding object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pull_object\",\n      \"trigger\": \"when holding an object and object is far from hold position\",\n      \"actions\": [\n        {\n          \"action\": \"apply pull force toward hold position in front of gun\"\n        },\n        {\n          \"action\": \"reduce object gravity while being pulled\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_hold\",\n      \"trigger\": \"when holding an object and object is at hold position\",\n      \"actions\": [\n        {\n          \"action\": \"keep object floating at hold distance from gun\"\n        },\n        {\n          \"action\": \"rotate object to face same direction as gun\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_object\",\n      \"trigger\": \"when fire button is released while holding object\",\n      \"actions\": [\n        {\n          \"action\": \"restore normal gravity to held object\"\n        },\n        {\n          \"action\": \"clear target object reference\"\n        },\n        {\n          \"action\": \"mark as not holding object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"launch_object\",\n      \"trigger\": \"when secondary fire button is pressed while holding object\",\n      \"actions\": [\n        {\n          \"action\": \"apply strong forward force to held object\"\n        },\n        {\n          \"action\": \"restore normal gravity to object\"\n        },\n        {\n          \"action\": \"clear target object reference\"\n        },\n        {\n          \"action\": \"mark as not holding object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class GravityGun : MonoBehaviour\n{\n    [Header(\"Gravity Gun Settings\")]\n    [SerializeField] private float _pullForce = 10f;\n    [SerializeField] private float _maxRange = 15f;\n    [SerializeField] private float _holdDistance = 3f;\n    [SerializeField] private LayerMask _pullableLayers = -1;\n    [SerializeField] private float _pullSpeed = 5f;\n    [SerializeField] private float _rotationDamping = 5f;\n    \n    [Header(\"Input\")]\n    [SerializeField] private KeyCode _pullKey = KeyCode.Mouse0;\n    [SerializeField] private KeyCode _releaseKey = KeyCode.Mouse1;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private LineRenderer _beamRenderer;\n    [SerializeField] private Transform _holdPoint;\n    [SerializeField] private ParticleSystem _pullEffect;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _pullSound;\n    [SerializeField] private AudioClip _releaseSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnObjectGrabbed;\n    public UnityEvent<GameObject> OnObjectReleased;\n    \n    private Camera _playerCamera;\n    private Rigidbody _heldObject;\n    private Transform _heldTransform;\n    private bool _isPulling;\n    private Vector3 _originalGravity;\n    private float _originalDrag;\n    private float _originalAngularDrag;\n    private bool _wasKinematic;\n    \n    private void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_holdPoint == null)\n        {\n            GameObject holdPointObj = new GameObject(\"HoldPoint\");\n            holdPointObj.transform.SetParent(transform);\n            holdPointObj.transform.localPosition = Vector3.forward * _holdDistance;\n            _holdPoint = holdPointObj.transform;\n        }\n        \n        if (_beamRenderer != null)\n        {\n            _beamRenderer.enabled = false;\n            _beamRenderer.positionCount = 2;\n        }\n        \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        UpdateHeldObject();\n        UpdateVisualEffects();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(_pullKey))\n        {\n            if (_heldObject == null)\n                TryGrabObject();\n        }\n        \n        if (Input.GetKeyUp(_pullKey) || Input.GetKeyDown(_releaseKey))\n        {\n            if (_heldObject != null)\n                ReleaseObject();\n        }\n    }\n    \n    private void TryGrabObject()\n    {\n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        \n        if (Physics.Raycast(ray, out RaycastHit hit, _maxRange, _pullableLayers))\n        {\n            Rigidbody targetRb = hit.collider.GetComponent<Rigidbody>();\n            \n            if (targetRb != null && !targetRb.isKinematic)\n            {\n                GrabObject(targetRb);\n            }\n        }\n    }\n    \n    private void GrabObject(Rigidbody target)\n    {\n        _heldObject = target;\n        _heldTransform = target.transform;\n        _isPulling = true;\n        \n        // Store original physics properties\n        _originalDrag = _heldObject.drag;\n        _originalAngularDrag = _heldObject.angularDrag;\n        _wasKinematic = _heldObject.isKinematic;\n        \n        // Modify physics for better control\n        _heldObject.drag = 10f;\n        _heldObject.angularDrag = 10f;\n        _heldObject.useGravity = false;\n        \n        // Play effects\n        PlaySound(_pullSound);\n        if (_pullEffect != null)\n            _pullEffect.Play();\n            \n        OnObjectGrabbed?.Invoke(_heldObject.gameObject);\n    }\n    \n    private void ReleaseObject()\n    {\n        if (_heldObject != null)\n        {\n            // Restore original physics properties\n            _heldObject.drag = _originalDrag;\n            _heldObject.angularDrag = _originalAngularDrag;\n            _heldObject.useGravity = true;\n            _heldObject.isKinematic = _wasKinematic;\n            \n            GameObject releasedObject = _heldObject.gameObject;\n            \n            _heldObject = null;\n            _heldTransform = null;\n            _isPulling = false;\n            \n            // Play effects\n            PlaySound(_releaseSound);\n            if (_pullEffect != null)\n                _pullEffect.Stop();\n                \n            OnObjectReleased?.Invoke(releasedObject);\n        }\n    }\n    \n    private void UpdateHeldObject()\n    {\n        if (_heldObject == null || _holdPoint == null) return;\n        \n        Vector3 targetPosition = _holdPoint.position;\n        Vector3 direction = targetPosition - _heldTransform.position;\n        float distance = direction.magnitude;\n        \n        // Apply force to move object to hold position\n        if (distance > 0.1f)\n        {\n            Vector3 force = direction.normalized * _pullForce * distance;\n            _heldObject.AddForce(force, ForceMode.Force);\n        }\n        \n        // Dampen rotation for stability\n        if (_heldObject.angularVelocity.magnitude > 0.1f)\n        {\n            _heldObject.angularVelocity = Vector3.Lerp(_heldObject.angularVelocity, Vector3.zero, Time.deltaTime * _rotationDamping);\n        }\n        \n        // Limit velocity to prevent objects from flying away\n        if (_heldObject.velocity.magnitude > 20f)\n        {\n            _heldObject.velocity = _heldObject.velocity.normalized * 20f;\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        if (_beamRenderer != null)\n        {\n            if (_isPulling && _heldObject != null)\n            {\n                _beamRenderer.enabled = true;\n                _beamRenderer.SetPosition(0, transform.position);\n                _beamRenderer.SetPosition(1, _heldTransform.position);\n            }\n            else\n            {\n                _beamRenderer.enabled = false;\n            }\n        }\n    }\n    \n    private void PlaySound(AudioClip clip)\n    {\n        if (_audioSource != null && clip != null)\n        {\n            _audioSource.PlayOneShot(clip);\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw max range\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _maxRange);\n        \n        // Draw hold point\n        if (_holdPoint != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawWireSphere(_holdPoint.position, 0.2f);\n        }\n        \n        // Draw line to held object\n        if (_heldObject != null)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawLine(transform.position, _heldObject.transform.position);\n        }\n    }\n    \n    public void SetPullForce(float force)\n    {\n        _pullForce = Mathf.Max(0f, force);\n    }\n    \n    public void SetMaxRange(float range)\n    {\n        _maxRange = Mathf.Max(0f, range);\n    }\n    \n    public bool IsHoldingObject()\n    {\n        return _heldObject != null;\n    }\n    \n    public GameObject GetHeldObject()\n    {\n        return _heldObject != null ? _heldObject.gameObject : null;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"OneTimeButton\",\n  \"components\": [\n    \"Button\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hasBeenPressed\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_event_once\",\n      \"trigger\": \"when button is clicked and has not been pressed before\",\n      \"actions\": [\n        {\n          \"action\": \"invoke button click event\"\n        },\n        {\n          \"action\": \"mark button as having been pressed\"\n        },\n        {\n          \"action\": \"disable button interaction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.UI;\n\npublic class OneTimeButton : MonoBehaviour\n{\n    [Header(\"Button Settings\")]\n    [SerializeField] private Button _button;\n    [SerializeField] private bool _disableAfterUse = true;\n    [SerializeField] private bool _hideAfterUse = false;\n    \n    [Header(\"Visual Feedback\")]\n    [SerializeField] private string _usedText = \"Used\";\n    [SerializeField] private Color _disabledColor = Color.gray;\n    \n    [Header(\"Events\")]\n    [SerializeField] private UnityEvent _onButtonPressed;\n    \n    private bool _hasBeenUsed = false;\n    private Text _buttonText;\n    private Image _buttonImage;\n    private string _originalText;\n    private Color _originalColor;\n    \n    private void Awake()\n    {\n        if (_button == null)\n            _button = GetComponent<Button>();\n            \n        if (_button != null)\n        {\n            _buttonText = _button.GetComponentInChildren<Text>();\n            _buttonImage = _button.GetComponent<Image>();\n            \n            if (_buttonText != null)\n                _originalText = _buttonText.text;\n                \n            if (_buttonImage != null)\n                _originalColor = _buttonImage.color;\n        }\n    }\n    \n    private void Start()\n    {\n        if (_button != null)\n        {\n            _button.onClick.AddListener(OnButtonClick);\n        }\n    }\n    \n    private void OnButtonClick()\n    {\n        if (_hasBeenUsed) return;\n        \n        _hasBeenUsed = true;\n        _onButtonPressed?.Invoke();\n        \n        HandlePostClickBehavior();\n    }\n    \n    private void HandlePostClickBehavior()\n    {\n        if (_button == null) return;\n        \n        if (_disableAfterUse)\n        {\n            _button.interactable = false;\n            \n            if (_buttonImage != null)\n                _buttonImage.color = _disabledColor;\n        }\n        \n        if (_buttonText != null && !string.IsNullOrEmpty(_usedText))\n        {\n            _buttonText.text = _usedText;\n        }\n        \n        if (_hideAfterUse)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n    \n    public void ResetButton()\n    {\n        _hasBeenUsed = false;\n        \n        if (_button != null)\n        {\n            _button.interactable = true;\n            \n            if (_buttonImage != null)\n                _buttonImage.color = _originalColor;\n        }\n        \n        if (_buttonText != null && !string.IsNullOrEmpty(_originalText))\n        {\n            _buttonText.text = _originalText;\n        }\n        \n        if (!gameObject.activeInHierarchy)\n        {\n            gameObject.SetActive(true);\n        }\n    }\n    \n    public bool HasBeenUsed => _hasBeenUsed;\n    \n    private void OnDestroy()\n    {\n        if (_button != null)\n        {\n            _button.onClick.RemoveListener(OnButtonClick);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"IceWand\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"freezeRange\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"freezeDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"cooldownTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isOnCooldown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"cast_freeze_spell\",\n      \"trigger\": \"when player presses fire button and wand is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"create ice particle effect at wand tip\"\n        },\n        {\n          \"action\": \"find all enemies within freeze range\"\n        },\n        {\n          \"action\": \"freeze all found enemies for freeze duration\"\n        },\n        {\n          \"action\": \"play ice casting sound effect\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_cooldown\",\n      \"trigger\": \"when cooldown timer reaches cooldown time\",\n      \"actions\": [\n        {\n          \"action\": \"set wand as ready to use again\"\n        },\n        {\n          \"action\": \"play ready chime sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"when wand is on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"dim wand glow effect\"\n        },\n        {\n          \"action\": \"show cooldown indicator\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class IceWand : MonoBehaviour\n{\n    [Header(\"Wand Settings\")]\n    [SerializeField] private float _freezeRange = 10f;\n    [SerializeField] private float _freezeDuration = 3f;\n    [SerializeField] private float _cooldownTime = 1f;\n    [SerializeField] private LayerMask _freezableLayer = -1;\n    [SerializeField] private KeyCode _useKey = KeyCode.Mouse0;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _freezeEffectPrefab;\n    [SerializeField] private ParticleSystem _castParticles;\n    [SerializeField] private LineRenderer _iceBeam;\n    [SerializeField] private float _beamDuration = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _freezeSound;\n    [SerializeField] private AudioClip _cooldownSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent<GameObject> OnTargetFrozen;\n    public UnityEvent OnWandUsed;\n    public UnityEvent OnCooldownComplete;\n    \n    private bool _isOnCooldown;\n    private float _cooldownTimer;\n    private Camera _playerCamera;\n    \n    [System.Serializable]\n    public class FreezableObject\n    {\n        public Rigidbody rigidBody;\n        public Collider objectCollider;\n        public Renderer objectRenderer;\n        public Material originalMaterial;\n        public Material frozenMaterial;\n        public bool isCurrentlyFrozen;\n        public float freezeEndTime;\n        public Vector3 originalVelocity;\n        public Vector3 originalAngularVelocity;\n        public bool wasKinematic;\n        \n        public FreezableObject(GameObject obj)\n        {\n            rigidBody = obj.GetComponent<Rigidbody>();\n            objectCollider = obj.GetComponent<Collider>();\n            objectRenderer = obj.GetComponent<Renderer>();\n            \n            if (objectRenderer != null)\n            {\n                originalMaterial = objectRenderer.material;\n            }\n            \n            if (rigidBody != null)\n            {\n                wasKinematic = rigidBody.isKinematic;\n            }\n        }\n    }\n    \n    private System.Collections.Generic.List<FreezableObject> _frozenObjects = new System.Collections.Generic.List<FreezableObject>();\n    \n    void Start()\n    {\n        _playerCamera = Camera.main;\n        if (_playerCamera == null)\n            _playerCamera = FindObjectOfType<Camera>();\n            \n        if (_audioSource == null)\n            _audioSource = GetComponent<AudioSource>();\n            \n        if (_iceBeam != null)\n        {\n            _iceBeam.enabled = false;\n            _iceBeam.startWidth = 0.1f;\n            _iceBeam.endWidth = 0.05f;\n        }\n    }\n    \n    void Update()\n    {\n        HandleInput();\n        UpdateCooldown();\n        UpdateFrozenObjects();\n    }\n    \n    void HandleInput()\n    {\n        if (Input.GetKeyDown(_useKey) && !_isOnCooldown)\n        {\n            UseWand();\n        }\n    }\n    \n    void UpdateCooldown()\n    {\n        if (_isOnCooldown)\n        {\n            _cooldownTimer -= Time.deltaTime;\n            if (_cooldownTimer <= 0f)\n            {\n                _isOnCooldown = false;\n                OnCooldownComplete?.Invoke();\n                \n                if (_audioSource != null && _cooldownSound != null)\n                    _audioSource.PlayOneShot(_cooldownSound);\n            }\n        }\n    }\n    \n    void UpdateFrozenObjects()\n    {\n        for (int i = _frozenObjects.Count - 1; i >= 0; i--)\n        {\n            var frozenObj = _frozenObjects[i];\n            \n            if (frozenObj.rigidBody == null)\n            {\n                _frozenObjects.RemoveAt(i);\n                continue;\n            }\n            \n            if (Time.time >= frozenObj.freezeEndTime)\n            {\n                UnfreezeObject(frozenObj);\n                _frozenObjects.RemoveAt(i);\n            }\n        }\n    }\n    \n    void UseWand()\n    {\n        if (_playerCamera == null) return;\n        \n        Ray ray = _playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2, 0));\n        RaycastHit hit;\n        \n        if (Physics.Raycast(ray, out hit, _freezeRange, _freezableLayer))\n        {\n            FreezeTarget(hit.collider.gameObject, hit.point);\n            \n            if (_iceBeam != null)\n                StartCoroutine(ShowIceBeam(transform.position, hit.point));\n        }\n        \n        StartCooldown();\n        OnWandUsed?.Invoke();\n        \n        if (_castParticles != null)\n            _castParticles.Play();\n            \n        if (_audioSource != null && _freezeSound != null)\n            _audioSource.PlayOneShot(_freezeSound);\n    }\n    \n    void FreezeTarget(GameObject target, Vector3 hitPoint)\n    {\n        if (target == null) return;\n        \n        // Check if already frozen\n        foreach (var frozen in _frozenObjects)\n        {\n            if (frozen.rigidBody != null && frozen.rigidBody.gameObject == target)\n            {\n                // Extend freeze duration\n                frozen.freezeEndTime = Time.time + _freezeDuration;\n                return;\n            }\n        }\n        \n        FreezableObject freezableObj = new FreezableObject(target);\n        \n        if (freezableObj.rigidBody != null)\n        {\n            // Store current physics state\n            freezableObj.originalVelocity = freezableObj.rigidBody.velocity;\n            freezableObj.originalAngularVelocity = freezableObj.rigidBody.angularVelocity;\n            \n            // Freeze physics\n            freezableObj.rigidBody.velocity = Vector3.zero;\n            freezableObj.rigidBody.angularVelocity = Vector3.zero;\n            freezableObj.rigidBody.isKinematic = true;\n        }\n        \n        // Visual freeze effect\n        if (freezableObj.objectRenderer != null && freezableObj.frozenMaterial != null)\n        {\n            freezableObj.objectRenderer.material = freezableObj.frozenMaterial;\n        }\n        \n        // Add ice effect\n        if (_freezeEffectPrefab != null)\n        {\n            GameObject iceEffect = Instantiate(_freezeEffectPrefab, hitPoint, Quaternion.identity);\n            iceEffect.transform.SetParent(target.transform);\n            Destroy(iceEffect, _freezeDuration);\n        }\n        \n        freezableObj.isCurrentlyFrozen = true;\n        freezableObj.freezeEndTime = Time.time + _freezeDuration;\n        \n        _frozenObjects.Add(freezableObj);\n        OnTargetFrozen?.Invoke(target);\n    }\n    \n    void UnfreezeObject(FreezableObject frozenObj)\n    {\n        if (frozenObj.rigidBody == null) return;\n        \n        // Restore physics\n        frozenObj.rigidBody.isKinematic = frozenObj.wasKinematic;\n        \n        if (!frozenObj.wasKinematic)\n        {\n            frozenObj.rigidBody.velocity = frozenObj.originalVelocity * 0.5f; // Reduced momentum\n            frozenObj.rigidBody.angularVelocity = frozenObj.originalAngularVelocity * 0.5f;\n        }\n        \n        // Restore visual\n        if (frozenObj.objectRenderer != null && frozenObj.originalMaterial != null)\n        {\n            frozenObj.objectRenderer.material = frozenObj.originalMaterial;\n        }\n        \n        frozenObj.isCurrentlyFrozen = false;\n    }\n    \n    void StartCooldown()\n    {\n        _isOnCooldown = true;\n        _cooldownTimer = _cooldownTime;\n    }\n    \n    System.Collections.IEnumerator ShowIceBeam(Vector3 start, Vector3 end)\n    {\n        if (_iceBeam == null) yield break;\n        \n        _iceBeam.enabled = true;\n        _iceBeam.positionCount = 2;\n        _iceBeam.SetPosition(0, start);\n        _iceBeam.SetPosition(1, end);\n        \n        yield return new WaitForSeconds(_beamDuration);\n        \n        _iceBeam.enabled = false;\n    }\n    \n    public bool IsOnCooldown()\n    {\n        return _isOnCooldown;\n    }\n    \n    public float GetCooldownProgress()\n    {\n        if (!_isOnCooldown) return 1f;\n        return 1f - (_cooldownTimer / _cooldownTime);\n    }\n    \n    public void SetFrozenMaterial(Material frozenMat)\n    {\n        foreach (var frozen in _frozenObjects)\n        {\n            frozen.frozenMaterial = frozenMat;\n        }\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_playerCamera != null)\n        {\n            Gizmos.color = Color.cyan;\n            Vector3 forward = _playerCamera.transform.forward;\n            Gizmos.DrawRay(_playerCamera.transform.position, forward * _freezeRange);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SnowboardController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"turnSpeed\",\n      \"type\": \"float\",\n      \"default\": 120\n    },\n    {\n      \"name\": \"brakeForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 12\n    },\n    {\n      \"name\": \"slopeAngleThreshold\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate_downhill\",\n      \"trigger\": \"when on a slope steeper than threshold angle\",\n      \"actions\": [\n        {\n          \"action\": \"accelerate forward based on slope steepness\"\n        },\n        {\n          \"action\": \"limit speed to maximum allowed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_left\",\n      \"trigger\": \"when left input is pressed and grounded\",\n      \"actions\": [\n        {\n          \"action\": \"rotate left at turn speed\"\n        },\n        {\n          \"action\": \"lean snowboard left for visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"turn_right\",\n      \"trigger\": \"when right input is pressed and grounded\",\n      \"actions\": [\n        {\n          \"action\": \"rotate right at turn speed\"\n        },\n        {\n          \"action\": \"lean snowboard right for visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake\",\n      \"trigger\": \"when brake input is held and grounded\",\n      \"actions\": [\n        {\n          \"action\": \"apply brake force to reduce speed\"\n        },\n        {\n          \"action\": \"create snow spray particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"jump\",\n      \"trigger\": \"when jump input is pressed and grounded\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward jump force\"\n        },\n        {\n          \"action\": \"set grounded status to false\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_on_ground\",\n      \"trigger\": \"when colliding with ground while not grounded\",\n      \"actions\": [\n        {\n          \"action\": \"set grounded status to true\"\n        },\n        {\n          \"action\": \"create landing impact effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_slope_alignment\",\n      \"trigger\": \"when grounded on sloped terrain\",\n      \"actions\": [\n        {\n          \"action\": \"align snowboard rotation to match ground slope\"\n        },\n        {\n          \"action\": \"adjust rider posture based on terrain angle\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SnowboardController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _maxSpeed = 20f;\n    [SerializeField] private float _acceleration = 5f;\n    [SerializeField] private float _deceleration = 3f;\n    [SerializeField] private float _turnSpeed = 100f;\n    [SerializeField] private float _gravityMultiplier = 2f;\n    \n    [Header(\"Slope Detection\")]\n    [SerializeField] private float _slopeCheckDistance = 1.5f;\n    [SerializeField] private LayerMask _groundLayer = 1;\n    [SerializeField] private float _minSlopeAngle = 5f;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _airDrag = 0.5f;\n    [SerializeField] private float _groundDrag = 2f;\n    [SerializeField] private float _jumpForce = 8f;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _snowSprayEffect;\n    [SerializeField] private TrailRenderer _boardTrail;\n    [SerializeField] private Transform _boardVisual;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _carveSound;\n    [SerializeField] private AudioClip _jumpSound;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnLanding;\n    public UnityEvent OnJump;\n    public UnityEvent<float> OnSpeedChange;\n    \n    private Rigidbody _rigidbody;\n    private bool _isGrounded;\n    private bool _isOnSlope;\n    private float _currentSpeed;\n    private float _slopeAngle;\n    private Vector3 _slopeNormal;\n    private Vector3 _moveDirection;\n    private bool _wasGrounded;\n    \n    private void Start()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _rigidbody.freezeRotation = true;\n        \n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_snowSprayEffect != null)\n        {\n            _snowSprayEffect.Stop();\n        }\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        CheckGroundStatus();\n        UpdateVisualEffects();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        ApplyMovement();\n        ApplyGravity();\n        HandleDrag();\n    }\n    \n    private void HandleInput()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = Input.GetAxis(\"Vertical\");\n        \n        if (_isGrounded)\n        {\n            // Turn the snowboard\n            if (Mathf.Abs(horizontalInput) > 0.1f)\n            {\n                transform.Rotate(0, horizontalInput * _turnSpeed * Time.deltaTime, 0);\n            }\n            \n            // Calculate movement direction based on slope\n            if (_isOnSlope)\n            {\n                _moveDirection = GetSlopeDirection();\n            }\n            else\n            {\n                _moveDirection = transform.forward;\n            }\n            \n            // Jump\n            if (Input.GetKeyDown(KeyCode.Space))\n            {\n                Jump();\n            }\n        }\n    }\n    \n    private void CheckGroundStatus()\n    {\n        RaycastHit hit;\n        _wasGrounded = _isGrounded;\n        \n        if (Physics.Raycast(transform.position, Vector3.down, out hit, _slopeCheckDistance, _groundLayer))\n        {\n            _isGrounded = true;\n            _slopeNormal = hit.normal;\n            _slopeAngle = Vector3.Angle(Vector3.up, _slopeNormal);\n            _isOnSlope = _slopeAngle > _minSlopeAngle && _slopeAngle < 60f;\n            \n            // Landing detection\n            if (!_wasGrounded && _isGrounded)\n            {\n                OnLanding?.Invoke();\n            }\n        }\n        else\n        {\n            _isGrounded = false;\n            _isOnSlope = false;\n            _slopeAngle = 0f;\n        }\n    }\n    \n    private Vector3 GetSlopeDirection()\n    {\n        Vector3 forward = transform.forward;\n        return Vector3.ProjectOnPlane(forward, _slopeNormal).normalized;\n    }\n    \n    private void ApplyMovement()\n    {\n        if (_isGrounded && _isOnSlope)\n        {\n            // Calculate slope-based acceleration\n            float slopeAcceleration = _acceleration * (_slopeAngle / 45f);\n            _currentSpeed = Mathf.Min(_currentSpeed + slopeAcceleration * Time.fixedDeltaTime, _maxSpeed);\n            \n            // Apply movement\n            Vector3 targetVelocity = _moveDirection * _currentSpeed;\n            targetVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 5f);\n        }\n        else if (_isGrounded && !_isOnSlope)\n        {\n            // Decelerate on flat ground\n            _currentSpeed = Mathf.Max(_currentSpeed - _deceleration * Time.fixedDeltaTime, 0f);\n            \n            Vector3 targetVelocity = _moveDirection * _currentSpeed;\n            targetVelocity.y = _rigidbody.velocity.y;\n            _rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, targetVelocity, Time.fixedDeltaTime * 3f);\n        }\n        \n        OnSpeedChange?.Invoke(_currentSpeed);\n    }\n    \n    private void ApplyGravity()\n    {\n        if (!_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.down * _gravityMultiplier * Physics.gravity.magnitude, ForceMode.Acceleration);\n        }\n    }\n    \n    private void HandleDrag()\n    {\n        _rigidbody.drag = _isGrounded ? _groundDrag : _airDrag;\n    }\n    \n    private void Jump()\n    {\n        if (_isGrounded)\n        {\n            _rigidbody.AddForce(Vector3.up * _jumpForce, ForceMode.Impulse);\n            OnJump?.Invoke();\n            \n            if (_audioSource != null && _jumpSound != null)\n            {\n                _audioSource.PlayOneShot(_jumpSound);\n            }\n        }\n    }\n    \n    private void UpdateVisualEffects()\n    {\n        // Snow spray effect\n        if (_snowSprayEffect != null)\n        {\n            if (_isGrounded && _currentSpeed > 5f)\n            {\n                if (!_snowSprayEffect.isPlaying)\n                {\n                    _snowSprayEffect.Play();\n                }\n                \n                var emission = _snowSprayEffect.emission;\n                emission.rateOverTime = _currentSpeed * 2f;\n            }\n            else if (_snowSprayEffect.isPlaying)\n            {\n                _snowSprayEffect.Stop();\n            }\n        }\n        \n        // Board trail\n        if (_boardTrail != null)\n        {\n            _boardTrail.emitting = _isGrounded && _currentSpeed > 3f;\n        }\n        \n        // Board visual rotation\n        if (_boardVisual != null && _isGrounded)\n        {\n            float tiltAngle = Mathf.Clamp(Input.GetAxis(\"Horizontal\") * 15f, -15f, 15f);\n            _boardVisual.localRotation = Quaternion.Lerp(_boardVisual.localRotation, \n                Quaternion.Euler(0, 0, -tiltAngle), Time.deltaTime * 5f);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null && _carveSound != null)\n        {\n            if (_isGrounded && _currentSpeed > 3f && Mathf.Abs(Input.GetAxis(\"Horizontal\")) > 0.3f)\n            {\n                if (!_audioSource.isPlaying)\n                {\n                    _audioSource.clip = _carveSound;\n                    _audioSource.Play();\n                }\n                _audioSource.volume = Mathf.Clamp01(_currentSpeed / _maxSpeed);\n            }\n            else if (_audioSource.isPlaying && _audioSource.clip == _carveSound)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        // Draw slope check ray\n        Gizmos.color = _isGrounded ? Color.green : Color.red;\n        Gizmos.DrawRay(transform.position, Vector3.down * _slopeCheckDistance);\n        \n        // Draw slope normal\n        if (_isOnSlope)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawRay(transform.position, _slopeNormal * 2f);\n        }\n        \n        // Draw movement direction\n        if (_moveDirection != Vector3.zero)\n        {\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawRay(transform.position, _moveDirection * 3f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpectatorCamera\",\n  \"components\": [\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"lookSensitivity\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"fastMoveMultiplier\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"free_look_movement\",\n      \"trigger\": \"when mouse moves\",\n      \"actions\": [\n        {\n          \"action\": \"rotate camera horizontally based on mouse horizontal movement\"\n        },\n        {\n          \"action\": \"rotate camera vertically based on mouse vertical movement\"\n        },\n        {\n          \"action\": \"clamp vertical rotation to prevent over-rotation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"forward_movement\",\n      \"trigger\": \"when W key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera forward in the direction it is facing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"backward_movement\",\n      \"trigger\": \"when S key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera backward opposite to the direction it is facing\"\n        }\n      ]\n    },\n    {\n      \"name\": \"left_strafe\",\n      \"trigger\": \"when A key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera left perpendicular to facing direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"right_strafe\",\n      \"trigger\": \"when D key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera right perpendicular to facing direction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"upward_movement\",\n      \"trigger\": \"when Q key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera upward in world space\"\n        }\n      ]\n    },\n    {\n      \"name\": \"downward_movement\",\n      \"trigger\": \"when E key is held down\",\n      \"actions\": [\n        {\n          \"action\": \"move camera downward in world space\"\n        }\n      ]\n    },\n    {\n      \"name\": \"fast_movement\",\n      \"trigger\": \"when shift key is held while moving\",\n      \"actions\": [\n        {\n          \"action\": \"multiply movement speed by fast move multiplier\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SpectatorCamera : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float _moveSpeed = 10f;\n    [SerializeField] private float _fastMoveSpeed = 20f;\n    [SerializeField] private float _smoothTime = 0.1f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _mouseSensitivity = 2f;\n    [SerializeField] private float _maxLookAngle = 80f;\n    \n    [Header(\"Zoom Settings\")]\n    [SerializeField] private float _zoomSpeed = 2f;\n    [SerializeField] private float _minFOV = 10f;\n    [SerializeField] private float _maxFOV = 90f;\n    \n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode _fastMoveKey = KeyCode.LeftShift;\n    [SerializeField] private KeyCode _upKey = KeyCode.E;\n    [SerializeField] private KeyCode _downKey = KeyCode.Q;\n    [SerializeField] private bool _invertY = false;\n    \n    private Camera _camera;\n    private Vector3 _velocity;\n    private float _rotationX = 0f;\n    private float _rotationY = 0f;\n    private bool _isMouseLocked = true;\n    \n    private void Start()\n    {\n        _camera = GetComponent<Camera>();\n        if (_camera == null)\n        {\n            _camera = Camera.main;\n        }\n        \n        Vector3 eulerAngles = transform.eulerAngles;\n        _rotationX = eulerAngles.x;\n        _rotationY = eulerAngles.y;\n        \n        LockCursor();\n    }\n    \n    private void Update()\n    {\n        HandleInput();\n        HandleMouseLook();\n        HandleMovement();\n        HandleZoom();\n    }\n    \n    private void HandleInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            ToggleCursorLock();\n        }\n    }\n    \n    private void HandleMouseLook()\n    {\n        if (!_isMouseLocked) return;\n        \n        float mouseX = Input.GetAxis(\"Mouse X\") * _mouseSensitivity;\n        float mouseY = Input.GetAxis(\"Mouse Y\") * _mouseSensitivity;\n        \n        if (_invertY)\n            mouseY = -mouseY;\n        \n        _rotationY += mouseX;\n        _rotationX -= mouseY;\n        _rotationX = Mathf.Clamp(_rotationX, -_maxLookAngle, _maxLookAngle);\n        \n        transform.rotation = Quaternion.Euler(_rotationX, _rotationY, 0f);\n    }\n    \n    private void HandleMovement()\n    {\n        Vector3 inputDirection = Vector3.zero;\n        \n        if (Input.GetKey(KeyCode.W)) inputDirection += Vector3.forward;\n        if (Input.GetKey(KeyCode.S)) inputDirection += Vector3.back;\n        if (Input.GetKey(KeyCode.A)) inputDirection += Vector3.left;\n        if (Input.GetKey(KeyCode.D)) inputDirection += Vector3.right;\n        if (Input.GetKey(_upKey)) inputDirection += Vector3.up;\n        if (Input.GetKey(_downKey)) inputDirection += Vector3.down;\n        \n        inputDirection = transform.TransformDirection(inputDirection);\n        inputDirection.Normalize();\n        \n        float currentSpeed = Input.GetKey(_fastMoveKey) ? _fastMoveSpeed : _moveSpeed;\n        Vector3 targetVelocity = inputDirection * currentSpeed;\n        \n        _velocity = Vector3.Lerp(_velocity, targetVelocity, Time.deltaTime / _smoothTime);\n        transform.position += _velocity * Time.deltaTime;\n    }\n    \n    private void HandleZoom()\n    {\n        if (_camera == null) return;\n        \n        float scroll = Input.GetAxis(\"Mouse ScrollWheel\");\n        if (Mathf.Abs(scroll) > 0.01f)\n        {\n            float newFOV = _camera.fieldOfView - scroll * _zoomSpeed * 10f;\n            _camera.fieldOfView = Mathf.Clamp(newFOV, _minFOV, _maxFOV);\n        }\n    }\n    \n    private void LockCursor()\n    {\n        Cursor.lockState = CursorLockMode.Locked;\n        Cursor.visible = false;\n        _isMouseLocked = true;\n    }\n    \n    private void UnlockCursor()\n    {\n        Cursor.lockState = CursorLockMode.None;\n        Cursor.visible = true;\n        _isMouseLocked = false;\n    }\n    \n    private void ToggleCursorLock()\n    {\n        if (_isMouseLocked)\n        {\n            UnlockCursor();\n        }\n        else\n        {\n            LockCursor();\n        }\n    }\n    \n    public void SetPosition(Vector3 position)\n    {\n        transform.position = position;\n        _velocity = Vector3.zero;\n    }\n    \n    public void SetRotation(Vector3 eulerAngles)\n    {\n        transform.eulerAngles = eulerAngles;\n        _rotationX = eulerAngles.x;\n        _rotationY = eulerAngles.y;\n    }\n    \n    public void SetMoveSpeed(float speed)\n    {\n        _moveSpeed = Mathf.Max(0f, speed);\n    }\n    \n    public void SetMouseSensitivity(float sensitivity)\n    {\n        _mouseSensitivity = Mathf.Max(0.1f, sensitivity);\n    }\n    \n    private void OnApplicationFocus(bool hasFocus)\n    {\n        if (hasFocus && _isMouseLocked)\n        {\n            LockCursor();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MatchmakingQueue\",\n  \"components\": [\n    \"MonoBehaviour\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxPlayersPerMatch\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"queueTimeoutSeconds\",\n      \"type\": \"float\",\n      \"default\": 60\n    },\n    {\n      \"name\": \"skillRangeThreshold\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"waitingPlayers\",\n      \"type\": \"List<Player>\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentQueueTime\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isSearchingForMatch\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"join_queue\",\n      \"trigger\": \"when player requests to join matchmaking\",\n      \"actions\": [\n        {\n          \"action\": \"add player to waiting players list\"\n        },\n        {\n          \"action\": \"set searching for match to true\"\n        },\n        {\n          \"action\": \"reset current queue time to zero\"\n        },\n        {\n          \"action\": \"display queue status to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"leave_queue\",\n      \"trigger\": \"when player cancels matchmaking or leaves\",\n      \"actions\": [\n        {\n          \"action\": \"remove player from waiting players list\"\n        },\n        {\n          \"action\": \"set searching for match to false\"\n        },\n        {\n          \"action\": \"hide queue status display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"find_match\",\n      \"trigger\": \"when enough players with similar skill levels are in queue\",\n      \"actions\": [\n        {\n          \"action\": \"group compatible players together\"\n        },\n        {\n          \"action\": \"remove matched players from waiting list\"\n        },\n        {\n          \"action\": \"create new match session\"\n        },\n        {\n          \"action\": \"notify all matched players\"\n        },\n        {\n          \"action\": \"transfer players to game lobby\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_queue_time\",\n      \"trigger\": \"every frame while searching for match\",\n      \"actions\": [\n        {\n          \"action\": \"increase current queue time\"\n        },\n        {\n          \"action\": \"update queue timer display\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_queue_timeout\",\n      \"trigger\": \"when queue time exceeds timeout limit\",\n      \"actions\": [\n        {\n          \"action\": \"expand skill range threshold\"\n        },\n        {\n          \"action\": \"notify player of extended search\"\n        },\n        {\n          \"action\": \"reset queue time if still no match found\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_skill_compatibility\",\n      \"trigger\": \"when evaluating potential player matches\",\n      \"actions\": [\n        {\n          \"action\": \"compare player skill ratings\"\n        },\n        {\n          \"action\": \"determine if players fall within acceptable range\"\n        },\n        {\n          \"action\": \"prioritize closer skill matches\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.UI;\n\npublic class MatchmakingQueue : MonoBehaviour\n{\n    [System.Serializable]\n    public class PlayerData\n    {\n        public string playerId;\n        public string playerName;\n        public int skillRating;\n        public float queueTime;\n        public bool isReady;\n        \n        public PlayerData(string id, string name, int rating)\n        {\n            playerId = id;\n            playerName = name;\n            skillRating = rating;\n            queueTime = 0f;\n            isReady = false;\n        }\n    }\n    \n    [System.Serializable]\n    public class Match\n    {\n        public List<PlayerData> players;\n        public string matchId;\n        public float averageSkillRating;\n        \n        public Match()\n        {\n            players = new List<PlayerData>();\n            matchId = System.Guid.NewGuid().ToString();\n        }\n    }\n    \n    [System.Serializable]\n    public class MatchmakingEvents\n    {\n        public UnityEvent<PlayerData> OnPlayerJoinedQueue;\n        public UnityEvent<PlayerData> OnPlayerLeftQueue;\n        public UnityEvent<Match> OnMatchFound;\n        public UnityEvent<string> OnMatchmakingStatusChanged;\n    }\n    \n    [Header(\"Queue Settings\")]\n    [SerializeField] private int _maxPlayersPerMatch = 4;\n    [SerializeField] private int _minPlayersPerMatch = 2;\n    [SerializeField] private float _maxSkillRatingDifference = 200f;\n    [SerializeField] private float _queueTimeExpansionRate = 50f;\n    [SerializeField] private float _maxQueueTime = 300f;\n    \n    [Header(\"Matchmaking Intervals\")]\n    [SerializeField] private float _matchmakingInterval = 2f;\n    [SerializeField] private float _queueUpdateInterval = 1f;\n    \n    [Header(\"UI References\")]\n    [SerializeField] private Text _queueStatusText;\n    [SerializeField] private Text _playersInQueueText;\n    [SerializeField] private Text _estimatedWaitTimeText;\n    [SerializeField] private Button _joinQueueButton;\n    [SerializeField] private Button _leaveQueueButton;\n    [SerializeField] private Slider _queueProgressSlider;\n    \n    [Header(\"Events\")]\n    [SerializeField] private MatchmakingEvents _events;\n    \n    private List<PlayerData> _queuedPlayers = new List<PlayerData>();\n    private List<Match> _activeMatches = new List<Match>();\n    private PlayerData _localPlayer;\n    private bool _isInQueue = false;\n    private bool _isMatchmakingActive = true;\n    private Coroutine _matchmakingCoroutine;\n    private Coroutine _queueUpdateCoroutine;\n    \n    public bool IsInQueue => _isInQueue;\n    public int PlayersInQueue => _queuedPlayers.Count;\n    public float LocalPlayerQueueTime => _localPlayer?.queueTime ?? 0f;\n    \n    private void Start()\n    {\n        InitializeUI();\n        StartMatchmaking();\n    }\n    \n    private void InitializeUI()\n    {\n        if (_joinQueueButton != null)\n            _joinQueueButton.onClick.AddListener(JoinQueue);\n            \n        if (_leaveQueueButton != null)\n            _leaveQueueButton.onClick.AddListener(LeaveQueue);\n            \n        UpdateUI();\n    }\n    \n    private void StartMatchmaking()\n    {\n        if (_matchmakingCoroutine != null)\n            StopCoroutine(_matchmakingCoroutine);\n            \n        if (_queueUpdateCoroutine != null)\n            StopCoroutine(_queueUpdateCoroutine);\n            \n        _matchmakingCoroutine = StartCoroutine(MatchmakingLoop());\n        _queueUpdateCoroutine = StartCoroutine(QueueUpdateLoop());\n    }\n    \n    public void JoinQueue()\n    {\n        if (_isInQueue) return;\n        \n        string playerId = SystemInfo.deviceUniqueIdentifier;\n        string playerName = \"Player_\" + UnityEngine.Random.Range(1000, 9999);\n        int skillRating = UnityEngine.Random.Range(1000, 2000);\n        \n        JoinQueue(playerId, playerName, skillRating);\n    }\n    \n    public void JoinQueue(string playerId, string playerName, int skillRating)\n    {\n        if (_isInQueue) return;\n        \n        _localPlayer = new PlayerData(playerId, playerName, skillRating);\n        _queuedPlayers.Add(_localPlayer);\n        _isInQueue = true;\n        \n        _events.OnPlayerJoinedQueue?.Invoke(_localPlayer);\n        _events.OnMatchmakingStatusChanged?.Invoke(\"Joined queue\");\n        \n        UpdateUI();\n    }\n    \n    public void LeaveQueue()\n    {\n        if (!_isInQueue || _localPlayer == null) return;\n        \n        _queuedPlayers.Remove(_localPlayer);\n        _events.OnPlayerLeftQueue?.Invoke(_localPlayer);\n        _events.OnMatchmakingStatusChanged?.Invoke(\"Left queue\");\n        \n        _localPlayer = null;\n        _isInQueue = false;\n        \n        UpdateUI();\n    }\n    \n    public void AddBotToQueue()\n    {\n        string botId = \"Bot_\" + System.Guid.NewGuid().ToString();\n        string botName = \"Bot_\" + UnityEngine.Random.Range(100, 999);\n        int botRating = UnityEngine.Random.Range(1000, 2000);\n        \n        PlayerData bot = new PlayerData(botId, botName, botRating);\n        _queuedPlayers.Add(bot);\n        \n        _events.OnPlayerJoinedQueue?.Invoke(bot);\n        UpdateUI();\n    }\n    \n    private IEnumerator MatchmakingLoop()\n    {\n        while (_isMatchmakingActive)\n        {\n            if (_queuedPlayers.Count >= _minPlayersPerMatch)\n            {\n                TryCreateMatches();\n            }\n            \n            yield return new WaitForSeconds(_matchmakingInterval);\n        }\n    }\n    \n    private IEnumerator QueueUpdateLoop()\n    {\n        while (_isMatchmakingActive)\n        {\n            UpdateQueueTimes();\n            UpdateUI();\n            \n            yield return new WaitForSeconds(_queueUpdateInterval);\n        }\n    }\n    \n    private void UpdateQueueTimes()\n    {\n        for (int i = 0; i < _queuedPlayers.Count; i++)\n        {\n            _queuedPlayers[i].queueTime += _queueUpdateInterval;\n            \n            if (_queuedPlayers[i].queueTime > _maxQueueTime)\n            {\n                RemovePlayerFromQueue(_queuedPlayers[i]);\n                i--;\n            }\n        }\n    }\n    \n    private void TryCreateMatches()\n    {\n        List<PlayerData> availablePlayers = new List<PlayerData>(_queuedPlayers);\n        availablePlayers.Sort((a, b) => a.queueTime.CompareTo(b.queueTime));\n        \n        while (availablePlayers.Count >= _minPlayersPerMatch)\n        {\n            Match match = CreateMatch(availablePlayers);\n            if (match != null && match.players.Count >= _minPlayersPerMatch)\n            {\n                _activeMatches.Add(match);\n                \n                foreach (PlayerData player in match.players)\n                {\n                    _queuedPlayers.Remove(player);\n                    availablePlayers.Remove(player);\n                }\n                \n                _events.OnMatchFound?.Invoke(match);\n                _events.OnMatchmakingStatusChanged?.Invoke($\"Match found with {match.players.Count} players\");\n                \n                if (_localPlayer != null && match.players.Contains(_localPlayer))\n                {\n                    _isInQueue = false;\n                    _localPlayer = null;\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    \n    private Match CreateMatch(List<PlayerData> availablePlayers)\n    {\n        if (availablePlayers.Count < _minPlayersPerMatch) return null;\n        \n        Match match = new Match();\n        PlayerData anchor = availablePlayers[0];\n        match.players.Add(anchor);\n        availablePlayers.RemoveAt(0);\n        \n        float expandedSkillRange = _maxSkillRatingDifference + (anchor.queueTime * _queueTimeExpansionRate);\n        \n        for (int i = availablePlayers.Count - 1; i >= 0 && match.players.Count < _maxPlayersPerMatch; i--)\n        {\n            PlayerData candidate = availablePlayers[i];\n            \n            if (IsPlayerCompatible(match, candidate, expandedSkillRange))\n            {\n                match.players.Add(candidate);\n                availablePlayers.RemoveAt(i);\n            }\n        }\n        \n        if (match.players.Count >= _minPlayersPerMatch)\n        {\n            CalculateMatchAverageRating(match);\n            return match;\n        }\n        \n        return null;\n    }\n    \n    private bool IsPlayerCompatible(Match match, PlayerData candidate, float skillRange)\n    {\n        foreach (PlayerData player in match.players)\n        {\n            if (Mathf.Abs(player.skillRating - candidate.skillRating) > skillRange)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private void CalculateMatchAverageRating(Match match)\n    {\n        float totalRating = 0f;\n        foreach (PlayerData player in match.players)\n        {\n            totalRating += player.skillRating;\n        }\n        match.averageSkillRating = totalRating / match.players.Count;\n    }\n    \n    private void RemovePlayerFromQueue(PlayerData player)\n    {\n        if (_queuedPlayers.Remove(player))\n        {\n            _events.OnPlayerLeftQueue?.Invoke(player);\n            \n            if (player == _localPlayer)\n            {\n                _isInQueue = false;\n                _localPlayer = null;\n                _events.OnMatchmakingStatusChanged?.Invoke(\"Removed from queue (timeout)\");\n            }\n        }\n    }\n    \n    private void UpdateUI()\n    {\n        if (_queueStatusText != null)\n        {\n            if (_isInQueue)\n            {\n                _queueStatusText.text = $\"In Queue ({LocalPlayerQueueTime:F0}s)\";\n            }\n            else\n            {\n                _queueStatusText.text = \"Not in queue\";\n            }\n        }\n        \n        if (_playersInQueueText != null)\n        {\n            _playersInQueueText.text = $\"Players in queue: {PlayersInQueue}\";\n        }\n        \n        if (_estimatedWaitTimeText != null)\n        {\n            float estimatedWait = CalculateEstimatedWaitTime();\n            _estimatedWaitTimeText.text = $\"Estimated wait: {estimatedWait:F0}s\";\n        }\n        \n        if (_joinQueueButton != null)\n        {\n            _joinQueueButton.interactable = !_isInQueue;\n        }\n        \n        if (_leaveQueueButton != null)\n        {\n            _leaveQueueButton.interactable = _isInQueue;\n        }\n        \n        if (_queueProgressSlider != null)\n        {\n            if (_isInQueue && _localPlayer != null)\n            {\n                _queueProgressSlider.value = Mathf.Clamp01(_localPlayer.queueTime / _maxQueueTime);\n            }\n            else\n            {\n                _queueProgressSlider.value = 0f;\n            }\n        }\n    }\n    \n    private float CalculateEstimatedWaitTime()\n    {\n        if (PlayersInQueue < _minPlayersPerMatch)\n        {\n            return 60f;\n        }\n        \n        float averageQueueTime = 0f;\n        foreach (PlayerData player in _queuedPlayers)\n        {\n            averageQueueTime += player.queueTime;\n        }\n        averageQueueTime /= _queuedPlayers.Count;\n        \n        return Mathf.Max(10f, 30f - (PlayersInQueue * 2f));\n    }\n    \n    public void SetMatchmakingActive(bool active)\n    {\n        _isMatchmakingActive = active;\n        \n        if (active)\n        {\n            StartMatchmaking();\n        }\n        else\n        {\n            if (_matchmakingCoroutine != null)\n                StopCoroutine(_matchmakingCoroutine);\n            if (_queueUpdateCoroutine != null)\n                StopCoroutine(_queueUpdateCoroutine);\n        }\n    }\n    \n    public List<PlayerData> GetQueuedPlayers()\n    {\n        return new List<PlayerData>(_queuedPlayers);\n    }\n    \n    public List<Match> GetActiveMatches()\n    {\n        return new List<Match>(_activeMatches);\n    }\n    \n    private void OnDestroy()\n    {\n        SetMatchmakingActive(false);\n        \n        if (_joinQueueButton != null)\n            _joinQueueButton.onClick.RemoveAllListeners();\n        if (_leaveQueueButton != null)\n            _leaveQueueButton.onClick.RemoveAllListeners();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Boomerang\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"returnForce\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"spinSpeed\",\n      \"type\": \"float\",\n      \"default\": 720\n    },\n    {\n      \"name\": \"maxDistance\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"thrower\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isReturning\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hasBeenThrown\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"throw_boomerang\",\n      \"trigger\": \"when throw input is pressed and boomerang has not been thrown\",\n      \"actions\": [\n        {\n          \"action\": \"store reference to the player as thrower\"\n        },\n        {\n          \"action\": \"apply forward force based on throw force\"\n        },\n        {\n          \"action\": \"mark boomerang as thrown\"\n        },\n        {\n          \"action\": \"start spinning continuously at spin speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_returning\",\n      \"trigger\": \"when boomerang has traveled maximum distance from thrower\",\n      \"actions\": [\n        {\n          \"action\": \"mark boomerang as returning\"\n        },\n        {\n          \"action\": \"reduce forward velocity\"\n        },\n        {\n          \"action\": \"begin moving toward thrower position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_thrower\",\n      \"trigger\": \"when boomerang is marked as returning\",\n      \"actions\": [\n        {\n          \"action\": \"move toward thrower at return force speed\"\n        },\n        {\n          \"action\": \"continue spinning\"\n        }\n      ]\n    },\n    {\n      \"name\": \"catch_boomerang\",\n      \"trigger\": \"when boomerang touches the thrower while returning\",\n      \"actions\": [\n        {\n          \"action\": \"stop all movement\"\n        },\n        {\n          \"action\": \"stop spinning\"\n        },\n        {\n          \"action\": \"reset thrown status\"\n        },\n        {\n          \"action\": \"reset returning status\"\n        },\n        {\n          \"action\": \"attach to thrower\"\n        }\n      ]\n    },\n    {\n      \"name\": \"bounce_off_obstacles\",\n      \"trigger\": \"when boomerang collides with solid objects while not returning\",\n      \"actions\": [\n        {\n          \"action\": \"reflect movement direction away from obstacle\"\n        },\n        {\n          \"action\": \"reduce velocity slightly\"\n        },\n        {\n          \"action\": \"continue spinning\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Boomerang : MonoBehaviour\n{\n    [Header(\"Flight Settings\")]\n    [SerializeField] private float _throwForce = 15f;\n    [SerializeField] private float _returnForce = 10f;\n    [SerializeField] private float _maxDistance = 20f;\n    [SerializeField] private float _returnDelay = 0.5f;\n    \n    [Header(\"Rotation Settings\")]\n    [SerializeField] private float _spinSpeed = 720f;\n    [SerializeField] private Vector3 _spinAxis = Vector3.forward;\n    \n    [Header(\"Physics\")]\n    [SerializeField] private float _drag = 0.5f;\n    [SerializeField] private float _gravityScale = 0.3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _throwSound;\n    [SerializeField] private AudioClip _catchSound;\n    [SerializeField] private AudioClip _whooshSound;\n    \n    private Transform _thrower;\n    private Vector3 _throwDirection;\n    private Rigidbody _rigidbody;\n    private AudioSource _audioSource;\n    private bool _isReturning = false;\n    private bool _isThrown = false;\n    private float _returnTimer = 0f;\n    private Vector3 _startPosition;\n    \n    private void Awake()\n    {\n        _rigidbody = GetComponent<Rigidbody>();\n        if (_rigidbody == null)\n        {\n            _rigidbody = gameObject.AddComponent<Rigidbody>();\n        }\n        \n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _rigidbody.drag = _drag;\n        _rigidbody.useGravity = true;\n        _startPosition = transform.position;\n    }\n    \n    private void Start()\n    {\n        Physics.gravity = new Vector3(0, -9.81f * _gravityScale, 0);\n    }\n    \n    private void Update()\n    {\n        if (_isThrown)\n        {\n            HandleSpin();\n            HandleReturn();\n            CheckMaxDistance();\n        }\n    }\n    \n    private void HandleSpin()\n    {\n        transform.Rotate(_spinAxis * _spinSpeed * Time.deltaTime);\n    }\n    \n    private void HandleReturn()\n    {\n        if (!_isReturning)\n        {\n            _returnTimer += Time.deltaTime;\n            if (_returnTimer >= _returnDelay)\n            {\n                StartReturning();\n            }\n        }\n        else if (_thrower != null)\n        {\n            Vector3 directionToThrower = (_thrower.position - transform.position).normalized;\n            _rigidbody.AddForce(directionToThrower * _returnForce, ForceMode.Acceleration);\n            \n            float distanceToThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceToThrower < 1f)\n            {\n                ReturnToThrower();\n            }\n        }\n    }\n    \n    private void CheckMaxDistance()\n    {\n        if (_thrower != null)\n        {\n            float distanceFromThrower = Vector3.Distance(transform.position, _thrower.position);\n            if (distanceFromThrower >= _maxDistance && !_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void StartReturning()\n    {\n        _isReturning = true;\n        _rigidbody.velocity = Vector3.zero;\n        \n        if (_whooshSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_whooshSound);\n        }\n    }\n    \n    public void ThrowBoomerang(Transform thrower, Vector3 direction)\n    {\n        if (_isThrown) return;\n        \n        _thrower = thrower;\n        _throwDirection = direction.normalized;\n        _isThrown = true;\n        _isReturning = false;\n        _returnTimer = 0f;\n        \n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.AddForce(_throwDirection * _throwForce, ForceMode.Impulse);\n        \n        if (_throwSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_throwSound);\n        }\n    }\n    \n    private void ReturnToThrower()\n    {\n        _isThrown = false;\n        _isReturning = false;\n        _returnTimer = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        \n        transform.position = _thrower.position;\n        transform.SetParent(_thrower);\n        \n        if (_catchSound != null && _audioSource != null)\n        {\n            _audioSource.PlayOneShot(_catchSound);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (_isThrown && other.transform == _thrower)\n        {\n            ReturnToThrower();\n        }\n        else if (_isThrown && !other.CompareTag(\"Player\") && !other.isTrigger)\n        {\n            if (!_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (_isThrown && collision.transform != _thrower)\n        {\n            if (!_isReturning)\n            {\n                StartReturning();\n            }\n        }\n    }\n    \n    public void ResetBoomerang()\n    {\n        _isThrown = false;\n        _isReturning = false;\n        _returnTimer = 0f;\n        _rigidbody.velocity = Vector3.zero;\n        _rigidbody.angularVelocity = Vector3.zero;\n        transform.position = _startPosition;\n        transform.SetParent(null);\n    }\n    \n    public bool IsAvailable()\n    {\n        return !_isThrown;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TransformingObject\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"transformationDuration\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"figureEightRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"basePitch\",\n      \"type\": \"float\",\n      \"default\": 440\n    },\n    {\n      \"name\": \"pitchRange\",\n      \"type\": \"float\",\n      \"default\": 200\n    },\n    {\n      \"name\": \"startingPosition\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.zero\"\n    },\n    {\n      \"name\": \"transformationProgress\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_transformation\",\n      \"trigger\": \"every frame while transformation is active\",\n      \"actions\": [\n        {\n          \"action\": \"calculate transformation progress as percentage of total duration\"\n        },\n        {\n          \"action\": \"smoothly rotate object based on transformation progress completing full 360 degree rotation\"\n        },\n        {\n          \"action\": \"smoothly scale object from original size to double size and back based on transformation progress using sine wave pattern\"\n        },\n        {\n          \"action\": \"change object color through rainbow spectrum based on transformation progress cycling through red orange yellow green blue indigo violet\"\n        },\n        {\n          \"action\": \"move object in figure-8 pattern around starting position based on transformation progress\"\n        },\n        {\n          \"action\": \"adjust audio pitch from base pitch within pitch range based on transformation progress\"\n        }\n      ]\n    },\n    {\n      \"name\": \"start_transformation\",\n      \"trigger\": \"when object becomes active\",\n      \"actions\": [\n        {\n          \"action\": \"record starting position\"\n        },\n        {\n          \"action\": \"reset transformation progress to zero\"\n        },\n        {\n          \"action\": \"start playing continuous audio tone at base pitch\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_transformation_cycle\",\n      \"trigger\": \"when transformation progress reaches full duration\",\n      \"actions\": [\n        {\n          \"action\": \"reset transformation progress to zero to loop the cycle\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class TransformingObject : MonoBehaviour\n{\n    [Header(\"Transformation Settings\")]\n    [SerializeField] private float _transformationDuration = 30f;\n    [SerializeField] private bool _loopTransformation = true;\n    \n    [Header(\"Movement\")]\n    [SerializeField] private float _figure8Width = 5f;\n    [SerializeField] private float _figure8Height = 3f;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private float _basePitch = 1f;\n    [SerializeField] private float _pitchRange = 2f;\n    [SerializeField] private float _baseFrequency = 440f;\n    \n    private Vector3 _startPosition;\n    private Vector3 _startScale;\n    private Quaternion _startRotation;\n    private Color _startColor;\n    private Renderer _renderer;\n    private AudioSource _audioSource;\n    private float _currentTime;\n    private bool _isTransforming;\n    \n    private void Start()\n    {\n        _startPosition = transform.position;\n        _startScale = transform.localScale;\n        _startRotation = transform.rotation;\n        \n        _renderer = GetComponent<Renderer>();\n        if (_renderer == null)\n        {\n            _renderer = GetComponentInChildren<Renderer>();\n        }\n        \n        if (_renderer != null)\n        {\n            _startColor = _renderer.material.color;\n        }\n        \n        SetupAudio();\n        StartTransformation();\n    }\n    \n    private void SetupAudio()\n    {\n        _audioSource = GetComponent<AudioSource>();\n        if (_audioSource == null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n        }\n        \n        _audioSource.clip = GenerateToneClip(_baseFrequency, 1f);\n        _audioSource.loop = true;\n        _audioSource.volume = 0.3f;\n        _audioSource.pitch = _basePitch;\n        _audioSource.Play();\n    }\n    \n    private AudioClip GenerateToneClip(float frequency, float duration)\n    {\n        int sampleRate = 44100;\n        int sampleCount = Mathf.RoundToInt(sampleRate * duration);\n        float[] samples = new float[sampleCount];\n        \n        for (int i = 0; i < sampleCount; i++)\n        {\n            float time = (float)i / sampleRate;\n            samples[i] = Mathf.Sin(2 * Mathf.PI * frequency * time) * 0.5f;\n        }\n        \n        AudioClip clip = AudioClip.Create(\"GeneratedTone\", sampleCount, 1, sampleRate, false);\n        clip.SetData(samples, 0);\n        return clip;\n    }\n    \n    private void Update()\n    {\n        if (!_isTransforming) return;\n        \n        _currentTime += Time.deltaTime;\n        float normalizedTime = _currentTime / _transformationDuration;\n        \n        if (normalizedTime >= 1f)\n        {\n            if (_loopTransformation)\n            {\n                _currentTime = 0f;\n                normalizedTime = 0f;\n            }\n            else\n            {\n                normalizedTime = 1f;\n                _isTransforming = false;\n            }\n        }\n        \n        ApplyTransformations(normalizedTime);\n    }\n    \n    private void ApplyTransformations(float t)\n    {\n        // Rotation - 360 degrees over duration\n        float rotationAngle = t * 360f;\n        transform.rotation = _startRotation * Quaternion.Euler(0, rotationAngle, 0);\n        \n        // Scale - 1x to 2x and back (sine wave)\n        float scaleMultiplier = 1f + Mathf.Sin(t * Mathf.PI);\n        transform.localScale = _startScale * scaleMultiplier;\n        \n        // Color - rainbow spectrum\n        Color rainbowColor = GetRainbowColor(t);\n        if (_renderer != null)\n        {\n            _renderer.material.color = rainbowColor;\n        }\n        \n        // Movement - figure-8 pattern\n        Vector3 figure8Position = GetFigure8Position(t);\n        transform.position = _startPosition + figure8Position;\n        \n        // Audio pitch based on transformation phase\n        if (_audioSource != null)\n        {\n            float pitchMultiplier = _basePitch + (Mathf.Sin(t * 2 * Mathf.PI) * _pitchRange * 0.5f);\n            _audioSource.pitch = Mathf.Clamp(pitchMultiplier, 0.1f, 3f);\n        }\n    }\n    \n    private Color GetRainbowColor(float t)\n    {\n        float hue = t;\n        return Color.HSVToRGB(hue, 1f, 1f);\n    }\n    \n    private Vector3 GetFigure8Position(float t)\n    {\n        float angle = t * 2 * Mathf.PI;\n        float x = _figure8Width * Mathf.Sin(angle);\n        float z = _figure8Height * Mathf.Sin(2 * angle);\n        return new Vector3(x, 0, z);\n    }\n    \n    public void StartTransformation()\n    {\n        _isTransforming = true;\n        _currentTime = 0f;\n    }\n    \n    public void StopTransformation()\n    {\n        _isTransforming = false;\n    }\n    \n    public void ResetToStart()\n    {\n        _currentTime = 0f;\n        transform.position = _startPosition;\n        transform.localScale = _startScale;\n        transform.rotation = _startRotation;\n        \n        if (_renderer != null)\n        {\n            _renderer.material.color = _startColor;\n        }\n        \n        if (_audioSource != null)\n        {\n            _audioSource.pitch = _basePitch;\n        }\n    }\n    \n    private void OnDestroy()\n    {\n        if (_audioSource != null && _audioSource.isPlaying)\n        {\n            _audioSource.Stop();\n        }\n    }\n    \n    private void OnValidate()\n    {\n        if (_transformationDuration <= 0f)\n        {\n            _transformationDuration = 30f;\n        }\n        \n        if (_figure8Width < 0f)\n        {\n            _figure8Width = 0f;\n        }\n        \n        if (_figure8Height < 0f)\n        {\n            _figure8Height = 0f;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MainMenuNavigation\",\n  \"components\": [\n    \"Canvas\",\n    \"GraphicRaycaster\",\n    \"EventSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"selectedButtonIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"totalButtons\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"navigationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"selectionSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"navigate_up\",\n      \"trigger\": \"when up arrow key or gamepad up is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"move selection to previous button in list\"\n        },\n        {\n          \"action\": \"wrap to last button if at first button\"\n        },\n        {\n          \"action\": \"play navigation sound\"\n        },\n        {\n          \"action\": \"highlight selected button\"\n        }\n      ]\n    },\n    {\n      \"name\": \"navigate_down\",\n      \"trigger\": \"when down arrow key or gamepad down is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"move selection to next button in list\"\n        },\n        {\n          \"action\": \"wrap to first button if at last button\"\n        },\n        {\n          \"action\": \"play navigation sound\"\n        },\n        {\n          \"action\": \"highlight selected button\"\n        }\n      ]\n    },\n    {\n      \"name\": \"confirm_selection\",\n      \"trigger\": \"when enter key or gamepad A button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"play selection sound\"\n        },\n        {\n          \"action\": \"execute action of currently selected button\"\n        },\n        {\n          \"action\": \"add button press visual feedback\"\n        }\n      ]\n    },\n    {\n      \"name\": \"mouse_hover\",\n      \"trigger\": \"when mouse cursor hovers over any menu button\",\n      \"actions\": [\n        {\n          \"action\": \"update selected button index to hovered button\"\n        },\n        {\n          \"action\": \"highlight hovered button\"\n        },\n        {\n          \"action\": \"play navigation sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_menu\",\n      \"trigger\": \"when menu becomes active\",\n      \"actions\": [\n        {\n          \"action\": \"set first button as selected\"\n        },\n        {\n          \"action\": \"highlight first button\"\n        },\n        {\n          \"action\": \"ensure all other buttons are unhighlighted\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing UnityEngine.Audio;\nusing System.Collections;\n\npublic class MainMenuNavigation : MonoBehaviour\n{\n    [Header(\"Menu Panels\")]\n    [SerializeField] private GameObject _mainMenuPanel;\n    [SerializeField] private GameObject _settingsPanel;\n    [SerializeField] private GameObject _creditsPanel;\n    [SerializeField] private GameObject _loadingPanel;\n    \n    [Header(\"Main Menu Buttons\")]\n    [SerializeField] private Button _playButton;\n    [SerializeField] private Button _settingsButton;\n    [SerializeField] private Button _creditsButton;\n    [SerializeField] private Button _quitButton;\n    \n    [Header(\"Settings UI\")]\n    [SerializeField] private Slider _masterVolumeSlider;\n    [SerializeField] private Slider _musicVolumeSlider;\n    [SerializeField] private Slider _sfxVolumeSlider;\n    [SerializeField] private Dropdown _resolutionDropdown;\n    [SerializeField] private Toggle _fullscreenToggle;\n    [SerializeField] private Button _settingsBackButton;\n    \n    [Header(\"Credits UI\")]\n    [SerializeField] private Button _creditsBackButton;\n    [SerializeField] private ScrollRect _creditsScrollRect;\n    \n    [Header(\"Loading UI\")]\n    [SerializeField] private Slider _loadingProgressBar;\n    [SerializeField] private Text _loadingText;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioMixer _audioMixer;\n    [SerializeField] private AudioSource _buttonClickSound;\n    [SerializeField] private AudioSource _backgroundMusic;\n    \n    [Header(\"Scene Management\")]\n    [SerializeField] private string _gameSceneName = \"GameScene\";\n    [SerializeField] private float _loadingDelay = 1f;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _panelTransitionSpeed = 0.3f;\n    [SerializeField] private AnimationCurve _transitionCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\n    \n    private Resolution[] _availableResolutions;\n    private bool _isTransitioning = false;\n    \n    private void Start()\n    {\n        InitializeMenu();\n        SetupButtonListeners();\n        LoadSettings();\n        SetupResolutions();\n    }\n    \n    private void InitializeMenu()\n    {\n        ShowPanel(_mainMenuPanel);\n        HidePanel(_settingsPanel);\n        HidePanel(_creditsPanel);\n        HidePanel(_loadingPanel);\n        \n        if (_backgroundMusic != null && !_backgroundMusic.isPlaying)\n        {\n            _backgroundMusic.Play();\n        }\n    }\n    \n    private void SetupButtonListeners()\n    {\n        if (_playButton != null)\n            _playButton.onClick.AddListener(OnPlayButtonClicked);\n        \n        if (_settingsButton != null)\n            _settingsButton.onClick.AddListener(OnSettingsButtonClicked);\n        \n        if (_creditsButton != null)\n            _creditsButton.onClick.AddListener(OnCreditsButtonClicked);\n        \n        if (_quitButton != null)\n            _quitButton.onClick.AddListener(OnQuitButtonClicked);\n        \n        if (_settingsBackButton != null)\n            _settingsBackButton.onClick.AddListener(OnSettingsBackButtonClicked);\n        \n        if (_creditsBackButton != null)\n            _creditsBackButton.onClick.AddListener(OnCreditsBackButtonClicked);\n        \n        if (_masterVolumeSlider != null)\n            _masterVolumeSlider.onValueChanged.AddListener(OnMasterVolumeChanged);\n        \n        if (_musicVolumeSlider != null)\n            _musicVolumeSlider.onValueChanged.AddListener(OnMusicVolumeChanged);\n        \n        if (_sfxVolumeSlider != null)\n            _sfxVolumeSlider.onValueChanged.AddListener(OnSFXVolumeChanged);\n        \n        if (_resolutionDropdown != null)\n            _resolutionDropdown.onValueChanged.AddListener(OnResolutionChanged);\n        \n        if (_fullscreenToggle != null)\n            _fullscreenToggle.onValueChanged.AddListener(OnFullscreenToggled);\n    }\n    \n    private void SetupResolutions()\n    {\n        if (_resolutionDropdown == null) return;\n        \n        _availableResolutions = Screen.resolutions;\n        _resolutionDropdown.ClearOptions();\n        \n        var options = new System.Collections.Generic.List<string>();\n        int currentResolutionIndex = 0;\n        \n        for (int i = 0; i < _availableResolutions.Length; i++)\n        {\n            string option = _availableResolutions[i].width + \" x \" + _availableResolutions[i].height;\n            options.Add(option);\n            \n            if (_availableResolutions[i].width == Screen.currentResolution.width &&\n                _availableResolutions[i].height == Screen.currentResolution.height)\n            {\n                currentResolutionIndex = i;\n            }\n        }\n        \n        _resolutionDropdown.AddOptions(options);\n        _resolutionDropdown.value = currentResolutionIndex;\n        _resolutionDropdown.RefreshShownValue();\n    }\n    \n    private void LoadSettings()\n    {\n        if (_masterVolumeSlider != null)\n        {\n            float masterVolume = PlayerPrefs.GetFloat(\"MasterVolume\", 0.75f);\n            _masterVolumeSlider.value = masterVolume;\n            OnMasterVolumeChanged(masterVolume);\n        }\n        \n        if (_musicVolumeSlider != null)\n        {\n            float musicVolume = PlayerPrefs.GetFloat(\"MusicVolume\", 0.75f);\n            _musicVolumeSlider.value = musicVolume;\n            OnMusicVolumeChanged(musicVolume);\n        }\n        \n        if (_sfxVolumeSlider != null)\n        {\n            float sfxVolume = PlayerPrefs.GetFloat(\"SFXVolume\", 0.75f);\n            _sfxVolumeSlider.value = sfxVolume;\n            OnSFXVolumeChanged(sfxVolume);\n        }\n        \n        if (_fullscreenToggle != null)\n        {\n            bool isFullscreen = PlayerPrefs.GetInt(\"Fullscreen\", 1) == 1;\n            _fullscreenToggle.isOn = isFullscreen;\n        }\n    }\n    \n    private void SaveSettings()\n    {\n        if (_masterVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MasterVolume\", _masterVolumeSlider.value);\n        \n        if (_musicVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"MusicVolume\", _musicVolumeSlider.value);\n        \n        if (_sfxVolumeSlider != null)\n            PlayerPrefs.SetFloat(\"SFXVolume\", _sfxVolumeSlider.value);\n        \n        if (_fullscreenToggle != null)\n            PlayerPrefs.SetInt(\"Fullscreen\", _fullscreenToggle.isOn ? 1 : 0);\n        \n        PlayerPrefs.Save();\n    }\n    \n    public void OnPlayButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(LoadGameScene());\n    }\n    \n    public void OnSettingsButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_settingsPanel));\n    }\n    \n    public void OnCreditsButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_creditsPanel));\n    }\n    \n    public void OnQuitButtonClicked()\n    {\n        PlayButtonSound();\n        \n        #if UNITY_EDITOR\n            UnityEditor.EditorApplication.isPlaying = false;\n        #else\n            Application.Quit();\n        #endif\n    }\n    \n    public void OnSettingsBackButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        SaveSettings();\n        StartCoroutine(TransitionToPanel(_mainMenuPanel));\n    }\n    \n    public void OnCreditsBackButtonClicked()\n    {\n        if (_isTransitioning) return;\n        \n        PlayButtonSound();\n        StartCoroutine(TransitionToPanel(_mainMenuPanel));\n    }\n    \n    public void OnMasterVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"MasterVolume\", dbValue);\n        }\n    }\n    \n    public void OnMusicVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"MusicVolume\", dbValue);\n        }\n    }\n    \n    public void OnSFXVolumeChanged(float value)\n    {\n        if (_audioMixer != null)\n        {\n            float dbValue = Mathf.Log10(Mathf.Clamp(value, 0.0001f, 1f)) * 20f;\n            _audioMixer.SetFloat(\"SFXVolume\", dbValue);\n        }\n    }\n    \n    public void OnResolutionChanged(int resolutionIndex)\n    {\n        if (_availableResolutions != null && resolutionIndex < _availableResolutions.Length)\n        {\n            Resolution resolution = _availableResolutions[resolutionIndex];\n            Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);\n        }\n    }\n    \n    public void OnFullscreenToggled(bool isFullscreen)\n    {\n        Screen.fullScreen = isFullscreen;\n    }\n    \n    private void PlayButtonSound()\n    {\n        if (_buttonClickSound != null)\n        {\n            _buttonClickSound.Play();\n        }\n    }\n    \n    private void ShowPanel(GameObject panel)\n    {\n        if (panel != null)\n        {\n            panel.SetActive(true);\n            var canvasGroup = panel.GetComponent<CanvasGroup>();\n            if (canvasGroup != null)\n            {\n                canvasGroup.alpha = 1f;\n                canvasGroup.interactable = true;\n                canvasGroup.blocksRaycasts = true;\n            }\n        }\n    }\n    \n    private void HidePanel(GameObject panel)\n    {\n        if (panel != null)\n        {\n            var canvasGroup = panel.GetComponent<CanvasGroup>();\n            if (canvasGroup != null)\n            {\n                canvasGroup.alpha = 0f;\n                canvasGroup.interactable = false;\n                canvasGroup.blocksRaycasts = false;\n            }\n            panel.SetActive(false);\n        }\n    }\n    \n    private IEnumerator TransitionToPanel(GameObject targetPanel)\n    {\n        _isTransitioning = true;\n        \n        GameObject currentPanel = GetCurrentActivePanel();\n        \n        if (currentPanel != null)\n        {\n            yield return StartCoroutine(FadeOutPanel(currentPanel));\n        }\n        \n        if (targetPanel != null)\n        {\n            yield return StartCoroutine(FadeInPanel(targetPanel));\n        }\n        \n        _isTransitioning = false;\n    }\n    \n    private GameObject GetCurrentActivePanel()\n    {\n        if (_mainMenuPanel != null && _mainMenuPanel.activeInHierarchy) return _mainMenuPanel;\n        if (_settingsPanel != null && _settingsPanel.activeInHierarchy) return _settingsPanel;\n        if (_creditsPanel != null && _creditsPanel.activeInHierarchy) return _creditsPanel;\n        return null;\n    }\n    \n    private IEnumerator FadeOutPanel(GameObject panel)\n    {\n        var canvasGroup = panel.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = panel.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.interactable = false;\n        \n        float elapsedTime = 0f;\n        float startAlpha = canvasGroup.alpha;\n        \n        while (elapsedTime < _panelTransitionSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _panelTransitionSpeed;\n            canvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, _transitionCurve.Evaluate(progress));\n            yield return null;\n        }\n        \n        canvasGroup.alpha = 0f;\n        canvasGroup.blocksRaycasts = false;\n        panel.SetActive(false);\n    }\n    \n    private IEnumerator FadeInPanel(GameObject panel)\n    {\n        panel.SetActive(true);\n        \n        var canvasGroup = panel.GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = panel.AddComponent<CanvasGroup>();\n        }\n        \n        canvasGroup.alpha = 0f;\n        canvasGroup.blocksRaycasts = true;\n        \n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _panelTransitionSpeed)\n        {\n            elapsedTime += Time.deltaTime;\n            float progress = elapsedTime / _panelTransitionSpeed;\n            canvasGroup.alpha = _transitionCurve.Evaluate(progress);\n            yield return null;\n        }\n        \n        canvasGroup.alpha = 1f;\n        canvasGroup.interactable = true;\n    }\n    \n    private IEnumerator LoadGameScene()\n    {\n        ShowPanel(_loadingPanel);\n        HidePanel(_mainMenuPanel);\n        \n        yield return new WaitForSeconds(_loadingDelay);\n        \n        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(_gameSceneName);\n        asyncLoad.allowSceneActivation = false;\n        \n        while (!asyncLoad.isDone)\n        {\n            float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f);\n            \n            if (_loadingProgressBar != null)\n            {\n                _loadingProgressBar.value = progress;\n            }\n            \n            if (_loadingText != null)\n            {\n                _loadingText.text = \"Loading... \" + Mathf.Round(progress * 100f) + \"%\";\n            }\n            \n            if (asyncLoad.progress >= 0.9f)\n            {\n                if (_loadingText != null)\n                {\n                    _loadingText.text = \"Press any key to continue...\";\n                }\n                \n                if (Input.anyKeyDown)\n                {\n                    asyncLoad.allowSceneActivation = true;\n                }\n            }\n            \n            yield return null;\n        }\n    }\n    \n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Escape))\n        {\n            HandleEscapeKey();\n        }\n    }\n    \n    private void HandleEscapeKey()\n    {\n        if (_isTransitioning) return;\n        \n        if (_settingsPanel != null && _settingsPanel.activeInHier"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BouncePad\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"launchForce\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"bounceSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"launch_player\",\n      \"trigger\": \"when player enters the bounce pad area\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward launch force to the player\"\n        },\n        {\n          \"action\": \"play bounce sound effect\"\n        },\n        {\n          \"action\": \"briefly animate the pad compressing and expanding\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class BouncePad : MonoBehaviour\n{\n    [Header(\"Bounce Settings\")]\n    [SerializeField] private float _bounceForce = 20f;\n    [SerializeField] private Vector3 _bounceDirection = Vector3.up;\n    [SerializeField] private bool _useLocalDirection = true;\n    [SerializeField] private bool _overrideVelocity = true;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _animationDuration = 0.3f;\n    [SerializeField] private float _compressionAmount = 0.2f;\n    [SerializeField] private AnimationCurve _animationCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _bounceSound;\n    [SerializeField] private float _volume = 1f;\n    \n    [Header(\"Effects\")]\n    [SerializeField] private ParticleSystem _bounceEffect;\n    [SerializeField] private GameObject _bounceEffectPrefab;\n    \n    [Header(\"Events\")]\n    public UnityEvent OnPlayerBounce;\n    \n    private Vector3 _originalScale;\n    private bool _isAnimating = false;\n    private AudioSource _audioSource;\n    \n    private void Start()\n    {\n        _originalScale = transform.localScale;\n        _audioSource = GetComponent<AudioSource>();\n        \n        if (_audioSource == null && _bounceSound != null)\n        {\n            _audioSource = gameObject.AddComponent<AudioSource>();\n            _audioSource.playOnAwake = false;\n        }\n        \n        _bounceDirection = _bounceDirection.normalized;\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\"))\n        {\n            LaunchPlayer(other);\n        }\n    }\n    \n    private void OnCollisionEnter(Collision collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            LaunchPlayer(collision.collider);\n        }\n    }\n    \n    private void LaunchPlayer(Collider player)\n    {\n        Rigidbody playerRigidbody = player.GetComponent<Rigidbody>();\n        \n        if (playerRigidbody == null)\n        {\n            playerRigidbody = player.GetComponentInParent<Rigidbody>();\n        }\n        \n        if (playerRigidbody != null)\n        {\n            Vector3 launchDirection = _useLocalDirection ? transform.TransformDirection(_bounceDirection) : _bounceDirection;\n            \n            if (_overrideVelocity)\n            {\n                playerRigidbody.velocity = Vector3.zero;\n            }\n            \n            playerRigidbody.AddForce(launchDirection * _bounceForce, ForceMode.VelocityChange);\n            \n            PlayBounceEffects();\n            OnPlayerBounce?.Invoke();\n        }\n    }\n    \n    private void PlayBounceEffects()\n    {\n        if (!_isAnimating)\n        {\n            StartCoroutine(PlayBounceAnimation());\n        }\n        \n        if (_audioSource != null && _bounceSound != null)\n        {\n            _audioSource.PlayOneShot(_bounceSound, _volume);\n        }\n        \n        if (_bounceEffect != null)\n        {\n            _bounceEffect.Play();\n        }\n        \n        if (_bounceEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_bounceEffectPrefab, transform.position, transform.rotation);\n            Destroy(effect, 5f);\n        }\n    }\n    \n    private System.Collections.IEnumerator PlayBounceAnimation()\n    {\n        _isAnimating = true;\n        float elapsedTime = 0f;\n        \n        while (elapsedTime < _animationDuration)\n        {\n            float normalizedTime = elapsedTime / _animationDuration;\n            float curveValue = _animationCurve.Evaluate(normalizedTime);\n            \n            float compressionScale = 1f - (_compressionAmount * curveValue);\n            Vector3 newScale = new Vector3(\n                _originalScale.x * (1f + (1f - compressionScale) * 0.5f),\n                _originalScale.y * compressionScale,\n                _originalScale.z * (1f + (1f - compressionScale) * 0.5f)\n            );\n            \n            transform.localScale = newScale;\n            \n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n        \n        transform.localScale = _originalScale;\n        _isAnimating = false;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Vector3 direction = _useLocalDirection ? transform.TransformDirection(_bounceDirection) : _bounceDirection;\n        Vector3 startPos = transform.position;\n        Vector3 endPos = startPos + direction * (_bounceForce * 0.1f);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawLine(startPos, endPos);\n        Gizmos.DrawSphere(endPos, 0.2f);\n        \n        Gizmos.color = Color.green;\n        Gizmos.matrix = transform.localToWorldMatrix;\n        Gizmos.DrawWireCube(Vector3.zero, Vector3.one);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PowerFlower\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"powerType\",\n      \"type\": \"string\",\n      \"default\": \"speed\"\n    },\n    {\n      \"name\": \"powerDuration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"powerMultiplier\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"respawnTime\",\n      \"type\": \"float\",\n      \"default\": 30.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"glow_effect\",\n      \"trigger\": \"when flower is active\",\n      \"actions\": [\n        {\n          \"action\": \"emit soft magical glow with pulsing animation\"\n        },\n        {\n          \"action\": \"create sparkle particles around flower petals\"\n        }\n      ]\n    },\n    {\n      \"name\": \"grant_power\",\n      \"trigger\": \"when player touches the flower\",\n      \"actions\": [\n        {\n          \"action\": \"give player the special power based on power type\"\n        },\n        {\n          \"action\": \"apply power multiplier to player abilities\"\n        },\n        {\n          \"action\": \"start power duration timer\"\n        },\n        {\n          \"action\": \"play magical chime sound effect\"\n        },\n        {\n          \"action\": \"create burst of golden particles\"\n        },\n        {\n          \"action\": \"make flower disappear temporarily\"\n        }\n      ]\n    },\n    {\n      \"name\": \"power_feedback\",\n      \"trigger\": \"when power is granted to player\",\n      \"actions\": [\n        {\n          \"action\": \"display power notification on screen\"\n        },\n        {\n          \"action\": \"add glowing aura effect to player\"\n        },\n        {\n          \"action\": \"change player movement trail color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respawn_flower\",\n      \"trigger\": \"when respawn time has elapsed after being picked\",\n      \"actions\": [\n        {\n          \"action\": \"make flower visible again\"\n        },\n        {\n          \"action\": \"reset flower to active state\"\n        },\n        {\n          \"action\": \"play gentle wind chime sound\"\n        },\n        {\n          \"action\": \"create swirling restoration particles\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class MagicalFlower : MonoBehaviour\n{\n    [Header(\"Flower Settings\")]\n    [SerializeField] private float _interactionRange = 2f;\n    [SerializeField] private float _powerDuration = 10f;\n    [SerializeField] private bool _singleUse = true;\n    [SerializeField] private float _respawnTime = 30f;\n    \n    [Header(\"Power Effects\")]\n    [SerializeField] private PowerType _powerType = PowerType.SpeedBoost;\n    [SerializeField] private float _powerMultiplier = 2f;\n    [SerializeField] private Color _powerColor = Color.magenta;\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private ParticleSystem _idleParticles;\n    [SerializeField] private ParticleSystem _collectParticles;\n    [SerializeField] private GameObject _flowerModel;\n    [SerializeField] private Light _magicalLight;\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _collectSound;\n    \n    [Header(\"Animation\")]\n    [SerializeField] private float _bobSpeed = 1f;\n    [SerializeField] private float _bobHeight = 0.2f;\n    [SerializeField] private float _rotationSpeed = 30f;\n    \n    [Header(\"Events\")]\n    public UnityEvent<PowerType, float, float> OnPowerGranted;\n    public UnityEvent OnFlowerCollected;\n    public UnityEvent OnFlowerRespawned;\n    \n    private bool _isAvailable = true;\n    private Vector3 _originalPosition;\n    private Transform _currentPlayer;\n    private Coroutine _respawnCoroutine;\n    \n    public enum PowerType\n    {\n        SpeedBoost,\n        JumpBoost,\n        StrengthBoost,\n        Invisibility,\n        Shield,\n        DoubleJump,\n        SlowMotion\n    }\n    \n    private void Start()\n    {\n        _originalPosition = transform.position;\n        \n        if (_magicalLight != null)\n        {\n            _magicalLight.color = _powerColor;\n        }\n        \n        if (_idleParticles != null)\n        {\n            var main = _idleParticles.main;\n            main.startColor = _powerColor;\n        }\n        \n        if (_collectParticles != null)\n        {\n            var main = _collectParticles.main;\n            main.startColor = _powerColor;\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isAvailable) return;\n        \n        AnimateFlower();\n        CheckForPlayer();\n    }\n    \n    private void AnimateFlower()\n    {\n        float bobOffset = Mathf.Sin(Time.time * _bobSpeed) * _bobHeight;\n        transform.position = _originalPosition + Vector3.up * bobOffset;\n        \n        transform.Rotate(Vector3.up, _rotationSpeed * Time.deltaTime);\n    }\n    \n    private void CheckForPlayer()\n    {\n        Collider[] colliders = Physics.OverlapSphere(transform.position, _interactionRange);\n        \n        foreach (Collider col in colliders)\n        {\n            if (col.CompareTag(\"Player\"))\n            {\n                GrantPower(col.gameObject);\n                break;\n            }\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!_isAvailable) return;\n        \n        if (other.CompareTag(\"Player\"))\n        {\n            GrantPower(other.gameObject);\n        }\n    }\n    \n    private void GrantPower(GameObject player)\n    {\n        if (!_isAvailable) return;\n        \n        _currentPlayer = player.transform;\n        \n        ApplyPowerToPlayer(player);\n        \n        OnPowerGranted?.Invoke(_powerType, _powerMultiplier, _powerDuration);\n        OnFlowerCollected?.Invoke();\n        \n        PlayCollectEffects();\n        \n        _isAvailable = false;\n        \n        if (_singleUse && _respawnTime <= 0)\n        {\n            gameObject.SetActive(false);\n        }\n        else\n        {\n            HideFlower();\n            if (_respawnCoroutine != null)\n                StopCoroutine(_respawnCoroutine);\n            _respawnCoroutine = StartCoroutine(RespawnCoroutine());\n        }\n    }\n    \n    private void ApplyPowerToPlayer(GameObject player)\n    {\n        PowerEffect powerEffect = player.GetComponent<PowerEffect>();\n        if (powerEffect == null)\n        {\n            powerEffect = player.AddComponent<PowerEffect>();\n        }\n        \n        powerEffect.ApplyPower(_powerType, _powerMultiplier, _powerDuration, _powerColor);\n    }\n    \n    private void PlayCollectEffects()\n    {\n        if (_collectParticles != null)\n        {\n            _collectParticles.Play();\n        }\n        \n        if (_audioSource != null && _collectSound != null)\n        {\n            _audioSource.PlayOneShot(_collectSound);\n        }\n        \n        if (_magicalLight != null)\n        {\n            StartCoroutine(FlashLight());\n        }\n    }\n    \n    private System.Collections.IEnumerator FlashLight()\n    {\n        float originalIntensity = _magicalLight.intensity;\n        \n        for (int i = 0; i < 3; i++)\n        {\n            _magicalLight.intensity = originalIntensity * 3f;\n            yield return new WaitForSeconds(0.1f);\n            _magicalLight.intensity = originalIntensity;\n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n    \n    private void HideFlower()\n    {\n        if (_flowerModel != null)\n            _flowerModel.SetActive(false);\n        \n        if (_idleParticles != null)\n            _idleParticles.Stop();\n        \n        if (_magicalLight != null)\n            _magicalLight.enabled = false;\n    }\n    \n    private void ShowFlower()\n    {\n        if (_flowerModel != null)\n            _flowerModel.SetActive(true);\n        \n        if (_idleParticles != null)\n            _idleParticles.Play();\n        \n        if (_magicalLight != null)\n            _magicalLight.enabled = true;\n    }\n    \n    private System.Collections.IEnumerator RespawnCoroutine()\n    {\n        yield return new WaitForSeconds(_respawnTime);\n        \n        _isAvailable = true;\n        ShowFlower();\n        OnFlowerRespawned?.Invoke();\n        \n        _respawnCoroutine = null;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, _interactionRange);\n    }\n}\n\npublic class PowerEffect : MonoBehaviour\n{\n    private MagicalFlower.PowerType _currentPowerType;\n    private float _powerMultiplier;\n    private float _remainingTime;\n    private Color _powerColor;\n    private bool _hasPower;\n    \n    private CharacterController _characterController;\n    private Rigidbody _rigidbody;\n    private Renderer _renderer;\n    private Material _originalMaterial;\n    private Material _powerMaterial;\n    \n    private float _originalSpeed;\n    private bool _canDoubleJump;\n    private bool _hasDoubleJumped;\n    \n    private void Start()\n    {\n        _characterController = GetComponent<CharacterController>();\n        _rigidbody = GetComponent<Rigidbody>();\n        _renderer = GetComponentInChildren<Renderer>();\n        \n        if (_renderer != null)\n        {\n            _originalMaterial = _renderer.material;\n        }\n    }\n    \n    private void Update()\n    {\n        if (_hasPower)\n        {\n            _remainingTime -= Time.deltaTime;\n            \n            if (_remainingTime <= 0)\n            {\n                RemovePower();\n            }\n            else\n            {\n                UpdatePowerEffects();\n            }\n        }\n    }\n    \n    public void ApplyPower(MagicalFlower.PowerType powerType, float multiplier, float duration, Color color)\n    {\n        if (_hasPower)\n        {\n            RemovePower();\n        }\n        \n        _currentPowerType = powerType;\n        _powerMultiplier = multiplier;\n        _remainingTime = duration;\n        _powerColor = color;\n        _hasPower = true;\n        \n        ApplyVisualEffects();\n        ApplyPowerSpecificEffects();\n    }\n    \n    private void ApplyVisualEffects()\n    {\n        if (_renderer != null && _originalMaterial != null)\n        {\n            _powerMaterial = new Material(_originalMaterial);\n            _powerMaterial.color = _powerColor;\n            _powerMaterial.SetFloat(\"_Metallic\", 0.8f);\n            _powerMaterial.EnableKeyword(\"_EMISSION\");\n            _powerMaterial.SetColor(\"_EmissionColor\", _powerColor * 0.5f);\n            _renderer.material = _powerMaterial;\n        }\n    }\n    \n    private void ApplyPowerSpecificEffects()\n    {\n        switch (_currentPowerType)\n        {\n            case MagicalFlower.PowerType.SpeedBoost:\n                if (_characterController != null)\n                {\n                    // Speed boost would be handled by movement script\n                }\n                break;\n                \n            case MagicalFlower.PowerType.DoubleJump:\n                _canDoubleJump = true;\n                _hasDoubleJumped = false;\n                break;\n                \n            case MagicalFlower.PowerType.Invisibility:\n                if (_renderer != null)\n                {\n                    Color invisColor = _renderer.material.color;\n                    invisColor.a = 0.3f;\n                    _renderer.material.color = invisColor;\n                }\n                break;\n                \n            case MagicalFlower.PowerType.SlowMotion:\n                Time.timeScale = 0.5f;\n                break;\n        }\n    }\n    \n    private void UpdatePowerEffects()\n    {\n        if (_renderer != null && _powerMaterial != null)\n        {\n            float pulse = Mathf.Sin(Time.time * 5f) * 0.3f + 0.7f;\n            _powerMaterial.SetColor(\"_EmissionColor\", _powerColor * pulse);\n        }\n    }\n    \n    private void RemovePower()\n    {\n        _hasPower = false;\n        \n        if (_renderer != null && _originalMaterial != null)\n        {\n            _renderer.material = _originalMaterial;\n        }\n        \n        if (_powerMaterial != null)\n        {\n            DestroyImmediate(_powerMaterial);\n        }\n        \n        switch (_currentPowerType)\n        {\n            case MagicalFlower.PowerType.DoubleJump:\n                _canDoubleJump = false;\n                break;\n                \n            case MagicalFlower.PowerType.SlowMotion:\n                Time.timeScale = 1f;\n                break;\n        }\n    }\n    \n    public bool HasPower()\n    {\n        return _hasPower;\n    }\n    \n    public MagicalFlower.PowerType GetCurrentPowerType()\n    {\n        return _currentPowerType;\n    }\n    \n    public float GetPowerMultiplier()\n    {\n        return _powerMultiplier;\n    }\n    \n    public float GetRemainingTime()\n    {\n        return _remainingTime;\n    }\n    \n    private void OnDestroy()\n    {\n        if (_currentPowerType == MagicalFlower.PowerType.SlowMotion)\n        {\n            Time.timeScale = 1f;\n        }\n        \n        if (_powerMaterial != null)\n        {\n            DestroyImmediate(_powerMaterial);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldingEnemy\",\n  \"components\": [\n    \"Transform\",\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"shieldRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"shieldStrength\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"shieldCooldown\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"isShielding\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"shieldEffect\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_nearby_allies\",\n      \"trigger\": \"continuously check for allies within shield radius\",\n      \"actions\": [\n        {\n          \"action\": \"scan area around self for friendly units\"\n        },\n        {\n          \"action\": \"identify allies that need protection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_shield\",\n      \"trigger\": \"when allies are detected within range and shield is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"set shielding state to active\"\n        },\n        {\n          \"action\": \"spawn visual shield effect around self\"\n        },\n        {\n          \"action\": \"apply damage reduction to all allies in radius\"\n        },\n        {\n          \"action\": \"play shield activation sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"maintain_shield\",\n      \"trigger\": \"while shielding is active and allies remain in range\",\n      \"actions\": [\n        {\n          \"action\": \"continuously reduce incoming damage to protected allies\"\n        },\n        {\n          \"action\": \"update shield visual effects\"\n        },\n        {\n          \"action\": \"drain energy or resources if applicable\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_shield\",\n      \"trigger\": \"when no allies remain in range or shield duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"set shielding state to inactive\"\n        },\n        {\n          \"action\": \"remove shield visual effects\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"remove damage reduction from allies\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_feedback\",\n      \"trigger\": \"when shield absorbs damage\",\n      \"actions\": [\n        {\n          \"action\": \"create impact visual effect on shield\"\n        },\n        {\n          \"action\": \"play shield hit sound\"\n        },\n        {\n          \"action\": \"briefly intensify shield glow\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ShieldingEnemy : MonoBehaviour\n{\n    [Header(\"Shield Settings\")]\n    [SerializeField] private float _shieldRadius = 5f;\n    [SerializeField] private float _shieldStrength = 0.5f;\n    [SerializeField] private LayerMask _allyLayerMask = -1;\n    [SerializeField] private string _allyTag = \"Enemy\";\n    \n    [Header(\"Visual Effects\")]\n    [SerializeField] private GameObject _shieldEffectPrefab;\n    [SerializeField] private LineRenderer _shieldBeamPrefab;\n    [SerializeField] private Color _shieldColor = Color.cyan;\n    [SerializeField] private bool _showShieldRadius = true;\n    \n    [Header(\"Performance\")]\n    [SerializeField] private float _updateInterval = 0.1f;\n    \n    private List<ShieldedAlly> _shieldedAllies = new List<ShieldedAlly>();\n    private List<GameObject> _activeShieldEffects = new List<GameObject>();\n    private List<LineRenderer> _activeBeams = new List<LineRenderer>();\n    private float _lastUpdateTime;\n    private SphereCollider _detectionCollider;\n    \n    [System.Serializable]\n    private class ShieldedAlly\n    {\n        public GameObject ally;\n        public float originalDamageMultiplier;\n        public AllyDamageReceiver damageReceiver;\n        \n        public ShieldedAlly(GameObject allyObject, AllyDamageReceiver receiver)\n        {\n            ally = allyObject;\n            damageReceiver = receiver;\n            originalDamageMultiplier = receiver.damageMultiplier;\n        }\n    }\n    \n    private class AllyDamageReceiver : MonoBehaviour\n    {\n        public float damageMultiplier = 1f;\n        public bool isShielded = false;\n        \n        public void TakeDamage(float damage)\n        {\n            float finalDamage = damage * damageMultiplier;\n            \n            if (TryGetComponent<Rigidbody>(out Rigidbody rb))\n            {\n                rb.AddForce(Vector3.up * finalDamage, ForceMode.Impulse);\n            }\n            \n            if (finalDamage >= 100f)\n            {\n                gameObject.SetActive(false);\n            }\n        }\n    }\n    \n    void Start()\n    {\n        SetupDetectionCollider();\n        _lastUpdateTime = Time.time;\n    }\n    \n    void Update()\n    {\n        if (Time.time - _lastUpdateTime >= _updateInterval)\n        {\n            UpdateShieldedAllies();\n            _lastUpdateTime = Time.time;\n        }\n    }\n    \n    void SetupDetectionCollider()\n    {\n        _detectionCollider = gameObject.GetComponent<SphereCollider>();\n        if (_detectionCollider == null)\n        {\n            _detectionCollider = gameObject.AddComponent<SphereCollider>();\n        }\n        \n        _detectionCollider.isTrigger = true;\n        _detectionCollider.radius = _shieldRadius;\n    }\n    \n    void UpdateShieldedAllies()\n    {\n        RemoveInvalidAllies();\n        FindNewAllies();\n        UpdateVisualEffects();\n    }\n    \n    void RemoveInvalidAllies()\n    {\n        for (int i = _shieldedAllies.Count - 1; i >= 0; i--)\n        {\n            var shieldedAlly = _shieldedAllies[i];\n            \n            if (shieldedAlly.ally == null || !shieldedAlly.ally.activeInHierarchy)\n            {\n                RemoveShieldFromAlly(shieldedAlly);\n                _shieldedAllies.RemoveAt(i);\n                continue;\n            }\n            \n            float distance = Vector3.Distance(transform.position, shieldedAlly.ally.transform.position);\n            if (distance > _shieldRadius)\n            {\n                RemoveShieldFromAlly(shieldedAlly);\n                _shieldedAllies.RemoveAt(i);\n            }\n        }\n    }\n    \n    void FindNewAllies()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, _shieldRadius, _allyLayerMask);\n        \n        foreach (var collider in nearbyColliders)\n        {\n            if (collider.gameObject == gameObject) continue;\n            \n            if (!string.IsNullOrEmpty(_allyTag) && !collider.CompareTag(_allyTag)) continue;\n            \n            if (!IsAllyAlreadyShielded(collider.gameObject))\n            {\n                AddShieldToAlly(collider.gameObject);\n            }\n        }\n    }\n    \n    bool IsAllyAlreadyShielded(GameObject ally)\n    {\n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            if (shieldedAlly.ally == ally)\n                return true;\n        }\n        return false;\n    }\n    \n    void AddShieldToAlly(GameObject ally)\n    {\n        AllyDamageReceiver damageReceiver = ally.GetComponent<AllyDamageReceiver>();\n        if (damageReceiver == null)\n        {\n            damageReceiver = ally.AddComponent<AllyDamageReceiver>();\n        }\n        \n        ShieldedAlly shieldedAlly = new ShieldedAlly(ally, damageReceiver);\n        damageReceiver.damageMultiplier = _shieldStrength;\n        damageReceiver.isShielded = true;\n        \n        _shieldedAllies.Add(shieldedAlly);\n    }\n    \n    void RemoveShieldFromAlly(ShieldedAlly shieldedAlly)\n    {\n        if (shieldedAlly.damageReceiver != null)\n        {\n            shieldedAlly.damageReceiver.damageMultiplier = shieldedAlly.originalDamageMultiplier;\n            shieldedAlly.damageReceiver.isShielded = false;\n        }\n    }\n    \n    void UpdateVisualEffects()\n    {\n        ClearVisualEffects();\n        \n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            if (shieldedAlly.ally != null)\n            {\n                CreateShieldEffect(shieldedAlly.ally);\n                CreateShieldBeam(shieldedAlly.ally);\n            }\n        }\n    }\n    \n    void CreateShieldEffect(GameObject ally)\n    {\n        if (_shieldEffectPrefab != null)\n        {\n            GameObject effect = Instantiate(_shieldEffectPrefab, ally.transform.position, Quaternion.identity);\n            effect.transform.SetParent(ally.transform);\n            _activeShieldEffects.Add(effect);\n            \n            if (effect.TryGetComponent<Renderer>(out Renderer renderer))\n            {\n                renderer.material.color = _shieldColor;\n            }\n        }\n    }\n    \n    void CreateShieldBeam(GameObject ally)\n    {\n        LineRenderer beam;\n        \n        if (_shieldBeamPrefab != null)\n        {\n            beam = Instantiate(_shieldBeamPrefab, transform.position, Quaternion.identity);\n        }\n        else\n        {\n            GameObject beamObject = new GameObject(\"ShieldBeam\");\n            beam = beamObject.AddComponent<LineRenderer>();\n            beam.material = new Material(Shader.Find(\"Sprites/Default\"));\n            beam.color = _shieldColor;\n            beam.startWidth = 0.1f;\n            beam.endWidth = 0.05f;\n        }\n        \n        beam.positionCount = 2;\n        beam.SetPosition(0, transform.position);\n        beam.SetPosition(1, ally.transform.position);\n        \n        _activeBeams.Add(beam);\n    }\n    \n    void ClearVisualEffects()\n    {\n        foreach (var effect in _activeShieldEffects)\n        {\n            if (effect != null)\n                DestroyImmediate(effect);\n        }\n        _activeShieldEffects.Clear();\n        \n        foreach (var beam in _activeBeams)\n        {\n            if (beam != null)\n                DestroyImmediate(beam.gameObject);\n        }\n        _activeBeams.Clear();\n    }\n    \n    void OnTriggerEnter(Collider other)\n    {\n        if (other.gameObject == gameObject) return;\n        \n        if (!string.IsNullOrEmpty(_allyTag) && !other.CompareTag(_allyTag)) return;\n        \n        if (!IsAllyAlreadyShielded(other.gameObject))\n        {\n            AddShieldToAlly(other.gameObject);\n        }\n    }\n    \n    void OnTriggerExit(Collider other)\n    {\n        for (int i = _shieldedAllies.Count - 1; i >= 0; i--)\n        {\n            if (_shieldedAllies[i].ally == other.gameObject)\n            {\n                RemoveShieldFromAlly(_shieldedAllies[i]);\n                _shieldedAllies.RemoveAt(i);\n                break;\n            }\n        }\n    }\n    \n    void OnDestroy()\n    {\n        foreach (var shieldedAlly in _shieldedAllies)\n        {\n            RemoveShieldFromAlly(shieldedAlly);\n        }\n        \n        ClearVisualEffects();\n    }\n    \n    void OnDrawGizmosSelected()\n    {\n        if (_showShieldRadius)\n        {\n            Gizmos.color = _shieldColor;\n            Gizmos.DrawWireSphere(transform.position, _shieldRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ConveyorBelt\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"beltSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"beltDirection\",\n      \"type\": \"Vector3\",\n      \"default\": \"Vector3.forward\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"move_objects_on_belt\",\n      \"trigger\": \"when object is touching the conveyor belt surface\",\n      \"actions\": [\n        {\n          \"action\": \"apply force to the object in the belt direction at belt speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"continuous_belt_movement\",\n      \"trigger\": \"every frame while belt is active\",\n      \"actions\": [\n        {\n          \"action\": \"move belt surface texture in the direction of movement to create visual motion effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ConveyorBelt : MonoBehaviour\n{\n    [Header(\"Conveyor Settings\")]\n    [SerializeField] private float _speed = 2f;\n    [SerializeField] private Vector3 _direction = Vector3.forward;\n    [SerializeField] private bool _isActive = true;\n    \n    [Header(\"Visual Settings\")]\n    [SerializeField] private Material _beltMaterial;\n    [SerializeField] private float _textureScrollSpeed = 1f;\n    [SerializeField] private string _texturePropertyName = \"_MainTex\";\n    \n    [Header(\"Physics Settings\")]\n    [SerializeField] private LayerMask _affectedLayers = -1;\n    [SerializeField] private bool _useRigidbodyForce = true;\n    [SerializeField] private ForceMode _forceMode = ForceMode.Force;\n    \n    [Header(\"Audio\")]\n    [SerializeField] private AudioSource _audioSource;\n    [SerializeField] private AudioClip _conveyorSound;\n    [SerializeField] private float _audioVolume = 0.5f;\n    \n    private List<Rigidbody> _objectsOnBelt = new List<Rigidbody>();\n    private List<Transform> _kinematicObjects = new List<Transform>();\n    private Renderer _beltRenderer;\n    private Vector2 _textureOffset;\n    private Vector3 _normalizedDirection;\n    \n    private void Start()\n    {\n        _normalizedDirection = _direction.normalized;\n        _beltRenderer = GetComponent<Renderer>();\n        \n        SetupAudio();\n        \n        if (_beltRenderer != null && _beltMaterial != null)\n        {\n            _beltRenderer.material = _beltMaterial;\n        }\n    }\n    \n    private void SetupAudio()\n    {\n        if (_audioSource == null)\n        {\n            _audioSource = GetComponent<AudioSource>();\n        }\n        \n        if (_audioSource != null && _conveyorSound != null)\n        {\n            _audioSource.clip = _conveyorSound;\n            _audioSource.loop = true;\n            _audioSource.volume = _audioVolume;\n            \n            if (_isActive)\n            {\n                _audioSource.Play();\n            }\n        }\n    }\n    \n    private void Update()\n    {\n        if (!_isActive) return;\n        \n        UpdateTextureAnimation();\n        UpdateAudio();\n    }\n    \n    private void FixedUpdate()\n    {\n        if (!_isActive) return;\n        \n        MoveObjectsOnBelt();\n    }\n    \n    private void UpdateTextureAnimation()\n    {\n        if (_beltRenderer != null && _beltRenderer.material != null)\n        {\n            _textureOffset.x += _speed * _textureScrollSpeed * Time.deltaTime;\n            _beltRenderer.material.SetTextureOffset(_texturePropertyName, _textureOffset);\n        }\n    }\n    \n    private void UpdateAudio()\n    {\n        if (_audioSource != null)\n        {\n            if (_isActive && !_audioSource.isPlaying && _conveyorSound != null)\n            {\n                _audioSource.Play();\n            }\n            else if (!_isActive && _audioSource.isPlaying)\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    private void MoveObjectsOnBelt()\n    {\n        Vector3 movement = _normalizedDirection * _speed;\n        \n        // Move rigidbody objects\n        for (int i = _objectsOnBelt.Count - 1; i >= 0; i--)\n        {\n            if (_objectsOnBelt[i] == null)\n            {\n                _objectsOnBelt.RemoveAt(i);\n                continue;\n            }\n            \n            Rigidbody rb = _objectsOnBelt[i];\n            \n            if (_useRigidbodyForce)\n            {\n                rb.AddForce(movement, _forceMode);\n            }\n            else\n            {\n                rb.velocity = new Vector3(movement.x, rb.velocity.y, movement.z);\n            }\n        }\n        \n        // Move kinematic objects\n        for (int i = _kinematicObjects.Count - 1; i >= 0; i--)\n        {\n            if (_kinematicObjects[i] == null)\n            {\n                _kinematicObjects.RemoveAt(i);\n                continue;\n            }\n            \n            Transform obj = _kinematicObjects[i];\n            obj.Translate(movement * Time.fixedDeltaTime, Space.World);\n        }\n    }\n    \n    private void OnTriggerEnter(Collider other)\n    {\n        if (!IsInAffectedLayer(other.gameObject)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            if (rb.isKinematic)\n            {\n                if (!_kinematicObjects.Contains(other.transform))\n                {\n                    _kinematicObjects.Add(other.transform);\n                }\n            }\n            else\n            {\n                if (!_objectsOnBelt.Contains(rb))\n                {\n                    _objectsOnBelt.Add(rb);\n                }\n            }\n        }\n        else\n        {\n            // Objects without rigidbody are moved as transforms\n            if (!_kinematicObjects.Contains(other.transform))\n            {\n                _kinematicObjects.Add(other.transform);\n            }\n        }\n    }\n    \n    private void OnTriggerExit(Collider other)\n    {\n        if (!IsInAffectedLayer(other.gameObject)) return;\n        \n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            _objectsOnBelt.Remove(rb);\n        }\n        \n        _kinematicObjects.Remove(other.transform);\n    }\n    \n    private bool IsInAffectedLayer(GameObject obj)\n    {\n        return (_affectedLayers.value & (1 << obj.layer)) != 0;\n    }\n    \n    public void SetActive(bool active)\n    {\n        _isActive = active;\n        \n        if (_audioSource != null)\n        {\n            if (_isActive && _conveyorSound != null)\n            {\n                _audioSource.Play();\n            }\n            else\n            {\n                _audioSource.Stop();\n            }\n        }\n    }\n    \n    public void SetSpeed(float newSpeed)\n    {\n        _speed = newSpeed;\n    }\n    \n    public void SetDirection(Vector3 newDirection)\n    {\n        _direction = newDirection;\n        _normalizedDirection = _direction.normalized;\n    }\n    \n    public void ReverseDirection()\n    {\n        _direction = -_direction;\n        _normalizedDirection = _direction.normalized;\n    }\n    \n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Vector3 center = transform.position;\n        Vector3 direction = _direction.normalized;\n        \n        // Draw direction arrow\n        Gizmos.DrawRay(center, direction * 2f);\n        Gizmos.DrawWireCube(center + direction * 1.8f, Vector3.one * 0.2f);\n        \n        // Draw conveyor bounds\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.matrix = transform.localToWorldMatrix;\n            \n            if (col is BoxCollider boxCol)\n            {\n                Gizmos.DrawWireCube(boxCol.center, boxCol.size);\n            }\n            else if (col is CapsuleCollider capsuleCol)\n            {\n                Gizmos.DrawWireCube(capsuleCol.center, new Vector3(capsuleCol.radius * 2, capsuleCol.height, capsuleCol.radius * 2));\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SequenceMemoryGame\",\n  \"components\": [\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"gameButtons\",\n      \"type\": \"GameObject[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"buttonColors\",\n      \"type\": \"Color[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"gameSequence\",\n      \"type\": \"int[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"playerSequence\",\n      \"type\": \"int[]\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentSequenceIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"playerInputIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"sequenceLength\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"maxSequenceLength\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"displaySpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"buttonHighlightDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isShowingSequence\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"isWaitingForInput\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"gameScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"gameState\",\n      \"type\": \"string\",\n      \"default\": \"menu\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_new_game\",\n      \"trigger\": \"when start button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"reset game score to zero\"\n        },\n        {\n          \"action\": \"set sequence length to one\"\n        },\n        {\n          \"action\": \"clear game sequence array\"\n        },\n        {\n          \"action\": \"generate new random button for sequence\"\n        },\n        {\n          \"action\": \"change game state to playing\"\n        },\n        {\n          \"action\": \"begin showing sequence to player\"\n        }\n      ]\n    },\n    {\n      \"name\": \"show_sequence\",\n      \"trigger\": \"when beginning to show sequence\",\n      \"actions\": [\n        {\n          \"action\": \"set showing sequence flag to true\"\n        },\n        {\n          \"action\": \"disable player input\"\n        },\n        {\n          \"action\": \"reset sequence display index to zero\"\n        },\n        {\n          \"action\": \"start highlighting buttons in sequence order\"\n        }\n      ]\n    },\n    {\n      \"name\": \"highlight_sequence_button\",\n      \"trigger\": \"when displaying next button in sequence\",\n      \"actions\": [\n        {\n          \"action\": \"change button color to bright highlight color\"\n        },\n        {\n          \"action\": \"play button sound effect\"\n        },\n        {\n          \"action\": \"wait for highlight duration\"\n        },\n        {\n          \"action\": \"return button to normal color\"\n        },\n        {\n          \"action\": \"move to next button in sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"finish_sequence_display\",\n      \"trigger\": \"when all sequence buttons have been shown\",\n      \"actions\": [\n        {\n          \"action\": \"set showing sequence flag to false\"\n        },\n        {\n          \"action\": \"enable player input\"\n        },\n        {\n          \"action\": \"set waiting for input flag to true\"\n        },\n        {\n          \"action\": \"reset player input index to zero\"\n        },\n        {\n          \"action\": \"clear player sequence array\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_button_press\",\n      \"trigger\": \"when player clicks a game button\",\n      \"actions\": [\n        {\n          \"action\": \"add clicked button to player sequence\"\n        },\n        {\n          \"action\": \"highlight clicked button briefly\"\n        },\n        {\n          \"action\": \"play button press sound\"\n        },\n        {\n          \"action\": \"check if input matches sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"validate_correct_input\",\n      \"trigger\": \"when player input matches sequence so far\",\n      \"actions\": [\n        {\n          \"action\": \"increment player input index\"\n        },\n        {\n          \"action\": \"check if complete sequence entered correctly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_sequence_success\",\n      \"trigger\": \"when player completes sequence correctly\",\n      \"actions\": [\n        {\n          \"action\": \"increase game score\"\n        },\n        {\n          \"action\": \"play success sound effect\"\n        },\n        {\n          \"action\": \"increment sequence length\"\n        },\n        {\n          \"action\": \"add new random button to sequence\"\n        },\n        {\n          \"action\": \"check if maximum length reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"advance_to_next_round\",\n      \"trigger\": \"when ready for next sequence round\",\n      \"actions\": [\n        {\n          \"action\": \"set waiting for input flag to false\"\n        },\n        {\n          \"action\": \"wait brief pause between rounds\"\n        },\n        {\n          \"action\": \"begin showing new sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_wrong_input\",\n      \"trigger\": \"when player input does not match sequence\",\n      \"actions\": [\n        {\n          \"action\": \"play error sound effect\"\n        },\n        {\n          \"action\": \"flash all buttons red briefly\"\n        },\n        {\n          \"action\": \"change game state to game over\"\n        },\n        {\n          \"action\": \"display final score\"\n        },\n        {\n          \"action\": \"show restart option\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_game_completion\",\n      \"trigger\": \"when maximum sequence length is reached\",\n      \"actions\": [\n        {\n          \"action\": \"play victory sound effect\"\n        },\n        {\n          \"action\": \"flash all buttons in celebration pattern\"\n        },\n        {\n          \"action\": \"change game state to victory\"\n        },\n        {\n          \"action\": \"display congratulations message\"\n        },\n        {\n          \"action\": \"show final score and restart option\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_game\",\n      \"trigger\": \"when restart button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"return all buttons to normal colors\"\n        },\n        {\n          \"action\": \"clear all sequence arrays\"\n        },\n        {\n          \"action\": \"reset all game variables to defaults\"\n        },\n        {\n          \"action\": \"change game state back to menu\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.Events;\n\npublic class SequenceMemoryGame : MonoBehaviour\n{\n    [System.Serializable]\n    public class GameButton\n    {\n        public Button button;\n        public Color normalColor = Color.white;\n        public Color highlightColor = Color.yellow;\n        public AudioClip soundClip;\n        [HideInInspector] public Image buttonImage;\n        [HideInInspector] public AudioSource audioSource;\n    }\n\n    [Header(\"Game Setup\")]\n    [SerializeField] private GameButton[] _gameButtons;\n    [SerializeField] private float _sequenceDisplayTime = 1f;\n    [SerializeField] private float _buttonHighlightDuration = 0.5f;\n    [SerializeField] private float _timeBetweenButtons = 0.3f;\n    [SerializeField] private int _startingSequenceLength = 3;\n    [SerializeField] private int _maxSequenceLength = 10;\n\n    [Header(\"UI Elements\")]\n    [SerializeField] private Button _startButton;\n    [SerializeField] private Button _resetButton;\n    [SerializeField] private Text _scoreText;\n    [SerializeField] private Text _levelText;\n    [SerializeField] private Text _statusText;\n    [SerializeField] private GameObject _gameOverPanel;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip _successSound;\n    [SerializeField] private AudioClip _failSound;\n    [SerializeField] private AudioSource _mainAudioSource;\n\n    [Header(\"Events\")]\n    public UnityEvent OnGameStart;\n    public UnityEvent OnGameOver;\n    public UnityEvent OnLevelComplete;\n    public UnityEvent<int> OnScoreChanged;\n\n    private List<int> _currentSequence = new List<int>();\n    private List<int> _playerInput = new List<int>();\n    private int _currentLevel = 1;\n    private int _score = 0;\n    private bool _isShowingSequence = false;\n    private bool _isWaitingForInput = false;\n    private bool _gameActive = false;\n    private Coroutine _sequenceCoroutine;\n\n    private void Start()\n    {\n        InitializeGame();\n    }\n\n    private void InitializeGame()\n    {\n        // Initialize button components\n        for (int i = 0; i < _gameButtons.Length; i++)\n        {\n            if (_gameButtons[i].button != null)\n            {\n                _gameButtons[i].buttonImage = _gameButtons[i].button.GetComponent<Image>();\n                _gameButtons[i].audioSource = _gameButtons[i].button.GetComponent<AudioSource>();\n                \n                if (_gameButtons[i].audioSource == null)\n                {\n                    _gameButtons[i].audioSource = _gameButtons[i].button.gameObject.AddComponent<AudioSource>();\n                }\n\n                int buttonIndex = i;\n                _gameButtons[i].button.onClick.AddListener(() => OnButtonPressed(buttonIndex));\n                \n                if (_gameButtons[i].buttonImage != null)\n                {\n                    _gameButtons[i].buttonImage.color = _gameButtons[i].normalColor;\n                }\n            }\n        }\n\n        // Setup UI buttons\n        if (_startButton != null)\n            _startButton.onClick.AddListener(StartGame);\n        \n        if (_resetButton != null)\n            _resetButton.onClick.AddListener(ResetGame);\n\n        // Initialize UI\n        UpdateUI();\n        SetGameButtonsInteractable(false);\n        \n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n    }\n\n    public void StartGame()\n    {\n        _gameActive = true;\n        _currentLevel = 1;\n        _score = 0;\n        _currentSequence.Clear();\n        _playerInput.Clear();\n\n        if (_startButton != null)\n            _startButton.interactable = false;\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n\n        UpdateUI();\n        OnGameStart?.Invoke();\n        \n        StartNewLevel();\n    }\n\n    public void ResetGame()\n    {\n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n            _sequenceCoroutine = null;\n        }\n\n        _gameActive = false;\n        _isShowingSequence = false;\n        _isWaitingForInput = false;\n        _currentLevel = 1;\n        _score = 0;\n        _currentSequence.Clear();\n        _playerInput.Clear();\n\n        if (_startButton != null)\n            _startButton.interactable = true;\n\n        SetGameButtonsInteractable(false);\n        ResetButtonColors();\n        UpdateUI();\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(false);\n    }\n\n    private void StartNewLevel()\n    {\n        if (!_gameActive) return;\n\n        _playerInput.Clear();\n        GenerateSequence();\n        \n        if (_statusText != null)\n            _statusText.text = \"Watch the sequence...\";\n\n        _sequenceCoroutine = StartCoroutine(ShowSequence());\n    }\n\n    private void GenerateSequence()\n    {\n        int sequenceLength = Mathf.Min(_startingSequenceLength + _currentLevel - 1, _maxSequenceLength);\n        \n        if (_currentLevel == 1)\n        {\n            _currentSequence.Clear();\n        }\n        else\n        {\n            // Add one more button to existing sequence\n        }\n\n        while (_currentSequence.Count < sequenceLength)\n        {\n            int randomButton = Random.Range(0, _gameButtons.Length);\n            _currentSequence.Add(randomButton);\n        }\n    }\n\n    private IEnumerator ShowSequence()\n    {\n        _isShowingSequence = true;\n        SetGameButtonsInteractable(false);\n        \n        yield return new WaitForSeconds(_sequenceDisplayTime);\n\n        for (int i = 0; i < _currentSequence.Count; i++)\n        {\n            int buttonIndex = _currentSequence[i];\n            yield return StartCoroutine(HighlightButton(buttonIndex));\n            yield return new WaitForSeconds(_timeBetweenButtons);\n        }\n\n        _isShowingSequence = false;\n        _isWaitingForInput = true;\n        SetGameButtonsInteractable(true);\n        \n        if (_statusText != null)\n            _statusText.text = \"Repeat the sequence!\";\n    }\n\n    private IEnumerator HighlightButton(int buttonIndex)\n    {\n        if (buttonIndex < 0 || buttonIndex >= _gameButtons.Length) yield break;\n\n        GameButton gameButton = _gameButtons[buttonIndex];\n        \n        // Highlight button\n        if (gameButton.buttonImage != null)\n        {\n            gameButton.buttonImage.color = gameButton.highlightColor;\n        }\n\n        // Play sound\n        if (gameButton.audioSource != null && gameButton.soundClip != null)\n        {\n            gameButton.audioSource.PlayOneShot(gameButton.soundClip);\n        }\n\n        yield return new WaitForSeconds(_buttonHighlightDuration);\n\n        // Return to normal color\n        if (gameButton.buttonImage != null)\n        {\n            gameButton.buttonImage.color = gameButton.normalColor;\n        }\n    }\n\n    private void OnButtonPressed(int buttonIndex)\n    {\n        if (!_isWaitingForInput || !_gameActive) return;\n\n        _playerInput.Add(buttonIndex);\n        StartCoroutine(HighlightButton(buttonIndex));\n\n        // Check if input matches sequence so far\n        bool isCorrect = true;\n        for (int i = 0; i < _playerInput.Count; i++)\n        {\n            if (_playerInput[i] != _currentSequence[i])\n            {\n                isCorrect = false;\n                break;\n            }\n        }\n\n        if (!isCorrect)\n        {\n            GameOver();\n            return;\n        }\n\n        // Check if sequence is complete\n        if (_playerInput.Count == _currentSequence.Count)\n        {\n            LevelComplete();\n        }\n    }\n\n    private void LevelComplete()\n    {\n        _isWaitingForInput = false;\n        SetGameButtonsInteractable(false);\n        \n        _score += _currentLevel * 10;\n        _currentLevel++;\n        \n        OnScoreChanged?.Invoke(_score);\n        OnLevelComplete?.Invoke();\n\n        if (_mainAudioSource != null && _successSound != null)\n        {\n            _mainAudioSource.PlayOneShot(_successSound);\n        }\n\n        if (_statusText != null)\n            _statusText.text = \"Correct! Next level...\";\n\n        UpdateUI();\n        \n        Invoke(nameof(StartNewLevel), 2f);\n    }\n\n    private void GameOver()\n    {\n        _gameActive = false;\n        _isWaitingForInput = false;\n        SetGameButtonsInteractable(false);\n        \n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n            _sequenceCoroutine = null;\n        }\n\n        if (_mainAudioSource != null && _failSound != null)\n        {\n            _mainAudioSource.PlayOneShot(_failSound);\n        }\n\n        if (_statusText != null)\n            _statusText.text = \"Game Over!\";\n\n        if (_startButton != null)\n            _startButton.interactable = true;\n\n        if (_gameOverPanel != null)\n            _gameOverPanel.SetActive(true);\n\n        OnGameOver?.Invoke();\n    }\n\n    private void SetGameButtonsInteractable(bool interactable)\n    {\n        foreach (GameButton gameButton in _gameButtons)\n        {\n            if (gameButton.button != null)\n            {\n                gameButton.button.interactable = interactable;\n            }\n        }\n    }\n\n    private void ResetButtonColors()\n    {\n        foreach (GameButton gameButton in _gameButtons)\n        {\n            if (gameButton.buttonImage != null)\n            {\n                gameButton.buttonImage.color = gameButton.normalColor;\n            }\n        }\n    }\n\n    private void UpdateUI()\n    {\n        if (_scoreText != null)\n            _scoreText.text = \"Score: \" + _score;\n\n        if (_levelText != null)\n            _levelText.text = \"Level: \" + _currentLevel;\n\n        if (_statusText != null && !_gameActive)\n            _statusText.text = \"Press Start to begin!\";\n    }\n\n    private void OnDestroy()\n    {\n        if (_sequenceCoroutine != null)\n        {\n            StopCoroutine(_sequenceCoroutine);\n        }\n    }\n}"}]}
