{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"KeyDoorInteraction\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"keyID\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"isCollected\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"collect_key\",\n      \"trigger\": \"when player touches key in game world\",\n      \"actions\": [\n        {\n          \"action\": \"mark key as collected\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"remove key from visible game scene\"\n        }\n      ]\n    },\n    {\n      \"name\": \"unlock_door\",\n      \"trigger\": \"when player approaches matching door with collected key\",\n      \"actions\": [\n        {\n          \"action\": \"check if key matches door's lock\"\n        },\n        {\n          \"action\": \"open door if key is correct\"\n        },\n        {\n          \"action\": \"play unlocking sound effect\"\n        },\n        {\n          \"action\": \"disable door's collision\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class KeyDoorInteraction : MonoBehaviour\n{\n    [SerializeField] private string keyId;\n    [SerializeField] private GameObject correspondingDoor;\n    [SerializeField] private AudioClip unlockSound;\n\n    private bool isUnlocked = false;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if player has collided with key\n        PlayerInventory playerInventory = other.GetComponent<PlayerInventory>();\n        \n        if (playerInventory != null && !isUnlocked)\n        {\n            // Check if player has matching key\n            if (playerInventory.HasKey(keyId))\n            {\n                UnlockDoor(playerInventory);\n            }\n        }\n    }\n\n    private void UnlockDoor(PlayerInventory playerInventory)\n    {\n        // Verify references are valid\n        if (correspondingDoor == null)\n        {\n            Debug.LogWarning(\"No corresponding door assigned to key\");\n            return;\n        }\n\n        // Remove key from inventory\n        playerInventory.RemoveKey(keyId);\n\n        // Unlock and open door\n        correspondingDoor.GetComponent<Animator>()?.SetTrigger(\"Unlock\");\n        \n        // Play unlock sound if available\n        if (unlockSound != null)\n        {\n            AudioSource.PlayClipAtPoint(unlockSound, transform.position);\n        }\n\n        // Mark as unlocked to prevent repeated interactions\n        isUnlocked = true;\n        gameObject.SetActive(false);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerMovement\",\n  \"components\": [\n    \"CharacterController\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"wallJumpForce\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"wallSlideSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"wallDetectionDistance\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isNearWall\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"wall_slide\",\n      \"trigger\": \"player is touching a wall and falling downward\",\n      \"actions\": [\n        {\n          \"action\": \"reduce vertical falling speed\"\n        },\n        {\n          \"action\": \"play wall sliding animation\"\n        },\n        {\n          \"action\": \"set wall contact state to true\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wall_jump\",\n      \"trigger\": \"player presses jump button while sliding on wall\",\n      \"actions\": [\n        {\n          \"action\": \"launch player away from wall surface\"\n        },\n        {\n          \"action\": \"apply upward momentum\"\n        },\n        {\n          \"action\": \"reset wall contact state\"\n        },\n        {\n          \"action\": \"play wall jump animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class WallJumpController : MonoBehaviour\n{\n    [Header(\"Wall Detection\")]\n    [SerializeField] private LayerMask wallLayer;\n    [SerializeField] private float wallCheckDistance = 0.5f;\n\n    [Header(\"Wall Slide Settings\")]\n    [SerializeField] private float wallSlideSpeed = 2f;\n    [SerializeField] private float wallSlideGravityReduction = 0.5f;\n\n    [Header(\"Wall Jump Settings\")]\n    [SerializeField] private float wallJumpForce = 12f;\n    [SerializeField] private Vector2 wallJumpAngle = new Vector2(1f, 2f);\n\n    private Rigidbody2D rb;\n    private bool isWallSliding;\n    private bool isTouchingWall;\n    private int wallDirection;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n    }\n\n    void Update()\n    {\n        CheckWallContact();\n        HandleWallSlide();\n        HandleWallJump();\n    }\n\n    void CheckWallContact()\n    {\n        RaycastHit2D hitRight = Physics2D.Raycast(transform.position, Vector2.right, wallCheckDistance, wallLayer);\n        RaycastHit2D hitLeft = Physics2D.Raycast(transform.position, Vector2.left, wallCheckDistance, wallLayer);\n\n        isTouchingWall = hitRight || hitLeft;\n        wallDirection = hitRight ? 1 : hitLeft ? -1 : 0;\n    }\n\n    void HandleWallSlide()\n    {\n        if (isTouchingWall && rb.velocity.y < 0)\n        {\n            isWallSliding = true;\n            rb.velocity = new Vector2(rb.velocity.x, -wallSlideSpeed);\n            rb.gravityScale = wallSlideGravityReduction;\n        }\n        else\n        {\n            isWallSliding = false;\n            rb.gravityScale = 1f;\n        }\n    }\n\n    void HandleWallJump()\n    {\n        if (isWallSliding && Input.GetButtonDown(\"Jump\"))\n        {\n            Vector2 jumpDirection = new Vector2(wallJumpAngle.x * -wallDirection, wallJumpAngle.y);\n            rb.velocity = jumpDirection * wallJumpForce;\n        }\n    }\n\n    void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawRay(transform.position, Vector2.right * wallCheckDistance);\n        Gizmos.DrawRay(transform.position, Vector2.left * wallCheckDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MountableHorse\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"mountHeight\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"isMounted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"mountSpeed\",\n      \"type\": \"float\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"mountRange\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_proximity\",\n      \"trigger\": \"when player approaches within mount range\",\n      \"actions\": [\n        {\n          \"action\": \"show mounting prompt\"\n        },\n        {\n          \"action\": \"highlight horse with interaction indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"mount_horse\",\n      \"trigger\": \"when player presses mount interaction button\",\n      \"actions\": [\n        {\n          \"action\": \"attach player to horse's back\"\n        },\n        {\n          \"action\": \"change camera to horse riding perspective\"\n        },\n        {\n          \"action\": \"enable horse movement controls\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dismount_horse\",\n      \"trigger\": \"when player presses dismount button\",\n      \"actions\": [\n        {\n          \"action\": \"detach player from horse\"\n        },\n        {\n          \"action\": \"reset camera to player perspective\"\n        },\n        {\n          \"action\": \"place player next to horse\"\n        }\n      ]\n    },\n    {\n      \"name\": \"horse_movement\",\n      \"trigger\": \"while horse is mounted\",\n      \"actions\": [\n        {\n          \"action\": \"move horse in direction of player input\"\n        },\n        {\n          \"action\": \"play walking or galloping animation\"\n        },\n        {\n          \"action\": \"generate horse movement sound effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HorseMountController : MonoBehaviour\n{\n    [SerializeField] private float mountRange = 2f;\n    [SerializeField] private Transform playerMountPoint;\n    [SerializeField] private float moveSpeed = 5f;\n    [SerializeField] private float turnSpeed = 180f;\n\n    private bool isBeingRidden = false;\n    private GameObject currentRider;\n    private Rigidbody horseRigidbody;\n\n    private void Start()\n    {\n        horseRigidbody = GetComponent<Rigidbody>();\n        \n        if (playerMountPoint == null)\n        {\n            playerMountPoint = transform;\n        }\n    }\n\n    private void Update()\n    {\n        if (isBeingRidden)\n        {\n            HandleRiderMovement();\n        }\n        else\n        {\n            CheckForMounting();\n        }\n    }\n\n    private void CheckForMounting()\n    {\n        Collider[] nearbyColliders = Physics.OverlapSphere(transform.position, mountRange);\n        \n        foreach (Collider col in nearbyColliders)\n        {\n            PlayerController player = col.GetComponent<PlayerController>();\n            \n            if (player != null && Input.GetKeyDown(KeyCode.E))\n            {\n                MountHorse(player.gameObject);\n                break;\n            }\n        }\n    }\n\n    private void HandleRiderMovement()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = Input.GetAxis(\"Vertical\");\n\n        Vector3 movement = transform.forward * verticalInput * moveSpeed * Time.deltaTime;\n        horseRigidbody.MovePosition(horseRigidbody.position + movement);\n\n        transform.Rotate(Vector3.up * horizontalInput * turnSpeed * Time.deltaTime);\n\n        if (Input.GetKeyDown(KeyCode.X))\n        {\n            DismountHorse();\n        }\n    }\n\n    private void MountHorse(GameObject player)\n    {\n        if (player == null) return;\n\n        currentRider = player;\n        isBeingRidden = true;\n\n        PlayerController playerController = player.GetComponent<PlayerController>();\n        if (playerController != null)\n        {\n            playerController.enabled = false;\n            player.transform.SetParent(playerMountPoint);\n            player.transform.localPosition = Vector3.zero;\n        }\n    }\n\n    private void DismountHorse()\n    {\n        if (currentRider == null) return;\n\n        PlayerController playerController = currentRider.GetComponent<PlayerController>();\n        if (playerController != null)\n        {\n            playerController.enabled = true;\n            currentRider.transform.SetParent(null);\n            currentRider.transform.position = transform.position + transform.forward * 2f;\n        }\n\n        currentRider = null;\n        isBeingRidden = false;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, mountRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TurretController\",\n  \"components\": [\n    \"Rotator\",\n    \"Shooter\",\n    \"PlayerDetector\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_player\",\n      \"trigger\": \"when player is within detection range\",\n      \"actions\": [\n        {\n          \"action\": \"slowly rotate turret barrel toward player's current position\"\n        },\n        {\n          \"action\": \"align turret's forward direction with player's location\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attack_player\",\n      \"trigger\": \"when player is directly in turret's line of sight\",\n      \"actions\": [\n        {\n          \"action\": \"fire projectile at player\"\n        },\n        {\n          \"action\": \"pause between shots based on fire rate\"\n        },\n        {\n          \"action\": \"create muzzle flash visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_behavior\",\n      \"trigger\": \"when no player is detected\",\n      \"actions\": [\n        {\n          \"action\": \"slowly scan surrounding area\"\n        },\n        {\n          \"action\": \"return to default neutral rotation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class TurretController : MonoBehaviour\n{\n    [SerializeField] private float rotationSpeed = 5f;\n    [SerializeField] private float detectionRadius = 10f;\n    [SerializeField] private float fireRate = 1f;\n    [SerializeField] private GameObject projectilePrefab;\n    [SerializeField] private Transform firePoint;\n\n    private Transform playerTransform;\n    private float nextFireTime;\n\n    private void Start()\n    {\n        // Find the player in the scene\n        playerTransform = GameObject.FindGameObjectWithTag(\"Player\").transform;\n    }\n\n    private void Update()\n    {\n        if (playerTransform == null) return;\n\n        // Calculate direction to player\n        Vector3 directionToPlayer = playerTransform.position - transform.position;\n        float distanceToPlayer = directionToPlayer.magnitude;\n\n        // Check if player is within detection radius\n        if (distanceToPlayer <= detectionRadius)\n        {\n            // Rotate turret towards player\n            Quaternion targetRotation = Quaternion.LookRotation(directionToPlayer);\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);\n\n            // Check if can fire\n            if (Time.time >= nextFireTime)\n            {\n                Shoot();\n                nextFireTime = Time.time + 1f / fireRate;\n            }\n        }\n    }\n\n    private void Shoot()\n    {\n        if (projectilePrefab == null || firePoint == null) return;\n\n        // Instantiate projectile at fire point\n        Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize detection radius in scene view\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, detectionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DamageFlashEffect\",\n  \"components\": [\n    \"Renderer\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"flashColor\",\n      \"type\": \"color\",\n      \"default\": \"bright red\"\n    },\n    {\n      \"name\": \"flashDuration\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"originalColor\",\n      \"type\": \"color\",\n      \"default\": \"white\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_flash\",\n      \"trigger\": \"when object receives damage\",\n      \"actions\": [\n        {\n          \"action\": \"change sprite color to flash color\"\n        },\n        {\n          \"action\": \"wait for flash duration\"\n        },\n        {\n          \"action\": \"restore sprite to original color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class DamageFlashEffect : MonoBehaviour\n{\n    [SerializeField] private Renderer targetRenderer;\n    [SerializeField] private Color flashColor = Color.white;\n    [SerializeField] private float flashDuration = 0.2f;\n    [SerializeField] private int flashCount = 2;\n\n    private Material originalMaterial;\n    private Color originalColor;\n    private bool isFlashing = false;\n\n    private void Start()\n    {\n        // Cache original material and color\n        if (targetRenderer == null)\n            targetRenderer = GetComponent<Renderer>();\n\n        if (targetRenderer != null)\n        {\n            originalMaterial = targetRenderer.material;\n            originalColor = originalMaterial.color;\n        }\n    }\n\n    public void TriggerDamageFlash()\n    {\n        if (!isFlashing && targetRenderer != null)\n        {\n            StartCoroutine(FlashEffect());\n        }\n    }\n\n    private System.Collections.IEnumerator FlashEffect()\n    {\n        isFlashing = true;\n\n        for (int i = 0; i < flashCount; i++)\n        {\n            // Flash on\n            targetRenderer.material.color = flashColor;\n            yield return new WaitForSeconds(flashDuration / 2f);\n\n            // Flash off\n            targetRenderer.material.color = originalColor;\n            yield return new WaitForSeconds(flashDuration / 2f);\n        }\n\n        // Restore original material\n        targetRenderer.material = originalMaterial;\n        isFlashing = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SavePoint\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"checkpointID\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"activationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"checkpoint_activation\",\n      \"trigger\": \"when player enters save point trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"mark this checkpoint as the current progress point\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"show visual indicator that checkpoint is activated\"\n        },\n        {\n          \"action\": \"store player's current health, inventory, and position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respawn_on_death\",\n      \"trigger\": \"when player dies or fails current challenge\",\n      \"actions\": [\n        {\n          \"action\": \"restore player to last activated checkpoint\"\n        },\n        {\n          \"action\": \"reset player's health to checkpoint state\"\n        },\n        {\n          \"action\": \"reload player's inventory from checkpoint\"\n        },\n        {\n          \"action\": \"reposition player at checkpoint location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System;\n\npublic class CheckpointSavePoint : MonoBehaviour\n{\n    [SerializeField] private bool hasBeenActivated = false;\n    [SerializeField] private Color activeColor = Color.green;\n    [SerializeField] private Color inactiveColor = Color.red;\n\n    public static event Action<Vector3> OnCheckpointReached;\n\n    private SpriteRenderer spriteRenderer;\n\n    private void Awake()\n    {\n        spriteRenderer = GetComponent<SpriteRenderer>();\n        UpdateVisualState();\n    }\n\n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (!hasBeenActivated && other.CompareTag(\"Player\"))\n        {\n            ActivateCheckpoint(other.transform.position);\n        }\n    }\n\n    private void ActivateCheckpoint(Vector3 playerPosition)\n    {\n        hasBeenActivated = true;\n        UpdateVisualState();\n\n        // Invoke event for game progress saving\n        OnCheckpointReached?.Invoke(playerPosition);\n    }\n\n    private void UpdateVisualState()\n    {\n        if (spriteRenderer != null)\n        {\n            spriteRenderer.color = hasBeenActivated ? activeColor : inactiveColor;\n        }\n    }\n\n    public bool IsCheckpointActivated()\n    {\n        return hasBeenActivated;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BossFightController\",\n  \"components\": [\n    \"Health\",\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentPhase\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"phaseThresholds\",\n      \"type\": \"float[]\",\n      \"default\": [\n        0.75,\n        0.5,\n        0.25\n      ]\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"phase_transition\",\n      \"trigger\": \"boss health drops below current phase health threshold\",\n      \"actions\": [\n        {\n          \"action\": \"increase current phase number\"\n        },\n        {\n          \"action\": \"change boss attack pattern\"\n        },\n        {\n          \"action\": \"play dramatic phase change animation\"\n        },\n        {\n          \"action\": \"trigger phase change sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"first_phase_attacks\",\n      \"trigger\": \"current phase is first phase\",\n      \"actions\": [\n        {\n          \"action\": \"perform basic melee attacks\"\n        },\n        {\n          \"action\": \"move in predictable patterns\"\n        },\n        {\n          \"action\": \"summon small minion enemies occasionally\"\n        }\n      ]\n    },\n    {\n      \"name\": \"second_phase_attacks\",\n      \"trigger\": \"current phase is second phase\",\n      \"actions\": [\n        {\n          \"action\": \"use ranged magical attacks\"\n        },\n        {\n          \"action\": \"move more erratically\"\n        },\n        {\n          \"action\": \"create protective energy shields\"\n        },\n        {\n          \"action\": \"spawn additional enemy types\"\n        }\n      ]\n    },\n    {\n      \"name\": \"final_phase_attacks\",\n      \"trigger\": \"current phase is final phase\",\n      \"actions\": [\n        {\n          \"action\": \"unleash most powerful and unpredictable attacks\"\n        },\n        {\n          \"action\": \"move extremely quickly\"\n        },\n        {\n          \"action\": \"ignore player's defensive maneuvers\"\n        },\n        {\n          \"action\": \"continuously spawn challenging enemy reinforcements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"boss_defeat\",\n      \"trigger\": \"boss health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play dramatic death animation\"\n        },\n        {\n          \"action\": \"trigger boss defeat sound effect\"\n        },\n        {\n          \"action\": \"spawn victory rewards\"\n        },\n        {\n          \"action\": \"unlock next game progression stage\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class BossController : MonoBehaviour\n{\n    [Header(\"Boss Health\")]\n    [SerializeField] private float maxHealth = 500f;\n    [SerializeField] private float currentHealth;\n\n    [Header(\"Attack Phases\")]\n    [SerializeField] private float[] phaseHealthThresholds = { 0.75f, 0.5f, 0.25f };\n    private int currentPhase = 0;\n\n    [Header(\"Attack Settings\")]\n    [SerializeField] private GameObject[] attackPrefabs;\n    [SerializeField] private Transform attackSpawnPoint;\n    [SerializeField] private float attackCooldown = 3f;\n    private bool canAttack = true;\n\n    [Header(\"Movement\")]\n    [SerializeField] private float moveSpeed = 2f;\n    [SerializeField] private Vector3[] movementPoints;\n\n    private Animator bossAnimator;\n    private bool isInvulnerable = false;\n\n    private void Start()\n    {\n        currentHealth = maxHealth;\n        bossAnimator = GetComponent<Animator>();\n        StartCoroutine(AttackRoutine());\n    }\n\n    private void Update()\n    {\n        HandlePhaseTransition();\n    }\n\n    private void HandlePhaseTransition()\n    {\n        float healthPercentage = currentHealth / maxHealth;\n\n        for (int i = currentPhase; i < phaseHealthThresholds.Length; i++)\n        {\n            if (healthPercentage <= phaseHealthThresholds[i])\n            {\n                TransitionToPhase(i + 1);\n                break;\n            }\n        }\n    }\n\n    private void TransitionToPhase(int newPhase)\n    {\n        if (newPhase > currentPhase)\n        {\n            currentPhase = newPhase;\n            bossAnimator.SetTrigger(\"PhaseChange\");\n            isInvulnerable = true;\n            StartCoroutine(PhaseTransitionCooldown());\n        }\n    }\n\n    private IEnumerator PhaseTransitionCooldown()\n    {\n        yield return new WaitForSeconds(2f);\n        isInvulnerable = false;\n    }\n\n    private IEnumerator AttackRoutine()\n    {\n        while (true)\n        {\n            if (canAttack)\n            {\n                PerformPhaseSpecificAttack();\n                yield return new WaitForSeconds(attackCooldown);\n            }\n            yield return null;\n        }\n    }\n\n    private void PerformPhaseSpecificAttack()\n    {\n        if (attackPrefabs.Length > currentPhase)\n        {\n            Instantiate(attackPrefabs[currentPhase], attackSpawnPoint.position, Quaternion.identity);\n            bossAnimator.SetTrigger(\"Attack\");\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (!isInvulnerable)\n        {\n            currentHealth -= damage;\n            bossAnimator.SetTrigger(\"Hit\");\n\n            if (currentHealth <= 0)\n            {\n                Die();\n            }\n        }\n    }\n\n    private void Die()\n    {\n        bossAnimator.SetTrigger(\"Death\");\n        canAttack = false;\n        // Additional death logic\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemyController\",\n  \"components\": [\n    \"Health\",\n    \"Animator\",\n    \"NavMeshAgent\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.5\n    },\n    {\n      \"name\": \"meleeAttackRange\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"rangedAttackRange\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"projectileDamage\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"meleeDamage\",\n      \"type\": \"float\",\n      \"default\": 25.0\n    },\n    {\n      \"name\": \"attackCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"patrol_behavior\",\n      \"trigger\": \"when no player is nearby\",\n      \"actions\": [\n        {\n          \"action\": \"wander randomly in current area\"\n        },\n        {\n          \"action\": \"move at walking speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"chase_player\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"move toward player\"\n        },\n        {\n          \"action\": \"track player's current position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ranged_attack\",\n      \"trigger\": \"when player is within ranged attack distance\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"aim at player\"\n        },\n        {\n          \"action\": \"fire projectile\"\n        },\n        {\n          \"action\": \"start attack cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"melee_attack\",\n      \"trigger\": \"when player is within melee attack range\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"perform melee attack animation\"\n        },\n        {\n          \"action\": \"deal damage to player\"\n        },\n        {\n          \"action\": \"start attack cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when receiving damage from player\",\n      \"actions\": [\n        {\n          \"action\": \"reduce health points\"\n        },\n        {\n          \"action\": \"play hurt animation\"\n        },\n        {\n          \"action\": \"become temporarily stunned\"\n        }\n      ]\n    },\n    {\n      \"name\": \"death_behavior\",\n      \"trigger\": \"when health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"play death animation\"\n        },\n        {\n          \"action\": \"drop possible loot\"\n        },\n        {\n          \"action\": \"disable enemy game object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class EnemyController : MonoBehaviour\n{\n    [Header(\"Attack Settings\")]\n    [SerializeField] private float meleeRange = 2f;\n    [SerializeField] private float rangedRange = 10f;\n    [SerializeField] private float meleeDamage = 10f;\n    [SerializeField] private float rangedDamage = 5f;\n    [SerializeField] private float attackCooldown = 1.5f;\n\n    [Header(\"Projectile Settings\")]\n    [SerializeField] private GameObject projectilePrefab;\n    [SerializeField] private Transform projectileSpawnPoint;\n\n    [Header(\"References\")]\n    [SerializeField] private Transform player;\n    [SerializeField] private Animator animator;\n\n    private float currentCooldown = 0f;\n    private bool canAttack = true;\n\n    private void Update()\n    {\n        if (player == null) return;\n\n        float distanceToPlayer = Vector3.Distance(transform.position, player.position);\n        \n        // Cooldown management\n        if (!canAttack)\n        {\n            currentCooldown -= Time.deltaTime;\n            if (currentCooldown <= 0)\n            {\n                canAttack = true;\n            }\n        }\n\n        // Attack logic\n        if (canAttack)\n        {\n            if (distanceToPlayer <= meleeRange)\n            {\n                PerformMeleeAttack();\n            }\n            else if (distanceToPlayer <= rangedRange)\n            {\n                PerformRangedAttack();\n            }\n        }\n    }\n\n    private void PerformMeleeAttack()\n    {\n        animator.SetTrigger(\"MeleeAttack\");\n        // Apply damage to player\n        player.GetComponent<PlayerHealth>()?.TakeDamage(meleeDamage);\n        ResetCooldown();\n    }\n\n    private void PerformRangedAttack()\n    {\n        animator.SetTrigger(\"RangedAttack\");\n        \n        if (projectilePrefab != null && projectileSpawnPoint != null)\n        {\n            GameObject projectile = Instantiate(projectilePrefab, projectileSpawnPoint.position, Quaternion.identity);\n            Projectile projectileScript = projectile.GetComponent<Projectile>();\n            \n            if (projectileScript != null)\n            {\n                projectileScript.Initialize(player.position, rangedDamage);\n            }\n        }\n\n        ResetCooldown();\n    }\n\n    private void ResetCooldown()\n    {\n        canAttack = false;\n        currentCooldown = attackCooldown;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize attack ranges in scene view\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, meleeRange);\n        \n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, rangedRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SawBladeHazard\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 180\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"rotationAxis\",\n      \"type\": \"string\",\n      \"default\": \"forward\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_rotation\",\n      \"trigger\": \"every physics update\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around specified axis at constant speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_damage\",\n      \"trigger\": \"when player collides with saw blade\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to player's health\"\n        },\n        {\n          \"action\": \"apply knockback force away from saw blade\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_warning\",\n      \"trigger\": \"when player approaches detection range\",\n      \"actions\": [\n        {\n          \"action\": \"increase rotation speed slightly\"\n        },\n        {\n          \"action\": \"emit warning particle effects\"\n        },\n        {\n          \"action\": \"play warning sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SawBladeHazard : MonoBehaviour\n{\n    [SerializeField] private float rotationSpeed = 180f;\n    [SerializeField] private float damageAmount = 25f;\n    [SerializeField] private float damageInterval = 0.5f;\n\n    [Header(\"Optional Visual Effects\")]\n    [SerializeField] private ParticleSystem bloodSplatterEffect;\n\n    private float lastDamageTime;\n\n    private void Update()\n    {\n        // Rotate saw blade continuously\n        transform.Rotate(Vector3.forward, rotationSpeed * Time.deltaTime);\n    }\n\n    private void OnTriggerStay2D(Collider2D other)\n    {\n        // Check if colliding object is a player\n        PlayerHealth playerHealth = other.GetComponent<PlayerHealth>();\n        if (playerHealth != null)\n        {\n            // Apply damage at specified interval\n            if (Time.time - lastDamageTime >= damageInterval)\n            {\n                playerHealth.TakeDamage(damageAmount);\n                lastDamageTime = Time.time;\n\n                // Optional blood splatter effect\n                if (bloodSplatterEffect != null)\n                {\n                    bloodSplatterEffect.transform.position = other.transform.position;\n                    bloodSplatterEffect.Play();\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Teleporter\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"destinationPoint\",\n      \"type\": \"Vector3\",\n      \"default\": null\n    },\n    {\n      \"name\": \"teleportSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"cooldownDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_entry\",\n      \"trigger\": \"when player enters teleporter trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"play teleport sound effect\"\n        },\n        {\n          \"action\": \"instantly move player to destination point\"\n        },\n        {\n          \"action\": \"start teleporter cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_rapid_teleports\",\n      \"trigger\": \"when teleporter cooldown is active\",\n      \"actions\": [\n        {\n          \"action\": \"block additional teleportation attempts\"\n        },\n        {\n          \"action\": \"show visual cooldown indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_teleporter_availability\",\n      \"trigger\": \"when cooldown duration has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"enable teleporter for next use\"\n        },\n        {\n          \"action\": \"hide cooldown indicator\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Teleporter : MonoBehaviour\n{\n    [SerializeField] private Transform destinationPoint;\n    [SerializeField] private float teleportCooldown = 1f;\n    [SerializeField] private bool requireTrigger = true;\n\n    private float lastTeleportTime;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!requireTrigger || CanTeleport(other.gameObject))\n        {\n            TeleportObject(other.gameObject);\n        }\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (!requireTrigger && CanTeleport(collision.gameObject))\n        {\n            TeleportObject(collision.gameObject);\n        }\n    }\n\n    private bool CanTeleport(GameObject obj)\n    {\n        // Check if object is player or teleportable\n        if (obj.CompareTag(\"Player\") && \n            Time.time >= lastTeleportTime + teleportCooldown)\n        {\n            return true;\n        }\n        return false;\n    }\n\n    private void TeleportObject(GameObject obj)\n    {\n        if (destinationPoint == null)\n        {\n            Debug.LogWarning(\"Teleporter destination not set!\");\n            return;\n        }\n\n        // Preserve object's velocity/momentum\n        Rigidbody rb = obj.GetComponent<Rigidbody>();\n        Vector3 originalVelocity = rb ? rb.velocity : Vector3.zero;\n\n        // Teleport object\n        obj.transform.position = destinationPoint.position;\n\n        // Reapply velocity if needed\n        if (rb)\n        {\n            rb.velocity = originalVelocity;\n        }\n\n        lastTeleportTime = Time.time;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ConveyorBelt\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"movementDirection\",\n      \"type\": \"string\",\n      \"default\": \"forward\"\n    },\n    {\n      \"name\": \"transportZone\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"transport_objects\",\n      \"trigger\": \"when object enters conveyor belt surface\",\n      \"actions\": [\n        {\n          \"action\": \"attach object to conveyor belt movement\"\n        },\n        {\n          \"action\": \"move object smoothly along conveyor path at consistent speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_objects\",\n      \"trigger\": \"when object reaches end of conveyor belt zone\",\n      \"actions\": [\n        {\n          \"action\": \"detach object from conveyor movement\"\n        },\n        {\n          \"action\": \"allow object to continue its independent physics behavior\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_direction\",\n      \"trigger\": \"when operator adjusts conveyor belt settings\",\n      \"actions\": [\n        {\n          \"action\": \"update movement direction based on new configuration\"\n        },\n        {\n          \"action\": \"smoothly transition objects to new movement path\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ConveyorBelt : MonoBehaviour\n{\n    [SerializeField] private float beltSpeed = 2f;\n    [SerializeField] private Vector3 movementDirection = Vector3.forward;\n    [SerializeField] private bool isActive = true;\n\n    [Header(\"Object Detection\")]\n    [SerializeField] private float detectionRadius = 1f;\n    [SerializeField] private LayerMask movableObjectLayer;\n\n    private void FixedUpdate()\n    {\n        if (!isActive) return;\n\n        MoveObjectsOnBelt();\n    }\n\n    private void MoveObjectsOnBelt()\n    {\n        Collider[] objectsOnBelt = Physics.OverlapSphere(transform.position, detectionRadius, movableObjectLayer);\n\n        foreach (Collider objectCollider in objectsOnBelt)\n        {\n            Rigidbody rb = objectCollider.GetComponent<Rigidbody>();\n            \n            if (rb != null)\n            {\n                rb.MovePosition(rb.position + movementDirection * beltSpeed * Time.fixedDeltaTime);\n            }\n        }\n    }\n\n    public void SetBeltActive(bool active)\n    {\n        isActive = active;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, detectionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParticleEmitterController\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"emissionIntensity\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"particleColor\",\n      \"type\": \"color\",\n      \"default\": \"yellow\"\n    },\n    {\n      \"name\": \"emissionDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"trigger_particle_emission\",\n      \"trigger\": \"when another object enters collision area\",\n      \"actions\": [\n        {\n          \"action\": \"start particle system emission\"\n        },\n        {\n          \"action\": \"set particle color to predefined color\"\n        },\n        {\n          \"action\": \"play particle emission for specified duration\"\n        },\n        {\n          \"action\": \"stop particle emission after duration completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ParticleEmitterTrigger : MonoBehaviour\n{\n    [SerializeField] private ParticleSystem particleSystemPrefab;\n    [SerializeField] private bool emitOnlyOnce = false;\n    [SerializeField] private float particleLifetime = 2f;\n\n    private bool hasEmitted = false;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if we should emit particles\n        if (particleSystemPrefab != null && (!emitOnlyOnce || !hasEmitted))\n        {\n            // Instantiate particle system at trigger point\n            ParticleSystem particleInstance = Instantiate(\n                particleSystemPrefab, \n                transform.position, \n                Quaternion.identity\n            );\n\n            // Play the particle system\n            particleInstance.Play();\n\n            // Destroy particle system after its lifetime\n            Destroy(particleInstance.gameObject, particleLifetime);\n\n            // Mark as emitted if one-time emission is enabled\n            if (emitOnlyOnce)\n            {\n                hasEmitted = true;\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InvincibilityPowerUp\",\n  \"components\": [\n    \"Collider\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"invincibilityDuration\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"glowIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_invincibility\",\n      \"trigger\": \"when player collides with power-up\",\n      \"actions\": [\n        {\n          \"action\": \"make player temporarily immune to damage\"\n        },\n        {\n          \"action\": \"change player visual appearance to indicate invincibility\"\n        },\n        {\n          \"action\": \"start countdown timer for invincibility effect\"\n        },\n        {\n          \"action\": \"play sparkling visual effect\"\n        },\n        {\n          \"action\": \"play invincibility sound\"\n        },\n        {\n          \"action\": \"remove power-up from game world\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_invincibility\",\n      \"trigger\": \"when invincibility duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"restore player to normal damage state\"\n        },\n        {\n          \"action\": \"return player visual appearance to default\"\n        },\n        {\n          \"action\": \"stop sparkling visual effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class InvincibilityPowerUp : MonoBehaviour\n{\n    [SerializeField] private float invincibilityDuration = 5f;\n    [SerializeField] private Color invincibilityColor = Color.yellow;\n\n    private PlayerHealth playerHealth;\n    private SpriteRenderer playerSprite;\n    private float remainingInvincibilityTime;\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        // Check if player collides with power-up\n        playerHealth = collision.GetComponent<PlayerHealth>();\n        \n        if (playerHealth != null)\n        {\n            playerSprite = collision.GetComponent<SpriteRenderer>();\n            ActivateInvincibility();\n            Destroy(gameObject);\n        }\n    }\n\n    private void ActivateInvincibility()\n    {\n        // Grant temporary invincibility\n        playerHealth.SetInvincible(true);\n        \n        // Optional: Visual feedback\n        if (playerSprite != null)\n        {\n            StartCoroutine(FlashPlayerColor());\n        }\n    }\n\n    private System.Collections.IEnumerator FlashPlayerColor()\n    {\n        float elapsedTime = 0f;\n\n        while (elapsedTime < invincibilityDuration)\n        {\n            playerSprite.color = invincibilityColor;\n            yield return new WaitForSeconds(0.2f);\n            playerSprite.color = Color.white;\n            yield return new WaitForSeconds(0.2f);\n\n            elapsedTime += 0.4f;\n        }\n\n        playerHealth.SetInvincible(false);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CirclingEnemyDrone\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"circleRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"circleHeight\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"circleSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"patrol_circle\",\n      \"trigger\": \"when enemy is spawned or no player is nearby\",\n      \"actions\": [\n        {\n          \"action\": \"hover in circular pattern above spawn point\"\n        },\n        {\n          \"action\": \"rotate slowly while maintaining consistent altitude\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attack_approach\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"adjust circle path to gradually descend toward player\"\n        },\n        {\n          \"action\": \"increase rotation speed to appear more aggressive\"\n        },\n        {\n          \"action\": \"play warning sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"retreat\",\n      \"trigger\": \"when taking significant damage or player moves out of range\",\n      \"actions\": [\n        {\n          \"action\": \"rapidly ascend to original circle height\"\n        },\n        {\n          \"action\": \"resume passive circular patrol pattern\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FlyingEnemy : MonoBehaviour\n{\n    [SerializeField] private float circleRadius = 5f;\n    [SerializeField] private float circleSpeed = 2f;\n    [SerializeField] private float verticalOffset = 3f;\n    [SerializeField] private float verticalWaveAmplitude = 1f;\n    [SerializeField] private float verticalWaveFrequency = 1f;\n\n    private Vector3 centerPoint;\n    private float currentAngle = 0f;\n    private float timeOffset;\n\n    private void Start()\n    {\n        // Initialize center point at current position\n        centerPoint = transform.position;\n        \n        // Random offset for vertical wave to create more natural movement\n        timeOffset = Random.Range(0f, Mathf.PI * 2);\n    }\n\n    private void Update()\n    {\n        // Update circular movement\n        currentAngle += circleSpeed * Time.deltaTime;\n\n        // Calculate horizontal circular movement\n        float x = Mathf.Cos(currentAngle) * circleRadius;\n        float z = Mathf.Sin(currentAngle) * circleRadius;\n\n        // Add vertical wave motion\n        float verticalWave = Mathf.Sin((Time.time + timeOffset) * verticalWaveFrequency) * verticalWaveAmplitude;\n\n        // Update enemy position\n        transform.position = centerPoint + new Vector3(x, verticalOffset + verticalWave, z);\n\n        // Optional: Rotate to face movement direction\n        transform.rotation = Quaternion.LookRotation(new Vector3(x, 0, z));\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LootChest\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isOpened\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"lootTable\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"gold_coin\",\n        \"health_potion\",\n        \"rare_weapon\",\n        \"common_armor\"\n      ]\n    },\n    {\n      \"name\": \"maxLootItems\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"minLootItems\",\n      \"type\": \"int\",\n      \"default\": 1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_interaction\",\n      \"trigger\": \"when player approaches and presses interaction button\",\n      \"actions\": [\n        {\n          \"action\": \"play opening sound effect\"\n        },\n        {\n          \"action\": \"randomly select loot items from loot table\"\n        },\n        {\n          \"action\": \"spawn selected loot items near chest\"\n        },\n        {\n          \"action\": \"mark chest as already opened\"\n        },\n        {\n          \"action\": \"disable further interactions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"generate_random_loot\",\n      \"trigger\": \"during chest opening\",\n      \"actions\": [\n        {\n          \"action\": \"determine random number of loot items between minimum and maximum\"\n        },\n        {\n          \"action\": \"ensure no duplicate items are selected\"\n        },\n        {\n          \"action\": \"create loot items with randomized quality and quantity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class LootChest : MonoBehaviour\n{\n    [SerializeField] private List<GameObject> possibleLootItems;\n    [SerializeField] private int minItemDrops = 1;\n    [SerializeField] private int maxItemDrops = 3;\n    [SerializeField] private float dropRadius = 1f;\n\n    private bool hasBeenOpened = false;\n\n    [SerializeField] private AudioClip openChestSound;\n    [SerializeField] private ParticleSystem openEffectPrefab;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        if (!hasBeenOpened && other.CompareTag(\"Player\"))\n        {\n            OpenChest();\n        }\n    }\n\n    private void OpenChest()\n    {\n        hasBeenOpened = true;\n\n        // Play open sound\n        if (openChestSound != null)\n        {\n            AudioSource.PlayClipAtPoint(openChestSound, transform.position);\n        }\n\n        // Spawn particle effect\n        if (openEffectPrefab != null)\n        {\n            Instantiate(openEffectPrefab, transform.position, Quaternion.identity);\n        }\n\n        // Spawn random loot\n        int itemCount = Random.Range(minItemDrops, maxItemDrops + 1);\n\n        for (int i = 0; i < itemCount; i++)\n        {\n            if (possibleLootItems.Count > 0)\n            {\n                GameObject randomLootItem = possibleLootItems[Random.Range(0, possibleLootItems.Count)];\n                Vector3 randomOffset = Random.insideUnitSphere * dropRadius;\n                randomOffset.y = 0.5f; // Lift items slightly off ground\n\n                Instantiate(randomLootItem, transform.position + randomOffset, Quaternion.identity);\n            }\n        }\n\n        // Destroy or hide chest after looting\n        Destroy(gameObject);\n    }\n}"}]}
